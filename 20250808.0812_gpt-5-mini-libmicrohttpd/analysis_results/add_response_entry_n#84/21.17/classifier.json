{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified add_response_entry_n code that contains useful probe functions that print useful logs to a file \"/tmp/logs/679.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of add_response_entry_n as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of add_response_entry_n:\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function add_response_entry_n:\nbool\nMHD_add_response_entry_no_check_ (struct MHD_Response *response,\n                                  enum MHD_ValueKind kind,\n                                  const char *header,\n                                  size_t header_len,\n                                  const char *content,\n                                  size_t content_len)\n{\n  char *header_malloced;\n  char *value_malloced;\n\n  mhd_assert (0 != header_len);\n  mhd_assert (0 != content_len);\n  header_malloced = malloc (header_len + 1);\n  if (NULL == header_malloced)\n    return false;\n\n  memcpy (header_malloced, header, header_len);\n  header_malloced[header_len] = 0;\n\n  value_malloced = malloc (content_len + 1);\n  if (NULL != value_malloced)\n  {\n    memcpy (value_malloced, content, content_len);\n    value_malloced[content_len] = 0;\n\n    if (MHD_add_response_entry_no_alloc_ (response, kind,\n                                          header_malloced, header_len,\n                                          value_malloced, content_len))\n      return true; /* Success exit point */\n\n    free (value_malloced);\n  }\n  free (header_malloced);\n\n  return false; /* Failure exit point */\n}\n...\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_footer (struct MHD_Response *response,\n                         const char *footer,\n                         const char *content)\n{\n  return add_response_entry (response,\n                             MHD_FOOTER_KIND,\n                             footer,\n                             content);\n}\n</additional code>\nJudge whether the above add_response_entry_n code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Calling add_response_entry_n with header == NULL and header_len > 0 (or content == NULL and content_len > 0) leads to memchr being invoked with a NULL pointer and a non-zero length. That causes access beyond the bounds of the referenced object (NULL), violating MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/stat.h>\n\n/* Minimal forward declarations/types so this unit compiles. */\nstruct MHD_Response;\nenum MHD_ValueKind { MHD_HEADER_KIND = 0, MHD_FOOTER_KIND = 1 };\n\n/* Declaration of the real function (defined elsewhere in the project). */\nextern bool MHD_add_response_entry_no_check_ (struct MHD_Response *response,\n                                              enum MHD_ValueKind kind,\n                                              const char *header,\n                                              size_t header_len,\n                                              const char *content,\n                                              size_t content_len);\n\n/* Modified add_response_entry_n preserving original logic and adding\n   probes/logging to /tmp/logs/679.txt to record control path and state\n   that demonstrate the violation scenario. */\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  FILE *log = NULL;\n  /* Attempt to ensure log directory exists (best-effort). */\n  (void) mkdir(\"/tmp/logs\", 0777);\n  log = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"add_response_entry_n ENTRY: response=%p, kind=%d, header=%p, header_len=%zu, content=%p, content_len=%zu\\n\",\n            (void *)response, (int)kind, (void *)header, header_len, (void *)content, content_len);\n    fflush(log);\n  }\n\n  if (NULL == response)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: response == NULL\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (0 == header_len)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: header_len == 0\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (0 == content_len)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"early exit: content_len == 0\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  /* Record that we are about to call memchr on header. This is the\n     point where, if header == NULL while header_len > 0, memchr will\n     dereference the pointer and may access beyond the bounds -> violation. */\n  if (NULL != log)\n  {\n    fprintf(log, \"about to memchr on header: header=%p, header_len=%zu\\n\", (void *)header, header_len);\n    fflush(log);\n  }\n  if (NULL != memchr (header, '\\t', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\t'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, ' ', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains ' ' (space)\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, '\\r', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\r'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (header, '\\n', header_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: header contains '\\\\n'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  /* Record that we are about to call memchr on content. If content == NULL\n     while content_len > 0, memchr will dereference it and can access beyond\n     the bounds -> violation. */\n  if (NULL != log)\n  {\n    fprintf(log, \"about to memchr on content: content=%p, content_len=%zu\\n\", (void *)content, content_len);\n    fflush(log);\n  }\n  if (NULL != memchr (content, '\\r', content_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: content contains '\\\\r'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n  if (NULL != memchr (content, '\\n', content_len))\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"rejected: content contains '\\\\n'\\n\");\n      fclose(log);\n    }\n    return false;\n  }\n\n  if (NULL != log)\n  {\n    fprintf(log, \"calling MHD_add_response_entry_no_check_ with header=%p (len=%zu) content=%p (len=%zu)\\n\",\n            (void *)header, header_len, (void *)content, content_len);\n    fclose(log);\n  }\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n"
}