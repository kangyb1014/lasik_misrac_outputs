{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When response->data_iov is non-NULL, the code computes copy_size = response->data_iovcnt * sizeof(MHD_iovec_) and then does memcpy(dest, response->data_iov, copy_size) without verifying that the source buffer actually contains at least response->data_iovcnt elements. If response->data_iovcnt is larger than the actual number of elements (e.g. due to a bug, corrupted metadata, or maliciously crafted value), memcpy can read beyond the bounds of the object pointed to by response->data_iov, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct RPProps { int send_reply_body; };\ntypedef enum {\n  MHD_resp_sender_default = 0,\n  MHD_resp_sender_sendfile = 1\n} MHD_resp_sender_t;\nstruct RespIov {\n  MHD_iovec_ *iov;\n  unsigned cnt;\n  size_t sent;\n};\nstruct MHD_RP {\n  struct MHD_Response *response;\n  struct RPProps props;\n  size_t rsp_write_position;\n  struct RespIov resp_iov;\n  MHD_resp_sender_t resp_sender;\n};\nstatic void\nMHD_mutex_unlock_chk_ (int *UNUSED_mutex)\n{\n  (void) UNUSED_mutex;\n  /* No-op in this minimal context */\n}\nstatic void\nCONNECTION_CLOSE_ERROR (struct MHD_Connection *UNUSED_conn, const char *msg)\n{\n  (void) UNUSED_conn;\n  /* In real implementation this would log/close; keep minimal here. */\n  (void) msg;\n}\nstatic void\nmhd_assert (int UNUSED_cond)\n{\n  (void) UNUSED_cond; /* no-op */\n}\n\nstatic void *\nMHD_connection_alloc_memory_ (struct MHD_Connection *UNUSED_CONN, size_t size)\n{\n  (void) UNUSED_CONN;\n  return malloc(size);\n}\nstatic void\nMHD_connection_close_ (struct MHD_Connection *UNUSED_conn, int UNUSED_reason)\n{\n  (void) UNUSED_conn;\n  (void) UNUSED_reason;\n}\nstatic MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  FILE *log = fopen(\"/tmp/logs/711.txt\", \"a\");\n\n  if (NULL != log)\n  {\n    fprintf(log, \"enter try_ready_normal_body: connection=%p\\n\", (void *) connection);\n  }\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"0-byte response or already at total_size -> ready\\n\");\n      fclose(log);\n    }\n    return MHD_YES;  /* 0-byte response is always ready */\n  }\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n    {\n      if (NULL != log)\n      {\n        fprintf(log, \"resp_iov already set -> ready\\n\");\n        fclose(log);\n      }\n      return MHD_YES;\n    }\n    copy_size = (size_t) response->data_iovcnt * sizeof(MHD_iovec_);\n    if (NULL != log)\n    {\n      fprintf(log, \"data_iov=%p data_iovcnt=%u sizeof(MHD_iovec_)=%zu copy_size=%zu\\n\",\n              (void *) response->data_iov,\n              (unsigned) response->data_iovcnt,\n              sizeof(MHD_iovec_),\n              copy_size);\n    }\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      if (NULL != log)\n      {\n        fprintf(log, \"allocation failed for size=%zu\\n\", copy_size);\n      }\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              \"Closing connection (out of memory).\");\n      if (NULL != log)\n        fclose(log);\n      return MHD_NO;\n    }\n    if (NULL != log)\n    {\n      fprintf(log, \"allocated resp_iov.iov=%p, about to memcpy from %p size=%zu\\n\",\n              (void *) connection->rp.resp_iov.iov,\n              (void *) response->data_iov,\n              copy_size);\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    if (NULL != log)\n    {\n      fprintf(log, \"memcpy done\\n\");\n    }\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    if (NULL != log)\n      fclose(log);\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"no crc -> ready\\n\");\n      fclose(log);\n    }\n    return MHD_YES;\n  }\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n  {\n    if (NULL != log)\n    {\n      fprintf(log, \"response already ready -> ready\\n\");\n      fclose(log);\n    }\n    return MHD_YES; /* response already ready */\n  }\n\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    if (NULL != log)\n    {\n      fprintf(log, \"sendfile path -> ready\\n\");\n      fclose(log);\n    }\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  /* Replace MHD_MIN macro with inline conditional expression */\n  {\n    uint64_t avail = (uint64_t) response->data_buffer_size;\n    uint64_t remain = response->total_size > connection->rp.rsp_write_position\n                      ? (response->total_size - connection->rp.rsp_write_position)\n                      : 0;\n    size_t to_check = (size_t) (avail < remain ? avail : remain);\n\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         (char *) response->data,\n                         to_check);\n  }\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              \"Closing connection (application reported \"\n                              \"error generating data).\");\n    if (NULL != log)\n      fclose(log);\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (NULL != log)\n      fclose(log);\n    return MHD_NO;\n  }\n  if (NULL != log)\n    fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In try_ready_normal_body the memcpy call copies response->data_iovcnt * sizeof(MHD_iovec_) bytes from response->data_iov without any local check that the object pointed to by response->data_iov actually contains at least response->data_iovcnt elements. Per MISRA C 2023 Rule 21.17, calls to memcpy must not result in accesses beyond the bounds of the source or destination objects. Unless there exists a provable program-wide invariant (established and verifiable outside this function) that response->data_iov and response->data_iovcnt are always consistent and the allocated/source buffer is large enough, this use is potentially out-of-bounds and therefore violates the rule. The provided test snippet failing to compile does not invalidate the logical issue in the original code. Recommendation: either validate the count/size before memcpy, or ensure and document (and verify) the invariant that guarantees the source buffer length >= response->data_iovcnt * sizeof(MHD_iovec_)."
}