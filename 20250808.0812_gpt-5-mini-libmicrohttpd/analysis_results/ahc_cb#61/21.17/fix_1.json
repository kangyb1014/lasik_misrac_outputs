{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nextern const char MHD_HTTP_METHOD_GET[];\nextern const char MHD_HTTP_VERSION_1_1[];\nextern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY[];\nextern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION[];\nextern const char WS_SEC_WEBSOCKET_VERSION[];\nextern enum MHD_Result MHD_lookup_connection_value_n (struct MHD_Connection *, int, const char *, size_t, const char **, size_t *);\nextern const char *MHD_lookup_connection_value (struct MHD_Connection *, int, const char *);\nextern struct MHD_Response *MHD_create_response_for_upgrade (const void *, void *);\nextern enum MHD_Result MHD_add_response_header (struct MHD_Response *, const char *, const char *);\nextern void MHD_destroy_response (struct MHD_Response *);\nextern enum MHD_Result MHD_queue_response (struct MHD_Connection *, int, struct MHD_Response *);\nstatic void\nlog_probe (const char *stage, const char *ws_key_header, size_t key_size)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  size_t i;\n  if (NULL == f)\n    return;\n  fprintf (f, \"[ahc_cb] stage=%s\\n\", stage);\n  fprintf (f, \"[ahc_cb] ws_key_header_ptr=%p key_size=%zu\\n\",\n           (const void *) ws_key_header, key_size);\n  if ((NULL != ws_key_header) && (key_size > 0))\n  {\n    /* Dump up to key_size bytes in hex. Use key_size (returned separately) to avoid relying on NUL-termination. */\n    fprintf (f, \"[ahc_cb] ws_key_header_bytes=\");\n    for (i = 0; i < key_size; ++i)\n      fprintf (f, \"%02x\", (unsigned char) ws_key_header[i]);\n    fprintf (f, \"\\n\");\n  }\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"enter\", NULL, 0);\n\n  if (NULL == *req_cls)\n  {\n    log_probe (\"first_request\", NULL, 0);\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, 0, \"Upgrade\");\n  con_header = MHD_lookup_connection_value (con, 0, \"Connection\");\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws_request\", NULL, 0);\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, 0);\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, 0,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_or_missing_ws_version\", NULL, 0);\n    return send_upgrade_required (con);\n  }\n\n  /* Lookup Sec-WebSocket-Key and obtain its size. */\n  ret = MHD_lookup_connection_value_n (con, 0,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  log_probe (\"after_lookup_key\", ws_key_header, key_size);\n\n  if ((MHD_NO == ret) || (key_size != 24))\n  {\n    log_probe (\"invalid_key_size\", ws_key_header, key_size);\n    return send_bad_request (con);\n  }\n\n  /* Log just before calling ws_get_accept_value to capture the state that\n     leads to the string handling calls inside that function. */\n  log_probe (\"before_ws_get_accept_value\", ws_key_header, key_size);\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  log_probe (\"after_ws_get_accept_value\", ws_key_header, key_size);\n\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Sec-WebSocket-Accept\", ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Upgrade\", \"websocket\"))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, 101, res);\n  MHD_destroy_response (res);\n  log_probe (\"exit\", NULL, 0);\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from websocket_threaded_example.c:43:\n../../src/include/microhttpd.h:1105:34: error: expected identifier or '(' before string constant\n 1105 | #define MHD_HTTP_METHOD_GET      \"GET\"\n      |                                  ^~~~~\nwebsocket_threaded_example.c:849:19: note: in expansion of macro 'MHD_HTTP_METHOD_GET'\n  849 | extern const char MHD_HTTP_METHOD_GET[];\n      |                   ^~~~~~~~~~~~~~~~~~~\n../../src/include/microhttpd.h:1091:30: error: expected identifier or '(' before string constant\n 1091 | #define MHD_HTTP_VERSION_1_1 \"HTTP/1.1\"\n      |                              ^~~~~~~~~~\nwebsocket_threaded_example.c:850:19: note: in expansion of macro 'MHD_HTTP_VERSION_1_1'\n  850 | extern const char MHD_HTTP_VERSION_1_1[];\n      |                   ^~~~~~~~~~~~~~~~~~~~\n../../src/include/microhttpd.h:876:43: error: expected identifier or '(' before string constant\n  876 | #define MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY \"Sec-WebSocket-Key\"\n      |                                           ^~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:851:19: note: in expansion of macro 'MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY'\n  851 | extern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY[];\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n../../src/include/microhttpd.h:880:47: error: expected identifier or '(' before string constant\n  880 | #define MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION \"Sec-WebSocket-Version\"\n      |                                               ^~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:852:19: note: in expansion of macro 'MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION'\n  852 | extern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION[];\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:104:34: error: expected identifier or '(' before string constant\n  104 | #define WS_SEC_WEBSOCKET_VERSION \"13\"\n      |                                  ^~~~\nwebsocket_threaded_example.c:853:19: note: in expansion of macro 'WS_SEC_WEBSOCKET_VERSION'\n  853 | extern const char WS_SEC_WEBSOCKET_VERSION[];\n      |                   ^~~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:854:24: error: conflicting types for 'MHD_lookup_connection_value_n'; have 'enum MHD_Result(struct MHD_Connection *, int,  const char *, size_t,  const char **, size_t *)' {aka 'enum MHD_Result(struct MHD_Connection *, int,  const char *, long unsigned int,  const char **, long unsigned int *)'}\n  854 | extern enum MHD_Result MHD_lookup_connection_value_n (struct MHD_Connection *, int, const char *, size_t, const char **, size_t *);\n      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from websocket_threaded_example.c:43:\n../../src/include/microhttpd.h:3692:1: note: previous declaration of 'MHD_lookup_connection_value_n' with type 'enum MHD_Result(struct MHD_Connection *, enum MHD_ValueKind,  const char *, size_t,  const char **, size_t *)' {aka 'enum MHD_Result(struct MHD_Connection *, enum MHD_ValueKind,  const char *, long unsigned int,  const char **, long unsigned int *)'}\n 3692 | MHD_lookup_connection_value_n (struct MHD_Connection *connection,\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:855:20: error: conflicting types for 'MHD_lookup_connection_value'; have 'const char *(struct MHD_Connection *, int,  const char *)'\n  855 | extern const char *MHD_lookup_connection_value (struct MHD_Connection *, int, const char *);\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from websocket_threaded_example.c:43:\n../../src/include/microhttpd.h:3667:1: note: previous declaration of 'MHD_lookup_connection_value' with type 'const char *(struct MHD_Connection *, enum MHD_ValueKind,  const char *)'\n 3667 | MHD_lookup_connection_value (struct MHD_Connection *connection,\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:856:29: error: conflicting types for 'MHD_create_response_for_upgrade'; have 'struct MHD_Response *(const void *, void *)'\n  856 | extern struct MHD_Response *MHD_create_response_for_upgrade (const void *, void *);\n      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from websocket_threaded_example.c:43:\n../../src/include/microhttpd.h:4473:1: note: previous declaration of 'MHD_create_response_for_upgrade' with type 'struct MHD_Response *(void (*)(void *, struct MHD_Connection *, void *, const char *, size_t,  MHD_socket,  struct MHD_UpgradeResponseHandle *), void *)' {aka 'struct MHD_Response *(void (*)(void *, struct MHD_Connection *, void *, const char *, long unsigned int,  int,  struct MHD_UpgradeResponseHandle *), void *)'}\n 4473 | MHD_create_response_for_upgrade (MHD_UpgradeHandler upgrade_handler,\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nwebsocket_threaded_example.c:859:24: error: conflicting types for 'MHD_queue_response'; have 'enum MHD_Result(struct MHD_Connection *, int,  struct MHD_Response *)'\n  859 | extern enum MHD_Result MHD_queue_response (struct MHD_Connection *, int, struct MHD_Response *);\n      |                        ^~~~~~~~~~~~~~~~~~\nIn file included from websocket_threaded_example.c:43:\n../../src/include/microhttpd.h:3746:1: note: previous declaration of 'MHD_queue_response' with type 'enum MHD_Result(struct MHD_Connection *, unsigned int,  struct MHD_Response *)'\n 3746 | MHD_queue_response (struct MHD_Connection *connection,\n      | ^~~~~~~~~~~~~~~~~~\nmake[4]: *** [Makefile:1208: websocket_threaded_example-websocket_threaded_example.o] Error 1\nmake[3]: *** [Makefile:1234: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_cb as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <microhttpd.h>\n\n/* Forward declarations for functions defined elsewhere in the project. */\nextern enum MHD_Result is_websocket_request(struct MHD_Connection *, const char *, const char *);\nextern enum MHD_Result send_chat_page(struct MHD_Connection *);\nextern enum MHD_Result send_bad_request(struct MHD_Connection *);\nextern enum MHD_Result send_upgrade_required(struct MHD_Connection *);\nextern enum MHD_Result ws_get_accept_value(const char *, char **);\n/* Forward declaration for the upgrade callback; matches MHD_UpgradeHandler signature. */\nextern void uh_cb(void *cls, struct MHD_Connection *connection, void *con_cls,\n                  const char *upload_data, size_t upload_data_size,\n                  MHD_socket socket, struct MHD_UpgradeResponseHandle *handle);\n\nstatic void\nlog_probe (const char *stage, const char *ws_key_header, size_t key_size)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  size_t i;\n  if (NULL == f)\n    return;\n  fprintf (f, \"[ahc_cb] stage=%s\\n\", stage);\n  fprintf (f, \"[ahc_cb] ws_key_header_ptr=%p key_size=%zu\\n\",\n           (const void *) ws_key_header, key_size);\n  if ((NULL != ws_key_header) && (key_size > 0))\n  {\n    /* Dump up to key_size bytes in hex. Use key_size (returned separately) to avoid relying on NUL-termination. */\n    fprintf (f, \"[ahc_cb] ws_key_header_bytes=\");\n    for (i = 0; i < key_size; ++i)\n      fprintf (f, \"%02x\", (unsigned char) ws_key_header[i]);\n    fprintf (f, \"\\n\");\n  }\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"enter\", NULL, 0);\n\n  if (NULL == *req_cls)\n  {\n    log_probe (\"first_request\", NULL, 0);\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND, \"Upgrade\");\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND, \"Connection\");\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws_request\", NULL, 0);\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, 0);\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_or_missing_ws_version\", NULL, 0);\n    return send_upgrade_required (con);\n  }\n\n  /* Lookup Sec-WebSocket-Key and obtain its size. */\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  log_probe (\"after_lookup_key\", ws_key_header, key_size);\n\n  if ((MHD_NO == ret) || (key_size != 24))\n  {\n    log_probe (\"invalid_key_size\", ws_key_header, key_size);\n    return send_bad_request (con);\n  }\n\n  /* Log just before calling ws_get_accept_value to capture the state that\n     leads to the string handling calls inside that function. */\n  log_probe (\"before_ws_get_accept_value\", ws_key_header, key_size);\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  log_probe (\"after_ws_get_accept_value\", ws_key_header, key_size);\n\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Sec-WebSocket-Accept\", ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Upgrade\", \"websocket\"))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, 101, res);\n  MHD_destroy_response (res);\n  log_probe (\"exit\", NULL, 0);\n  return ret;\n}\n",
  "explanation": "I removed the conflicting local extern declarations that duplicated symbols/macros defined in microhttpd.h and instead included <microhttpd.h> so the correct definitions are used. I added standard headers and forward declarations for the helper functions used by ahc_cb (is_websocket_request, send_chat_page, send_bad_request, send_upgrade_required, ws_get_accept_value) and a forward declaration for uh_cb matching the MHD_UpgradeHandler signature. I also adjusted calls to MHD_lookup_connection_value and MHD_lookup_connection_value_n to use MHD_HEADER_KIND for the value-kind parameter (so they match the header API) and otherwise preserved the original ahc_cb logic and logging."
}