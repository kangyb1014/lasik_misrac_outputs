{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified ahc_cb code that contains useful probe functions that print useful logs to a file \"/tmp/logs/495.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_cb as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of ahc_cb:\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_cb:\n_MHD_EXTERN const char *\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)\n{\n  const char *value;\n\n  value = NULL;\n  (void) MHD_lookup_connection_value_n (connection,\n                                        kind,\n                                        key,\n                                        (NULL == key) ? 0 : strlen (key),\n                                        &value,\n                                        NULL);\n  return value;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n...\n#define MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY \"Sec-WebSocket-Key\"\n...\n#define WS_KEY_LEN 24\n...\n#define MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION \"Sec-WebSocket-Version\"\n...\n#define WS_SEC_WEBSOCKET_VERSION \"13\"\n...\n#define MHD_HTTP_METHOD_GET \"GET\"\n...\n#define MHD_HTTP_VERSION_1_1 \"HTTP/1.1\"\n</additional code>\nJudge whether the above ahc_cb code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "Violation occurs in ws_get_accept_value: the function uses strlen(key) and then calls strncpy(str, key, WS_KEY_LEN + 1). If the header value (key) is not NUL-terminated (pos->value is returned with value_size == WS_KEY_LEN), strlen(key) will read past the buffer and strncpy will copy WS_KEY_LEN+1 bytes, causing a one-byte out-of-bounds read. Thus use of string.h functions can access beyond object bounds.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal forward declarations to allow compilation in isolation. */\nstruct MHD_Connection;\nstruct MHD_Response;\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nextern const char MHD_HTTP_METHOD_GET[];\nextern const char MHD_HTTP_VERSION_1_1[];\nextern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY[];\nextern const char MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION[];\nextern const char WS_SEC_WEBSOCKET_VERSION[];\n\nextern enum MHD_Result MHD_lookup_connection_value_n (struct MHD_Connection *, int, const char *, size_t, const char **, size_t *);\nextern const char *MHD_lookup_connection_value (struct MHD_Connection *, int, const char *);\nextern enum MHD_Result is_websocket_request (struct MHD_Connection *, const char *, const char *);\nextern enum MHD_Result send_chat_page (struct MHD_Connection *);\nextern enum MHD_Result send_bad_request (struct MHD_Connection *);\nextern enum MHD_Result send_upgrade_required (struct MHD_Connection *);\nextern enum MHD_Result ws_get_accept_value (const char *, char **);\nextern struct MHD_Response *MHD_create_response_for_upgrade (const void *, void *);\nextern enum MHD_Result MHD_add_response_header (struct MHD_Response *, const char *, const char *);\nextern void MHD_destroy_response (struct MHD_Response *);\nextern enum MHD_Result MHD_queue_response (struct MHD_Connection *, int, struct MHD_Response *);\n\nextern const int uh_cb; /* opaque, only its address is passed */\n\n/* Helper probe: log control path and state to /tmp/logs/495.txt */\nstatic void\nlog_probe (const char *stage, const char *ws_key_header, size_t key_size)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  size_t i;\n  if (NULL == f)\n    return;\n  fprintf (f, \"[ahc_cb] stage=%s\\n\", stage);\n  fprintf (f, \"[ahc_cb] ws_key_header_ptr=%p key_size=%zu\\n\",\n           (const void *) ws_key_header, key_size);\n  if ((NULL != ws_key_header) && (key_size > 0))\n  {\n    /* Dump up to key_size bytes in hex. Use key_size (returned separately) to avoid relying on NUL-termination. */\n    fprintf (f, \"[ahc_cb] ws_key_header_bytes=\");\n    for (i = 0; i < key_size; ++i)\n      fprintf (f, \"%02x\", (unsigned char) ws_key_header[i]);\n    fprintf (f, \"\\n\");\n  }\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"enter\", NULL, 0);\n\n  if (NULL == *req_cls)\n  {\n    log_probe (\"first_request\", NULL, 0);\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, 0, \"Upgrade\");\n  con_header = MHD_lookup_connection_value (con, 0, \"Connection\");\n\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws_request\", NULL, 0);\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, 0);\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, 0,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_or_missing_ws_version\", NULL, 0);\n    return send_upgrade_required (con);\n  }\n\n  /* Lookup Sec-WebSocket-Key and obtain its size. */\n  ret = MHD_lookup_connection_value_n (con, 0,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  log_probe (\"after_lookup_key\", ws_key_header, key_size);\n\n  if ((MHD_NO == ret) || (key_size != 24))\n  {\n    log_probe (\"invalid_key_size\", ws_key_header, key_size);\n    return send_bad_request (con);\n  }\n\n  /* Log just before calling ws_get_accept_value to capture the state that\n     leads to the string handling calls inside that function. */\n  log_probe (\"before_ws_get_accept_value\", ws_key_header, key_size);\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  log_probe (\"after_ws_get_accept_value\", ws_key_header, key_size);\n\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Sec-WebSocket-Accept\", ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, \"Upgrade\", \"websocket\"))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, 101, res);\n  MHD_destroy_response (res);\n  log_probe (\"exit\", NULL, 0);\n  return ret;\n}\n"
}