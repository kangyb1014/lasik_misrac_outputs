{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop count and optionally loop flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with essentially Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:BASE64Encode contains a for loop where the loop counter 'i' is modified inside the loop body (multiple ++i and ++i in branches). This violates MISRA C 2023 Rule 14.2: the loop counter shall not be modified in the loop body and the third clause shall only modify the loop counter.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection { const char *dummy; };\nstruct MHD_Response { int dummy; };\nstatic const char *MHD_HTTP_HEADER_UPGRADE = \"Upgrade\";\nstatic const char *MHD_HTTP_HEADER_CONNECTION = \"Connection\";\nstatic const char *MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION = \"Sec-WebSocket-Version\";\nstatic const char *MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\nstatic const char *MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT = \"Sec-WebSocket-Accept\";\nstatic const char *MHD_HTTP_HEADER_UPGRADE_VALUE = \"Upgrade\";\nstatic const char *MHD_HTTP_METHOD_GET = \"GET\";\nstatic const char *MHD_HTTP_VERSION_1_1 = \"HTTP/1.1\";\nstatic const char *WS_SEC_WEBSOCKET_VERSION = \"13\";\nstatic const size_t WS_KEY_LEN = 24;\nstatic const char *WS_UPGRADE_VALUE = \"websocket\";\nstatic const char *\nMHD_lookup_connection_value (struct MHD_Connection *con, int kind, const char *name)\n{\n  (void) con; (void) kind;\n  /* For compilation/testing purposes, return NULL for most headers so\n     ahc_cb's checks behave predictably. */\n  (void) name;\n  return NULL;\n}\nstatic enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *con, int kind,\n                               const char *name, size_t name_len,\n                               const char **valuep, size_t *value_len)\n{\n  (void) con; (void) kind; (void) name_len;\n  if (0 == strcmp (name, MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY))\n  {\n    /* Provide a dummy key of the expected length so the main code path can proceed. */\n    static const char dummy_key[WS_KEY_LEN + 1] = \"ABCDEFGHIJKLMNOPQRSTUVWX\"; /* 24 chars */\n    *valuep = dummy_key;\n    *value_len = WS_KEY_LEN;\n    return MHD_YES;\n  }\n  *valuep = NULL;\n  *value_len = 0;\n  return MHD_NO;\n}\nstatic struct MHD_Response *\nMHD_create_response_for_upgrade (void *cb, void *cls)\n{\n  (void) cb; (void) cls;\n  struct MHD_Response *r = malloc (sizeof (*r));\n  if (r) r->dummy = 0;\n  return r;\n}\nstatic enum MHD_Result\nMHD_add_response_header (struct MHD_Response *res, const char *name, const char *value)\n{\n  (void) res; (void) name; (void) value;\n  return MHD_YES;\n}\nstatic void\nMHD_destroy_response (struct MHD_Response *res)\n{\n  free (res);\n}\nstatic enum MHD_Result\nMHD_queue_response (struct MHD_Connection *con, int status_code, struct MHD_Response *res)\n{\n  (void) con; (void) status_code; (void) res;\n  return MHD_YES;\n}\nstatic void probe_log(const char *tag, size_t idx, size_t len)\n{\n  FILE *f = fopen(\"/tmp/logs/492.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s: idx=%zu len=%zu\\n\", tag, idx, len);\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg, const char *con_hdr)\n{\n  (void) con;\n  /* If both headers are non-NULL and match expected values, treat as websocket. */\n  if (upg && con_hdr && 0 == strcasecmp (upg, WS_UPGRADE_VALUE) && 0 == strcasecmp (con_hdr, \"Upgrade\"))\n    return MHD_YES;\n  /* Default: say it's a websocket request so the AH handler goes through the websocket flow. */\n  return MHD_YES;\n}\nstatic enum MHD_Result send_chat_page (struct MHD_Connection *con)\n{\n  (void) con;\n  return MHD_NO;\n}\nstatic enum MHD_Result send_bad_request (struct MHD_Connection *con)\n{\n  (void) con;\n  return MHD_NO;\n}\nstatic enum MHD_Result send_upgrade_required (struct MHD_Connection *con)\n{\n  (void) con;\n  return MHD_NO;\n}\nstatic enum MHD_Result ws_get_accept_value (const char *key, char **output)\n{\n  if (NULL == key || NULL == output)\n    return MHD_NO;\n  /* For demonstration purposes allocate a small accept value. */\n  *output = strdup (\"dummy-accept-value\");\n  if (NULL == *output) return MHD_NO;\n  return MHD_YES;\n}\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  probe_log(\"ahc_cb:start\", 0u, 0u);\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    probe_log(\"ahc_cb:req_cls_set\", 0u, 0u);\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, 0, MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, 0, MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    probe_log(\"ahc_cb:not_ws\", 0u, 0u);\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    probe_log(\"ahc_cb:bad_method_or_version\", 0u, 0u);\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, 0, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    probe_log(\"ahc_cb:bad_ws_version\", 0u, 0u);\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, 0,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    probe_log(\"ahc_cb:no_key_or_bad_size\", (size_t) key_size, WS_KEY_LEN);\n    return send_bad_request (con);\n  }\n\n  /* probe before calling the accept-value generation that calls BASE64Encode */\n  probe_log(\"ahc_cb:before_ws_get_accept_value\", 0u, 0u);\n\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    probe_log(\"ahc_cb:ws_get_accept_value_failed\", 0u, 0u);\n    return ret;\n  }\n  static void *uh_cb = NULL;\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    probe_log(\"ahc_cb:add_header_accept_failed\", 0u, 0u);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    probe_log(\"ahc_cb:add_header_upgrade_failed\", 0u, 0u);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, 101 /* Switching Protocols */, res);\n  MHD_destroy_response (res);\n  probe_log(\"ahc_cb:done\", (size_t) ret, 0u);\n  return ret;\n}\nstatic ssize_t\nBASE64Encode (const void *in, size_t len, char **output)\n{\n  const char *cvt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    \"abcdefghijklmnopqrstuvwxyz\"\n                    \"0123456789+/\";\n  const char *data = (const char *) in;\n  char *opt;\n  ssize_t ret;\n  size_t i;\n  char c;\n\n  ret = 0;\n\n  opt = malloc (2 + (len * 4 / 3) + 8);\n  if (NULL == opt)\n  {\n    probe_log(\"BASE64Encode:malloc_failed\", 0u, len);\n    return -1;\n  }\n  for (i = 0; i < len; ++i)\n  {\n    probe_log(\"BASE64Encode:loop_entry\", i, len);\n    c = (data[i] >> 2) & 0x3F;\n    opt[ret++] = cvt[(int) c];\n    c = (data[i] << 4) & 0x3F;\n    if (++i < len)\n    {\n      /* Here the loop counter 'i' is incremented inside the loop body. */\n      probe_log(\"BASE64Encode:branch_inc1\", i, len);\n      c = (char) (c | ((data[i] >> 4) & 0x0F));\n    }\n    opt[ret++] = cvt[(int) c];\n    if (i < len)\n    {\n      c = (char) (c | ((data[i] << 2) & 0x3F));\n      if (++i < len)\n      {\n        /* Another modification of loop counter inside the body. */\n        probe_log(\"BASE64Encode:branch_inc2\", i, len);\n        c = (char) (c | ((data[i] >> 6) & 0x03));\n      }\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      ++i; /* and here */\n      probe_log(\"BASE64Encode:branch_inc3_else\", i, len);\n      opt[ret++] = '='; /* FILLCHAR */\n    }\n    if (i < len)\n    {\n      c = data[i] & 0x3F;\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      opt[ret++] = '='; /* FILLCHAR */\n    }\n    probe_log(\"BASE64Encode:loop_exit\", i, len);\n  }\n  *output = opt;\n  probe_log(\"BASE64Encode:finished\", (size_t) ret, len);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 14.2 requires that a for loop have a single loop counter that is initialized in the first clause, is the only object modified by the third clause, and is not modified in the body of the loop. In the provided BASE64Encode implementation the loop is declared as for (i = 0; i < len; ++i) but the body contains multiple modifications of the same loop counter (if (++i < len) { ... }, if (++i < len) { ... }, and ++i in the else). Those in-body increments modify the loop counter and therefore violate Rule 14.2 (clauses 3 and 4). Note: the original ahc_cb snippet shown earlier did not include BASE64Encode, but in the supplied test code the BASE64Encode function is present and exhibits the violation; if that function is part of the codebase the reported violation is valid."
}