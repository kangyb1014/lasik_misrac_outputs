{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The violation occurs in add_response_header_connection where memcmp is used to compare an HTTP header value to the literal \"close\": mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); hdr->value is a null-terminated header string. Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstatic const char *const MHD_HEADER_KIND = \"header\";\nstatic const char *const MHD_HTTP_HEADER_UPGRADE = \"Upgrade\";\nstatic const char *const MHD_HTTP_HEADER_CONNECTION = \"Connection\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION = \"Sec-WebSocket-Version\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\nstatic const char *const MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT = \"Sec-WebSocket-Accept\";\nstatic const char *const MHD_HTTP_METHOD_GET = \"GET\";\nstatic const char *const MHD_HTTP_VERSION_1_1 = \"HTTP/1.1\";\nstatic const char *const WS_SEC_WEBSOCKET_VERSION = \"13\";\nstatic const size_t WS_KEY_LEN = 24;\nstatic const char *const WS_UPGRADE_VALUE = \"websocket\";\nstatic const int MHD_HTTP_SWITCHING_PROTOCOLS = 101;\nextern const char *MHD_lookup_connection_value(struct MHD_Connection *con,\n                                               const char *kind,\n                                               const char *key);\nextern enum MHD_Result MHD_lookup_connection_value_n(struct MHD_Connection *con,\n                                                     const char *kind,\n                                                     const char *key,\n                                                     size_t key_len,\n                                                     const char **value_p,\n                                                     size_t *value_len);\nextern struct MHD_Response *MHD_create_response_for_upgrade(void (*upgrade_cb)(void),\\n                                                            void *cls);\nextern enum MHD_Result MHD_add_response_header(struct MHD_Response *res,\n                                               const char *name,\n                                               const char *value);\nextern void MHD_destroy_response(struct MHD_Response *res);\nextern enum MHD_Result MHD_queue_response(struct MHD_Connection *con,\n                                          int status_code,\n                                          struct MHD_Response *res);\nstatic void\nlog_probe (const char *stage, const void *res_ptr, const char *note)\n{\n  FILE *f = fopen (\"/tmp/logs/494.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"stage: %s\\n\", stage);\n  fprintf (f, \"res_ptr: %p\\n\", res_ptr);\n  if (note != NULL)\n    fprintf (f, \"note: %s\\n\", note);\n  fprintf (f, \"----\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  log_probe (\"entry\", NULL, \"ahc_cb entered\");\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    log_probe (\"first_req\", NULL, \"initial request class set\");\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    log_probe (\"not_ws\", NULL, \"not a websocket request, sending chat page\");\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    log_probe (\"bad_method_or_version\", NULL, \"bad method or version\");\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    log_probe (\"bad_ws_version\", NULL, \"missing or unsupported websocket version\");\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    log_probe (\"bad_key\", NULL, \"missing or wrong size websocket key\");\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    log_probe (\"ws_get_accept_failed\", NULL, \"ws_get_accept_value failed\");\n    return ret;\n  }\n\n  /* Create the upgrade response as in original logic */\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  log_probe (\"created_response\", res, \"response created for upgrade\");\n\n  /*\n   * Probe scenario that exercises the code path where memcmp is used to\n   * compare a null-terminated header value to the literal \"close\".\n   * We add the \"Connection: close\" header first and then add another\n   * connection header value to force the update path where the existing\n   * header entry is inspected (this triggers the mhd_assert that contains\n   * the memcmp in add_response_header_connection).\n   *\n   * These extra calls are probes only and intended to record the control\n   * flow and state. They preserve the rest of ahc_cb logic as much as\n   * possible.\n   */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"close\");\n  log_probe (\"after_add_connection_close\", res, \"added Connection: close\");\n\n  /* Second addition triggers the update branch in add_response_header_connection */\n  (void) MHD_add_response_header (res, MHD_HTTP_HEADER_CONNECTION, \"keep-alive\");\n  log_probe (\"after_add_connection_keepalive\", res, \"added Connection: keep-alive to trigger update path\");\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    log_probe (\"add_accept_failed\", res, \"failed to add Sec-WebSocket-Accept header\");\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    log_probe (\"add_upgrade_failed\", res, \"failed to add Upgrade header\");\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  log_probe (\"queued_response\", res, (ret == MHD_YES) ? \"queued ok\" : \"queue failed\");\n  MHD_destroy_response (res);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings (you must use the string comparison functions instead). The ahc_cb implementation you provided does not call memcmp: it uses strcmp and library calls such as MHD_add_response_header / MHD_lookup_connection_value. The agent A\u2019s scenario alleges a memcmp in add_response_header_connection (mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));). That snippet is not present in the ahc_cb source you gave, so ahc_cb itself does not violate Rule 21.14.\n\nIf the asserted memcmp actually exists inside the Microhttpd library (in add_response_header_connection) and it compares a null\u2011terminated header string to a literal via memcmp, then that library code would indeed violate MISRA C 2023 Rule 21.14. However, based on the supplied ahc_cb code and the failing test build (no evidence produced), there is no proof in the materials you provided that ahc_cb violates the rule. Therefore the report that ahc_cb itself violates Rule 21.14 is not correct."
}