{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The final 'else' branch (mhd_assert(0); uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;) is effectively unreachable in the project: get_rq_uname is static and all callers only invoke it after checking that uname_type is neither MISSING nor INVALID, so only STANDARD, USERHASH or EXTENDED values reach this function. Consequently the default 'else' path cannot be executed in normal project use and is unreachable code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct simple_val {\n  char *str;\n  size_t len;\n};\nstruct MHD_RqDAuth {\n  struct simple_val username;      /* params->username.value.str in original */\n  struct simple_val username_ext;  /* params->username_ext.value.str/len */\n  int userhash;                    /* truthy if username is a userhash */\n};\nstatic void mhd_assert(int cond)\n{\n  if (!cond)\n    abort();\n}\n\nstatic enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  if (params == NULL)\n    return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  if (params->username_ext.str != NULL && params->username_ext.len > 0)\n    return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n  if (params->userhash)\n    return MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n  if (params->username.str != NULL)\n    return MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct simple_val *p, char *dest)\n{\n  if (p == NULL || p->str == NULL || dest == NULL)\n    return 0;\n  /* If len is provided use it, otherwise use strlen. */\n  size_t len = p->len ? p->len : strlen(p->str);\n  memcpy(dest, p->str, len);\n  dest[len] = '\\0';\n  return len;\n}\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *src, size_t src_len,\n                               char *dest, size_t dest_size)\n{\n  if (src == NULL || dest == NULL)\n    return -1;\n  /* src_len may be zero meaning empty name; accept it. */\n  if (dest_size == 0)\n    return -1;\n  if (src_len >= dest_size)\n    return -1; /* won't fit including terminating NUL */\n  memcpy(dest, src, src_len);\n  dest[src_len] = '\\0';\n  return (ssize_t) src_len;\n}\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n  FILE *log = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (log != NULL)\n  {\n    /* Log entry state: provided uname_type and computed uname_type from params */\n    fprintf(log, \"ENTER get_rq_uname: caller_uname_type=%d, computed_uname_type=%d, username.ptr=%p, username_ext.ptr=%p, userhash=%d, buf_size=%zu\\n\",\n            (int) uname_type,\n            (int) get_rq_uname_type (params),\n            (void *) (params ? params->username.str : NULL),\n            (void *) (params ? params->username_ext.str : NULL),\n            params ? (params->userhash ? 1 : 0) : 0,\n            buf_size);\n  }\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    if (log != NULL)\n      fprintf(log, \"BRANCH: STANDARD\\n\");\n\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&(struct simple_val){.str = params->username.str, .len = params->username.len},\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n\n    if (log != NULL)\n      fprintf(log, \"STANDARD: username_len=%zu, buf_used=%zu\\n\",\n              uname_info->username_len, buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n    if (log != NULL)\n      fprintf(log, \"BRANCH: USERHASH\\n\");\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&(struct simple_val){.str = params->username.str, .len = params->username.len},\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      if (log != NULL)\n        fprintf(log, \"USERHASH: hex_len=%zu, res=%zu -> INVALID\\n\",\n                uname_info->userhash_hex_len, res);\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      if (log != NULL)\n        fprintf(log, \"USERHASH: hex_len=%zu, res=%zu, buf_used=%zu\\n\",\n                uname_info->userhash_hex_len, res, buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    if (log != NULL)\n      fprintf(log, \"BRANCH: EXTENDED\\n\");\n\n    res = get_rq_extended_uname_copy_z (params->username_ext.str,\n                                        params->username_ext.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n\n    if (log != NULL)\n      fprintf(log, \"EXTENDED: res=%zd, username_len=%zu, buf_used=%zu\\n\",\n              res, uname_info->username_len, buf_used);\n  }\n  else\n  {\n    /* This branch is never reached from any project caller (see call sites).\n       Keep defensive code but log the unexpected state for the diagnostic. */\n    if (log != NULL)\n    {\n      fprintf(log, \"BRANCH: DEFAULT (unexpected) - uname_type=%d, computed=%d\\n\",\n              (int) uname_type, (int) get_rq_uname_type (params));\n    }\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"EXIT get_rq_uname: buf_used=%zu, reported_uname_type=%d\\n\",\n            buf_used, (int) uname_info->uname_type);\n    fclose(log);\n  }\n\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.1 forbids code that cannot be reached by any possible program execution in the project; to claim a branch is unreachable you must show (for the whole project) that no execution path can ever take it. The final else in get_rq_uname is only asserted to be impossible at runtime (mhd_assert and precondition checks), but that is not a compile\u2011time proof of impossibility across the project. In particular:\n- get_rq_uname is static so callers are limited to the translation unit, but the snippet does not prove (and there is no global, static-analysis evidence here) that every caller will always pass only STANDARD, USERHASH or EXTENDED. A change or a faulty caller could pass another enum value. That makes the else reachable in principle.\n- The code relies on mhd_assert to detect impossible states at runtime. Assertions are runtime checks (and in some builds may be compiled out); they do not render the else branch provably unreachable for the purposes of MISRA\u2019s requirement.\n- The provided test harness failed to compile and therefore supplies no evidence that the branch is unreachable.\nBecause there is no incontrovertible project\u2011wide proof that the default else can never execute, the branch cannot be classified as unreachable code under MISRA 2.1. Therefore the agent A\u2019s claim of a Rule 2.1 violation is incorrect."
}