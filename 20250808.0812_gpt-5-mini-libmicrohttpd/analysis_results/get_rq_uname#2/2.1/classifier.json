{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_rq_uname code that contains useful probe functions that print useful logs to a file \"/tmp/logs/17.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_uname as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_rq_uname:\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_uname:\nenum MHD_DigestAuthUsernameType\n{\n  /**\n   * No username parameter in in Digest Authorization header.\n   * This should be treated as an error.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_MISSING = 0,\n\n  /**\n   * The 'username' parameter is used to specify the username.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD = (1 << 2),\n\n  /**\n   * The username is specified by 'username*' parameter with\n   * the extended notation (see RFC 5987 #section-3.2.1).\n   * The only difference between standard and extended types is\n   * the way how username value is encoded in the header.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED = (1 << 3),\n\n  /**\n   * The username provided in form of 'userhash' as\n   * specified by RFC 7616 #section-3.4.4.\n   * @sa #MHD_digest_auth_calc_userhash_hex(), #MHD_digest_auth_calc_userhash()\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH = (1 << 1),\n\n  /**\n   * The invalid combination of username parameters are used by client.\n   * Either:\n   * * both 'username' and 'username*' are used\n   * * 'username*' is used with 'userhash=true'\n   * * 'username*' used with invalid extended notation\n   * * 'username' is not hexadecimal string, while 'userhash' set to 'true'\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_INVALID = (1 << 0)\n}\n...\n_MHD_static_inline enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  if (NULL != params->username.value.str)\n  {\n    if (NULL == params->username_ext.value.str)\n      return params->userhash ?\n             MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH :\n             MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    else  /* Both 'username' and 'username*' are used */\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  else if (NULL != params->username_ext.value.str)\n  {\n    if (! params->username_ext.quoted && ! params->userhash &&\n        (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len) )\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\n...\nstruct MHD_RqDAuth\n{\n  struct MHD_RqDAuthParam nonce;\n  struct MHD_RqDAuthParam opaque;\n  struct MHD_RqDAuthParam response;\n  struct MHD_RqDAuthParam username;\n  struct MHD_RqDAuthParam username_ext;\n  struct MHD_RqDAuthParam realm;\n  struct MHD_RqDAuthParam uri;\n  /* The raw QOP value, used in the 'response' calculation */\n  struct MHD_RqDAuthParam qop_raw;\n  struct MHD_RqDAuthParam cnonce;\n  struct MHD_RqDAuthParam nc;\n\n  /* Decoded values are below */\n  bool userhash; /* True if 'userhash' parameter has value 'true'. */\n  enum MHD_DigestAuthAlgo3 algo3;\n  enum MHD_DigestAuthQOP qop;\n}\n...\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n...\nsize_t\nMHD_str_unquote (const char *quoted,\n                 size_t quoted_len,\n                 char *result)\n{\n  size_t r;\n  size_t w;\n\n  r = 0;\n  w = 0;\n\n  while (quoted_len > r)\n  {\n    if ('\\\\' == quoted[r])\n    {\n      ++r;\n      if (quoted_len == r)\n        return 0; /* Last backslash is not followed by char to unescape */\n    }\n    result[w++] = quoted[r++];\n  }\n  return w;\n}\n...\nsize_t\nMHD_hex_to_bin (const char *hex,\n                size_t len,\n                void *bin)\n{\n  uint8_t *const out = (uint8_t *) bin;\n  size_t r;\n  size_t w;\n\n  if (0 == len)\n    return 0;\n  r = 0;\n  w = 0;\n  if (0 != len % 2)\n  {\n    /* Assume the first byte is encoded with single digit */\n    const int l = toxdigitvalue (hex[r++]);\n    if (0 > l)\n      return 0;\n    out[w++] = (uint8_t) ((unsigned int) l);\n  }\n  while (r < len)\n  {\n    const int h = toxdigitvalue (hex[r++]);\n    const int l = toxdigitvalue (hex[r++]);\n    if ((0 > h) || (0 > l))\n      return 0;\n    out[w++] = (uint8_t) ( ((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)) );\n  }\n  mhd_assert (len == r);\n  mhd_assert ((len + 1) / 2 == w);\n  return w;\n}\n...\n_MHD_static_inline int\ntoxdigitvalue (char c)\n{\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n  switch ((unsigned char) c)\n  {\n#if 0 /* Disabled to give the compiler a hint about low probability */\n  case 0x00U:    /* NUL */\n  case 0x01U:    /* SOH */\n  case 0x02U:    /* STX */\n  case 0x03U:    /* ETX */\n  case 0x04U:    /* EOT */\n  case 0x05U:    /* ENQ */\n  case 0x06U:    /* ACK */\n  case 0x07U:    /* BEL */\n  case 0x08U:    /* BS */\n  case 0x09U:    /* HT */\n  case 0x0AU:    /* LF */\n  case 0x0BU:    /* VT */\n  case 0x0CU:    /* FF */\n  case 0x0DU:    /* CR */\n  case 0x0EU:    /* SO */\n  case 0x0FU:    /* SI */\n  case 0x10U:    /* DLE */\n  case 0x11U:    /* DC1 */\n  case 0x12U:    /* DC2 */\n  case 0x13U:    /* DC3 */\n  case 0x14U:    /* DC4 */\n  case 0x15U:    /* NAK */\n  case 0x16U:    /* SYN */\n  case 0x17U:    /* ETB */\n  case 0x18U:    /* CAN */\n  case 0x19U:    /* EM */\n  case 0x1AU:    /* SUB */\n  case 0x1BU:    /* ESC */\n  case 0x1CU:    /* FS */\n  case 0x1DU:    /* GS */\n  case 0x1EU:    /* RS */\n  case 0x1FU:    /* US */\n  case 0x20U:    /* ' ' */\n  case 0x21U:    /* '!' */\n  case 0x22U:    /* '\"' */\n  case 0x23U:    /* '#' */\n  case 0x24U:    /* '$' */\n  case 0x25U:    /* '%' */\n  case 0x26U:    /* '&' */\n  case 0x27U:    /* '\\'' */\n  case 0x28U:    /* '(' */\n  case 0x29U:    /* ')' */\n  case 0x2AU:    /* '*' */\n  case 0x2BU:    /* '+' */\n  case 0x2CU:    /* ',' */\n  case 0x2DU:    /* '-' */\n  case 0x2EU:    /* '.' */\n  case 0x2FU:    /* '/' */\n    return -1;\n#endif\n  case 0x30U: /* '0' */\n    return 0;\n  case 0x31U: /* '1' */\n    return 1;\n  case 0x32U: /* '2' */\n    return 2;\n  case 0x33U: /* '3' */\n    return 3;\n  case 0x34U: /* '4' */\n    return 4;\n  case 0x35U: /* '5' */\n    return 5;\n  case 0x36U: /* '6' */\n    return 6;\n  case 0x37U: /* '7' */\n    return 7;\n  case 0x38U: /* '8' */\n    return 8;\n  case 0x39U: /* '9' */\n    return 9;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x3AU: /* ':' */\n  case 0x3BU: /* ';' */\n  case 0x3CU: /* '<' */\n  case 0x3DU: /* '=' */\n  case 0x3EU: /* '>' */\n  case 0x3FU: /* '?' */\n  case 0x40U: /* '@' */\n    return -1;\n#endif\n  case 0x41U: /* 'A' */\n    return 0xAU;\n  case 0x42U: /* 'B' */\n    return 0xBU;\n  case 0x43U: /* 'C' */\n    return 0xCU;\n  case 0x44U: /* 'D' */\n    return 0xDU;\n  case 0x45U: /* 'E' */\n    return 0xEU;\n  case 0x46U: /* 'F' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x47U: /* 'G' */\n  case 0x48U: /* 'H' */\n  case 0x49U: /* 'I' */\n  case 0x4AU: /* 'J' */\n  case 0x4BU: /* 'K' */\n  case 0x4CU: /* 'L' */\n  case 0x4DU: /* 'M' */\n  case 0x4EU: /* 'N' */\n  case 0x4FU: /* 'O' */\n  case 0x50U: /* 'P' */\n  case 0x51U: /* 'Q' */\n  case 0x52U: /* 'R' */\n  case 0x53U: /* 'S' */\n  case 0x54U: /* 'T' */\n  case 0x55U: /* 'U' */\n  case 0x56U: /* 'V' */\n  case 0x57U: /* 'W' */\n  case 0x58U: /* 'X' */\n  case 0x59U: /* 'Y' */\n  case 0x5AU: /* 'Z' */\n  case 0x5BU: /* '[' */\n  case 0x5CU: /* '\\' */\n  case 0x5DU: /* ']' */\n  case 0x5EU: /* '^' */\n  case 0x5FU: /* '_' */\n  case 0x60U: /* '`' */\n    return -1;\n#endif\n  case 0x61U: /* 'a' */\n    return 0xAU;\n  case 0x62U: /* 'b' */\n    return 0xBU;\n  case 0x63U: /* 'c' */\n    return 0xCU;\n  case 0x64U: /* 'd' */\n    return 0xDU;\n  case 0x65U: /* 'e' */\n    return 0xEU;\n  case 0x66U: /* 'f' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x67U: /* 'g' */\n  case 0x68U: /* 'h' */\n  case 0x69U: /* 'i' */\n  case 0x6AU: /* 'j' */\n  case 0x6BU: /* 'k' */\n  case 0x6CU: /* 'l' */\n  case 0x6DU: /* 'm' */\n  case 0x6EU: /* 'n' */\n  case 0x6FU: /* 'o' */\n  case 0x70U: /* 'p' */\n  case 0x71U: /* 'q' */\n  case 0x72U: /* 'r' */\n  case 0x73U: /* 's' */\n  case 0x74U: /* 't' */\n  case 0x75U: /* 'u' */\n  case 0x76U: /* 'v' */\n  case 0x77U: /* 'w' */\n  case 0x78U: /* 'x' */\n  case 0x79U: /* 'y' */\n  case 0x7AU: /* 'z' */\n  case 0x7BU: /* '{' */\n  case 0x7CU: /* '|' */\n  case 0x7DU: /* '}' */\n  case 0x7EU: /* '~' */\n  case 0x7FU: /* DEL */\n  case 0x80U: /* EXT */\n  case 0x81U: /* EXT */\n  case 0x82U: /* EXT */\n  case 0x83U: /* EXT */\n  case 0x84U: /* EXT */\n  case 0x85U: /* EXT */\n  case 0x86U: /* EXT */\n  case 0x87U: /* EXT */\n  case 0x88U: /* EXT */\n  case 0x89U: /* EXT */\n  case 0x8AU: /* EXT */\n  case 0x8BU: /* EXT */\n  case 0x8CU: /* EXT */\n  case 0x8DU: /* EXT */\n  case 0x8EU: /* EXT */\n  case 0x8FU: /* EXT */\n  case 0x90U: /* EXT */\n  case 0x91U: /* EXT */\n  case 0x92U: /* EXT */\n  case 0x93U: /* EXT */\n  case 0x94U: /* EXT */\n  case 0x95U: /* EXT */\n  case 0x96U: /* EXT */\n  case 0x97U: /* EXT */\n  case 0x98U: /* EXT */\n  case 0x99U: /* EXT */\n  case 0x9AU: /* EXT */\n  case 0x9BU: /* EXT */\n  case 0x9CU: /* EXT */\n  case 0x9DU: /* EXT */\n  case 0x9EU: /* EXT */\n  case 0x9FU: /* EXT */\n  case 0xA0U: /* EXT */\n  case 0xA1U: /* EXT */\n  case 0xA2U: /* EXT */\n  case 0xA3U: /* EXT */\n  case 0xA4U: /* EXT */\n  case 0xA5U: /* EXT */\n  case 0xA6U: /* EXT */\n  case 0xA7U: /* EXT */\n  case 0xA8U: /* EXT */\n  case 0xA9U: /* EXT */\n  case 0xAAU: /* EXT */\n  case 0xABU: /* EXT */\n  case 0xACU: /* EXT */\n  case 0xADU: /* EXT */\n  case 0xAEU: /* EXT */\n  case 0xAFU: /* EXT */\n  case 0xB0U: /* EXT */\n  case 0xB1U: /* EXT */\n  case 0xB2U: /* EXT */\n  case 0xB3U: /* EXT */\n  case 0xB4U: /* EXT */\n  case 0xB5U: /* EXT */\n  case 0xB6U: /* EXT */\n  case 0xB7U: /* EXT */\n  case 0xB8U: /* EXT */\n  case 0xB9U: /* EXT */\n  case 0xBAU: /* EXT */\n  case 0xBBU: /* EXT */\n  case 0xBCU: /* EXT */\n  case 0xBDU: /* EXT */\n  case 0xBEU: /* EXT */\n  case 0xBFU: /* EXT */\n  case 0xC0U: /* EXT */\n  case 0xC1U: /* EXT */\n  case 0xC2U: /* EXT */\n  case 0xC3U: /* EXT */\n  case 0xC4U: /* EXT */\n  case 0xC5U: /* EXT */\n  case 0xC6U: /* EXT */\n  case 0xC7U: /* EXT */\n  case 0xC8U: /* EXT */\n  case 0xC9U: /* EXT */\n  case 0xCAU: /* EXT */\n  case 0xCBU: /* EXT */\n  case 0xCCU: /* EXT */\n  case 0xCDU: /* EXT */\n  case 0xCEU: /* EXT */\n  case 0xCFU: /* EXT */\n  case 0xD0U: /* EXT */\n  case 0xD1U: /* EXT */\n  case 0xD2U: /* EXT */\n  case 0xD3U: /* EXT */\n  case 0xD4U: /* EXT */\n  case 0xD5U: /* EXT */\n  case 0xD6U: /* EXT */\n  case 0xD7U: /* EXT */\n  case 0xD8U: /* EXT */\n  case 0xD9U: /* EXT */\n  case 0xDAU: /* EXT */\n  case 0xDBU: /* EXT */\n  case 0xDCU: /* EXT */\n  case 0xDDU: /* EXT */\n  case 0xDEU: /* EXT */\n  case 0xDFU: /* EXT */\n  case 0xE0U: /* EXT */\n  case 0xE1U: /* EXT */\n  case 0xE2U: /* EXT */\n  case 0xE3U: /* EXT */\n  case 0xE4U: /* EXT */\n  case 0xE5U: /* EXT */\n  case 0xE6U: /* EXT */\n  case 0xE7U: /* EXT */\n  case 0xE8U: /* EXT */\n  case 0xE9U: /* EXT */\n  case 0xEAU: /* EXT */\n  case 0xEBU: /* EXT */\n  case 0xECU: /* EXT */\n  case 0xEDU: /* EXT */\n  case 0xEEU: /* EXT */\n  case 0xEFU: /* EXT */\n  case 0xF0U: /* EXT */\n  case 0xF1U: /* EXT */\n  case 0xF2U: /* EXT */\n  case 0xF3U: /* EXT */\n  case 0xF4U: /* EXT */\n  case 0xF5U: /* EXT */\n  case 0xF6U: /* EXT */\n  case 0xF7U: /* EXT */\n  case 0xF8U: /* EXT */\n  case 0xF9U: /* EXT */\n  case 0xFAU: /* EXT */\n  case 0xFBU: /* EXT */\n  case 0xFCU: /* EXT */\n  case 0xFDU: /* EXT */\n  case 0xFEU: /* EXT */\n  case 0xFFU: /* EXT */\n    return -1;\n  default:\n    mhd_assert (0);\n    break;  /* Should be unreachable */\n#else\n  default:\n    break;\n#endif\n  }\n  return -1;\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (isasciidigit (c))\n    return (unsigned char) (c - '0');\n  if ( (c >= 'A') && (c <= 'F') )\n    return (unsigned char) (c - 'A' + 10);\n  if ( (c >= 'a') && (c <= 'f') )\n    return (unsigned char) (c - 'a' + 10);\n\n  return -1;\n#endif /* MHD_FAVOR_SMALL_CODE */\n}\n...\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n...\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  if (broken)\n    return 0;\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  if (buf_size >= pct_encoded_len)\n  {\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n          return 0;\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n            return 0;\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          decoded[w] = (char) out;\n        }\n      }\n      else\n        decoded[w] = chr;\n      ++r;\n      ++w;\n    }\n    return w;\n  }\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    if (w >= buf_size)\n      return 0;\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n        return 0;\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        if ((0 > h) || (0 > l))\n          return 0;\n        out =\n          (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)));\n        decoded[w] = (char) out;\n      }\n    }\n    else\n      decoded[w] = chr;\n    ++r;\n    ++w;\n  }\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n...\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n</additional code>\nJudge whether the above get_rq_uname code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "The final 'else' branch (mhd_assert(0); uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;) is effectively unreachable in the project: get_rq_uname is static and all callers only invoke it after checking that uname_type is neither MISSING nor INVALID, so only STANDARD, USERHASH or EXTENDED values reach this function. Consequently the default 'else' path cannot be executed in normal project use and is unreachable code.",
  "test_code": "#include <stdio.h>\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n  FILE *log = fopen(\"/tmp/logs/17.txt\", \"a\");\n  if (log != NULL)\n  {\n    /* Log entry state: provided uname_type and computed uname_type from params */\n    fprintf(log, \"ENTER get_rq_uname: caller_uname_type=%d, computed_uname_type=%d, username.ptr=%p, username_ext.ptr=%p, userhash=%d, buf_size=%zu\\n\",\n            (int) uname_type,\n            (int) get_rq_uname_type (params),\n            (void *) params->username.value.str,\n            (void *) params->username_ext.value.str,\n            params->userhash ? 1 : 0,\n            buf_size);\n  }\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    if (log != NULL)\n      fprintf(log, \"BRANCH: STANDARD\\n\");\n\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n\n    if (log != NULL)\n      fprintf(log, \"STANDARD: username_len=%zu, buf_used=%zu\\n\",\n              uname_info->username_len, buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n    if (log != NULL)\n      fprintf(log, \"BRANCH: USERHASH\\n\");\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      if (log != NULL)\n        fprintf(log, \"USERHASH: hex_len=%zu, res=%zu -> INVALID\\n\",\n                uname_info->userhash_hex_len, res);\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      if (log != NULL)\n        fprintf(log, \"USERHASH: hex_len=%zu, res=%zu, buf_used=%zu\\n\",\n                uname_info->userhash_hex_len, res, buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    if (log != NULL)\n      fprintf(log, \"BRANCH: EXTENDED\\n\");\n\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n\n    if (log != NULL)\n      fprintf(log, \"EXTENDED: res=%zd, username_len=%zu, buf_used=%zu\\n\",\n              res, uname_info->username_len, buf_used);\n  }\n  else\n  {\n    /* This branch is never reached from any project caller (see call sites).\n       Keep defensive code but log the unexpected state for the diagnostic. */\n    if (log != NULL)\n    {\n      fprintf(log, \"BRANCH: DEFAULT (unexpected) - uname_type=%d, computed=%d\\n\",\n              (int) uname_type, (int) get_rq_uname_type (params));\n    }\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"EXIT get_rq_uname: buf_used=%zu, reported_uname_type=%d\\n\",\n            buf_used, (int) uname_info->uname_type);\n    fclose(log);\n  }\n\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n"
}