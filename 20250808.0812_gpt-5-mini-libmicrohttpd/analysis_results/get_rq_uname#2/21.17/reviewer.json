{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation: In the STANDARD and USERHASH branches there is no check that the remaining buffer (buf_size - buf_used) is large enough before calling get_rq_param_unquoted_copy_z which internally does memcpy(buf, param->value.str, param->value.len) and writes a terminating NUL. If param->value.len + 1 > buf_size - buf_used this results in writing beyond the bounds of buf. In the USERHASH branch, after copying the hex string there is likewise no check that the remaining buffer is large enough for the binary output of MHD_hex_to_bin, so that call can also write beyond buf. Both cases violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct RqParamValue {\n  const char *str; /* pointer to actual bytes */\n  size_t len;\n};\nstruct RqParam {\n  struct RqParamValue value;\n};\nstruct MHD_RqDAuth {\n  /* For simplicity, include the type here so get_rq_uname_type can return it */\n  enum MHD_DigestAuthUsernameType uname_type;\n  struct RqParam username;\n  struct RqParam username_ext;\n};\nstatic void mhd_assert(int cond)\n{\n  assert(cond);\n}\nstatic void\nlog_state(const char *stage, size_t buf_size, size_t buf_used,\n          size_t param_len, const char *branch, size_t extra)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log control path and key sizes that demonstrate overflow potential */\n  fprintf(f, \"%s: branch=%s buf_size=%zu buf_used=%zu param_len=%zu extra=%zu\\n\",\n          stage, branch, buf_size, buf_used, param_len, extra);\n  fclose(f);\n}\n\nstatic enum MHD_DigestAuthUsernameType\nget_rq_uname_type(const struct MHD_RqDAuth *params)\n{\n  return params->uname_type;\n}\nstatic size_t\nget_rq_param_unquoted_copy_z(const struct RqParam *param, char *dest)\n{\n  size_t i, j = 0;\n  /* If quoted (starts and ends with '\"') drop quotes. */\n  int quoted = (param->value.len >= 2 && param->value.str[0] == '\"' &&\n                param->value.str[param->value.len - 1] == '\"');\n  for (i = quoted ? 1 : 0; i < param->value.len - (quoted ? 1 : 0); ++i)\n  {\n    dest[j++] = param->value.str[i];\n  }\n  dest[j] = '\\0';\n  return j;\n}\nstatic ssize_t\nget_rq_extended_uname_copy_z(const char *src, size_t src_len,\n                              char *dest, size_t dest_size)\n{\n  if (dest_size == 0) return -1;\n  /* Copy up to dest_size - 1 bytes to leave room for NUL. */\n  size_t to_copy = src_len < (dest_size - 1) ? src_len : (dest_size - 1);\n  memcpy(dest, src, to_copy);\n  dest[to_copy] = '\\0';\n  return (ssize_t)to_copy;\n}\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    /* Log before copy: we don't check remaining buffer here (potential overflow) */\n    log_state(\"before_copy\", buf_size, buf_used, params->username.value.len,\n              \"STANDARD\", 0);\n\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n\n    /* Log after copy: username_len may exceed remaining space */\n    log_state(\"after_copy\", buf_size, buf_used, uname_info->username_len,\n              \"STANDARD\", 0);\n\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    /* Log before hex copy */\n    log_state(\"before_hex_copy\", buf_size, buf_used, params->username.value.len,\n              \"USERHASH\", 0);\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n\n    /* Log after hex copy: we still don't verify space for binary output */\n    log_state(\"after_hex_copy\", buf_size, buf_used, uname_info->userhash_hex_len,\n              \"USERHASH\", 0);\n\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n\n    /* Log result of hex->bin conversion and potential space needed */\n    log_state(\"after_hex_to_bin\", buf_size, buf_used, uname_info->userhash_hex_len,\n              \"USERHASH\", res);\n\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  /* Final state log */\n  log_state(\"return\", buf_size, buf_used, 0, \"END\", 0);\n  return buf_used;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the STANDARD branch the code sets uname_info->username = buf + buf_used and then calls get_rq_param_unquoted_copy_z without checking that buf_size - buf_used is large enough to hold the copied bytes plus the terminating NUL. If the helper actually copies param->value.len (or param length minus quotes) bytes and then writes a NUL (for example via memcpy or a manual copy), this can write past buf. Likewise in the USERHASH branch the hex string is copied into the remaining buffer without checking remaining space, and then MHD_hex_to_bin is invoked to write the binary output at buf + buf_used; there is no check that the remaining space can hold the binary output (res bytes). The final mhd_assert(buf_size >= buf_used) is only a postcondition/test and does not prevent the intermediate out-of-bounds writes.\n\nThe validity of the violation depends on the implementations of get_rq_param_unquoted_copy_z and MHD_hex_to_bin; if those helpers perform unbounded memcpy-like writes, then Rule 21.17 is violated. Given the presented scenario (and the example test helper implementations), the calls can indeed result in out-of-bounds accesses, so the report is correct. Recommended fix: check (param_len + 1) <= (buf_size - buf_used) before copying, or change the helpers to accept a destination size and fail safely if insufficient space, and check remaining space before calling MHD_hex_to_bin (e.g. ensure (hex_len/2) <= (buf_size - buf_used))."
}