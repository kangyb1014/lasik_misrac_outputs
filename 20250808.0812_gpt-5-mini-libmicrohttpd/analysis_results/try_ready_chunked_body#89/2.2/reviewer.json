{
  "user_message": "An agent A claimed that the following try_ready_chunked_body code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_chunked_body.\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code contains an apparently unreachable/unused error-handling branch: the inner block guarded by 'if (NULL == response->crc)' (commented with \"There is no way to reach this code\") is dead. The project-level invariants (response must have either a data buffer covering the required position or a crc callback) make this branch effectively redundant; its presence constitutes dead code per MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef ssize_t (*mhd_crc_fn)(void *cls, uint64_t position, char *buffer, size_t size);\nstruct MHD_RP {\n    struct MHD_Response *response;\n    uint64_t rsp_write_position;\n};\nstatic inline void mhd_assert(int cond)\n{\n    if (!cond)\n        abort();\n}\nstatic const uint64_t MHD_SIZE_UNKNOWN = (uint64_t) -1;\nstatic const ssize_t MHD_CONTENT_READER_END_OF_STREAM = (ssize_t) -2;\nstatic const ssize_t MHD_CONTENT_READER_END_WITH_ERROR = (ssize_t) -1;\nextern void CONNECTION_CLOSE_ERROR(struct MHD_Connection *c, const char *msg);\nstatic void try_ready_chunked_body_probe(const char *tag,\n                                         struct MHD_Connection *connection,\n                                         struct MHD_Response *response,\n                                         ssize_t ret_val,\n                                         size_t size_to_fill,\n                                         uint64_t left_to_send)\n{\n    FILE *f = fopen(\"/tmp/logs/714.txt\", \"a\");\n    if (NULL == f)\n        return;\n    /* Print addresses safely. Function pointers are cast via uintptr_t. */\n    fprintf(f, \"%s: conn=%p resp=%p crc=%p data=%p rsp_write_pos=%llu data_start=%llu data_size=%zu size_to_fill=%zu left_to_send=%llu ret=%lld\\n\",\n            tag,\n            (void *) connection,\n            (void *) response,\n            (void *) (response ? (void *)(uintptr_t)response->crc : NULL),\n            (void *) (response ? (void *) response->data : NULL),\n            (unsigned long long) (connection ? connection->rp.rsp_write_position : 0ULL),\n            (unsigned long long) (response ? response->data_start : 0ULL),\n            (response ? response->data_size : 0U),\n            size_to_fill,\n            (unsigned long long) left_to_send,\n            (long long) ret_val);\n    fclose(f);\n}\n\nstatic enum MHD_Result /* enum type alias; not used elsewhere */\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n    ssize_t ret;\n    struct MHD_Response *response;\n    static const size_t max_chunk = 0xFFFFFF;\n    char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n    /* \"FFFFFF\" + \"\\r\\n\" */\n    static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n    /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n    static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n    size_t chunk_hdr_len;\n    uint64_t left_to_send;\n    size_t size_to_fill;\n\n    response = connection->rp.response;\n    mhd_assert (NULL != response->crc || NULL != response->data);\n\n    mhd_assert (0 == connection->write_buffer_append_offset);\n\n    try_ready_chunked_body_probe(\"enter\", connection, response, -9999, 0, 0);\n\n    /* The buffer must be reasonably large enough */\n    if (128 > connection->write_buffer_size)\n    {\n        size_t size;\n\n        size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n        if (128 > size)\n        {\n            /* not enough memory */\n            try_ready_chunked_body_probe(\"out_of_memory\", connection, response, -8888, 0, 0);\n            CONNECTION_CLOSE_ERROR (connection,\n                                    \"Closing connection (out of memory).\");\n            return MHD_NO;\n        }\n        /* Limit the buffer size to the largest usable size for chunks */\n        if ( (max_chunk + max_chunk_overhead) < size)\n            size = max_chunk + max_chunk_overhead;\n        mhd_assert ((NULL == connection->write_buffer) ||\n                    MHD_pool_is_resizable_inplace (connection->pool,\n                                                   connection->write_buffer,\n                                                   connection->write_buffer_size));\n        connection->write_buffer =\n            MHD_pool_reallocate (connection->pool,\n                                 connection->write_buffer,\n                                 connection->write_buffer_size,\n                                 size);\n        mhd_assert (NULL != connection->write_buffer);\n        connection->write_buffer_size = size;\n    }\n    mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n    if (MHD_SIZE_UNKNOWN == response->total_size)\n        left_to_send = MHD_SIZE_UNKNOWN;\n    else\n        left_to_send = response->total_size\n                       - connection->rp.rsp_write_position;\n\n    size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n    /* Limit size for the callback to the max usable size */\n    if (max_chunk < size_to_fill)\n        size_to_fill = max_chunk;\n    if (left_to_send < size_to_fill)\n        size_to_fill = (size_t) left_to_send;\n\n    if (0 == left_to_send)\n        /* nothing to send, don't bother calling crc */\n        ret = MHD_CONTENT_READER_END_OF_STREAM;\n    else if ( (response->data_start <=\n               connection->rp.rsp_write_position) &&\n              (response->data_start + response->data_size >\n               connection->rp.rsp_write_position) )\n    {\n        /* difference between rsp_write_position and data_start is less\n           than data_size which is size_t type, no need to check for overflow */\n        const size_t data_write_offset\n          = (size_t) (connection->rp.rsp_write_position\n                      - response->data_start);\n        /* buffer already ready, use what is there for the chunk */\n        mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n        mhd_assert (response->data_size >= data_write_offset);\n        ret = (ssize_t) (response->data_size - data_write_offset);\n        if ( ((size_t) ret) > size_to_fill)\n            ret = (ssize_t) size_to_fill;\n        memcpy (&connection->write_buffer[max_chunk_hdr_len],\n                &response->data[data_write_offset],\n                (size_t) ret);\n        try_ready_chunked_body_probe(\"used_existing_data\", connection, response, ret, size_to_fill, left_to_send);\n    }\n    else\n    {\n        if (NULL == response->crc)\n        {\n            try_ready_chunked_body_probe(\"impossible_no_crc_branch\", connection, response, -7777, size_to_fill, left_to_send);\n            CONNECTION_CLOSE_ERROR (connection,\n                                    \"No callback for the chunked data.\");\n            return MHD_NO;\n        }\n        ret = response->crc (response->crc_cls,\n                             connection->rp.rsp_write_position,\n                             &connection->write_buffer[max_chunk_hdr_len],\n                             size_to_fill);\n        try_ready_chunked_body_probe(\"crc_called\", connection, response, ret, size_to_fill, left_to_send);\n    }\n    if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n    {\n        /* error, close socket! */\n        /* TODO: remove update of the response size */\n        response->total_size = connection->rp.rsp_write_position;\n        try_ready_chunked_body_probe(\"crc_error\", connection, response, ret, size_to_fill, left_to_send);\n        CONNECTION_CLOSE_ERROR (connection,\n                                \"Closing connection (application error generating response).\");\n        return MHD_NO;\n    }\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n    {\n        *p_finished = true;\n        /* TODO: remove update of the response size */\n        response->total_size = connection->rp.rsp_write_position;\n        try_ready_chunked_body_probe(\"end_of_stream\", connection, response, ret, size_to_fill, left_to_send);\n        return MHD_YES;\n    }\n    if (0 == ret)\n    {\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        try_ready_chunked_body_probe(\"zero_return_unready\", connection, response, ret, size_to_fill, left_to_send);\n        return MHD_NO;\n    }\n    if (size_to_fill < (size_t) ret)\n    {\n        try_ready_chunked_body_probe(\"crc_returned_more_than_requested\", connection, response, ret, size_to_fill, left_to_send);\n        CONNECTION_CLOSE_ERROR (connection,\n                                \"Closing connection (application returned more data than requested).\");\n        return MHD_NO;\n    }\n    chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                        sizeof(chunk_hdr));\n    mhd_assert (chunk_hdr_len != 0);\n    mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n    *p_finished = false;\n    connection->write_buffer_send_offset =\n      (max_chunk_hdr_len - (chunk_hdr_len + 2));\n    memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n            chunk_hdr,\n            chunk_hdr_len);\n    connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n    connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n    connection->rp.rsp_write_position += (size_t) ret;\n    connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n    try_ready_chunked_body_probe(\"return_yes\", connection, response, ret, size_to_fill, left_to_send);\n    return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's report is not correct. The inner \"if (NULL == response->crc)\" block is not provably dead from the snippet shown. The only check that relates crc and data is mhd_assert(NULL != response->crc || NULL != response->data) \u2014 an assertion, not a compile-time or guaranteed runtime invariant (and typically not present in release builds). That assertion merely ensures at least one of crc or data is non-NULL, it does not guarantee that the data buffer covers the current rsp_write_position. The else branch is entered when the current write position is not within the data buffer; in that situation response->crc must be non-NULL to supply data. If response->data is non-NULL but does not cover the position and response->crc is NULL, the branch in question would be executed and its behaviour (closing the connection) affects program behaviour. Thus the code is reachable in plausible runtime states unless there is a separate, project-level invariant (outside the provided code) that guarantees crc is always non-NULL whenever the data buffer does not cover the requested position. No such invariant or proof was provided; the test harness did not produce evidence. Because the claim of dead code relies on an unshown invariant and the branch can be exercised at runtime, the reported MISRA 2.2 violation is not supported by the evidence."
}