{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstruct MHD_Response;\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    void (*crfc)(void *));\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content);\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response);\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response);\nstatic void\nprobe_log(const char *stage, const struct Session *session, int reply_len, const char *reply)\n{\n  FILE *f = fopen(\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* best-effort logging */\n  }\n\n  fprintf(f, \"stage=%s\\n\", stage);\n  if (NULL != session)\n  {\n    /* print a safe preview of strings */\n    fprintf(f, \"  sid=%s\\n\", session->sid[0] ? session->sid : \"(empty)\");\n    fprintf(f, \"  value_1=%s\\n\", session->value_1[0] ? session->value_1 : \"(empty)\");\n  }\n  fprintf(f, \"  reply_len=%d\\n\", reply_len);\n  if ((NULL != reply) && (reply_len > 0))\n  {\n    const int preview = (reply_len > 128) ? 128 : reply_len;\n    fprintf(f, \"  reply_preview=%.*s\\n\", preview, reply);\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  probe_log(\"after_snprintf_len\", session, reply_len, NULL);\n\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n  {\n    probe_log(\"malloc_failed\", session, reply_len, NULL);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    probe_log(\"snprintf_mismatch\", session, reply_len, reply);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  probe_log(\"filled_reply\", session, reply_len, reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    /* add_session_cookie reads session->sid but does not modify session in this path;\n       the fact that fill_v1_form takes a non-const session is the violation scenario. */\n    probe_log(\"before_add_session_cookie\", session, reply_len, reply);\n    add_session_cookie (session, response);\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      probe_log(\"add_response_header_failed\", session, reply_len, reply);\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log(\"after_queue_response\", session, reply_len, reply);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    probe_log(\"create_response_failed\", session, reply_len, reply);\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpoo6bnj58/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of fill_v1_form as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Minimal, self-contained declarations so this translation unit compiles.\n   These are declarations only (no mock implementations) to keep the\n   original fill_v1_form logic intact. */\n\nstruct MHD_Response;\nstruct MHD_Connection;\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nextern struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    void (*crfc)(void *));\nextern enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content);\nextern enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response);\nextern void\nMHD_destroy_response (struct MHD_Response *response);\n\n/* The code expects these identifiers; provide minimal consts instead of macros. */\nstatic const char MHD_HTTP_HEADER_CONTENT_TYPE[] = \"Content-Type\";\nstatic const unsigned int MHD_HTTP_OK = 200u;\n\n/* The Session structure: keep the fields accessed by the functions. */\nstruct Session {\n  char sid[64];\n  char value_1[256];\n};\n\n/* Declaration only; implementation is assumed to exist elsewhere. */\nextern void add_session_cookie (struct Session *session, struct MHD_Response *response);\n\n/* A safe format string to emulate the original FORM_V1. */\nstatic const char FORM_V1[] = \"%s\";\n\nstatic void\nprobe_log(const char *stage, const struct Session *session, int reply_len, const char *reply)\n{\n  FILE *f = fopen(\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* best-effort logging */\n  }\n\n  fprintf(f, \"stage=%s\\n\", stage);\n  if (NULL != session)\n  {\n    /* print a safe preview of strings */\n    fprintf(f, \"  sid=%s\\n\", session->sid[0] ? session->sid : \"(empty)\");\n    fprintf(f, \"  value_1=%s\\n\", session->value_1[0] ? session->value_1 : \"(empty)\");\n  }\n  fprintf(f, \"  reply_len=%d\\n\", reply_len);\n  if ((NULL != reply) && (reply_len > 0))\n  {\n    const int preview = (reply_len > 128) ? 128 : reply_len;\n    fprintf(f, \"  reply_preview=%.*s\\n\", preview, reply);\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  probe_log(\"after_snprintf_len\", session, reply_len, NULL);\n\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n  {\n    probe_log(\"malloc_failed\", session, reply_len, NULL);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    probe_log(\"snprintf_mismatch\", session, reply_len, reply);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  probe_log(\"filled_reply\", session, reply_len, reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    /* add_session_cookie reads session->sid but does not modify session in this path;\n       the fact that fill_v1_form takes a non-const session is the violation scenario. */\n    probe_log(\"before_add_session_cookie\", session, reply_len, reply);\n    add_session_cookie (session, response);\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      probe_log(\"add_response_header_failed\", session, reply_len, reply);\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log(\"after_queue_response\", session, reply_len, reply);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    probe_log(\"create_response_failed\", session, reply_len, reply);\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n",
  "explanation": "I made the translation unit self-contained so it compiles while preserving the original fill_v1_form logic. Changes:\n- Included necessary headers (stdio.h, stdlib.h, string.h, stddef.h, stdint.h).\n- Replaced unknown _MHD_EXTERN with standard extern function declarations for the MHD APIs (no implementations were added).\n- Declared enum MHD_Result and the constants MHD_YES/MHD_NO.\n- Forward-declared struct MHD_Response and struct MHD_Connection.\n- Added a minimal Session struct with the fields used by the code.\n- Declared add_session_cookie (no mock implementation) and MHD API functions as extern so the file compiles as a translation unit.\n- Provided FORM_V1 as a const char array instead of a macro and provided MHD_HTTP_HEADER_CONTENT_TYPE and MHD_HTTP_OK as const values.\n\nNo function implementations (mocks) were added; only declarations and small supporting definitions required for compilation. The fill_v1_form function and probe_log are otherwise unchanged."
}