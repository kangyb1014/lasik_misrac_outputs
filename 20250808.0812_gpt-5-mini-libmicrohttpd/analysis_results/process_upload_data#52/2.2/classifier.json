{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified process_upload_data code that contains useful probe functions that print useful logs to a file \"/tmp/logs/418.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_upload_data as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of process_upload_data:\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function process_upload_data:\nstruct UploadContext\n{\n  /**\n   * Handle where we write the uploaded file to.\n   */\n  int fd;\n\n  /**\n   * Name of the file on disk (used to remove on errors).\n   */\n  char *filename;\n\n  /**\n   * Language for the upload.\n   */\n  char *language;\n\n  /**\n   * Category for the upload.\n   */\n  char *category;\n\n  /**\n   * Post processor we're using to process the upload.\n   */\n  struct MHD_PostProcessor *pp;\n\n  /**\n   * Handle to connection that we're processing the upload for.\n   */\n  struct MHD_Connection *connection;\n\n  /**\n   * Response to generate, NULL to use directory.\n   */\n  struct MHD_Response *response;\n}\n...\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  if (NULL == (buf = malloc (old_len + size + 1)))\n    return MHD_NO;\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n  memcpy (&buf[old_len],\n          data,\n          size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}\n...\nstatic struct MHD_Response *request_refused_response\n...\nstatic struct MHD_Response *internal_error_response\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n</additional code>\nJudge whether the above process_upload_data code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The explicit (void) casts for unused parameters (kind, content_type, transfer_encoding, off) are executed but have no effect on program behaviour; removing them would not change the program's behaviour, so they constitute dead code under MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n/* Forward declarations from the surrounding project. These are expected\n   to be defined elsewhere in the project and are not redefined here. */\nstruct MHD_PostProcessor;\nstruct MHD_Connection;\nstruct MHD_Response;\nstatic struct MHD_Response *request_refused_response;\nstatic struct MHD_Response *internal_error_response;\n\nenum MHD_ValueKind { MHD_KIND_PLACEHOLDER };\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nstruct UploadContext\n{\n  int fd;\n  char *filename;\n  char *language;\n  char *category;\n  struct MHD_PostProcessor *pp;\n  struct MHD_Connection *connection;\n  struct MHD_Response *response;\n};\n\n/* External helper used by process_upload_data; defined elsewhere. */\nstatic enum MHD_Result do_append (char **ret, const char *data, size_t size);\n\n/* Probe helper that logs control path and state. The function attempts to\n   avoid changing program logic (it only appends diagnostic lines to the\n   log file). */\nstatic void probe_log_state(const char *event,\n                            const struct UploadContext *uc,\n                            const char *key,\n                            const char *filename,\n                            const char *data,\n                            size_t size)\n{\n  FILE *f = fopen(\"/tmp/logs/418.txt\", \"a\");\n  if (f == NULL)\n  {\n    /* If logging fails we silently continue to avoid affecting behaviour. */\n    return;\n  }\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \" key=%s filename=%s size=%zu\\n\",\n          (key != NULL) ? key : \"(null)\",\n          (filename != NULL) ? filename : \"(null)\",\n          size);\n  if (uc != NULL)\n  {\n    fprintf(f, \" uc->fd=%d uc->filename=%s uc->category=%s uc->language=%s\\n\",\n            uc->fd,\n            (uc->filename != NULL) ? uc->filename : \"(null)\",\n            (uc->category != NULL) ? uc->category : \"(null)\",\n            (uc->language != NULL) ? uc->language : \"(null)\");\n  }\n  if (data != NULL)\n  {\n    /* Print a small prefix of data to avoid huge logs. */\n    size_t n = (size > 32U) ? 32U : size;\n    fprintf(f, \" data_prefix=\");\n    fwrite(data, 1, n, f);\n    if (n < size)\n      fprintf(f, \"...\");\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"----\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = (struct UploadContext *) cls;\n  size_t i;\n  int res;\n  /* Unused parameters are explicitly cast to void in the original code.\n     These operations are executed but have no effect; removing them would\n     not affect behaviour. They therefore constitute dead code under\n     MISRA C 2023 Rule 2.2. We keep them here to illustrate the\n     violation and immediately log the state for diagnostics. */\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  /* Log entry showing that the function was entered and the unused\n     parameter casts above were executed (they are no-ops). */\n  probe_log_state(\"enter\", uc, key, filename, data, size);\n\n  if (0 == strcmp (key, \"category\"))\n  {\n    probe_log_state(\"append_category\", uc, key, filename, data, size);\n    return do_append (&uc->category, data, size);\n  }\n  if (0 == strcmp (key, \"language\"))\n  {\n    probe_log_state(\"append_language\", uc, key, filename, data, size);\n    return do_append (&uc->language, data, size);\n  }\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    probe_log_state(\"ignore_unexpected\", uc, key, filename, data, size);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    probe_log_state(\"no_filename\", uc, key, filename, data, size);\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    probe_log_state(\"missing_form_data\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"bad_filename_chars\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      probe_log_state(\"path_too_long\", uc, key, filename, data, size);\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      probe_log_state(\"open_failed\", uc, key, fn, data, size);\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n    probe_log_state(\"file_created\", uc, key, uc->filename, data, size);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    probe_log_state(\"write_failed\", uc, key, filename, data, size);\n    return MHD_NO;\n  }\n  probe_log_state(\"ok_continue\", uc, key, filename, data, size);\n  return MHD_YES;\n}\n"
}