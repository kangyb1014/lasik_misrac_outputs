{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified compress_buf code that contains useful probe functions that print useful logs to a file \"/tmp/logs/669.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of compress_buf as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of compress_buf:\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function compress_buf:\n#define CHUNK 16384\n</additional code>\nJudge whether the above compress_buf code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The value parameter 'src_size' is modified inside the function (src_size -= CHUNK). Modifying a value parameter violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <zlib.h>\n\n/* Minimal definition to keep original return semantics */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  FILE *logf = fopen(\"/tmp/logs/669.txt\", \"a\");\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER compress_buf: src=%p, initial_src_size=%zu, offset_ptr=%p, *offset=%zu, dest_ptr=%p, dest_size_ptr=%p, *dest_size=%zu\\n\",\n            src, src_size, (void *)offset, (offset != NULL) ? *offset : 0U, (void *)dest, (void *)dest_size, (dest_size != NULL) ? *dest_size : 0U);\n  }\n\n  *dest = NULL;\n  *dest_size = 0;\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"After init: *dest=NULL, *dest_size=0\\n\");\n  }\n\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Branch: src_size > CHUNK (src_size=%zu > %d)\\n\", src_size, CHUNK);\n      }\n\n      strm->avail_in = CHUNK;\n      /* VIOLATION: modifying the value parameter 'src_size' (demonstrates Rule 17.8 breach) */\n      src_size -= CHUNK;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Modified src_size after -= CHUNK: new_src_size=%zu\\n\", src_size);\n      }\n\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Branch: src_size <= CHUNK (src_size=%zu)\\n\", src_size);\n      }\n\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n\n    if (offset != NULL)\n    {\n      *offset += strm->avail_in;\n    }\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"After setting avail_in/offset: avail_in=%u, *offset=%zu, flush=%d\\n\",\n              (unsigned)strm->avail_in, (offset != NULL) ? *offset : 0U, flush);\n    }\n\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Inner loop: deflate returned %s, have=%u, prior *dest_size=%zu\\n\",\n                (ret == MHD_YES) ? \"Z_OK->MHD_YES\" : \"deflate_error->MHD_NO\", have, *dest_size);\n      }\n\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        if (logf != NULL)\n        {\n          fprintf(logf, \"realloc failed for size=%zu, freeing *dest and returning MHD_NO\\n\", *dest_size);\n        }\n        free (*dest);\n        *dest = NULL;\n        if (logf != NULL)\n        {\n          fclose(logf);\n        }\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"realloc succeeded, new *dest_size=%zu, copying %u bytes to dest offset %zu\\n\",\n                *dest_size, have, (*dest_size) - have);\n      }\n\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"EXIT compress_buf: final *dest=%p, *dest_size=%zu, return=%d\\n\", *dest, *dest_size, (int)ret);\n    fclose(logf);\n  }\n  return ret;\n}\n"
}