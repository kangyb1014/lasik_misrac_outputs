{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The value parameter 'src_size' is modified inside the function (src_size -= CHUNK). Modifying a value parameter violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int CHUNK = 16384;\n\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  FILE *logf = fopen(\"/tmp/logs/669.txt\", \"a\");\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER compress_buf: src=%p, initial_src_size=%zu, offset_ptr=%p, *offset=%zu, dest_ptr=%p, dest_size_ptr=%p, *dest_size=%zu\\n\",\n            src, src_size, (void *)offset, (offset != NULL) ? *offset : 0U, (void *)dest, (void *)dest_size, (dest_size != NULL) ? *dest_size : 0U);\n  }\n\n  *dest = NULL;\n  *dest_size = 0;\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"After init: *dest=NULL, *dest_size=0\\n\");\n  }\n\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Branch: src_size > CHUNK (src_size=%zu > %d)\\n\", src_size, CHUNK);\n      }\n\n      strm->avail_in = CHUNK;\n      /* VIOLATION: modifying the value parameter 'src_size' (demonstrates Rule 17.8 breach) */\n      src_size -= CHUNK;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Modified src_size after -= CHUNK: new_src_size=%zu\\n\", src_size);\n      }\n\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Branch: src_size <= CHUNK (src_size=%zu)\\n\", src_size);\n      }\n\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n\n    if (offset != NULL)\n    {\n      *offset += strm->avail_in;\n    }\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"After setting avail_in/offset: avail_in=%u, *offset=%zu, flush=%d\\n\",\n              (unsigned)strm->avail_in, (offset != NULL) ? *offset : 0U, flush);\n    }\n\n    /* Cast away const because zlib's next_in is a Bytef* (non-const) */\n    strm->next_in = (Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = (Bytef *) tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"Inner loop: deflate returned %s, have=%u, prior *dest_size=%zu\\n\",\n                (ret == MHD_YES) ? \"Z_OK->MHD_YES\" : \"deflate_error->MHD_NO\", have, *dest_size);\n      }\n\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        if (logf != NULL)\n        {\n          fprintf(logf, \"realloc failed for size=%zu, freeing *dest and returning MHD_NO\\n\", *dest_size);\n        }\n        free (*dest);\n        *dest = NULL;\n        if (logf != NULL)\n        {\n          fclose(logf);\n        }\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n\n      if (logf != NULL)\n      {\n        fprintf(logf, \"realloc succeeded, new *dest_size=%zu, copying %u bytes to dest offset %zu\\n\",\n                *dest_size, have, (*dest_size) - have);\n      }\n\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"EXIT compress_buf: final *dest=%p, *dest_size=%zu, return=%d\\n\", *dest, *dest_size, (int)ret);\n    fclose(logf);\n  }\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function modifies the value parameter src_size (src_size -= CHUNK), which is a direct modification of a function parameter variable. MISRA C 2023 Rule 17.8 prohibits modifying function parameters; although objects referred to by pointer parameters may be modified, value parameters themselves shall not be changed. Other modifications in the function (e.g. *offset, *dest, *dest_size, fields of *strm) are modifications of objects referred to by pointer parameters and are permitted by the rule. To comply, make a local copy (e.g. size_t remaining = src_size) and update that instead of modifying the parameter."
}