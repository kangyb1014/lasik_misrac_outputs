{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nconst size_t CHUNK = 16384u;\nstatic void log_state(const char *stage,\n                      size_t src_size, size_t offset, size_t dest_size,\n                      unsigned int have, int flush,\n                      const void *src, const void *tmp, const void *dest)\n{\n  FILE *f = fopen(\"/tmp/logs/671.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  fprintf(f, \"stage=%s src_size=%zu offset=%zu dest_size=%zu have=%u flush=%d\\n\",\n          stage, src_size, offset, dest_size, have, flush);\n  fprintf(f, \"  src=%p tmp=%p dest=%p\\n\", src, tmp, dest);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    log_state(\"outer_start\", src_size, *offset, *dest_size, 0, 0, src, tmp, *dest);\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      /* call zlib deflate; unchanged */\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      log_state(\"after_deflate\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        log_state(\"realloc_fail\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      /* Log immediately before the memcpy that can read from \"tmp\" up to 'have' bytes. */\n      log_state(\"before_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n      log_state(\"after_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nhttp_chunked_compression.c:61:15: error: expected identifier or '(' before numeric constant\n   61 | #define CHUNK 16384\n      |               ^~~~~\nhttp_chunked_compression.c:70:14: note: in expansion of macro 'CHUNK'\n   70 | const size_t CHUNK = 16384u;\n      |              ^~~~~\nmake[4]: *** [Makefile:1086: http_chunked_compression.o] Error 1\nmake[3]: *** [Makefile:1234: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of compress_buf as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Minimal stand-ins for external library types/constants so this\n   translation unit compiles standalone. These are NOT mock functions; just\n   type/constant declarations to avoid requiring zlib/libmicrohttpd headers. */\n\ntypedef unsigned char Bytef;\ntypedef unsigned int uInt;\n\n/* Minimal z_stream-like struct used by compress_buf. */\ntypedef struct z_stream_s {\n  uInt avail_in;\n  const Bytef *next_in;\n  uInt avail_out;\n  Bytef *next_out;\n} z_stream;\n\n/* Prototype for deflate (no implementation here). The real symbol is\n   expected to be provided at link time when using real zlib. */\nint deflate(z_stream *strm, int flush);\n\n/* zlib-like constants used by the code. Values chosen only so the code\n   compiles; real values come from zlib.h. */\nenum { Z_NO_FLUSH = 0, Z_SYNC_FLUSH = 2, Z_OK = 0 };\n\n/* Minimal enum for MHD_Result so the code compiles standalone. */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Use a different identifier to avoid collisions with any macro named CHUNK. */\nstatic const size_t CHUNK_SIZE = 16384u;\n\nstatic void log_state(const char *stage,\n                      size_t src_size, size_t offset, size_t dest_size,\n                      unsigned int have, int flush,\n                      const void *src, const void *tmp, const void *dest)\n{\n  FILE *f = fopen(\"/tmp/logs/671.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  fprintf(f, \"stage=%s src_size=%zu offset=%zu dest_size=%zu have=%u flush=%d\\n\",\n          stage, src_size, offset, dest_size, have, flush);\n  fprintf(f, \"  src=%p tmp=%p dest=%p\\n\", src, tmp, dest);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    log_state(\"outer_start\", src_size, *offset, *dest_size, 0, 0, src, tmp, *dest);\n    if (src_size > CHUNK_SIZE)\n    {\n      strm->avail_in = (uInt) CHUNK_SIZE;\n      src_size -= CHUNK_SIZE;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = (uInt) CHUNK_SIZE;\n      strm->next_out = (Bytef *) tmp;\n      /* call zlib deflate; unchanged */\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = (unsigned int)(CHUNK_SIZE - strm->avail_out);\n      log_state(\"after_deflate\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        log_state(\"realloc_fail\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      /* Log immediately before the memcpy that can read from \"tmp\" up to 'have' bytes. */\n      log_state(\"before_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n      log_state(\"after_memcpy\", src_size, *offset, *dest_size, have, flush, src, tmp, *dest);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n",
  "explanation": "The original failed because a macro named CHUNK was already defined (likely from an included header), so the declaration const size_t CHUNK = ... expanded incorrectly. I renamed the constant to CHUNK_SIZE and updated all uses. To make the file self-contained and compilable without external headers, I added minimal type/constant declarations for zlib- and libmicrohttpd-related symbols (z_stream, Bytef, uInt, deflate prototype, Z_* constants, and enum MHD_Result). No macros or functions were defined beyond what was necessary; the logic of compress_buf and logging is preserved."
}