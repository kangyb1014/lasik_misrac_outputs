{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'compress_buf': {'callees': [], 'callers': ['read_cb']}, 'read_cb': {'callees': ['compress_buf'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "CHUNK (macro)",
    "read_cb (caller) \u2014 caller code that allocates/passes the tmp buffer",
    "tmp buffer allocation/size in read_cb (the concrete size passed as the tmp argument)",
    "z_stream (type definition) \u2014 fields next_out, avail_out, next_in, avail_in and their types/semantics",
    "deflate (zlib) \u2014 prototype and behavioral contract (writes at most avail_out bytes to next_out and updates avail_out); constants Z_OK, Z_NO_FLUSH, Z_SYNC_FLUSH",
    "typedefs uInt and Bytef (zlib typedefs)",
    "realloc, memcpy, free (standard library semantics/prototypes)"
  ],
  "explanation": "For a correct MISRA analysis of memcpy usage and to determine whether accesses can go out-of-bounds you must know concrete buffer sizes and the producers/consumers of those sizes and counts:\n\n- CHUNK (macro): compress_buf uses CHUNK for avail_out, for computing have = CHUNK - strm->avail_out, and as the unit passed to tmp. You must know the numeric value of CHUNK to reason about maximum bytes copied and required tmp buffer size.\n\n- read_cb (caller) \u2014 caller code that allocates/passes the tmp buffer: compress_buf receives tmp from its caller. To prove memcpy does not read beyond tmp you must inspect the caller to see how tmp is allocated and what its size is.\n\n- tmp buffer allocation/size in read_cb: the analysis must know the actual number of bytes allocated for the tmp buffer (e.g. is it CHUNK bytes?). If tmp < have then memcpy(tmp, have) may read out-of-bounds.\n\n- z_stream (type definition) \u2014 fields next_out, avail_out, next_in, avail_in and their types/semantics: compress_buf depends on these fields (assigning avail_out = CHUNK, next_out = tmp, computing have from avail_out). Knowing their types (uInt/Bytef*) and semantics is necessary to reason about value ranges and pointer targets.\n\n- deflate (zlib) \u2014 prototype and behavioral contract (writes at most avail_out bytes to next_out and updates avail_out); constants Z_OK, Z_NO_FLUSH, Z_SYNC_FLUSH: The safety of have = CHUNK - strm->avail_out and the guarantee that deflate will not write more than CHUNK bytes into tmp relies on deflate semantics and on the meaning of the flush constants and return codes.\n\n- typedefs uInt and Bytef (zlib typedefs): to reason about integer widths, potential overflows, and pointer element size when computing byte counts.\n\n- realloc, memcpy, free (standard library semantics/prototypes): to reason about the post-realloc buffer size (realloc(*dest, *dest_size) must provide at least *dest_size bytes when non-NULL) and to know memcpy behavior (copies exactly the requested byte count from src to dest and requires src/dest to be valid for that many bytes) so you can conclude whether the destination write and source read are in-bounds.\n\nThese symbols together allow you to check (1) that 'have' cannot exceed tmp's allocated size, (2) that the destination region ((*dest) with size *dest_size after realloc) is large enough for the memcpy target, and (3) that the pointer arithmetic used for the memcpy source/destination does not produce out-of-bounds accesses."
}