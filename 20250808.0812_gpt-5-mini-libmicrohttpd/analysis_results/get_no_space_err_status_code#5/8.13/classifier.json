{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_no_space_err_status_code code that contains useful probe functions that print useful logs to a file \"/tmp/logs/43.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_no_space_err_status_code as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_no_space_err_status_code:\n```c\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n```\n</target_code>\nJudge whether the above get_no_space_err_status_code code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The function get_no_space_err_status_code takes a non-const pointer argument 'struct MHD_Connection *c' even though it only reads fields of the connection and does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Making 'c' a 'const struct MHD_Connection *' would be preferred, unless functions called with 'c' (e.g. MHD_lookup_connection_value_n) legitimately modify the connection. In the shown code, no modification of *c is performed in this function, so the non-const pointer is a violation scenario.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n\n/* Minimal stand-in definitions so this file is self-contained and\n   compilable. They are intentionally simple and do not modify the\n   connection object so that the example shows the pointer could be\n   const-qualified. */\n\nenum MHD_ProcRecvDataStage\n{\n  MHD_PROC_RECV_HEADERS,\n  MHD_PROC_RECV_BODY_CHUNKED\n};\n\nenum MHD_Connection_State\n{\n  MHD_CONNECTION_REQ_LINE_RECEIVED = 1,\n  MHD_CONNECTION_HEADERS_RECEIVED = 2\n};\n\nstruct field_lines_t {\n  char *start;\n  size_t size;\n};\n\nstruct request_t {\n  struct field_lines_t field_lines;\n  size_t req_target_len;\n  int http_mthd; /* treat as an int for simplicity */\n  char *method;\n};\n\nstruct MHD_Connection {\n  int state;\n  char *read_buffer;\n  size_t read_buffer_offset;\n  struct request_t rq;\n};\n\n/* Minimal constants used by the function */\n#define MHD_HTTP_CONTENT_TOO_LARGE 413\n#define MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE 431\n#define MHD_HTTP_NOT_IMPLEMENTED 501\n#define MHD_HTTP_URI_TOO_LONG 414\n\nstatic const size_t MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ = 4;\nstatic const size_t MHD_MAX_REASONABLE_HEADERS_SIZE_ = 1024;\nstatic const size_t MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ = 8192;\nstatic const size_t MHD_MIN_REASONABLE_HEADERS_SIZE_ = 32;\nstatic const size_t MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ = 64;\nstatic const size_t MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ = 4;\n\nstatic const char MHD_HTTP_HEADER_HOST[] = \"Host\";\n\n/* Minimal helpers that only read data (do not modify *c). */\nstatic int MHD_lookup_connection_value_n(const struct MHD_Connection *c,\n                                         int kind,\n                                         const char *key,\n                                         size_t key_len,\n                                         void *unused1,\n                                         size_t *value_len)\n{\n  (void)c; (void)kind; (void)key; (void)key_len; (void)unused1;\n  /* For testing, pretend a Host header of length 7 (e.g. example) exists. */\n  if (value_len != NULL)\n  {\n    *value_len = 7;\n    return 1; /* MHD_YES */\n  }\n  return 0; /* MHD_NO */\n}\n\nstatic int MHD_str_equal_caseless_bin_n_(const char *a, const char *b, size_t n)\n{\n  for (size_t i = 0; i < n; ++i)\n  {\n    unsigned char ca = (unsigned char)a[i];\n    unsigned char cb = (unsigned char)b[i];\n    if (ca >= 'A' && ca <= 'Z') ca += (char)('a' - 'A');\n    if (cb >= 'A' && cb <= 'Z') cb += (char)('a' - 'A');\n    if (ca != cb) return 0;\n  }\n  return 1;\n}\n\n/* Simple assertion function (no side-effects) */\nstatic void mhd_assert(int cond)\n{\n  (void)cond;\n}\n\n/* The modified get_no_space_err_status_code with logging to /tmp/logs/43.txt\n   to demonstrate the control flow and state information relevant to the\n   pointer const-qualification discussion. The original logic is preserved\n   as closely as possible. */\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  FILE *log = fopen(\"/tmp/logs/43.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entering get_no_space_err_status_code: c=%p, state=%d, stage=%d, add_element=%p, add_element_size=%zu\\n\",\n            (void *)c, c ? c->state : -1, (int)stage, (const void *)add_element, add_element_size);\n  }\n\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n    if (log) fprintf(log, \"Computed opt_headers_size (partial read buffer) = %zu\\n\", opt_headers_size);\n  }\n  else\n  {\n    opt_headers_size = c->rq.field_lines.size;\n    if (log) fprintf(log, \"Using opt_headers_size (stored) = %zu\\n\", opt_headers_size);\n  }\n\n  if (log) fprintf(log, \"Stage check: stage=%d, add_element_size=%zu\\n\", (int)stage, add_element_size);\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    if (log) fprintf(log, \"Returning CONTENT_TOO_LARGE (chunked and large add_element)\\n\");\n    if (log) fclose(log);\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    const size_t header_host_key_len = sizeof(MHD_HTTP_HEADER_HOST) - 1;\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (log) fprintf(log, \"is_host_header=%d\\n\", (int)is_host_header);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n      if (log) fprintf(log, \"Host header parsed: actual_element_size=%zu, opt_headers_size now=%zu\\n\",\n                       actual_element_size, opt_headers_size);\n    }\n  }\n\n  if (0 == host_field_line_size)\n  {\n    const size_t host_field_name_len = sizeof(MHD_HTTP_HEADER_HOST) - 1;\n    size_t host_field_name_value_len;\n    if (MHD_lookup_connection_value_n (c,\n                                      0,\n                                      MHD_HTTP_HEADER_HOST,\n                                      host_field_name_len,\n                                      NULL,\n                                      &host_field_name_value_len))\n    {\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* ':' and LF */\n\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0;\n\n      if (log) fprintf(log, \"Host from lookup: host_field_line_size=%zu, opt_headers_size=%zu\\n\",\n                       host_field_line_size, opt_headers_size);\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (/*MHD_HTTP_MTHD_OTHER !=*/ c->rq.http_mthd /* simplified */)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    if (log) fprintf(log, \"Large opt_headers_size branch: opt_headers_size=%zu, uri_size=%zu, method_size=%zu\\n\",\n                     opt_headers_size, uri_size, method_size);\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n      {\n        if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE\\n\"); if (log) fclose(log);\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return MHD_HTTP_NOT_IMPLEMENTED;\n      }\n    }\n    else\n    {\n      if ((uri_size / 16) > method_size)\n      {\n        if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n        return MHD_HTTP_URI_TOO_LONG;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return MHD_HTTP_NOT_IMPLEMENTED;\n      }\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    if (log) fprintf(log, \"URI too large branch: uri_size=%zu, method_size=%zu\\n\", uri_size, method_size);\n    if ((uri_size / 16) > method_size)\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n      return MHD_HTTP_URI_TOO_LONG;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n      return MHD_HTTP_NOT_IMPLEMENTED;\n    }\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    if (log) fprintf(log, \"Min reasonable headers branch: opt_headers_size=%zu, uri_size=%zu, method_size=%zu\\n\",\n                     opt_headers_size, uri_size, method_size);\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n      {\n        if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE\\n\"); if (log) fclose(log);\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return MHD_HTTP_NOT_IMPLEMENTED;\n      }\n    }\n    else\n    {\n      if (uri_size > method_size * 4)\n      {\n        if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n        return MHD_HTTP_URI_TOO_LONG;\n      }\n      else\n      {\n        if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n        return MHD_HTTP_NOT_IMPLEMENTED;\n      }\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    if (log) fprintf(log, \"Recommend shorter request target: uri_size=%zu, method_size=%zu\\n\", uri_size, method_size);\n    if (uri_size > method_size * 4)\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG\\n\"); if (log) fclose(log);\n      return MHD_HTTP_URI_TOO_LONG;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning NOT_IMPLEMENTED (method too large)\\n\"); if (log) fclose(log);\n      return MHD_HTTP_NOT_IMPLEMENTED;\n    }\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    if (log) fprintf(log, \"Method is very large: returning NOT_IMPLEMENTED\\n\"); if (log) fclose(log);\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n    {\n      if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE (final)\\n\"); if (log) fclose(log);\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    else\n    {\n      if (log) fprintf(log, \"Returning URI_TOO_LONG (final)\\n\"); if (log) fclose(log);\n      return MHD_HTTP_URI_TOO_LONG;\n    }\n  }\n\n  if (0 != host_field_line_size)\n  {\n    if (log) fprintf(log, \"Returning REQUEST_HEADER_FIELDS_TOO_LARGE (no reducible elements)\\n\"); if (log) fclose(log);\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n  }\n\n  if (log) fprintf(log, \"Returning URI_TOO_LONG (default) and exiting\\n\"); if (log) fclose(log);\n  return MHD_HTTP_URI_TOO_LONG;\n}\n"
}