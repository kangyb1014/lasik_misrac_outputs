{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    struct connection_info_struct *con_info;\n\n    con_info = malloc (sizeof (struct connection_info_struct));\n    if (NULL == con_info)\n      return MHD_NO;\n    con_info->answerstring = NULL;\n\n    if (0 == strcmp (method, \"POST\"))\n    {\n      con_info->postprocessor =\n        MHD_create_post_processor (connection, POSTBUFFERSIZE,\n                                   iterate_post, (void *) con_info);\n\n      if (NULL == con_info->postprocessor)\n      {\n        free (con_info);\n        return MHD_NO;\n      }\n\n      con_info->connectiontype = POST;\n    }\n    else\n      con_info->connectiontype = GET;\n\n    *req_cls = (void *) con_info;\n\n    return MHD_YES;\n  }\n\n  if (0 == strcmp (method, \"GET\"))\n  {\n    return send_page (connection, askpage);\n  }\n\n  if (0 == strcmp (method, \"POST\"))\n  {\n    struct connection_info_struct *con_info = *req_cls;\n\n    if (*upload_data_size != 0)\n    {\n      if (MHD_YES !=\n          MHD_post_process (con_info->postprocessor,\n                            upload_data,\n                            *upload_data_size))\n        return MHD_NO;\n      *upload_data_size = 0;\n\n      return MHD_YES;\n    }\n    else if (NULL != con_info->answerstring)\n      return send_page (connection, con_info->answerstring);\n  }\n\n  return send_page (connection, errorpage);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling strcmp(method, ...) without ensuring 'method' is a valid, null-terminated string can read past the bounds of the object referenced by 'method' (or dereference a NULL pointer). For example, if the HTTP library passes a non-null pointer that does not point to a NUL-terminated buffer (or passes NULL), the strcmp calls (strcmp(method, \"POST\") and strcmp(method, \"GET\")) can access memory beyond the object bounds, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection { int dummy; };\nstatic const int GET = 0;\nstatic const int POST = 1;\nstatic const size_t POSTBUFFERSIZE = 2048;\nvoid *MHD_create_post_processor(struct MHD_Connection *connection,\n                                size_t buffer_size,\n                                void (*iterator)(void *coninfo, const char *key, const char *filename, const char *content_type),\n                                void *coninfo);\nenum MHD_Result MHD_post_process(void *postprocessor, const char *upload_data, size_t size);\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  /* Log entry and some pointers/state; do not dereference method here. */\n  FILE *log = fopen(\"/tmp/logs/439.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"enter answer_to_connection: cls=%p, connection=%p, url=%p, method=%p, version=%p, req_cls_ptr=%p, *req_cls=%p, upload_data_size=%p\\n\",\n            cls, (void *) connection, (const void *) url, (const void *) method, (const void *) version,\n            (void *) req_cls, (void *) (req_cls ? *req_cls : NULL), (void *) upload_data_size);\n    fclose(log);\n  }\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    struct connection_info_struct *con_info;\n\n    con_info = malloc (sizeof (struct connection_info_struct));\n    if (NULL == con_info)\n      return MHD_NO;\n    con_info->answerstring = NULL;\n\n    if (0 == strcmp (method, \"POST\"))\n    {\n      con_info->postprocessor =\n        MHD_create_post_processor (connection, POSTBUFFERSIZE,\n                                   iterate_post, (void *) con_info);\n\n      if (NULL == con_info->postprocessor)\n      {\n        free (con_info);\n        return MHD_NO;\n      }\n\n      con_info->connectiontype = POST;\n    }\n    else\n      con_info->connectiontype = GET;\n\n    *req_cls = (void *) con_info;\n\n    return MHD_YES;\n  }\n\n  /* Log just prior to strcmp usages to capture the pointer value and note potential issue. */\n  log = fopen(\"/tmp/logs/439.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"about to compare method (pointer=%p) with \\\"GET\\\" and \\\"POST\\\"\\n\", (const void *) method);\n    fclose(log);\n  }\n\n  if (0 == strcmp (method, \"GET\"))\n  {\n    return send_page (connection, askpage);\n  }\n\n  if (0 == strcmp (method, \"POST\"))\n  {\n    struct connection_info_struct *con_info = *req_cls;\n\n    if (*upload_data_size != 0)\n    {\n      if (MHD_YES !=\n          MHD_post_process (con_info->postprocessor,\n                            upload_data,\n                            *upload_data_size))\n        return MHD_NO;\n      *upload_data_size = 0;\n\n      return MHD_YES;\n    }\n    else if (NULL != con_info->answerstring)\n      return send_page (connection, con_info->answerstring);\n  }\n\n  return send_page (connection, errorpage);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 requires that calls to the <string.h> functions must not cause accesses beyond the bounds of the objects referenced by the pointer parameters. strcmp reads both operands until it finds a NUL byte, and it dereferences the pointers; therefore the operands must be valid, non-NULL pointers to NUL-terminated buffers (or otherwise proven to have sufficient accessible storage). In the posted answer_to_connection the code calls strcmp(method, \"POST\") and strcmp(method, \"GET\") without first checking that method is non-NULL or otherwise guaranteed to be a valid NUL-terminated string by the surrounding context. If the HTTP library ever supplied a NULL pointer or a pointer to a non-NUL-terminated buffer the strcmp calls could read out of bounds (or dereference NULL), which would violate Rule 21.17.\n\nSo the agent A report is correct in the general sense: the code, as written, can violate MISRA C 2023 Rule 21.17 unless there is an explicit, documented API contract that method is always a valid, non-NULL, NUL-terminated string. If such a contract exists and is relied upon, the code is acceptable; otherwise it should be hardened (for example, check method != NULL before use, or use an API that provides method length or otherwise prove the buffer bounds prior to calling strcmp)."
}