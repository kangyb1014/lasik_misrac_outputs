{
  "user_message": "Target function code is:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}, 'MHD_create_thread_': {'callees': [], 'callers': ['MHD_create_named_thread_']}, 'new_connection_process_': {'callees': ['MHD_pool_create', 'MHD_DLOG', '__builtin_unreachable', 'MHD_connection_set_initial_state_', 'MHD_create_named_thread_', 'MHD_pool_destroy', 'MHD_ip_limit_del'], 'callers': ['internal_add_connection', 'new_connections_list_process_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_thread_handle_ID_ (type/definition)",
    "MHD_thread_handle_ID_get_native_handle_ptr_ (prototype)",
    "MHD_thread_handle_ID_set_invalid_ (prototype/implementation)",
    "MHD_thread_handle_ID_set_native_handle_ (prototype/implementation)",
    "struct MHD_named_helper_param_ (definition)",
    "named_thread_starter (function signature/implementation)",
    "MHD_create_thread_ (prototype/signature and parameter types)",
    "MHD_THREAD_START_ROUTINE_ (typedef/signature)",
    "pthread_attr_setname_np variants (prototypes for the HAVE_* variants used)"
  ],
  "explanation": "Why each symbol is required for MISRA C const-pointer analysis:\n\n- MHD_thread_handle_ID_ (type/definition): The function takes MHD_thread_handle_ID_ *handle_id. To decide whether the pointer should be const-qualified we must know the actual type and whether its pointed-to object is modified by callees. The concrete type definition helps determine whether any fields are modified directly or indirectly and whether const would be appropriate.\n\n- MHD_thread_handle_ID_get_native_handle_ptr_ (prototype): This function (when present) returns a pointer into the handle object (pthread_t *). Its prototype/semantics indicate whether it modifies the handle or returns a writable pointer; that affects whether handle_id can be const.\n\n- MHD_thread_handle_ID_set_invalid_ (prototype/implementation): Called in this function when an error occurs. Its implementation/prototype shows that it modifies the handle object; thus handle_id must not be const. Required to demonstrate mutation.\n\n- MHD_thread_handle_ID_set_native_handle_ (prototype/implementation): Called to store new_tid into the handle. Its prototype/implementation confirms it mutates the handle object, proving handle_id must be non-const.\n\n- struct MHD_named_helper_param_ (definition): In the non-MHD_USE_THREAD_ATTR_SETNAME branch the code mallocs this struct and assigns param->name = thread_name. To check whether the pointer-to-name should be const, we need to know the declared type of the name member (char * vs const char *). If name is non-const but the code never mutates the underlying string, MISRA suggests it should be const; conversely, if name is later modified, it must remain non-const.\n\n- named_thread_starter (function signature/implementation): This function is passed param as the starter for the created thread and is responsible for setting the thread name inside the thread. We must inspect whether named_thread_starter writes to param->name or to the string pointed to by name. If it modifies the string, name (and therefore thread_name) must not be const; if it only reads it, the pointer could be const.\n\n- MHD_create_thread_ (prototype/signature and parameter types): The code calls MHD_create_thread_(handle_id, stack_size, &named_thread_starter, (void *) param). We must know the expected type of the start routine and arg parameter, and whether MHD_create_thread_ will store/copy/modify the arg or call the starter in a way that would require non-const. Its signature also shows whether arg is treated as const void * or void *, which affects whether passing a const pointer would be allowed.\n\n- MHD_THREAD_START_ROUTINE_ (typedef/signature): The start routine type used throughout determines whether thread start functions accept void * or const void * for their argument and whether they are expected to modify the object pointed to. This affects whether the arg and any contained name pointer must be const or non-const.\n\n- pthread_attr_setname_np variants (prototypes for the HAVE_* variants used): In the MHD_USE_THREAD_ATTR_SETNAME branch thread_name is passed to platform-specific pthread_attr_setname_np variants. If any variant's prototype accepts a non-const char * and potentially modifies the string, then thread_name must not be const. Inspecting those prototypes/semantics confirms whether passing a const char * is safe and whether the parameter declarations should be const-qualified.\n\nIncluding these symbols allows examining every place the function (and its arguments) are stored, passed, or potentially modified, which is necessary to determine correct const qualifications of pointer types under the MISRA rule."
}