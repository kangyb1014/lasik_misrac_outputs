{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A caller provides a username or realm that is not NUL-terminated (for example, a fixed-size buffer filled from network input without a terminating '\\0'). The function calls strlen(username) / strlen(realm) which will scan memory beyond the object's bounds looking for a NUL byte, causing an out-of-bounds access (undefined behavior).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_DigestAuthAlgo3 { MHD_DIGEST_ALGO_3_PLACEHOLDER = 0 };\nextern int digest_init_one_time (struct DigestAlgorithm *da, int base_algo);\nextern void digest_deinit (struct DigestAlgorithm *da);\nextern int digest_ext_error (struct DigestAlgorithm *da);\n\nenum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  /* Open a log file to record control path and state relevant to the\n     potential out-of-bounds access when calling strlen on caller-provided\n     pointers. The logging does not change the original logic. */\n  FILE *logf = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER: MHD_digest_auth_calc_userdigest: algo3=%u, username_ptr=%p, realm_ptr=%p, password_ptr=%p, bin_buf_size=%zu\\n\",\n            (unsigned) algo3, (const void *) username, (const void *) realm,\n            (const void *) password, bin_buf_size);\n  }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (logf != NULL)\n    {\n      fprintf(logf, \"EXIT: digest_init_one_time failed\\n\");\n      fclose(logf);\n    }\n    return MHD_NO;\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    /* Compute lengths exactly as original code did via strlen; we store\n       them in locals so we can log them without changing the behavior. */\n    size_t username_len = 0u;\n    size_t realm_len = 0u;\n\n    /* These strlen calls are the source of the potential Rule 21.17\n       violation if the caller provided pointers that are not NUL-terminated\n       within their object bounds. We log the computed lengths. */\n    username_len = strlen (username);\n    realm_len = strlen (realm);\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"BEFORE calc_userdigest: username_len=%zu, realm_len=%zu, expected_bin_size=%u\\n\",\n              username_len, realm_len, (unsigned) digest_get_size(&da));\n    }\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"AFTER calc_userdigest: ret=%d\\n\", (int) ret);\n    }\n  }\n  digest_deinit (&da);\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"EXIT: MHD_digest_auth_calc_userdigest returning %d\\n\", (int) ret);\n    fclose(logf);\n  }\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls strlen(username) and strlen(realm) on caller-supplied char pointers without any bounds or termination checks. strlen scans memory until it finds a NUL byte; if the caller supplies a non\u2011NUL\u2011terminated buffer (or a pointer to an object whose accessible bytes do not include a terminating '\\0'), those strlen calls can read past the object bounds, producing undefined behavior and violating MISRA C 2023 Rule 21.17. \n\nTo conform, the code must ensure the accesses cannot exceed the object bounds (for example: accept and use explicit lengths, use a bounded variant such as strnlen with a known maximum that is guaranteed not to exceed the object, or otherwise establish and document/verify the precondition that the pointers reference NUL-terminated arrays of sufficient size). As written, there is no such guarantee or check, so the reported violation is valid."
}