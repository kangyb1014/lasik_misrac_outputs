{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  /* Open a log file to record control path and state relevant to the\n     potential out-of-bounds access when calling strlen on caller-provided\n     pointers. The logging does not change the original logic. */\n  FILE *logf = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER: MHD_digest_auth_calc_userdigest: algo3=%u, username_ptr=%p, realm_ptr=%p, password_ptr=%p, bin_buf_size=%zu\\n\",\n            (unsigned) algo3, (const void *) username, (const void *) realm,\n            (const void *) password, bin_buf_size);\n  }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (logf != NULL)\n    {\n      fprintf(logf, \"EXIT: digest_init_one_time failed\\n\");\n      fclose(logf);\n    }\n    return MHD_NO;\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    /* Compute lengths exactly as original code did via strlen; we store\n       them in locals so we can log them without changing the behavior. */\n    size_t username_len = 0u;\n    size_t realm_len = 0u;\n\n    /* These strlen calls are the source of the potential Rule 21.17\n       violation if the caller provided pointers that are not NUL-terminated\n       within their object bounds. We log the computed lengths. */\n    username_len = strlen (username);\n    realm_len = strlen (realm);\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"BEFORE calc_userdigest: username_len=%zu, realm_len=%zu, expected_bin_size=%u\\n\",\n              username_len, realm_len, (unsigned) digest_get_size(&da));\n    }\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"AFTER calc_userdigest: ret=%d\\n\", (int) ret);\n    }\n  }\n  digest_deinit (&da);\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"EXIT: MHD_digest_auth_calc_userdigest returning %d\\n\", (int) ret);\n    fclose(logf);\n  }\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpve61qeqx/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_digest_auth_calc_userdigest as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Minimal type declarations so this translation unit compiles cleanly.\n   Real definitions are expected to be provided elsewhere in the project. */\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Placeholder enum for the algorithm selector. Real values live elsewhere. */\nenum MHD_DigestAuthAlgo3 { MHD_DIGEST_ALGO_3_PLACEHOLDER = 0 };\n\n/* The DigestAlgorithm structure is instantiated locally in the function,\n   so provide an opaque-but-sized struct. Real structure definition should\n   come from the library's headers in the real build. */\nstruct DigestAlgorithm { int _internal; };\n\n/* External functions used by MHD_digest_auth_calc_userdigest.\n   Only prototypes are provided so this file compiles; actual\n   implementations are expected in other compilation units. */\nextern int digest_init_one_time (struct DigestAlgorithm *da, int base_algo);\nextern int get_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3);\nextern size_t digest_get_size (struct DigestAlgorithm *da);\nextern void calc_userdigest (struct DigestAlgorithm *da,\n                             const char *username, size_t username_len,\n                             const char *realm, size_t realm_len,\n                             const char *password, void *userdigest_bin);\nextern void digest_deinit (struct DigestAlgorithm *da);\nextern int digest_ext_error (struct DigestAlgorithm *da);\n\n/* The original declaration used an export macro (_MHD_EXTERN). Remove\n   that macro here so the unit is self-contained. The logic of the\n   function is preserved exactly as in the original source. */\n\nenum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  /* Open a log file to record control path and state relevant to the\n     potential out-of-bounds access when calling strlen on caller-provided\n     pointers. The logging does not change the original logic. */\n  FILE *logf = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (logf != NULL)\n  {\n    fprintf(logf, \"ENTER: MHD_digest_auth_calc_userdigest: algo3=%u, username_ptr=%p, realm_ptr=%p, password_ptr=%p, bin_buf_size=%zu\\n\",\n            (unsigned) algo3, (const void *) username, (const void *) realm,\n            (const void *) password, bin_buf_size);\n  }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (logf != NULL)\n    {\n      fprintf(logf, \"EXIT: digest_init_one_time failed\\n\");\n      fclose(logf);\n    }\n    return MHD_NO;\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    /* Compute lengths exactly as original code did via strlen; we store\n       them in locals so we can log them without changing the behavior. */\n    size_t username_len = 0u;\n    size_t realm_len = 0u;\n\n    /* These strlen calls are the source of the potential Rule 21.17\n       violation if the caller provided pointers that are not NUL-terminated\n       within their object bounds. We log the computed lengths. */\n    username_len = strlen (username);\n    realm_len = strlen (realm);\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"BEFORE calc_userdigest: username_len=%zu, realm_len=%zu, expected_bin_size=%u\\n\",\n              username_len, realm_len, (unsigned) digest_get_size(&da));\n    }\n\n    calc_userdigest (&da,\n                     username,\n                     username_len,\n                     realm,\n                     realm_len,\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (logf != NULL)\n    {\n      fprintf(logf, \"AFTER calc_userdigest: ret=%d\\n\", (int) ret);\n    }\n  }\n  digest_deinit (&da);\n\n  if (logf != NULL)\n  {\n    fprintf(logf, \"EXIT: MHD_digest_auth_calc_userdigest returning %d\\n\", (int) ret);\n    fclose(logf);\n  }\n\n  return ret;\n}\n",
  "explanation": "To make the file compile as a standalone translation unit I: 1) added the necessary standard headers (<stdio.h>, <string.h>, <stddef.h>), 2) removed the undefined _MHD_EXTERN macro from the function signature, and 3) supplied minimal type declarations (enum MHD_Result, enum MHD_DigestAuthAlgo3, struct DigestAlgorithm) and external function prototypes for the digest helper functions. These changes preserve the original function logic while ensuring the code compiles; the actual implementations of the extern functions and the real type definitions are expected to be provided elsewhere in the full project."
}