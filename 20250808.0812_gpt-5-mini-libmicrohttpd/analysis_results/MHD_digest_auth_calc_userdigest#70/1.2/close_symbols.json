{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_calc_userdigest': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userdigest'], 'callers': ['add_new_user_entry']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'get_base_digest_algo': {'callees': [], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calc_userdigest': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userdigest', 'digest_auth_check_all_inner']}, 'add_new_user_entry': {'callees': ['MHD_digest_auth_calc_userhash', 'MHD_digest_auth_calc_userdigest'], 'callers': ['add_new_users']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN (macro definition)",
    "enum MHD_Result (definition and enumerators MHD_YES, MHD_NO)",
    "enum MHD_DigestAuthAlgo3 (definition)",
    "struct DigestAlgorithm (definition)",
    "digest_init_one_time (prototype/definition)",
    "get_base_digest_algo (prototype/definition)",
    "digest_get_size (prototype/definition)",
    "calc_userdigest (prototype/definition)",
    "digest_deinit (prototype/definition)",
    "digest_ext_error (prototype/definition)",
    "MHD_DIGEST_HAS_EXT_ERROR (macro definition)"
  ],
  "explanation": "For checking MISRA rule about language extensions we must inspect any symbols that could introduce compiler-specific extensions (attributes, storage-class macros, calling-convention keywords, non\u2011standard types, or other compiler extensions) into the translation unit of the target function. Explaination for each: \n\n- _MHD_EXTERN (macro definition): This macro prefixes the function and may expand to compiler-specific storage-class or attribute syntax (e.g. __attribute__, __declspec, visibility, extern \"C\" wrappers). Its expansion must be examined for extensions.\n\n- enum MHD_Result (definition and enumerators MHD_YES, MHD_NO): The enum type and its enumerators are used in the function signature and body; their declaration might use non\u2011standard syntax or macros and is part of the translation unit.\n\n- enum MHD_DigestAuthAlgo3 (definition): The parameter type for the function. Its declaration could contain extensions (e.g. underlying type specifiers) or macros.\n\n- struct DigestAlgorithm (definition): Local variable da is of this type; the struct definition or any annotations on it (packed, aligned, attributes) could be compiler extensions.\n\n- digest_init_one_time (prototype/definition): Called at function start; its prototype or definition may carry attributes (e.g. __attribute__, inline, noreturn) or non\u2011standard qualifiers affecting whether the target uses extensions by inclusion of that declaration.\n\n- get_base_digest_algo (prototype/definition): Called to build a parameter for digest_init_one_time; its declaration might use extensions.\n\n- digest_get_size (prototype/definition): Its prototype or inline/attribute decorations must be checked for language extensions.\n\n- calc_userdigest (prototype/definition): The heavy call inside the function \u2014 its declaration may include attributes or nonstandard parameter annotations (and could bring extension macros into the TU).\n\n- digest_deinit (prototype/definition): Called at end; its declaration may use extensions.\n\n- digest_ext_error (prototype/definition): Used inside the optional MHD_DIGEST_HAS_EXT_ERROR block \u2014 its declaration may include extensions and the symbol is conditionally compiled into the function.\n\n- MHD_DIGEST_HAS_EXT_ERROR (macro definition): Controls conditional compilation inside the function. Its definition may be set/unset by build system or headers and might be tied to extension-specific code paths; must be known to decide what code is actually present and whether any extension-bearing code is compiled in.\n\nIn short: inspect these macro definitions, type declarations, and function prototypes/definitions to see whether any use compiler-specific keywords or attributes. Standard library symbols (size_t, strlen) are assumed standard and need not be listed here."
}