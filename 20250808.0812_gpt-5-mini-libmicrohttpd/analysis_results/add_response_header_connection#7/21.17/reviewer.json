{
  "user_message": "An agent A claimed that the following add_response_header_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_header_connection.\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function can write beyond the allocated buffer when inserting the \"close\" token: memmove copies norm_len + 1 bytes from buf + old_value_len to buf + old_value_len + prefix_length, but buf was allocated with size old_value_len + norm_len (no extra space for the prefix or the extra byte). The code relies on mhd_assert to check sufficient space but mhd_assert is a no-op, so the memcpy/memmove may access/write beyond the allocated buf causing out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nstatic const int MHD_HEADER_KIND = 1;\nstatic const unsigned int MHD_RAF_HAS_CONNECTION_HDR = 0x01u;\nstatic const unsigned int MHD_RAF_HAS_CONNECTION_CLOSE = 0x02u;\nstatic void mhd_assert (int cond)\n{\n  assert (cond);\n}\nstatic size_t mhd_staticstr_len (const char *s)\n{\n  return strlen (s);\n}\nstatic void _MHD_insert_header_first (struct MHD_Response *resp,\n                                      struct MHD_HTTP_Res_Header *hdr)\n{\n  if (! resp || ! hdr) return;\n  hdr->next = resp->headers;\n  resp->headers = hdr;\n}\nstatic void trim_bounds (const char **pstart, size_t *plen)\n{\n  const char *s = *pstart;\n  size_t n = *plen;\n  while (n > 0 && isspace ((unsigned char) s[0]))\n  {\n    s++; n--;\n  }\n  while (n > 0 && isspace ((unsigned char) s[n - 1]))\n    n--;\n  *pstart = s;\n  *plen = n;\n}\nstatic int token_eq_caseless (const char *a, size_t a_len,\n                              const char *b, size_t b_len)\n{\n  if (a_len != b_len) return 0;\n  for (size_t i = 0; i < a_len; ++i)\n    if (tolower ((unsigned char) a[i]) != tolower ((unsigned char) b[i]))\n      return 0;\n  return 1;\n}\n\nstatic struct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *resp, int kind,\n                             const char *key, size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *h;\n  if (! resp) return NULL;\n  for (h = resp->headers; h; h = h->next)\n  {\n    if (h->kind == kind && h->header && h->header_size == key_len &&\n        0 == memcmp (h->header, key, key_len))\n      return h;\n  }\n  return NULL;\n}\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  const char *key = MHD_HTTP_HEADER_CONNECTION;\n  size_t key_len = strlen (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /* length of value */\n  size_t old_value_len; /* length of existing Connection value (+2 if present) */\n  size_t buf_size;  /* size of buffer */\n  size_t norm_len;  /* length of normalised value */\n  char *buf;        /* temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /* existing Connection header */\n  bool value_has_close; /* value has \"close\" token */\n  bool already_has_close; /* existing Connection header has close */\n  size_t pos = 0; /* position of addition in buf */\n\n  /* Probe: log entry and input checks */\n  {\n    FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf (f, \"add_response_header_connection: entry value=%p\\n\", (void *) value);\n      fclose (f);\n    }\n  }\n\n  if ( (NULL != strchr (value, '\\r')) || (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* hdr may be NULL if something inconsistent; keep assertion similar */\n    if (hdr != NULL)\n      mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  /* Probe: log computed sizes before allocation */\n  {\n    FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf (f, \"computed: value_len=%zu norm_len=%zu old_value_len=%zu buf_size=%zu\\n\",\n               value_len, norm_len, old_value_len, buf_size);\n      fclose (f);\n    }\n  }\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n\n  {\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      mhd_staticstr_len (\"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     mhd_staticstr_len (\"keep-alive\"));\n\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len + mhd_staticstr_len (\"close, \") + 1);\n\n    /* Probe: log intention to memmove and sizes involved */\n    {\n      FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n      if (f != NULL)\n      {\n        fprintf (f, \"about to memmove: old_value_len=%zu norm_len=%zu buf_size=%zu prefix=%zu\\n\",\n                 old_value_len, norm_len, buf_size, (size_t) mhd_staticstr_len (\"close, \"));\n        fclose (f);\n      }\n    }\n\n    if (0 != norm_len)\n      memmove (buf + mhd_staticstr_len (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", mhd_staticstr_len (\"close\"));\n    pos += mhd_staticstr_len (\"close\");\n  }\n\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value, hdr->value_size);\n    pos += hdr->value_size;\n  }\n\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ?\n                (mhd_staticstr_len (\"close, \") + old_value_len == pos) :\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n\n  /* Probe: log final positions before termination */\n  {\n    FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (f != NULL)\n    {\n      fprintf (f, \"final: pos=%zu buf_size=%zu (buf_size>pos=%d) value_has_close=%d already_has_close=%d\\n\",\n               pos, buf_size, (int) (buf_size > pos), (int) value_has_close, (int) already_has_close);\n      fclose (f);\n    }\n  }\n\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /* new Connection header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code allocates buf_size = old_value_len + norm_len (where norm_len was computed as a capacity for the normalized value including space for a terminating NUL). Later, when value_has_close && !already_has_close, the code does\n  if (0 != norm_len)\n    memmove(buf + prefix + old_value_len, buf + old_value_len, norm_len + 1);\nwhich moves norm_len+1 bytes (the normalized bytes plus the NUL) to a destination that starts prefix bytes further into the same buffer. The allocated space after that destination is buf_size - (prefix + old_value_len) = norm_len - prefix, so the memmove will write past the end of the allocation whenever prefix > 0 (and typically prefix == length of \"close, \" > 0). The code contains an mhd_assert that would check for sufficient space, but assertions can be no-ops in production, so the code still allows an out-of-bounds access. This is precisely a violation of MISRA C 2023 Rule 21.17 (use of string functions must not result in accesses beyond object bounds)."
}