{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_response_header_connection': {'callees': ['MHD_get_response_element_n_'], 'callers': ['MHD_add_response_header']}, 'MHD_get_response_element_n_': {'callees': [], 'callers': ['add_response_header_connection', 'del_response_header_connection', 'MHD_add_response_header', 'MHD_del_response_header']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "struct MHD_HTTP_Res_Header",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_STATICSTR_LEN_",
    "MHD_str_remove_token_caseless_",
    "MHD_str_remove_tokens_caseless_",
    "MHD_get_response_element_n_",
    "MHD_calloc_",
    "_MHD_insert_header_first",
    "SSIZE_MAX",
    "mhd_assert",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_HEADER_KIND",
    "enum MHD_Result (MHD_YES,MHD_NO)",
    "malloc",
    "free",
    "strlen",
    "strchr",
    "memcmp",
    "memcpy",
    "memmove"
  ],
  "explanation": "For a correct MISRA <string.h> bounds analysis you must know the exact data layouts, length semantics and contracts of the helper functions/macros used in add_response_header_connection. Brief explanation of why each symbol is required:\n\n- struct MHD_Response\n  - Needed to know what fields exist (flags_auto, upgrade_handler, headers/list pointer) and the types/widths used when computing or checking sizes (response->flags_auto, response->upgrade_handler). These affect control flow and bounds decisions (e.g. early return when upgrade_handler present).\n\n- struct MHD_HTTP_Res_Header\n  - Required to interpret hdr->value and hdr->value_size semantics (is value_size the byte count excluding/including NUL?) and to determine whether copying hdr->value of hdr->value_size bytes is within allocated storage. Also needed for header/header_size use when creating a new header.\n\n- MHD_HTTP_HEADER_CONNECTION\n  - The constant string used to set key and copied with memcpy; its exact length determines key_len and the malloc size (key_len + 1). Must know its actual characters/length to ensure the copy (memcpy(key, key, key_len+1)) does not overrun.\n\n- MHD_STATICSTR_LEN_\n  - Macro used repeatedly to derive key_len and literal lengths (\"close\", \"close, \", \"keep-alive\"). You must know whether it returns strlen (number of bytes before NUL) or includes NUL etc. The code relies on key_len and these lengths to allocate and to compute memmove/memcpy offsets and assertions.\n\n- MHD_str_remove_token_caseless_\n  - This function writes normalized tokens into buf+old_value_len and updates norm_len_s. You must know its exact contract: how many bytes it may write relative to the provided normalization buffer, whether it NUL-terminates, and the meaning of the returned value and of norm_len_s on success/failure. Safety of subsequent memcpy/memmove and of buf sizing depends on its behavior and output length.\n\n- MHD_str_remove_tokens_caseless_\n  - Similar to above: it mutates the buffer in place and adjusts norm_len. Its exact behavior (how it shortens data and whether it NUL-terminates) is required to reason about bounds for later memmove/memcpy and the final buf[pos] = 0.\n\n- MHD_get_response_element_n_\n  - Returns hdr used by the function. Must know whether it can return a pointer to internal structures whose value/value_size are stable, whether value is NUL-terminated, and the semantics of value_size. These determine whether reading hdr->value_size and copying hdr->value are safe.\n\n- MHD_calloc_\n  - Allocation wrapper used to allocate struct MHD_HTTP_Res_Header; understanding whether it mirrors standard calloc semantics (zeroed allocation) and any failure modes is necessary for ownership/cleanup reasoning (not strictly a memcpy bound, but required to follow allocation success paths).\n\n- _MHD_insert_header_first\n  - Called after constructing new_hdr; its ownership and side-effects (does it copy the header/value or adopt pointers?) affect whether the code is correctly managing buffer ownership and whether subsequent frees/assignments are valid. For bounds analysis we need to know if it expects null-terminated strings and if it makes internal copies (which would require sizes to be correct).\n\n- SSIZE_MAX\n  - Used in range checks for value_len and norm_len (compared against SSIZE_MAX). You must know its value/meaning on the target platform to validate that the numeric checks actually prevent overflows or out-of-range sizes provided to string functions.\n\n- mhd_assert\n  - Assertions are used to check invariants (e.g. existing \"close\" token presence). You must know whether mhd_assert is compiled out in production (i.e. has no effect) because the function logic may rely on them only in debug builds; understanding whether assertions provide safety guarantees at runtime matters for MISRA compliance reasoning.\n\n- MHD_RAF_HAS_CONNECTION_HDR and MHD_RAF_HAS_CONNECTION_CLOSE\n  - Flag bit values and semantics: required to know exclusivity/overlap and how flags_auto is used to infer presence of hdr and of the \"close\" token (affects control flow and whether certain memcpy/memmove branches execute).\n\n- MHD_HEADER_KIND\n  - The enum/constant used when creating/getting headers. Its meaning ensures the correct header entry type is retrieved/inserted; affects which hdr->value and lengths you will be working with.\n\n- enum MHD_Result (MHD_YES, MHD_NO)\n  - Return values used by the function; necessary to understand calling conventions and error paths (which free buffers and which proceed to write into buffers). This affects which branches could lead to buffer writes.\n\n- malloc and free\n  - Standard allocation functions used for buf and new_hdr->header; must assume standard semantics and check that sizes passed to malloc are correct and that later writes (memcpy/memmove and buf[pos]=0) fall within malloc'd sizes.\n\n- strlen\n  - Used to compute value_len. You must assume standard strlen semantics and ensure that the value pointer passed in is a valid NUL-terminated string, and that the result does not lead to size_t/SSIZE_MAX issues.\n\n- strchr\n  - Used to check for CR/LF in value. Its result influences early return; you must know standard semantics for pointer scans to know whether value is valid for strchr.\n\n- memcmp\n  - Used in an assertion comparing hdr->value to \"close\"; need to know the number of bytes compared and that hdr->value has at least that many bytes available.\n\n- memcpy and memmove\n  - The main Standard Library copy/move operations whose parameter sizes must be proven in-bounds. You must know each call-site size argument (e.g. key_len+1, hdr->value_size, norm_len+1 and other computed offsets) and validate them against the allocated buffer sizes (malloc/calloc and existing hdr->value allocations). Their use depends on all the above symbols (allocation sizes, value_size semantics, tokens removal functions and MHD_STATICSTR_LEN_ macro) to ensure no out-of-bounds access.\n\nIn short: to determine compliance with the MISRA string-bounds rule you need the data-structure definitions and the exact contracts/behaviour of the MHD helper macros/functions that compute lengths or mutate buffers (MHD_STATICSTR_LEN_, MHD_str_remove_token_caseless_, MHD_str_remove_tokens_caseless_, MHD_get_response_element_n_, _MHD_insert_header_first, and the flags/consts). You also must know the platform limits (SSIZE_MAX) and whether assertions are present at runtime (mhd_assert). With those symbols you can validate each memcpy/memmove/memcmp/strlen/strchr call-site against allocated/advertised sizes and prove (or disprove) absence of out-of-bounds accesses."
}