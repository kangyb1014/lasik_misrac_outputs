{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nenum MHD_YesNo { MHD_NO = 0, MHD_YES = 1 };\nstruct MHD_Response {\n  const void *buf;\n  size_t len;\n};\nconst char *MHD_HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\nstruct MHD_Response *\nMHD_create_response_from_buffer_static (size_t len, const void *buf)\n{\n  struct MHD_Response *r = (struct MHD_Response *) malloc (sizeof (*r));\n  if (r != NULL)\n  {\n    r->buf = buf;\n    r->len = len;\n  }\n  return r;\n}\nenum MHD_YesNo\nMHD_add_response_header (struct MHD_Response *resp,\n                         const char *header,\n                         const char *value)\n{\n  /* pretend it always succeeds */\n  (void) resp; (void) header; (void) value;\n  return MHD_YES;\n}\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *conn,\n                    int status_code,\n                    struct MHD_Response *resp)\n{\n  /* log queueing event for visibility */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"MHD_queue_response: conn=%p status=%d resp=%p len=%zu\\n\",\n             (void *) conn, status_code, (void *) resp, (resp ? resp->len : 0));\n    fclose (f);\n  }\n  (void) resp; (void) status_code; (void) conn;\n  return MHD_HTTP_OK;\n}\nvoid\nMHD_destroy_response (struct MHD_Response *resp)\n{\n  free (resp);\n}\nvoid probe_violation (void)\n{\n  /* ensure log directory exists (ignore errors) */\n  (void) mkdir (\"/tmp/logs\", 0777);\n\n  struct Container {\n    char a[4];    /* not NUL-terminated */\n    char term;    /* adjacent member holding the terminator */\n  } c;\n\n  c.a[0] = 'A'; c.a[1] = 'B'; c.a[2] = 'C'; c.a[3] = 'D';\n  c.term = '\\0'; /* terminator lives in the adjacent object */\n\n  /* log the setup so test log shows why strlen must read past c.a */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"probe_violation: container at %p, a=%p, term at %p value=0x%02X\\n\",\n             (void *) &c, (void *) c.a, (void *) &c.term, (unsigned char) c.term);\n    fclose (f);\n  }\n\n  /* Call serve_simple_form with a pointer to the non-NUL-terminated array. */\n  (void) serve_simple_form ((const void *) c.a, \"text/html\", NULL, NULL);\n}\n\nvoid\nadd_session_cookie (struct Session *session, struct MHD_Response *response)\n{\n  (void) session; (void) response; /* no-op for this test harness */\n}\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* log entry and the bytes at the start of form (not assuming NUL) */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"enter serve_simple_form: form=%p mime=%s session=%p connection=%p\\n\",\n               (void *) form, (mime ? mime : \"(null)\"), (void *) session, (void *) connection);\n      /* dump a few bytes starting at form for visibility (print as chars and hex) */\n      if (form != NULL)\n      {\n        fprintf (f, \"form bytes: \");\n        for (size_t i = 0U; i < 8U; ++i)\n        {\n          unsigned char c = (unsigned char) form[i];\n          fprintf (f, \"%c(0x%02X) \", (c >= 32 && c < 127) ? (char) c : '.', c);\n        }\n        fprintf (f, \"\\n\");\n      }\n      fclose (f);\n    }\n  }\n\n  /* return static form */\n  {\n    size_t len = strlen (form); /* POTENTIAL OUT-OF-BOUNDS read if 'form' isn't NUL-terminated */\n\n    /* log the computed length */\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"strlen(form) -> %zu\\n\", len);\n      fclose (f);\n    }\n\n    response = MHD_create_response_from_buffer_static (len, form);\n  }\n\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* log exit */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"exit serve_simple_form: ret=%d\\n\", ret);\n      fclose (f);\n    }\n  }\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpp2k8sv6c/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of serve_simple_form as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nenum MHD_YesNo { MHD_NO = 0, MHD_YES = 1 };\n\n/* Minimal definitions to make the test code self-contained. These are\n   simple opaque types so the rest of the code can compile. */\nstruct MHD_Connection { void *opaque; };\nstruct Session { void *opaque; };\n\nenum MHD_Result { MHD_HTTP_OK = 0, MHD_HTTP_INTERNAL_SERVER_ERROR = 1 };\n\nstruct MHD_Response {\n  const void *buf;\n  size_t len;\n};\nconst char *MHD_HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\n\n/* forward declaration so probe_violation can call it */\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection);\n\nstruct MHD_Response *\nMHD_create_response_from_buffer_static (size_t len, const void *buf)\n{\n  struct MHD_Response *r = (struct MHD_Response *) malloc (sizeof (*r));\n  if (r != NULL)\n  {\n    r->buf = buf;\n    r->len = len;\n  }\n  return r;\n}\n\nenum MHD_YesNo\nMHD_add_response_header (struct MHD_Response *resp,\n                         const char *header,\n                         const char *value)\n{\n  /* pretend it always succeeds */\n  (void) resp; (void) header; (void) value;\n  return MHD_YES;\n}\n\nenum MHD_Result\nMHD_queue_response (struct MHD_Connection *conn,\n                    int status_code,\n                    struct MHD_Response *resp)\n{\n  /* log queueing event for visibility */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"MHD_queue_response: conn=%p status=%d resp=%p len=%zu\\n\",\n             (void *) conn, status_code, (void *) resp, (resp ? resp->len : 0));\n    fclose (f);\n  }\n  (void) resp; (void) status_code; (void) conn;\n  return MHD_HTTP_OK;\n}\n\nvoid\nMHD_destroy_response (struct MHD_Response *resp)\n{\n  free (resp);\n}\n\nvoid probe_violation (void)\n{\n  /* ensure log directory exists (ignore errors) */\n  (void) mkdir (\"/tmp/logs\", 0777);\n\n  struct Container {\n    char a[4];    /* not NUL-terminated */\n    char term;    /* adjacent member holding the terminator */\n  } c;\n\n  c.a[0] = 'A'; c.a[1] = 'B'; c.a[2] = 'C'; c.a[3] = 'D';\n  c.term = '\\0'; /* terminator lives in the adjacent object */\n\n  /* log the setup so test log shows why strlen must read past c.a */\n  FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n  if (f)\n  {\n    fprintf (f, \"probe_violation: container at %p, a=%p, term at %p value=0x%02X\\n\",\n             (void *) &c, (void *) c.a, (void *) &c.term, (unsigned char) c.term);\n    fclose (f);\n  }\n\n  /* Call serve_simple_form with a pointer to the non-NUL-terminated array. */\n  (void) serve_simple_form ((const void *) c.a, \"text/html\", NULL, NULL);\n}\n\nvoid\nadd_session_cookie (struct Session *session, struct MHD_Response *response)\n{\n  (void) session; (void) response; /* no-op for this test harness */\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* log entry and the bytes at the start of form (not assuming NUL) */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"enter serve_simple_form: form=%p mime=%s session=%p connection=%p\\n\",\n               (void *) form, (mime ? mime : \"(null)\"), (void *) session, (void *) connection);\n      /* dump a few bytes starting at form for visibility (print as chars and hex) */\n      if (form != NULL)\n      {\n        fprintf (f, \"form bytes: \");\n        for (size_t i = 0U; i < 8U; ++i)\n        {\n          unsigned char c = (unsigned char) form[i];\n          fprintf (f, \"%c(0x%02X) \", (c >= 32 && c < 127) ? (char) c : '.', c);\n        }\n        fprintf (f, \"\\n\");\n      }\n      fclose (f);\n    }\n  }\n\n  /* return static form */\n  {\n    size_t len = strlen (form); /* POTENTIAL OUT-OF-BOUNDS read if 'form' isn't NUL-terminated */\n\n    /* log the computed length */\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"strlen(form) -> %zu\\n\", len);\n      fclose (f);\n    }\n\n    response = MHD_create_response_from_buffer_static (len, form);\n  }\n\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* log exit */\n  {\n    FILE *f = fopen (\"/tmp/logs/87.txt\", \"a\");\n    if (f)\n    {\n      fprintf (f, \"exit serve_simple_form: ret=%d\\n\", ret);\n      fclose (f);\n    }\n  }\n\n  return ret;\n}\n",
  "explanation": "I added the necessary headers (stdio.h, stdlib.h, string.h, sys/stat.h, sys/types.h), defined minimal types missing from the original code (enum MHD_Result, struct MHD_Connection, struct Session) and provided a forward declaration for serve_simple_form so probe_violation can call it. These changes are minimal and preserve the original serve_simple_form logic while making the unit self-contained and compilable. No main() or macros were added."
}