{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response (and members: fd, fd_off)",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "ssize_t",
    "SSIZE_MAX",
    "uint64_t",
    "int64_t",
    "uintptr_t",
    "_get_osfhandle",
    "HANDLE",
    "INVALID_HANDLE_VALUE",
    "OVERLAPPED",
    "ULARGE_INTEGER",
    "DWORD",
    "ReadFile (Windows API prototype, including calling convention macros like WINAPI)",
    "pread64",
    "pread",
    "lseek64",
    "lseek",
    "read",
    "off_t",
    "INT32_MAX",
    "HAVE_PREAD64",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "_WIN32",
    "__CYGWIN__",
    "SEEK_SET"
  ],
  "explanation": "For an accurate MISRA-C \"Language extensions should not be used\" determination you must know whether any referenced types, macros or API declarations rely on compiler-specific language extensions or non\u2011standard calling conventions. Each listed symbol is needed for that check:\n\n- struct MHD_Response (fd, fd_off): to see the declared types of fd and fd_off (are they standard integer types, pointers, compiler-specific typedefs?) and whether project macros introduce extensions.\n- MHD_CONTENT_READER_END_WITH_ERROR / MHD_CONTENT_READER_END_OF_STREAM: to know their definitions/types (macros/enum/const) and whether they use compiler extensions (e.g. nonstandard attributes or cast tricks).\n- ssize_t / SSIZE_MAX: ssize_t is POSIX (not strictly standard C); need its definition to judge whether use of a POSIX type violates the MISRA rule in your toolchain/standards setting. SSIZE_MAX value/type also matters for integer casts/clamps.\n- uint64_t / int64_t: these are C99 stdint types; need their presence/definition in the build environment to confirm C99 usage is permitted or an extension for that compiler/standard.\n- uintptr_t: same rationale \u2014 uintptr_t is C99; check if it is provided by the compiler/runtime and whether its use (cast between integer and pointer) relies on an extension.\n- _get_osfhandle: CRT/OS function \u2014 need its prototype/return type (often intptr_t) to determine if the cast sequence ( (HANDLE)(uintptr_t)_get_osfhandle(...) ) uses implementation-specific integer/pointer conversions or nonstandard return types.\n- HANDLE / INVALID_HANDLE_VALUE / OVERLAPPED / ULARGE_INTEGER / DWORD / ReadFile: Windows API types and function prototypes often use calling\u2011convention macros (e.g. WINAPI, __stdcall, __declspec) which are compiler-specific language extensions. You must inspect their declarations to see if they introduce compiler extensions (or nonstandard attributes) and whether the code relies on those extensions.\n- pread64 / pread / lseek64 / lseek / read: POSIX/OS-level I/O functions \u2014 their presence may be governed by feature macros and some variants (pread64, lseek64) can be nonstandard extensions. Need the prototypes to decide if they are standard or extension functions in the current build.\n- off_t / SEEK_SET: off_t size and SEEK_SET macro definitions are required because the code tests sizeof(off_t) relative to uint64_t and casts an int64 offset to off_t; this is relevant to determine if the code relies on nonportable integer sizes or implementation-defined behaviour (which could be implemented via extensions).\n- INT32_MAX: limits macro used in comparisons \u2014 need its definition to assess portability and whether it comes from a nonstandard header in this environment.\n- HAVE_PREAD64 / HAVE_PREAD / HAVE_LSEEK64: these build configuration macros control which code paths compile. To decide if any compiled path uses compiler extensions you must know which of these are defined in the target build.\n- _WIN32 / __CYGWIN__: predefined platform macros control conditional compilation; their definitions determine which platform-specific (and possibly extension-using) code is active.\n\nIn short: inspect the definitions/prototypes/typedefs for these symbols to detect any use of compiler-specific calling conventions, attributes, or nonstandard types/casts. Only after knowing those definitions can you reliably report violations of the MISRA rule about language extensions."
}