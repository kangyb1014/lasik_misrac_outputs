{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified file_reader code that contains useful probe functions that print useful logs to a file \"/tmp/logs/618.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of file_reader as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of file_reader:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function file_reader:\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n...\n#define MHD_CONTENT_READER_END_WITH_ERROR ((ssize_t)-2)\n...\n#define MHD_CONTENT_READER_END_OF_STREAM ((ssize_t)-1)\n...\n#define HAVE_PREAD64 1\n...\n#define HAVE_PREAD 1\n...\n#define HAVE_LSEEK64 1\n</additional code>\nJudge whether the above file_reader code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "When the project is configured with HAVE_PREAD64 (and the build is non-Windows), the code paths for the alternative read/seek implementations (the #elif HAVE_PREAD and the subsequent lseek-based branches) are never compiled or executed in this build configuration. Those excluded branches in the source are effectively dead for this project configuration: they will never be part of the produced binary and therefore represent code in the project that has no effect on the program behaviour for this configuration.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n\n/* Probe helper: append control-path and state information to the log. */\nstatic void\nfile_reader_probe (const char *evt,\n                   uint64_t pos,\n                   int64_t offset64,\n                   size_t max,\n                   ssize_t n)\n{\n  FILE *f = fopen(\"/tmp/logs/618.txt\", \"a\");\n  if (f != NULL)\n    {\n      /* Log an event, the input pos, computed offset, the max size and the read result. */\n      fprintf (f, \"%s: pos=%\" PRIu64 \" offset64=%\" PRId64 \" max=%zu n=%zd\\n\",\n               evt, pos, offset64, max, n);\n      fclose (f);\n    }\n}\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  /* Log computed offset early. */\n  file_reader_probe (\"entry\", pos, offset64, max, (ssize_t)0);\n\n  if (offset64 < 0)\n    {\n      file_reader_probe (\"offset_negative_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n    }\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  /* Preferred path on this configuration. */\n  file_reader_probe (\"using_pread64_before\", pos, offset64, max, (ssize_t)0);\n  n = pread64 (response->fd, buf, max, offset64);\n  file_reader_probe (\"using_pread64_after\", pos, offset64, max, n);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    {\n      file_reader_probe (\"pread_offset_too_large_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n    }\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    {\n      file_reader_probe (\"lseek64_failed_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n    }\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    {\n      file_reader_probe (\"lseek_offset_too_large_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n    }\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    {\n      file_reader_probe (\"lseek_failed_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n    }\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    {\n      file_reader_probe (\"end_of_stream\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_OF_STREAM);\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n  if (n < 0)\n    {\n      file_reader_probe (\"read_error\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR;\n    }\n  file_reader_probe (\"return_n\", pos, offset64, max, n);\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    {\n      file_reader_probe (\"invalid_handle_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n      return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n    }\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      {\n        file_reader_probe (\"win_read_error_return\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_WITH_ERROR);\n        return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n      }\n    if (0 == resRead)\n      {\n        file_reader_probe (\"win_end_of_stream\", pos, offset64, max, (ssize_t)MHD_CONTENT_READER_END_OF_STREAM);\n        return MHD_CONTENT_READER_END_OF_STREAM;\n      }\n    file_reader_probe (\"win_return_resRead\", pos, offset64, max, (ssize_t) resRead);\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n"
}