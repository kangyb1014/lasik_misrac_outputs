{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified file_reader code that contains useful probe functions that print useful logs to a file \"/tmp/logs/621.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of file_reader as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of file_reader:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\nJudge whether the above file_reader code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function modifies its scalar parameter 'max' inside file_reader: the line 'if (max > SSIZE_MAX) max = SSIZE_MAX;' assigns to the parameter 'max', which violates MISRA C 2023 Rule 17.8 (a function parameter shall not be modified).",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n\n/* Minimal supporting definitions to make this translation unit self-contained. */\nstruct MHD_Response\n{\n  int fd;\n  uint64_t fd_off;\n};\n\nstatic const ssize_t MHD_CONTENT_READER_END_WITH_ERROR = -1;\nstatic const ssize_t MHD_CONTENT_READER_END_OF_STREAM = 0;\n\n/* Simple probe logger that appends control path and state information to the\n   required log file. Does not change the logic of file_reader; parameters are\n   passed by value. */\nstatic void log_state(const char *stage, uint64_t pos, size_t max, int code)\n{\n  FILE *f = fopen(\"/tmp/logs/621.txt\", \"a\");\n  if (f != NULL)\n  {\n    /* stage: textual description, pos: requested position, max: byte count, code: branch id */\n    fprintf(f, \"%s: pos=%\" PRIu64 \", max=%zu, branch=%d\\n\", stage, pos, max, code);\n    (void) fclose(f);\n  }\n}\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n  ssize_t n;\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  /* Log entry state */\n  log_state(\"entry\", pos, max, 0);\n\n  if (offset64 < 0)\n  {\n    log_state(\"offset_negative\", pos, max, 1);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (max > SSIZE_MAX)\n  {\n    /* This assignment modifies the parameter 'max' (violation of MISRA C 2023 Rule 17.8). */\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n    log_state(\"clamped_max\", pos, max, 2);\n  }\n\n  /* Attempt seek and read using lseek/read as a generic POSIX path. The logic\n     is preserved from the original implementation. */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n  {\n    log_state(\"lseek64_fail\", pos, max, 3);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#else\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n  {\n    log_state(\"seek_overflow\", pos, max, 4);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n  {\n    log_state(\"lseek_fail\", pos, max, 5);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#endif\n\n  n = read (response->fd,\n            buf,\n            max);\n\n  if (0 == n)\n  {\n    log_state(\"eof\", pos, max, 6);\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (n < 0)\n  {\n    log_state(\"read_error\", pos, max, 7);\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n\n  log_state(\"read_success\", pos, (size_t) n, 8);\n  return n;\n}\n"
}