{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nenum MHD_ValueKind { MHD_HEADER_KIND = 0 };\nstatic const unsigned MHD_RAF_HAS_CONNECTION_HDR = 0x01u;\nstatic const unsigned MHD_RAF_HAS_CONNECTION_CLOSE = 0x02u;\nstatic void mhd_assert (int cond)\n{\n  (void) cond; /* keep behaviour minimal for test harness */\n}\nstatic void probe_log_connection_state(const char *stage,\n                                      const struct MHD_Response *response,\n                                      const struct MHD_HTTP_Res_Header *hdr)\n{\n  FILE *f = fopen(\"/tmp/logs/54.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"Stage: %s\\n\", stage);\n  if (NULL != response)\n    fprintf(f, \" response->flags_auto=0x%08x, response->flags=0x%08x\\n\",\n            response->flags_auto, response->flags);\n  if (NULL != hdr)\n  {\n    fprintf(f, \" hdr present: header_size=%zu, value_size=%zu\\n\",\n            hdr->header_size, hdr->value_size);\n    /* Print up to a limited number of characters of hdr->value */\n    if (NULL != hdr->value)\n    {\n      size_t to_print = hdr->value_size;\n      if (to_print > 128u)\n        to_print = 128u;\n      fprintf(f, \" hdr->value (prefix): '%.*s'\\n\", (int) to_print, hdr->value);\n      /* Use strncmp (not memcmp) here to avoid introducing a second memcmp\n         violation in the probe itself. */\n      int cmp_first5 = 0;\n      if (hdr->value_size >= 5u)\n        cmp_first5 = strncmp(hdr->value, \"close\", 5);\n      else\n        cmp_first5 = 1; /* different if shorter */\n      fprintf(f, \" strncmp first5 vs 'close' => %d\\n\", cmp_first5);\n    }\n  }\n  else\n    fprintf(f, \" hdr not present\\n\");\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\nstatic bool charsequalcaseless (const char c1, const char c2)\n{\n  return ( (c1 == c2) ||\n           (isascii((unsigned char)c1) && isupper((unsigned char)c1) ?\n            ((char)(c1 - 'A' + 'a') == c2) :\n            (c1 == (char)(c2 - 'A' + 'a') && isascii((unsigned char)c2) && isupper((unsigned char)c2))) );\n}\n\nstruct MHD_HTTP_Res_Header * MHD_get_response_element_n_ (struct MHD_Response *response,\n                                                         enum MHD_ValueKind kind,\n                                                         const char *key,\n                                                         size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  if (NULL == response)\n    return NULL;\n  for (pos = response->first_header; NULL != pos; pos = pos->next)\n  {\n    if ((pos->header_size == key_len) && (kind == pos->kind))\n    {\n      /* Compare header name case-insensitively for key_len bytes */\n      size_t i;\n      int equal = 1;\n      for (i = 0u; i < key_len; ++i)\n      {\n        if (!charsequalcaseless(pos->header[i], key[i]))\n        {\n          equal = 0; break;\n        }\n      }\n      if (equal)\n        return pos;\n    }\n  }\n  return NULL;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, \"Connection\"))\n    return add_response_header_connection (response, content);\n\n  /* The rest of the original branches are omitted in detail for brevity but\n     would call the same helper functions in the real project. For test\n     compilation we simply fall through to a default stub. */\n\n  return add_response_header_connection(response, content);\n}\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = \"Connection\";\n  const size_t key_len = 10u; /* length of \"Connection\" */\n  size_t value_len; /* length of the @a value */\n  size_t old_value_len;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n\n  if ((NULL != strchr (value, '\\r')) || (NULL != strchr (value, '\\n')))\n    return MHD_NO;\n\n  if (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n\n    /* Probe log before the original mhd_assert that contains the memcmp */\n    probe_log_connection_state(\"before_assert\", response, hdr);\n\n    /* ORIGINAL ASSERT PRESENT IN SOURCE (kept to demonstrate the violation):\n       mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n       This is the memcmp use that violates MISRA C 2023 Rule 21.14 because it\n       compares null-terminated strings using memcmp. We keep it exactly as in\n       the original to produce the violation scenario. */\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n\n  /* Continue with a minimal preservation of the original flow. For brevity\n     we will not implement the full token-normalisation logic here; the\n     important point is that the memcmp call above is present in the same\n     control path and the probe has logged the state. */\n\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2u;\n  else\n    old_value_len = 0u;\n\n  value_len = strlen(value);\n  if (value_len >= (size_t)SSIZE_MAX)\n    return MHD_NO;\n\n  /* Minimal behaviour: if hdr exists, update its value to a copy of value; */\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr = (struct MHD_HTTP_Res_Header *)calloc(1, sizeof(*new_hdr));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = (char *)malloc(key_len + 1u);\n      if (NULL != new_hdr->header)\n      {\n        memcpy(new_hdr->header, key, key_len);\n        new_hdr->header[key_len] = '\\0';\n        new_hdr->header_size = key_len;\n        new_hdr->value = (char *)malloc(value_len + 1u);\n        if (NULL != new_hdr->value)\n        {\n          memcpy(new_hdr->value, value, value_len + 1u);\n          new_hdr->value_size = value_len;\n          new_hdr->kind = MHD_HEADER_KIND;\n          if (strcmp(value, \"close\") == 0)\n            response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE);\n          else\n            response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n          /* insert at head */\n          new_hdr->next = response->first_header;\n          response->first_header = new_hdr;\n          probe_log_connection_state(\"inserted_new_hdr\", response, new_hdr);\n          return MHD_YES;\n        }\n        free(new_hdr->header);\n      }\n      free(new_hdr);\n    }\n    return MHD_NO;\n  }\n\n  /* Update existing header entry (simplified) */\n  free (hdr->value);\n  hdr->value = (char *)malloc(value_len + 1u);\n  if (NULL == hdr->value)\n    return MHD_NO;\n  memcpy(hdr->value, value, value_len + 1u);\n  hdr->value_size = value_len;\n  if ((strcmp(value, \"close\") == 0) && !already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n\n  probe_log_connection_state(\"updated_existing_hdr\", response, hdr);\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nresponse.c:338:6: error: redeclaration of 'enum MHD_ValueKind'\n  338 | enum MHD_ValueKind { MHD_HEADER_KIND = 0 };\n      |      ^~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from response.c:49:\n../../src/include/microhttpd.h:2244:6: note: originally defined here\n 2244 | enum MHD_ValueKind\n      |      ^~~~~~~~~~~~~\nresponse.c:338:22: error: redeclaration of enumerator 'MHD_HEADER_KIND'\n  338 | enum MHD_ValueKind { MHD_HEADER_KIND = 0 };\n      |                      ^~~~~~~~~~~~~~~\nIn file included from internal.h:34,\n                 from response.c:49:\n../../src/include/microhttpd.h:2260:3: note: previous definition of 'MHD_HEADER_KIND' with type 'enum MHD_ValueKind'\n 2260 |   MHD_HEADER_KIND = 1,\n      |   ^~~~~~~~~~~~~~~\nresponse.c:339:23: error: 'MHD_RAF_HAS_CONNECTION_HDR' redeclared as different kind of symbol\n  339 | static const unsigned MHD_RAF_HAS_CONNECTION_HDR = 0x01u;\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from response.c:49:\ninternal.h:407:3: note: previous definition of 'MHD_RAF_HAS_CONNECTION_HDR' with type 'enum MHD_ResponseAutoFlags'\n  407 |   MHD_RAF_HAS_CONNECTION_HDR = 1 << 0,    /**< Has \"Connection\" header */\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~\nresponse.c:340:23: error: 'MHD_RAF_HAS_CONNECTION_CLOSE' redeclared as different kind of symbol\n  340 | static const unsigned MHD_RAF_HAS_CONNECTION_CLOSE = 0x02u;\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from response.c:49:\ninternal.h:408:3: note: previous definition of 'MHD_RAF_HAS_CONNECTION_CLOSE' with type 'enum MHD_ResponseAutoFlags'\n  408 |   MHD_RAF_HAS_CONNECTION_CLOSE = 1 << 1,  /**< Has \"Connection: close\" */\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from internal.h:35,\n                 from response.c:49:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\nresponse.c:341:13: note: in expansion of macro 'mhd_assert'\n  341 | static void mhd_assert (int cond)\n      |             ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nresponse.c:341:13: note: in expansion of macro 'mhd_assert'\n  341 | static void mhd_assert (int cond)\n      |             ^~~~~~~~~~\nmake[3]: *** [Makefile:2182: libmicrohttpd_la-response.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_add_response_header as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Fixed response.c test snippet: removed duplicate definitions that conflicted with included headers. */\n\n/* Note: enum MHD_ValueKind, MHD_RAF_* flags and the mhd_assert macro/function\n   are provided by the project's headers (internal.h / mhd_assert.h). This\n   file must not redeclare them to avoid conflicts. */\n\nstatic void probe_log_connection_state(const char *stage,\n                                      const struct MHD_Response *response,\n                                      const struct MHD_HTTP_Res_Header *hdr)\n{\n  FILE *f = fopen(\"/tmp/logs/54.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"Stage: %s\\n\", stage);\n  if (NULL != response)\n    fprintf(f, \" response->flags_auto=0x%08x, response->flags=0x%08x\\n\",\n            response->flags_auto, response->flags);\n  if (NULL != hdr)\n  {\n    fprintf(f, \" hdr present: header_size=%zu, value_size=%zu\\n\",\n            hdr->header_size, hdr->value_size);\n    /* Print up to a limited number of characters of hdr->value */\n    if (NULL != hdr->value)\n    {\n      size_t to_print = hdr->value_size;\n      if (to_print > 128u)\n        to_print = 128u;\n      fprintf(f, \" hdr->value (prefix): '%.*s'\\n\", (int) to_print, hdr->value);\n      /* Use strncmp (not memcmp) here to avoid introducing a second memcmp\n         violation in the probe itself. */\n      int cmp_first5 = 0;\n      if (hdr->value_size >= 5u)\n        cmp_first5 = strncmp(hdr->value, \"close\", 5);\n      else\n        cmp_first5 = 1; /* different if shorter */\n      fprintf(f, \" strncmp first5 vs 'close' => %d\\n\", cmp_first5);\n    }\n  }\n  else\n    fprintf(f, \" hdr not present\\n\");\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\nstatic bool charsequalcaseless (const char c1, const char c2)\n{\n  return ( (c1 == c2) ||\n           (isascii((unsigned char)c1) && isupper((unsigned char)c1) ?\n            ((char)(c1 - 'A' + 'a') == c2) :\n            (c1 == (char)(c2 - 'A' + 'a') && isascii((unsigned char)c2) && isupper((unsigned char)c2))) );\n}\n\nstruct MHD_HTTP_Res_Header * MHD_get_response_element_n_ (struct MHD_Response *response,\n                                                         enum MHD_ValueKind kind,\n                                                         const char *key,\n                                                         size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  if (NULL == response)\n    return NULL;\n  for (pos = response->first_header; NULL != pos; pos = pos->next)\n  {\n    if ((pos->header_size == key_len) && (kind == pos->kind))\n    {\n      /* Compare header name case-insensitively for key_len bytes */\n      size_t i;\n      int equal = 1;\n      for (i = 0u; i < key_len; ++i)\n      {\n        if (!charsequalcaseless(pos->header[i], key[i]))\n        {\n          equal = 0; break;\n        }\n      }\n      if (equal)\n        return pos;\n    }\n  }\n  return NULL;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, \"Connection\"))\n    return add_response_header_connection (response, content);\n\n  /* The rest of the original branches are omitted in detail for brevity but\n     would call the same helper functions in the real project. For test\n     compilation we simply fall through to a default stub. */\n\n  return add_response_header_connection(response, content);\n}\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = \"Connection\";\n  const size_t key_len = 10u; /* length of \"Connection\" */\n  size_t value_len; /* length of the @a value */\n  size_t old_value_len;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n\n  if ((NULL != strchr (value, '\\r')) || (NULL != strchr (value, '\\n')))\n    return MHD_NO;\n\n  if (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0u != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n\n    /* Probe log before the original mhd_assert that contains the memcmp */\n    probe_log_connection_state(\"before_assert\", response, hdr);\n\n    /* ORIGINAL ASSERT PRESENT IN SOURCE (kept to demonstrate the violation):\n       mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n       This is the memcmp use that violates MISRA C 2023 Rule 21.14 because it\n       compares null-terminated strings using memcmp. We keep it exactly as in\n       the original to produce the violation scenario. */\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response, MHD_HEADER_KIND, key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n\n  /* Continue with a minimal preservation of the original flow. For brevity\n     we will not implement the full token-normalisation logic here; the\n     important point is that the memcmp call above is present in the same\n     control path and the probe has logged the state. */\n\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2u;\n  else\n    old_value_len = 0u;\n\n  value_len = strlen(value);\n  if (value_len >= (size_t)SSIZE_MAX)\n    return MHD_NO;\n\n  /* Minimal behaviour: if hdr exists, update its value to a copy of value; */\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr = (struct MHD_HTTP_Res_Header *)calloc(1, sizeof(*new_hdr));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = (char *)malloc(key_len + 1u);\n      if (NULL != new_hdr->header)\n      {\n        memcpy(new_hdr->header, key, key_len);\n        new_hdr->header[key_len] = '\\0';\n        new_hdr->header_size = key_len;\n        new_hdr->value = (char *)malloc(value_len + 1u);\n        if (NULL != new_hdr->value)\n        {\n          memcpy(new_hdr->value, value, value_len + 1u);\n          new_hdr->value_size = value_len;\n          new_hdr->kind = MHD_HEADER_KIND;\n          if (strcmp(value, \"close\") == 0)\n            response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE);\n          else\n            response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n          /* insert at head */\n          new_hdr->next = response->first_header;\n          response->first_header = new_hdr;\n          probe_log_connection_state(\"inserted_new_hdr\", response, new_hdr);\n          return MHD_YES;\n        }\n        free(new_hdr->header);\n      }\n      free(new_hdr);\n    }\n    return MHD_NO;\n  }\n\n  /* Update existing header entry (simplified) */\n  free (hdr->value);\n  hdr->value = (char *)malloc(value_len + 1u);\n  if (NULL == hdr->value)\n    return MHD_NO;\n  memcpy(hdr->value, value, value_len + 1u);\n  hdr->value_size = value_len;\n  if ((strcmp(value, \"close\") == 0) && !already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n\n  probe_log_connection_state(\"updated_existing_hdr\", response, hdr);\n  return MHD_YES;\n}\n",
  "explanation": "I removed the local redeclarations that conflicted with the project's headers: the enum MHD_ValueKind, the MHD_RAF_HAS_CONNECTION_* constant definitions, and the local mhd_assert function. Those symbols are expected to be provided by included headers (internal.h / mhd_assert.h), so removing the duplicate definitions avoids the redeclaration errors while preserving the original logic and control flow. The rest of the file is unchanged so the behavior of MHD_add_response_header and its helper remains intact."
}