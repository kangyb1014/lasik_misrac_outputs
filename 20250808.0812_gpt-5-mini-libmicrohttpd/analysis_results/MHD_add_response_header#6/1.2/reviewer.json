{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a compiler-specific attribute via the _MHD_EXTERN macro which expands to __attribute__((visibility(\"default\")))extern. __attribute__ is a GCC/Clang language extension and therefore violates MISRA C 2023 Rule 1.2 (language extensions should not be used).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nstatic const char MHD_HTTP_HEADER_TRANSFER_ENCODING[] = \"Transfer-Encoding\";\nstatic const char MHD_HTTP_HEADER_DATE[] = \"Date\";\nstatic const char MHD_HTTP_HEADER_CONTENT_LENGTH[] = \"Content-Length\";\nstatic const unsigned long long MHD_RAF_HAS_TRANS_ENC_CHUNKED = 1ULL << 0;\nstatic const unsigned long long MHD_RAF_HAS_CONTENT_LENGTH = 1ULL << 1;\nstatic const unsigned long long MHD_RAF_HAS_DATE_HDR = 1ULL << 2;\nstatic const unsigned long long MHD_RF_INSANITY_HEADER_CONTENT_LENGTH = 1ULL << 3;\nstatic const unsigned long long MHD_RF_HEAD_ONLY_RESPONSE = 1ULL << 4;\nstatic const int MHD_HEADER_KIND = 0;\nvoid _MHD_remove_header(struct MHD_Response *response, struct MHD_HTTP_Res_Header *hdr);\n\nenum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  FILE *log = fopen(\"/tmp/logs/48.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"MHD_add_response_header called: header=%p content=%p\\n\",\n            (void *)header, (void *)content);\n    fprintf(log, \"response=%p flags_auto=%llu flags=%llu\\n\",\n            (void *)response,\n            (unsigned long long) (response ? response->flags_auto : 0ULL),\n            (unsigned long long) (response ? response->flags : 0ULL));\n  }\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    if (log) fprintf(log, \"branch: Connection -> add_response_header_connection\\n\");\n    enum MHD_Result r = add_response_header_connection (response, content);\n    if (log) fprintf(log, \"add_response_header_connection returned=%d\\n\", r);\n    if (log) fclose(log);\n    return r;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (log) fprintf(log, \"branch: Transfer-Encoding\\n\");\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      if (log) fprintf(log, \"Transfer-Encoding content != chunked -> MHD_NO\\n\");\n      if (log) fclose(log);\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      if (log) fprintf(log, \"Already has chunked -> MHD_YES\\n\");\n      if (log) fclose(log);\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      if (log) fprintf(log, \"Has Content-Length and no Insanity flag -> MHD_NO\\n\");\n      if (log) fclose(log);\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      if (log) fprintf(log, \"add_response_entry succeeded -> set HAS_TRANS_ENC_CHUNKED -> MHD_YES\\n\");\n      if (log) fclose(log);\n      return MHD_YES;\n    }\n    if (log) fprintf(log, \"add_response_entry failed -> MHD_NO\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (log) fprintf(log, \"branch: Date\\n\");\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         (sizeof(MHD_HTTP_HEADER_DATE) - 1));\n      assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n      if (log) fprintf(log, \"existing Date header removed\\n\");\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      if (log) fprintf(log, \"add_response_entry succeeded -> set HAS_DATE_HDR -> MHD_YES\\n\");\n      if (log) fclose(log);\n      return MHD_YES;\n    }\n    if (log) fprintf(log, \"add_response_entry failed for Date -> MHD_NO\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    if (log) fprintf(log, \"branch: Content-Length\\n\");\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        if (log) fprintf(log, \"add_response_entry succeeded -> set HAS_CONTENT_LENGTH -> MHD_YES\\n\");\n        if (log) fclose(log);\n        return MHD_YES;\n      }\n    }\n    if (log) fprintf(log, \"Content-Length not added or failed -> MHD_NO\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (log) fprintf(log, \"branch: default -> add_response_entry\\n\");\n  enum MHD_Result r = add_response_entry (response,\n                                         MHD_HEADER_KIND,\n                                         header,\n                                         content);\n  if (log) fprintf(log, \"add_response_entry returned=%d\\n\", r);\n  if (log) fclose(log);\n  return r;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The target code as shown contains the identifier _MHD_EXTERN before the function return type, but the code fragment does not include the definition of that macro. MISRA C 2023 Rule 1.2 only applies when a language/compiler extension is actually used (and that extension is documented as an extension by the compiler). Agent A asserts that _MHD_EXTERN expands to __attribute__((visibility(\"default\"))) extern, and if that is true then it would indeed use GCC/Clang\u2019s __attribute__ extension and therefore violate Rule 1.2. However, that assertion is not proven by the provided code: the macro definition (or the preprocessed output) is not shown, so you cannot confirm from the snippet whether a compiler-specific attribute is actually present.\n\nConclusion: the report is not demonstrably correct based on the supplied code. If in your build environment _MHD_EXTERN expands to a __attribute__ form (or any other non\u2011standard attribute syntax), then the code does violate MISRA 2023 Rule 1.2. To confirm and fix: inspect the macro definition or the preprocessed source (gcc -E) to see the real expansion; if it contains __attribute__ (or other compiler extension), remove or conditionally hide it for MISRA\u2011checked builds (or provide a standard-compliant alternative)."
}