{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "MHD_UpgradeResponseHandle",
    "make_blocking",
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "MHD_upgrade_action",
    "MHD_upgraded_connection_mark_app_closed_",
    "MUTEX",
    "CLIENT_SOCKS",
    "MAX_CLIENTS",
    "MHD_INVALID_SOCKET",
    "MHD_UPGRADE_ACTION_CLOSE",
    "pthread_mutex_lock",
    "pthread_mutex_unlock",
    "recv",
    "malloc",
    "free",
    "snprintf",
    "ssize_t",
    "size_t",
    "NULL",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "abort"
  ],
  "explanation": "For each symbol below, the target-function analysis must inspect its declaration/definition because compiler/language extensions (for example: GNU __attribute__, __declspec, asm, typeof, __extension__, nested functions, variable-length-array usage in interfaces, non\u2011standard pragmas, or other compiler-specific constructs) can appear there and would violate the MISRA rule. Short reasons:\n\n- struct WsData: contains the member types (e.g. sock, urh) and any field attributes or non\u2011standard layout directives.\n- MHD_UpgradeResponseHandle: its type definition might use compiler extensions or attributes.\n- make_blocking: function definition or prototype may include compiler-specific attributes or asm.\n- ws_receive_frame: prototype/definition may use extensions (attributes, nonstandard types, inline asm) and affects how msg/got are produced.\n- ws_send_frame: prototype/definition may use extensions or nonstandard calling conventions/attributes.\n- send_all: called (indirectly via ws_send_frame per call graph); its definition may contain extensions that propagate to callers.\n- MHD_upgrade_action: prototype or macro might expand to compiler-specific constructs; it calls MHD_upgraded_connection_mark_app_closed_, so include both.\n- MHD_upgraded_connection_mark_app_closed_: definition could contain extensions (attributes, pragmas) used by MHD library.\n- MUTEX: the mutex object type (likely a macro or pthread_mutex_t) definition could use implementation-specific extensions or typedefs.\n- CLIENT_SOCKS: global array definition could use nonstandard linkage, attributes, or flexible/packed array extensions.\n- MAX_CLIENTS: macro value or definition could be an expression using compiler extensions.\n- MHD_INVALID_SOCKET: macro/constant might be defined using compiler-specific constructs or typedefs.\n- MHD_UPGRADE_ACTION_CLOSE: macro constant might be defined via extension-heavy macros.\n- pthread_mutex_lock / pthread_mutex_unlock: their declarations (system headers) may contain attributes or compiler-specific annotations that could be considered extensions in a MISRA analysis.\n- recv: socket API declaration (system headers) might include platform-specific attributes or calling conventions.\n- malloc / free: standard library declarations could include non\u2011standard annotations (implementation headers) \u2014 inspect for attributes like __malloc__, etc.\n- snprintf: header declaration could carry attributes or extensions.\n- ssize_t: typedef origin (POSIX type) \u2014 check whether its definition uses implementation-specific typedefs or extension macros.\n- size_t: check typedef/definition in headers for any nonstandard annotations.\n- NULL: macro definition could be implementation-specific (e.g. ((void*)0) vs 0) \u2014 sometimes relevant for extension detection.\n- WS_OPCODE_TEXT_FRAME / WS_OPCODE_CON_CLOSE_FRAME: macros/constants used in control flow; their definitions could expand to nonstandard constructs.\n- abort: declaration might have attributes (noreturn) or other extensions in headers.\n\nIn short: any function prototypes, type definitions, macros, or global objects referenced by run_usock must be inspected because compiler-specific language extensions can appear in their declarations/definitions and would cause a MISRA violation even if the run_usock body itself looks standard. The listed symbols cover all external identifiers referenced directly (and the indirect callee send_all and the MHD internal call) that could hide such extensions."
}