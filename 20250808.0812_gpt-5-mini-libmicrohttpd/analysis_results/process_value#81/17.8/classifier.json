{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified process_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/653.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of process_value:\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function process_value:\nstruct MHD_PostProcessor\n{\n\n  /**\n   * The connection for which we are doing\n   * POST processing.\n   */\n  struct MHD_Connection *connection;\n\n  /**\n   * Function to call with POST data.\n   */\n  MHD_PostDataIterator ikvi;\n\n  /**\n   * Extra argument to ikvi.\n   */\n  void *cls;\n\n  /**\n   * Encoding as given by the headers of the connection.\n   */\n  const char *encoding;\n\n  /**\n   * Primary boundary (points into encoding string)\n   */\n  const char *boundary;\n\n  /**\n   * Nested boundary (if we have multipart/mixed encoding).\n   */\n  char *nested_boundary;\n\n  /**\n   * Pointer to the name given in disposition.\n   */\n  char *content_name;\n\n  /**\n   * Pointer to the (current) content type.\n   */\n  char *content_type;\n\n  /**\n   * Pointer to the (current) filename.\n   */\n  char *content_filename;\n\n  /**\n   * Pointer to the (current) encoding.\n   */\n  char *content_transfer_encoding;\n\n  /**\n   * Value data left over from previous iteration.\n   */\n  char xbuf[2];\n\n  /**\n   * Size of our buffer for the key.\n   */\n  size_t buffer_size;\n\n  /**\n   * Current position in the key buffer.\n   */\n  size_t buffer_pos;\n\n  /**\n   * Current position in @e xbuf.\n   */\n  size_t xbuf_pos;\n\n  /**\n   * Current offset in the value being processed.\n   */\n  uint64_t value_offset;\n\n  /**\n   * strlen(boundary) -- if boundary != NULL.\n   */\n  size_t blen;\n\n  /**\n   * strlen(nested_boundary) -- if nested_boundary != NULL.\n   */\n  size_t nlen;\n\n  /**\n   * Do we have to call the 'ikvi' callback when processing the\n   * multipart post body even if the size of the payload is zero?\n   * Set to #MHD_YES whenever we parse a new multiparty entry header,\n   * and to #MHD_NO the first time we call the 'ikvi' callback.\n   * Used to ensure that we do always call 'ikvi' even if the\n   * payload is empty (but not more than once).\n   */\n  bool must_ikvi;\n\n  /**\n   * Set if we still need to run the unescape logic\n   * on the key allocated at the end of this struct.\n   */\n  bool must_unescape_key;\n\n  /**\n   * State of the parser.\n   */\n  enum PP_State state;\n\n  /**\n   * Side-state-machine: skip CRLF (or just LF).\n   * Set to 0 if we are not in skip mode.  Set to 2\n   * if a CRLF is expected, set to 1 if a CR should\n   * be skipped if it is the next character.\n   */\n  enum RN_State skip_rn;\n\n  /**\n   * If we are in skip_rn with \"dash\" mode and\n   * do find 2 dashes, what state do we go into?\n   */\n  enum PP_State dash_state;\n\n  /**\n   * Which headers are global? (used to tell which\n   * headers were only valid for the nested multipart).\n   */\n  enum NE_State have;\n\n}\n</additional code>\nJudge whether the above process_value code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function modifies its pointer parameters 'value_start' and 'value_end'. Specifically, value_end is assigned (value_end = last_escape;) and value_start is incremented (value_start += delta;). This changes the pointer parameters themselves, which violates MISRA C 2023 Rule 17.8 (function parameter should not be modified).",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\nstatic void log_probe(const char *tag,\n                      const char *value_start,\n                      const char *value_end,\n                      const char *last_escape,\n                      size_t xoff,\n                      size_t delta,\n                      bool cut,\n                      size_t clen,\n                      uint64_t value_offset)\n{\n  FILE *f = fopen(\"/tmp/logs/653.txt\", \"a\");\n  if (NULL != f)\n  {\n    fprintf(f,\n            \"%s: value_start=%p value_end=%p last_escape=%p xoff=%zu delta=%zu cut=%d clen=%zu value_offset=%llu\\n\",\n            tag,\n            (const void *) value_start,\n            (const void *) value_end,\n            (const void *) last_escape,\n            xoff,\n            delta,\n            (int) cut,\n            clen,\n            (unsigned long long) value_offset);\n    fclose(f);\n  }\n}\n\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n\n  /* Log initial state */\n  log_probe(\"ENTRY\", value_start, value_end, last_escape, xoff, 0u, false, 0u, pp->value_offset);\n\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n\n    /* Log before modifying value_end and pp->xbuf_pos */\n    log_probe(\"BEFORE_MOVE_LAST_ESCAPE\", value_start, value_end, last_escape, xoff, (size_t) (value_end - last_escape), false, 0u, pp->value_offset);\n\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n\n    /* This assignment modifies the pointer parameter 'value_end' */\n    value_end = last_escape;\n\n    /* Log after modifying value_end */\n    log_probe(\"AFTER_MOVE_LAST_ESCAPE\", value_start, value_end, last_escape, xoff, pp->xbuf_pos, false, 0u, pp->value_offset);\n  }\n\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n\n      /* Log before modifying value_start */\n      log_probe(\"BEFORE_ADVANCE_VALUE_START\", value_start, value_end, last_escape, xoff, delta, cut, clen, pp->value_offset);\n\n      /* This modifies the pointer parameter 'value_start' */\n      value_start += delta;\n\n      /* Log after modifying value_start */\n      log_probe(\"AFTER_ADVANCE_VALUE_START\", value_start, value_end, last_escape, xoff, delta, cut, clen, pp->value_offset);\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n\n        /* Log error return */\n        log_probe(\"IKVI_ERROR\", value_start, value_end, last_escape, xoff, 0u, cut, clen, pp->value_offset);\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n\n    /* Log loop iteration end state */\n    log_probe(\"LOOP_END\", value_start, value_end, last_escape, xoff, 0u, cut, clen, pp->value_offset);\n\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n"
}