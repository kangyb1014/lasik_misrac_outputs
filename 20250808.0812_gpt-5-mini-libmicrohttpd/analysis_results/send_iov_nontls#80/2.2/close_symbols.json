{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SENDMSG",
    "HAVE_WRITEV",
    "MHD_WINSOCK_SOCKETS",
    "_MHD_IOV_MAX",
    "MHD_USE_MSG_MORE",
    "_WIN64",
    "EPOLL_SUPPORT",
    "MHD_USE_TLS",
    "struct MHD_Connection",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "struct MHD_iovec_track_",
    "struct iovec (iov_base, iov_len)",
    "MHD_iov_size_",
    "pre_send_setopt",
    "post_send_setopt",
    "sendmsg",
    "writev",
    "WSASend",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EBADF_",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_BADF_",
    "connection->daemon->options",
    "connection->socket_fd",
    "connection->state",
    "connection->epoll_state",
    "MHD_EPOLL_STATE_WRITE_READY",
    "MSG_NOSIGNAL_OR_ZERO",
    "MSG_MORE",
    "UINT32_MAX",
    "DWORD",
    "LPWSABUF",
    "mhd_assert",
    "uint8_t"
  ],
  "explanation": "To decide whether any statements or branches in send_iov_nontls are dead code you must know which branches can actually be compiled or reached at runtime and whether runtime conditions can make particular blocks redundant. The required symbols fall into these categories:\n\n- Compile-time feature-selection macros (HAVE_SENDMSG, HAVE_WRITEV, MHD_WINSOCK_SOCKETS, _MHD_IOV_MAX, MHD_USE_MSG_MORE, _WIN64, EPOLL_SUPPORT): these determine which alternative implementations and #ifdef blocks are present in the compiled object. A region that is never compiled is not reachable; conversely, knowing which are defined is necessary to see if code is active or dead.\n\n- TLS / option flags (MHD_USE_TLS, connection->daemon->options): the initial mhd_assert and the guarantee that TLS is not used depend on these; if options or macros force TLS on/off this can affect whether some code paths are meaningful.\n\n- Connection state and socket constants (struct MHD_Connection, connection->socket_fd, connection->state, MHD_INVALID_SOCKET, MHD_CONNECTION_CLOSED): the early-return on invalid socket / closed connection depends on these definitions and possible runtime values (dead if the condition can never be true in the deployment context).\n\n- I/O tracking and iovec layout (struct MHD_iovec_track_, struct iovec (iov_base, iov_len), MHD_iov_size_, uint8_t): the loop that advances r_iov->sent and adjusts iov_base/iov_len is only meaningful if the iovec structure and sizes behave as assumed. To decide if that bookkeeping is redundant you must know the iovec semantics and the ranges of cnt/sent/iov_len.\n\n- Send-path helper functions and OS calls (pre_send_setopt, post_send_setopt, sendmsg, writev, WSASend, MSG_NOSIGNAL_OR_ZERO, MSG_MORE, LPWSABUF, DWORD, UINT32_MAX): whether calls to these functions have side effects (and therefore are not dead) or whether branches leading to those calls can occur depends on availability and behavior of these functions and macros.\n\n- Error reporting and classification (MHD_socket_get_error_, MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_, MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_ERR_IS_LOW_RESOURCES_, MHD_SCKT_EBADF_): the large error-handling cascade after a negative res depends on how socket errors are reported and classified. To determine if any of those error-specific branches are unreachable (and therefore dead) you must know the mapping from platform errors to these predicates.\n\n- Return-code constants (MHD_ERR_NOTCONN_, MHD_ERR_AGAIN_, MHD_ERR_CONNRESET_, MHD_ERR_PIPE_, MHD_ERR_OPNOTSUPP_, MHD_ERR_INVAL_, MHD_ERR_NOMEM_, MHD_ERR_BADF_): although their numeric values do not by themselves cause dead code, they are the visible effects of the branches; you need them to reason about whether removing a branch would alter observable program behaviour (return values).\n\n- Epoll state and enum (connection->epoll_state, MHD_EPOLL_STATE_WRITE_READY): the code that clears the EPOLL write-ready flag is only reachable/meaningful if EPOLL_SUPPORT is enabled and epoll state exists; you must know these symbols to decide if that manipulation is a no-op in the deployed configuration.\n\n- mhd_assert: assertions can be compiled out; knowledge of mhd_assert semantics is needed to determine whether the assertion lines are no-op (dead) in the build.\n\nEach listed symbol either governs compilation of code blocks, affects runtime reachability of branches, or determines whether a statement has side effects that would make its removal change program behaviour \u2014 all necessary to decide whether any part of send_iov_nontls qualifies as dead code under the MISRA rule."
}