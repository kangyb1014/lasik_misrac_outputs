{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The value parameter 'push_data' (a by-value function parameter) is assigned to (modified) inside the function in at least two places: once when _MHD_IOV_MAX < items_to_send (push_data = false) and once in the Windows-specific branch when items_to_send > UINT32_MAX (cnt_w = UINT32_MAX; push_data = false). Assigning to the by-value parameter 'push_data' violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const ssize_t MHD_ERR_NOTCONN_ = -1;\nstatic const ssize_t MHD_ERR_AGAIN_ = -2;\nstatic const ssize_t MHD_ERR_CONNRESET_ = -3;\nstatic const ssize_t MHD_ERR_PIPE_ = -4;\nstatic const ssize_t MHD_ERR_OPNOTSUPP_ = -5;\nstatic const ssize_t MHD_ERR_INVAL_ = -6;\nstatic const ssize_t MHD_ERR_NOMEM_ = -7;\nstatic const ssize_t MHD_ERR_BADF_ = -8;\nstatic const int MHD_INVALID_SOCKET = -1;\nstatic const int MHD_CONNECTION_CLOSED = 0;\nstatic const int MHD_USE_TLS = 1;\nstatic inline void mhd_assert(int expr) { (void)expr; /* no-op in this test code */ }\nstatic void\nmhd_log_probe (const char *tag,\n               struct MHD_Connection *connection,\n               struct MHD_iovec_track_ *const r_iov,\n               bool push_data,\n               size_t items_to_send,\n               ssize_t res)\n{\n  FILE *f = fopen(\"/tmp/logs/645.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf (f, \"%s: tag=%s, socket_fd=%d, state=%d, cnt=%zu, sent=%zu, items_to_send=%zu, push_data=%d, res=%zd\\n\",\n             __func__, tag,\n             (int) connection->socket_fd,\n             (int) connection->state,\n             (r_iov != NULL) ? r_iov->cnt : 0U,\n             (r_iov != NULL) ? r_iov->sent : 0U,\n             items_to_send,\n             (int) push_data,\n             res);\n    fclose (f);\n  }\n}\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n\n  /* Ensure this is not a TLS connection in this non-TLS function. */\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    mhd_log_probe(\"early_return_notconn\", connection, r_iov, push_data, 0U, (ssize_t) MHD_ERR_NOTCONN_);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  mhd_log_probe(\"after_calc_items_to_send\", connection, r_iov, push_data, items_to_send, 0);\n\n  /* Reduce to the platform iov limit if necessary. Use IOV_MAX if available. */\n#ifdef IOV_MAX\n  if (IOV_MAX < (long) items_to_send)\n  {\n    mhd_assert (0 < IOV_MAX);\n    if (0 == IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = (size_t) IOV_MAX;\n    /* Violation scenario in original: by-value 'push_data' might be modified. */\n    push_data = false; /* Incomplete response */\n    mhd_log_probe(\"after_reduce_iov_max_push_data_false\", connection, r_iov, push_data, items_to_send, 0);\n  }\n#endif\n\n  /* Use writev for vectorized write. This preserves the original\n     intention of sending multiple iovecs in a single syscall. */\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                (int) items_to_send);\n\n  mhd_log_probe(\"after_send_call\", connection, r_iov, push_data, items_to_send, res);\n\n  if (0 > res)\n  {\n    const int err = errno;\n\n    if ((err == EAGAIN) || (err == EWOULDBLOCK))\n    {\n      /* EAGAIN --- no longer write-ready */\n      mhd_log_probe(\"eagain_return\", connection, r_iov, push_data, items_to_send, res);\n      return MHD_ERR_AGAIN_;\n    }\n    if (err == EINTR)\n      return MHD_ERR_AGAIN_;\n    if (err == ECONNRESET)\n      return MHD_ERR_CONNRESET_;\n    if (err == EPIPE)\n      return MHD_ERR_PIPE_;\n    if (err == EOPNOTSUPP)\n      return MHD_ERR_OPNOTSUPP_;\n    if (err == ENOTCONN)\n      return MHD_ERR_NOTCONN_;\n    if (err == EINVAL)\n      return MHD_ERR_INVAL_;\n    if (err == ENOMEM)\n      return MHD_ERR_NOMEM_;\n    if (err == EBADF)\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  mhd_log_probe(\"returning_success\", connection, r_iov, push_data, items_to_send, res);\n  return res;\n}\n\nstatic void pre_send_setopt(struct MHD_Connection *c, bool a, bool b) { (void)c; (void)a; (void)b; }\nstatic void post_send_setopt(struct MHD_Connection *c, bool a, bool b) { (void)c; (void)a; (void)b; }\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The parameter push_data is a by-value function parameter and it is assigned to inside the function (e.g. push_data = false in the _MHD_IOV_MAX branch and again in the Windows branch when items_to_send > UINT32_MAX). MISRA C 2023 Rule 17.8 states a function parameter shall not be modified (the object addressed by a pointer parameter may be modified, but not the parameter itself). Assigning to push_data therefore violates Rule 17.8. \n\nRemediation: copy the parameter into a local variable at the function start (e.g. bool local_push = push_data;) and modify local_push instead; then use local_push in subsequent calls/logic. This preserves behavior while complying with the rule."
}