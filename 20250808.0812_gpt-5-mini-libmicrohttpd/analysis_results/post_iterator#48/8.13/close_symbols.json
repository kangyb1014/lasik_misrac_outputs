{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. A pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Session",
    "struct Request",
    "memcpy (declaration)",
    "strcmp (declaration)",
    "callback prototype that declares the type of the 'cls' parameter (registration/signature in the HTTP lib)"
  ],
  "explanation": "1) struct Session: Essential to know the exact declaration of session->value_1, session->value_2 and session->sid (types, array sizes and any const qualifiers). The function writes into value_1/value_2 (memcpy and null-termination). If those fields are declared const or point-to-const, the code would violate the rule (modifying through a pointer to const). Also sizes are needed to validate the code paths that crop/discard data.\n\n2) struct Request: Required to know the declaration of the session member (its type and any const qualification). If Request::session is declared as 'const struct Session *' or otherwise const-qualified, then post_iterator modifies objects via a pointer-to-const (request->session->value_1 etc.), which would violate the rule.\n\n3) memcpy (declaration): The parameter qualifiers for memcpy (standard: void *dest, const void *src) must be known to check that a pointer-to-const is not being used as the destination. Knowing memcpy's prototype confirms that the destination argument must be non-const and that passing &session->value_n is a write operation to a non-const object.\n\n4) strcmp (declaration): Confirms that strcmp takes const char * arguments. This verifies that use of key and string literals is compatible with const qualification (helps show where pointers should be const and that no const-discarding occurs when calling strcmp).\n\n5) callback prototype that declares the type of the 'cls' parameter (registration/signature in the HTTP lib): The library's callback typedef/prototype that defines the type of the cls parameter (e.g. whether the callback is declared to receive void *cls or const void *cls) is required. If the library supplies cls as a const-qualified pointer (or the registration API expects a const pointer) but this function assigns it to a non-const struct Request *, that would be a const-discard and a potential MISRA violation.\n\nThese symbols together allow determination of whether the function writes through pointers that are or should be const-qualified, and whether it discards const qualifiers when casting/assigning pointers \u2014 the core checks for the cited MISRA rule."
}