{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "mhd_assert",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "_MHD_RED_ZONE_SIZE",
    "__asan_region_is_poisoned",
    "memset",
    "memcpy"
  ],
  "explanation": "Explain why each symbol is required for checking the MISRA rule (function parameter shall not be modified):\n\n- struct MemoryPool\n  Need the definition (fields: memory, pos, end, size, etc.) to determine which writes (e.g. pool->pos = ...) modify the object pointed to by the 'pool' parameter (permitted) versus any possible assignments to the parameter variable 'pool' itself (forbidden). Also needed to confirm whether any member access is actually an alias that could reassign the parameter.\n\n- ROUND_TO_ALIGN\n  This macro/function is invoked with pool->pos and other offsets. If ROUND_TO_ALIGN is a macro with side effects (e.g. assigns to its argument) it could modify a parameter expression; its definition is required to prove it does not reassign function parameters.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE\n  Same reason as ROUND_TO_ALIGN: this expansion is used in comparisons and assignments; its definition must be examined to ensure it does not modify any parameter or subexpression (for example via an lvalue or assignment in a macro).\n\n- mp_ptr_diff_\n  Called with (old, pool->memory). If this is a macro it could have side effects on its arguments; the symbol's definition is required to show it only computes a difference (no assignment to 'old' or other parameters).\n\n- mp_ptr_le_\n  Called with (pool->memory, old). Need its definition to ensure it does not modify either pointer argument (it is expected to be a comparator but could be a macro with side-effects).\n\n- mhd_assert\n  Usually a macro wrapping condition checks. Because it is used multiple times with expressions involving parameters, its expansion could, in principle, assign to parameters or call functions that do so. Its definition is required to ensure it has no side effects that reassign function parameters.\n\n- _MHD_POISON_MEMORY\n  This macro/function is called with pointer expressions (old + new_size, old, etc.). We must confirm it only writes to the memory addressed and does not reassign the pointer parameter variables passed to it (e.g. via macro argument aliasing or assignment in the macro body).\n\n- _MHD_UNPOISON_MEMORY\n  Same as above: confirm it only operates on memory and does not modify the pointer parameter variables passed into MHD_pool_reallocate.\n\n- _MHD_RED_ZONE_SIZE\n  Constant/macro used in arithmetic and comparisons that affect control flow. Its definition/value is required to understand calculations that decide in-place resize and to ensure no hidden macro side effects.\n\n- __asan_region_is_poisoned\n  The ASAN check is used inside an mhd_assert. Its prototype/definition is needed to confirm it does not perform any modifications to its pointer or size arguments (it is expected to be a query-only function).\n\n- memset\n  Standard library function used to zero memory. Included to confirm the expected semantics (writes to *old memory but does not modify the pointer variable 'old'). Useful for explicit reasoning that only the pointee is changed, not the parameter variable.\n\n- memcpy\n  Standard library function used to move data. Included to confirm it only writes to the pointee(s) and does not modify pointer parameters.\n\nRationale summary: To decide whether MHD_pool_reallocate violates the MISRA rule you must distinguish (a) assignments or side-effects that rebind parameter variables (forbidden) from (b) writes to objects pointed to by pointer parameters (permitted). Any macro/function used in expressions that reference parameters must be inspected to ensure it does not contain hidden assignments to those parameter variables. The symbols above are exactly the macros/functions/constants and the pool structure whose definitions/implementations are necessary to make that determination."
}