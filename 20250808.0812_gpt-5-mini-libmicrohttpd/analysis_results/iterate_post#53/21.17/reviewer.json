{
  "user_message": "An agent A claimed that the following iterate_post code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of iterate_post.\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs when the POST field named \"name\" has 'data' of length 'size' that is not null-terminated. The code checks only that size > 0 and size <= MAXNAMESIZE, then passes 'data' (which may not be '\\0'-terminated) to snprintf with a \"%s\" format specifier. snprintf will read beyond the provided object bounds searching for a terminator, resulting in an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind { MHD_VAL_KIND = 0 };\nstatic const size_t MAXANSWERSIZE = 512;\nstatic const size_t MAXNAMESIZE = 20;\nstatic const char GREETINGPAGE[] = \"<html><body><h1>Welcome, %s!</center></h1></body></html>\";\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if (f == NULL)\n  {\n    return; /* Do not abort the original function behavior. */\n  }\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputs(\"\\n\", f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  /* Log entry and pointers/sizes for diagnostics. */\n  probe_log(\"iterate_post: entry key=%p size=%zu data=%p con_info=%p\", (const void *)key, size, (const void *)data, (const void *)con_info);\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    probe_log(\"iterate_post: matched key 'name'\");\n\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      /* Before calling snprintf, probe whether 'data' contains a '\\0' within the provided size. */\n      void *term = memchr(data, '\\0', size);\n      if (term != NULL)\n      {\n        size_t pos = (size_t)((const char *)term - data);\n        probe_log(\"iterate_post: data appears NUL-terminated within size at offset %zu\", pos);\n      }\n      else\n      {\n        probe_log(\"iterate_post: data NOT NUL-terminated within provided size (%zu). Using %%s in snprintf will read beyond bounds.\", size);\n      }\n\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n      {\n        probe_log(\"iterate_post: malloc failed for answerstring (size %zu)\", MAXANSWERSIZE);\n        return MHD_NO;\n      }\n\n      probe_log(\"iterate_post: about to call snprintf(answerstring=%p, MAXANSWERSIZE=%zu, GREETINGPAGE, data=%p)\", (void *)answerstring, MAXANSWERSIZE, (const void *)data);\n      /* Original behavior retained: this snprintf may read beyond 'data' if 'data' is not NUL-terminated. */\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n\n      probe_log(\"iterate_post: snprintf completed; answerstring=%p contents_start='%.64s'\", (void *)answerstring, answerstring);\n      con_info->answerstring = answerstring;\n    }\n    else\n    {\n      probe_log(\"iterate_post: size check failed (size=%zu), setting con_info->answerstring = NULL\", size);\n      con_info->answerstring = NULL;\n    }\n\n    probe_log(\"iterate_post: returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  probe_log(\"iterate_post: key not matched, returning MHD_YES\");\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The scenario described by agent A is correct about the runtime defect: if the POST field 'data' is not NUL-terminated, using snprintf with the \"%s\" format will cause the library to read bytes past the provided buffer (searching for a terminator), so there is a potential out\u2011of\u2011bounds read.\n\nHowever, the specific MISRA C 2023 rule cited by agent A (21.17) as given in your excerpt explicitly concerns the string handling functions from <string.h> (memcpy, strcpy, strlen, etc.). snprintf is a <stdio.h> formatting function, not one of the <string.h> functions named in the rule text. Therefore the code exhibits a genuine out\u2011of\u2011bounds string/read risk, but it is not a direct violation of MISRA C 2023 Rule 21.17 as stated. The report is a correct identification of a bug, but it misattributes the violation to 21.17.\n\nRecommended fixes: ensure the incoming data is NUL-terminated within size before using \"%s\", or use a bounded format such as \"%.*s\" with the known size, or copy/terminate the input into a local buffer of size+1 before passing to snprintf."
}