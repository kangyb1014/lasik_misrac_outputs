{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_np_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY_NP) && defined(HAVE_GETPID)\n  /* NetBSD style */\n  cpuset_t *cpuset_ptr;\n  cpuset_ptr = cpuset_create ();\n  if (NULL != cpuset_ptr)\n  {\n    if (0 == sched_getaffinity_np (getpid (), cpuset_size (cpuset_ptr),\n                                   cpuset_ptr))\n    {\n      cpuid_t cpu_num;\n#if defined(HAVE_SYSCONF) && defined(HAVE_DECL__SC_NPROCESSORS_CONF)\n      unsigned int max_num = 0;\n      long sc_value;\n      sc_value = sysconf (_SC_NPROCESSORS_ONLN);\n      if (0 < sc_value)\n        max_num = (unsigned int) sc_value;\n      if (0 < max_num)\n      {\n        ret = 0;\n        for (cpu_num = 0; cpu_num < max_num; ++cpu_num)\n          if (0 < cpuset_isset (cpu_num, cpuset_ptr))\n            ++ret;\n      }\n      else /* Combined with the next 'if' */\n#endif /* HAVE_SYSCONF && HAVE_DECL__SC_NPROCESSORS_CONF */\n      if (1)\n      {\n        int res;\n        cpu_num = 0;\n        ret = 0;\n        do\n        {\n          res = cpuset_isset (cpu_num++, cpuset_ptr);\n          if (0 < res)\n            ++ret;\n        } while (0 <= res);\n      }\n#ifdef __NetBSD__\n      if (0 == ret)\n      {\n        /* On NetBSD \"unset\" affinity (exactly zero CPUs) means\n           \"all CPUs are available\". */\n        ret = mhd_tool_get_sys_cpu_count_sysctl_ ();\n      }\n#endif /* __NetBSD__ */\n    }\n    cpuset_destroy (cpuset_ptr);\n  }\n#endif /* HAVE_SCHED_GETAFFINITY_NP && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SCHED_GETAFFINITY_NP",
    "HAVE_GETPID",
    "HAVE_SYSCONF",
    "HAVE_DECL__SC_NPROCESSORS_CONF",
    "__NetBSD__",
    "cpuset_t",
    "cpuset_create",
    "cpuset_size",
    "cpuset_destroy",
    "cpuset_isset",
    "sched_getaffinity_np",
    "getpid",
    "cpuid_t",
    "sysconf",
    "_SC_NPROCESSORS_ONLN",
    "mhd_tool_get_sys_cpu_count_sysctl_"
  ],
  "explanation": "For each symbol: \n- HAVE_SCHED_GETAFFINITY_NP: Conditional compilation macro that gates use of sched_getaffinity_np. You must know whether this macro is defined by the build environment to determine if the (potentially nonstandard) call is actually compiled \u2014 essential to decide if a language/compiler extension is used. \n- HAVE_GETPID: As above, controls inclusion of getpid usage; needed to know whether the getpid() call (and the guarded code) is compiled. \n- HAVE_SYSCONF: Controls use of sysconf; required to determine whether sysconf and associated platform-specific constants are used. \n- HAVE_DECL__SC_NPROCESSORS_CONF: Controls use of the _SC_NPROCESSORS_* constant; required to know whether reliance on nonportable sysconf name is compiled. \n- __NetBSD__: Target/platform predefined macro supplied by the compiler. Predefined implementation macros are compiler/target specific; their presence can indicate use of platform/compiler provided extensions or behavior that is outside standard C. \n- cpuset_t: Type used for CPU sets; this is platform/OS-specific (NetBSD/cpuset API). You must inspect its origin to decide if it is a compiler or platform extension (nonstandard language or ABI usage). \n- cpuset_create: Platform-specific API to allocate a cpuset. Needed to determine whether nonstandard library/platform APIs are used in compiled code paths. \n- cpuset_size: Platform-specific API to obtain cpuset size; needed to know whether nonstandard API (and possibly macros or inline helpers) are used. \n- cpuset_destroy: Platform-specific cleanup function; included for the same reason as other cpuset_* symbols. \n- cpuset_isset: Platform-specific test routine used in a loop; must be known to see if platform-specific semantics or compiler-provided intrinsics/extension behavior are present. \n- sched_getaffinity_np: Function with ``_np'' (non-portable) suffix; commonly a nonstandard extension \u2014 must be checked against compiler/documentation to determine if it is a language/compiler extension or merely a library/OS API. \n- getpid: POSIX/library call gated by HAVE_GETPID; include to confirm whether standard POSIX or an extension is being used in the compiled configuration. \n- cpuid_t: Type for CPU indices \u2014 likely a typedef from platform headers; needed to check whether it is a compiler-provided typedef/extension. \n- sysconf: Standard/POSIX-like function whose use is conditional; must be inspected to ensure no compiler-specific extension is being relied on. \n- _SC_NPROCESSORS_ONLN: system-specific sysconf name; may not be standardized across C implementations \u2014 required to decide if the code depends on implementation-defined constants (not a language extension but relevant to portability checks). \n- mhd_tool_get_sys_cpu_count_sysctl_: Local helper called when NetBSD semantics apply; include to inspect whether that helper or its headers introduce compiler-specific extensions.\n\nThese symbols are needed because the MISRA rule in question requires determining whether any compiler/language extensions are being used in code paths that actually compile. That determination depends on which conditional macros are defined, whether compiler/predefined target macros (e.g. __NetBSD__) are present, and whether the functions/types used are standard C/POSIX or documented compiler/implementation extensions. The listed symbols let the analyzer (a) know which branches are active and (b) inspect any referenced types/functions to see if they are explicitly documented as compiler language extensions."
}