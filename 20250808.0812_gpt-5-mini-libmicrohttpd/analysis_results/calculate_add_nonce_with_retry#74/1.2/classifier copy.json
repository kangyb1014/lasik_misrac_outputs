{
  "user_message": "<misra_rule>
  MISRA C 2023 Rule 1.2 is: Language extensions should not be used.
  You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.
  </misra_rule>
  <response format>
  Provide your answer with these fields.
  - is_rule_violated: whether the rule is violated or not (true/false),
  - scenario: a specific violation scenario.
  - test_code: a modified calculate_add_nonce_with_retry code that contains useful probe functions that print useful logs to a file \"/tmp/logs/592.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.
  Here are the constraints for the test code:
  - DO NOT introduce new violations to demonstrate your scenario.
  - The test code MUST be compilable and executable.
  - The test code MUST include line breaks.
  - The test code MUST preserve the original logic of calculate_add_nonce_with_retry as much as possible.
  - You MUST NOT define the main function.
  - You MUST NOT define macros.
  - The test code MUST not contain any mock functions.
  </response format>
  <target_code>
  Here is the code of calculate_add_nonce_with_retry:
  ```c
  static bool
  calculate_add_nonce_with_retry (struct MHD_Connection *const connection,
                                  const char *realm,
                                  struct DigestAlgorithm *da,
                                  char *nonce)
  {
    const uint64_t timestamp1 = MHD_monotonic_msec_counter ();
    const size_t realm_len = strlen (realm);
    mhd_assert (! da->hashing);
  
  #ifdef HAVE_MESSAGES
    if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)
      MHD_DLOG (connection->daemon,
                _ (\"Random value was not initialised by \" \\
                   \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\
                   \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\
                   \"are predictable.\
  \"));
  #endif
  
    if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,
                               nonce))
    {
      /* Either:
       * 1. The same nonce was already generated. If it will be used then one
       * of the clients will fail (as no initial 'nc' value could be given to
       * the client, the second client which will use 'nc=00000001' will fail).
       * 2. Another nonce uses the same slot, and this nonce never has been
       * used by the client and this nonce is still fresh enough.
       */
      const size_t digest_size = digest_get_size (da);
      char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];
      uint64_t timestamp2;
  #ifdef MHD_DIGEST_HAS_EXT_ERROR
      if (digest_ext_error (da))
        return false; /* No need to re-try */
  #endif /* MHD_DIGEST_HAS_EXT_ERROR */
      if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)
        return false; /* No need to re-try */
  
      timestamp2 = MHD_monotonic_msec_counter ();
      if (timestamp1 == timestamp2)
      {
        /* The timestamps are equal, need to generate some arbitrary
         * difference for nonce. */
        /* As the number is needed only to differentiate clients, weak
         * pseudo-random generators could be used. Seeding is not needed. */
        uint64_t base1;
        uint32_t base2;
        uint16_t base3;
        uint8_t base4;
  #ifdef HAVE_RANDOM
        base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);
        base4 = 0xb8;
  #elif defined(HAVE_RAND)
        base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);
        base4 = 0x92;
  #else
        /* Monotonic msec counter alone does not really help here as it is already
           known that this value is not unique. */
        base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);
        base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);
        base2 = _MHD_ROTR32 (base2, 4);
        base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);
        base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);
        base1 = ((uint64_t) MHD_monotonic_msec_counter ())
                ^ UINT64_C (0xccab93f72cf5b15);
  #endif
        base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);
        base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));
        base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);
        base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);
        /* Use up to 127 ms difference */
        timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);
        if (timestamp1 == timestamp2)
          timestamp2 -= 2; /* Fallback value */
      }
      digest_reset (da);
      if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,
                                 nonce2))
      {
        /* No free slot has been found. Re-tries are expensive, just use
         * the generated nonce. As it is not stored in nonce-nc map array,
         * the next request of the client will be recognized as valid, but 'stale'
         * so client should re-try automatically. */
        return false;
      }
      memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));
    }
    return true;
  }
  ```
  </target_code>
  <additional code>Here are the definitions of symbols that are close to the target function calculate_add_nonce_with_retry:
  #define _MHD_ROTL32(value32, bits) ((uint32_t)__builtin_rotateleft32((value32),(bits)))
  ...
  #define _MHD_ROTR32(value32, bits) ((uint32_t)__builtin_rotateright32((value32),(bits)))
  ...
  #define mhd_assert(ignore) ((void)0)
  ...
  void
  MHD_DLOG (const struct MHD_Daemon *daemon,
            const char *format,
            ...)
  {
    va_list va;
  
    if (0 == (daemon->options & MHD_USE_ERROR_LOG))
      return;
    va_start (va, format);
    daemon->custom_error_log (daemon->custom_error_log_cls,
                              format,
                              va);
    va_end (va);
  }
  ...
  #define NONCE_STD_LEN(digest_size) ((digest_size)*2+TIMESTAMP_CHARS_LEN)
  ...
  #define MAX_DIGEST SHA512_256_DIGEST_SIZE
  ...
  #define DAUTH_JUMPBACK_MAX (0x7F)
  ...
  #define digest_ext_error(da) (false)
  </additional code>
  Judge whether the above calculate_add_nonce_with_retry code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "The code relies on compiler-specific builtins via the macros _MHD_ROTL32 and _MHD_ROTR32 which expand to GCC/Clang __builtin_rotateleft32 and __builtin_rotateright32. These __builtin_* functions are compiler language extensions (GCC/Clang builtins) and thus violate MISRA C 2023 Rule 1.2 (language extensions should not be used).",
  "test_code": "#include <stdio.h>
  #include <stdarg.h>
  #include <stdint.h>
  #include <stddef.h>
  #include <stdbool.h>
  #include <string.h>
  #include <stdlib.h>
  
  /* Minimal type declarations so the function compiles in-context. */
  struct MHD_Daemon
  {
    int options;
    void (*custom_error_log)(void *, const char *, va_list);
    void *custom_error_log_cls;
    size_t digest_auth_rand_size;
    size_t nonce_nc_size;
  };
  
  struct MHD_Connection
  {
    struct MHD_Daemon *daemon;
  };
  
  struct DigestAlgorithm
  {
    int hashing;
  };
  
  /* External functions (prototypes only) - implementations are expected
     to be provided by the surrounding project. */
  uint64_t MHD_monotonic_msec_counter (void);
  const struct MHD_Daemon *MHD_get_master (const struct MHD_Daemon *d);
  size_t digest_get_size (struct DigestAlgorithm *da);
  void digest_reset (struct DigestAlgorithm *da);
  bool calculate_add_nonce (struct MHD_Connection *const connection,
                             uint64_t timestamp,
                             const char *realm,
                             size_t realm_len,
                             struct DigestAlgorithm *da,
                             char *nonce);
  
  /* Simple probe logger that appends control path and state to a file. */
  static void
  probe_log (const char *fmt, ...)
  {
    FILE *f = fopen (\"/tmp/logs/592.txt\", \"a\");
    if (f == NULL)
      return;
  
    va_list ap;
    va_start (ap, fmt);
    vfprintf (f, fmt, ap);
    fprintf (f, \"\
  \");
    va_end (ap);
    fclose (f);
  }
  
  /* Modified function: preserves original logic as much as possible but
     emits probe logs documenting decisions and key state. */
  static bool
  calculate_add_nonce_with_retry (struct MHD_Connection *const connection,
                                  const char *realm,
                                  struct DigestAlgorithm *da,
                                  char *nonce)
  {
    const uint64_t timestamp1 = MHD_monotonic_msec_counter ();
    const size_t realm_len = strlen (realm);
    /* original had: mhd_assert (! da->hashing); */
  
    probe_log (\"enter: timestamp1=%"
}