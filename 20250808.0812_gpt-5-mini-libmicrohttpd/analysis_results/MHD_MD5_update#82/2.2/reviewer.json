{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When MHD_FAVOR_SMALL_CODE is defined, the early 'if (0 == length) return;' shortcut is omitted. A call to MHD_MD5_update with length == 0 still executes operations such as computing bytes_have and performing ctx->count += length (adding zero). Those executed operations have no effect on program behaviour for length == 0, so they constitute dead code per MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_assert (int cond)\n{\n  (void) cond;\n}\nstatic void probe_log (const char *tag,\n                       const struct Md5Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length,\n                       unsigned int bytes_have)\n{\n  FILE *f = fopen(\"/tmp/logs/658.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log tag, length, bytes_have, ctx->count and a few bytes of buffer/data */\n  fprintf (f, \"[%s] length=%zu bytes_have=%u ctx_count=%llu\\n\",\n           tag, length, bytes_have, (unsigned long long) ctx->count);\n  if ((data != NULL) && (length > 0))\n  {\n    size_t i, to = (length < 8) ? length : 8;\n    fprintf (f, \"  data[0..%zu):\", to);\n    for (i = 0; i < to; ++i)\n      fprintf (f, \" %02x\", (unsigned) data[i]);\n    fprintf (f, \"\\n\");\n  }\n  /* Dump first words of internal buffer for context (not endian-sensitive) */\n  fprintf (f, \"  buffer[0]=%08x buffer[1]=%08x\\n\",\n           ctx->buffer[0], ctx->buffer[1]);\n  fclose (f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    probe_log(\"early_return\", ctx, data, length, 0);\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (64 - 1));\n  probe_log(\"before_count_inc\", ctx, data, length, bytes_have);\n  ctx->count += length;\n  probe_log(\"after_count_inc\", ctx, data, length, bytes_have);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = 64 - bytes_have;\n    probe_log(\"have_bytes_branch\", ctx, data, length, bytes_have);\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n      probe_log(\"processed_full_block\", ctx, data, length, bytes_have);\n    }\n    else\n      probe_log(\"not_enough_to_fill\", ctx, data, length, bytes_have);\n  }\n\n  while (64 <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += 64;\n    length -= 64;\n    probe_log(\"processed_block_direct\", ctx, data, length, 0);\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    probe_log(\"copied_incomplete_block\", ctx, data, length, bytes_have);\n  }\n  else\n  {\n    probe_log(\"no_remaining_bytes\", ctx, data, length, bytes_have);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.2 targets operations that can be removed from the project without changing program behaviour. The statements in MHD_MD5_update (bytes_have calculation, ctx->count += length, subsequent branches/loops) are required for the normal (length != 0) case: they determine buffering, block processing and the maintained byte count. They are therefore not universally removable. The fact that, for one particular call where length == 0, some executed operations have no observable effect in that single execution does not make them dead code under Rule 2.2. Additionally, Note 1 points out timing can be observable behaviour (so removal may change timing), and reads/writes could matter for volatile or memory-mapped contexts. For these reasons the agent A\u2019s claim that the code violates MISRA C 2023 Rule 2.2 is incorrect."
}