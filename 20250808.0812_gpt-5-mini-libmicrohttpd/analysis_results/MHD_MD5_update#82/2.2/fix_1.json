{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_assert (int cond)\n{\n  (void) cond;\n}\nstatic void probe_log (const char *tag,\n                       const struct Md5Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length,\n                       unsigned int bytes_have)\n{\n  FILE *f = fopen(\"/tmp/logs/658.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log tag, length, bytes_have, ctx->count and a few bytes of buffer/data */\n  fprintf (f, \"[%s] length=%zu bytes_have=%u ctx_count=%llu\\n\",\n           tag, length, bytes_have, (unsigned long long) ctx->count);\n  if ((data != NULL) && (length > 0))\n  {\n    size_t i, to = (length < 8) ? length : 8;\n    fprintf (f, \"  data[0..%zu):\", to);\n    for (i = 0; i < to; ++i)\n      fprintf (f, \" %02x\", (unsigned) data[i]);\n    fprintf (f, \"\\n\");\n  }\n  /* Dump first words of internal buffer for context (not endian-sensitive) */\n  fprintf (f, \"  buffer[0]=%08x buffer[1]=%08x\\n\",\n           ctx->buffer[0], ctx->buffer[1]);\n  fclose (f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    probe_log(\"early_return\", ctx, data, length, 0);\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (64 - 1));\n  probe_log(\"before_count_inc\", ctx, data, length, bytes_have);\n  ctx->count += length;\n  probe_log(\"after_count_inc\", ctx, data, length, bytes_have);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = 64 - bytes_have;\n    probe_log(\"have_bytes_branch\", ctx, data, length, bytes_have);\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n      probe_log(\"processed_full_block\", ctx, data, length, bytes_have);\n    }\n    else\n      probe_log(\"not_enough_to_fill\", ctx, data, length, bytes_have);\n  }\n\n  while (64 <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += 64;\n    length -= 64;\n    probe_log(\"processed_block_direct\", ctx, data, length, 0);\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    probe_log(\"copied_incomplete_block\", ctx, data, length, bytes_have);\n  }\n  else\n  {\n    probe_log(\"no_remaining_bytes\", ctx, data, length, bytes_have);\n  }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from md5.c:42:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\nmd5.c:401:13: note: in expansion of macro 'mhd_assert'\n  401 | static void mhd_assert (int cond)\n      |             ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nmd5.c:401:13: note: in expansion of macro 'mhd_assert'\n  401 | static void mhd_assert (int cond)\n      |             ^~~~~~~~~~\nmake[3]: *** [Makefile:2231: libmicrohttpd_la-md5.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_MD5_update as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "/* Guard the local mhd_assert definition so it doesn't conflict with a macro\n   definition coming from mhd_assert.h. If mhd_assert is already defined as a\n   macro, we skip defining the function. */\n#ifndef mhd_assert\nstatic void mhd_assert (int cond)\n{\n  (void) cond;\n}\n#endif\n\nstatic void probe_log (const char *tag,\n                       const struct Md5Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length,\n                       unsigned int bytes_have)\n{\n  FILE *f = fopen(\"/tmp/logs/658.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log tag, length, bytes_have, ctx->count and a few bytes of buffer/data */\n  fprintf (f, \"[%s] length=%zu bytes_have=%u ctx_count=%llu\\n\",\n           tag, length, bytes_have, (unsigned long long) ctx->count);\n  if ((data != NULL) && (length > 0))\n  {\n    size_t i, to = (length < 8) ? length : 8;\n    fprintf (f, \"  data[0..%zu):\", to);\n    for (i = 0; i < to; ++i)\n      fprintf (f, \" %02x\", (unsigned) data[i]);\n    fprintf (f, \"\\n\");\n  }\n  /* Dump first words of internal buffer for context (not endian-sensitive) */\n  fprintf (f, \"  buffer[0]=%08x buffer[1]=%08x\\n\",\n           ctx->buffer[0], ctx->buffer[1]);\n  fclose (f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    probe_log(\"early_return\", ctx, data, length, 0);\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (64 - 1));\n  probe_log(\"before_count_inc\", ctx, data, length, bytes_have);\n  ctx->count += length;\n  probe_log(\"after_count_inc\", ctx, data, length, bytes_have);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = 64 - bytes_have;\n    probe_log(\"have_bytes_branch\", ctx, data, length, bytes_have);\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n      probe_log(\"processed_full_block\", ctx, data, length, bytes_have);\n    }\n    else\n      probe_log(\"not_enough_to_fill\", ctx, data, length, bytes_have);\n  }\n\n  while (64 <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += 64;\n    length -= 64;\n    probe_log(\"processed_block_direct\", ctx, data, length, 0);\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    probe_log(\"copied_incomplete_block\", ctx, data, length, bytes_have);\n  }\n  else\n  {\n    probe_log(\"no_remaining_bytes\", ctx, data, length, bytes_have);\n  }\n}\n",
  "explanation": "The build error was caused by a name conflict: mhd_assert is sometimes defined as a macro in mhd_assert.h, so providing a function with the same name breaks compilation. To fix this without changing behavior I wrapped the local function definition in #ifndef mhd_assert. If the macro exists the function definition is skipped (the macro provides the no-op), otherwise the function is defined as before. No macros were defined and the original logic of MHD_MD5_update and probe_log is preserved."
}