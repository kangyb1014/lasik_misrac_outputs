{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'post_process_multipart': {'callees': ['find_boundary', 'process_multipart_headers', 'MHD_str_equal_caseless_n_', 'process_value_to_boundary', 'free_unmarked', '__builtin_unreachable'], 'callers': ['MHD_post_process']}, 'find_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}, 'MHD_str_equal_caseless_n_': {'callees': ['charsequalcaseless'], 'callers': ['MHD_create_post_processor', 'try_match_header', 'process_multipart_headers', 'post_process_multipart', 'MHD_post_process']}, 'process_value_to_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'free_unmarked': {'callees': [], 'callers': ['post_process_multipart', 'MHD_destroy_post_processor']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_post_process': {'callees': ['MHD_str_equal_caseless_n_', 'post_process_urlencoded', 'post_process_multipart'], 'callers': ['create_response', 'generate_page', 'answer_to_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_PostProcessor",
    "RN_Inactive",
    "RN_OptN",
    "RN_Dash",
    "RN_Dash2",
    "RN_Full",
    "enum PP_* (PP_Error, PP_Done, PP_Init, PP_NextBoundary, PP_ProcessEntryHeaders, PP_PerformCheckMultipart, PP_ProcessValueToBoundary, PP_PerformCleanup, PP_Nested_Init, PP_Nested_PerformMarking, PP_Nested_ProcessEntryHeaders, PP_Nested_ProcessValueToBoundary, PP_Nested_PerformCleanup, PP_ProcessKey, PP_ProcessValue, PP_Callback)",
    "NE_none",
    "NE_content_name",
    "NE_content_type",
    "NE_content_filename",
    "NE_content_transfer_encoding",
    "MHD_create_post_processor",
    "find_boundary",
    "process_multipart_headers",
    "process_value_to_boundary",
    "free_unmarked",
    "MHD_str_equal_caseless_n_",
    "MHD_STATICSTR_LEN_",
    "strstr",
    "strdup",
    "strlen",
    "memcpy",
    "memmove",
    "MHD_NO",
    "MHD_YES"
  ],
  "explanation": "For a correct bounds-safety analysis of memcpy/memmove and related string-handling here you must know how pp and the other helpers constrain buffer lengths and pointer validity:\n\n- struct MHD_PostProcessor\n  - Needed to see the exact layout/fields used here (buffer_size, buffer_pos, boundary, blen, nested_boundary, nlen, content_type, content_name, content_filename, content_transfer_encoding, dash_state, skip_rn, state, have, value_offset, must_ikvi). The code reads/writes these fields; their types and intended ranges are essential to check indexes and pointer arithmetic (buf = (char *)&pp[1], pp->buffer_pos, pp->buffer_size, blen/nlen etc.).\n\n- RN_Inactive, RN_OptN, RN_Dash, RN_Dash2, RN_Full\n  - The skip_rn state enum values control the early switch logic that advances ioff and affects which bytes are consumed; need their definitions to reason about branches and ioff increments (bounds implications).\n\n- enum PP_* (all listed PP_... states)\n  - The state machine values (PP_Error, PP_Done, PP_Init, ..., PP_Callback) are used to direct control flow that influences calls into helper routines and modifications of buffer_pos/ioff; definitions clarify legal transitions and when helpers are invoked (hence when memmove/memcpy operate on how many bytes).\n\n- NE_none, NE_content_name, NE_content_type, NE_content_filename, NE_content_transfer_encoding\n  - Flags set in pp->have are used by nested processing and cleanup; knowing these symbols clarifies when pointers (e.g. content_type/content_filename) may be NULL or live and whether free_unmarked may touch them.\n\n- MHD_create_post_processor\n  - The factory/allocation routine establishes how much memory is actually allocated for the pp structure plus the trailing internal buffer (buf = (char *)&pp[1]). To judge whether memcpy(&buf[pp->buffer_pos], &post_data[poff], max) is in-bounds you must know the allocation scheme and correspondence between buffer_size and the allocated tail space.\n\n- find_boundary\n  - Called repeatedly and may consume/inspect pp->buffer contents and update pp/state/ioff. Its semantics determine how much of the internal buffer can be considered parsed/consumed and whether it can leave pp->buffer_pos larger than expected. Also it returns failure/partial indications that affect whether the outer loop uses remaining bytes (thus affecting mem* usage).\n\n- process_multipart_headers\n  - Parses headers and may set/allocate/free content_type and other pointers (affecting later strdup/strstr/strlen uses) and updates ioff and state. Need to know whether it can read/write beyond buffer or rely on null-termination assumptions.\n\n- process_value_to_boundary\n  - Scans values up to a boundary and updates ioff/pp->buffer_pos/state. Its behavior affects how much of the buffer is considered consumed and when memmove/memcpy shifts data; its correctness/assumptions are required to prove overall bounds safety.\n\n- free_unmarked\n  - Frees or clears pp-owned pointers (e.g. nested_boundary, content_type). To ensure later uses (strdup/strlen/strstr, free) are on valid/non-freed memory you must know which fields free_unmarked touches and when.\n\n- MHD_str_equal_caseless_n_\n  - Used to test content_type against the literal \"multipart/mixed\". Its exact behavior (does it read beyond provided length, NUL handling) affects whether calling it with pp->content_type is safe.\n\n- MHD_STATICSTR_LEN_\n  - Macro/utility used to compute the offset into the matched literal (\"boundary=\"). Needed to verify the pointer arithmetic &pp->nested_boundary[MHD_STATICSTR_LEN_(\"boundary=\")] is within bounds of the located substring and consistent with strdup usage.\n\n- strstr\n  - Used to locate \"boundary=\" inside pp->content_type; correctness depends on content_type being a valid NUL-terminated string and not reading past allocated memory. Must inspect how/when content_type is set and whether it is NUL-terminated.\n\n- strdup\n  - Allocates and copies a NUL-terminated suffix of content_type into pp->nested_boundary. To ensure strdup reads only valid memory we must know that the passed pointer points to a valid NUL-terminated region and that length logic (nlen = strlen(pp->nested_boundary)) is safe.\n\n- strlen\n  - Used to set pp->nlen after strdup; need to ensure the argument is NUL-terminated and not NULL.\n\n- memcpy\n  - One of the core functions under MISRA scrutiny here; we must check every call site (source/dest pointers and max) for possible out-of-bounds, so we need the buffer_size, buffer_pos, post_data_len/post_data pointer valid ranges and allocation strategy from MHD_create_post_processor.\n\n- memmove\n  - Used to compact the internal buffer after consuming ioff bytes; correctness depends on buffer size, buffer_pos, ioff ranges and that destination/source ranges lie within the allocated tail buffer.\n\n- MHD_NO, MHD_YES\n  - Return/result constants (and MHD_Result type) are used by helpers and control flow (early returns). Knowing exact return semantics is necessary to reason about partial-processing branches where buffer contents remain unconsumed (affecting subsequent memcpy/memmove invocations).\n\nSummary: to prove the string functions in this function cannot read/write out of bounds you must inspect the concrete memory layout and invariants of the MHD_PostProcessor object (allocation size vs buffer_size), the helper routines that manipulate pp->buffer_pos/ioff/state (find_boundary, process_multipart_headers, process_value_to_boundary, free_unmarked), and the string utilities used (strstr, strdup, strlen, MHD_str_equal_caseless_n_, plus the actual memcpy/memmove implementations/semantics). These symbols together let an analyzer determine that all memcpy/memmove/strdup/strlen/strstr calls operate on objects with valid lengths and terminators."
}