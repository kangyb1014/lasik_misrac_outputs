{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  FILE *file;\n  int fd;\n  DIR *dir;\n  struct stat buf;\n  char emsg[1024];\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  file = fopen (&url[1], \"rb\");\n  if (NULL != file)\n  {\n    fd = fileno (file);\n    if (-1 == fd)\n    {\n      (void) fclose (file);\n      return MHD_NO;     /* internal error */\n    }\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      fclose (file);\n      file = NULL;\n    }\n  }\n\n  if (NULL == file)\n  {\n    dir = opendir (\".\");\n    if (NULL == dir)\n    {\n      /* most likely cause: more concurrent requests than\n         available file descriptors / 2 */\n      snprintf (emsg,\n                sizeof (emsg),\n                \"Failed to open directory `.': %s\\n\",\n                strerror (errno));\n      response = MHD_create_response_from_buffer (strlen (emsg),\n                                                  emsg,\n                                                  MHD_RESPMEM_MUST_COPY);\n      if (NULL == response)\n        return MHD_NO;\n      ret = MHD_queue_response (connection,\n                                MHD_HTTP_SERVICE_UNAVAILABLE,\n                                response);\n      MHD_destroy_response (response);\n    }\n    else\n    {\n      response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                    32 * 1024,\n                                                    &dir_reader,\n                                                    dir,\n                                                    &dir_free_callback);\n      if (NULL == response)\n      {\n        closedir (dir);\n        return MHD_NO;\n      }\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n    }\n  }\n  else\n  {\n    response = MHD_create_response_from_callback ((size_t) buf.st_size,\n                                                  32 * 1024, /* 32k page size */\n                                                  &file_reader,\n                                                  file,\n                                                  &file_free_callback);\n    if (NULL == response)\n    {\n      fclose (file);\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation: the explicit (void) casts for unused parameters (e.g. (void) cls; (void) version; (void) upload_data; (void) upload_data_size;) are executed no-op statements whose removal would not affect program behaviour \u2014 they constitute dead code per MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nstruct MHD_Response;\nstatic const char *MHD_HTTP_METHOD_GET = \"GET\";\nstatic const int MHD_RESPMEM_MUST_COPY = 0;\nstatic const size_t MHD_SIZE_UNKNOWN = (size_t)-1;\nstatic const int MHD_HTTP_SERVICE_UNAVAILABLE = 503;\nstatic const int MHD_HTTP_OK = 200;\nstruct MHD_Response *\nMHD_create_response_from_buffer(size_t, const void *, int);\nstruct MHD_Response *\nMHD_create_response_from_callback(size_t, size_t, void *, void *, void *);\nvoid MHD_destroy_response(struct MHD_Response *);\nenum MHD_Result\nMHD_queue_response(struct MHD_Connection *, int, struct MHD_Response *);\nstatic void probe_log(const char *stage,\n                      const char *method,\n                      const char *url,\n                      const void *req_cls)\n{\n  FILE *f = fopen(\"/tmp/logs/442.txt\", \"a\");\n  if (f != NULL)\n  {\n    /* Log simple control/state information; avoid changing program state. */\n    fprintf(f, \"%s: method=%s, url=%s, req_cls=%p\\n\",\n            stage,\n            (method != NULL) ? method : \"(null)\",\n            (url != NULL) ? url : \"(null)\",\n            req_cls);\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  FILE *file;\n  int fd;\n  DIR *dir;\n  struct stat buf;\n  char emsg[1024];\n\n  /* Unused parameter casts - these no-op statements are the subject of the\n     Rule 2.2 violation: they are executed but removing them does not change\n     program behaviour. */\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Probe: record that the explicit (void) casts were reached. */\n  probe_log(\"params_ignored\", method, url, (const void *) *req_cls);\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n  {\n    probe_log(\"unexpected_method\", method, url, (const void *) *req_cls);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  probe_log(\"method_ok\", method, url, (const void *) *req_cls);\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    probe_log(\"first_call_set_req_cls\", method, url, (const void *) *req_cls);\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n  probe_log(\"processing_request\", method, url, (const void *) *req_cls);\n\n  file = fopen (&url[1], \"rb\");\n  if (NULL != file)\n  {\n    probe_log(\"file_opened\", method, url, (const void *) file);\n    fd = fileno (file);\n    if (-1 == fd)\n    {\n      (void) fclose (file);\n      probe_log(\"fileno_failed\", method, url, (const void *) file);\n      return MHD_NO;     /* internal error */\n    }\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      fclose (file);\n      file = NULL;\n      probe_log(\"not_regular_file\", method, url, (const void *) file);\n    }\n  }\n  else\n  {\n    probe_log(\"file_open_failed\", method, url, (const void *) file);\n  }\n\n  if (NULL == file)\n  {\n    dir = opendir (\".\");\n    if (NULL == dir)\n    {\n      /* most likely cause: more concurrent requests than\n         available file descriptors / 2 */\n      snprintf (emsg,\n                sizeof (emsg),\n                \"Failed to open directory `.': %s\\n\",\n                strerror (errno));\n      response = MHD_create_response_from_buffer (strlen (emsg),\n                                                  emsg,\n                                                  MHD_RESPMEM_MUST_COPY);\n      if (NULL == response)\n        return MHD_NO;\n      ret = MHD_queue_response (connection,\n                                MHD_HTTP_SERVICE_UNAVAILABLE,\n                                response);\n      MHD_destroy_response (response);\n      probe_log(\"dir_open_failed_response_queued\", method, url, (const void *) response);\n    }\n    else\n    {\n      response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                    32 * 1024,\n                                                    &dir_reader,\n                                                    dir,\n                                                    &dir_free_callback);\n      if (NULL == response)\n      {\n        closedir (dir);\n        return MHD_NO;\n      }\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      probe_log(\"dir_response_queued\", method, url, (const void *) response);\n    }\n  }\n  else\n  {\n    response = MHD_create_response_from_callback ((size_t) buf.st_size,\n                                                  32 * 1024, /* 32k page size */\n                                                  &file_reader,\n                                                  file,\n                                                  &file_free_callback);\n    if (NULL == response)\n    {\n      fclose (file);\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n    probe_log(\"file_response_queued\", method, url, (const void *) response);\n  }\n  probe_log(\"returning\", method, url, (const void *) (uintptr_t) ret);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Although the (void) parameter casts are no\u2011op expression statements (they do not change program state), MISRA Rule 2.2 is intended to prohibit genuinely redundant code that can safely be removed and that increases maintenance risk. The idiom (void) parameter; is a standard, intentional way to mark an unused parameter and suppress compiler diagnostics. Such statements document intent and, in the strict sense used by MISRA, cannot be assumed harmless to remove (e.g. removal can alter timing or observable behaviour of an embedded system \u2014 see Note 1 of the rule). In practice MISRA guidance and tool chains treat explicit discards of unused parameters as an acceptable pattern rather than a Rule 2.2 violation. Therefore the claim that those casts constitute a Rule 2.2 violation is incorrect."
}