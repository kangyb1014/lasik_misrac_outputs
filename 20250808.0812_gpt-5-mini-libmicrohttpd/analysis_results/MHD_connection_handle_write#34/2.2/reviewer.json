{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When a connection enters one of the switch cases that currently call mhd_assert(0) \u2014 for example MHD_CONNECTION_INIT \u2014 the mhd_assert(0) expression is executed. In the provided code mhd_assert is defined as ((void)0), so those executed assert statements have no effect; removing them would not change program behaviour. Thus these executed no-op assert calls constitute dead code and violate MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct response_props {\n  int send_reply_body;\n  int chunked;\n};\nstruct rp_struct {\n  struct MHD_Response *response;\n  struct response_props props;\n  size_t rsp_write_position;\n  void *resp_sender;\n  void *resp_iov;\n  void *resp_iov_len;\n};\nstruct rq_struct {\n  const char *url;\n};\nstatic const int MHD_TLS_CONN_NO_TLS = 0;\nstatic const int MHD_TLS_CONN_CONNECTED = 2;\nstatic const int MHD_ERR_AGAIN_ = -2;\nstatic const int MHD_CONN_MUST_UPGRADE = 1;\nstatic const int MHD_RESP_SENDER_SENDFILE_ID = 1;\nstatic const int MHD_CONNECTION_INIT = 0;\nstatic const int MHD_CONNECTION_REQ_LINE_RECEIVING = 1;\nstatic const int MHD_CONNECTION_REQ_LINE_RECEIVED = 2;\nstatic const int MHD_CONNECTION_REQ_HEADERS_RECEIVING = 3;\nstatic const int MHD_CONNECTION_HEADERS_RECEIVED = 4;\nstatic const int MHD_CONNECTION_HEADERS_PROCESSED = 5;\nstatic const int MHD_CONNECTION_CONTINUE_SENDING = 6;\nstatic const int MHD_CONNECTION_BODY_RECEIVING = 7;\nstatic const int MHD_CONNECTION_BODY_RECEIVED = 8;\nstatic const int MHD_CONNECTION_FOOTERS_RECEIVING = 9;\nstatic const int MHD_CONNECTION_FOOTERS_RECEIVED = 10;\nstatic const int MHD_CONNECTION_FULL_REQ_RECEIVED = 11;\nstatic const int MHD_CONNECTION_START_REPLY = 12;\nstatic const int MHD_CONNECTION_HEADERS_SENDING = 13;\nstatic const int MHD_CONNECTION_HEADERS_SENT = 14;\nstatic const int MHD_CONNECTION_NORMAL_BODY_READY = 15;\nstatic const int MHD_CONNECTION_NORMAL_BODY_UNREADY = 16;\nstatic const int MHD_CONNECTION_CHUNKED_BODY_READY = 17;\nstatic const int MHD_CONNECTION_CHUNKED_BODY_UNREADY = 18;\nstatic const int MHD_CONNECTION_CHUNKED_BODY_SENT = 19;\nstatic const int MHD_CONNECTION_FOOTERS_SENDING = 20;\nstatic const int MHD_CONNECTION_FULL_REPLY_SENT = 21;\nstatic const int MHD_CONNECTION_CLOSED = 22;\nstatic const int MHD_CONNECTION_UPGRADE = 23;\nstatic const char HTTP_100_CONTINUE[] = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\";\nconst char *MHD_FUNC_ = \"MHD_connection_handle_write\";\nconst char *_(const char *s) { return s; }\nsize_t MHD_STATICSTR_LEN_(const char *s) { return strlen(s); }\nstatic void probe_log(const struct MHD_Connection *connection,\n                      const char *message)\n{\n  FILE *f = fopen(\"/tmp/logs/274.txt\", \"a\");\n  if (f)\n  {\n    const void *connp = (const void *) connection;\n    int state = -1;\n    const char *url = \"(null)\";\n    if (NULL != connection)\n    {\n      state = (int) connection->state;\n      /* guard access to nested fields */\n      if (NULL != connection->rq.url)\n        url = connection->rq.url;\n    }\n    fprintf(f, \"probe: conn=%p state=%d msg=%s url=%s\\n\",\n            connp, state, message, url);\n    fclose(f);\n  }\n}\nvoid mhd_assert(int cond)\n{\n  if (!cond)\n    abort();\n}\nint MHD_run_tls_handshake_(struct MHD_Connection *connection)\n{\n  (void) connection;\n  return 1; /* handshake completed */\n}\nvoid MHD_DLOG(struct MHD_Daemon *daemon, const char *fmt, ...)\n{\n  (void) daemon; (void) fmt;\n  /* no-op logger for compilation */\n}\nconst char *MHD_state_to_string(int state)\n{\n  switch (state) {\n  case MHD_CONNECTION_INIT: return \"INIT\";\n  case MHD_CONNECTION_HEADERS_SENDING: return \"HEADERS_SENDING\";\n  case MHD_CONNECTION_NORMAL_BODY_READY: return \"NORMAL_BODY_READY\";\n  default: return \"OTHER\";\n  }\n}\nvoid CONNECTION_CLOSE_ERROR(struct MHD_Connection *c, const char *msg)\n{\n  (void) c; (void) msg;\n}\nconst char *str_conn_error_(ssize_t r)\n{\n  (void) r;\n  return \"error\";\n}\nssize_t MHD_send_sendfile_(struct MHD_Connection *connection)\n{\n  (void) connection;\n  return 0;\n}\nvoid MHD_mutex_lock_chk_(int *m) { (void) m; }\nvoid MHD_mutex_unlock_chk_(int *m) { (void) m; }\nvoid MHD_PANIC(const char *msg)\n{\n  fprintf(stderr, \"PANIC: %s\\n\", msg);\n  abort();\n}\n\nvoid MHD_update_last_activity_(struct MHD_Connection *c)\n{\n  (void) c;\n}\nint try_ready_normal_body(struct MHD_Connection *connection)\n{\n  (void) connection;\n  return 1; /* MHD_YES */\n}\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    probe_log(connection, \"entered assert-case: headers/req initial states\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          1);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    probe_log(connection, \"entered assert-case: body/footers/full_req_received\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    probe_log(connection, \"entered assert-case: start_reply\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      0,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      0,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      if (((size_t) ret) > wb_ready)\n      {\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      /* simplified check_write_done: set state to HEADERS_SENT */\n      connection->state = MHD_CONNECTION_HEADERS_SENT;\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n\n      if (0 == try_ready_normal_body (connection))\n      {\n        return;\n      }\n\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               1);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (\"Data offset exceeds limit.\\n\");\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              1);\n      }\n\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    probe_log(connection, \"entered assert-case: normal_body_unready\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          1);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    /* simplified check_write_done: set a new state depending on amounts */\n    if ((connection->rp.response->total_size ==\n         connection->rp.rsp_write_position))\n      connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n    else\n      connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    probe_log(connection, \"entered assert-case: chunked body unready/sent\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          1);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    probe_log(connection, \"entered assert-case: full_reply_sent\");\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n  case MHD_CONNECTION_UPGRADE:\n    probe_log(connection, \"entered assert-case: upgrade\");\n    mhd_assert (0);\n    return;\n  default:\n    probe_log(connection, \"entered default assert-case: internal error\");\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            \"Internal error.\\n\");\n    break;\n  }\n  return;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s reasoning is only valid under a specific build-time assumption (that mhd_assert is defined globally as a no-op, e.g. #define mhd_assert(x) ((void)0)). If, in the actual project configuration, mhd_assert expands to a checking routine (one that aborts/logs on a failed condition), then the mhd_assert(0) calls are active checks and their removal would change behaviour, so they are not dead code. Rule 2.2 applies to the code as it exists in the project/build configuration: an executed statement that has no effect in that configuration is dead code and would violate the rule. Agent A did not demonstrate that in the real project build mhd_assert is a no-op; their test code used a different definition and failed to produce output. Therefore the blanket claim that the posted MHD_connection_handle_write violates MISRA C:2023 Rule 2.2 is not correct unless you can show the project actually defines mhd_assert as a no-op in the build being analysed. If you do have mhd_assert defined as ((void)0) in the project, then those reachable mhd_assert(0) calls are dead code and should be fixed (remove them or make the checks effective, or conditionally compile them so no no-op statements remain)."
}