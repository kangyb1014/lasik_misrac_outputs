{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n  FILE *fp = fopen(\"/tmp/logs/634.txt\", \"a\");\n\n  if (fp != NULL)\n  {\n    fprintf(fp, \"enter process_value_to_boundary: buffer_pos=%zu buffer_size=%zu value_offset=%llu must_ikvi=%d blen=%zu\\n\",\n            pp->buffer_pos, pp->buffer_size, (unsigned long long)pp->value_offset, (int)pp->must_ikvi, blen);\n  }\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n        break;\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      /* can check boundary */\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        /* no boundary, \"\\r\\n--\" is part of content, skip */\n        if (fp != NULL)\n        {\n          fprintf(fp, \"no boundary at pos %zu, skipping 4 -> new newline=%zu\\n\", newline, newline + 4);\n        }\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        /* boundary found, process until newline then\n           skip boundary and go back to init */\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;             /* skip boundary as well */\n        if (fp != NULL)\n        {\n          fprintf(fp, \"boundary found at %zu: setting skip_rn=%d state=%d dash_state=%d ioffptr=%zu\\n\",\n                  newline, (int)pp->skip_rn, (int)pp->state, (int)pp->dash_state, *ioffptr);\n        }\n        /* The following NUL write is used in the original code to terminate the\n           buffer at the newline position. The ikvi callback receives an\n           explicit length, so this write does not affect that call.\n           This operation is therefore the focus of the dead-code scenario. */\n        buf[newline] = '\\0';\n        if (fp != NULL)\n        {\n          fprintf(fp, \"performed buf[%zu] = '\\\\0' (value after write=%d)\\n\", newline, (int)buf[newline]);\n        }\n        break;\n      }\n    }\n    else\n    {\n      /* cannot check for boundary, process content that\n         we have and check again later; except, if we have\n         no content, abort (out of memory) */\n      if ( (0 == newline) &&\n           (pp->buffer_pos == pp->buffer_size) )\n      {\n        if (fp != NULL)\n        {\n          fprintf(fp, \"out of memory condition: setting PP_Error and returning MHD_NO\\n\");\n        }\n        pp->state = PP_Error;\n        if (fp != NULL)\n        {\n          fclose(fp);\n        }\n        return MHD_NO;\n      }\n      break;\n    }\n  }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (pp->must_ikvi) ||\n         (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    if (fp != NULL)\n    {\n      fprintf(fp, \"ikvi returned MHD_NO: setting PP_Error and returning MHD_NO\\n\");\n      fclose(fp);\n    }\n    pp->state = PP_Error;\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n\n  if (fp != NULL)\n  {\n    fprintf(fp, \"exit process_value_to_boundary: value_offset=%llu ioffptr=%zu must_ikvi=%d newline=%zu\\n\",\n            (unsigned long long)pp->value_offset, *ioffptr, (int)pp->must_ikvi, newline);\n    fclose(fp);\n  }\n  return MHD_YES;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp0roelj9k/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_value_to_boundary as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Minimal enums / constants to allow compilation while preserving logic */\nenum PP_State {\n  PP_Init = 0,\n  PP_Error = 1\n};\n\nenum RN_State {\n  RN_None = 0,\n  RN_Dash = 1\n};\n\nenum {\n  MHD_POSTDATA_KIND = 0,\n  MHD_YES = 1,\n  MHD_NO = 0\n};\n\n/* Minimal structure matching the fields accessed by the function */\nstruct MHD_PostProcessor {\n  size_t buffer_pos;\n  size_t buffer_size;\n  unsigned long long value_offset;\n  bool must_ikvi;\n  enum RN_State skip_rn;\n  enum PP_State state;\n  enum PP_State dash_state;\n  /* callback: cls, kind, content_name, content_filename, content_type,\n     content_transfer_encoding, buffer, value_offset, len */\n  int (*ikvi)(void *, int, const char *, const char *, const char *, const char *, char *, unsigned long long, size_t);\n  void *cls;\n  const char *content_name;\n  const char *content_filename;\n  const char *content_type;\n  const char *content_transfer_encoding;\n};\n\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n  FILE *fp = fopen(\"/tmp/logs/634.txt\", \"a\");\n\n  if (fp != NULL)\n  {\n    fprintf(fp, \"enter process_value_to_boundary: buffer_pos=%zu buffer_size=%zu value_offset=%llu must_ikvi=%d blen=%zu\\n\",\n            pp->buffer_pos, pp->buffer_size, (unsigned long long)pp->value_offset, (int)pp->must_ikvi, blen);\n  }\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n        break;\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      /* can check boundary */\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        /* no boundary, \"\\r\\n--\" is part of content, skip */\n        if (fp != NULL)\n        {\n          fprintf(fp, \"no boundary at pos %zu, skipping 4 -> new newline=%zu\\n\", newline, newline + 4);\n        }\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        /* boundary found, process until newline then\n           skip boundary and go back to init */\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;             /* skip boundary as well */\n        if (fp != NULL)\n        {\n          fprintf(fp, \"boundary found at %zu: setting skip_rn=%d state=%d dash_state=%d ioffptr=%zu\\n\",\n                  newline, (int)pp->skip_rn, (int)pp->state, (int)pp->dash_state, *ioffptr);\n        }\n        /* The following NUL write is used in the original code to terminate the\n           buffer at the newline position. The ikvi callback receives an\n           explicit length, so this write does not affect that call.\n           This operation is therefore the focus of the dead-code scenario. */\n        buf[newline] = '\\0';\n        if (fp != NULL)\n        {\n          fprintf(fp, \"performed buf[%zu] = '\\\\0' (value after write=%d)\\n\", newline, (int)buf[newline]);\n        }\n        break;\n      }\n    }\n    else\n    {\n      /* cannot check for boundary, process content that\n         we have and check again later; except, if we have\n         no content, abort (out of memory) */\n      if ( (0 == newline) &&\n           (pp->buffer_pos == pp->buffer_size) )\n      {\n        if (fp != NULL)\n        {\n          fprintf(fp, \"out of memory condition: setting PP_Error and returning MHD_NO\\n\");\n        }\n        pp->state = PP_Error;\n        if (fp != NULL)\n        {\n          fclose(fp);\n        }\n        return MHD_NO;\n      }\n      break;\n    }\n  }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (pp->must_ikvi) ||\n         (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    if (fp != NULL)\n    {\n      fprintf(fp, \"ikvi returned MHD_NO: setting PP_Error and returning MHD_NO\\n\");\n      fclose(fp);\n    }\n    pp->state = PP_Error;\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n\n  if (fp != NULL)\n  {\n    fprintf(fp, \"exit process_value_to_boundary: value_offset=%llu ioffptr=%zu must_ikvi=%d newline=%zu\\n\",\n            (unsigned long long)pp->value_offset, *ioffptr, (int)pp->must_ikvi, newline);\n    fclose(fp);\n  }\n  return MHD_YES;\n}\n",
  "explanation": "The original function referenced project types and constants that were not defined in the test environment. To make the file self-contained and compilable I added minimal definitions: enums for PP_State and RN_State, constants for MHD_POSTDATA_KIND, MHD_YES and MHD_NO, and a struct MHD_PostProcessor with the fields accessed by the function (including a compatible ikvi callback signature). I also included the necessary standard headers. The function body and logic were left unchanged."
}