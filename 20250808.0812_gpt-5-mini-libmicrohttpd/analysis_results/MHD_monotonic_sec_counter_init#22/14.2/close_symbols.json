{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_sec_counter_init': {'callees': [], 'callers': ['MHD_init']}, 'MHD_init': {'callees': ['MHD_set_panic_func', 'MHD_monotonic_sec_counter_init', 'MHD_send_init_static_vars_', 'MHD_init_mem_pools_'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop count and optionally loop flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with essentially Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GETTIME",
    "HAVE_CLOCK_GET_TIME",
    "HAVE_GETHRTIME",
    "_WIN32",
    "_WIN32_WINNT",
    "CLOCK_MONOTONIC_COARSE",
    "CLOCK_MONOTONIC_FAST",
    "CLOCK_MONOTONIC_RAW_APPROX",
    "CLOCK_MONOTONIC_RAW",
    "CLOCK_BOOTTIME",
    "CLOCK_MONOTONIC",
    "CLOCK_UPTIME",
    "CLOCK_HIGHRES",
    "clock_gettime",
    "host_get_clock_service",
    "clock_get_time",
    "mach_host_self",
    "mach_task_self",
    "mach_port_deallocate",
    "GetTickCount64",
    "QueryPerformanceFrequency",
    "QueryPerformanceCounter",
    "gethrtime",
    "timespec_get",
    "gettimeofday",
    "time",
    "mono_clock_id",
    "mono_clock_start",
    "mono_clock_service",
    "tick_start",
    "perf_freq",
    "perf_start",
    "hrtime_start",
    "gettime_start",
    "sys_clock_start",
    "_MHD_mono_clock_source",
    "_MHD_CLOCK_NO_SOURCE",
    "_MHD_UNWANTED_CLOCK",
    "_MHD_INVALID_CLOCK_SERV",
    "_MHD_CLOCK_GETTIME",
    "_MHD_CLOCK_GET_TIME",
    "_MHD_CLOCK_GETTICKCOUNT64",
    "_MHD_CLOCK_PERFCOUNTER",
    "_MHD_CLOCK_GETHRTIME",
    "KERN_SUCCESS",
    "SYSTEM_CLOCK",
    "TIME_UTC",
    "struct timespec",
    "struct timeval",
    "mach_timespec_t",
    "LARGE_INTEGER"
  ],
  "explanation": "To determine whether MHD_monotonic_sec_counter_init violates the MISRA C for-loop well-formedness rule we must be sure there are no for-loops introduced either directly in this function or indirectly via macros or called functions, and that no objects used as potential loop counters are modified in the function body or by any called macro/function used in loop clauses. For that we need the following symbols:\n\n- Preprocessor feature macros (HAVE_CLOCK_GETTIME, HAVE_CLOCK_GET_TIME, HAVE_GETHRTIME, _WIN32, _WIN32_WINNT): control which blocks of code are compiled in; needed to know exactly which code (and any hidden loops) is present.\n- Clock ID macros (CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_FAST, CLOCK_MONOTONIC_RAW_APPROX, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_MONOTONIC, CLOCK_UPTIME, CLOCK_HIGHRES): used in conditional calls (clock_gettime). If any are macros that expand to code containing loops, that matters.\n- Time/clock functions and related system calls (clock_gettime, host_get_clock_service, clock_get_time, mach_host_self, mach_task_self, mach_port_deallocate, GetTickCount64, QueryPerformanceFrequency, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time): these are invoked from the function. MISRA counts the behaviour of called functions as part of the loop body; if any of these are macros or inline functions that contain for-loops or modify objects used as loop counters, the rule could be affected.\n- Global variables modified/used here (mono_clock_id, mono_clock_start, mono_clock_service, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start): these are objects modified by the function. If any of them are used as loop counters elsewhere or could be part of loop-control expressions, they must be known and inspected.\n- Local enum/type/constants used for control or comparison (_MHD_mono_clock_source, _MHD_CLOCK_NO_SOURCE, _MHD_UNWANTED_CLOCK, _MHD_INVALID_CLOCK_SERV, _MHD_CLOCK_GETTIME, _MHD_CLOCK_GET_TIME, _MHD_CLOCK_GETTICKCOUNT64, _MHD_CLOCK_PERFCOUNTER, _MHD_CLOCK_GETHRTIME): needed to understand control flow choices and whether any of these are macros/functions that could hide loops or side effects.\n- Kernel/system constants (KERN_SUCCESS, SYSTEM_CLOCK, TIME_UTC): used in conditionals; if they are macros expanding to expressions with side-effects or loops (unusual but must be ruled out), they could affect compliance.\n- Relevant type definitions used in calls/assignments (struct timespec, struct timeval, mach_timespec_t, LARGE_INTEGER): if any are implemented as macros with side-effects or hide code with loops (again unusual), they must be checked.\n\nIn short: include all preprocessor selectors that change which code is compiled, all called functions/macros (and the system constants they use), and all global variables and enums modified or used in this function. With these symbols available the next analyzer can determine definitively that no for-loop appears in this function or is introduced indirectly by macros/called code, and that no loop counters are modified here."
}