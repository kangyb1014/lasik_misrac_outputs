{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a compiler-specific GCC/Clang attribute via the _MHD_EXTERN macro (defined as __attribute__((visibility(\"default\")))extern). The use of __attribute__((...)) is a compiler language extension and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_state(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/32.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\nstruct MHD_RqParam {\n    const char *str;\n    size_t len;\n};\nstruct MHD_RqDAuth {\n    struct MHD_RqParam opaque;\n    struct MHD_RqParam realm;\n    struct MHD_RqParam cnonce;\n    int algo3;\n    int qop;\n    unsigned nc;\n};\nconst struct MHD_RqDAuth *MHD_get_rq_dauth_params_(struct MHD_Connection *);\nsize_t get_rq_unames_size(const struct MHD_RqDAuth *, enum MHD_DigestAuthUsernameType);\nvoid mhd_assert(int cond)\n{\n    if (!cond) {\n        abort();\n    }\n}\n\nstruct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n  {\n    mhd_log_state(\"MHD_digest_auth_get_request_info3: no params (NULL), returning NULL\");\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n  mhd_log_state(\"uname_type=%d\", (int) uname_type);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n  mhd_log_state(\"after get_rq_unames_size: unif_buf_size=%zu\", unif_buf_size);\n\n  if (NULL != params->opaque.str)\n  {\n    unif_buf_size += params->opaque.len + 1;  /* Add one for zero-termination */\n    mhd_log_state(\"opaque present: len=%zu, unif_buf_size=%zu\", params->opaque.len, unif_buf_size);\n  }\n  if (NULL != params->realm.str)\n  {\n    unif_buf_size += params->realm.len + 1;   /* Add one for zero-termination */\n    mhd_log_state(\"realm present: len=%zu, unif_buf_size=%zu\", params->realm.len, unif_buf_size);\n  }\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  mhd_log_state(\"allocated info at %p (requested bytes=%zu)\", (void *) info,\n                (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n  mhd_log_state(\"algo3=%d\", (int) info->algo3);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    size_t used = get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n    unif_buf_used += used;\n    mhd_log_state(\"get_rq_uname branch: used=%zu, unif_buf_used=%zu\", used, unif_buf_used);\n  }\n  else\n  {\n    info->uname_type = uname_type;\n    mhd_log_state(\"uname missing or invalid: uname_type=%d\", (int) uname_type);\n  }\n\n  if (NULL != params->opaque.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n    mhd_log_state(\"opaque copied: opaque_len=%zu, unif_buf_used=%zu\", info->opaque_len, unif_buf_used);\n  }\n  if (NULL != params->realm.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n    mhd_log_state(\"realm copied: realm_len=%zu, unif_buf_used=%zu\", info->realm_len, unif_buf_used);\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  mhd_log_state(\"buffer usage check: unif_buf_size=%zu, unif_buf_used=%zu\", unif_buf_size, unif_buf_used);\n\n  info->qop = params->qop;\n  mhd_log_state(\"qop=%d\", (int) info->qop);\n\n  if (NULL != params->cnonce.str)\n  {\n    info->cnonce_len = params->cnonce.len;\n    mhd_log_state(\"cnonce present: cnonce_len=%zu\", info->cnonce_len);\n  }\n  else\n  {\n    info->cnonce_len = 0;\n    mhd_log_state(\"cnonce missing: cnonce_len=0\");\n  }\n\n  nc_res = get_rq_nc (params, &info->nc);\n  mhd_log_state(\"get_rq_nc result=%d, nc=%u\", (int) nc_res, (unsigned) info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = (unsigned) -1; /* MHD_DIGEST_AUTH_INVALID_NC_VALUE substitute */\n\n  mhd_log_state(\"returning info at %p (nc=%u)\", (void *) info, (unsigned) info->nc);\n  return info;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct provided the macro expands as claimed. The GCC/Clang attribute syntax __attribute__((...)) is a compiler language extension (documented as such by those compilers). If _MHD_EXTERN expands to __attribute__((visibility(\"default\"))) extern, that is a use of a compiler-specific language extension and therefore breaches MISRA C 2023 Rule 1.2 (Language extensions should not be used). Note: the snippet shown does not include the macro definition, so you must confirm _MHD_EXTERN is indeed defined that way in the project. The test code failing to compile is likely due to the missing macro/headers in the isolated test harness and does not affect the rule assessment."
}