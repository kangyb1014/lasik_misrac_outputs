{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_get_request_info3': {'callees': ['MHD_get_rq_dauth_params_', 'get_rq_uname_type', 'get_rq_unames_size', 'get_rq_uname', 'get_rq_param_unquoted_copy_z', 'get_rq_nc'], 'callers': []}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}, 'get_rq_uname_type': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_unames_size': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_param_unquoted_copy_z': {'callees': ['MHD_str_unquote'], 'callers': ['get_rq_uname', 'MHD_digest_auth_get_request_info3']}, 'get_rq_nc': {'callees': ['MHD_str_unquote', 'MHD_strx_to_uint64_n_'], 'callers': ['MHD_digest_auth_get_request_info3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "struct MHD_DigestAuthInfo",
    "struct MHD_DigestAuthUsernameInfo",
    "enum MHD_DigestAuthUsernameType",
    "struct MHD_RqDAuth",
    "type(s) of MHD_RqDAuth members (opaque, realm, cnonce -- e.g. MHD_RqParam or similar)",
    "MHD_calloc_",
    "mhd_assert",
    "MHD_DIGEST_AUTH_UNAME_TYPE_MISSING",
    "MHD_DIGEST_AUTH_UNAME_TYPE_INVALID",
    "MHD_DIGEST_AUTH_INVALID_NC_VALUE",
    "MHD_GET_RQ_NC_VALID",
    "enum MHD_GetRqNCResult",
    "MHD_get_rq_dauth_params_",
    "get_rq_uname_type",
    "get_rq_unames_size",
    "get_rq_uname",
    "get_rq_param_unquoted_copy_z",
    "get_rq_nc"
  ],
  "explanation": "For checking for language/compiler extensions you must inspect any macros, typedefs, struct/enum definitions and called functions that could hide use of compiler-specific extensions (attributes, __declspec, anonymous/unnamed unions, flexible-array or GCC extensions, statement expressions, typeof, inline asm, etc.). Reason for each symbol: \n\n_MHD_EXTERN: macro used on the function declaration/definition \u2014 may expand to compiler-specific storage-class/visibility attributes (e.g. __attribute__, __declspec) or other extensions. Must inspect its definition.\n\nstruct MHD_DigestAuthInfo: full definition may contain flexible-array members, anonymous unions/structs, GCC/MSVC attributes or nonstandard alignment/packing pragmas \u2014 all are language/compiler extensions.\n\nstruct MHD_DigestAuthUsernameInfo: referenced by cast; its layout could use anonymous structs/unions or other extensions that affect pointer casting semantics.\n\nenum MHD_DigestAuthUsernameType: the enum definition could include nonstandard underlying type, attributes, or other compiler-specific annotations.\n\nstruct MHD_RqDAuth: this parameter type (and its fields) is read heavily; its member types might be macros/structs that use extensions (anonymous members, bit-fields with implementation-defined widths, attributes).\n\ntype(s) of MHD_RqDAuth members (opaque, realm, cnonce \u2014 e.g. MHD_RqParam): the .value.str and .value.len members are used; the type(s) might be macro-defined or use extensions (anonymous unions, flexible arrays, bitfields, attributes). Inspecting them is necessary to detect extensions hidden inside member types.\n\nMHD_calloc_: allocation routine used here \u2014 may be a macro wrapping calloc with attributes (e.g. malloc attribute) or a compiler-specific builtin; inspect to see if it uses extensions.\n\nmhd_assert: likely a macro \u2014 could use compiler builtins or statement-expression ({ ... }) or attributes; must check its definition for extensions.\n\nMHD_DIGEST_AUTH_UNAME_TYPE_MISSING / MHD_DIGEST_AUTH_UNAME_TYPE_INVALID: macros/constants \u2014 could be defined using compiler-specific constructs (e.g. enum aliasing or extension macros). Check definitions for nonstandard constructs.\n\nMHD_DIGEST_AUTH_INVALID_NC_VALUE / MHD_GET_RQ_NC_VALID: macros/constants used in control flow; their definitions might use compiler extensions or nonstandard integer types.\n\nenum MHD_GetRqNCResult: the enum return of get_rq_nc may be annotated or defined with nonstandard underlying type or attributes; inspect for extensions.\n\nMHD_get_rq_dauth_params_, get_rq_uname_type, get_rq_unames_size, get_rq_uname, get_rq_param_unquoted_copy_z, get_rq_nc: definitions/prototypes of all called functions \u2014 they may be implemented as macros, inline functions, or use compiler extensions (inline semantics, __attribute__, statement-expressions, typeof, nonstandard parameter/return types). You must inspect their declarations/definitions to ensure no compiler-specific language extensions are used.\n\nNote: Standard types used in the function (size_t, uint8_t) are from standard headers and generally acceptable; they need not be re-listed unless their typedefs in this codebase are nonstandard. The above symbols are the minimal set that can hide language extensions affecting the target function's compliance with the MISRA rule."
}