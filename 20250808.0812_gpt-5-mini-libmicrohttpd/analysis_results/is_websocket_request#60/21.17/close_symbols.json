{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ahc_cb",
    "MHD_lookup_connection_value",
    "MHD_lookup_connection_value_n",
    "struct MHD_Connection",
    "WS_UPGRADE_VALUE",
    "strcmp (from <string.h>)",
    "strstr (from <string.h>)",
    "HTTP header parsing / storage code that populates MHD_Connection header values"
  ],
  "explanation": "To determine whether strcmp and strstr in is_websocket_request can read beyond object bounds you must know the provenance, representation and termination guarantees of the two pointer parameters (upg_header and con_header).\n\n- ahc_cb: The caller that passes upg_header and con_header. Its code shows exactly how those pointers are obtained and whether they can be non-NULL without being NUL-terminated or can point into short/lifetime-limited buffers.\n\n- MHD_lookup_connection_value: One of the likely suppliers of header string pointers. Its prototype/implementation/spec is required to know whether it returns a NUL-terminated string, a pointer into an internal buffer, an allocated buffer, or a truncated/non-terminated region.\n\n- MHD_lookup_connection_value_n: Same reason as above (ahc_cb may call this variant). Need its behavior guarantees about termination and bounds.\n\n- struct MHD_Connection: The internal layout and storage for header values (if lookup returns pointers into the connection) determine whether those buffers are NUL-terminated, their sizes, and lifetime \u2014 all relevant to avoiding out-of-bounds reads by strcmp/strstr.\n\n- WS_UPGRADE_VALUE: The constant string compared by strcmp. Its definition (NUL-terminated string literal or other form) is needed to ensure strcmp is used with a properly terminated RHS and to reason about length when comparing.\n\n- strcmp (from <string.h>): Include the standard specification/prototype (or confirmation thereof) so the analyzer knows strcmp requires both arguments to be pointers to NUL-terminated arrays and that it will read until NUL (risk of out-of-bounds if NUL absent).\n\n- strstr (from <string.h>): Include the standard specification/prototype which states it scans the haystack until a NUL byte; this is necessary to reason about potential unbounded reads of con_header if it is not NUL-terminated.\n\n- HTTP header parsing / storage code that populates MHD_Connection header values: If the header strings originate from an HTTP parser (tokenization, concatenation, or truncation routines), that code can impose size limits, add terminating NUL, or produce non-terminated buffers. Its behavior is essential to conclude whether strcmp/strstr can legally read each string to the terminating NUL without overrunning the underlying storage.\n\nIn short: to check MISRA's prohibition on out-of-bounds string function accesses you must inspect the call site (ahc_cb), the providers of the header pointers (MHD_lookup_connection_value / _n and the HTTP parser), the connection storage (struct MHD_Connection), and the definitions/specs of WS_UPGRADE_VALUE and the used string.h functions (strcmp, strstr) so you can prove both operands are valid, in-bounds, and NUL-terminated before being scanned."
}