{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pre_send_setopt",
    "post_send_setopt",
    "gnutls_record_send",
    "MHD_send4_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EBADF_",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_TLS_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_BADF_",
    "SSIZE_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MHD_socket",
    "struct MHD_Connection::socket_fd",
    "struct MHD_Connection::state",
    "struct MHD_Connection::daemon",
    "struct MHD_Connection::tls_session",
    "struct MHD_Connection::epoll_state",
    "struct MHD_Daemon::options",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT",
    "EPOLL_SUPPORT",
    "MHD_USE_MSG_MORE",
    "MSG_MORE",
    "GNUTLS_E_AGAIN",
    "GNUTLS_E_INTERRUPTED",
    "GNUTLS_E_ENCRYPTION_FAILED",
    "GNUTLS_E_INVALID_SESSION",
    "GNUTLS_E_COMPRESSION_FAILED",
    "GNUTLS_E_EXPIRED",
    "GNUTLS_E_HASH_FAILED",
    "GNUTLS_E_PUSH_ERROR",
    "GNUTLS_E_INTERNAL_ERROR",
    "GNUTLS_E_CRYPTODEV_IOCTL_ERROR",
    "GNUTLS_E_CRYPTODEV_DEVICE_ERROR",
    "GNUTLS_E_PREMATURE_TERMINATION",
    "GNUTLS_E_UNEXPECTED_PACKET_LENGTH",
    "GNUTLS_E_MEMORY_ERROR",
    "enum MHD_EpollState",
    "MHD_EPOLL_STATE_WRITE_READY"
  ],
  "explanation": "For MISRA dead-code analysis we must know which operations are potentially unconditional, which branches can be compiled out, and which calls have side effects. Brief reasons for each symbol:\n\n- pre_send_setopt: may have side effects that make its call non-dead; needed to decide if its invocation can be removed.\n- post_send_setopt: same as above; its side effects determine whether the conditional call is meaningful.\n- gnutls_record_send: return values control many TLS branches; needed to determine reachability of TLS error-handling code.\n- MHD_send4_: plain-socket send implementation whose return semantics determine non-TLS error branches.\n- MHD_socket_get_error_: obtains errno-equivalent used to select error-handling branches after send; required to know which error branches can occur.\n- MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_, MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_ERR_IS_LOW_RESOURCES_, MHD_SCKT_EBADF_: all socket-error predicates/constants used to decide which error-handling blocks execute; needed to know if any such blocks are unreachable (dead).\n- MHD_INVALID_SOCKET, MHD_CONNECTION_CLOSED: constants used in the initial early-return check; required to see if that early-return is ever taken.\n- MHD_ERR_NOTCONN_, MHD_ERR_AGAIN_, MHD_ERR_TLS_, MHD_ERR_PIPE_, MHD_ERR_CONNRESET_, MHD_ERR_NOMEM_, MHD_ERR_OPNOTSUPP_, MHD_ERR_INVAL_, MHD_ERR_BADF_: return-code macros used throughout; knowing their identities is needed to determine whether returning early changes observable behaviour.\n- SSIZE_MAX: used to clamp buffer_size and alter push_data \u2014 affects whether following code executes or is meaningful.\n- MHD_SCKT_SEND_MAX_SIZE_: used to clamp send length in plaintext path; affects later conditions and possible epoll handling.\n- MHD_socket: underlying socket type \u2014 knowing its invalid value semantics may affect the first-if check.\n- struct MHD_Connection::socket_fd, ::state, ::daemon, ::tls_session, ::epoll_state: fields of connection read/modified by this function; required to reason about which reads/writes are observable side effects and whether removals would change behaviour.\n- struct MHD_Daemon::options and MHD_USE_TLS: daemon options and TLS flag determine tls_conn at runtime; required to know whether TLS path is possible or compile-time forced.\n- HTTPS_SUPPORT: compile-time macro gating TLS code \u2014 if undefined, all TLS blocks are not present (dead at compile time); must be known to classify dead vs. unreachable code.\n- EPOLL_SUPPORT: compile-time macro gating epoll-state modifications \u2014 affects presence/removal of bitwise epoll-state ops.\n- MHD_USE_MSG_MORE and MSG_MORE: affect whether MSG_MORE is passed to MHD_send4_; needed because it changes send behavior and push_data handling.\n- GNUTLS_E_* symbols (AGAIN, INTERRUPTED, ENCRYPTION_FAILED, INVALID_SESSION, COMPRESSION_FAILED, EXPIRED, HASH_FAILED, PUSH_ERROR, INTERNAL_ERROR, CRYPTODEV_IOCTL_ERROR, CRYPTODEV_DEVICE_ERROR, PREMATURE_TERMINATION, UNEXPECTED_PACKET_LENGTH, MEMORY_ERROR): gnutls_record_send error codes mapped to specific return-handling branches; required to determine which TLS branches are reachable and meaningful.\n- enum MHD_EpollState and MHD_EPOLL_STATE_WRITE_READY: used when clearing write-ready flag on epoll_state; needed to decide whether the epoll_state modifications are observable side effects (hence not dead).\n\nIn short: these symbols determine compile-time presence of branches, runtime branch conditions, side effects (state mutations and external calls) and therefore are necessary to decide whether any executed operation in MHD_send_data_ could be removed without changing program behaviour (i.e., whether it is dead code)."
}