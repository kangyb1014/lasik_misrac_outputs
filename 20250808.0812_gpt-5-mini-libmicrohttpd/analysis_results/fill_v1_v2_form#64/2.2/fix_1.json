{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void\nprobe_log(const char *label,\n          const void *cls,\n          const char *mime,\n          const struct Session *session,\n          const struct MHD_Connection *connection)\n{\n  FILE *f = fopen(\"/tmp/logs/514.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* keep behavior safe if logging not available */\n  }\n\n  fprintf(f, \"--- %s ---\\n\", label);\n  fprintf(f, \"cls=%p mime=%p connection=%p session=%p\\n\",\n          cls, (const void *) mime, (const void *) connection,\n          (const void *) session);\n  if (session != NULL)\n  {\n    const char *v1 = session->value_1;\n    const char *v2 = session->value_2;\n    fprintf(f, \"value_1=%p value_2=%p\\n\", (const void *) v1, (const void *) v2);\n    if ((v1 != NULL) && (v2 != NULL))\n    {\n      /* print contents guarded by NULL checks */\n      fprintf(f, \"value_1=\\\"%s\\\" value_2=\\\"%s\\\"\\n\", v1, v2);\n    }\n  }\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n\n  /* Log entry and state before the no-op cast */\n  probe_log(\"enter_fill_v1_v2_form_before_cast\", cls, mime, session, connection);\n\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Log that the cast-to-void was executed (the statement believed to be dead code) */\n  probe_log(\"after_void_cast\", cls, mime, session, connection);\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* Log exit and returned result */\n  probe_log(\"exit_fill_v1_v2_form\", cls, mime, session, connection);\n\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp6p_6c2xj/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of fill_v1_v2_form as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Minimal declarations so this translation unit compiles without\n   requiring the entire libmicrohttpd or other project sources.  These are\n   declarations only (no mock implementations) so the original logic of\n   fill_v1_v2_form is preserved. */\n\nstruct MHD_Connection;\nstruct MHD_Response;\n\nstruct Session {\n  const char *value_1;\n  const char *value_2;\n};\n\n/* Result enumeration used by the functions in the original code. */\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n/* Common HTTP OK status used by the original code. */\nconst int MHD_HTTP_OK = 200;\n\n/* Header name used by the original code (was originally a macro). */\nconst char *MHD_HTTP_HEADER_CONTENT_ENCODING = \"Content-Encoding\";\n\n/* Prototypes for functions that exist elsewhere in the project; we only\n   declare them so this file compiles. Definitions are intentionally not\n   provided here (no mock functions). */\nextern struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback(size_t size,\n                                                   void *buffer,\n                                                   void (*free_callback)(void *));\n\nextern enum MHD_Result\nMHD_add_response_header(struct MHD_Response *response,\n                        const char *header,\n                        const char *value);\n\nextern enum MHD_Result\nMHD_queue_response(struct MHD_Connection *connection,\n                   int status_code,\n                   struct MHD_Response *response);\n\nextern void\nMHD_destroy_response(struct MHD_Response *response);\n\nextern void\nadd_session_cookie(struct Session *session, struct MHD_Response *response);\n\n/* The HTML/template string used by the original code. Declared extern to\n   avoid providing a concrete value here. */\nextern const char *SECOND_PAGE;\n\nstatic void\nprobe_log(const char *label,\n          const void *cls,\n          const char *mime,\n          const struct Session *session,\n          const struct MHD_Connection *connection)\n{\n  FILE *f = fopen(\"/tmp/logs/514.txt\", \"a\");\n  if (NULL == f)\n  {\n    return; /* keep behavior safe if logging not available */\n  }\n\n  fprintf(f, \"--- %s ---\\n\", label);\n  fprintf(f, \"cls=%p mime=%p connection=%p session=%p\\n\",\n          cls, (const void *) mime, (const void *) connection,\n          (const void *) session);\n  if (session != NULL)\n  {\n    const char *v1 = session->value_1;\n    const char *v2 = session->value_2;\n    fprintf(f, \"value_1=%p value_2=%p\\n\", (const void *) v1, (const void *) v2);\n    if ((v1 != NULL) && (v2 != NULL))\n    {\n      /* print contents guarded by NULL checks */\n      fprintf(f, \"value_1=\\\"%s\\\" value_2=\\\"%s\\\"\\n\", v1, v2);\n    }\n  }\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n\n  /* Log entry and state before the no-op cast */\n  probe_log(\"enter_fill_v1_v2_form_before_cast\", cls, mime, session, connection);\n\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Log that the cast-to-void was executed (the statement believed to be dead code) */\n  probe_log(\"after_void_cast\", cls, mime, session, connection);\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* Log exit and returned result */\n  probe_log(\"exit_fill_v1_v2_form\", cls, mime, session, connection);\n\n  return ret;\n}\n",
  "explanation": "I made this translation unit self-contained for compilation by adding the necessary #includes and minimal type/function declarations that the original code relies on (opaque structs for MHD types, the Session struct, enum MHD_Result, constants, and external prototypes). I did not provide implementations (no mock functions) \u2014 only declarations \u2014 so the original logic of probe_log and fill_v1_v2_form is preserved. Also replaced the originally-macro header name with a const char* definition to avoid using undefined macros. No main() was added and no macros were defined."
}