{
  "user_message": "Target function code is:\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_create': {'callees': [], 'callers': ['new_connection_process_']}, 'new_connection_process_': {'callees': ['MHD_pool_create', 'MHD_DLOG', '__builtin_unreachable', 'MHD_connection_set_initial_state_', 'MHD_create_named_thread_', 'MHD_pool_destroy', 'MHD_ip_limit_del'], 'callers': ['internal_add_connection', 'new_connections_list_process_']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_sys_page_size_",
    "MAP_ANONYMOUS",
    "_WIN32",
    "mmap",
    "VirtualAlloc",
    "MAP_FAILED",
    "PROT_READ",
    "PROT_WRITE",
    "MAP_PRIVATE",
    "MEM_COMMIT",
    "MEM_RESERVE",
    "PAGE_READWRITE",
    "malloc",
    "free",
    "ROUND_TO_ALIGN",
    "ALIGN_SIZE",
    "_MHD_POISON_MEMORY",
    "struct MemoryPool",
    "uintptr_t",
    "size_t",
    "bool"
  ],
  "explanation": "You must inspect each of these symbols to determine whether the target function relies on compiler/implementation language extensions (MISRA violation). Short justification per symbol: \n\n- mhd_assert: a macro \u2014 may expand to compiler builtins (e.g. __builtin_expect, __builtin_unreachable) or other extension usage; inspect its definition.\n- MHD_sys_page_size_: global/constant \u2014 may be defined via platform-specific or compiler-specific mechanism (e.g. attribute or asm) that could be an extension.\n- MAP_ANONYMOUS: a platform macro \u2014 check how it is defined; its presence selects code paths that use mmap which may rely on non\u2011standard headers or compiler extensions.\n- _WIN32: predefined macro controlling conditional compilation; need to see whether other extension-only code is enabled under this macro.\n- mmap: POSIX API \u2014 not a language extension itself, but its use may be behind macros or wrappers that use extensions; inspect declaration/headers for attributes or inline asm.\n- VirtualAlloc: WinAPI function \u2014 inspect its declaration/headers for any compiler-specific attributes or non\u2011standard language constructs.\n- MAP_FAILED: sentinel macro \u2014 may be defined in an implementation-specific way (e.g. ((void *) -1)); verify it is not implemented using compiler-specific extension.\n- PROT_READ / PROT_WRITE / MAP_PRIVATE: platform macros \u2014 check definitions and included headers for extension usage.\n- MEM_COMMIT / MEM_RESERVE / PAGE_READWRITE: Windows constants/macros \u2014 inspect headers for extension use.\n- malloc / free: standard C library calls \u2014 inspect any project wrappers/macros that might redefine them to extension constructs.\n- ROUND_TO_ALIGN: macro/function used to compute alloc_size \u2014 may be implemented with compiler extensions (e.g. GCC builtins, asm, alignof/attribute hacks); check definition.\n- ALIGN_SIZE: macro/constant used in alignment check \u2014 may be defined using compiler-specific extensions (alignment attributes, builtin macros); inspect definition.\n- _MHD_POISON_MEMORY: macro/function used to poison memory \u2014 often implemented with memset or compiler fences or builtins; check for extension usage (inline asm, builtin).\n- struct MemoryPool: type definition and its fields (memory, is_mmap, pos, end, size) \u2014 need the definition to verify use of non\u2011standard types, bitfields, packed/aligned attributes or compiler extensions in its declaration.\n- uintptr_t: type from stdint.h \u2014 normally standard, but verify whether the project provides a custom typedef or uses compiler extensions to obtain it.\n- size_t: standard type \u2014 verify includes/typedefs to ensure no extension hides it.\n- bool: C99 _Bool / stdbool.h \u2014 verify whether a project-defined boolean or compiler extension (C++ bool or custom) is used.\n\nInspecting the definitions/headers for these symbols lets the next agent detect any use of explicit compiler builtins, attributes, inline asm, nonstandard keywords or other constructs that would constitute a MISRA 'language extensions' violation."
}