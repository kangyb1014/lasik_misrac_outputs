{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nextern void _MHD_POISON_MEMORY (void *pointer, size_t size);\nextern void mhd_assert (int);\nextern size_t ROUND_TO_ALIGN (size_t n);\nstatic void mhd_logf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/625.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  mhd_logf(\"MHD_pool_create: entered, max=%zu\", max);\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_logf(\"allocated pool=%p (malloc returned)\", (void *)pool);\n  if (NULL == pool)\n  {\n    mhd_logf(\"pool allocation failed, returning NULL\");\n    return NULL;\n  }\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  mhd_logf(\"COMPILE-TIME: MAP_ANONYMOUS=%d _WIN32=%d\",\n#if defined(MAP_ANONYMOUS)\n           1,\n#else\n           0,\n#endif\n#if defined(_WIN32)\n           1\n#else\n           0\n#endif\n           );\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_logf(\"Decision: small allocation -> set pool->memory = MAP_FAILED\");\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_logf(\"Attempting system mapping, alloc_size=%zu, page_size=%zu\", alloc_size, MHD_sys_page_size_);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_logf(\"mmap() returned %p\", pool->memory);\n#elif defined(_WIN32)\n    /* VirtualAlloc returns NULL on failure (Windows), not MAP_FAILED like mmap. */\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_logf(\"VirtualAlloc() returned %p (NOTE: VirtualAlloc returns NULL on failure, not MAP_FAILED)\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_logf(\"COMPILE-TIME: no mapping support; set pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  /* Detect mapping failure by comparing to MAP_FAILED (POSIX). On Windows, VirtualAlloc returns NULL on failure,\n     so this comparison will be false even when allocation failed. This makes the MAP_FAILED-handling branch\n     effectively unreachable in the Windows build when VirtualAlloc is used. */\n  if (MAP_FAILED == pool->memory)\n  {\n    mhd_logf(\"Detected MAP_FAILED, falling back to malloc with ROUND_TO_ALIGN(max)\");\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    mhd_logf(\"Fallback malloc returned %p, alloc_size=%zu\", pool->memory, alloc_size);\n    if (NULL == pool->memory)\n    {\n      mhd_logf(\"Fallback malloc failed, freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_logf(\"Using fallback malloc (is_mmap=false)\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_logf(\"Mapping succeeded (or treated as succeeded): is_mmap=true, pool->memory=%p\", pool->memory);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n\n  mhd_logf(\"Asserting alignment of pool->memory: %p modulo ALIGN_SIZE\", pool->memory);\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_logf(\"pool state at exit: pos=%zu end=%zu size=%zu is_mmap=%d\", pool->pos, pool->end, pool->size, pool->is_mmap ? 1 : 0);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_logf(\"Returning pool=%p\", (void *)pool);\n  return pool;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmemorypool.c:113:44: error: expected identifier or '(' before 'void'\n  113 | #define _MHD_POISON_MEMORY(pointer, size) (void)0\n      |                                            ^~~~\nmemorypool.c:279:13: note: in expansion of macro '_MHD_POISON_MEMORY'\n  279 | extern void _MHD_POISON_MEMORY (void *pointer, size_t size);\n      |             ^~~~~~~~~~~~~~~~~~\nIn file included from memorypool.c:43:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\nmemorypool.c:280:13: note: in expansion of macro 'mhd_assert'\n  280 | extern void mhd_assert (int);\n      |             ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\nmemorypool.c:280:13: note: in expansion of macro 'mhd_assert'\n  280 | extern void mhd_assert (int);\n      |             ^~~~~~~~~~\nmemorypool.c:281:38: error: expected ')' before 'n'\n  281 | extern size_t ROUND_TO_ALIGN (size_t n);\n      |                                      ^\nmemorypool.c:105:30: note: in definition of macro 'ROUND_TO_ALIGN'\n  105 | #define ROUND_TO_ALIGN(n) (((n) + (ALIGN_SIZE - 1)) \\\n      |                              ^\nmemorypool.c:105:33: error: expected ')' before '+' token\n  105 | #define ROUND_TO_ALIGN(n) (((n) + (ALIGN_SIZE - 1)) \\\n      |                                 ^\nmemorypool.c:281:15: note: in expansion of macro 'ROUND_TO_ALIGN'\n  281 | extern size_t ROUND_TO_ALIGN (size_t n);\n      |               ^~~~~~~~~~~~~~\nmemorypool.c:106:28: error: expected ')' before '/' token\n  106 |                            / (ALIGN_SIZE) *(ALIGN_SIZE))\n      |                            ^\nmemorypool.c:281:15: note: in expansion of macro 'ROUND_TO_ALIGN'\n  281 | extern size_t ROUND_TO_ALIGN (size_t n);\n      |               ^~~~~~~~~~~~~~\nmake[3]: *** [Makefile:2126: libmicrohttpd_la-memorypool.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_pool_create as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void mhd_logf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/625.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  mhd_logf(\"MHD_pool_create: entered, max=%zu\", max);\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_logf(\"allocated pool=%p (malloc returned)\", (void *)pool);\n  if (NULL == pool)\n  {\n    mhd_logf(\"pool allocation failed, returning NULL\");\n    return NULL;\n  }\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  mhd_logf(\"COMPILE-TIME: MAP_ANONYMOUS=%d _WIN32=%d\",\n#if defined(MAP_ANONYMOUS)\n           1,\n#else\n           0,\n#endif\n#if defined(_WIN32)\n           1\n#else\n           0\n#endif\n           );\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_logf(\"Decision: small allocation -> set pool->memory = MAP_FAILED\");\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_logf(\"Attempting system mapping, alloc_size=%zu, page_size=%zu\", alloc_size, MHD_sys_page_size_);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_logf(\"mmap() returned %p\", pool->memory);\n#elif defined(_WIN32)\n    /* VirtualAlloc returns NULL on failure (Windows), not MAP_FAILED like mmap. */\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_logf(\"VirtualAlloc() returned %p (NOTE: VirtualAlloc returns NULL on failure, not MAP_FAILED)\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_logf(\"COMPILE-TIME: no mapping support; set pool->memory = MAP_FAILED\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  /* Detect mapping failure by comparing to MAP_FAILED (POSIX). On Windows, VirtualAlloc returns NULL on failure,\n     so this comparison will be false even when allocation failed. This makes the MAP_FAILED-handling branch\n     effectively unreachable in the Windows build when VirtualAlloc is used. */\n  if (MAP_FAILED == pool->memory)\n  {\n    mhd_logf(\"Detected MAP_FAILED, falling back to malloc with ROUND_TO_ALIGN(max)\");\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    mhd_logf(\"Fallback malloc returned %p, alloc_size=%zu\", pool->memory, alloc_size);\n    if (NULL == pool->memory)\n    {\n      mhd_logf(\"Fallback malloc failed, freeing pool and returning NULL\");\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_logf(\"Using fallback malloc (is_mmap=false)\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_logf(\"Mapping succeeded (or treated as succeeded): is_mmap=true, pool->memory=%p\", pool->memory);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n\n  mhd_logf(\"Asserting alignment of pool->memory: %p modulo ALIGN_SIZE\", pool->memory);\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_logf(\"pool state at exit: pos=%zu end=%zu size=%zu is_mmap=%d\", pool->pos, pool->end, pool->size, pool->is_mmap ? 1 : 0);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_logf(\"Returning pool=%p\", (void *)pool);\n  return pool;\n}\n",
  "explanation": "The compile errors were caused by redeclaring identifiers that are already defined as macros (for example _MHD_POISON_MEMORY, mhd_assert, ROUND_TO_ALIGN). Those extern declarations expanded into invalid code due to macro substitution. I removed the three conflicting extern declarations at the top of the snippet so the existing macro definitions (from included headers) are used as intended. No other logic was changed; all original behavior in MHD_pool_create is preserved."
}