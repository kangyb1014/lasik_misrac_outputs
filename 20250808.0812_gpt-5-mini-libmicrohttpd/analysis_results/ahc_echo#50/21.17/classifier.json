{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified ahc_echo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/407.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_echo:\n#define MHD_HTTP_METHOD_GET \"GET\"\n...\n#define MHD_HTTP_METHOD_HEAD \"HEAD\"\n</additional code>\nJudge whether the above ahc_echo code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "A caller provides a url pointer that is not a valid NUL-terminated C string (for example a buffer that does not contain a terminating '\\0' within its allocated bounds). The call to strstr(url, \"../\") scans the url buffer until a NUL byte is found; if the url buffer is not NUL-terminated within its bounds this will read beyond the end of the object referenced by 'url' and thus violate MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n\n/* Forward declarations to match original environment; these are not\n   mock implementations, only types used by ahc_echo's signature. */\nstruct MHD_Connection;\nstruct MHD_Response;\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0 };\n\n/* Probes: write control path and state information to /tmp/logs/407.txt */\nstatic void probe_log(const char *tag, const char *url, const char *method,\n                      const void *req_cls, size_t url_len, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/407.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  /* Print pointer values and a few inspected bytes safely. */\n  (void) fprintf(f, \"[%s] tag=%s method_ptr=%p url_ptr=%p url_len=%zu req_cls=%p extra=%s\\n\",\n                 tag, tag, (const void *) method, (const void *) url, url_len, req_cls,\n                 (NULL != extra) ? extra : \"\");\n  if (NULL != url)\n  {\n    /* Print up to first 8 characters safely without reading beyond the single object\n       by checking characters individually (we still assume url is accessible). */\n    size_t i;\n    (void) fprintf(f, \"[%s] url_bytes=\\\"\", tag);\n    for (i = 0U; i < 8U; ++i)\n    {\n      char c = url[i];\n      if (c == '\\0')\n      {\n        break;\n      }\n      /* print printable characters; non-printable as hex */\n      if ((c >= 0x20) && (c < 0x7F))\n      {\n        (void) fputc((int) c, f);\n      }\n      else\n      {\n        (void) fprintf(f, \"\\\\x%02X\", (unsigned char) c);\n      }\n    }\n    (void) fprintf(f, \"\\\"\\n\");\n  }\n  (void) fclose(f);\n}\n\nstatic size_t safe_strlen(const char *s)\n{\n  if (NULL == s)\n  {\n    return 0U;\n  }\n  return strlen(s);\n}\n\n/* The original ahc_echo with added probes to log control path and state. */\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and basic inspected state. */\n  probe_log(\"enter\", url, method, (NULL == req_cls) ? NULL : *req_cls,\n            safe_strlen(url), \"start\");\n\n  if ( (0 != strcmp (method, \"GET\")) &&\n       (0 != strcmp (method, \"HEAD\")) )\n    return MHD_NO;              /* unexpected method */\n\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    probe_log(\"first_call\", url, method, *req_cls, safe_strlen(url), \"registered req_cls\");\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  probe_log(\"before_strstr\", url, method, *req_cls, safe_strlen(url), \"about to call strstr\");\n\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    probe_log(\"strstr_found\", url, method, *req_cls, safe_strlen(url), \"parent traversal detected\");\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  }\n  else\n  {\n    /* Log computed filename pointer (url+1). This is the location that may\n       point past the end of the url object if url is not a proper C string\n       or does not contain a leading '/'. */\n    probe_log(\"before_open\", url, method, *req_cls, safe_strlen(url), \"opening url+1\");\n    fd = open (url + 1, O_RDONLY);\n  }\n\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (\"PAGE\"),\n                                                       \"PAGE\");\n    ret = MHD_queue_response (connection, /* MHD_HTTP_NOT_FOUND */ 404, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, /* MHD_HTTP_OK */ 200, response);\n    MHD_destroy_response (response);\n  }\n\n  probe_log(\"exit\", url, method, *req_cls, safe_strlen(url), \"returning\");\n  return ret;\n}\n"
}