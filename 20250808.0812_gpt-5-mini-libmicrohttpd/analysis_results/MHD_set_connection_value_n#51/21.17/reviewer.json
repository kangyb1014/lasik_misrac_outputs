{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling strlen on 'key' or 'value' can read past the provided object bounds if those buffers are not null-terminated within key_size/value_size. Example: passing a char buffer of length key_size that contains no terminating '\\0' will cause strlen(key) to read beyond the buffer \u2014 a violation of MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nenum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  FILE *fp = fopen(\"/tmp/logs/415.txt\", \"a\");\n  if (fp != NULL)\n  {\n    fprintf(fp, \"ENTER: MHD_set_connection_value_n connection=%p kind=%d key=%p key_size=%zu value=%p value_size=%zu\\n\",\n            (void *)connection, (int)kind, (const void *)key, key_size, (const void *)value, value_size);\n  }\n\n  /* Preserve original short-circuit semantics: only call strlen for value\n     if key check passed (to avoid introducing additional reads). */\n  if (MHD_GET_ARGUMENT_KIND != kind)\n  {\n    size_t key_len = 0u;\n\n    if (key)\n    {\n      /* This strlen call is the potential out-of-bounds access described in the scenario. */\n      key_len = strlen(key);\n    }\n\n    if (fp != NULL)\n    {\n      fprintf(fp, \"CHECK: key %p computed_len=%zu expected_size=%zu\\n\", (const void *)key, key_len, key_size);\n    }\n\n    if (key_len != key_size)\n    {\n      if (fp != NULL)\n      {\n        fprintf(fp, \"VIOLATION_PATH: returning MHD_NO due to key length mismatch (key_len=%zu != key_size=%zu)\\n\", key_len, key_size);\n        fclose(fp);\n      }\n      return MHD_NO; /* binary zero is allowed only in GET arguments */\n    }\n\n    {\n      size_t value_len = 0u;\n\n      if (value)\n      {\n        /* This strlen call is the other potential out-of-bounds access. */\n        value_len = strlen(value);\n      }\n\n      if (fp != NULL)\n      {\n        fprintf(fp, \"CHECK: value %p computed_len=%zu expected_size=%zu\\n\", (const void *)value, value_len, value_size);\n      }\n\n      if (value_len != value_size)\n      {\n        if (fp != NULL)\n        {\n          fprintf(fp, \"VIOLATION_PATH: returning MHD_NO due to value length mismatch (value_len=%zu != value_size=%zu)\\n\", value_len, value_size);\n          fclose(fp);\n        }\n        return MHD_NO; /* binary zero is allowed only in GET arguments */\n      }\n    }\n  }\n\n  if (fp != NULL)\n  {\n    fprintf(fp, \"PASS_PATH: calling MHD_set_connection_value_n_nocheck_\\n\");\n    fclose(fp);\n  }\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. strlen reads bytes until it finds a '\\0'; if the caller supplies a non-NULL pointer whose buffer is not NUL-terminated within the provided bounds, calling strlen(key) or strlen(value) can read past the end of the object and thus produce out-of-bounds accesses. That use of strlen therefore violates MISRA C 2023 Rule 21.17. In other words, the conditional ((key ? strlen(key) : 0) != key_size) (and the analogous value check) can invoke undefined behaviour when key or value do not contain a terminating '\\0' within their valid storage.\n\nRecommended action: avoid unbounded strlen on buffers whose termination is not guaranteed. Use a bounded scan (e.g. memchr with a known object size or an explicit loop limited to the known maximum number of bytes), or otherwise require/document that the pointers reference NUL-terminated strings. Do not call strlen unless you can guarantee the object contains the terminator within its bounds."
}