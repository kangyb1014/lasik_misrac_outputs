{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "SSIZE_MAX",
    "mhd_assert"
  ],
  "explanation": "For checking the MISRA rule \u201ca function parameter shall not be modified\u201d we must be sure no symbol used by get_rq_extended_uname_copy_z expands or behaves in a way that assigns to any of the function\u2019s parameters (uname_ext, uname_ext_len, buf, buf_size). The following are required so the analyser can determine whether any of those symbols modify a parameter (either by macro expansion or side effects):\n\n- MHD_str_pct_decode_strict_n_: provide its declaration/definition (or macro body). It is called with expressions derived from the parameters (uname_ext + r, uname_ext_len - r, buf, buf_size). If this is a macro it could expand into code that assigns to one of the identifiers passed (e.g. buf) in the caller; if it is a function it cannot change the caller\u2019s parameter variables but may still change the objects pointed to (which is allowed). Verify it does not modify the parameter variables themselves.\n\n- MHD_str_equal_caseless_bin_n_: provide its declaration/definition (or macro body). It is used as a predicate on uname_ext; if it is a macro it might expand into code that assigns to uname_ext or uname_ext_len, so the macro body must be inspected to ensure no modification of caller parameters.\n\n- MHD_STATICSTR_LEN_: provide its macro definition. It is invoked on MHD_DAUTH_EXT_PARAM_PREFIX and its expansion could be a macro that references identifiers in a way that could modify parameters if misused; inspect to be certain it does not assign to any function parameter.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: provide its definition (the static string/identifier). Its form matters only to resolve MHD_STATICSTR_LEN_, but include it so the macro expansion is fully analyzable.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: provide its definition (constant). Used in a comparison with uname_ext_len; include to check nothing odd (e.g. if it were a macro with side effects) and to fully expand expressions.\n\n- SSIZE_MAX: provide its definition (limit macro). Used in the first check and in mhd_assert; include to ensure any macros or casts do not trigger hidden modifications via macro expansion.\n\n- mhd_assert: provide its macro/definition. Assert macros are commonly macros that may expand into statements; ensure its expansion does not modify any parameter identifiers.\n\nOnly these symbols are needed to determine whether any of the function\u2019s own parameters (the pointer variables or size_t parameters) are assigned to or otherwise modified by code (including macro expansions) inside get_rq_extended_uname_copy_z. Note: definitions/prototypes of called functions that are ordinary functions (not macros) are less critical because functions cannot reassign the caller\u2019s local parameter variables, but macros must be inspected; the list focuses on all identifiers in the function that could be macros or have side-effecting expansions."
}