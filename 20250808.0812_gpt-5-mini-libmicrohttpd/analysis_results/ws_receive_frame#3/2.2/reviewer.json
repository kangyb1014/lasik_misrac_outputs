{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When a connection-close WebSocket frame is received, ws_receive_frame sets *type = WS_OPCODE_CON_CLOSE_FRAME and returns msg == NULL. In the caller (run_usock) the very next statement checks if (NULL == msg) and breaks out of the receive loop, so the value written to *type is never observed or used. The assignment to *type in the close-frame branch is therefore an executed operation whose removal would not change behaviour of the current program \u2014 i.e. dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  /* Lightweight tracing to show control path and state for the close-frame scenario. */\n  {\n    FILE *log = fopen(\"/tmp/logs/26.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"ENTER ws_receive_frame: frame0=0x%02X length=%zd\\n\", (unsigned int) frame[0], (ssize_t) *length);\n      fclose(log);\n    }\n  }\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    /* This assignment is the focus of the dead-code scenario: it is executed\n       but in the current program the caller ignores *type when msg == NULL. */\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n\n    /* Log that we took the close-frame path and that msg remains NULL. */\n    {\n      FILE *log = fopen(\"/tmp/logs/26.txt\", \"a\");\n      if (log != NULL)\n      {\n        fprintf(log, \"BRANCH close-frame: set *type=%d msg=%p (msg is NULL)\\n\", *type, (void *) msg);\n        fclose(log);\n      }\n    }\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n\n  /* Final state log for visibility. */\n  {\n    FILE *log = fopen(\"/tmp/logs/26.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"EXIT ws_receive_frame: returned msg=%p type=%d length=%zd\\n\", (void *) msg, *type, (ssize_t) *length);\n      fclose(log);\n    }\n  }\n\n  return msg;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 2.2 forbids dead code: an operation that is executed but whose removal would not affect program behaviour anywhere in the project. The agent\u2019s claim is plausible as a local scenario (if every caller checks for NULL msg and returns/ignores *type when msg==NULL, then writing *type in the close-frame case has no observable effect and could be dead). However, whether that assignment is actually dead is a whole\u2011project property that cannot be established from the single function alone. The assignment writes to caller-supplied storage (int *type) and could be observed by some caller or by later code, could affect aliased or memory-mapped data in unusual build configurations, or be relied on by other call sites. Also the provided test (instrumented code) did not produce evidence (it failed to compile), so there is no demonstrated proof that removal would not change behaviour. Therefore the report as stated is not provably correct: you need a project-wide analysis (all call sites of ws_receive_frame and the uses of *type) to conclude a Rule 2.2 violation. In short: the claim is plausible but not established from the supplied information, so the report is not correct as presented."
}