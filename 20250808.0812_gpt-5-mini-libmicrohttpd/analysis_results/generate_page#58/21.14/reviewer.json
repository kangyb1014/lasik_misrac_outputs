{
  "user_message": "An agent A claimed that the following generate_page code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of generate_page.\n```c\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs in add_response_header_connection: the code uses memcmp to compare an existing Connection header value with the literal \"close\" (mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)))). This performs a memcmp-based comparison against a null-terminated string (hdr->value is treated as a NUL-terminated buffer earlier: buf[pos] = 0). The problematic control path is when MHD_add_response_header is called for the \"Connection\" header while a Connection header is already present (i.e. updating an existing header). In that situation add_response_header_connection reaches the branch that contains the memcmp call and compares hdr->value (a null-terminated C string) to the literal \"close\" using memcmp, violating MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection;\nextern const char *MHD_HTTP_METHOD_GET;\nextern const char *MHD_HTTP_METHOD_HEAD;\nextern const char *MHD_HTTP_METHOD_POST;\nextern const char *MHD_HTTP_HEADER_CONTENT_TYPE;\nextern const unsigned int MHD_HTTP_OK;\nextern const unsigned int MHD_HTTP_FORBIDDEN;\nextern const unsigned int MHD_HTTP_NOT_FOUND;\nextern enum MHD_Result MHD_queue_response(struct MHD_Connection *connection,\n                                         unsigned int status_code,\n                                         struct MHD_Response *response);\nextern struct MHD_Response *MHD_create_response_from_fd(size_t size, int fd);\nextern void MHD_destroy_response(struct MHD_Response *response);\nextern int MHD_add_response_header(struct MHD_Response *response,\n                                   const char *header, const char *value);\nextern void *MHD_create_post_processor(struct MHD_Connection *connection,\n                                       size_t buffer_size,\n                                       void (*processor)(void),\n                                       void *cls);\nextern int MHD_post_process(void *post_processor, const char *data, size_t size);\nextern void MHD_destroy_post_processor(void *post_processor);\nstatic void\nlog_probe (const char *event,\n           const char *url,\n           const char *method,\n           int fd_state)\n{\n  FILE *f = fopen (\"/tmp/logs/470.txt\", \"a\");\n  if (NULL == f)\n    return;\n  (void) fprintf (f, \"EVENT: %s | url=%s | method=%s | fd_state=%d\\n\",\n                  event, (url != NULL) ? url : \"(null)\",\n                  (method != NULL) ? method : \"(null)\", fd_state);\n  (void) fclose (f);\n}\n\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  /* Log entry and basic inputs */\n  log_probe (\"enter_generate_page\", url, method, -1);\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      log_probe (\"unexpected_method_for_file\", url, method, -1);\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    }\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n    {\n      log_probe (\"file_not_found\", url, method, fd);\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n    }\n\n    /* Without libmagic: fall back to extension-based mime detection */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      log_probe (\"create_response_from_fd_failed\", url, method, fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n\n    /* Log before returning file response */\n    log_probe (\"queued_file_response\", url, method, fd);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      log_probe (\"started_post_processor\", url, method, -1);\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      log_probe (\"processing_upload_chunk\", url, method, -1);\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      (void) close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      log_probe (\"upload_refused_response\", url, method, -1);\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      log_probe (\"upload_update_directory_and_return\", url, method, -1);\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* Directory listing returned. This control path can end up calling\n       update_cached_response / MHD_add_response_header that ultimately\n       contains add_response_header_connection where memcmp is used to\n       compare an existing Connection header value to the literal \"close\".\n       Log the fact that we're taking the directory-returning path. */\n    log_probe (\"returning_directory_response_possible_connection_update\", url, method, -1);\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  log_probe (\"unexpected_request_refuse\", url, method, -1);\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct as stated. The generate_page function shown does not itself call memcmp nor perform any direct comparison of null\u2011terminated strings with memcmp. The agent\u2019s scenario points to a memcmp call inside add_response_header_connection (invoked indirectly via MHD_add_response_header) \u2014 if that function actually calls memcmp to compare hdr->value against \"close\" and hdr->value is a NUL\u2011terminated C string, then that other function would violate MISRA C 2023 Rule 21.14. However, that violation would belong to add_response_header_connection (or wherever the memcmp is used), not to generate_page. The test code did not compile and no direct evidence was produced that generate_page itself contains the forbidden memcmp. In short: the underlying memcmp usage (if present) would be a valid MISRA finding, but agent A\u2019s claim that generate_page itself violates Rule 21.14 is incorrect \u2014 the violation would be in the other function invoked by generate_page, not in generate_page\u2019s code shown."
}