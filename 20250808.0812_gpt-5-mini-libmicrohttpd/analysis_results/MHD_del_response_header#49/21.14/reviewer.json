{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function computes header_len = strlen(header) and content_len = strlen(content) (both inputs are null-terminated strings) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare them. This is memcmp being used to compare null-terminated strings, which violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind { MHD_HEADER_KIND = 1 };\nstatic const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nstatic const char MHD_HTTP_HEADER_TRANSFER_ENCODING[] = \"Transfer-Encoding\";\nstatic const char MHD_HTTP_HEADER_DATE[] = \"Date\";\nstatic const char MHD_HTTP_HEADER_CONTENT_LENGTH[] = \"Content-Length\";\nstatic size_t staticstr_len(const char *s)\n{\n  return strlen(s);\n}\nstatic int charsequalcaseless(char a, char b)\n{\n  unsigned char ua = (unsigned char) a;\n  unsigned char ub = (unsigned char) b;\n  if (ua >= 'A' && ua <= 'Z') ua = (unsigned char)(ua - 'A' + 'a');\n  if (ub >= 'A' && ub <= 'Z') ub = (unsigned char)(ub - 'A' + 'a');\n  return ua == ub;\n}\nstatic void log_state(const char *fmt, ...)\n{\n  FILE *f = NULL;\n  /* attempt to create parent directory (ignore errors) */\n  (void) mkdir(\"/tmp/logs\", 0755);\n  f = fopen(\"/tmp/logs/398.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (response == NULL || key == NULL || key_len == 0U)\n    return NULL;\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\nenum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  log_state(\"ENTER MHD_del_response_header: response=%p, header=%p, content=%p\", (void *)response, (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    log_state(\"NULL parameter: header=%p content=%p\", (const void *)header, (const void *)content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  log_state(\"computed header_len=%zu for header='%s'\", header_len, header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (staticstr_len(MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    log_state(\"delegating to del_response_header_connection branch\");\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  log_state(\"computed content_len=%zu for content='%s'\", content_len, content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    log_state(\"iterating header node: pos=%p header_size=%zu value_size=%zu\", (void *)pos, pos->header_size, pos->value_size);\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      log_state(\"memcmp succeeded for header_len=%zu content_len=%zu; removing header node %p\", header_len, content_len, (void *)pos);\n      /* unlink and free */\n      if (NULL == pos->prev)\n      {\n        response->first_header = pos->next;\n      }\n      else\n      {\n        pos->prev->next = pos->next;\n      }\n\n      if (NULL == pos->next)\n      {\n        response->last_header = pos->prev;\n      }\n      else\n      {\n        pos->next->prev = pos->prev;\n      }\n\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (staticstr_len(MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        log_state(\"matched Transfer-Encoding header; clearing TRANS_ENC_CHUNKED flag(0x%X)\", (unsigned) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      }\n      else if ( (staticstr_len(MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        log_state(\"matched Date header; clearing DATE_HDR flag(0x%X)\", (unsigned) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      }\n      else if ( (staticstr_len(MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        log_state(\"matched Content-Length header; checking for other content-length headers\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          log_state(\"no other Content-Length header found; clearing CONTENT_LENGTH flag(0x%X)\", (unsigned) response->flags_auto);\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n      }\n      log_state(\"header removed, returning MHD_YES\");\n      return MHD_YES;\n    }\n    else\n    {\n      /* Log mismatch details */\n      int hcmp = 0;\n      int vcmp = 0;\n      if (header_len == pos->header_size)\n        hcmp = memcmp(header, pos->header, header_len);\n      else\n        hcmp = -1;\n      if (content_len == pos->value_size)\n        vcmp = memcmp(content, pos->value, content_len);\n      else\n        vcmp = -1;\n      log_state(\"comparison failed: hcmp=%d vcmp=%d (header_len=%zu pos->header_size=%zu content_len=%zu pos->value_size=%zu)\", hcmp, vcmp, header_len, pos->header_size, content_len, pos->value_size);\n    }\n    pos = pos->next;\n  }\n  log_state(\"no matching header found; returning MHD_NO\");\n  return MHD_NO;\n}\nstatic enum MHD_Result del_response_header_connection (struct MHD_Response *response,\n                                                       const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr;\n\n  log_state(\"ENTER del_response_header_connection: response=%p value='%s'\", (void *)response, value ? value : \"(null)\");\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     staticstr_len(MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n  {\n    log_state(\"no Connection header present\");\n    return MHD_NO;\n  }\n\n  /* A simplified token removal: if value matches exactly hdr->value, remove token */\n  if (strlen(value) != hdr->value_size)\n  {\n    log_state(\"token length mismatch: value_len=%zu hdr->value_size=%zu\", strlen(value), hdr->value_size);\n    return MHD_NO;\n  }\n  if (0 != memcmp(hdr->value, value, hdr->value_size))\n  {\n    log_state(\"token content mismatch\");\n    return MHD_NO;\n  }\n\n  /* remove header entirely for simplicity */\n  if (NULL == hdr->prev)\n  {\n    response->first_header = hdr->next;\n  }\n  else\n  {\n    hdr->prev->next = hdr->next;\n  }\n\n  if (NULL == hdr->next)\n  {\n    response->last_header = hdr->prev;\n  }\n  else\n  {\n    hdr->next->prev = hdr->prev;\n  }\n\n  free(hdr->value);\n  free(hdr->header);\n  free(hdr);\n  response->flags_auto &= ~((enum MHD_ResponseAutoFlags) (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE));\n  log_state(\"Connection header removed\");\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes header_len = strlen(header) and content_len = strlen(content), so header and content are null-terminated C strings. It then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare those strings. MISRA C 2023 Rule 21.14 forbids use of memcmp to compare null-terminated strings; using memcmp with pointers that refer to C strings (even when comparing only the non\u2011NUL bytes) violates the rule. (The failing test build is irrelevant to the correctness of the reported rule violation.) Suggested remedies: ensure both operands are non\u2011string binary buffers before using memcmp, or use the appropriate string functions (e.g. strcmp/strncmp) with guaranteed NUL-termination, or otherwise make explicit and documented that the buffers are non\u2011NUL-terminated binary data.)"
}