{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_file_size code that contains useful probe functions that print useful logs to a file \"/tmp/logs/43.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_file_size as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_file_size:\n```c\nlfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_size(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    lfs_soff_t res = lfs_file_size_(lfs, file);\n\n    LFS_TRACE(\"lfs_file_size -> %\"PRIu32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n```\n</target_code>\nJudge whether the above lfs_file_size code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "The function lfs_file_size takes pointers lfs_t *lfs and lfs_file_t *file even though it does not modify the objects they point to. According to MISRA C 2023 Rule 8.13, pointers should point to const-qualified types whenever possible. In this code path lfs_file_size only reads from lfs and file (locks using lfs->cfg, asserts open status, calls lfs_file_size_ which is expected to compute size), so both parameters could be const-qualified (for example: const lfs_t *lfs, const lfs_file_t *file). Keeping them non-const prevents expressing the intent that the objects are not modified and therefore violates Rule 8.13.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n\n/* Minimal type definitions preserving original API semantics. */\ntypedef int32_t lfs_soff_t;\n\ntypedef struct lfs_t {\n    void *cfg;\n    void *mlist;\n} lfs_t;\n\ntypedef struct lfs_file_t {\n    /* opaque representation in this unit */\n    int placeholder;\n} lfs_file_t;\n\n/* External functions / macros from the original codebase are declared\n   but not defined here so this file compiles as a translation unit. */\nextern int LFS_LOCK(const void *cfg);\nextern void LFS_UNLOCK(const void *cfg);\nextern void LFS_TRACE(const char *fmt, ...);\nextern void LFS_ASSERT(int cond);\nextern int lfs_mlist_isopen(void *mlist, struct lfs_mlist *m);\nextern lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file);\n\n/* Probe logger: writes control path and state information to a file. */\nstatic void probe_log(const char *stage, const lfs_t *lfs, const lfs_file_t *file,\n                      int err, lfs_soff_t res)\n{\n    FILE *f = fopen(\"/tmp/logs/43.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    /* Log pointer values and state. */\n    (void)fprintf(f, \"stage=%s, lfs=%p, file=%p, err=%d, res=%\" PRId32 \"\\n\",\n                  stage, (const void*)lfs, (const void*)file, err, res);\n    (void)fclose(f);\n}\n\n/* The original function, preserved as closely as possible, with added\n   probe logging to demonstrate the violation scenario. Note: parameters\n   remain non-const like the original API, which is what triggers the\n   Rule 8.13 concern (they could be const if not modified). */\n\nlfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {\n    /* Probe: entering function; no modification performed here. */\n    probe_log(\"enter\", lfs, file, 0, 0);\n\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        /* Log lock failure path and return the error as in original code. */\n        probe_log(\"lock_failed\", lfs, file, err, 0);\n        return (lfs_soff_t)err;\n    }\n\n    LFS_TRACE(\"lfs_file_size(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Call underlying implementation (assumed not to modify lfs/file here).\n       Preserve original call signature to maintain behavior. */\n    lfs_soff_t res = lfs_file_size_(lfs, file);\n\n    /* Probe: after computing size. */\n    probe_log(\"after_size\", lfs, file, 0, res);\n\n    LFS_TRACE(\"lfs_file_size -> %\" PRIu32, (uint32_t)res);\n    LFS_UNLOCK(lfs->cfg);\n\n    /* Probe: before return. */\n    probe_log(\"return\", lfs, file, 0, res);\n    return res;\n}\n"
}