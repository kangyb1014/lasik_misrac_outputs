{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_file_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/34.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_file_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_file_open:\n```c\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_file_open:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\n#define LFS_ASSERT(test) assert(test)\n...\nstatic bool lfs_mlist_isopen(struct lfs_mlist *head,\n        struct lfs_mlist *node) {\n    for (struct lfs_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n...\nstatic int lfs_file_open_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags) {\n    static const struct lfs_file_config defaults = {0};\n    int err = lfs_file_opencfg_(lfs, file, path, flags, &defaults);\n    return err;\n}\n...\nstatic int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n#ifndef LFS_READONLY\n    // deorphan if we haven't yet, needed at most once after poweron\n    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n        int err = lfs_fs_forceconsistency(lfs);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS_ASSERT((flags & LFS_O_RDONLY) == LFS_O_RDONLY);\n#endif\n\n    // setup simple file details\n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    // allocate entry for file if it doesn't exist\n    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);\n    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {\n        err = tag;\n        goto cleanup;\n    }\n\n    // get id, add to list of mdirs to catch update changes\n    file->type = LFS_TYPE_REG;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)file);\n\n#ifdef LFS_READONLY\n    if (tag == LFS_ERR_NOENT) {\n        err = LFS_ERR_NOENT;\n        goto cleanup;\n#else\n    if (tag == LFS_ERR_NOENT) {\n        if (!(flags & LFS_O_CREAT)) {\n            err = LFS_ERR_NOENT;\n            goto cleanup;\n        }\n\n        // don't allow trailing slashes\n        if (lfs_path_isdir(path)) {\n            err = LFS_ERR_NOTDIR;\n            goto cleanup;\n        }\n\n        // check that name fits\n        lfs_size_t nlen = lfs_path_namelen(path);\n        if (nlen > lfs->name_max) {\n            err = LFS_ERR_NAMETOOLONG;\n            goto cleanup;\n        }\n\n        // get next slot and create entry to remember name\n        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(\n                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},\n                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},\n                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n\n        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will\n        // not fit in a 128 byte block.\n        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;\n        if (err) {\n            goto cleanup;\n        }\n\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);\n    } else if (flags & LFS_O_EXCL) {\n        err = LFS_ERR_EXIST;\n        goto cleanup;\n#endif\n    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {\n        err = LFS_ERR_ISDIR;\n        goto cleanup;\n#ifndef LFS_READONLY\n    } else if (flags & LFS_O_TRUNC) {\n        // truncate if requested\n        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS_F_DIRTY;\n#endif\n    } else {\n        // try to load what's on disk, if it's inlined we'll fix it later\n        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n        lfs_ctz_fromle32(&file->ctz);\n    }\n\n    // fetch attrs\n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        // if opened for read / read-write operations\n        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            if (res < 0 && res != LFS_ERR_NOENT) {\n                err = res;\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS_READONLY\n        // if opened for write / read-write operations\n        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {\n            if (file->cfg->attrs[i].size > lfs->attr_max) {\n                err = LFS_ERR_NOSPC;\n                goto cleanup;\n            }\n\n            file->flags |= LFS_F_DIRTY;\n        }\n#endif\n    }\n\n    // allocate buffer if needed\n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else {\n        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    // zero to avoid information leak\n    lfs_cache_zero(lfs, &file->cache);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        // load inline files\n        file->ctz.head = LFS_BLOCK_INLINE;\n        file->ctz.size = lfs_tag_size(tag);\n        file->flags |= LFS_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs->cfg->cache_size;\n\n        // don't always read (may be new/trunc file)\n        if (file->ctz.size > 0) {\n            lfs_stag_t res = lfs_dir_get(lfs, &file->m,\n                    LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,\n                        lfs_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            if (res < 0) {\n                err = res;\n                goto cleanup;\n            }\n        }\n    }\n\n    return 0;\n\ncleanup:\n    // clean up lingering resources\n#ifndef LFS_READONLY\n    file->flags |= LFS_F_ERRED;\n#endif\n    lfs_file_close_(lfs, file);\n    return err;\n}\n...\nstruct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    }\n</additional code>\nJudge whether the above lfs_file_open code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The calls to LFS_LOCK / LFS_UNLOCK and LFS_TRACE in lfs_file_open are effectively no-ops in the provided project configuration (LFS_LOCK expands to ((void)cfg,0), LFS_UNLOCK to ((void)cfg), and LFS_TRACE to nothing). The invocation of these operations is executed but their removal would not affect program behaviour in this configuration, therefore they constitute dead code per MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe function: logs control path and state to /tmp/logs/34.txt\n   This function preserves behavior (only appends a trace), and is\n   intended to show that certain operations (locks/traces) are no-ops\n   in the current configuration. */\nstatic void lfs_file_open_probe(const char *stage, const void *lfs,\n        const void *file, const char *path, int flags,\n        int err_before, int err_after) {\n    FILE *fp = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (!fp) {\n        return;\n    }\n    fprintf(fp, \"stage=%s lfs=%p file=%p path=%s flags=0x%08x err_before=%d err_after=%d\\n\",\n            stage, (const void*)lfs, (const void*)file,\n            (path != NULL) ? path : \"<null>\", (unsigned)flags,\n            err_before, err_after);\n    fclose(fp);\n}\n\nint lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {\n    /* Preserve original logic: obtain lock and record its return */\n    int err = LFS_LOCK(lfs->cfg);\n    lfs_file_open_probe(\"after_lock\", lfs, file, path, flags, err, -1);\n    if (err) {\n        lfs_file_open_probe(\"lock_failed\", lfs, file, path, flags, err, -1);\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs, (void*)file, path, (unsigned)flags);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Call underlying open implementation */\n    err = lfs_file_open_(lfs, file, path, flags);\n\n    lfs_file_open_probe(\"after_open_\", lfs, file, path, flags, 0, err);\n\n    LFS_TRACE(\"lfs_file_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    lfs_file_open_probe(\"after_unlock\", lfs, file, path, flags, err, err);\n    return err;\n}\n"
}