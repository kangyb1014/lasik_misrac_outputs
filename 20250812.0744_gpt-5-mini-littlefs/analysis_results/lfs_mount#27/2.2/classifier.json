{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_mount code that contains useful probe functions that print useful logs to a file \"/tmp/logs/218.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_mount as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_mount:\n```c\nint lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = LFS_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_mount(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRId32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"})\",\n            (void*)lfs, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    err = lfs_mount_(lfs, cfg);\n\n    LFS_TRACE(\"lfs_mount -> %d\", err);\n    LFS_UNLOCK(cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_mount:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\nstatic int lfs_mount_(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = lfs_init(lfs, cfg);\n    if (err) {\n        return err;\n    }\n\n    // scan directory blocks for superblock and any global updates\n    lfs_mdir_t dir = {.tail = {0, 1}};\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    while (!lfs_pair_isnull(dir.tail)) {\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        if (err < 0) {\n            goto cleanup;\n        }\n\n        // fetch next block in tail list\n        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,\n                LFS_MKTAG(0x7ff, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),\n                NULL,\n                lfs_dir_find_match, &(struct lfs_dir_find_match){\n                    lfs, \"littlefs\", 8});\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n\n        // has superblock?\n        if (tag && !lfs_tag_isdelete(tag)) {\n            // update root\n            lfs->root[0] = dir.pair[0];\n            lfs->root[1] = dir.pair[1];\n\n            // grab superblock\n            lfs_superblock_t superblock;\n            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock);\n            if (tag < 0) {\n                err = tag;\n                goto cleanup;\n            }\n            lfs_superblock_fromle32(&superblock);\n\n            // check version\n            uint16_t major_version = (0xffff & (superblock.version >> 16));\n            uint16_t minor_version = (0xffff & (superblock.version >>  0));\n            if (major_version != lfs_fs_disk_version_major(lfs)\n                    || minor_version > lfs_fs_disk_version_minor(lfs)) {\n                LFS_ERROR(\"Invalid version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" != v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            // found older minor version? set an in-device only bit in the\n            // gstate so we know we need to rewrite the superblock before\n            // the first write\n            bool needssuperblock = false;\n            if (minor_version < lfs_fs_disk_version_minor(lfs)) {\n                LFS_DEBUG(\"Found older minor version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" < v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs_fs_disk_version_major(lfs),\n                        lfs_fs_disk_version_minor(lfs));\n                needssuperblock = true;\n            }\n            // note this bit is reserved on disk, so fetching more gstate\n            // will not interfere here\n            lfs_fs_prepsuperblock(lfs, needssuperblock);\n\n            // check superblock configuration\n            if (superblock.name_max) {\n                if (superblock.name_max > lfs->name_max) {\n                    LFS_ERROR(\"Unsupported name_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.name_max, lfs->name_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->name_max = superblock.name_max;\n            }\n\n            if (superblock.file_max) {\n                if (superblock.file_max > lfs->file_max) {\n                    LFS_ERROR(\"Unsupported file_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.file_max, lfs->file_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->file_max = superblock.file_max;\n            }\n\n            if (superblock.attr_max) {\n                if (superblock.attr_max > lfs->attr_max) {\n                    LFS_ERROR(\"Unsupported attr_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.attr_max, lfs->attr_max);\n                    err = LFS_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs->attr_max = superblock.attr_max;\n\n                // we also need to update inline_max in case attr_max changed\n                lfs->inline_max = lfs_min(lfs->inline_max, lfs->attr_max);\n            }\n\n            // this is where we get the block_count from disk if block_count=0\n            if (lfs->cfg->block_count\n                    && superblock.block_count != lfs->cfg->block_count) {\n                LFS_ERROR(\"Invalid block count (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_count, lfs->cfg->block_count);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n\n            lfs->block_count = superblock.block_count;\n\n            if (superblock.block_size != lfs->cfg->block_size) {\n                LFS_ERROR(\"Invalid block size (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_size, lfs->cfg->block_size);\n                err = LFS_ERR_INVAL;\n                goto cleanup;\n            }\n        }\n\n        // has gstate?\n        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);\n        if (err) {\n            goto cleanup;\n        }\n    }\n\n    // update littlefs with gstate\n    if (!lfs_gstate_iszero(&lfs->gstate)) {\n        LFS_DEBUG(\"Found pending gstate 0x%08\"PRIx32\"%08\"PRIx32\"%08\"PRIx32,\n                lfs->gstate.tag,\n                lfs->gstate.pair[0],\n                lfs->gstate.pair[1]);\n    }\n    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);\n    lfs->gdisk = lfs->gstate;\n\n    // setup free lookahead, to distribute allocations uniformly across\n    // boots, we start the allocator at a random location\n    lfs->lookahead.start = lfs->seed % lfs->block_count;\n    lfs_alloc_drop(lfs);\n\n    return 0;\n\ncleanup:\n    lfs_unmount_(lfs);\n    return err;\n}\n</additional code>\nJudge whether the above lfs_mount code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "LFS_UNLOCK(cfg) (and in the present configuration LFS_LOCK(cfg)) are effectively no-ops. LFS_UNLOCK expands to ((void)cfg) which only evaluates cfg and has no side-effects. Because that operation is executed on every successful mount but its removal would not change program behaviour, it constitutes dead code under MISRA C 2023 Rule 2.2. (Note: LFS_TRACE expands to nothing and is removed by the preprocessor, so it is not executed \u2014 per the rule's Note 2 that unreachable code is not the same issue.)",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdbool.h>\n\n/* Probe logger: append human-readable control-path/state info to file.\n   This function has side-effects (file I/O) and is used at multiple\n   points in lfs_mount to demonstrate where the (now-)dead operations\n   occur in the control flow. */\nstatic void probe_log(const char *event, void *lfs_ptr, const struct lfs_config *cfg, int err) {\n    FILE *f = fopen(\"/tmp/logs/218.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    /* Log basic control path and some configuration/state fields used\n       by lfs_mount. We mirror some of the fields the original code\n       references to give context for the violation scenario. */\n    fprintf(f, \"event=%s lfs=%p cfg=%p err=%d\\n\",\n            event, lfs_ptr, (void*)cfg, err);\n\n    if (cfg != NULL) {\n        /* Some of these members are referenced by the original lfs_mount\n           call site. Cast function pointers via (uintptr_t) for safe\n           printing as pointers. */\n        fprintf(f, \"  cfg->context=%p\\n\", cfg->context);\n        fprintf(f, \"  cfg->read=%p prog=%p erase=%p sync=%p\\n\",\n                (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n                (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync);\n        fprintf(f, \"  sizes: read=%\" PRIu32 \" prog=%\" PRIu32 \" block=%\" PRIu32 \" count=%\" PRIu32 \"\\n\",\n                cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count);\n    }\n\n    fclose(f);\n}\n\n/* Modified lfs_mount that preserves original behaviour but inserts\n   probe_log calls to record the control path and state. The original\n   locking/unlocking macros are still called; the probe demonstrates\n   that LFS_UNLOCK expands to a side-effect free operation that is\n   executed but could be removed without changing behaviour. */\nint lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {\n    int err = LFS_LOCK(cfg);\n\n    /* Log immediately after attempting lock to capture err value. */\n    probe_log(\"after_lock\", (void*)lfs, cfg, err);\n\n    if (err) {\n        probe_log(\"early_return_lock_fail\", (void*)lfs, cfg, err);\n        return err;\n    }\n\n    /* Preserve original trace call sites (which are macros in the\n       project). We do not use LFS_TRACE here because it expands to\n       nothing in this configuration; instead we emit explicit logs. */\n    probe_log(\"before_mount_impl\", (void*)lfs, cfg, 0);\n\n    err = lfs_mount_(lfs, cfg);\n\n    probe_log(\"after_mount_impl\", (void*)lfs, cfg, err);\n\n    /* The following unlock is executed on the normal return path. In\n       the current project configuration LFS_UNLOCK(cfg) expands to\n       '((void)cfg)', an operation without side-effects. This call is\n       therefore an executed operation whose removal would not affect\n       program behaviour (dead code by Rule 2.2). We still invoke it\n       here to preserve original logic. */\n    probe_log(\"before_unlock\", (void*)lfs, cfg, err);\n    LFS_UNLOCK(cfg);\n    probe_log(\"after_unlock\", (void*)lfs, cfg, err);\n\n    return err;\n}\n"
}