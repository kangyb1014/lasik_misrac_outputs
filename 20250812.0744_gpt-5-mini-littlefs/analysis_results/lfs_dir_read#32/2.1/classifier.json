{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_dir_read code that contains useful probe functions that print useful logs to a file \"/tmp/logs/257.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_dir_read as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_dir_read:\n```c\nint lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_read(%p, %p, %p)\",\n            (void*)lfs, (void*)dir, (void*)info);\n\n    err = lfs_dir_read_(lfs, dir, info);\n\n    LFS_TRACE(\"lfs_dir_read -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_read:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\nstatic int lfs_dir_read_(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {\n    memset(info, 0, sizeof(*info));\n\n    // special offset for '.' and '..'\n    if (dir->pos == 0) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \".\");\n        dir->pos += 1;\n        return true;\n    } else if (dir->pos == 1) {\n        info->type = LFS_TYPE_DIR;\n        strcpy(info->name, \"..\");\n        dir->pos += 1;\n        return true;\n    }\n\n    while (true) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return false;\n            }\n\n            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);\n        if (err && err != LFS_ERR_NOENT) {\n            return err;\n        }\n\n        dir->id += 1;\n        if (err != LFS_ERR_NOENT) {\n            break;\n        }\n    }\n\n    dir->pos += 1;\n    return true;\n}\n</additional code>\nJudge whether the above lfs_dir_read code violates the rule 2.1 or not.",
  "is_rule_violated": false,
  "scenario": "No violation: lfs_dir_read contains no unreachable code. All statements are on reachable control paths: the initial early return on lock failure is conditional and valid, and the remaining trace/unlock/return sequence is executed when the lock succeeds. There are no statements that can never be executed.",
  "test_code": ""
}