{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_stat code that contains useful probe functions that print useful logs to a file \"/tmp/logs/98.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_stat as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_stat:\n```c\nint lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_stat(%p, \\\"%s\\\", %p)\", (void*)lfs, path, (void*)info);\n\n    err = lfs_stat_(lfs, path, info);\n\n    LFS_TRACE(\"lfs_stat -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_stat:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\nstatic int lfs_stat_(lfs_t *lfs, const char *path, struct lfs_info *info) {\n    lfs_mdir_t cwd;\n    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    // only allow trailing slashes on dirs\n    if (strchr(path, '/') != NULL\n            && lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n        return LFS_ERR_NOTDIR;\n    }\n\n    return lfs_dir_getinfo(lfs, &cwd, lfs_tag_id(tag), info);\n}\n...\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic inline uint16_t lfs_tag_type3(lfs_tag_t tag) {\n    return (tag & 0x7ff00000) >> 20;\n}\n...\nstatic int lfs_dir_getinfo(lfs_t *lfs, lfs_mdir_t *dir,\n        uint16_t id, struct lfs_info *info) {\n    if (id == 0x3ff) {\n        // special case for root\n        strcpy(info->name, \"/\");\n        info->type = LFS_TYPE_DIR;\n        return 0;\n    }\n\n    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    info->type = lfs_tag_type3(tag);\n\n    struct lfs_ctz ctz;\n    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n            LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n    if (tag < 0) {\n        return (int)tag;\n    }\n    lfs_ctz_fromle32(&ctz);\n\n    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {\n        info->size = ctz.size;\n    } else if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {\n        info->size = lfs_tag_size(tag);\n    }\n\n    return 0;\n}\n...\nstatic inline uint16_t lfs_tag_id(lfs_tag_t tag) {\n    return (tag & 0x000ffc00) >> 10;\n}\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n...\nstruct lfs_info {\n    // Type of the file, either LFS_TYPE_REG or LFS_TYPE_DIR\n    uint8_t type;\n\n    // Size of the file, only valid for REG files. Limited to 32-bits.\n    lfs_size_t size;\n\n    // Name of the file stored as a null-terminated string. Limited to\n    // LFS_NAME_MAX+1, which can be changed by redefining LFS_NAME_MAX to\n    // reduce RAM. LFS_NAME_MAX is stored in superblock and must be\n    // respected by other littlefs drivers.\n    char name[LFS_NAME_MAX+1];\n}\n</additional code>\nJudge whether the above lfs_stat code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "In this project LFS_TRACE is defined as an empty macro and LFS_UNLOCK is defined to ((void)cfg) (no effect). The LFS_UNLOCK() call (and the trace calls) are executed but have no effect on program behaviour; removing them would not change behaviour, so they constitute dead code per MISRA C 2023 Rule 2.2. Additionally, LFS_LOCK() is defined to return 0, making the 'if (err) { return err; }' branch unreachable (note 2 says unreachable code is not dead code, but it highlights that lock always succeeds in this configuration). The concrete violation is the presence of executed no-op operations (lock/unlock/trace) whose removal would not affect program behaviour.",
  "test_code": "#include <stdio.h>\n#include <sys/stat.h>\n\n/* Probe function that logs control path and state to /tmp/logs/98.txt.\n   This function intentionally keeps the original lfs_stat behaviour but\n   records the control flow and key state values so the no-op operations\n   (LFS_TRACE / LFS_UNLOCK) and the lock result can be observed. */\nstatic void lfs_stat_probe(const char *stage, lfs_t *lfs, const char *path,\n        struct lfs_info *info, int err) {\n    /* try to ensure the log directory exists; ignore errors */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    FILE *f = fopen(\"/tmp/logs/98.txt\", \"a\");\n    if (f) {\n        /* Log stage, pointers and err value. Cast pointers to void* for %p. */\n        fprintf(f, \"stage=%s, lfs=%p, path=%p, info=%p, err=%d\\n\",\n                stage, (void*)lfs, (void*)path, (void*)info, err);\n        /* If info is present, attempt to log some of its state safely. */\n        if (info != NULL) {\n            /* name may not be null-terminated in pathological cases, but in\n               typical usage it is. We print pointer and type/size fields if\n               available. Accessing fields preserves original behaviour. */\n            fprintf(f, \"  info->type=%u, info->size=%u, info->name=%p\\n\",\n                    (unsigned)info->type,\n                    (unsigned)info->size,\n                    (void*)info->name);\n        }\n        fclose(f);\n    }\n}\n\nint lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {\n    int err = LFS_LOCK(lfs->cfg);\n    /* Probe immediately after lock to show the lock result (in this\n       project LFS_LOCK expands to 0). */\n    lfs_stat_probe(\"after_lock\", lfs, path, info, err);\n\n    if (err) {\n        /* Log the early return path if it ever occurs. In the provided\n           configuration this branch will not be taken because LFS_LOCK\n           returns 0, but we preserve the original logic. */\n        lfs_stat_probe(\"early_return_lock_failed\", lfs, path, info, err);\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_stat(%p, \\\"%s\\\", %p)\", (void*)lfs, path, (void*)info);\n\n    err = lfs_stat_(lfs, path, info);\n\n    /* Log result from the internal lfs_stat_ call. */\n    lfs_stat_probe(\"after_lfs_stat_\", lfs, path, info, err);\n\n    LFS_TRACE(\"lfs_stat -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    /* Log just before returning so we can observe that LFS_UNLOCK is a\n       no-op in this configuration: the behavior-established state is the\n       same with or without the explicit unlock call here. */\n    lfs_stat_probe(\"before_return\", lfs, path, info, err);\n    return err;\n}\n"
}