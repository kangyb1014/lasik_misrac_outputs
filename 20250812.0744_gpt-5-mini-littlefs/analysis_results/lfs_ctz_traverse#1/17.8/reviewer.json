{
  "user_message": "An agent A claimed that the following lfs_ctz_traverse code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of lfs_ctz_traverse.\n```c\nstatic int lfs_ctz_traverse(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_block_t head, lfs_size_t size,\n        int (*cb)(void*, lfs_block_t), void *data) {\n    if (size == 0) {\n        return 0;\n    }\n\n    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});\n\n    while (true) {\n        int err = cb(data, head);\n        if (err) {\n            return err;\n        }\n\n        if (index == 0) {\n            return 0;\n        }\n\n        lfs_block_t heads[2];\n        int count = 2 - (index & 1);\n        err = lfs_bd_read(lfs,\n                pcache, rcache, count*sizeof(head),\n                head, 0, &heads, count*sizeof(head));\n        heads[0] = lfs_fromle32(heads[0]);\n        heads[1] = lfs_fromle32(heads[1]);\n        if (err) {\n            return err;\n        }\n\n        for (int i = 0; i < count-1; i++) {\n            err = cb(data, heads[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        head = heads[count-1];\n        index -= count;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function modifies the non-pointer parameter 'head' (type lfs_block_t) inside the traversal loop: the assignment 'head = heads[count-1];' changes the value of the parameter 'head'. According to MISRA C 2023 Rule 17.8, a function parameter should not be modified. This modification occurs when size != 0 and the traversal loop iterates (index != 0).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_probe(const char *stage, lfs_block_t head, lfs_off_t index, int count) {\n    FILE *f = fopen(\"/tmp/logs/13.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    /* Write a single line with stage and state values */\n    fprintf(f, \"%s: head=%u, index=%u, count=%d\\n\", stage, (unsigned)head, (unsigned)index, count);\n    fclose(f);\n}\n\nstatic lfs_off_t lfs_ctz_index(const lfs_t *lfs, lfs_off_t *off) {\n    /* Return the provided offset as-is (no modification of *off) */\n    (void)lfs;\n    return *off;\n}\nstatic int lfs_bd_read(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_size_t size, lfs_block_t block, lfs_off_t off,\n        void *buffer, lfs_size_t bsize) {\n    (void)lfs; (void)pcache; (void)rcache; (void)size; (void)off; (void)bsize;\n    /* Provide deterministic next-head values for demonstration purposes. */\n    uint32_t *buf = (uint32_t *)buffer;\n    buf[0] = (uint32_t)(block + 1);\n    buf[1] = (uint32_t)(block + 2);\n    return 0;\n}\nstatic int lfs_ctz_traverse(lfs_t *lfs,\n        const lfs_cache_t *pcache, lfs_cache_t *rcache,\n        lfs_block_t head, lfs_size_t size,\n        int (*cb)(void*, lfs_block_t), void *data) {\n    if (size == 0) {\n        log_probe(\"entry_zero_size\", head, 0u, 0);\n        return 0;\n    }\n\n    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});\n    log_probe(\"entry\", head, index, 0);\n\n    while (true) {\n        /* Log before callback invocation */\n        log_probe(\"before_cb\", head, index, 0);\n        int err = cb(data, head);\n        /* Log after callback returns */\n        log_probe(\"after_cb\", head, index, 0);\n        if (err) {\n            log_probe(\"cb_err\", head, index, 0);\n            return err;\n        }\n\n        if (index == 0) {\n            log_probe(\"done_index_zero\", head, index, 0);\n            return 0;\n        }\n\n        lfs_block_t heads[2];\n        int count = 2 - (index & 1);\n        log_probe(\"before_read\", head, index, count);\n        err = lfs_bd_read(lfs,\n                pcache, rcache, (lfs_size_t)count * (lfs_size_t)sizeof(head),\n                head, 0, &heads, (lfs_size_t)count * (lfs_size_t)sizeof(head));\n        heads[0] = (lfs_block_t)lfs_fromle32((uint32_t)heads[0]);\n        heads[1] = (lfs_block_t)lfs_fromle32((uint32_t)heads[1]);\n        log_probe(\"after_read\", head, index, count);\n        if (err) {\n            log_probe(\"read_err\", head, index, count);\n            return err;\n        }\n\n        for (int i = 0; i < count-1; i++) {\n            log_probe(\"before_cb_heads\", heads[i], index, count);\n            err = cb(data, heads[i]);\n            log_probe(\"after_cb_heads\", heads[i], index, count);\n            if (err) {\n                log_probe(\"cb_heads_err\", heads[i], index, count);\n                return err;\n            }\n        }\n\n        /* VIOLATION: modifying the parameter 'head' here\n           (this is the Rule 17.8 violation we are demonstrating) */\n        log_probe(\"before_assign_head\", head, index, count);\n        head = heads[count-1];\n        log_probe(\"after_assign_head\", head, index, count);\n\n        index -= count;\n        log_probe(\"after_index_dec\", head, index, count);\n    }\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for lfs_ctz_traverse. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the note only permits modifying the object pointed-to by a pointer parameter, not the pointer itself). In lfs_ctz_traverse the parameter head (a scalar lfs_block_t passed by value) is assigned to inside the loop (head = heads[count-1];), which modifies the parameter object and therefore violates Rule 17.8. To comply, make a local copy (for example lfs_block_t cur = head;) and modify cur instead, or otherwise avoid assigning to the parameter."
}