{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_TranslatePath code that contains useful probe functions that print useful logs to a file \"/tmp/logs/97.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_TranslatePath as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_TranslatePath:\n```c\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_TranslatePath:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_MAX_PATH_LEN 64\n...\n#define OS_MAX_FILE_NAME 20\n...\nbool OS_FileSys_FindVirtMountPoint(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_filesys_internal_record_t *filesys;\n    const char *                  target = (const char *)ref;\n    size_t                        mplen;\n\n    filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL) == 0)\n    {\n        return false;\n    }\n\n    mplen = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n    /*\n     * The virtual_mountpt member should be a substring of the search target.\n     * If this matches a basic substring check then it may be match\n     */\n    if (mplen == 0 || mplen >= sizeof(filesys->virtual_mountpt) ||\n        strncmp(target, filesys->virtual_mountpt, mplen) != 0)\n    {\n        /* not a substring, so not a match */\n        return false;\n    }\n\n    /*\n     * Confirm that the substring ends at either a directory separator\n     * or the end of string  (so exact mount points also match).\n     *\n     * For instance consider a virtual_mountpt of /mnt/abc and searching\n     * for target=/mnt/abcd - this should return false in that case.\n     */\n    return (target[mplen] == '/' || target[mplen] == 0);\n}\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n</additional code>\nJudge whether the above OS_TranslatePath code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "The code contains an unreachable code segment after a return statement inside conditional branches. For example, if 'VirtualPath[0] != '/'', the function returns immediately, and any code following that outside the conditional is unreachable.",
  "test_code": "int32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    FILE *log_file = fopen(\"/tmp/logs/97.txt\", \"w\");\n    if (!log_file) return -1;\n\n    OS_object_token_t token;\n    int32 return_code;\n    const char *name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t SysMountPointLen;\n    size_t VirtPathLen;\n    size_t VirtPathBegin;\n\n    /* Log start of function call */\n    fprintf(log_file, \"Start OS_TranslatePath\\n\");\n\n    /* Check parameters */\n    if (VirtualPath == NULL)\n    {\n        fprintf(log_file, \"VirtualPath is NULL\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_PATH_INVALID;\n    }\n    if (LocalPath == NULL)\n    {\n        fprintf(log_file, \"LocalPath is NULL\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Check length */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    fprintf(log_file, \"VirtPathLen=%zu\\n\", VirtPathLen);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        fprintf(log_file, \"Path too long\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    fprintf(log_file, \"Name ptr=%p\\n\", (void*)name_ptr);\n    if (name_ptr == NULL)\n    {\n        fprintf(log_file, \"No '/' found\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    fprintf(log_file, \"Name ptr after = %p\\n\", (void*)name_ptr);\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        fprintf(log_file, \"Name too long\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin = VirtPathLen;\n\n    /* Check if path starts with '/' */\n    if (VirtualPath[0] != '/')\n    {\n        fprintf(log_file, \"Path does not start with '/'\\n\");\n        fclose(log_file);\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get filesystem lock and find mount point */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n    fprintf(log_file, \"Return from OS_ObjectIdGetBySearch=%d\\n\", return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n        fprintf(log_file, \"ObjectIdGetBySearch failed\\n\");\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n        fprintf(log_file, \"Found filesys flags=0x%x\\n\", filesys->flags);\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n            fprintf(log_file, \"Mounted system, SysMountPointLen=%zu\\n\", SysMountPointLen);\n        }\n        else\n        {\n            fprintf(log_file, \"File system not mounted\\n\");\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            fprintf(log_file, \"Invalid path length\\n\");\n            fclose(log_file);\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            fprintf(log_file, \"VirtPathBegin=%zu, VirtPathLen=%zu\\n\", VirtPathBegin, VirtPathLen);\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n                fprintf(log_file, \"Constructed LocalPath=%s\\n\", LocalPath);\n            }\n            else\n            {\n                fprintf(log_file, \"Path too long to fit in LocalPath\\n\");\n                fclose(log_file);\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    fclose(log_file);\n    return return_code;\n}"
}