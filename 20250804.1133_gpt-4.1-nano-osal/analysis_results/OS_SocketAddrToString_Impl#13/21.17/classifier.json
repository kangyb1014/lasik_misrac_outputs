{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_SocketAddrToString_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/111.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_SocketAddrToString_Impl as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_SocketAddrToString_Impl:\n```c\nint32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr)\n{\n    const void *                  addrbuffer;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            addrbuffer = &Accessor->sa_in.sin_addr;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrbuffer = &Accessor->sa_in6.sin6_addr;\n            break;\n#endif\n        default:\n            return OS_ERR_BAD_ADDRESS;\n            break;\n    }\n\n    if (inet_ntop(Accessor->sa.sa_family, addrbuffer, buffer, buflen) == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\nJudge whether the above OS_SocketAddrToString_Impl code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function calls inet_ntop with the buffer and buflen provided as parameters, which internally uses string handling functions like memcpy or strcpy that could potentially write beyond the buffer bounds if buflen is insufficient or the address is malformed, violating rule 21.17.",
  "test_code": "```c\n#include <stdio.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nint os_socketaddrtoString_log(const char *msg) {\n    FILE *logfile = fopen(\"/tmp/logs/111.txt\", \"a\");\n    if (!logfile) return -1;\n    fprintf(logfile, \"%s\\n\", msg);\n    fclose(logfile);\n    return 0;\n}\n\nint32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr) {\n    const void *addrbuffer;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family) {\n        case AF_INET:\n            addrbuffer = &Accessor->sa_in.sin_addr;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrbuffer = &Accessor->sa_in6.sin6_addr;\n            break;\n#endif\n        default:\n            os_socketaddrtoString_log(\"Default case: invalid address family.\");\n            return OS_ERR_BAD_ADDRESS;\n    }\n\n    if (inet_ntop(Accessor->sa.sa_family, addrbuffer, buffer, buflen) == NULL) {\n        os_socketaddrtoString_log(\"inet_ntop failed: unable to convert address to string.\");\n        return OS_ERROR;\n    }\n\n    os_socketaddrtoString_log(\"Address conversion succeeded.\");\n    return OS_SUCCESS;\n}\n```"
}