{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses strcmp(stream->stream_name, Filename), which compares strings without verifying that the pointers are valid and properly null-terminated within bounds  before usage.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32 return_code;\n    OS_object_iter_t iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    if (Filename == NULL) {\n        FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n        if (logfile != NULL) {\n            fprintf(logfile, \"Parameter Filename is NULL at OS_FileOpenCheck.\\n\");\n            fclose(logfile);\n        }\n        return OS_ERROR;\n    }\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream != NULL && stream->socket_domain == OS_SocketDomain_INVALID) {\n            // Check stream_name pointer validity\n            if (stream->stream_name != NULL) {\n                // Check for null-terminator within a reasonable size to ensure string safety\n                size_t max_check = 256;\n                size_t i = 0;\n                int null_found = 0;\n                while (i < max_check) {\n                    if (stream->stream_name[i] == '\\0') {\n                        null_found = 1;\n                        break;\n                    }\n                    i++;\n                }\n                if (null_found) {\n                    if (strcmp(stream->stream_name, Filename) == 0) {\n                        return_code = OS_SUCCESS;\n                        break;\n                    }\n                } else {\n                    // log potential string without null-terminator\n                    FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n                    if (logfile != NULL) {\n                        fprintf(logfile, \"Potential unterminated string in stream_name at iter token %d.\\n\", iter.token);\n                        fclose(logfile);\n                    }\n                }\n            } else {\n                // log null pointer for stream_name\n                FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (logfile != NULL) {\n                    fprintf(logfile, \"stream_name is NULL at iter token %d.\\n\", iter.token);\n                    fclose(logfile);\n                }\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The original code uses strcmp(stream->stream_name, Filename) directly without verifying that stream->stream_name points to a null-terminated string within bounds. This could potentially lead to undefined behavior if stream->stream_name does not satisfy these conditions. The provided test code enhancement introduces checks for null pointers and attempts to ensure string safety, which supports the concern raised. Since strcmp relies on a null-terminated string, any violation of this assumption would constitute a breach of MISRA C 2023 Rule 21.17. Therefore, the agent's claim that the original code violates this rule is justified."
}