{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_BSP_Initialize code that contains useful probe functions that print useful logs to a file \"/tmp/logs/146.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_BSP_Initialize as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_BSP_Initialize:\n```c\nvoid OS_BSP_Initialize(void)\n{\n    FILE *              fp;\n    char                buffer[32];\n    pthread_mutexattr_t mutex_attr;\n    int                 status;\n\n    /*\n     * If not running as root, check /proc/sys/fs/mqueue/msg_max\n     *\n     * This special file represents the max depth of a POSIX message queue for an unprivileged user.\n     *\n     * In order to facilitate running in simulation mode without any need for root access --\n     * this will allow the OSAL to successfully create message queues by truncating anything larger than this size.\n     *\n     * No need to check _LINUX_OS_ here; if the file fails to open, i.e. if not on Linux and the file does not exist,\n     * then leave well enough alone and don't do anything.\n     */\n    if (geteuid() != 0)\n    {\n        fp = fopen(\"/proc/sys/fs/mqueue/msg_max\", \"r\");\n        if (fp)\n        {\n            if (fgets(buffer, sizeof(buffer), fp) != NULL)\n            {\n                OS_BSP_Global.MaxQueueDepth = OSAL_BLOCKCOUNT_C(strtoul(buffer, NULL, 10));\n                BSP_DEBUG(\"Maximum user msg queue depth = %u\\n\", (unsigned int)OS_BSP_Global.MaxQueueDepth);\n            }\n            fclose(fp);\n        }\n    }\n\n    /* Initialize the low level access mutex (w/priority inheritance) */\n    status = pthread_mutexattr_init(&mutex_attr);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutexattr_init: %s\\n\", strerror(status));\n    }\n    status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutexattr_setprotocol: %s\\n\", strerror(status));\n    }\n    status = pthread_mutex_init(&OS_BSP_GenericLinuxGlobal.AccessMutex, &mutex_attr);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_init: %s\\n\", strerror(status));\n    }\n}\n```\n</target_code>\nJudge whether the above OS_BSP_Initialize code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The code contains a branch that opens and reads from the file '/proc/sys/fs/mqueue/msg_max' only if 'geteuid() != 0'. If this condition is false (i.e., the process runs as root), the branch is skipped, and no other code in the function is executed, leaving the function effectively doing nothing. If the opening of the file failed or was not attempted, no side effects or behaviors occur, and the function still completes without performing any action. This means the code section that reads the message queue size could be unexecuted during runtime, and if the program logic does not require this operation to always run, the code might be considered dead. Considering the comments, the operation is necessary only for non-root users, and in some configurations, this code might not be executed at all. Therefore, the branch for reading the file can be considered dead code under certain configurations, especially if the condition is never true or the file always fails to open.",
  "test_code": "void OS_BSP_Initialize(void)\n{\n    FILE *              fp;\n    char                buffer[32];\n    pthread_mutexattr_t mutex_attr;\n    int                 status;\n\n    /* Log the start of initialization process */\n    FILE *log_fp = fopen(\"/tmp/logs/146.txt\", \"a\");\n    if (log_fp) {\n        fprintf(log_fp, \"Starting OS_BSP_Initialize\\n\");\n    }\n\n    if (geteuid() != 0)\n    {\n        fp = fopen(\"/proc/sys/fs/mqueue/msg_max\", \"r\");\n        if (fp)\n        {\n            if (fgets(buffer, sizeof(buffer), fp) != NULL)\n            {\n                OS_BSP_Global.MaxQueueDepth = OSAL_BLOCKCOUNT_C(strtoul(buffer, NULL, 10));\n                if (log_fp) {\n                    fprintf(log_fp, \"Maximum user msg queue depth set to %u\\n\", (unsigned int)OS_BSP_Global.MaxQueueDepth);\n                }\n            }\n            fclose(fp);\n        } else {\n            if (log_fp) {\n                fprintf(log_fp, \"Failed to open message queue max file\\n\");\n            }\n        }\n    } else {\n        if (log_fp) {\n            fprintf(log_fp, \"Running as root, skipping message max file check\\n\");\n        }\n    }\n\n    /* Initialize the low level access mutex (w/priority inheritance) */\n    status = pthread_mutexattr_init(&mutex_attr);\n    if (status < 0)\n    {\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutexattr_init: %s\\n\", strerror(status));\n        }\n    }\n    status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n    if (status < 0)\n    {\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutexattr_setprotocol: %s\\n\", strerror(status));\n        }\n    }\n    status = pthread_mutex_init(&OS_BSP_Global.AccessMutex, &mutex_attr);\n    if (status < 0)\n    {\n        if (log_fp) {\n            fprintf(log_fp, \"pthread_mutex_init: %s\\n\", strerror(status));\n        }\n    }\n    if (log_fp) {\n        fprintf(log_fp, \"OS_BSP_Initialize completed\\n\");\n        fclose(log_fp);\n    }\n}\n"
}