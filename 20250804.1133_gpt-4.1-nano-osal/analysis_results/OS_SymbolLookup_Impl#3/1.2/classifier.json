{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_SymbolLookup_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/24.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_SymbolLookup_Impl as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_SymbolLookup_Impl:\n```c\nint32 OS_SymbolLookup_Impl(cpuaddr *SymbolAddress, const char *SymbolName)\n{\n    int32            status;\n    int32            local_status;\n    OS_object_iter_t iter;\n\n    /* First search global table */\n    status = OS_GenericSymbolLookup_Impl(OSAL_DLSYM_DEFAULT_HANDLE, SymbolAddress, SymbolName);\n\n    /* If not found iterate through module local symbols and break if found */\n    if (status != OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(OS_OBJECT_TYPE_OS_MODULE, &iter);\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            local_status = OS_ModuleSymbolLookup_Impl(&iter.token, SymbolAddress, SymbolName);\n            if (local_status == OS_SUCCESS)\n            {\n                status = local_status;\n                break;\n            }\n        }\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return status;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SymbolLookup_Impl:\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n</additional code>\nJudge whether the above OS_SymbolLookup_Impl code violates the rule 1.2 or not.",
  "is_rule_violated": false,
  "scenario": "The code does not use any language extensions explicitly stated as extensions in compiler documentation, such as pragma directives or compiler-specific keywords.",
  "test_code": ""
}