{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code contains an assignment to 'ret' with MHD_YES which is then immediately overwritten with MHD_NO if digest_ext_error(&da) returns true. Since digest_ext_error(da) is defined as always false via macro, the conditional block is never executed and the assignment to ret = MHD_NO in that block constitutes dead code, as its removal would not affect program behaviour.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  FILE *log_fp = fopen(\"/tmp/logs/586.txt\", \"a\");\n  if (log_fp == NULL)\n    return MHD_NO; /* Unable to open log, fail safely */\n\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    fprintf(log_fp, \"digest_init_one_time failed\\n\");\n    fclose(log_fp);\n    return MHD_NO;\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n  {\n    fprintf(log_fp, \"Buffer size insufficient: %lu needed, %lu provided\\n\",\n            (unsigned long)digest_get_size(&da), (unsigned long)bin_buf_size);\n    ret = MHD_NO;\n  }\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n    fprintf(log_fp, \"Assigned ret = MHD_YES\\n\");\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      ret = MHD_NO;  /* Dead code: never executed since digest_ext_error always false */\n      fprintf(log_fp, \"Assigned ret = MHD_NO inside digest_ext_error block\\n\");\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  fprintf(log_fp, \"Returning ret = %d\\n\", ret);\n  fclose(log_fp);\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation claims that the assignment 'ret = MHD_NO;' inside the 'if (digest_ext_error(&da))' block constitutes dead code because 'digest_ext_error(&da)' is always false, making this block never executed. If 'digest_ext_error' is indeed always false via macro definition, then the code inside that conditional (including 'ret = MHD_NO;') will never execute, but as noted in MISRA C 2023 Rule 2.2, unreachable code is not necessarily dead code. However, this is a different case: the code is reachable, but the condition is always false, so that code behaves as dead code, because its removal would not affect the behavior.\n\nHowever, this assumption depends entirely on 'digest_ext_error' definition and whether 'MHD_DIGEST_HAS_EXT_ERROR' is defined. If 'MHD_DIGEST_HAS_EXT_ERROR' is not defined, the conditional block is excluded from compilation, making the assignment simply not present. If macro defines it but 'digest_ext_error' always returns false, then the code block is present but never executed.\n\nMoreover, rule 2.2 clarifies that initialization is not dead code, but any operation executed yet removable without effect is dead code. Here, since the assignment is inside a false-condition block, it is never executed, thus must be considered unreachable code rather than dead code.\n\nSince the condition is always false, the code inside is unreachable code, not dead code. The note specifically says unreachable code is not dead code. Therefore, the assignment is unreachable, not dead code.\n\nHence, Agent A's claim that this code violates Rule 2.2 because of dead code is incorrect, as the code is unreachable, not dead code. Moreover, the failure to compile the test code indicates incomplete or improper testing of the hypothesis.\n\nIn conclusion, Agent A's report that this code violates MISRA Rule 2.2 due to dead code is not correct; the code in question is unreachable, not dead code, and does not violate Rule 2.2."
}