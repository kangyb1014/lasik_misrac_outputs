{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the username or realm strings are not properly null-terminated or their lengths provided by strlen are incorrect, passing these lengths to digest_update in calc_userdigest could cause string handling functions within digest_update to access memory beyond the bounds of the given strings, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nextern bool digest_init_one_time (struct DigestAlgorithm *da, enum MHD_DigestBaseAlgo algo);\nextern void digest_deinit (struct DigestAlgorithm *da);\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  FILE *log_file = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log_file == NULL) {\n    /* If log file can't be opened, proceed silently */\n  }\n\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (log_file) fprintf(log_file, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (log_file) fprintf(log_file, \"digest_init_one_time() failed\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_NO;\n  }\n\n  unsigned int needed_size = digest_get_size (&da);\n  if (log_file) fprintf(log_file, \"digest_get_size() returned %u, buffer size %zu\\n\", needed_size, bin_buf_size);\n\n  if (needed_size > bin_buf_size)\n  {\n    ret = MHD_NO;\n    if (log_file) fprintf(log_file, \"Buffer too small for digest - violation scenario\\n\");\n  }\n  else\n  {\n    /* Log lengths of username and realm strings - suspicious if lengths too large */\n    size_t username_len = strlen(username);\n    size_t realm_len = strlen(realm);\n    if (log_file) fprintf(log_file, \"Username length: %zu, Realm length: %zu\\n\", username_len, realm_len);\n\n    /* Potential violation if username_len or realm_len exceed actual allocated buffer sizes */\n\n    calc_userdigest (&da, username, username_len, realm, realm_len, password, userdigest_bin);\n\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      ret = MHD_NO;\n      if (log_file) fprintf(log_file, \"digest_ext_error triggered after calc_userdigest\\n\");\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n\n  digest_deinit (&da);\n\n  if (log_file) fprintf(log_file, \"Exiting MHD_digest_auth_calc_userdigest with result: %d\\n\", ret);\n  if (log_file) fclose(log_file);\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 mandates that the usage of string handling functions from <string.h> must not lead to accesses beyond the bounds of the pointed-to objects. The reported violation scenario hinges on the possibility that the input strings 'username' and 'realm' are not properly null-terminated, causing strlen to return incorrect lengths. These incorrect lengths are then passed to 'calc_userdigest', which likely uses string handling functions internally. If 'username' or 'realm' are malformed, this could indeed lead to out-of-bounds memory access inside 'calc_userdigest'. However, it is important to note that the root cause resides outside the function 'MHD_digest_auth_calc_userdigest' itself, namely in how the caller provides the string parameters. The function assumes the contract that 'username' and 'realm' point to valid null-terminated strings, as is typical in C string APIs. The function itself correctly uses strlen to obtain lengths and checks buffer sizes for the output buffer 'userdigest_bin'. The code does not use <string.h> functions on the input strings beyond these proper length calculations. Therefore, within the scope of this function, there is no direct violation of Rule 21.17. The potential violation arises only if the API contract is violated by the caller, which is not a fault of this code snippet. Given that the function defensively checks output buffer size and uses lengths obtained via strlen in a standard manner, the agent A's report is not a direct violation of MISRA C 2023 Rule 21.17 concerning this function's code. The test code cannot compile, and thus no runtime evidence can be produced, which also limits the demonstration of the violation. In conclusion, the concern is valid from an application safety standpoint but does not reflect a direct MISRA 21.17 violation in this code."
}