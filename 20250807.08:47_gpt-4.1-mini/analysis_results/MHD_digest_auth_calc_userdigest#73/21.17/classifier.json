{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_digest_auth_calc_userdigest code that contains useful probe functions that print useful logs to a file \"/tmp/logs/591.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_digest_auth_calc_userdigest as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_calc_userdigest:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_digest_auth_calc_userdigest:\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n...\n_MHD_static_inline enum MHD_DigestBaseAlgo\nget_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3)\n{\n  unsigned int base_algo;\n\n  base_algo =\n    ((unsigned int) algo3)\n    & ~((unsigned int)\n        (MHD_DIGEST_AUTH_ALGO3_NON_SESSION\n         | MHD_DIGEST_AUTH_ALGO3_NON_SESSION));\n  return (enum MHD_DigestBaseAlgo) base_algo;\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n</additional code>\nJudge whether the above MHD_digest_auth_calc_userdigest code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If the username or realm strings are not properly null-terminated or their lengths provided by strlen are incorrect, passing these lengths to digest_update in calc_userdigest could cause string handling functions within digest_update to access memory beyond the bounds of the given strings, violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n/* Assuming these types and enums are defined elsewhere as in original code */\n\nstruct DigestAlgorithm {\n#ifdef _DEBUG\n  bool uninitialised;\n  bool algo_selected;\n  bool ready_for_hashing;\n  bool hashing;\n#endif\n  int algo;\n  union {\n    // dummy context structs\n    char md5_ctx[1];\n    char sha256_ctx[1];\n    char sha512_256_ctx[1];\n  } ctx;\n};\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\nenum MHD_DigestBaseAlgo { MHD_DIGEST_BASE_ALGO_MD5 = 1, MHD_DIGEST_BASE_ALGO_SHA256 = 2, MHD_DIGEST_BASE_ALGO_SHA512_256 = 3, MHD_DIGEST_BASE_ALGO_INVALID = 0 };\nenum MHD_DigestAuthAlgo3 { MHD_DIGEST_AUTH_ALGO3_MD5 = 1, MHD_DIGEST_AUTH_ALGO3_SHA256 = 2, MHD_DIGEST_AUTH_ALGO3_SHA512_256 =3 };\n\nextern bool digest_init_one_time (struct DigestAlgorithm *da, enum MHD_DigestBaseAlgo algo);\nextern enum MHD_DigestBaseAlgo get_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3);\nextern unsigned int digest_get_size (struct DigestAlgorithm *da);\nextern void calc_userdigest (struct DigestAlgorithm *da, const char *username, const size_t username_len,\n                            const char *realm, const size_t realm_len, const char *password, uint8_t *ha1_bin);\nextern void digest_deinit (struct DigestAlgorithm *da);\n\n/* Modified function with logging */\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  FILE *log_file = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (log_file == NULL) {\n    /* If log file can't be opened, proceed silently */\n  }\n\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (log_file) fprintf(log_file, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (log_file) fprintf(log_file, \"digest_init_one_time() failed\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_NO;\n  }\n\n  unsigned int needed_size = digest_get_size (&da);\n  if (log_file) fprintf(log_file, \"digest_get_size() returned %u, buffer size %zu\\n\", needed_size, bin_buf_size);\n\n  if (needed_size > bin_buf_size)\n  {\n    ret = MHD_NO;\n    if (log_file) fprintf(log_file, \"Buffer too small for digest - violation scenario\\n\");\n  }\n  else\n  {\n    /* Log lengths of username and realm strings - suspicious if lengths too large */\n    size_t username_len = strlen(username);\n    size_t realm_len = strlen(realm);\n    if (log_file) fprintf(log_file, \"Username length: %zu, Realm length: %zu\\n\", username_len, realm_len);\n\n    /* Potential violation if username_len or realm_len exceed actual allocated buffer sizes */\n\n    calc_userdigest (&da, username, username_len, realm, realm_len, password, userdigest_bin);\n\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      ret = MHD_NO;\n      if (log_file) fprintf(log_file, \"digest_ext_error triggered after calc_userdigest\\n\");\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n\n  digest_deinit (&da);\n\n  if (log_file) fprintf(log_file, \"Exiting MHD_digest_auth_calc_userdigest with result: %d\\n\", ret);\n  if (log_file) fclose(log_file);\n\n  return ret;\n}\n"
}