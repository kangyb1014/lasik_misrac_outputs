{
  "user_message": "An agent A claimed that the following MHD_polling_thread code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_polling_thread.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function MHD_polling_thread uses the identifiers MHD_THRD_RTRN_TYPE_ and MHD_THRD_CALL_SPEC_ which are likely macros defined to specify return type and calling convention for threads. These macros may be compiler-specific extensions (e.g., __stdcall, __attribute__ syntax), representing language extensions that are not part of standard C language. If these macros expand to compiler-specific keywords or attributes (as commonly done for threaded functions), then this usage violates MISRA C 2023 Rule 1.2 which prohibits language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <string.h>\n#include <pthread.h>\n\nstruct MHD_Daemon\n{\n    bool shutdown;\n    bool sigpipe_blocked;\n    int options;\n    int tid;\n};\n\nvoid MHD_thread_handle_ID_set_current_thread_ID_(int *id_ptr)\n{\n    /* For demonstration, just assign an ID */\n    *id_ptr = 123;\n}\n\nvoid MHD_DLOG(const struct MHD_Daemon *daemon, const char *format, ...)\n{\n    (void)daemon; // unused parameter\n    va_list args;\n    va_start(args, format);\n    vfprintf(stderr, format, args);\n    va_end(args);\n}\n\nint MHD_polling_thread(void *cls)\n{\n    struct MHD_Daemon *daemon = (struct MHD_Daemon *)cls;\n\n    MHD_thread_handle_ID_set_current_thread_ID_(&(daemon->tid));\n\n#if defined(SIGPIPE)\n    {\n        sigset_t s_mask;\n        int err;\n\n        if ((sigemptyset(&s_mask) == 0) && (sigaddset(&s_mask, SIGPIPE) == 0))\n        {\n            err = pthread_sigmask(SIG_BLOCK, &s_mask, NULL);\n        }\n        else\n        {\n            err = errno;\n        }\n\n        if (err == 0)\n        {\n            daemon->sigpipe_blocked = true;\n        }\n        else\n        {\n            MHD_DLOG(daemon, \"Failed to block SIGPIPE on daemon thread: %s\\n\", strerror(err));\n        }\n    }\n#endif\n\n    while (!daemon->shutdown)\n    {\n        // Polling logic omitted intentionally\n\n        break; // avoid infinite loop in demonstration\n    }\n\n    return 0;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The MISRA C 2023 Rule 1.2 states that language extensions should not be used unless explicitly noted and allowed. The identifiers MHD_THRD_RTRN_TYPE_ and MHD_THRD_CALL_SPEC_ in the code sample are macros, likely defined to specify thread function return type and calling convention. Such macros commonly alias compiler-specific keywords or attributes (e.g., __stdcall, __attribute__((stdcall)), or other calling convention specifiers) that are language extensions beyond standard C. Since these macros are used to enable specific calling conventions or thread return types that are not part of standard C, their use amounts to language extensions as per the rule. Unless those macros are strictly defined as standard compliant and not relying on compiler-specific extensions, their presence constitutes a violation of Rule 1.2. The provided test code omits use of these macros and thus does not demonstrate otherwise. Therefore, the reasoning by agent A is valid and the report is correct."
}