{
  "user_message": "An agent A claimed that the following MHD_send_data_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_data_.\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The MHD_send_data_ function contains an ifdef section for HTTPS_SUPPORT where an inner ifdef block checks and handles various error cases after a call to gnutls_record_send. Under the !HTTPS_SUPPORT branch inside the tls_conn condition, the code just assigns ret = MHD_ERR_NOTCONN_; but there is no subsequent code using ret in that branch within the #else block. This assignment is executed but has no effect on the program behavior, as it is overwritten or leads to no effect afterwards. Thus, this constitutes dead code as per MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nint gnutls_record_send(void *tls_session, const char *buffer, size_t buffer_size) {\n    (void) tls_session;\n    (void) buffer;\n    (void) buffer_size;\n    return 42; /* pretend success */\n}\n\nvoid pre_send_setopt(struct MHD_Connection *connection, bool plain_send, bool push_data) {\n    FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"pre_send_setopt called: plain_send=%d, push_data=%d\\n\", plain_send, push_data);\n        fclose(f);\n    }\n}\nvoid post_send_setopt(struct MHD_Connection *connection, bool plain_send_next, bool push_data) {\n    FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"post_send_setopt called: plain_send_next=%d, push_data=%d\\n\", plain_send_next, push_data);\n        fclose(f);\n    }\n}\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n    int s = connection->socket_fd;\n    ssize_t ret;\n#ifdef HTTPS_SUPPORT\n    const bool tls_conn = (connection->daemon->options & MHD_USE_TLS) != 0;\n#else\n    const bool tls_conn = false;\n#endif\n\n    FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"Function entered with socket_fd=%d, state=%d, buffer_size=%zu, push_data=%d, tls_conn=%d\\n\",\n                s, connection->state, buffer_size, push_data, tls_conn);\n        fclose(f);\n    }\n\n    if ( (MHD_INVALID_SOCKET == s) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n    {\n        return MHD_ERR_NOTCONN_;\n    }\n\n    if (buffer_size > SSIZE_MAX)\n    {\n        buffer_size = SSIZE_MAX;\n        push_data = false;\n    }\n\n    if (tls_conn)\n    {\n#ifdef HTTPS_SUPPORT\n        pre_send_setopt(connection, !tls_conn, push_data);\n        ret = gnutls_record_send(connection->tls_session, buffer, buffer_size);\n        if (ret == 42) {\n            FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n            if (f) {\n                fprintf(f, \"gnutls_record_send returned success\\n\");\n                fclose(f);\n            }\n        }\n        if (GNUTLS_E_AGAIN == ret) {\n#ifdef EPOLL_SUPPORT\n            connection->epoll_state &= ~((int)0x01);\n#endif\n            return MHD_ERR_AGAIN_;\n        }\n        /* Error handling conditions omitted for brevity */\n#else\n        /* This block is not compiled since HTTPS_SUPPORT is not defined */\n        ret = MHD_ERR_NOTCONN_;\n#endif\n    }\n    else\n    {\n        /* plaintext transmission (omitted for brevity) */\n        ret = (ssize_t)buffer_size; /* pretend success */\n    }\n\n    if ((push_data) && (buffer_size == (size_t)ret)) {\n        post_send_setopt(connection, !tls_conn, push_data);\n    }\n\n    FILE *f2 = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f2) {\n        fprintf(f2, \"Function returning ret=%zd\\n\", ret);\n        fclose(f2);\n    }\n\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A's report claims a violation of MISRA C 2023 Rule 2.2 on the basis that within the tls_conn true branch but !HTTPS_SUPPORT else block, the assignment ret = MHD_ERR_NOTCONN_; is executed but its value is never used afterwards, hence constituting dead code. However, examining the provided code, the tls_conn boolean is defined as false when HTTPS_SUPPORT is not defined, due to the preprocessor conditional setting tls_conn false in the non-HTTPS_SUPPORT case. Therefore, when HTTPS_SUPPORT is not defined, the tls_conn condition is false, and the entire if (tls_conn) block (including the else for !HTTPS_SUPPORT) won't be executed at all. The else block of if(tls_conn) (plaintext transmission) executes instead, and the assignment ret = MHD_ERR_NOTCONN_; inside the #else of HTTPS_SUPPORT inside if(tls_conn) is effectively unreachable code with the given defines. According to note 2 in the MISRA rule text, unreachable code is not dead code. Dead code is code that is executed but whose removal does not affect the program behavior. Since this code is unreachable, it does not violate Rule 2.2. Hence the report is incorrect. The test code provided by the agent also fails to compile due to the same confusing conditional compilation and wrong assumptions about tls_conn and HTTPS_SUPPORT macros. In conclusion, the assigned statement for ret inside #else !HTTPS_SUPPORT inside if(tls_conn) is unreachable, not dead code, and therefore does not violate MISRA C 2023 Rule 2.2."
}