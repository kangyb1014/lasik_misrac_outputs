{
  "user_message": "An agent A claimed that the following MHD_send_data_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_data_.\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Usage of GNU extension in MHD_send4_ macro: the flag MSG_NOSIGNAL_OR_ZERO may be defined as MSG_NOSIGNAL flag, which is GNU/Linux specific and a compiler/library extension beyond standard C. This usage implies language/compiler extensions are used in the code, violating MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nssize_t MHD_send_data_ (struct MHD_Connection *connection,\n                        const char *buffer,\n                        size_t buffer_size,\n                        int push_data)  // Changed bool to int since bool may require including <stdbool.h>\n{\n    FILE *log = fopen(\"/tmp/logs/360.txt\", \"a\");\n    if (!log) return -1;\n\n    fprintf(log, \"Entering MHD_send_data_ with socket_fd=%d, buffer_size=%zu, push_data=%d\\n\",\n            connection->socket_fd, buffer_size, push_data);\n\n    int s = connection->socket_fd;\n    ssize_t ret;\n\n#ifdef HTTPS_SUPPORT\n    const int tls_conn = (connection->daemon->options & MHD_USE_TLS) != 0;\n#else\n    const int tls_conn = 0;\n#endif\n\n    if ((MHD_INVALID_SOCKET == s) || (MHD_CONNECTION_CLOSED == connection->state))\n    {\n        fprintf(log, \"Socket invalid or connection closed\\n\");\n        fclose(log);\n        return MHD_ERR_NOTCONN_;\n    }\n\n    if (buffer_size > SSIZE_MAX)\n    {\n        buffer_size = SSIZE_MAX;\n        push_data = 0;\n        fprintf(log, \"Buffer size clipped to SSIZE_MAX, push_data set to false\\n\");\n    }\n\n    if (!tls_conn)\n    {\n        if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n        {\n            buffer_size = MHD_SCKT_SEND_MAX_SIZE_;\n            push_data = 0;\n            fprintf(log, \"Buffer size clipped to MHD_SCKT_SEND_MAX_SIZE_, push_data set to false\\n\");\n        }\n\n        // Probe output before send\n        fprintf(log, \"Calling MHD_send4_ with flags including MSG_NOSIGNAL: 0x%x\\n\", MSG_NOSIGNAL_OR_ZERO);\n\n        ret = MHD_send4_(s, buffer, buffer_size, push_data ? 0 : MSG_MORE);\n\n        if (ret < 0)\n        {\n            int err = errno;\n            fprintf(log, \"send() failed with errno=%d\\n\", err);\n            fclose(log);\n            return -1; // Simplified error handling\n        }\n        fprintf(log, \"send() succeeded, returned %zd\\n\", ret);\n    }\n    else\n    {\n        fprintf(log, \"TLS connection not handled in this probe code\\n\");\n        ret = -1;\n    }\n\n    fclose(log);\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 prohibits the use of compiler or language extensions beyond standard C that are explicitly documented as such by the compiler vendor. In the given code, the agent A alleges that usage of the GNU/Linux-specific flag MSG_NOSIGNAL (or a related macro) via the MHD_send4_ macro represents such a language extension, thus violating Rule 1.2. However, the provided code snippet does not explicitly use MSG_NOSIGNAL; it conditionally includes MSG_MORE or 0, and the MHD_send4_ macro is assumed to be a wrapper around a socket send call. Additionally, MSG_NOSIGNAL is a POSIX/Linux socket flag, which can be considered a platform-specific extension, but POSIX APIs are often allowed under MISRA as part of the target platform's standard libraries. The MISRA guideline allows platform-specific APIs if they are documented and carefully considered. Furthermore, the user's test code failed to compile likely due to missing definitions or environment setup, not conclusively proving the presence of a language extension in the original code. The original code does not explicitly include or utilize GNU extensions or non-standard language constructs; it primarily uses conditional compilation and platform-dependent macros. Therefore, the claim that the code violates MISRA Rule 1.2 solely because of indirect usage of potentially non-standard flags is not sufficiently supported. Hence, the report by agent A is not correct."
}