{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses function pointer casts to (void *) when obtaining the addresses of Windows API functions via GetProcAddress, which may be considered a compiler language extension depending on the compiler's documentation (strictly, the C standard does not guarantee conversion between data and function pointers). Usage of such casting to (void *) is often an extension recognized by certain compilers such as MSVC.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  FILE *log_file = fopen(\"/tmp/logs/256.txt\", \"a\");\n  if (log_file == NULL)\n  {\n    return -1;\n  }\n\n  fprintf(log_file, \"Entering mhd_tool_get_proc_cpu_count\\n\");\n\n#if defined(__linux__) || defined(__GLIBC__)\n  fprintf(log_file, \"Using linux/glibc affinity APIs\\n\");\n  int res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  fprintf(log_file, \"sched_getaffinity result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from sched_getaffinity path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  fprintf(log_file, \"cpuset_getaffinity result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from cpuset_getaffinity path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n#else  /* ! __linux__ && ! __GLIBC__ */\n  fprintf(log_file, \"Using non-linux/glibc affinity APIs\\n\");\n  int res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  fprintf(log_file, \"cpuset_getaffinity result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from cpuset_getaffinity path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  fprintf(log_file, \"sched_getaffinity result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from sched_getaffinity path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  fprintf(log_file, \"sched_getaffinity_np result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from sched_getaffinity_np path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  fprintf(log_file, \"w32 result: %d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning %d from w32 path\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  fprintf(log_file, \"All methods failed, returning -1\\n\");\n  fclose(log_file);\n  return -1;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The code provided for the function `mhd_tool_get_proc_cpu_count` itself does not contain any explicit language extensions such as casting between function pointers and `void *` or other compiler-specific extensions. The scenario described by agent A refers to usage of function pointer casts to `(void *)` in calls to `GetProcAddress` when obtaining Windows API function addresses, which are not present in the shown function code. Therefore, no direct evidence shows that this particular code violates MISRA C 2023 Rule 1.2 from the provided snippet. The test code which adds logging also does not contain such language extensions. Given this, the report that this code violates Rule 1.2 due to language extensions is incorrect based on the code samples provided. Unless other unseen parts of the codebase contain such extensions, the claim is not supported here."
}