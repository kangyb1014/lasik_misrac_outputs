{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code contains a block of code within an #if 0 preprocessor directive that declares and initializes a const char *password field inside struct UserEntry which is disabled (dead) code. This disabled code is never compiled or executed, representing dead code in the project.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_DigestAuthAlgo3 { MHD_DIGEST_AUTH_ALGO3_MD5, MHD_DIGEST_AUTH_ALGO3_SHA256, MHD_DIGEST_AUTH_ALGO3_SHA512_256 };\nenum MHD_Result MHD_digest_auth_calc_userhash(enum MHD_DigestAuthAlgo3 algo,\n                                               const char *username,\n                                               const char *realm,\n                                               unsigned char *buffer,\n                                               size_t buffer_len) {\n    /* Fake filling buffer with zero */\n    memset(buffer, 0, buffer_len);\n    return MHD_YES;\n}\nenum MHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo,\n                                                 const char *username,\n                                                 const char *realm,\n                                                 const char *password,\n                                                 unsigned char *buffer,\n                                                 size_t buffer_len) {\n    /* Fake filling buffer with zero */\n    memset(buffer, 0, buffer_len);\n    return MHD_YES;\n}\nvoid log_to_file(const char *msg)\n{\n    FILE *fp = fopen(\"/tmp/logs/354.txt\", \"a\");\n    if(fp != NULL) {\n        fputs(msg, fp);\n        fclose(fp);\n    }\n}\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  char logbuf[256];\n\n  snprintf(logbuf, sizeof(logbuf), \"Function add_new_user_entry called with username=%s, password=%s, realm=%s\\n\", username, password, realm);\n  log_to_file(logbuf);\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    log_to_file(\"No more space to add new entry\\n\");\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating MD5 userhash\\n\");\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  }\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating MD5 userdigest\\n\");\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n  }\n\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating SHA256 userhash\\n\");\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  }\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating SHA256 userdigest\\n\");\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n  }\n\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating SHA512_256 userhash\\n\");\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  }\n  if (MHD_NO != res) {\n    log_to_file(\"Calculating SHA512_256 userdigest\\n\");\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha512_256,\n                                           sizeof(entry->userdigest_sha512_256));\n  }\n\n  if (MHD_NO == res) {\n    log_to_file(\"Authentication calculation failed\\n\");\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  log_to_file(\"New user entry added successfully\\n\");\n\n  return ! 0;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation scenario claims that the project contains dead code in the form of code inside an #if 0 preprocessor block that declares a const char *password field inside struct UserEntry. However, the provided code snippet for the function add_new_user_entry does not contain any such #if 0 disabled code or unused code blocks. The function code itself is fully active and relevant, no statements or assignments in it are redundant or can be removed without changing program behavior. According to MISRA C 2023 Rule 2.2, dead code is code that is executed but whose removal would have no effect on program behavior. Disabled code within #if 0 is not included in the project and is effectively discarded by the preprocessor, so it does not constitute dead code within the compiled project. Given also that the test code provided by agent A fails to compile and no actual evidence of dead code within the compiled project was demonstrated, the claim that add_new_user_entry violates Rule 2.2 is not substantiated. Therefore, the report by agent A is incorrect regarding this function and this rule."
}