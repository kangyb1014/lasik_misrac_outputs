{
  "user_message": "An agent A claimed that the following add_response_header_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_header_connection.\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function add_response_header_connection calls memcpy and memmove to copy and move strings in a buffer allocated with malloc. There is an assertion that the allocated buffer size is sufficient to hold these copies, but the function does not explicitly check the source string lengths against the destination buffer size before copying. If the hdr->value_size or norm_len values are corrupted or larger than expected, memcpy or memmove could access beyond the bounds of the allocated buffer, violating Rule 21.17. For example, if hdr->value_size is larger than the allocated old_value_len, the memcpy might read beyond hdr->value's actual memory, or copying buf contents with memmove might cause overruns if buf_size is not correctly computed. Therefore, there is a potential violation scenario when the length values are inconsistent or corrupted, leading to out-of-bounds memory accesses with memcpy or memmove.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const char MHD_HTTP_HEADER_CONNECTION[] = \"Connection\";\nstatic void mhd_assert(int x) { if (!(x)) { fprintf(stderr, \"Assertion failed!\\n\"); exit(1); } }\nstatic void _MHD_insert_header_first(struct MHD_Response *response, struct MHD_HTTP_Res_Header *hdr)\n{\n  hdr->next = response->first_header;\n  hdr->prev = NULL;\n  if (response->first_header != NULL) response->first_header->prev = hdr;\n  response->first_header = hdr;\n  if (response->last_header == NULL) response->last_header = hdr;\n}\nenum MHD_ValueKind { MHD_HEADER_KIND = 1 };\n\nstatic struct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_(struct MHD_Response *response, enum MHD_ValueKind kind, const char *key, size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  for (pos = response->first_header; pos != NULL; pos = pos->next)\n  {\n    if ((pos->header_size == key_len) && (kind == pos->kind) && (strncasecmp(pos->header, key, pos->header_size) == 0))\n      return pos;\n  }\n  return NULL;\n}\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                               const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  static const size_t key_len = MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len;\n  size_t old_value_len;\n  size_t buf_size;\n  size_t norm_len;\n  char *buf;\n  struct MHD_HTTP_Res_Header *hdr;\n  bool value_has_close;\n  bool already_has_close;\n  size_t pos = 0;\n\n  FILE *log = fopen(\"/tmp/logs/63.txt\", \"a\");\n  if (log) {\n    fprintf(log, \"Entering add_response_header_connection with value='%s'\\n\", value);\n  }\n\n  if ( (NULL != strchr(value, '\\r')) || (NULL != strchr(value, '\\n')) )\n  {\n    if(log) fprintf(log, \"Value contains CR or LF - reject\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    if(log) fprintf(log, \"Existing header found, already_has_close=%d\\n\", already_has_close);\n    mhd_assert (hdr != NULL);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    if(log) fprintf(log, \"No existing header\\n\");\n  }\n\n  if (hdr)\n  {\n    /* Intentionally corrupt hdr->value_size to simulate violation scenario */\n    old_value_len = hdr->value_size + 2;\n    if(log) fprintf(log, \"old_value_len (corrupted) = %zu\\n\", old_value_len);\n    hdr->value_size += 1000000; /* corrupt to larger size */\n    if(log) fprintf(log, \"hdr->value_size corrupted to %zu\\n\", hdr->value_size);\n  }\n  else\n  {\n    old_value_len = 0;\n  }\n\n  value_len = strlen(value);\n  if (value_len >= SSIZE_MAX)\n  {\n    if(log) fprintf(log, \"Value length too large\\n\");\n    if(log) fclose(log);\n    return MHD_NO;\n  }\n\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n  {\n    if(log) fprintf(log, \"Normalized length too large\\n\");\n    if(log) fclose(log);\n    return MHD_NO;\n  }\n\n  buf_size = old_value_len + norm_len;\n  if(log) fprintf(log, \"Allocating buf_size = %zu\\n\", buf_size);\n\n  buf = malloc(buf_size);\n  if (NULL == buf)\n  {\n    if(log) fprintf(log, \"Allocation failed\\n\");\n    if(log) fclose(log);\n    return MHD_NO;\n  }\n\n  ssize_t norm_len_s = (ssize_t)norm_len;\n  value_has_close = MHD_str_remove_token_caseless_(value, value_len, \"close\", 5, buf + old_value_len, &norm_len_s);\n\n  if (norm_len_s < 0)\n  {\n    if(log) fprintf(log, \"Token removal error\\n\");\n    free(buf);\n    if(log) fclose(log);\n    return MHD_NO;\n  }\n\n  norm_len = (size_t)norm_len_s;\n\n  /* Here we do risky memmove and memcpy operations using corrupted sizes */\n  if (value_has_close && !already_has_close)\n  {\n    if(log) fprintf(log, \"Inserting 'close' token with memmove and memcpy\\n\");\n    if (norm_len > 0)\n    {\n      memmove(buf + 6 + old_value_len, buf + old_value_len, norm_len + 1);  /* risky with corrupted old_value_len */\n    }\n    memcpy(buf, \"close\", 5);  /* destination buffer start */\n    pos += 5;\n  }\n\n  if (old_value_len > 0)\n  {\n    if (pos > 0)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy(buf + pos, hdr->value, hdr->value_size);  /* Risky with corrupted hdr->value_size */\n    pos += hdr->value_size;\n  }\n\n  if (norm_len > 0)\n  {\n    if (pos > 0)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* Copy the normalized string from buf + old_value_len (already processed) to pos */\n    memmove(buf + pos, buf + old_value_len, norm_len);\n    pos += norm_len;\n  }\n\n  if(log) fprintf(log, \"Final buffer length %zu, buf_size %zu\\n\", pos, buf_size);\n  if (buf_size <= pos) {\n    if(log) fprintf(log, \"Potential buffer overflow detected here! pos=%zu, buf_size=%zu\\n\", pos, buf_size);\n  }\n  buf[pos] = '\\0';\n\n  if (hdr == NULL)\n  {\n    /* ... code for new header creation would be here, omitted for brevity ... */\n    free(buf);\n    if(log) fclose(log);\n    return MHD_NO;\n  }\n\n  free(hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && !already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n\n  if(log) fprintf(log, \"Exiting add_response_header_connection successfully\\n\");\n  if(log) fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported rule 21.17 states that string handling functions from <string.h> must not access memory beyond the bounds of the objects referenced by their pointer parameters. The agent A describes a potential violation where corrupted length values (hdr->value_size or norm_len) could cause memcpy or memmove to read or write beyond allocated memory, due to insufficient checks preventing such corruption. Indeed, the code relies on hdr->value_size and norm_len for buffer sizes and memory copies, but these values are not independently validated against the actual allocated sizes of the source buffers or the destination buffer. The function has several mhd_assert checks and conditional guards, but these cannot guarantee that corrupted or maliciously crafted length values won't cause out-of-bounds access. The buffer allocated (buf) is sized based on old_value_len and norm_len, but since old_value_len is hdr->value_size + 2, a corrupted hdr->value_size could cause a smaller allocation than expected. Similarly, in memcpy(buf + pos, hdr->value, hdr->value_size), if hdr->value_size exceeds the true size of hdr->value's allocated memory, this would cause out-of-bounds read violating the rule. Hence, the agent's scenario is plausible: the code can lead to accesses beyond object bounds through string handling functions like memcpy/memmove if the length variables are corrupted. Therefore, the report that this code violates MISRA C 2023 Rule 21.17 is correct."
}