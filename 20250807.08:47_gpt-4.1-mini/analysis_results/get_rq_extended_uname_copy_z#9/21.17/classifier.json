{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified get_rq_extended_uname_copy_z code that contains useful probe functions that print useful logs to a file \"/tmp/logs/79.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of get_rq_extended_uname_copy_z as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of get_rq_extended_uname_copy_z:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_extended_uname_copy_z:\nbool\nMHD_str_equal_caseless_bin_n_ (const char *const str1,\n                               const char *const str2,\n                               size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; ++i)\n  {\n    const char c1 = str1[i];\n    const char c2 = str2[i];\n    if (charsequalcaseless (c1, c2))\n      continue;\n    else\n      return 0;\n  }\n  return ! 0;\n}\n...\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n...\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  if (broken)\n    return 0;\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  if (buf_size >= pct_encoded_len)\n  {\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n          return 0;\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n            return 0;\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          decoded[w] = (char) out;\n        }\n      }\n      else\n        decoded[w] = chr;\n      ++r;\n      ++w;\n    }\n    return w;\n  }\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    if (w >= buf_size)\n      return 0;\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n        return 0;\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        if ((0 > h) || (0 > l))\n          return 0;\n        out =\n          (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)));\n        decoded[w] = (char) out;\n      }\n    }\n    else\n      decoded[w] = chr;\n    ++r;\n    ++w;\n  }\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n</additional code>\nJudge whether the above get_rq_extended_uname_copy_z code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If the buf_size provided to get_rq_extended_uname_copy_z is too small to hold the decoded percent-encoded string plus the terminating null character, then the code writes buf[w] = 0 without checking if w < buf_size, potentially writing beyond the buffer bounds, violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdbool.h>\n\n// Dummy definitions to support the test\n#define MHD_DAUTH_EXT_PARAM_MIN_LEN 5\n#define MHD_DAUTH_EXT_PARAM_PREFIX \"EXT=\"\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n\n// Simulate assert\n#define mhd_assert(x) do { if (!(x)) { fprintf(stderr, \"Assertion failed\\n\"); } } while(0)\n\n// Function prototype for printing logs\nstatic FILE *log_file = NULL;\nstatic void log_state(const char *msg)\n{\n    if (!log_file)\n        log_file = fopen(\"/tmp/logs/79.txt\", \"a\");\n    if (log_file) {\n        fprintf(log_file, \"%s\\n\", msg);\n        fflush(log_file);\n    }\n}\n\n\n// Minimal charsequalcaseless: only exact match (for simplicity)\nstatic bool charsequalcaseless(char a, char b) {\n    // Simplified to case sensitive for test\n    return a == b;\n}\n\nbool MHD_str_equal_caseless_bin_n_(const char *const str1,\n                                   const char *const str2,\n                                   size_t len)\n{\n    size_t i;\n    for (i = 0; i < len; ++i)\n    {\n        const char c1 = str1[i];\n        const char c2 = str2[i];\n        if (charsequalcaseless(c1, c2))\n            continue;\n        else\n            return 0;\n    }\n    return 1;\n}\n\nstatic int toxdigitvalue(char c)\n{\n    if ('0' <= c && c <= '9') return c - '0';\n    if ('A' <= c && c <= 'F') return c - 'A' + 10;\n    if ('a' <= c && c <= 'f') return c - 'a' + 10;\n    return -1;\n}\n\nsize_t MHD_str_pct_decode_strict_n_(const char *pct_encoded,\n                                   size_t pct_encoded_len,\n                                   char *decoded,\n                                   size_t buf_size)\n{\n    size_t r = 0;\n    size_t w = 0;\n\n    // Log decode start\n    log_state(\"Decode start: pct_encoded_len and buf_size check\");\n\n    // Intentionally simplified for testing buffer boundary\n    while (r < pct_encoded_len)\n    {\n        const char chr = pct_encoded[r];\n        if ('%' == chr)\n        {\n            if (2 > pct_encoded_len - r)\n                return 0;\n            else\n            {\n                const int h = toxdigitvalue(pct_encoded[r+1]);\n                const int l = toxdigitvalue(pct_encoded[r+2]);\n                if ((0 > h) || (0 > l))\n                    return 0;\n                if (w >= buf_size)\n                {\n                    log_state(\"Buffer too small during percent decode\");\n                    return 0;\n                }\n                decoded[w] = (char) ((h << 4) | l);\n                r += 3;\n                w++;\n                continue;\n            }\n        }\n        else\n        {\n            if (w >= buf_size)\n            {\n                log_state(\"Buffer too small during direct copy\");\n                return 0;\n            }\n            decoded[w] = chr;\n            r++;\n            w++;\n        }\n    }\n\n    log_state(\"Decode finished\");\n    return w;\n}\n\nstatic ssize_t get_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    log_state(\"Input string too long\");\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    log_state(\"Input too short for required prefix\");\n    return -1; /* Required prefix is missing */\n  }\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    log_state(\"Prefix mismatch\");\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n  }\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n\n  log_state(\"Scanning language tag\");\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      log_state(\"Wrong character in language tag\");\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n  }\n\n  if (r >= uname_ext_len)\n  {\n    log_state(\"End of language tag not found\");\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n\n  // Log decode start\n  log_state(\"Calling percent decode\");\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  \n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    log_state(\"Broken percent encoding detected\");\n    return -1; /* Broken percent encoding */\n  }\n\n  // Here is the potential violation:\n  // buf[w] = 0; // zero terminate the result without any check\n  char zero_terminate_msg[100];\n  if (w >= buf_size) {\n    snprintf(zero_terminate_msg, sizeof(zero_terminate_msg),\n             \"Potential buffer overflow: w (%zu) >= buf_size (%zu) when zero terminating\", w, buf_size);\n    log_state(zero_terminate_msg);\n    // Still do it to demonstrate violation\n  }\n  else {\n    log_state(\"Safe zero termination at buf[w]\");\n  }\n\n  buf[w] = 0; /* Zero terminate the result */\n\n  mhd_assert (SSIZE_MAX > w);\n\n  // Log final state\n  char final_msg[100];\n  snprintf(final_msg, sizeof(final_msg), \"Returning length: %zu\", w);\n  log_state(final_msg);\n\n  return (ssize_t) w;\n}\n"
}