{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count_cpuset_getaffinity_.\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses several identifiers and functions such as cpuset_getaffinity, CPU_ALLOC, CPU_FREE, CPU_ALLOC_SIZE which are system or compiler-specific extensions related to CPU affinity APIs provided by some operating systems (e.g., FreeBSD). These APIs are not part of standard C and are considered language or platform extensions. Hence, the usage of these functions violates MISRA C 2023 Rule 1.2, which forbids language extensions explicitly documented as compiler or platform extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (ret <= 0)\n  {\n    cpuset_t cur_mask;\n    /* Log: attempting to get anonymous mask\n       The anonymous mask is always a subset of the assigned set (subset of root set). */\n    FILE *log_file = fopen(\"/tmp/logs/136.txt\", \"a\");\n    if (log_file != NULL) {\n      fprintf(log_file, \"Entered cpuset_getaffinity block\\n\");\n      fclose(log_file);\n    }\n\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n      FILE *log_file2 = fopen(\"/tmp/logs/136.txt\", \"a\");\n      if (log_file2 != NULL) {\n        fprintf(log_file2, \"cpuset_getaffinity call succeeded\\n\");\n        fclose(log_file2);\n      }\n\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (ret <= 0)\n  {\n    FILE *log_file3 = fopen(\"/tmp/logs/136.txt\", \"a\");\n    if (log_file3 != NULL) {\n      fprintf(log_file3, \"Entering CPU_COUNT_S block\\n\");\n      fclose(log_file3);\n    }\n\n    /* Use 256 times larger size than size for default maximum CPU number. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (ret <= 0)\n    return -1;\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 forbids the use of language extensions explicitly documented as extensions in compiler documentation. The functions and types used here, such as cpuset_getaffinity, CPU_ALLOC, CPU_FREE, CPU_ALLOC_SIZE, and cpuset_t, are part of system or platform-specific APIs provided by the operating system (e.g., FreeBSD) for CPU affinity management, not standard C language constructs or extensions at the language/compiler level. These are operating system or platform APIs, not language extensions implemented by the compiler. MISRA's Rule 1.2 covers language/compiler-specific extensions, not platform-specific system APIs. Therefore, unless the compiler specifically documents these as language extensions (which is typically not the case), their usage does not violate Rule 1.2. Furthermore, the presence of these platform APIs is usually managed by conditional compilation and documentation, and their use must be considered a platform dependency rather than a compiler language extension violation. Thus, agent A's claim that usage of cpuset_getaffinity and related functions violates MISRA C 2023 Rule 1.2 is incorrect."
}