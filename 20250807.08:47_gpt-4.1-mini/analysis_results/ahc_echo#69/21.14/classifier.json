{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified ahc_echo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/558.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_echo:\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n</additional code>\nJudge whether the above ahc_echo code violates the rule 21.14 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses memcmp to compare authentication username and password strings which are null terminated strings, violating MISRA C 2023 Rule 21.14.",
  "test_code": "static enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  FILE *log_file = fopen(\"/tmp/logs/558.txt\", \"a\");\n  (void) cls;\n  (void) url;\n  (void) version;\n  (void) upload_data;\n  (void) upload_data_size;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"ahc_echo called with method: %s\\n\", method);\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    if (log_file != NULL)\n      fprintf(log_file, \"Method is not GET, returning MHD_NO\\n\");\n    if (log_file != NULL) fclose(log_file);\n    return MHD_NO; /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    if (log_file != NULL)\n      fprintf(log_file, \"First call, setting req_cls to aptr and returning MHD_YES\\n\");\n    *req_cls = &aptr;\n    if (log_file != NULL) fclose(log_file);\n    return MHD_YES;\n  }\n  *req_cls = NULL; /* reset when done */\n\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (log_file != NULL)\n    fprintf(log_file, \"Obtained auth_info at %p\\n\", (void*)auth_info);\n\n  fail = ((NULL == auth_info) ||\n          (strlen (\"Aladdin\") != auth_info->username_len) ||\n          (0 != memcmp (auth_info->username, \"Aladdin\",\n                        auth_info->username_len)) ||\n          (NULL == auth_info->password) ||\n          (strlen (\"open sesame\") != auth_info->password_len) ||\n          (0 != memcmp (auth_info->password, \"open sesame\",\n                        auth_info->password_len)));\n\n  if (log_file != NULL)\n    fprintf(log_file, \"Authentication %s\\n\", fail ? \"failed\" : \"succeeded\");\n\n  if (fail)\n  {\n    response = MHD_create_response_from_buffer_static(strlen(DENIED),\n                                                     (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3(connection,\n                                                  \"TestRealm\",\n                                                  MHD_NO,\n                                                  response);\n  }\n  else\n  {\n    response = MHD_create_response_from_buffer_static(strlen(PAGE),\n                                                     (const void *) PAGE);\n    ret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n  }\n\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Response sent, ret=%d\\n\", ret);\n    fclose(log_file);\n  }\n\n  return ret;\n}\n"
}