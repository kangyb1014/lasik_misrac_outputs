{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The ahc_echo function uses string handling functions strcmp, strlen, and memcmp with pointers derived from authentication info username and password fields obtained from MHD_basic_auth_get_username_password3. The function checks lengths via username_len and password_len members, which are derived correctly by zero-terminating strings within the allocated buffer. However, if the authentication info's username_len or password_len contain incorrect, larger-than-actual values, the memcmp call might access beyond the bounds of the underlying username or password arrays, violating Rule 21.17. Therefore, if improperly formed authentication info is passed with inconsistent length fields, this can lead to out-of-bounds access in string.h functions used in ahc_echo.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  FILE *log = fopen(\"/tmp/logs/559.txt\", \"a\");\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  fprintf(log, \"Entered ahc_echo with method=%s\\n\", method);\n\n  if (0 != strcmp (method, \"GET\")) {\n    fprintf(log, \"Method not GET; returning MHD_NO\\n\");\n    fclose(log);\n    return MHD_NO;              /* unexpected method */\n  }\n\n  if (&aptr != *req_cls)\n  {\n    fprintf(log, \"First call: setting *req_cls and returning MHD_YES\\n\");\n    *req_cls = &aptr;\n    fclose(log);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* Obtaining auth_info */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (auth_info == NULL) {\n    fprintf(log, \"auth_info is NULL\\n\");\n  } else {\n    fprintf(log, \"auth_info: username_len=%zu, password_len=%zu\\n\", \n            auth_info->username_len, auth_info->password_len);\n    fprintf(log, \"auth_info: username='%s', password='%s'\\n\", \n            auth_info->username ? auth_info->username : \"(null)\", \n            auth_info->password ? auth_info->password : \"(null)\");\n\n    /* Log bounds to check correct lengths to avoid out-of-bounds */\n    for (size_t i=0; i<auth_info->username_len; i++) {\n      fprintf(log, \"username[%zu] = 0x%02x\\n\", i, (unsigned char)auth_info->username[i]);\n    }\n    for (size_t i=0; i<auth_info->password_len; i++) {\n      fprintf(log, \"password[%zu] = 0x%02x\\n\", i, (unsigned char)auth_info->password[i]);\n    }\n  }\n\n  /* Define DENIED and PAGE string literals here to avoid compile error */\n  static const char DENIED[] = \"Access Denied\";\n  static const char PAGE[] = \"<html><body>Access Granted</body></html>\";\n\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n\n  fprintf(log, \"Authentication %s\\n\", fail ? \"failed\" : \"succeeded\");\n\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer (strlen (DENIED),\n                                       (const void *) DENIED,\n                                       MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_basic_auth_required_response (connection,\n                                                  \"TestRealm\",\n                                                  MHD_NO,\n                                                  response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer (strlen (PAGE),\n                                       (const void *) PAGE,\n                                       MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  fprintf(log, \"ahc_echo returning %d\\n\", ret);\n  fclose(log);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits string handling functions from <string.h> to access beyond object bounds. In the ahc_echo function, memcmp and strlen operate on pointers and lengths derived from authentication info obtained via MHD_basic_auth_get_username_password3. The function relies on username_len and password_len members to constrain memcmp. The report hypothesizes that if these length fields are incorrect (e.g., larger than actual allocated buffers), then memcmp may read out-of-bounds, violating the rule. This is a valid concern: the function assumes MHD_basic_auth_get_username_password3 provides consistent and safe length information. However, the function itself does not perform additional internal checks to verify length correctness with regard to the buffer size. This means that if malformed or malicious auth_info struct with inconsistent length fields were passed, the code could indeed execute out-of-bounds accesses, violating Rule 21.17. Though the fundamental source of unsafety is external data integrity, from the standpoint of this function using <string.h> functions, the potential for bounds violation exists and is a violation of Rule 21.17 as stated. Therefore, the agent A report that ahc_echo potentially violates Rule 21.17 under this scenario is correct."
}