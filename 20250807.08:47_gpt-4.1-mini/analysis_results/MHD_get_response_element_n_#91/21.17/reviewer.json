{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the 'header' pointer in any MHD_HTTP_Res_Header structure within the linked list is not properly null-terminated or is smaller than 'header_size', or if 'key' points to a shorter buffer than 'key_len', then the function MHD_str_equal_caseless_bin_n_ might access memory beyond the bounds of these pointer parameters when comparing the headers, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind {\n  MHD_KIND_UNDEFINED = 0,\n  MHD_KIND_HEADER,\n  // other kinds...\n};\nstatic void log_state(const char *message, const char *header, size_t header_size, const char *key, size_t key_len)\n{\n  FILE *log = fopen(\"/tmp/logs/735.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"%s - header_size: %zu, key_len: %zu\\n\", message, header_size, key_len);\n    if (header != NULL && header_size > 0)\n      fprintf(log, \"Header segment: '%.10s'\\n\", header);\n    if (key != NULL && key_len > 0)\n      fprintf(log, \"Key segment: '%.10s'\\n\", key);\n    fclose(log);\n  }\n}\n\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                           enum MHD_ValueKind kind,\n                           const char *key,\n                           size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (response == NULL) {\n    log_state(\"Response is NULL\", NULL, 0, key, key_len);\n    return NULL;\n  }\n\n  if (NULL == key || 0 == key[0] || 0 == key_len)\n  {\n    log_state(\"Invalid key or key_len\", NULL, 0, key, key_len);\n    return NULL;\n  }\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    log_state(\"Checking header\", pos->header, pos->header_size, key, key_len);\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n    {\n      log_state(\"Match found\", pos->header, pos->header_size, key, key_len);\n      return pos;\n    }\n  }\n  log_state(\"No match found\", NULL, 0, key, key_len);\n  return NULL;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 mandates that the use of string handling functions from <string.h> must not result in accesses beyond the bounds of the referenced objects. The code in MHD_get_response_element_n_ calls MHD_str_equal_caseless_bin_n_ with pos->header, key, and pos->header_size. The key_len is asserted non-zero and pos->header_size is compared to key_len, ensuring equal length usage in the comparison. However, the key point is whether pos->header points to a buffer at least pos->header_size long, and key points to a buffer at least key_len long, so that no buffer overruns occur during string operations inside MHD_str_equal_caseless_bin_n_. The function itself is not shown, but assuming it uses safe length-bounded comparison, this can be safe. The code asserts key is non-null and key_len is non-zero before use, but no explicit validation ensures pos->header has at least pos->header_size valid bytes, nor that key points to at least key_len bytes. The scenario given by agent A points out that if these assumptions fail, then memory access beyond bounds can occur, violating Rule 21.17. Because the code lacks validation for the buffers' actual sizes or contents - i.e., the size validity of pos->header and key buffers beyond relying on the header_size and key_len values - a potential violation of Rule 21.17 exists if these invariants are not upheld elsewhere. Thus, agent A's report is correct in principle: the code can violate Rule 21.17 if the stated assumptions are not guaranteed. However, whether this is a direct violation depends on the contract and data invariants established elsewhere in the code base. The test code provided failed to compile, so no runnable proof was given, but the reasoning remains valid from the perspective of Rule 21.17. Therefore, the report should be considered correct as the code might lead to out-of-bounds accesses via string.h functions if input data is improperly bounded."
}