{
  "user_message": "An agent A claimed that the following ws_get_accept_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ws_get_accept_value.\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function ws_get_accept_value uses strncpy to copy key into str with length WS_KEY_LEN + 1, and then copies WS_GUID with length WS_GUID_LEN + 1 to str + WS_KEY_LEN. If WS_KEY_LEN + 1 exceeds the actual length of key, or WS_GUID_LEN + 1 exceeds the intended bounds, it causes strncpy to write beyond allocated memory. Since str is allocated with size WS_KEY_LEN + WS_GUID_LEN + 1, copying WS_KEY_LEN + 1 bytes plus WS_GUID_LEN + 1 bytes can result in buffer overflow, accessing beyond the bounds of str. Thus, the use of strncpy in this function potentially violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nws_get_accept_value(const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n  FILE *log = fopen(\"/tmp/logs/503.txt\", \"a\");\n\n  if ((NULL == key) || (WS_KEY_LEN != (ssize_t)strlen(key)))\n  {\n    if (log) fprintf(log, \"Exit: key is NULL or length mismatch.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  str = malloc(WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    if (log) fprintf(log, \"Exit: malloc failed.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (log) fprintf(log, \"Copying key to str with memcpy: length = %zu, dest size = %zu\\n\", (size_t)WS_KEY_LEN, (size_t)(WS_KEY_LEN + WS_GUID_LEN + 1));\n  memcpy(str, key, WS_KEY_LEN);\n\n  if (log) fprintf(log, \"Copying GUID to str + WS_KEY_LEN with memcpy: length = %zu\\n\", (size_t)WS_GUID_LEN);\n  memcpy(str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN);\n\n  str[WS_KEY_LEN + WS_GUID_LEN] = '\\0';\n\n  SHA1Reset(&ctx);\n  SHA1Input(&ctx, (const unsigned char *)str, WS_KEY_LEN + WS_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result(&ctx, hash))\n  {\n    free(str);\n    if (log) fprintf(log, \"Exit: SHA1Result failure.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  free(str);\n  len = BASE64Encode(hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    if (log) fprintf(log, \"Exit: BASE64Encode failed.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  (*val)[len] = '\\0';\n  if (log) fprintf(log, \"Success: value generated with length %zd.\\n\", len);\n  if (log) fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A argues that using strncpy with lengths WS_KEY_LEN + 1 and WS_GUID_LEN + 1 on a buffer allocated with size WS_KEY_LEN + WS_GUID_LEN + 1 might overflow the buffer, thus violating MISRA C 2023 Rule 21.17. On inspection, the buffer str is allocated with size WS_KEY_LEN + WS_GUID_LEN + 1 bytes. The first strncpy copies WS_KEY_LEN + 1 bytes to str, and the second strncpy copies WS_GUID_LEN + 1 bytes to str + WS_KEY_LEN. Sum of bytes copied is (WS_KEY_LEN + 1) + (WS_GUID_LEN + 1) = WS_KEY_LEN + WS_GUID_LEN + 2 bytes, which exceeds the buffer allocation by 1 byte, causing an overflow and thus access beyond bounds. This use of strncpy leads to buffer overflow, which directly violates Rule 21.17 that prohibits accesses beyond object bounds in string handling functions. Therefore, the agent's report correctly identifies a violation in the code. The test code provided uses memcpy with lengths matching the key and GUID lengths (without the +1), matching correct sizing and avoids the risk, but it failed compilation likely due to other reasons. Nonetheless, the original code does contain the violation as claimed."
}