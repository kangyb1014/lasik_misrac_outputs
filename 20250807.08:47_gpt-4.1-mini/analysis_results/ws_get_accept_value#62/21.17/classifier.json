{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified ws_get_accept_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/503.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ws_get_accept_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of ws_get_accept_value:\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ws_get_accept_value:\nstatic enum SHA1_RESULT\nSHA1Reset (struct SHA1Context *context)\n{\n  if (! context)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  context->length_low = 0;\n  context->length_high = 0;\n  context->message_block_index = 0;\n  context->intermediate_hash[0] = 0x67452301;\n  context->intermediate_hash[1] = 0xEFCDAB89;\n  context->intermediate_hash[2] = 0x98BADCFE;\n  context->intermediate_hash[3] = 0x10325476;\n  context->intermediate_hash[4] = 0xC3D2E1F0;\n  context->computed = 0;\n  context->corrupted = 0;\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Input (struct SHA1Context *context, const unsigned char *message_array,\n           unsigned length)\n{\n  if (! length)\n  {\n    return SHA1_RESULT_SUCCESS;\n  }\n  if (! context || ! message_array)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->computed)\n  {\n    context->corrupted = 1;\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  while (length-- && ! context->corrupted)\n  {\n    context->message_block[context->message_block_index++]\n      = (*message_array & 0xFF);\n    context->length_low += 8;\n    if (context->length_low == 0)\n    {\n      context->length_high++;\n      if (context->length_high == 0)\n      {\n        context->corrupted = 1;\n      }\n    }\n    if (context->message_block_index == 64)\n    {\n      SHA1ProcessMessageBlock (context);\n    }\n    message_array++;\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Result (struct SHA1Context *context, unsigned char\n            Message_Digest[SHA1HashSize])\n{\n  int i;\n\n  if (! context || ! Message_Digest)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (! context->computed)\n  {\n    SHA1PadMessage (context);\n    for (i = 0; i < 64; ++i)\n    {\n      context->message_block[i] = 0;\n    }\n    context->length_low = 0;\n    context->length_high = 0;\n    context->computed = 1;\n  }\n  for (i = 0; i < SHA1HashSize; ++i)\n  {\n    Message_Digest[i]\n      = (unsigned char) (context->intermediate_hash[i >> 2]\n                         >> 8 * (3 - (i & 0x03)));\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic ssize_t\nBASE64Encode (const void *in, size_t len, char **output)\n{\n#define FILLCHAR '='\n  const char *cvt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    \"abcdefghijklmnopqrstuvwxyz\"\n                    \"0123456789+/\";\n  const char *data = in;\n  char *opt;\n  ssize_t ret;\n  size_t i;\n  char c;\n  ret = 0;\n\n  opt = malloc (2 + (len * 4 / 3) + 8);\n  if (NULL == opt)\n  {\n    return -1;\n  }\n  for (i = 0; i < len; ++i)\n  {\n    c = (data[i] >> 2) & 0x3F;\n    opt[ret++] = cvt[(int) c];\n    c = (data[i] << 4) & 0x3F;\n    if (++i < len)\n    {\n      c = (char) (c | ((data[i] >> 4) & 0x0F));\n    }\n    opt[ret++] = cvt[(int) c];\n    if (i < len)\n    {\n      c = (char) (c | ((data[i] << 2) & 0x3F));\n      if (++i < len)\n      {\n        c = (char) (c | ((data[i] >> 6) & 0x03));\n      }\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      ++i;\n      opt[ret++] = FILLCHAR;\n    }\n    if (i < len)\n    {\n      c = data[i] & 0x3F;\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      opt[ret++] = FILLCHAR;\n    }\n  }\n  *output = opt;\n  return ret;\n}\n</additional code>\nJudge whether the above ws_get_accept_value code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function ws_get_accept_value uses strncpy to copy key into str with length WS_KEY_LEN + 1, and then copies WS_GUID with length WS_GUID_LEN + 1 to str + WS_KEY_LEN. If WS_KEY_LEN + 1 exceeds the actual length of key, or WS_GUID_LEN + 1 exceeds the intended bounds, it causes strncpy to write beyond allocated memory. Since str is allocated with size WS_KEY_LEN + WS_GUID_LEN + 1, copying WS_KEY_LEN + 1 bytes plus WS_GUID_LEN + 1 bytes can result in buffer overflow, accessing beyond the bounds of str. Thus, the use of strncpy in this function potentially violates MISRA C 2023 Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic enum MHD_Result\nws_get_accept_value(const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n  FILE *log = fopen(\"/tmp/logs/503.txt\", \"a\");\n\n  if ((NULL == key) || (WS_KEY_LEN != strlen(key)))\n  {\n    if (log)fprintf(log, \"Exit: key is NULL or length mismatch.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  str = malloc(WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    if (log)fprintf(log, \"Exit: malloc failed.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (log) fprintf(log, \"Copying key to str with strncpy: length = %zu, dest size = %zu\\n\", (size_t)(WS_KEY_LEN + 1), (size_t)(WS_KEY_LEN + WS_GUID_LEN + 1));\n  strncpy(str, key, (WS_KEY_LEN + 1));\n\n  if (log) fprintf(log, \"Copying GUID to str + WS_KEY_LEN with strncpy: length = %zu\\n\", (size_t)(WS_GUID_LEN + 1));\n  strncpy(str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n\n  SHA1Reset(&ctx);\n  SHA1Input(&ctx, (const unsigned char *)str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result(&ctx, hash))\n  {\n    free(str);\n    if (log) fprintf(log, \"Exit: SHA1Result failure.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  free(str);\n  len = BASE64Encode(hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    if (log) fprintf(log, \"Exit: BASE64Encode failed.\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  (*val)[len] = '\\0';\n  if (log) fprintf(log, \"Success: value generated with length %zd.\\n\", len);\n  if (log) fclose(log);\n  return MHD_YES;\n}\n"
}