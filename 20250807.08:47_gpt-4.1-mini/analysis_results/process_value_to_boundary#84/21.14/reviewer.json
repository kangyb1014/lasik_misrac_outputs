{
  "user_message": "An agent A claimed that the following process_value_to_boundary code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of process_value_to_boundary.\n```c\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n        break;\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      /* can check boundary */\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        /* no boundary, \"\\r\\n--\" is part of content, skip */\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        /* boundary found, process until newline then\n           skip boundary and go back to init */\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;             /* skip boundary as well */\n        buf[newline] = '\\0';\n        break;\n      }\n    }\n    else\n    {\n      /* cannot check for boundary, process content that\n         we have and check again later; except, if we have\n         no content, abort (out of memory) */\n      if ( (0 == newline) &&\n           (pp->buffer_pos == pp->buffer_size) )\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      break;\n    }\n  }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (pp->must_ikvi) ||\n         (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    pp->state = PP_Error;\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp to compare a substring of the buffer (which may be null terminated or part of a null terminated string) to the string literal \"\\r\\n--\" and to the boundary string, which is intended to be a null terminated string. This usage violates MISRA C:2023 Rule 21.14 that prohibits using memcmp to compare null terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  FILE *log = fopen(\"/tmp/logs/678.txt\", \"a\");\n  char *buf = (char *) (pp + 1);  /* Changed from &pp[1] to (pp + 1) to ensure pointer arithmetic on the struct pointer rather than array indexing */\n  size_t newline;\n  const char *r;\n\n  fprintf(log, \"Start process_value_to_boundary\\n\");\n\n  newline = 0;\n  while (1)\n  {\n    fprintf(log, \"Outer while loop start, newline=%zu\\n\", newline);\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        fprintf(log, \"No '\\r' found, set newline=%zu\\n\", newline);\n        break;\n      }\n      newline = (size_t) (r - buf);\n      fprintf(log, \"'\\r' found at position %zu\\n\", newline);\n\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n      {\n        fprintf(log, \"Found '\\r\\n--' at position %zu using memcmp\\n\", newline);\n        break;\n      }\n      newline++;\n      fprintf(log, \"No match, increment newline to %zu\\n\", newline);\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        fprintf(log, \"Boundary not matched at position %zu\\n\", newline + 4);\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        fprintf(log, \"Boundary matched at position %zu\\n\", newline + 4);\n\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;\n        buf[newline] = '\\0';\n        break;\n      }\n    }\n    else\n    {\n      if ( (0 == newline) && (pp->buffer_pos == pp->buffer_size) )\n      {\n        pp->state = PP_Error;\n        fprintf(log, \"Error: no content and buffer full\\n\");\n        fclose(log);\n        return MHD_NO;\n      }\n      fprintf(log, \"Cannot check for boundary, exit loop\\n\");\n      break;\n    }\n  }\n\n  if ( ( (pp->must_ikvi) || (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    pp->state = PP_Error;\n    fprintf(log, \"ikvi function returned MHD_NO, error state set\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n\n  fprintf(log, \"End process_value_to_boundary, value_offset=%zu, ioffptr=%zu\\n\", pp->value_offset, *ioffptr);\n  fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.14 states that the standard library function memcmp shall not be used to compare null terminated strings. The code uses memcmp to compare fixed lengths of buffers (4 bytes with the literal \"\\r\\n--\" and blen bytes with the boundary string). These comparisons are over known fixed lengths rather than relying on null termination. The memcmp calls do not assume that the compared areas are null terminated strings; rather, they compare specified byte counts. Therefore, the memcmp usage here compares raw memory buffers, not null terminated strings, and does not violate Rule 21.14. The agent A's claim that memcmp is used to compare null terminated strings is incorrect, because neither operand is guaranteed to be null terminated strings in these calls and the length parameters specifically prevent this. Hence, the report is not correct."
}