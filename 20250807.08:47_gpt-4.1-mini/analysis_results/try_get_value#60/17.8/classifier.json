{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_get_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/485.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_get_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_get_value:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\nJudge whether the above try_get_value code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function try_get_value modifies the parameter 'destination' by assigning a new malloc'ed pointer to it, i.e., *destination = malloc(vlen);, which alters the pointer parameter itself rather than only modifying the object it points to. This is a violation of MISRA C 2023 Rule 17.8, which states that a function parameter should not be modified. Here, the pointer 'destination' itself (the parameter) is modified, not just the object it points to.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  FILE *log = fopen(\"/tmp/logs/485.txt\", \"a\");\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  fprintf(log, \"try_get_value called with buf='%s', key='%s', *destination=%p\\n\", buf, key, (void *)*destination);\n\n  if (NULL != *destination)\n  {\n    fprintf(log, \"*destination already set, returning immediately\\n\");\n    fclose(log);\n    return;\n  }\n\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    fprintf(log, \"Found key occurrence at position %td\\n\", spos - buf);\n\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      fprintf(log, \"No valid match found here: spos[klen]='%c', spos[-1]='%c'\\n\", spos[klen], spos[-1]);\n      bpos = spos + 1;\n      continue;\n    }\n\n    if (spos[klen + 1] != '\"')\n    {\n      fprintf(log, \"Value not quoted properly. Expected '\"' but got '%c'\\n\", spos[klen + 1]);\n      fclose(log);\n      return;                   /* not quoted */\n    }\n\n    if (NULL == (endv = strchr (&spos[klen + 2], '\"')))\n    {\n      fprintf(log, \"No ending quote found for the value\\n\");\n      fclose(log);\n      return;                   /* no end-quote */\n    }\n\n    vlen = (size_t) (endv - spos) - klen - 1;\n    fprintf(log, \"Allocating memory of size %zu for *destination\\n\", vlen);\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n    {\n      fprintf(log, \"Memory allocation failed\\n\");\n      fclose(log);\n      return;                   /* out of memory */\n    }\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination, &spos[klen + 2], vlen - 1);\n    fprintf(log, \"Copied value: %s\\n\", *destination);\n\n    fclose(log);\n    return;                     /* success */\n  }\n  fprintf(log, \"Key not found in buffer\\n\");\n  fclose(log);\n}\n"
}