{
  "user_message": "An agent A claimed that the following try_get_value code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of try_get_value.\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function try_get_value modifies the parameter 'destination' by assigning a new malloc'ed pointer to it, i.e., *destination = malloc(vlen);, which alters the pointer parameter itself rather than only modifying the object it points to. This is a violation of MISRA C 2023 Rule 17.8, which states that a function parameter should not be modified. Here, the pointer 'destination' itself (the parameter) is modified, not just the object it points to.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  FILE *log = fopen(\"/tmp/logs/485.txt\", \"a\");\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  fprintf(log, \"try_get_value called with buf='%s', key='%s', *destination=%p\\n\", buf, key, (void *)*destination);\n\n  if (NULL != *destination)\n  {\n    fprintf(log, \"*destination already set, returning immediately\\n\");\n    fclose(log);\n    return;\n  }\n\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    fprintf(log, \"Found key occurrence at position %td\\n\", spos - buf);\n\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      fprintf(log, \"No valid match found here: spos[klen]='%c', spos[-1]='%c'\\n\", spos[klen], spos[-1]);\n      bpos = spos + 1;\n      continue;\n    }\n\n    if (spos[klen + 1] != '\"')\n    {\n      fprintf(log, \"Value not quoted properly. Expected '\"' but got '%c'\\n\", spos[klen + 1]);\n      fclose(log);\n      return;                   /* not quoted */\n    }\n\n    if (NULL == (endv = strchr (&spos[klen + 2], '\"')))\n    {\n      fprintf(log, \"No ending quote found for the value\\n\");\n      fclose(log);\n      return;                   /* no end-quote */\n    }\n\n    vlen = (size_t) (endv - spos) - klen - 1;\n    fprintf(log, \"Allocating memory of size %zu for *destination\\n\", vlen);\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n    {\n      fprintf(log, \"Memory allocation failed\\n\");\n      fclose(log);\n      return;                   /* out of memory */\n    }\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination, &spos[klen + 2], vlen - 1);\n    fprintf(log, \"Copied value: %s\\n\", *destination);\n\n    fclose(log);\n    return;                     /* success */\n  }\n  fprintf(log, \"Key not found in buffer\\n\");\n  fclose(log);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 17.8 specifies that function parameters themselves should not be modified; however, it explicitly allows modification of the object the pointer parameter points to, but not the pointer parameter variable. In the function try_get_value, the parameter destination has the type char **destination. The function modifies *destination (the object pointed to by destination) by assigning it a malloc'ed memory block. This is modifying the object pointed to by the pointer parameter, which is allowed. The pointer parameter destination itself (the variable destination) is not modified \u2014 only *destination is changed. The scenario from agent A states that assigning *destination = malloc(...) modifies the pointer parameter itself, which is incorrect. The pointer parameter destination remains unchanged; only the pointed-to object is modified. Therefore, this code does not violate Rule 17.8."
}