{
  "user_message": "An agent A claimed that the following try_get_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_get_value.\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function try_get_value uses memcpy to copy a substring from the input buffer to a newly allocated memory region. However, the allocated size is vlen bytes, and memcpy copies vlen-1 bytes into it, which is acceptable. Yet, the pointer arithmetic and length calculation for vlen is complex and potentially error-prone. Since vlen is computed as (endv - spos) - klen - 1, if the string is malformed or the quotes are missing, it can lead to incorrect vlen and possible buffer overflows when accessing *destination. Moreover, writing a null terminator at (*destination)[vlen - 1] is correct given the allocation of vlen bytes. Overall, the code does not ensure memory accesses beyond the bounds in normal correct use, but if the input format is unexpected, the pointer arithmetic may cause out-of-bounds accesses. Thus, it violates MISRA C 2023 Rule 21.17 because the string handling function memcpy can result in accesses beyond object bounds if the input string does not strictly follow the expected format.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  FILE *log = fopen(\"/tmp/logs/487.txt\", \"w\");\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n  {\n    fprintf(log, \"Early return: destination not NULL\\n\");\n    fclose(log);\n    return;\n  }\n  bpos = buf;\n  klen = strlen (key);\n  fprintf(log, \"Start: key=\\\"%s\\\", klen=%zu\\n\", key, klen);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    fprintf(log, \"Found key at position: %td\\n\", spos - buf);\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      fprintf(log, \"No match: expected '=' and space before key\\n\");\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n    {\n      fprintf(log, \"Return: value not quoted, char='%c' at spos+klen+1\\n\", spos[klen + 1]);\n      fclose(log);\n      return;                   /* not quoted */\n    }\n    endv = strchr (&spos[klen + 2], '\"');\n    if (NULL == endv)\n    {\n      fprintf(log, \"Return: no end quote found\\n\");\n      fclose(log);\n      return;                   /* no end-quote */\n    }\n    vlen = (size_t) (endv - &spos[klen + 2]) + 1;\n    fprintf(log, \"vlen calculated = %zu\\n\", vlen);\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n    {\n      fprintf(log, \"Return: out of memory\\n\");\n      fclose(log);\n      return;                   /* out of memory */\n    }\n    memcpy (*destination, &spos[klen + 2], vlen - 1);\n    (*destination)[vlen - 1] = '\\0';\n    fprintf(log, \"Copy done, destination string: '%s'\\n\", *destination);\n    fclose(log);\n    return;                     /* success */\n  }\n  fprintf(log, \"Key not found in buffer\\n\");\n  fclose(log);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits string functions from <string.h> causing accesses beyond the bounds of the referenced objects. In the provided code, bounds checking relies on a sequence of pointer operations and conditions that verify the input string's format before performing memcpy. The calculation of 'vlen' in the original code is intended to represent the length including the null terminator allocation and the code explicitly checks for the presence of the '=' character, the opening quote '\"', and the closing quote '\"' before allocating memory and copying data. If these conditions fail, the function returns early without any memory operations, thereby preventing buffer overflows. Though the pointer arithmetic is somewhat complex, it is guarded by these checks, making out-of-bound accesses unlikely under controlled input. The key point is that rule 21.17 concerns actual accesses beyond allocated bounds, not potential ones due to malformed inputs if the code guards exits properly. The provided scenario hypothesizes input without the expected format could cause overflows, but the code returns early in such cases rather than continuing to memcpy. The failed compilation of the test code (which modified vlen calculation) does not affect the original code\u2019s analysis. Therefore, agent A\u2019s claim that the code violates rule 21.17 is not substantiated, since the code does guard accesses properly."
}