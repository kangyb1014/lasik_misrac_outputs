{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_get_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/487.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_get_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_get_value:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\nJudge whether the above try_get_value code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function try_get_value uses memcpy to copy a substring from the input buffer to a newly allocated memory region. However, the allocated size is vlen bytes, and memcpy copies vlen-1 bytes into it, which is acceptable. Yet, the pointer arithmetic and length calculation for vlen is complex and potentially error-prone. Since vlen is computed as (endv - spos) - klen - 1, if the string is malformed or the quotes are missing, it can lead to incorrect vlen and possible buffer overflows when accessing *destination. Moreover, writing a null terminator at (*destination)[vlen - 1] is correct given the allocation of vlen bytes. Overall, the code does not ensure memory accesses beyond the bounds in normal correct use, but if the input format is unexpected, the pointer arithmetic may cause out-of-bounds accesses. Thus, it violates MISRA C 2023 Rule 21.17 because the string handling function memcpy can result in accesses beyond object bounds if the input string does not strictly follow the expected format.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  FILE *log = fopen(\"/tmp/logs/487.txt\", \"w\");\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n  {\n    fprintf(log, \"Early return: destination not NULL\\n\");\n    fclose(log);\n    return;\n  }\n  bpos = buf;\n  klen = strlen (key);\n  fprintf(log, \"Start: key=\\\"%s\\\", klen=%zu\\n\", key, klen);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    fprintf(log, \"Found key at position: %td\\n\", spos - buf);\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      fprintf(log, \"No match: expected '=' and space before key\\n\");\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n    {\n      fprintf(log, \"Return: value not quoted, char='%c' at spos+klen+1\\n\", spos[klen + 1]);\n      fclose(log);\n      return;                   /* not quoted */\n    }\n    endv = strchr (&spos[klen + 2], '\"');\n    if (NULL == endv)\n    {\n      fprintf(log, \"Return: no end quote found\\n\");\n      fclose(log);\n      return;                   /* no end-quote */\n    }\n    vlen = (size_t) (endv - spos) - klen - 1;\n    fprintf(log, \"vlen calculated = %zu\\n\", vlen);\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n    {\n      fprintf(log, \"Return: out of memory\\n\");\n      fclose(log);\n      return;                   /* out of memory */\n    }\n    (*destination)[vlen - 1] = '\\0';\n    fprintf(log, \"Copying %zu bytes to destination\\n\", vlen - 1);\n    memcpy (*destination, &spos[klen + 2], vlen - 1);\n    fprintf(log, \"Copy done, destination string: '%s'\\n\", *destination);\n    fclose(log);\n    return;                     /* success */\n  }\n  fprintf(log, \"Key not found in buffer\\n\");\n  fclose(log);\n}\n"
}