{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation occurs if the string handling functions such as memcpy or get_rq_param_unquoted_copy_z (which uses memcpy and then writes a zero terminator) are called with buffers smaller than the source strings, leading to out-of-bounds access. For example, if computed unif_buf_size is smaller than the sum of expected lengths plus zero-termination bytes, the copying functions would overflow the allocated buffer when writing opaque or realm strings or usernames. This might happen if the length calculations inside get_rq_unames_size or the additions for opaque and realm lengths are incorrect or do not match with actual usage. In particular, get_rq_param_unquoted_copy_z uses memcpy with param->value.len but the allocated unif_buf_size must have been at least the sum of these lengths + 1 for zero-termination to avoid overflow.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct {\n  char *str;\n  size_t len;\n} typedef MHD_String_View;\nstruct MHD_Param {\n  struct {\n    char *str;\n    size_t len;\n  } value;\n};\nstruct MHD_RqDAuth {\n  struct MHD_Param opaque;\n  struct MHD_Param realm;\n  struct MHD_Param cnonce;\n  int algo3;\n  int qop;\n};\nstatic const struct MHD_RqDAuth *MHD_get_rq_dauth_params_(struct MHD_Connection *connection) {\n  (void)connection;\n  return NULL; /* For compilation only */\n}\nstatic size_t get_rq_unames_size(const struct MHD_RqDAuth *params, enum MHD_DigestAuthUsernameType type) {\n  (void)params; (void)type;\n  return 0;\n}\nstatic void mhd_assert(int expr) { if (!(expr)) abort(); }\n\nstatic enum MHD_DigestAuthUsernameType get_rq_uname_type(const struct MHD_RqDAuth *params) {\n  (void)params;\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\nstatic size_t get_rq_uname(const struct MHD_RqDAuth *params, enum MHD_DigestAuthUsernameType type,\n                           struct MHD_DigestAuthInfo *info, uint8_t *buf, size_t buflen) {\n  (void)params; (void)type; (void)info; (void)buf; (void)buflen;\n  return 0;\n}\nstatic size_t get_rq_param_unquoted_copy_z(const struct MHD_Param *param, char *dest) {\n  if (!param || !param->value.str || !dest) return 0;\n  size_t len = param->value.len;\n  for (size_t i=0; i<len; i++) {\n    dest[i] = param->value.str[i];\n  }\n  dest[len] = '\\0';\n  return len;\n}\nstatic enum MHD_GetRqNCResult get_rq_nc(const struct MHD_RqDAuth *params, unsigned int *nc) {\n  (void)params;\n  *nc = 0;\n  return MHD_GET_RQ_NC_VALID;\n}\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3(struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/39.txt\", \"a\");\n  if (log != NULL)\n    fprintf(log, \"Entered MHD_digest_auth_get_request_info3\\n\");\n\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_(connection);\n  if (NULL == params)\n  {\n    if (log != NULL)\n      fprintf(log, \"params is NULL, returning NULL\\n\");\n    if (log) fclose(log);\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type(params);\n  if (log != NULL)\n    fprintf(log, \"uname_type: %d\\n\", (int)uname_type);\n\n  unif_buf_size += get_rq_unames_size(params, uname_type);\n  if (log != NULL)\n    fprintf(log, \"unif_buf_size after uname size: %zu\\n\", unif_buf_size);\n\n  if (NULL != params->opaque.value.str)\n  {\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n    if (log != NULL)\n      fprintf(log, \"Added opaque size: %zu + 1\\n\", params->opaque.value.len);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n    if (log != NULL)\n      fprintf(log, \"Added realm size: %zu + 1\\n\", params->realm.value.len);\n  }\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_(1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  if (info == NULL)\n  {\n    if (log != NULL)\n      fprintf(log, \"Memory allocation failed\\n\");\n    if (log) fclose(log);\n    return NULL;\n  }\n\n  unif_buf_ptr = (uint8_t *)(info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    size_t ret = get_rq_uname(params, uname_type,\n                              (struct MHD_DigestAuthInfo *)info,\n                              unif_buf_ptr + unif_buf_used,\n                              unif_buf_size - unif_buf_used);\n    if (log != NULL)\n      fprintf(log, \"get_rq_uname returned %zu\\n\", ret);\n    unif_buf_used += ret;\n  }\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *)(unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z(&params->opaque, info->opaque);\n    if (log != NULL)\n      fprintf(log, \"opaque_len: %zu\\n\", info->opaque_len);\n    unif_buf_used += info->opaque_len + 1;\n    if (log != NULL)\n      fprintf(log, \"unif_buf_used after opaque: %zu / %zu\\n\", unif_buf_used, unif_buf_size);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *)(unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z(&params->realm, info->realm);\n    if (log != NULL)\n      fprintf(log, \"realm_len: %zu\\n\", info->realm_len);\n    unif_buf_used += info->realm_len + 1;\n    if (log != NULL)\n      fprintf(log, \"unif_buf_used after realm: %zu / %zu\\n\", unif_buf_used, unif_buf_size);\n  }\n\n  if (log != NULL)\n  {\n    if (unif_buf_size < unif_buf_used)\n      fprintf(log, \"Buffer overflow risk: unif_buf_size %zu, unif_buf_used %zu\\n\", unif_buf_size, unif_buf_used);\n    else\n      fprintf(log, \"Buffer usage within limit: unif_buf_size %zu, unif_buf_used %zu\\n\", unif_buf_size, unif_buf_used);\n  }\n\n  mhd_assert(unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc(params, &info->nc);\n  if (log != NULL)\n    fprintf(log, \"get_rq_nc result: %d, nc value: %u\\n\", nc_res, info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  if (log) fclose(log);\n  return info;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation concerns possible out-of-bounds accesses when using string handling functions like memcpy or a wrapper (get_rq_param_unquoted_copy_z) that copies and zero-terminates strings, without sufficient buffer allocation. Examining the code, unif_buf_size is computed by summing the sizes returned by get_rq_unames_size (for usernames) plus the lengths of opaque and realm parameters each with an added one byte for zero-termination. The allocated buffer is then of sufficient size to hold all these copies including zero terminators. After copying, the total used buffer size is tracked via unif_buf_used, and an assertion mhd_assert(unif_buf_size >= unif_buf_used) confirms that usage does not exceed allocation. This pattern enforces no buffer overrun during copying. The risk suggested by agent A depends on whether the size computations inside get_rq_unames_size and additions for opaque/realm lengths are exact. If those functions correctly reflect the exact data sizes including the +1 zero terminator, and the lengths stored in params->opaque.value.len and params->realm.value.len are accurate, then no overflow occurs. The code structure and the assertion strongly indicate careful sizing to prevent buffer overruns consistent with MISRA rule 21.17. The test code provided failed to compile, so no empirical evidence confirms the violation. In absence of proof of incorrect length computations or inaccurate length fields, the report is speculative. Therefore, based on the given code and logic, the report of violation of MISRA C 2023 Rule 21.17 is unsubstantiated and likely incorrect."
}