{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function MHD_digest_auth_get_request_info3 uses the compiler-specific extension _MHD_EXTERN in the function declaration. Such annotations are typically language extensions beyond standard C and some compilers document these prefixes or macros as extensions to support link visibility or calling conventions, which violates MISRA C 2023 Rule 1.2 against language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/32.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entering MHD_digest_auth_get_request_info3\\n\");\n  }\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_(connection);\n  if (log != NULL)\n  {\n    fprintf(log, \"params: %p\\n\", (void *)params);\n  }\n  if (NULL == params)\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"params is NULL, exiting with NULL\\n\");\n      fclose(log);\n    }\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type(params);\n  if (log != NULL)\n  {\n    fprintf(log, \"uname_type: %d\\n\", uname_type);\n  }\n\n  unif_buf_size += get_rq_unames_size(params, uname_type);\n\n  if (params->opaque.value.str != NULL)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (params->realm.value.str != NULL)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_(1, sizeof(struct MHD_DigestAuthInfo) + unif_buf_size);\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Allocated info: %p\\n\", (void *)info);\n  }\n\n  unif_buf_ptr = (uint8_t *)(info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ((uname_type != MHD_DIGEST_AUTH_UNAME_TYPE_MISSING) &&\n      (uname_type != MHD_DIGEST_AUTH_UNAME_TYPE_INVALID))\n  {\n    unif_buf_used += get_rq_uname(\n        params, uname_type,\n        (struct MHD_DigestAuthUsernameInfo *)info,\n        unif_buf_ptr + unif_buf_used,\n        unif_buf_size - unif_buf_used);\n  }\n  else\n  {\n    info->uname_type = uname_type;\n  }\n\n  if (params->opaque.value.str != NULL)\n  {\n    info->opaque = (char *)(unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z(&params->opaque, info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (params->realm.value.str != NULL)\n  {\n    info->realm = (char *)(unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z(&params->realm, info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert(unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (params->cnonce.value.str != NULL)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc(params, &info->nc);\n  if (nc_res != MHD_GET_RQ_NC_VALID)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Exiting MHD_digest_auth_get_request_info3 with info: %p\\n\", (void *)info);\n    fclose(log);\n  }\n\n  return info;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The symbol _MHD_EXTERN in the function declaration appears to be a macro used for symbol visibility or linkage specification. Such macros are common in cross-platform or library code to handle extern declarations or compiler-specific attributes transparently. However, MISRA C 2023 Rule 1.2 prohibits the use of language extensions\u2014features or constructs not part of the ISO C standard and explicitly documented as extensions by the compiler vendor.\n\nWhether _MHD_EXTERN violates Rule 1.2 depends on its definition. If _MHD_EXTERN expands to standard C keywords (e.g., plain 'extern') or nothing, it is not a compiler extension and does not violate the rule. If it expands to a compiler-specific keyword, attribute, or pragma that the compiler documents as an extension, then its usage would violate MISRA C 2023 Rule 1.2.\n\nGiven only the snippet, the _MHD_EXTERN macro definition is not provided. Usually, such symbols are defined conditionally in headers to handle cross-platform exporting, and sometimes they expand to compiler-specific extensions (e.g., __declspec(dllexport) in MSVC or __attribute__((visibility(\"default\"))) in GCC). Those are exactly the kind of extensions MISRA C 2023 Rule 1.2 forbids.\n\nAgent A's scenario claims that _MHD_EXTERN is a compiler-specific extension macro, and thus its use violates Rule 1.2. However, the test code that uses this macro failed to compile, so no runtime evidence was obtained. Compilation failure alone does not prove that the macro is an extension---it may indicate missing macro definitions for the build environment.\n\nSince no direct information about the macro definition or its expansion is given, we must assume typical situations:\n- If _MHD_EXTERN is defined as a compiler-specific extension macro, the report is correct.\n- If it is defined as a simple 'extern' or empty macro, it is not an extension, and the report is incorrect.\n\nWithout the macro definition, the claim cannot be fully verified. Still, the scenario presented by agent A is plausible and likely correct in a typical setting where _MHD_EXTERN controls symbol attributes via compiler extensions.\n\nTherefore, the report that the code violates MISRA C 2023 Rule 1.2 due to using _MHD_EXTERN as a language extension macro is accepted as correct."
}