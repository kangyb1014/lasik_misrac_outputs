{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the key or value pointers passed to MHD_set_connection_value_n do not point to strings of length key_size or value_size (as expected by strlen), the calls to strlen may read beyond the bounds of the buffers, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n(struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          size_t key_size,\n                          const char *value,\n                          size_t value_size)\n{\n  FILE *log = fopen(\"/tmp/logs/439.txt\", \"a\");\n  if (log == NULL)\n  {\n    /* Cannot open log file, continue without logging */\n  }\n\n  if (log)\n  {\n    fprintf(log, \"Entry: kind=%d, key=0x%p, key_size=%zu, value=0x%p, value_size=%zu\\n\",\n            (int)kind, (const void*)key, key_size, (const void*)value, value_size);\n  }\n\n  if ((MHD_GET_ARGUMENT_KIND != kind) &&\n      ((((key ? strlen(key) : 0)) != key_size) ||\n       (((value ? strlen(value) : 0)) != value_size)))\n  {\n    if (log)\n    {\n      fprintf(log, \"Violation detected: strlen(key) or strlen(value) does not match sizes\\n\");\n      fclose(log);\n    }\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  if (log)\n  {\n    fprintf(log, \"No violation detected: calling MHD_set_connection_value_n_nocheck_\\n\");\n    fclose(log);\n  }\n\n  return MHD_set_connection_value_n_nocheck_(connection, kind, key, key_size, value, value_size);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The code in MHD_set_connection_value_n calls strlen on the pointers key and value if they are not NULL. According to the rule, using string handling functions like strlen must not access beyond the bounds of the objects pointed to. However, the function accepts key_size and value_size parameters which represent sizes. There is nothing in the code ensuring that the key and value pointers actually point to valid null-terminated strings of length key_size and value_size, respectively. If these pointers point to buffers that are not null-terminated or that contain embedded null characters before key_size or value_size bytes, strlen will read beyond the passed object boundaries, causing a violation of MISRA Rule 21.17. Therefore, the agent A's scenario is correct: the use of strlen here can cause out-of-bounds accesses if the inputs do not correspond to valid C strings of the given sizes. Hence, the report that the code violates MISRA Rule 21.17 is correct."
}