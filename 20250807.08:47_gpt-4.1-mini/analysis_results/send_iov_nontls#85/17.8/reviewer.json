{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'push_data' is a boolean value passed by value to the function send_iov_nontls. Inside the function, 'push_data' is assigned new values multiple times, for example setting 'push_data = false;' (lines related to _MHD_IOV_MAX and items_to_send) and in the Windows sockets section conditionally modifying 'push_data' to false when 'items_to_send' exceeds UINT32_MAX. This constitutes modification of a function parameter, which is prohibited by MISRA C 2023 Rule 17.8. The object pointed to by pointer parameters is not modified; however, the value parameter 'push_data' itself is modified within the function, violating the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#define _MHD_IOV_MAX 16\n#define UINT32_MAX 4294967295U\n\n/* Stubs for types used */\ntypedef struct MHD_iovec_ {\n  void *iov_base;\n  size_t iov_len;\n} MHD_iovec_;\n\nstruct MHD_iovec_track_ {\n  MHD_iovec_ *iov;\n  size_t cnt;\n  size_t sent;\n};\n\nstruct MHD_Connection {\n  void *daemon;\n  int socket_fd;\n  int state;\n};\n\n#ifdef MHD_WINSOCK_SOCKETS\n#include <windows.h>\n#endif\n\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  FILE *log_fp = fopen(\"/tmp/logs/685.txt\", \"a\");\n  if (log_fp == NULL) return -1;\n\n  ssize_t res;\n  size_t items_to_send;\n\n  fprintf(log_fp, \"send_iov_nontls called with push_data = %d\\n\", push_data);\n\n#ifdef _MHD_IOV_MAX\n  items_to_send = r_iov->cnt - r_iov->sent;\n  fprintf(log_fp, \"Initial items_to_send = %zu\\n\", items_to_send);\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    fprintf(log_fp, \"_MHD_IOV_MAX = %d is less than items_to_send %zu - modifying push_data\\n\", _MHD_IOV_MAX, items_to_send);\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n    fprintf(log_fp, \"Modified push_data to %d\\n\", push_data);\n  }\n#else\n  items_to_send = r_iov->cnt - r_iov->sent;\n#endif\n\n#ifdef MHD_WINSOCK_SOCKETS\n  DWORD cnt_w;\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    fprintf(log_fp, \"items_to_send > UINT32_MAX - modifying push_data to false\\n\");\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else\n  cnt_w = (DWORD) items_to_send;\n#endif\n#endif\n\n  fprintf(log_fp, \"Final push_data value before sending: %d\\n\", push_data);\n  fclose(log_fp);\n\n  /* Original function code would continue here, preserving logic. */\n\n  return 0; /* stub return */\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter should not be modified. This means the parameter variable itself, as declared in the function's parameter list, must not be assigned a new value inside the function body. In the given send_iov_nontls function, the parameter 'push_data' is of type bool and is passed by value. Within the function, there are multiple assignments to 'push_data', e.g., 'push_data = false;'. Since 'push_data' is a value parameter (not a pointer), modifying it inside the function violates Rule 17.8, as the parameter variable itself is changed after entry. The object pointed to by pointer parameters is allowed to be modified, but here, 'push_data' is not a pointer parameter; it is a value parameter directly modified. Hence, the agent A's report accurately identifies a violation of MISRA C 2023 Rule 17.8 by the function send_iov_nontls."
}