{
  "user_message": "An agent A claimed that the following process_upload_data code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of process_upload_data.\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The violation occurs when the 'data' pointer passed to string handling functions like memcpy in do_append points to a buffer smaller than the 'size' parameter, leading to out-of-bounds access. Since the size is externally provided and unchecked against the actual data buffer length, this can result in accessing memory beyond the referenced object.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = (struct UploadContext *)cls;\n  FILE *log = fopen(\"/tmp/logs/447.txt\", \"a\");\n  if (log == NULL) return MHD_NO;\n\n  (void) kind;\n  (void) content_type;\n  (void) transfer_encoding;\n  (void) off;\n\n  fprintf(log, \"process_upload_data called with key=%s, filename=%s, size=%zu\\n\", key, filename ? filename : \"(null)\", size);\n\n  if (0 == strcmp (key, \"category\")) {\n    fprintf(log, \"Branch: key == category\\n\");\n    fprintf(log, \"Calling do_append with size=%zu\\n\", size);\n    fclose(log);\n    return do_append (&uc->category, data, size);\n  }\n  if (0 == strcmp (key, \"language\")) {\n    fprintf(log, \"Branch: key == language\\n\");\n    fprintf(log, \"Calling do_append with size=%zu\\n\", size);\n    fclose(log);\n    return do_append (&uc->language, data, size);\n  }\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    fprintf(log, \"Branch: unexpected form key, returning MHD_YES\\n\");\n    fclose(log);\n    return MHD_YES;\n  }\n\n  if (filename == NULL)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    fprintf(log, \"Branch: filename is NULL, returning MHD_NO\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  if ((uc->category == NULL) || (uc->language == NULL))\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    fprintf(log, \"Branch: missing form data category or language, returning MHD_NO\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  /* Rest of original code is not changed, so omitted for brevity */\n\n  fprintf(log, \"Completed processing without memcpy or string functions beyond bounds\\n\");\n  fclose(log);\n  return MHD_YES;\n}\nstatic enum MHD_Result\ndo_append (char **ret,\n           const char *data,\n           size_t size)\n{\n  FILE *log = fopen(\"/tmp/logs/447.txt\", \"a\");\n  if (log != NULL)\n    fprintf(log, \"do_append called with size=%zu\\n\", size);\n\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n\n  if (log != NULL)\n    fprintf(log, \"Old string length=%zu, allocating buffer of size %zu\\n\", old_len, old_len + size + 1);\n\n  buf = (char *)malloc (old_len + size + 1);\n  if (NULL == buf) {\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (NULL != *ret)\n  {\n    memcpy (buf,\n            *ret,\n            old_len);\n    free (*ret);\n  }\n\n  if (log) fprintf(log, \"Memcpy data with size=%zu\\n\", size);\n  memcpy (&buf[old_len],\n          data,\n          size);  /* POTENTIAL VIOLATION: data pointer with size unverified */\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n\n  if (log) fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported MISRA C 2023 Rule 21.17 violation concerns the potential out-of-bounds access in string handling functions due to the unverified 'size' parameter when copying data in the do_append function. The 'data' pointer and 'size' are passed into do_append from process_upload_data, where 'size' is externally provided and not internally checked against the actual buffer length of 'data'. The do_append function uses memcpy to copy 'size' bytes from 'data' without validating that 'data' indeed references at least 'size' bytes, which could lead to accesses beyond the object bounds if the caller provides inconsistent or incorrect 'size'. This is a direct violation of Rule 21.17, which requires that string functions must not access beyond the bounds of the referenced objects. The test code intended to demonstrate this was not compiled successfully, but the static code analysis and the logic are sufficient to indicate the violation. Therefore, Agent A's claim that the code violates Rule 21.17 is valid."
}