{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Using standard string functions strcmp and strstr on pointers upg_header and con_header may lead to out-of-bounds access if these pointers do not point to properly null-terminated strings. Specifically, if upg_header or con_header is not null-terminated, strcmp or strstr can read beyond the object bounds, violating rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Connection {};\nstatic const char *WS_UPGRADE_VALUE = \"websocket\";\n\nstatic MHD_Result\nis_websocket_request(struct MHD_Connection *con, const char *upg_header,\n                     const char *con_header)\n{\n    FILE *log = fopen(\"/tmp/logs/511.txt\", \"a\");\n    if (log == NULL) {\n        /* If logging fails, proceed without logs */\n        return MHD_NO;\n    }\n    (void) con;  /* Unused. Silent compiler warning. */\n\n    fprintf(log, \"is_websocket_request called with upg_header at %p, con_header at %p\\n\", (void *)upg_header, (void *)con_header);\n\n    if ((upg_header != NULL) && (con_header != NULL)) {\n        fprintf(log, \"Both headers are non-null\\n\");\n\n        /* Log the contents being compared */\n        fprintf(log, \"Comparing upg_header ('%s') with WS_UPGRADE_VALUE ('%s')\\n\", upg_header, WS_UPGRADE_VALUE);\n\n        int cmp_result = strcmp(upg_header, WS_UPGRADE_VALUE);\n        fprintf(log, \"strcmp result: %d\\n\", cmp_result);\n\n        const char *strstr_result = strstr(con_header, \"Upgrade\");\n        fprintf(log, \"strstr result pointer: %p\\n\", (void *)strstr_result);\n\n        if ((cmp_result == 0) && (strstr_result != NULL)) {\n            fprintf(log, \"Request is a websocket request: returning MHD_YES\\n\");\n            fclose(log);\n            return MHD_YES;\n        }\n    } else {\n        fprintf(log, \"One or both headers are NULL - returning MHD_NO\\n\");\n    }\n    fprintf(log, \"Request is NOT a websocket request: returning MHD_NO\\n\");\n    fclose(log);\n    return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits the use of string handling functions from <string.h> in a way that leads to accessing beyond the bounds of their referenced objects. The provided is_websocket_request code uses strcmp and strstr on pointers upg_header and con_header without explicit checks for proper null-termination of these strings. The code checks for non-NULL pointers but does not guarantee that the strings pointed to are null-terminated. If either upg_header or con_header is not null-terminated, calls to strcmp or strstr can indeed read beyond the object bounds, violating Rule 21.17. Therefore, the agent A's claim that the code violates Rule 21.17 due to potential out-of-bounds access when using standard string functions is correct. The test code provided by agent A does not refute this claim even if it failed to compile, because the potential violation arises from assumptions on the caller's inputs which are not enforced or validated in the code itself."
}