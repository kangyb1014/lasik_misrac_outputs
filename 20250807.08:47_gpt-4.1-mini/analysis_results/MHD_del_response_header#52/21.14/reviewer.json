{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the MHD_del_response_header function, memcmp is used to compare header and content strings with stored header and value buffers. Although memcmp is used with explicit length parameters corresponding to string lengths, the rule prohibits using memcmp for null-terminated string comparison. Here, the strings are null-terminated, and memcmp is used instead of safer string comparison functions for null-terminated strings, violating Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  FILE *log_file = fopen(\"/tmp/logs/422.txt\", \"a\");\n\n  struct MHD_HTTP_Res_Header *pos;\n  struct MHD_HTTP_Res_Header *next;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) ) {\n    if (log_file) {\n      fprintf(log_file, \"Early return: header or content is NULL\\n\");\n      fclose(log_file);\n    }\n    return MHD_NO;\n  }\n\n  header_len = strlen (header);\n  if (log_file) {\n    fprintf(log_file, \"header_len: %zu\\n\", header_len);\n  }\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len)) {\n    if (log_file) {\n      fprintf(log_file, \"Calling del_response_header_connection\\n\");\n      fclose(log_file);\n    }\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  if (log_file) {\n    fprintf(log_file, \"content_len: %zu\\n\", content_len);\n  }\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    next = pos->next;\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      if (log_file) {\n        fprintf(log_file, \"Match found for header and content, removing header\\n\");\n      }\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) ) {\n\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        if (log_file) {\n          fprintf(log_file, \"Cleared MHD_RAF_HAS_TRANS_ENC_CHUNKED flag\\n\");\n        }\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) ) {\n\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        if (log_file) {\n          fprintf(log_file, \"Cleared MHD_RAF_HAS_DATE_HDR flag\\n\");\n        }\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        if (log_file) {\n          fprintf(log_file, \"Checked and possibly cleared MHD_RAF_HAS_CONTENT_LENGTH flag\\n\");\n        }\n      }\n\n      if (log_file) {\n        fclose(log_file);\n      }\n      return MHD_YES;\n    }\n    else {\n      if (log_file) {\n        fprintf(log_file, \"No match at current header node, moving to next\\n\");\n      }\n    }\n    pos = next;\n  }\n\n  if (log_file) {\n    fprintf(log_file, \"No matching header found, returning MHD_NO\\n\");\n    fclose(log_file);\n  }\n  return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.14 states that the Standard Library function memcmp shall not be used to compare null-terminated strings. The key point is that memcmp is intended for binary memory comparison and does not safely handle null-terminated strings, for which string functions like strcmp or strncmp are designed. However, in this code, memcmp is used with explicit length parameters corresponding to the string lengths (obtained via strlen), and the comparison is done over exactly those lengths rather than relying on null terminators. This usage effectively treats the strings as binary buffers of known length, not as null-terminated strings. Thus, the use of memcmp here is not comparing null-terminated strings per se, but comparing buffers of known length. This is compliant with the intended spirit of Rule 21.14, which prohibits memcmp on null-terminated strings without length information. Therefore, the claim that memcmp is improperly used to compare null-terminated strings is incorrect, and the reported violation of Rule 21.14 is not justified from this code snippet."
}