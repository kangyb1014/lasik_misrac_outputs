{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the MHD_del_response_header function, the lengths of the header and content strings are obtained using strlen. Subsequently, memcmp is used to compare these strings with pos->header and pos->value up to header_len and content_len respectively. If pos->header or pos->value are not at least header_len or content_len bytes long, this could lead to accesses beyond the bounds of these objects. Hence, if these buffers are shorter than the lengths derived from the input parameters, the use of memcmp may violate MISRA C 2023 Rule 21.17 by potentially accessing out-of-bounds memory.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                     const char *header,\n                     const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n  FILE *log_fp = fopen(\"/tmp/logs/423.txt\", \"a\");\n\n  if (log_fp == NULL)\n    return MHD_NO;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    fprintf(log_fp, \"Early return: header or content is NULL\\n\");\n    fclose(log_fp);\n    return MHD_NO;\n  }\n\n  header_len = strlen (header);\n  fprintf(log_fp, \"header_len: %zu\\n\", header_len);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    fprintf(log_fp, \"Calling del_response_header_connection\\n\");\n    fclose(log_fp);\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  fprintf(log_fp, \"content_len: %zu\\n\", content_len);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    fprintf(log_fp, \"Checking header at pos: %p\\n\", (void *)pos);\n    fprintf(log_fp, \"pos->header_size: %zu, pos->value_size: %zu\\n\", pos->header_size, pos->value_size);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size))\n    {\n      fprintf(log_fp, \"Lengths match, comparing memory\\n\");\n\n      /* Probe for potential out-of-bounds access */\n      fprintf(log_fp, \"memcmp header\\n\");\n      if (memcmp (header, pos->header, header_len) != 0)\n      {\n        fprintf(log_fp, \"Header memcmp mismatch\\n\");\n        pos = pos->next;\n        continue;\n      }\n\n      fprintf(log_fp, \"memcmp content\\n\");\n      if (memcmp (content, pos->value, content_len) != 0)\n      {\n        fprintf(log_fp, \"Content memcmp mismatch\\n\");\n        pos = pos->next;\n        continue;\n      }\n\n      fprintf(log_fp, \"Header and content matched, removing header\\n\");\n      _MHD_remove_header (response, pos);\n\n      if (pos->header != NULL) free (pos->header);\n      if (pos->value  != NULL) free (pos->value);\n\n      /* Save next pointer prior to freeing pos */\n      struct MHD_HTTP_Res_Header *next_pos = pos->next;\n      free (pos);\n      pos = next_pos;\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n\n      fprintf(log_fp, \"Header removed successfully\\n\");\n      fclose(log_fp);\n      return MHD_YES;\n    }\n    else\n    {\n      fprintf(log_fp, \"Length mismatch or content mismatch, continuing\\n\");\n    }\n\n    pos = pos->next;\n  }\n\n  fprintf(log_fp, \"No matching header found to remove\\n\");\n  fclose(log_fp);\n  return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The provided code uses strlen to get the length of the input strings header and content, and then searches through a linked list of headers in the response. For each header entry (pos), it checks if the stored header_size and value_size match the lengths of the input header and content strings, respectively. Only when these lengths match does it call memcmp to compare the actual bytes. This logically ensures that the buffers pos->header and pos->value are at least header_len and content_len bytes long respectively, because their stored sizes must be equal to these lengths. Therefore, the memcmp calls do not access beyond the bounds of these objects. \n\nAgent A's alleged violation scenario assumes pos->header or pos->value are shorter than their corresponding size fields (pos->header_size or pos->value_size), which should never happen if the data structure is correctly maintained. The code reasonably relies on these size fields as valid indicators of the buffer lengths. Unless the size fields themselves are corrupted or incorrect, there is no out-of-bounds access in the usage of memcmp here.\n\nWhile defensive programming might add further runtime checks, the code as given correctly ensures accesses are within bounds according to the documented sizes. Hence, it does not violate MISRA C 2023 Rule 21.17 in this context.\n\nRegarding the test code, the failure to compile (likely due to missing definitions, headers, or macros) does not prove the original code violates the rule, it only indicates the test setup is incomplete or incorrect. The core logic in MHD_del_response_header is sound with respect to Rule 21.17 violations in use of string.h functions."
}