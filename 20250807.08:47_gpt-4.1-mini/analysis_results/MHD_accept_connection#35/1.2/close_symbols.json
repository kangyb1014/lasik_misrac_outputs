{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_socket_nonblocking_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_start_daemon_va']}, 'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'internal_add_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'new_connection_prepare_', 'new_connection_process_'], 'callers': ['MHD_add_connection', 'MHD_accept_connection']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_poll_all': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'call_handlers'], 'callers': ['MHD_poll', 'MHD_run_wait']}, 'MHD_poll_listen_socket': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'new_connections_list_process_', 'MHD_accept_connection'], 'callers': ['MHD_poll']}, 'MHD_epoll': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'resume_suspended_connections', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'MHD_connection_handle_idle', 'call_handlers'], 'callers': ['MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_socket_strerr_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_DLOG",
    "MHD_socket_nonblocking_",
    "MHD_socket_noninheritable_",
    "MHD_socket_nosignal_",
    "MHD_socket_close_",
    "internal_add_connection",
    "mhd_assert",
    "MHD_thread_handle_ID_is_current_thread_"
  ],
  "explanation": "These symbols are required to fully analyze the MHD_accept_connection function because they are either called directly or used in macros/assertions within the function. Specifically, the error handling and socket state functions (MHD_socket_get_error_, MHD_SCKT_ERR_IS_*, MHD_socket_nonblocking_, MHD_socket_noninheritable_, MHD_socket_nosignal_) control flow and system calls that might rely on compiler extensions. The logging function MHD_DLOG might use compiler-specific variadic macros or extensions. The internal_add_connection is called at the end and might contain language extensions affecting the function's behavior. Assertions (mhd_assert) and thread checking function (MHD_thread_handle_ID_is_current_thread_) may be macros or inline functions possibly using compiler extensions. Knowledge of these symbols is crucial to check if the code uses any non-standard language extensions violating MISRA C rules."
}