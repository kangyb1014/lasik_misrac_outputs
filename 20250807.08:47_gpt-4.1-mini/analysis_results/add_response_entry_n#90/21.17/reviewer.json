{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If header_len or content_len do not correctly reflect the true allocated buffer sizes of header or content respectively, the memchr calls could access beyond the object bounds, violating MISRA C 2023 Rule 21.17. For example, if header_len is larger than the actual size of the header buffer, memchr(header, '\\t', header_len) can read out-of-bounds memory.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind {\n    MHD_KIND_GET,\n    MHD_KIND_POST,\n    // other kinds as needed\n};\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                     enum MHD_ValueKind kind,\n                     const char *header,\n                     size_t header_len,\n                     const char *content,\n                     size_t content_len)\n{\n  FILE *log = fopen(\"/tmp/logs/727.txt\", \"w\");\n  if (log == NULL) return false;\n\n  if (NULL == response) {\n    fprintf(log, \"response is NULL\\n\");\n    fclose(log);\n    return false;\n  }\n\n  fprintf(log, \"header_len = %zu\\n\", header_len);\n  fprintf(log, \"content_len = %zu\\n\", content_len);\n\n  if (0 == header_len) {\n    fprintf(log, \"header_len is zero\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (0 == content_len) {\n    fprintf(log, \"content_len is zero\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (header, '\\t', header_len)) {\n    fprintf(log, \"Found '\\t' in header\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (header, ' ', header_len)) {\n    fprintf(log, \"Found ' ' in header\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (header, '\\r', header_len)) {\n    fprintf(log, \"Found '\\r' in header\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (header, '\\n', header_len)) {\n    fprintf(log, \"Found '\\n' in header\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (content, '\\r', content_len)) {\n    fprintf(log, \"Found '\\r' in content\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (content, '\\n', content_len)) {\n    fprintf(log, \"Found '\\n' in content\\n\");\n    fclose(log);\n    return false;\n  }\n\n  fprintf(log, \"Passing arguments to MHD_add_response_entry_no_check_\\n\");\n  fclose(log);\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 requires that calls to string handling functions from <string.h> must not access memory beyond the bounds of the objects referenced by their pointer parameters. In the provided code, the memchr calls use the parameters header_len and content_len as the length to examine. The critical question is whether these length parameters accurately reflect the allocated sizes of the buffers pointed to by header and content. The code does not itself check or enforce that header_len or content_len correspond to the actual object sizes; it assumes that the caller provides correct lengths. Therefore, if a caller supplies a length parameter greater than the actual buffer size, then memchr may access beyond the object bounds, violating Rule 21.17. The agent A's scenario is valid in that the code relies on external correctness of length parameters and does not itself prevent buffer overruns in memchr. However, the code as is cannot enforce or guarantee this. Thus, the potential for violation exists due to insufficient validation and reliance on external correctness. Hence, the report that the code violates MISRA C 2023 Rule 21.17 under these assumptions is correct."
}