{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_ready_normal_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/755.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_ready_normal_body as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_ready_normal_body:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_normal_body:\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\nstatic void\nconnection_close_error (struct MHD_Connection *connection,\n                        const char *emsg)\n{\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              \"%s\\n\",\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void) emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}\n...\nvoid\nMHD_connection_close_ (struct MHD_Connection *connection,\n                       enum MHD_RequestTerminationCode termination_code)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_Response *resp = connection->rp.response;\n\n  mhd_assert (! connection->suspended);\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  if ( (NULL != daemon->notify_completed) &&\n       (connection->rq.client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n                              connection,\n                              &connection->rq.client_context,\n                              termination_code);\n  connection->rq.client_aware = false;\n  if (NULL != resp)\n  {\n    connection->rp.response = NULL;\n    MHD_destroy_response (resp);\n  }\n  if (NULL != connection->pool)\n  {\n    MHD_pool_destroy (connection->pool);\n    connection->pool = NULL;\n  }\n\n  MHD_connection_mark_closed_ (connection);\n}\n</additional code>\nJudge whether the above try_ready_normal_body code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "In try_ready_normal_body, the function pointer response->crc is called with response->data cast to a non-const pointer (char *), while it likely points to a const-qualified type representing the response data. This cast removes const qualification to pass to a function that may modify data, which violates Rule 8.13: a pointer should point to a const-qualified type whenever possible, except when the function modifies the pointed data. Here, casting away const to pass to response->crc indicates a potential violation as the function may modify the data, or the design is inconsistent regarding const qualification.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stddef.h>\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n\n#define MHD_MIN(a,b) ((a) < (b) ? (a) : (b))\n\nstruct MHD_Response\n{\n  ssize_t (*crc)(void *cls, size_t pos, char *buf, size_t len);\n  void *crc_cls;\n  const void *data; /* pointer to const data */\n  size_t data_buffer_size;\n  size_t total_size;\n  size_t data_start;\n  size_t data_size;\n  size_t data_iovcnt;\n  const void *data_iov; /* assumed const */\n  void *resp_iov_iov;\n  int *mutex;\n};\n\nstruct response_props {\n  void *response;\n  size_t rsp_write_position;\n  struct {\n    void *iov;\n    size_t cnt;\n    size_t sent;\n  } resp_iov;\n  int resp_sender;\n};\n\nstruct MHD_Connection\n{\n  struct response_props rp;\n  int state;\n};\n\nstatic void log_to_file(const char *msg)\n{\n  FILE *file = fopen(\"/tmp/logs/755.txt\", \"a\");\n  if (file != NULL)\n  {\n    fprintf(file, \"%s\\n\", msg);\n    fclose(file);\n  }\n}\n\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response = (struct MHD_Response *)connection->rp.response;\n\n  log_to_file(\"Entered try_ready_normal_body\");\n\n  if ((0 == response->total_size) || (connection->rp.rsp_write_position == response->total_size))\n  {\n    log_to_file(\"Response total size is zero or fully written - ready\");\n    return MHD_YES;\n  }\n\n  if (NULL != response->data_iov)\n  {\n    log_to_file(\"Copying iov data to connection response iov\");\n    size_t copy_size = response->data_iovcnt * sizeof(void*);\n    connection->rp.resp_iov.iov = (void *)response->data_iov; /* simplified */\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    log_to_file(\"Response iov set\");\n    return MHD_YES;\n  }\n\n  if (NULL == response->crc)\n  {\n    log_to_file(\"No crc function, response ready\");\n    return MHD_YES;\n  }\n\n  /* Log state before crc call */\n  char logbuf[256];\n  snprintf(logbuf, sizeof(logbuf), \"Calling crc with rsp_write_position=%zu, data_buffer_size=%zu\", connection->rp.rsp_write_position, response->data_buffer_size);\n  log_to_file(logbuf);\n\n  /* Violation: casting const void* data to char* removing const qualifier */\n  ret = response->crc(response->crc_cls,\n                      connection->rp.rsp_write_position,\n                      (char *) response->data, /* cast from const void* to char* - violates Rule 8.13 */\n                      (size_t) MHD_MIN((uint64_t) response->data_buffer_size,\n                                       response->total_size - connection->rp.rsp_write_position));\n\n  snprintf(logbuf, sizeof(logbuf), \"crc returned %zd\", ret);\n  log_to_file(logbuf);\n\n  if (ret < 0)\n  {\n    log_to_file(\"crc returned error, closing connection\");\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_NO;\n  }\n\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n\n  if (ret == 0)\n  {\n    connection->state = 1; /* MHD_CONNECTION_NORMAL_BODY_UNREADY */\n    log_to_file(\"crc returned zero, normal body unready\");\n    return MHD_NO;\n  }\n\n  log_to_file(\"Response is ready\");\n  return MHD_YES;\n}\n"
}