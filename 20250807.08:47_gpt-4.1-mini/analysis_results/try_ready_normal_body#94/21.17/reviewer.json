{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the branch where memcpy is used to copy data from response->data_iov to connection->rp.resp_iov.iov, the size copied is calculated as response->data_iovcnt * sizeof(MHD_iovec_). If response->data_iovcnt or response->data_iov are incorrect or not properly bounded relative to the allocated memory, this memcpy call may read or write beyond the bounds of the referenced objects, violating Rule 21.17. Specifically, if the memory pointed to by response->data_iov is smaller than data_iovcnt * sizeof(MHD_iovec_) bytes, this results in out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  FILE *log_file = fopen(\"/tmp/logs/759.txt\", \"a\");\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if (log_file) fprintf(log_file, \"Entered try_ready_normal_body\\n\");\n\n  if ( (0 == response->total_size) ||\n       (connection->rp.rsp_write_position == response->total_size) )\n  {\n    if (log_file) fprintf(log_file, \"0-byte response or all data written, return MHD_YES\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_YES;  /* 0-byte response is always ready */\n  }\n\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (log_file) fprintf(log_file, \"response->data_iov is not NULL\\n\");\n\n    if (NULL != connection->rp.resp_iov.iov)\n    {\n      if (log_file) fprintf(log_file, \"connection->rp.resp_iov.iov is already set, return MHD_YES\\n\");\n      if (log_file) fclose(log_file);\n      return MHD_YES;\n    }\n\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    if (log_file) fprintf(log_file, \"Allocating memory of size %zu bytes\\n\", copy_size);\n\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      if (log_file) fprintf(log_file, \"Memory allocation failed for resp_iov.iov\\n\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      if (log_file) fclose(log_file);\n      return MHD_NO;\n    }\n\n    if (log_file) fprintf(log_file, \"Copying data: memcpy size %zu\\n\", copy_size);\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n\n    if (log_file) fprintf(log_file, \"Setting resp_iov.cnt=%u and resp_iov.sent=0\\n\", (unsigned int)response->data_iovcnt);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n\n    if (log_file) fclose(log_file);\n    return MHD_YES;\n  }\n\n  if (NULL == response->crc)\n  {\n    if (log_file) fprintf(log_file, \"response->crc is NULL, return MHD_YES\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_YES;\n  }\n\n  if ( (response->data_start <= connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start > connection->rp.rsp_write_position) )\n  {\n    if (log_file) fprintf(log_file, \"Response already ready, return MHD_YES\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_YES; /* response already ready */\n  }\n\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    if (log_file) fprintf(log_file, \"Using sendfile, return MHD_YES\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n\n  if (log_file) fprintf(log_file, \"Crc function returned %zd\\n\", ret);\n\n  if (0 > ret)\n  {\n    response->total_size = connection->rp.rsp_write_position;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported error generating data).\"));\n\n    if (log_file) fprintf(log_file, \"Error from crc, returning MHD_NO\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_NO;\n  }\n\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (log_file) fprintf(log_file, \"crc returned 0, setting state to UNREADY and returning MHD_NO\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (log_file) fprintf(log_file, \"Data ready, returning MHD_YES\\n\");\n  if (log_file) fclose(log_file);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The code uses memcpy to copy response->data_iovcnt * sizeof(MHD_iovec_) bytes from response->data_iov to connection->rp.resp_iov.iov, after allocating memory of the same size. The MISRA C 2023 Rule 21.17 prohibits accesses beyond the bounds of objects referenced by pointers in string functions including memcpy. The risk pointed out by agent A is that if response->data_iovcnt or response->data_iov do not correctly represent the bounds of the memory, this memcpy may cause out-of-bounds memory access, violating Rule 21.17. However, the code itself assumes that response->data_iov and data_iovcnt are valid and correctly bounded, which is likely managed by other parts of the program. In the given code and context, there is no explicit evidence or guard validating these values before the memcpy call. Because the use of memcpy depends on the correctness of these variables, and there is a potential for out-of-bounds accesses if these values are incorrect, the report is valid as a potential violation under MISRA Rule 21.17. Therefore, the report by agent A is correct in identifying a violation risk with the memcpy usage in this code segment."
}