{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_pool_reallocate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/664.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_pool_reallocate as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_pool_reallocate:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_reallocate:\n#define mhd_assert(ignore) ((void)0)\n...\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n...\n#define ROUND_TO_ALIGN_PLUS_RED_ZONE(n) ROUND_TO_ALIGN(n)\n...\n#define mp_ptr_diff_(p1, p2) ((size_t)(((constuint8_t*)(p1))-((constuint8_t*)(p2))))\n...\n#define mp_ptr_le_(p1, p2) (((constuint8_t*)(p1))<=((constuint8_t*)(p2)))\n...\n#define _MHD_RED_ZONE_SIZE (0)\n...\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n...\n#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0\n</additional code>\nJudge whether the above MHD_pool_reallocate code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "Use of compiler-specific extensions such as __asan_region_is_poisoned() function call inside conditional compilation blocks, which relies on compiler-specific sanitizers and may be considered a language extension depending on the compiler documentation.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define ALIGN_SIZE 8\n#define mhd_assert(ignore) ((void)0)\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n#define ROUND_TO_ALIGN_PLUS_RED_ZONE(n) ROUND_TO_ALIGN(n)\n#define _MHD_RED_ZONE_SIZE (0)\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0\n#define mp_ptr_diff_(p1, p2) ((size_t)(((const uint8_t*)(p1))-((const uint8_t*)(p2))))\n#define mp_ptr_le_(p1, p2) (((const uint8_t*)(p1))<=((const uint8_t*)(p2)))\n\nstruct MemoryPool\n{\n  size_t size;\n  size_t pos;\n  size_t end;\n  uint8_t *memory;\n};\n\n// Prototype for possible compiler extension function (AddressSanitizer)\n#ifdef MHD_ASAN_POISON_ACTIVE\n#ifdef HAVE___ASAN_REGION_IS_POISONED\nextern void * __asan_region_is_poisoned(const void * addr, size_t size);\n#endif\n#endif\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  FILE *log = fopen(\"/tmp/logs/664.txt\", \"a\");\n  size_t asize;\n  uint8_t *new_blc;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Entered MHD_pool_reallocate: old=%p, old_size=%zu, new_size=%zu\\n\", old, old_size, new_size);\n  }\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  if (log != NULL)\n  {\n    fprintf(log, \"Checking __asan_region_is_poisoned for region %p size %zu\\n\", old, old_size);\n  }\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    if (log != NULL)\n    {\n      fprintf(log, \"Old block at offset %zu, shrinking=%d\\n\", old_offset, shrinking);\n    }\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert ((old_size == 0) || (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    if (shrinking)\n    {\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      if (log != NULL)\n      {\n        fprintf(log, \"Shrinking block, zeroed and poisoned old+%zu to old+%zu\\n\", new_size, old_size);\n      }\n    }\n\n    if (pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {\n      const size_t new_apos = ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {\n        if ( (new_apos > pool->end) || (new_apos < pool->pos) )\n        {\n          if (log != NULL)\n          {\n            fprintf(log, \"No space to grow in-place: new_apos=%zu, pool->end=%zu, pool->pos=%zu\\n\", new_apos, pool->end, pool->pos);\n          }\n          fclose(log);\n          return NULL;\n        }\n      }\n\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n\n      if (log != NULL)\n      {\n        fprintf(log, \"Resized in-place at pos %zu\\n\", pool->pos);\n      }\n\n      fclose(log);\n      return old;\n    }\n\n    if (shrinking)\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"Shrunk in-place, returning old\\n\");\n      }\n      fclose(log);\n      return old;\n    }\n  }\n\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) && (0 != new_size) ) || (asize > pool->end - pool->pos) )\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"Allocation failed: asize=%zu, available=%zu\\n\", asize, pool->end - pool->pos);\n    }\n    fclose(log);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n\n  if (0 != old_size)\n  {\n    memcpy (new_blc, old, old_size);\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    if (log != NULL)\n    {\n      fprintf(log, \"Moved data from old %p to new %p, zeroed and poisoned old\\n\", old, new_blc);\n    }\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Returned new block at %p\\n\", new_blc);\n    fclose(log);\n  }\n  return new_blc;\n}\n"
}