{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of compiler-specific extensions such as __asan_region_is_poisoned() function call inside conditional compilation blocks, which relies on compiler-specific sanitizers and may be considered a language extension depending on the compiler documentation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid *\nMHD_pool_reallocate(struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  FILE *log = fopen(\"/tmp/logs/664.txt\", \"a\");\n  size_t asize;\n  uint8_t *new_blc;\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Entered MHD_pool_reallocate: old=%p, old_size=%zu, new_size=%zu\\n\", old, old_size, new_size);\n  }\n\n  mhd_assert(pool->end >= pool->pos);\n  mhd_assert(pool->size >= pool->end - pool->pos);\n  mhd_assert(old != NULL || old_size == 0);\n  mhd_assert(pool->size >= old_size);\n  mhd_assert(pool->pos == ROUND_TO_ALIGN(pool->pos));\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  if (log != NULL)\n  {\n    fprintf(log, \"Checking __asan_region_is_poisoned for region %p size %zu\\n\", old, old_size);\n  }\n  mhd_assert(NULL == __asan_region_is_poisoned(old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (old != NULL)\n  {\n    const size_t old_offset = mp_ptr_diff_(old, pool->memory);\n    const int shrinking = (old_size > new_size) ? 1 : 0;\n\n    if (log != NULL)\n    {\n      fprintf(log, \"Old block at offset %zu, shrinking=%d\\n\", old_offset, shrinking);\n    }\n\n    mhd_assert(mp_ptr_le_(pool->memory, old));\n    mhd_assert((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert((old_size == 0) || (pool->pos > old_offset));\n    mhd_assert((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    if (shrinking)\n    {\n      memset((uint8_t *)old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY((uint8_t *)old + new_size, old_size - new_size);\n      if (log != NULL)\n      {\n        fprintf(log, \"Shrinking block, zeroed and poisoned old+%zu to old+%zu\\n\", new_size, old_size);\n      }\n    }\n\n    if (pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE(old_offset + old_size))\n    {\n      const size_t new_apos = ROUND_TO_ALIGN_PLUS_RED_ZONE(old_offset + new_size);\n      if (!shrinking)\n      {\n        if ((new_apos > pool->end) || (new_apos < pool->pos))\n        {\n          if (log != NULL)\n          {\n            fprintf(log, \"No space to grow in-place: new_apos=%zu, pool->end=%zu, pool->pos=%zu\\n\", new_apos, pool->end, pool->pos);\n          }\n          fclose(log);\n          return NULL;\n        }\n      }\n\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY(old, new_size);\n\n      if (log != NULL)\n      {\n        fprintf(log, \"Resized in-place at pos %zu\\n\", pool->pos);\n      }\n\n      fclose(log);\n      return old;\n    }\n\n    if (shrinking)\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"Shrunk in-place, returning old\\n\");\n      }\n      fclose(log);\n      return old;\n    }\n  }\n\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE(new_size);\n  if (((0 == asize) && (0 != new_size)) || (asize > pool->end - pool->pos))\n  {\n    if (log != NULL)\n    {\n      fprintf(log, \"Allocation failed: asize=%zu, available=%zu\\n\", asize, pool->end - pool->pos);\n    }\n    fclose(log);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n  _MHD_UNPOISON_MEMORY(new_blc, new_size);\n\n  if (0 != old_size)\n  {\n    memcpy(new_blc, old, old_size);\n    memset(old, 0, old_size);\n    _MHD_POISON_MEMORY(old, old_size);\n    if (log != NULL)\n    {\n      fprintf(log, \"Moved data from old %p to new %p, zeroed and poisoned old\\n\", old, new_blc);\n    }\n  }\n\n  if (log != NULL)\n  {\n    fprintf(log, \"Returned new block at %p\\n\", new_blc);\n    fclose(log);\n  }\n  return new_blc;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported MISRA C 2023 Rule 1.2 violation concerns the use of the function __asan_region_is_poisoned(). This function is part of the AddressSanitizer (ASan) tooling provided by some compilers such as GCC and Clang, and is indeed a compiler-specific extension, not part of standard C. The code uses this function within a conditional compilation block that depends on the macro HAVE___ASAN_REGION_IS_POISONED, indicating explicit awareness of its optional and extension-specific nature. As per MISRA Rule 1.2, language extensions should not be used. The presence of an ArchSanitizer-specific function call qualifies as a language extension. Therefore, agent A's claim that the code violates Rule 1.2 due to the use of __asan_region_is_poisoned() is correct and justified. The failure to compile given the test code is unrelated to this rule's applicability; rather it shows the environment does not support the extension or the macro was not defined, but that does not invalidate the report about the rule violation when the extension is used."
}