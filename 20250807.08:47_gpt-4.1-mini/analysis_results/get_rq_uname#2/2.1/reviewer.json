{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function get_rq_uname contains an else branch at the end which is intended for handling invalid uname_type values not matching any of the defined ones. However, all valid uname_type values are already asserted before, and the function get_rq_uname_type ensures one of the expected types is returned or an invalid type that triggers the final else branch. Given the asserts and the enum coverage, the else branch (which contains mhd_assert(0)) should never be reached, making the code inside it effectively unreachable under normal conditions. This else branch is a violation scenario of unreachable code as per MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_DigestAuthUsernameType\nget_rq_uname_type(const struct MHD_RqDAuth *params)\n{\n  if (NULL != params->username.value.str)\n  {\n    if (NULL == params->username_ext.value.str)\n      return params->userhash ? MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH : MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  else if (NULL != params->username_ext.value.str)\n  {\n    if (!params->username_ext.quoted && !params->userhash && (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len))\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\nstatic size_t\nget_rq_uname(const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n  FILE *log = fopen(\"/tmp/logs/17.txt\", \"a\");\n  buf_used = 0;\n  mhd_assert(get_rq_uname_type(params) == uname_type);\n  mhd_assert(MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert(MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    if(log) fprintf(log, \"Entered STANDARD branch\\n\");\n    uname_info->username = (char *)(buf + buf_used);\n    uname_info->username_len = get_rq_param_unquoted_copy_z(&params->username, uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    if(log) fprintf(log, \"Entered USERHASH branch\\n\");\n    size_t res;\n    uname_info->userhash_hex = (char *)(buf + buf_used);\n    uname_info->userhash_hex_len = get_rq_param_unquoted_copy_z(&params->username, uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *)(buf + buf_used);\n    res = MHD_hex_to_bin(uname_info->userhash_hex, uname_info->userhash_hex_len, uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      if(log) fprintf(log, \"Hex to bin conversion failed: res %zu\\n\", res);\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *)uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    if(log) fprintf(log, \"Entered EXTENDED branch\\n\");\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z(params->username_ext.value.str, params->username_ext.value.len, (char *)(buf + buf_used), buf_size - buf_used);\n    if (0 > res)\n    {\n      if(log) fprintf(log, \"Extended uname copy failed with %zd\\n\", res);\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      uname_info->username = (char *)(buf + buf_used);\n      uname_info->username_len = (size_t)res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    if(log) fprintf(log, \"Entered unreachable else branch - uname_type invalid: %d\\n\", (int)uname_type);\n    mhd_assert(0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  if(log) fprintf(log, \"buf_size=%zu, buf_used=%zu\\n\", buf_size, buf_used);\n  if(log) fclose(log);\n  mhd_assert(buf_size >= buf_used);\n  return buf_used;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 2.1 forbids unreachable code in a project. Here, the function get_rq_uname has an else branch to handle cases when uname_type does not match any of the valid enum values handled in preceding if-else if branches. Before this branching, the code asserts that uname_type is not invalid or missing, while also verifying it matches the result of get_rq_uname_type. However, get_rq_uname_type can return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID under some conditions, which is explicitly asserted against in get_rq_uname (there is an assertion that uname_type != MHD_DIGEST_AUTH_UNAME_TYPE_INVALID). Therefore, under normal operation with asserts enabled, the else branch with the mhd_assert(0) should never be reached, effectively making it unreachable code.\n\nMoreover, asserts can be disabled in production builds, which means the else branch could be reached if an unexpected uname_type is passed. This design pattern is typical to catch programming errors during development while providing a fallback path at runtime.\n\nFrom the perspective of MISRA C strict compliance, unreachable code is code that cannot be executed under any normal or exceptional runtime circumstances. Here, since the else branch is logically unreachable under assumptions enforced by asserts, the agent's claim that this else branch constitutes unreachable code violating MISRA C 2023 Rule 2.1 is valid. The asserts do not guarantee that the else branch cannot be reached if disabled; but MISRA considers code that cannot be reached under the intended control flow as unreachable.\n\nHence, the reported violation is correct as the final else branch is effectively unreachable code under the given assumptions enforced by the assertions, violating Rule 2.1."
}