{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the buffer size (buf_size) passed to get_rq_uname is smaller than the total data copied plus required zero terminators, accesses beyond the bounds of buf can occur during calls to memcpy in get_rq_param_unquoted_copy_z and when writing zero terminators, especially in the MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED branch, since the function assumes buf has enough space without explicit bounds checking before copying data into it.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_RqDAuthParam;\nstruct MHD_RqDAuth;\n\nstatic size_t get_rq_uname(const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used = 0;\n  FILE *log = fopen(\"/tmp/logs/23.txt\", \"a\");\n\n  if (log) fprintf(log, \"get_rq_uname start: buf_size=%zu, uname_type=%d\\n\", buf_size, uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    if (log) fprintf(log, \"Standard uname branch: buf_used=%zu\\n\", buf_used);\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len = get_rq_param_unquoted_copy_z(&params->username, uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n    if (log) fprintf(log, \"Userhash uname branch: buf_used=%zu\\n\", buf_used);\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len = get_rq_param_unquoted_copy_z(&params->username, uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    /* For demonstration, assume conversion always succeeds returning half length */\n    res = uname_info->userhash_hex_len / 2;\n    buf_used += res;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used - res);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    if (log) fprintf(log, \"Extended uname branch: buf_used=%zu\\n\", buf_used);\n    ssize_t res = get_rq_extended_uname_copy_z(params->username_ext.value.str,\n                                               params->username_ext.value.len,\n                                               (char *) (buf + buf_used),\n                                               buf_size - buf_used);\n    if (res < 0)\n    {\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      if (log) fprintf(log, \"Extended uname copy failed with %zd\\n\", res);\n    }\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      if (log) fprintf(log, \"Extended uname copy succeeded: buf_used=%zu\\n\", buf_used);\n    }\n  }\n  else\n  {\n    if (log) fprintf(log, \"Invalid uname_type branch\\n\");\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  if (log)\n  {\n    fprintf(log, \"Final buf_used=%zu, buf_size=%zu\\n\", buf_used, buf_size);\n    if (buf_size < buf_used)\n      fprintf(log, \"WARNING: Buffer overflow possible!\\n\");\n    fclose(log);\n  }\n\n  return buf_used;\n}\nsize_t get_rq_param_unquoted_copy_z(const struct MHD_RqDAuthParam *param, char *buf) {\n  memcpy(buf, param->value.str, param->value.len);\n  buf[param->value.len] = '\\0';\n  return param->value.len;\n}\nssize_t get_rq_extended_uname_copy_z(const char *uname_ext, size_t uname_ext_len, char *buf, size_t buf_size) {\n  size_t copy_len = uname_ext_len < buf_size ? uname_ext_len : buf_size;\n  memcpy(buf, uname_ext, copy_len);\n  if (copy_len < buf_size) {\n    buf[copy_len] = '\\0';\n  }\n  if (copy_len < uname_ext_len) return -1;\n  return (ssize_t)copy_len;\n}\nenum MHD_DigestAuthUsernameType get_rq_uname_type(const struct MHD_RqDAuth *params) {\n  if (params->username.value.str != NULL) {\n    if (params->username_ext.value.str == NULL) {\n      return params->userhash ? MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH : MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    } else {\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n  } else if (params->username_ext.value.str != NULL) {\n    if (!params->username_ext.quoted && !params->userhash && (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len)) {\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    } else {\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n  }\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The provided code uses string handling functions indirectly via calls such as get_rq_param_unquoted_copy_z and get_rq_extended_uname_copy_z which internally use memcpy to copy data into the buffer 'buf'. The critical aspect is whether these copies respect the bounds of 'buf' as prescribed by the MISRA C 2023 Rule 21.17. The code does perform some length calculations and increments 'buf_used' after each copy, but it relies on the caller to provide a sufficiently large 'buf_size' to avoid buffer overflows.\n\nAgent A's scenario points out that if 'buf_size' is smaller than the total data plus terminators to be copied, the memcpy operations inside these functions could write beyond the bounds of 'buf'. The code does not appear to perform explicit checks before each memcpy to ensure that the destination buffer has enough space, except in get_rq_extended_uname_copy_z, which attempts to limit the copy length to 'buf_size - buf_used'. However, the other copy function get_rq_param_unquoted_copy_z does not have any bounds checking and blindly uses memcpy and sets a terminator, which may lead to out-of-bounds writes.\n\nTherefore, the report that the code violates MISRA C 2023 Rule 21.17 due to potential out-of-bounds access from string handling functions is correct. The lack of explicit buffer size validation before memory copies indeed risks accesses beyond the objects' bounds referenced by pointers passed to string handling functions, violating the rule."
}