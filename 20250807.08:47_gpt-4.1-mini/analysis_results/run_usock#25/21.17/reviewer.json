{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the run_usock function, ws_receive_frame uses the frame buffer and length to extract a message. If the frame data length calculation or indexing is incorrect, ws_receive_frame might read beyond the bounds of buf, leading to out-of-bounds access when using string handling functions or memcpy internally. Specifically, the calculation of idx_first_data and subsequent access of frame[] elements without proper bounds checking could result in out-of-bounds access if the received data size (got) is smaller than expected or the frame structure is malformed.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n  FILE *log_file = fopen(\"/tmp/logs/207.txt\", \"w\");\n\n  if (log_file == NULL)\n    abort ();\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    fprintf(log_file, \"recv returned: %zd\\n\", got);\n    if (0 >= got)\n    {\n      fprintf(log_file, \"recv less or equal zero, break\\n\");\n      break;\n    }\n    msg = ws_receive_frame (buf, (size_t *)&got, &type);\n    fprintf(log_file, \"ws_receive_frame returned msg=%p, type=%d, length=%zd\\n\", (void *)msg, type, got);\n    if (NULL == msg)\n    {\n      fprintf(log_file, \"msg is NULL, break\\n\");\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      fprintf(log_file, \"snprintf length for formatted text: %d\\n\", buf_size);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n          {\n            fprintf(log_file, \"snprintf successful, sending frame\\n\");\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n            fprintf(log_file, \"ws_send_frame sent: %zd\\n\", sent);\n          }\n          else\n          {\n            fprintf(log_file, \"snprintf length mismatch, sent set to -1\\n\");\n            sent = -1;\n          }\n          free (text);\n        }\n        else\n        {\n          fprintf(log_file, \"malloc for text failed, sent set to -1\\n\");\n          sent = -1;\n        }\n      }\n      else\n      {\n        fprintf(log_file, \"invalid snprintf length, sent set to -1\\n\");\n        sent = -1;\n      }\n      free (msg);\n      if (-1 == sent)\n      {\n        fprintf(log_file, \"sent is -1, breaking loop\\n\");\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        fprintf(log_file, \"received close frame, freeing msg and breaking\\n\");\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  fprintf(log_file, \"entered client cleanup loop\\n\");\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      fprintf(log_file, \"removed client socket %d at index %d\\n\", (int)ws->sock, i);\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  fprintf(log_file, \"finished run_usock cleanup\\n\");\n  fclose(log_file);\n  return NULL;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation pertains to potential out-of-bounds access caused by the ws_receive_frame function when used in run_usock. Rule 21.17 of MISRA C 2023 forbids string handling functions from accessing beyond object bounds. The function run_usock reads network data into the buffer 'buf' and passes this buffer with its size to ws_receive_frame, which presumably extracts a message frame from the buffer. The potential violation depends entirely on the correctness and robustness of ws_receive_frame's implementation, specifically whether it validates that all internal string or memory accesses stay within the bounds of the 'buf' array as indicated by the provided length parameter. The provided code of run_usock itself does not directly invoke any string handling functions on the data in 'buf' except via ws_receive_frame and subsequent calls. The test code attempt to log did not compile, so no further evidence is available. Without inspecting the implementation of ws_receive_frame, it is impossible to definitively conclude whether the rule is violated. However, from run_usock's perspective, it uses ws_receive_frame correctly by providing the buffer pointer and its size, and it does not itself use any string handling function that could access beyond bounds. Therefore, the claim that run_usock itself violates MISRA C 2023 Rule 21.17 is not demonstrated by the given code. The violation, if any, would be more appropriately attributed to ws_receive_frame if it improperly handles buffer boundaries."
}