{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses conditional compilation to support different pthread extensions, such as pthread_attr_setname_np() with different signatures on NetBSD, OSF1, and IBM i systems. These functions (pthread_attr_setname_np) are non-standard POSIX extensions provided by certain compilers and platforms, which are language/compiler/library extensions beyond standard C. Therefore, the code uses language/compiler/library extensions explicitly as documented, resulting in violation of MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdlib.h>\n\nstatic void log_to_file(const char *message)\n{\n    FILE *fp = fopen(\"/tmp/logs/264.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"%s\\n\", message);\n        fclose(fp);\n    }\n}\n\nint\nMHD_create_named_thread_ (int *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          void *(*start_routine)(void *),\n                          void *arg)\n{\n  int res = 0;\n  pthread_attr_t attr;\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n\n  log_to_file(\"Entering MHD_create_named_thread_: pthread_attr_init\");\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n    /* Only one variant of pthread_attr_setname_np is called here for demo */\n    /* Adjust this accordingly if supporting multiple platforms with macros */\n    log_to_file(\"Calling pthread_attr_setname_np\");\n#ifdef HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD\n    res = pthread_attr_setname_np(&attr, thread_name, 0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np(&attr, thread_name);\n#else\n    /* Assume no pthread_attr_setname_np available, skip setting name */\n    res = 0;\n#endif\n    if ((res == 0) && (0 != stack_size))\n    {\n      log_to_file(\"Setting stack size with pthread_attr_setstacksize\");\n      res = pthread_attr_setstacksize (&attr, stack_size);\n    }\n    if (0 == res)\n    {\n      log_to_file(\"Creating thread with pthread_create\");\n      res = pthread_create (new_tid_ptr, &attr, start_routine, arg);\n    }\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    log_to_file(\"Thread creation failed, setting handle invalid\");\n    /* MHD_thread_handle_ID_set_invalid_ (handle_id); */\n  }\n  else\n  {\n    log_to_file(\"Thread created successfully, setting native handle\");\n    /* MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid); */\n  }\n\n  log_to_file(\"Exiting MHD_create_named_thread_\");\n  return !res;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions should not be used, specifically those that are compiler or language extensions explicitly documented as such by compiler vendors. In the provided code, the use of pthread_attr_setname_np() functions is guarded by preprocessor conditionals that depend on platform-specific macros such as HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD or HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI. These functions are non-standard pthread extensions provided by specific platforms or libraries, not standard ISO C language constructs. Therefore, these represent the use of platform or compiler/library-specific extensions beyond the standard C language, and their use can be considered a violation of MISRA C 2023 Rule 1.2. The agent A's scenario correctly identifies that these pthread non-portable extensions are language/library extensions and thus their presence in the code constitutes a violation of Rule 1.2. Hence, the report is correct."
}