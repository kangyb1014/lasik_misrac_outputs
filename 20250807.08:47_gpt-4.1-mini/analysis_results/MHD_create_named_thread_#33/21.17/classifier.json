{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_create_named_thread_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/271.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_create_named_thread_ as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_create_named_thread_:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_named_thread_:\n#define MHD_thread_handle_ID_set_invalid_(hndl_id_ptr) (MHD_thread_handle_set_invalid_(&((hndl_id_ptr)->handle)),MHD_thread_ID_set_invalid_(&((hndl_id_ptr)->ID)))\n...\n#define MHD_thread_handle_ID_set_native_handle_(hndl_id_ptr, native_val) MHD_thread_handle_set_native_(&((hndl_id_ptr)->handle),native_val)\n...\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n...\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n</additional code>\nJudge whether the above MHD_create_named_thread_ code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "A violation of MISRA C 2023 Rule 21.17 could occur if the string handling function pthread_attr_setname_np is called with a thread_name pointer whose string length exceeds any internal buffer size expected by the implementation, resulting in out-of-bounds access. Since MHD_create_named_thread_ passes thread_name directly to pthread_attr_setname_np without verifying the string length or ensuring it fits the expected bounds, if a too-long thread_name is provided, this can cause accesses beyond the bounds of the string or internal buffers used by pthread_attr_setname_np, violating the rule.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n// Simulated minimal necessary types and functions\ntypedef int MHD_THREAD_START_ROUTINE_(void *);\ntypedef struct {\n  int dummy;\n} MHD_thread_handle_ID_;\n\n// Dummy functions representing missing external functions\nvoid MHD_thread_handle_ID_set_invalid_(MHD_thread_handle_ID_ *handle_id) { (void)handle_id; }\nvoid MHD_thread_handle_ID_set_native_handle_(MHD_thread_handle_ID_ *handle_id, pthread_t native) { (void)handle_id; (void)native; }\n\n// Path to the log file\nstatic const char *log_path = \"/tmp/logs/271.txt\";\n\n// Log helper\nstatic void log_state(const char *msg)\n{\n    FILE *fp = fopen(log_path, \"a\");\n    if (fp)\n    {\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ *start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n\n  log_state(\"MHD_create_named_thread_: started\");\n\n  res = pthread_attr_init(&attr);\n  log_state(\"pthread_attr_init called\");\n  if (res == 0)\n  {\n    // Log length of thread_name\n    char buf[1000];\n    size_t len = strlen(thread_name);\n    snprintf(buf, sizeof(buf), \"thread_name length: %zu\", len);\n    log_state(buf);\n\n    // For testing, call setname with given thread_name\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    res = pthread_attr_setname_np(&attr, thread_name, 0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np(&attr, thread_name);\n#else\n    // Simulating calling pthread_attr_setname_np\n    res = pthread_attr_setname_np(&attr, thread_name);\n#endif\n    snprintf(buf, sizeof(buf), \"pthread_attr_setname_np returned: %d\", res);\n    log_state(buf);\n\n    if ((res == 0) && (stack_size != 0))\n    {\n      res = pthread_attr_setstacksize(&attr, stack_size);\n      snprintf(buf, sizeof(buf), \"pthread_attr_setstacksize returned: %d\", res);\n      log_state(buf);\n    }\n\n    if (res == 0)\n    {\n      res = pthread_create(new_tid_ptr,\n                           &attr,\n                           start_routine,\n                           arg);\n      snprintf(buf, sizeof(buf), \"pthread_create returned: %d\", res);\n      log_state(buf);\n    }\n\n    pthread_attr_destroy(&attr);\n    log_state(\"pthread_attr_destroy called\");\n  }\n\n  if (res != 0)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_(handle_id);\n    log_state(\"Set handle invalid due to error\");\n  }\n  else\n  {\n    MHD_thread_handle_ID_set_native_handle_(handle_id, new_tid);\n    log_state(\"Set native handle after successful create\");\n  }\n\n  log_state(\"MHD_create_named_thread_: exited\");\n  return !res;\n#else\n  // No thread attribute setname support, empty implementation for probe\n  (void)handle_id;\n  (void)thread_name;\n  (void)stack_size;\n  (void)start_routine;\n  (void)arg;\n  return 0;\n#endif\n}\n\n/*\n * The returned logs in /tmp/logs/271.txt will include:\n * - entry and exit points\n * - length of thread_name used in pthread_attr_setname_np\n * - result codes of string functions and pthread_create\n * This allows tracing the scenario when a too long or manipulated string may lead to out-of-bound accesses.\n */"
}