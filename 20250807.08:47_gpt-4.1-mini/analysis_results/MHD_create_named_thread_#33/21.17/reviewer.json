{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation of MISRA C 2023 Rule 21.17 could occur if the string handling function pthread_attr_setname_np is called with a thread_name pointer whose string length exceeds any internal buffer size expected by the implementation, resulting in out-of-bounds access. Since MHD_create_named_thread_ passes thread_name directly to pthread_attr_setname_np without verifying the string length or ensuring it fits the expected bounds, if a too-long thread_name is provided, this can cause accesses beyond the bounds of the string or internal buffers used by pthread_attr_setname_np, violating the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n// Simulated minimal necessary types and functions\ntypedef void *(*MHD_THREAD_START_ROUTINE_)(void *);\ntypedef struct {\n  pthread_t native_handle;\n} MHD_thread_handle_ID_;\n\nvoid MHD_thread_handle_ID_set_invalid_(MHD_thread_handle_ID_ *handle_id) {\n  (void)handle_id;\n}\n\nvoid MHD_thread_handle_ID_set_native_handle_(MHD_thread_handle_ID_ *handle_id, pthread_t native) {\n  handle_id->native_handle = native;\n}\n\n// Path to the log file\nstatic const char *log_path = \"/tmp/logs/271.txt\";\n\n// Log helper\nstatic void log_state(const char *msg)\n{\n    FILE *fp = fopen(log_path, \"a\");\n    if (fp)\n    {\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n\n  log_state(\"MHD_create_named_thread_: started\");\n\n  res = pthread_attr_init(&attr);\n  log_state(\"pthread_attr_init called\");\n  if (res == 0)\n  {\n    char buf[1000];\n    size_t len = strlen(thread_name);\n    snprintf(buf, sizeof(buf), \"thread_name length: %zu\", len);\n    log_state(buf);\n\n  // Attempt to set thread name\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    res = pthread_attr_setname_np(&attr, thread_name, 0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np(&attr, thread_name);\n#else\n    // Since pthread_attr_setname_np is a non-standard extension, it might not exist.\n    // To keep compilable, we skip setting name if not defined.\n    res = 0;\n#endif\n\n    snprintf(buf, sizeof(buf), \"pthread_attr_setname_np returned: %d\", res);\n    log_state(buf);\n\n    if ((res == 0) && (stack_size != 0))\n    {\n      res = pthread_attr_setstacksize(&attr, stack_size);\n      snprintf(buf, sizeof(buf), \"pthread_attr_setstacksize returned: %d\", res);\n      log_state(buf);\n    }\n\n    if (res == 0)\n    {\n      res = pthread_create(new_tid_ptr,\n                           &attr,\n                           start_routine,\n                           arg);\n      snprintf(buf, sizeof(buf), \"pthread_create returned: %d\", res);\n      log_state(buf);\n    }\n\n    pthread_attr_destroy(&attr);\n    log_state(\"pthread_attr_destroy called\");\n  }\n\n  if (res != 0)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_(handle_id);\n    log_state(\"Set handle invalid due to error\");\n  }\n  else\n  {\n    MHD_thread_handle_ID_set_native_handle_(handle_id, new_tid);\n    log_state(\"Set native handle after successful create\");\n  }\n\n  log_state(\"MHD_create_named_thread_: exited\");\n  return !res;\n#else\n  (void)handle_id;\n  (void)thread_name;\n  (void)stack_size;\n  (void)start_routine;\n  (void)arg;\n  return 0;\n#endif\n}\n\n/*\n * The returned logs in /tmp/logs/271.txt will include:\n * - entry and exit points\n * - length of thread_name used in pthread_attr_setname_np\n * - result codes of string functions and pthread_create\n * This allows tracing the scenario when a too long or manipulated string may lead to out-of-bound accesses.\n */\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 requires that the use of string handling functions from <string.h> must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. Here, the key point is that pthread_attr_setname_np is not a standard string handling function from <string.h>, but a pthread extension function that accepts a thread name string. The rule explicitly applies to functions like memcpy, strcpy, strlen, etc., but does not cover pthread functions, even if they accept strings as arguments.\n\nHowever, the agent's scenario is concerned with internal buffer overflows inside pthread_attr_setname_np if an overly long thread_name string is supplied. While the implementation of pthread_attr_setname_np might impose internal limits (e.g., maximum thread name length), this is an issue of API contract or runtime behavior, not a direct application of MISRA C 2023 Rule 21.17, because the rule targets misuse of standard string functions with user pointers, not internal handling of parameters by external library functions.\n\nIn the posted code, thread_name is passed as is to pthread_attr_setname_np without explicit length checks or truncation. Although this might cause runtime errors or failures within the pthread library, it is not a violation of Rule 21.17 because no string handling function from <string.h> is directly used in a way that violates bounds on the application's pointers. Moreover, application code cannot control the internal implementation of pthread_attr_setname_np.\n\nTherefore, the agent's claim that the code violates MISRA C 2023 Rule 21.17 is incorrect. The potential issue is a robustness or API usage concern, not a MISRA C violation related to standard string functions and out-of-bounds accesses at the source code level."
}