{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter_init code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter_init.\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses platform-specific constants such as CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_FAST, CLOCK_MONOTONIC_RAW_APPROX, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_UPTIME, CLOCK_HIGHRES and functions like host_get_clock_service, mach_host_self, clock_get_time, mach_port_deallocate, which are specific to certain platforms and are considered language compiler extensions or system-specific extensions. These identifiers and functions are not part of the standard C language and rely on system-specific extensions, thus violating MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\nstatic int mono_clock_id = _MHD_UNWANTED_CLOCK;\nstatic long mono_clock_start = 0;\nstatic int32_t mono_clock_service = _MHD_INVALID_CLOCK_SERV;\nstatic uint64_t tick_start = 0;\nstatic uint64_t perf_freq = 0;\nstatic uint64_t perf_start = 0;\nstatic uint64_t hrtime_start = 0;\nstatic long gettime_start = 0;\n\nvoid MHD_monotonic_sec_counter_init (void)\n{\n  FILE *log = fopen(\"/tmp/logs/176.txt\", \"w\");\n  if (log == NULL) return;\n\n#if defined(CLOCK_MONOTONIC_COARSE) || defined(CLOCK_MONOTONIC_FAST) \\\n || defined(CLOCK_MONOTONIC_RAW_APPROX) || defined(CLOCK_MONOTONIC_RAW) \\\n || defined(CLOCK_BOOTTIME) || defined(CLOCK_MONOTONIC) || defined(CLOCK_UPTIME) \\\n || defined(CLOCK_HIGHRES)\n  struct timespec ts;\n#endif\n\n  /* Initialize mono_clock_id and mono_clock_source */\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n  mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n\n  /* Check clock_gettime options */\n#if defined(CLOCK_MONOTONIC_COARSE)\n  if (0 == clock_gettime(CLOCK_MONOTONIC_COARSE, &ts))\n  {\n    fprintf(log, \"Using CLOCK_MONOTONIC_COARSE clock source\\n\");\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_MONOTONIC_FAST)\n  if (0 == clock_gettime(CLOCK_MONOTONIC_FAST, &ts))\n  {\n    fprintf(log, \"Using CLOCK_MONOTONIC_FAST clock source\\n\");\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_MONOTONIC_RAW_APPROX)\n  if (0 == clock_gettime(CLOCK_MONOTONIC_RAW_APPROX, &ts))\n  {\n    fprintf(log, \"Using CLOCK_MONOTONIC_RAW_APPROX clock source\\n\");\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_MONOTONIC_RAW)\n  if (0 == clock_gettime(CLOCK_MONOTONIC_RAW, &ts))\n  {\n    fprintf(log, \"Using CLOCK_MONOTONIC_RAW clock source\\n\");\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_BOOTTIME)\n  if (0 == clock_gettime(CLOCK_BOOTTIME, &ts))\n  {\n    fprintf(log, \"Using CLOCK_BOOTTIME clock source\\n\");\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_MONOTONIC)\n  if (0 == clock_gettime(CLOCK_MONOTONIC, &ts))\n  {\n    fprintf(log, \"Using CLOCK_MONOTONIC clock source\\n\");\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_UPTIME)\n  if (0 == clock_gettime(CLOCK_UPTIME, &ts))\n  {\n    fprintf(log, \"Using CLOCK_UPTIME clock source\\n\");\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n#if defined(CLOCK_HIGHRES)\n  if (0 == clock_gettime(CLOCK_HIGHRES, &ts))\n  {\n    fprintf(log, \"Using Solaris CLOCK_HIGHRES clock source\\n\");\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif\n\n  /* Fallback to gettimeofday */\n  {\n    struct timeval tv;\n    if (0 == gettimeofday(&tv, NULL))\n    {\n      fprintf(log, \"Using gettimeofday fallback clock source\\n\");\n      mono_clock_start = tv.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n    else\n    {\n      fprintf(log, \"No suitable clock source found\\n\");\n      mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    }\n  }\n\n  /* Setup other timing values */\n#if defined(HAVE_TIMESPEC_GET)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get(&tsg, TIME_UTC))\n    {\n      gettime_start = tsg.tv_sec;\n      fprintf(log, \"Using timespec_get start time: %ld\\n\", gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      fprintf(log, \"Failed timespec_get\\n\");\n    }\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday(&tv, NULL))\n    {\n      gettime_start = tv.tv_sec;\n      fprintf(log, \"Using gettimeofday start time: %ld\\n\", gettime_start);\n    }\n    else\n    {\n      gettime_start = 0;\n      fprintf(log, \"Failed gettimeofday\\n\");\n    }\n  }\n#endif\n\n  sys_clock_start = time(NULL);\n  fprintf(log, \"System time start: %ld\\n\", sys_clock_start);\n\n  fclose(log);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions beyond the standard C language should not be used, specifically those explicitly documented as compiler extensions. The provided code makes extensive use of platform-specific APIs and constants such as CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_FAST, host_get_clock_service, mach_host_self, and Windows APIs like GetTickCount64. These are not part of the standard C language; rather, they are system-specific calls provided by the underlying OS and its libraries. However, MISRA C Rule 1.2 is concerned with language compiler extensions, not OS or library APIs, which are outside the scope of the C language itself. The use of platform-specific APIs and constants is common in portable code guarded by #ifdef directives; while such usage may pose portability concerns, it is not considered a violation of MISRA Rule 1.2 unless the compiler introduces language extensions beyond the standard. Therefore, the agent A's report\u2014that the code violates MISRA C 2023 Rule 1.2 because of these system-specific constants and functions\u2014is not correct, since these do not represent compiler language extensions but platform-dependent APIs. Additionally, the test code provided by agent A failed to compile, indicating possible issues with the test environment or definitions, but this does not prove a violation of Rule 1.2. Hence, the claim is incorrect regarding MISRA Rule 1.2 violation."
}