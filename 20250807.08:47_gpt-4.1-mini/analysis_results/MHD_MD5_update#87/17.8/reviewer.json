{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the function MHD_MD5_update, the parameter 'data' is a pointer to constant uint8_t data (const uint8_t *data). The code modifies the pointer 'data' itself by incrementing it (e.g., data += bytes_left; data += MD5_BLOCK_SIZE;), which violates MISRA C 2023 Rule 17.8 that states that a function parameter should not be modified. Although the data pointed by 'data' is const, the pointer parameter itself must not be altered inside the function. This modification of the pointer parameter 'data' is a violation scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void md5_transform(uint32_t H[4], const void *M) { /* body omitted */ (void)H; (void)M; }\nvoid MHD_MD5_update (struct Md5Ctx *ctx,\n                     const uint8_t *data,\n                     size_t length)\n{\n  FILE *log_file = fopen(\"/tmp/logs/701.txt\", \"a\");\n  unsigned int bytes_have; /* Number of bytes in the context buffer */\n  const uint8_t *current_data = data;\n  size_t current_length = length;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Entered MHD_MD5_update: length=%zu\\n\", length);\n  }\n\n  if ((current_data != NULL) || (current_length == 0))\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Assertion passed: data not NULL or zero length\\n\");\n    }\n  }\n  else\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Assertion failed: data is NULL and length non-zero\\n\");\n    }\n  }\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == current_length)\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Shortcut: length is zero, return early\\n\");\n      fclose(log_file);\n    }\n    return; /* Shortcut, do nothing */\n  }\n#endif\n\n  bytes_have = (unsigned int)(ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += current_length;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"ctx->count updated to %llu, bytes_have=%u\\n\",\n            (unsigned long long)ctx->count, bytes_have);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n\n    if (current_length >= bytes_left)\n    { /* Combine new data with data in the buffer and process the full block. */\n      memcpy(((uint8_t *)ctx->buffer) + bytes_have, current_data, bytes_left);\n\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"Data combined for full block: copying %u bytes\\n\", bytes_left);\n      }\n\n      current_data += bytes_left;\n      current_length -= bytes_left;\n\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"Pointer 'current_data' modified: advanced by %u bytes, new length=%zu\\n\", bytes_left, current_length);\n      }\n\n      md5_transform(ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= current_length)\n  { /* Process full blocks without copying. */\n    md5_transform(ctx->H, current_data);\n\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Processing full MD5 block directly\\n\");\n    }\n\n    current_data += MD5_BLOCK_SIZE;\n    current_length -= MD5_BLOCK_SIZE;\n\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Pointer 'current_data' modified in loop, length now %zu\\n\", current_length);\n    }\n  }\n\n  if (0 != current_length)\n  { /* Copy incomplete block to buffer. */\n    memcpy(((uint8_t *)ctx->buffer) + bytes_have, current_data, current_length);\n\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Copying incomplete block of %zu bytes to buffer\\n\", current_length);\n    }\n  }\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Exiting MHD_MD5_update\\n\");\n    fclose(log_file);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter should not be modified. However, this rule specifically refers to the parameter itself as an entity \u2014 i.e., the identifier representing the parameter. It does not forbid modifying the object pointed to by a pointer parameter (which in this case is declared as const, so the data pointed to is not modified). In the provided code, the parameter 'data' is a pointer to const data, and the code modifies the pointer 'data' itself by incrementing it (e.g., data += bytes_left;). This constitutes modifying the parameter 'data'. According to Rule 17.8, this is a violation. The rule is explicit that although the object pointed to may be modified, the pointer parameter itself shall not be modified. The agent's scenario correctly identifies that 'data' is a pointer parameter that is modified by arithmetic operations, which violates the rule. The modified test code attempts to avoid this by copying 'data' to 'current_data' and modifying 'current_data' instead, which is the proper approach to avoid this violation. The failure to compile the test code does not invalidate the conceptual correctness of the violation reported. Therefore, the agent A's report correctly identifies the violation of MISRA C 2023 Rule 17.8 in the original MHD_MD5_update function where the pointer parameter 'data' is modified inside the function body."
}