{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the 'length' parameter passed to MHD_MD5_update is larger than the available space left in ctx->buffer plus any remaining data in the buffer, and data points to a buffer smaller than 'length', the memcpy calls can access beyond the bounds of the source buffer 'data', violating Rule 21.17. Although the function updates 'data' and 'length' carefully, if the input buffer 'data' itself is smaller than declared 'length', this can cause out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid md5_transform(uint32_t H[4], const uint8_t *data)\n{\n  // Stub: just log transform call\n  FILE *fp = fopen(\"/tmp/logs/703.txt\", \"a\");\n  if(fp) {\n    fprintf(fp, \"md5_transform called with data at %p\\n\", data);\n    fclose(fp);\n  }\n}\nvoid MHD_MD5_update (struct Md5Ctx *ctx,\n                    const uint8_t *data,\n                    size_t length)\n{\n  unsigned int bytes_have;\n  FILE *fp = fopen(\"/tmp/logs/703.txt\", \"a\");\n  if(fp) {\n    fprintf(fp, \"MHD_MD5_update called with ctx=%p, data=%p, length=%zu\\n\", (void*)ctx, (void*)data, length);\n    fprintf(fp, \"Initial ctx->count=%llu\\n\", (unsigned long long)ctx->count);\n  }\n\n  // mhd_assert replaced by runtime check and log\n  if (!((data != NULL) || (length == 0))) {\n    if(fp) fprintf(fp, \"Assertion failure: data==NULL and length!=0\\n\");\n    if(fp) fclose(fp);\n    return;\n  }\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length) {\n    if(fp) {\n      fprintf(fp, \"Length is zero, return early\\n\");\n      fclose(fp);\n    }\n    return;\n  }\n#endif\n\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if(fp) fprintf(fp, \"Computed bytes_have=%u, updated ctx->count=%llu\\n\", bytes_have, (unsigned long long)ctx->count);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {\n      if(fp) fprintf(fp, \"Copying %u bytes to complete buffer\\n\", bytes_left);\n      memcpy(((uint8_t *) ctx->buffer) + bytes_have, data, bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      if(fp) fprintf(fp, \"Calling md5_transform on full buffer after copy\\n\");\n      md5_transform(ctx->H, (uint8_t *)ctx->buffer);\n      bytes_have = 0;\n    }\n    else {\n      if(fp) fprintf(fp, \"Not enough data to fill the buffer\\n\");\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {\n    if(fp) fprintf(fp, \"Calling md5_transform on data block of size %d bytes\\n\", MD5_BLOCK_SIZE);\n    md5_transform(ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {\n    if(fp) fprintf(fp, \"Copying remaining %zu bytes to buffer at offset %u\\n\", length, bytes_have);\n    memcpy(((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n\n  if(fp) fclose(fp);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The scenario provided by Agent A states that if the 'length' parameter is larger than the actual size of the source buffer pointed by 'data', the calls to memcpy() in MHD_MD5_update may result in out-of-bounds accesses, thereby violating MISRA C 2023 Rule 21.17. The rule mandates that string handling functions from <string.h> must not access beyond the bounds of their pointer parameters. The code assumes that the caller supplies a valid 'data' buffer of at least 'length' bytes. However, this is a precondition that the function does not verify internally. If the caller violates this precondition, out-of-bounds access may occur. This violation is not due to the function's internal logic but due to incorrect usage or contract breach by the caller. MISRA Rule 21.17 is about ensuring functions do not themselves perform out-of-bounds accesses. Given that MHD_MD5_update performs memcpy() with 'length' and carefully updates pointers, and given that it relies on the caller's guaranteeing correct 'length' and buffer size, the function itself does not inherently violate Rule 21.17. The provided test with added logging does not demonstrate an internal flaw or unsafe memcpy usage in the function. Therefore, the report is not correct because the violation arises from external misuse, not from the function implementation violating the rule internally."
}