{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_ready_chunked_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/767.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_ready_chunked_body as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_ready_chunked_body:\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_chunked_body:\n#define mhd_assert(ignore) ((void)0)\n...\n#define CONNECTION_CLOSE_ERROR(c, emsg) connection_close_error(c,emsg)\n...\nsize_t\nMHD_pool_get_free (struct MemoryPool *pool)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#ifdef MHD_ASAN_POISON_ACTIVE\n  if ((pool->end - pool->pos) <= _MHD_RED_ZONE_SIZE)\n    return 0;\n#endif /* MHD_ASAN_POISON_ACTIVE */\n  return (pool->end - pool->pos) - _MHD_RED_ZONE_SIZE;\n}\n...\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n...\nsize_t\nMHD_uint32_to_strx (uint32_t val,\n                    char *buf,\n                    size_t buf_size)\n{\n  size_t o_pos = 0; /**< position of the output character */\n  int digit_pos = 8; /** zero-based, digit position in @a 'val' */\n  int digit;\n\n  /* Skip leading zeros */\n  do\n  {\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  } while ((0 == digit) && (0 != digit_pos));\n\n  while (o_pos < buf_size)\n  {\n    buf[o_pos++] =\n      (char) ((digit <= 9) ?\n              ('0' + (char) digit) :\n              ('A' + (char) digit - 10));\n    if (0 == digit_pos)\n      return o_pos;\n    digit_pos--;\n    digit = (int) (val >> 28);\n    val <<= 4;\n  }\n  return 0; /* The buffer is too small */\n}\n</additional code>\nJudge whether the above try_ready_chunked_body code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function try_ready_chunked_body uses memcpy to copy data into connection->write_buffer at certain offsets, including 'max_chunk_hdr_len' and 'connection->write_buffer_send_offset'. If the calculation of these offsets combined with the size of the copied data exceeds 'connection->write_buffer_size', memcpy could access beyond the buffer boundaries, violating Rule 21.17. For example, if ret (the amount of data copied) is larger than expected but size_to_fill and buffer size were incorrectly calculated or not properly guarded, this could happen. The function has assertions and checks on sizes, but potential boundary errors exist if left_to_send or data_size calculations are incorrect, or if connection->write_buffer_size is smaller than max_chunk_overhead plus the data to copy, leading to out-of-bound memcpy access.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n\n// Forward declarations of structs and enums\nstruct MHD_Response {\n    const char *crc_cls;\n    ssize_t (*crc)(const char *, size_t, void *, size_t);\n    uint64_t total_size;\n    size_t data_start;\n    size_t data_size;\n    const char *data;\n    void *mutex;\n};\n\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0, MHD_CONTENT_READER_END_OF_STREAM = -1, MHD_CONTENT_READER_END_WITH_ERROR = -2 };\n\nstruct MHD_Connection {\n    struct MHD_Response *rp_response;\n    struct MHD_Response *rp_response_alias; // For direct access\n    size_t write_buffer_size;\n    char *write_buffer;\n    size_t write_buffer_append_offset;\n    size_t write_buffer_send_offset;\n    uint64_t rp_rsp_write_position;\n    enum { MHD_CONNECTION_CHUNKED_BODY_UNREADY } state;\n    struct MemoryPool *pool;\n    struct {\n        struct MHD_Response *response;\n        uint64_t rsp_write_position;\n    } rp;\n};\n\n// Dummy definition for MemoryPool\nstruct MemoryPool {\n    size_t size;\n    size_t pos;\n    uint8_t *memory;\n    size_t end;\n};\n\n// Dummy assertions and macros\n#define mhd_assert(ignore) ((void)0)\n#define CONNECTION_CLOSE_ERROR(c, emsg) connection_close_error(c, emsg)\n\n// Dummy implementations to allow logging\nstatic FILE *log_fp = NULL;\n\nstatic void log_probe(const char *msg)\n{\n    if (!log_fp)\n        log_fp = fopen(\"/tmp/logs/767.txt\", \"a\");\n    if (log_fp)\n    {\n        fprintf(log_fp, \"%s\\n\", msg);\n        fflush(log_fp);\n    }\n}\n\nstatic void connection_close_error(struct MHD_Connection *connection, const char *emsg)\n{\n    log_probe(\"CONNECTION_CLOSE_ERROR called\");\n    log_probe(emsg);\n}\n\nsize_t MHD_pool_get_free(struct MemoryPool *pool) { return 1000; }\nchar *MHD_pool_reallocate(struct MemoryPool *pool, char *old, size_t old_size, size_t new_size) { return old; }\nsize_t MHD_uint32_to_strx(uint32_t val, char *buf, size_t buf_size) { return 6; }\n\n// Modified try_ready_chunked_body with logging to track control path and state\nenum MHD_Result try_ready_chunked_body(struct MHD_Connection *connection,\n                                      bool *p_finished)\n{\n    ssize_t ret;\n    struct MHD_Response *response;\n    static const size_t max_chunk = 0xFFFFFF;\n    char chunk_hdr[6];\n    static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n    static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n    size_t chunk_hdr_len;\n    uint64_t left_to_send;\n    size_t size_to_fill;\n\n    response = connection->rp.response;\n    mhd_assert(NULL != response->crc || NULL != response->data);\n\n    mhd_assert(0 == connection->write_buffer_append_offset);\n\n    /* Log entry into function */\n    log_probe(\"try_ready_chunked_body: entered\");\n\n    if (128 > connection->write_buffer_size)\n    {\n        size_t size;\n\n        size = connection->write_buffer_size + MHD_pool_get_free(connection->pool);\n        if (128 > size)\n        {\n            log_probe(\"Insufficient memory for write_buffer\");\n            CONNECTION_CLOSE_ERROR(connection, \"Closing connection (out of memory).\");\n            return MHD_NO;\n        }\n        if ((max_chunk + max_chunk_overhead) < size)\n            size = max_chunk + max_chunk_overhead;\n\n        connection->write_buffer =\n            MHD_pool_reallocate(connection->pool,\n                                connection->write_buffer,\n                                connection->write_buffer_size,\n                                size);\n        mhd_assert(NULL != connection->write_buffer);\n        connection->write_buffer_size = size;\n\n        char buf[128];\n        snprintf(buf, sizeof(buf),\n                 \"Reallocated buffer to size: %zu\", connection->write_buffer_size);\n        log_probe(buf);\n    }\n\n    mhd_assert(max_chunk_overhead < connection->write_buffer_size);\n\n    if (MHD_SIZE_UNKNOWN == response->total_size)\n        left_to_send = MHD_SIZE_UNKNOWN;\n    else\n        left_to_send = response->total_size - connection->rp.rsp_write_position;\n\n    size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n    if (max_chunk < size_to_fill)\n        size_to_fill = max_chunk;\n    if (left_to_send < size_to_fill)\n        size_to_fill = (size_t) left_to_send;\n\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"left_to_send: %llu, size_to_fill: %zu\",\n                 (unsigned long long)left_to_send, size_to_fill);\n        log_probe(buf);\n    }\n\n    if (0 == left_to_send)\n    {\n        ret = MHD_CONTENT_READER_END_OF_STREAM;\n        log_probe(\"left_to_send == 0: end of stream\");\n    }\n    else if ((response->data_start <= connection->rp.rsp_write_position) &&\n             (response->data_start + response->data_size > connection->rp.rsp_write_position))\n    {\n        const size_t data_write_offset = (size_t)(connection->rp.rsp_write_position - response->data_start);\n        mhd_assert(SSIZE_MAX >= (response->data_size - data_write_offset));\n        mhd_assert(response->data_size >= data_write_offset);\n        ret = (ssize_t)(response->data_size - data_write_offset);\n        if (((size_t)ret) > size_to_fill)\n            ret = (ssize_t)size_to_fill;\n\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"Copying data offset: %zu, size: %zu\", data_write_offset, (size_t)ret);\n            log_probe(buf);\n        }\n\n        // Boundary check to avoid violation\n        if ((max_chunk_hdr_len + (size_t)ret) > connection->write_buffer_size) {\n            log_probe(\"ERROR: memcpy beyond buffer bounds detected\");\n            CONNECTION_CLOSE_ERROR(connection, \"Closing connection (buffer overflow risk in memcpy).\");\n            return MHD_NO;\n        }\n\n        memcpy(&connection->write_buffer[max_chunk_hdr_len],\n               &response->data[data_write_offset],\n               (size_t)ret);\n    }\n    else\n    {\n        if (NULL == response->crc)\n        {\n            CONNECTION_CLOSE_ERROR(connection, \"No callback for the chunked data.\");\n            return MHD_NO;\n        }\n        ret = response->crc(response->crc_cls,\n                           connection->rp.rsp_write_position,\n                           &connection->write_buffer[max_chunk_hdr_len],\n                           size_to_fill);\n    }\n\n    if (ret == MHD_CONTENT_READER_END_WITH_ERROR)\n    {\n        response->total_size = connection->rp.rsp_write_position;\n        CONNECTION_CLOSE_ERROR(connection,\"Closing connection (application error generating response).\");\n        return MHD_NO;\n    }\n    if (ret == MHD_CONTENT_READER_END_OF_STREAM)\n    {\n        *p_finished = true;\n        response->total_size = connection->rp.rsp_write_position;\n        return MHD_YES;\n    }\n    if (ret == 0)\n    {\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        return MHD_NO;\n    }\n\n    if (size_to_fill < (size_t)ret)\n    {\n        CONNECTION_CLOSE_ERROR(connection, \"Application returned more data than requested.\");\n        return MHD_NO;\n    }\n\n    chunk_hdr_len = MHD_uint32_to_strx((uint32_t)ret, chunk_hdr, sizeof(chunk_hdr));\n    mhd_assert(chunk_hdr_len != 0);\n    mhd_assert(chunk_hdr_len < sizeof(chunk_hdr));\n\n    *p_finished = false;\n    connection->write_buffer_send_offset = (max_chunk_hdr_len - (chunk_hdr_len + 2));\n\n    // Check memcpy bounds for header copy\n    if ((connection->write_buffer_send_offset + chunk_hdr_len) > connection->write_buffer_size) {\n        log_probe(\"ERROR: Chunk header memcpy out of bounds\");\n        CONNECTION_CLOSE_ERROR(connection,\"Closing connection (chunk header memcpy out of bounds).\");\n        return MHD_NO;\n    }\n\n    memcpy(connection->write_buffer + connection->write_buffer_send_offset,\n           chunk_hdr,\n           chunk_hdr_len);\n\n    connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n\n    // Check bounds for trailing '\\r\\n'\n    if ((max_chunk_hdr_len + (size_t)ret + 1) >= connection->write_buffer_size) {\n        log_probe(\"ERROR: Trailing CRLF write out of buffer bounds\");\n        CONNECTION_CLOSE_ERROR(connection,\"Closing connection (trailing CRLF out of buffer bounds).\");\n        return MHD_NO;\n    }\n\n    connection->write_buffer[max_chunk_hdr_len + (size_t)ret] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len + (size_t)ret + 1] = '\\n';\n\n    connection->rp.rsp_write_position += (size_t)ret;\n    connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t)ret + 2;\n\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"Finished chunk: data length %zd, new write pos: %llu\", ret, (unsigned long long)connection->rp.rsp_write_position);\n        log_probe(buf);\n    }\n\n    return MHD_YES;\n}\n"
}