{
  "user_message": "An agent A claimed that the following try_ready_chunked_body code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_chunked_body.\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function try_ready_chunked_body uses memcpy to copy data into connection->write_buffer at certain offsets, including 'max_chunk_hdr_len' and 'connection->write_buffer_send_offset'. If the calculation of these offsets combined with the size of the copied data exceeds 'connection->write_buffer_size', memcpy could access beyond the buffer boundaries, violating Rule 21.17. For example, if ret (the amount of data copied) is larger than expected but size_to_fill and buffer size were incorrectly calculated or not properly guarded, this could happen. The function has assertions and checks on sizes, but potential boundary errors exist if left_to_send or data_size calculations are incorrect, or if connection->write_buffer_size is smaller than max_chunk_overhead plus the data to copy, leading to out-of-bound memcpy access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct RP {\n    struct MHD_Response *response;\n    uint64_t rsp_write_position;\n};\nvoid mhd_assert(int expr) { (void)expr; }\nstatic FILE *log_fp = NULL;\nstatic void log_probe(const char *msg)\n{\n    if (!log_fp)\n        log_fp = fopen(\"/tmp/logs/767.txt\", \"a\");\n    if (log_fp)\n    {\n        fprintf(log_fp, \"%s\\n\", msg);\n        fflush(log_fp);\n    }\n}\n\nstatic void connection_close_error(struct MHD_Connection *connection, const char *emsg)\n{\n    (void)connection;\n    log_probe(\"CONNECTION_CLOSE_ERROR called\");\n    log_probe(emsg);\n}\nenum MHD_Result try_ready_chunked_body(struct MHD_Connection *connection,\n                                      bool *p_finished)\n{\n    ssize_t ret;\n    struct MHD_Response *response;\n    static const size_t max_chunk = 0xFFFFFF;\n    char chunk_hdr[6];\n    static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n    static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n    size_t chunk_hdr_len;\n    uint64_t left_to_send;\n    size_t size_to_fill;\n\n    response = connection->rp.response;\n    mhd_assert(NULL != response->crc || NULL != response->data);\n\n    mhd_assert(0 == connection->write_buffer_append_offset);\n\n    /* Log entry into function */\n    log_probe(\"try_ready_chunked_body: entered\");\n\n    if (128 > connection->write_buffer_size)\n    {\n        size_t size;\n\n        size = connection->write_buffer_size + MHD_pool_get_free(connection->pool);\n        if (128 > size)\n        {\n            log_probe(\"Insufficient memory for write_buffer\");\n            connection_close_error(connection, \"Closing connection (out of memory).\");\n            return MHD_NO;\n        }\n        if ((max_chunk + max_chunk_overhead) < size)\n            size = max_chunk + max_chunk_overhead;\n\n        connection->write_buffer =\n            MHD_pool_reallocate(connection->pool,\n                                connection->write_buffer,\n                                connection->write_buffer_size,\n                                size);\n        mhd_assert(NULL != connection->write_buffer);\n        connection->write_buffer_size = size;\n\n        char buf[128];\n        snprintf(buf, sizeof(buf),\n                 \"Reallocated buffer to size: %zu\", connection->write_buffer_size);\n        log_probe(buf);\n    }\n\n    mhd_assert(max_chunk_overhead < connection->write_buffer_size);\n\n    if (MHD_SIZE_UNKNOWN == response->total_size)\n        left_to_send = MHD_SIZE_UNKNOWN;\n    else\n        left_to_send = response->total_size - connection->rp.rsp_write_position;\n\n    size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n    if (max_chunk < size_to_fill)\n        size_to_fill = max_chunk;\n    if (left_to_send < size_to_fill)\n        size_to_fill = (size_t) left_to_send;\n\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"left_to_send: %llu, size_to_fill: %zu\",\n                 (unsigned long long)left_to_send, size_to_fill);\n        log_probe(buf);\n    }\n\n    if (0 == left_to_send)\n    {\n        ret = MHD_CONTENT_READER_END_OF_STREAM;\n        log_probe(\"left_to_send == 0: end of stream\");\n    }\n    else if ((response->data_start <= connection->rp.rsp_write_position) &&\n             (response->data_start + response->data_size > connection->rp.rsp_write_position))\n    {\n        const size_t data_write_offset = (size_t)(connection->rp.rsp_write_position - response->data_start);\n        mhd_assert(SSIZE_MAX >= (response->data_size - data_write_offset));\n        mhd_assert(response->data_size >= data_write_offset);\n        ret = (ssize_t)(response->data_size - data_write_offset);\n        if (((size_t)ret) > size_to_fill)\n            ret = (ssize_t)size_to_fill;\n\n        {\n            char buf[256];\n            snprintf(buf, sizeof(buf), \"Copying data offset: %zu, size: %zu\", data_write_offset, (size_t)ret);\n            log_probe(buf);\n        }\n\n        // Boundary check to avoid violation\n        if ((max_chunk_hdr_len + (size_t)ret) > connection->write_buffer_size) {\n            log_probe(\"ERROR: memcpy beyond buffer bounds detected\");\n            connection_close_error(connection, \"Closing connection (buffer overflow risk in memcpy).\");\n            return MHD_NO;\n        }\n\n        memcpy(&connection->write_buffer[max_chunk_hdr_len],\n               &response->data[data_write_offset],\n               (size_t)ret);\n    }\n    else\n    {\n        if (NULL == response->crc)\n        {\n            connection_close_error(connection, \"No callback for the chunked data.\");\n            return MHD_NO;\n        }\n        ret = response->crc(response->crc_cls,\n                           connection->rp.rsp_write_position,\n                           &connection->write_buffer[max_chunk_hdr_len],\n                           size_to_fill);\n    }\n\n    if (ret == MHD_CONTENT_READER_END_WITH_ERROR)\n    {\n        response->total_size = connection->rp.rsp_write_position;\n        connection_close_error(connection,\"Closing connection (application error generating response).\");\n        return MHD_NO;\n    }\n    if (ret == MHD_CONTENT_READER_END_OF_STREAM)\n    {\n        *p_finished = true;\n        response->total_size = connection->rp.rsp_write_position;\n        return MHD_YES;\n    }\n    if (ret == 0)\n    {\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        return MHD_NO;\n    }\n\n    if (size_to_fill < (size_t)ret)\n    {\n        connection_close_error(connection, \"Application returned more data than requested.\");\n        return MHD_NO;\n    }\n\n    chunk_hdr_len = MHD_uint32_to_strx((uint32_t)ret, chunk_hdr, sizeof(chunk_hdr));\n    mhd_assert(chunk_hdr_len != 0);\n    mhd_assert(chunk_hdr_len < sizeof(chunk_hdr));\n\n    *p_finished = false;\n    if (max_chunk_hdr_len < (chunk_hdr_len + 2)) {\n        connection_close_error(connection, \"Chunk header length too long.\");\n        return MHD_NO;\n    }\n    connection->write_buffer_send_offset = (max_chunk_hdr_len - (chunk_hdr_len + 2));\n\n    // Check memcpy bounds for header copy\n    if ((connection->write_buffer_send_offset + chunk_hdr_len) > connection->write_buffer_size) {\n        log_probe(\"ERROR: Chunk header memcpy out of bounds\");\n        connection_close_error(connection,\"Closing connection (chunk header memcpy out of bounds).\");\n        return MHD_NO;\n    }\n\n    memcpy(connection->write_buffer + connection->write_buffer_send_offset,\n           chunk_hdr,\n           chunk_hdr_len);\n\n    connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n\n    // Check bounds for trailing '\\r\\n'\n    if ((max_chunk_hdr_len + (size_t)ret + 1) >= connection->write_buffer_size) {\n        log_probe(\"ERROR: Trailing CRLF write out of buffer bounds\");\n        connection_close_error(connection,\"Closing connection (trailing CRLF out of buffer bounds).\");\n        return MHD_NO;\n    }\n\n    connection->write_buffer[max_chunk_hdr_len + (size_t)ret] = '\\r';\n    connection->write_buffer[max_chunk_hdr_len + (size_t)ret + 1] = '\\n';\n\n    connection->rp.rsp_write_position += (size_t)ret;\n    connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t)ret + 2;\n\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"Finished chunk: data length %zd, new write pos: %llu\", ret, (unsigned long long)connection->rp.rsp_write_position);\n        log_probe(buf);\n    }\n\n    return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 requires that the use of string handling functions like memcpy must not access beyond the boundaries of the buffers involved. In the provided function try_ready_chunked_body, memcpy is used several times to copy data into connection->write_buffer at calculated offsets such as max_chunk_hdr_len and connection->write_buffer_send_offset. The code contains multiple assertions and runtime checks aiming to ensure that these offsets and lengths are within the bounds of connection->write_buffer_size. For example, before memcpy calls, there are mhd_assert statements verifying buffer size constraints and logic limiting size_to_fill and ret values to avoid buffer overflows. The agent A's scenario highlights a potential risk if these calculations or conditions are incorrect or if left_to_send or data_size calculations underflow or overflow, causing memcpy to access beyond the buffer. However, the function's logic carefully manages these size variables, clamps values to safe limits, and asserts invariants to prevent this. The agent A\u2019s supplied test code tries to detect such out-of-bounds accesses and prevent them, but it failed to compile, and no runtime evidence was obtained. Without concrete evidence or execution traces showing buffer overruns, the claims remain hypothetical. Therefore, while hypothetically possible in case of bugs in size calculations, the current code correctly guards the memcpy usage, and hence it does not violate MISRA C 2023 Rule 21.17 in its given form. Thus, the agent A report about violation is not correct based on the provided code and information."
}