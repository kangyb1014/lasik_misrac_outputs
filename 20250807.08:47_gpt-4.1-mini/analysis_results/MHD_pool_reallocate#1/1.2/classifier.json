{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_pool_reallocate code that contains useful probe functions that print useful logs to a file \"/tmp/logs/8.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_pool_reallocate as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_pool_reallocate:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_reallocate:\n#define mhd_assert(ignore) ((void)0)\n...\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n...\n#define ROUND_TO_ALIGN_PLUS_RED_ZONE(n) ROUND_TO_ALIGN(n)\n...\n#define mp_ptr_diff_(p1, p2) ((size_t)(((constuint8_t*)(p1))-((constuint8_t*)(p2))))\n...\n#define mp_ptr_le_(p1, p2) (((constuint8_t*)(p1))<=((constuint8_t*)(p2)))\n...\n#define _MHD_RED_ZONE_SIZE (0)\n...\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n...\n#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0\n</additional code>\nJudge whether the above MHD_pool_reallocate code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "Use of compiler-specific built-in function __asan_region_is_poisoned, which is a language extension active only when both MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED are defined. This function is an example of a language extension as it is a compiler/analysis tool specific intrinsic not part of standard C.",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nstruct MemoryPool {\n  uint8_t *memory;\n  size_t size;\n  size_t pos;\n  size_t end;\n};\n\n// Stub definitions for macros and functions\n#define mhd_assert(ignore) ((void)0)\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n#define ROUND_TO_ALIGN_PLUS_RED_ZONE(n) ROUND_TO_ALIGN(n)\n#define mp_ptr_diff_(p1, p2) ((size_t)(((const uint8_t*)(p1))-((const uint8_t*)(p2))))\n#define mp_ptr_le_(p1, p2) (((const uint8_t*)(p1))<=((const uint8_t*)(p2)))\n#define _MHD_RED_ZONE_SIZE (0)\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0\n\n#define ALIGN_SIZE (8)\n\n// Declare __asan_region_is_poisoned as external compiler intrinsic\n// Here we simulate it as a stub returning NULL (no poison)\nvoid* __asan_region_is_poisoned(void* ptr, size_t size) {\n  return NULL;\n}\n\n// Modified MHD_pool_reallocate with probe logging for the violation scenario\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  FILE *log = fopen(\"/tmp/logs/8.txt\", \"a\");\n  if (log != NULL) {\n    fprintf(log, \"MHD_pool_reallocate called: pool=%p old=%p old_size=%zu new_size=%zu\\n\", (void*)pool, old, old_size, new_size);\n  }\n\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  if (log != NULL) {\n    fprintf(log, \"Checking __asan_region_is_poisoned for old=%p size=%zu\\n\", old, old_size);\n  }\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n  if (log != NULL) {\n    fprintf(log, \"__asan_region_is_poisoned check passed\\n\");\n  }\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (old != NULL)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert ((old_size == 0) || (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    if (log != NULL) {\n      fprintf(log, \"Old block info: old_offset=%zu shrinking=%d\\n\", old_offset, shrinking);\n    }\n\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      if (log != NULL) {\n        fprintf(log, \"Shrinking in place: zeroed and poisoned bytes from %zu to %zu\\n\", new_size, old_size);\n      }\n    }\n    if (pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos = ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (!shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ((new_apos > pool->end) || (new_apos < pool->pos))\n        {\n          if (log != NULL) {\n            fprintf(log, \"No space to grow in-place: new_apos=%zu pool->end=%zu pool->pos=%zu\\n\", new_apos, pool->end, pool->pos);\n          }\n          fclose(log);\n          return NULL;                /* No space */\n        }\n      }\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n\n      if (log != NULL) {\n        fprintf(log, \"Resized in-place: new pos=%zu\\n\", pool->pos);\n      }\n\n      fclose(log);\n      return old;\n    }\n    if (shrinking)\n    {\n      if (log != NULL) {\n        fprintf(log, \"Shrinking returns old block without moving\\n\");\n      }\n      fclose(log);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if (((0 == asize) && (0 != new_size)) || (asize > pool->end - pool->pos))\n  {\n    if (log != NULL) {\n      fprintf(log, \"Allocation failed: asize=%zu space left=%zu\\n\", asize, pool->end - pool->pos);\n    }\n    fclose(log);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    memcpy (new_blc, old, old_size);\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    if (log != NULL) {\n      fprintf(log, \"Moved data to new block; old block zeroed and poisoned\\n\");\n    }\n  }\n\n  if (log != NULL) {\n    fprintf(log, \"New block allocated at: %p\\n\", (void *)new_blc);\n    fclose(log);\n  }\n\n  return new_blc;\n}\n"
}