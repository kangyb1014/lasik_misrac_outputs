{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of compiler-specific built-in function __asan_region_is_poisoned, which is a language extension active only when both MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED are defined. This function is an example of a language extension as it is a compiler/analysis tool specific intrinsic not part of standard C.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nvoid* __asan_region_is_poisoned(void* ptr, size_t size) {\n    return NULL;\n}\nvoid mhd_assert(bool expression) {\n    if (!expression) {\n        fprintf(stderr, \"Assertion failed\\n\");\n        // In production code, might abort or handle differently\n    }\n}\nsize_t ROUND_TO_ALIGN(size_t val) {\n    const size_t ALIGN = 8;\n    return (val + (ALIGN - 1)) & ~(ALIGN - 1);\n}\nsize_t ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t val) {\n    const size_t RED_ZONE = 16;\n    return ROUND_TO_ALIGN(val) + RED_ZONE;\n}\nvoid _MHD_POISON_MEMORY(void* mem, size_t size) {\n    (void)mem; (void)size;\n    // No-op in this dummy implementation\n}\nvoid _MHD_UNPOISON_MEMORY(void* mem, size_t size) {\n    (void)mem; (void)size;\n    // No-op in this dummy implementation\n}\nsize_t mp_ptr_diff_(void* a, void* b) {\n    return (size_t)((uint8_t*)a - (uint8_t*)b);\n}\nbool mp_ptr_le_(void* a, void* b) {\n    return a <= b;\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  FILE *log = fopen(\"/tmp/logs/8.txt\", \"a\");\n  if (log != NULL) {\n    fprintf(log, \"MHD_pool_reallocate called: pool=%p old=%p old_size=%zu new_size=%zu\\n\", (void*)pool, old, old_size, new_size);\n  }\n\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  if (log != NULL) {\n    fprintf(log, \"Checking __asan_region_is_poisoned for old=%p size=%zu\\n\", old, old_size);\n  }\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n  if (log != NULL) {\n    fprintf(log, \"__asan_region_is_poisoned check passed\\n\");\n  }\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (old != NULL)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert ((old_size == 0) || (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    if (log != NULL) {\n      fprintf(log, \"Old block info: old_offset=%zu shrinking=%d\\n\", old_offset, shrinking);\n    }\n\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n      if (log != NULL) {\n        fprintf(log, \"Shrinking in place: zeroed and poisoned bytes from %zu to %zu\\n\", new_size, old_size);\n      }\n    }\n    if (pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos = ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (!shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ((new_apos > pool->end) || (new_apos < pool->pos))\n        {\n          if (log != NULL) {\n            fprintf(log, \"No space to grow in-place: new_apos=%zu pool->end=%zu pool->pos=%zu\\n\", new_apos, pool->end, pool->pos);\n          }\n          fclose(log);\n          return NULL;                /* No space */\n        }\n      }\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n\n      if (log != NULL) {\n        fprintf(log, \"Resized in-place: new pos=%zu\\n\", pool->pos);\n      }\n\n      fclose(log);\n      return old;\n    }\n    if (shrinking)\n    {\n      if (log != NULL) {\n        fprintf(log, \"Shrinking returns old block without moving\\n\");\n      }\n      fclose(log);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if (((0 == asize) && (0 != new_size)) || (asize > pool->end - pool->pos))\n  {\n    if (log != NULL) {\n      fprintf(log, \"Allocation failed: asize=%zu space left=%zu\\n\", asize, pool->end - pool->pos);\n    }\n    fclose(log);\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    memcpy (new_blc, old, old_size);\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    if (log != NULL) {\n      fprintf(log, \"Moved data to new block; old block zeroed and poisoned\\n\");\n    }\n  }\n\n  if (log != NULL) {\n    fprintf(log, \"New block allocated at: %p\\n\", (void *)new_blc);\n    fclose(log);\n  }\n\n  return new_blc;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of the compiler-specific built-in function __asan_region_is_poisoned, which is conditionally compiled only if MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED are defined. This function is not part of standard C but is an intrinsic provided by the AddressSanitizer tool integrated with certain compiler toolchains. Using such built-in functions constitutes use of a language extension, as these intrinsics go beyond the standard C language specification. MISRA C 2023 Rule 1.2 explicitly prohibits language extensions unless documented as standard. Therefore, the presence of __asan_region_is_poisoned does indeed violate MISRA C 2023 Rule 1.2 when the associated macros are defined. The additional test code attempts to stub this function but fails to compile in the provided environment, which does not negate the fact that the original code uses a compiler extension when configured accordingly. Hence, the report by agent A is correct."
}