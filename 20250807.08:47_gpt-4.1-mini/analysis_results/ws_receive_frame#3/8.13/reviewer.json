{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'frame' passed to the function ws_receive_frame is of type 'unsigned char *' and points to data that is not intended to be modified by the function. The function reads the data from 'frame' without modifying it, so to conform to MISRA C 2023 Rule 8.13, the pointer should be to a 'const unsigned char *' to indicate the data is not modified. Hence, the rule is violated because 'frame' should be 'const unsigned char *'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic unsigned char *\nws_receive_frame(unsigned char *frame, ssize_t *length, int *type)\n{\n  FILE *log_file = fopen(\"/tmp/logs/27.txt\", \"a\");\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg = NULL;\n  unsigned char flength;\n  unsigned int idx_first_mask;\n  unsigned int idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Entered ws_receive_frame\\n\");\n    fprintf(log_file, \"First byte of frame: 0x%X\\n\", frame[0]);\n  }\n\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = idx_first_mask + 4;\n    data_length = (size_t)*length - idx_first_data;\n\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Frame indicates text frame. Length fields: flength=%u, idx_first_mask=%u, idx_first_data=%u\\n\",\n              flength, idx_first_mask, idx_first_data);\n      fprintf(log_file, \"Data length calculated: %zu\\n\", data_length);\n    }\n\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Masks extracted: %02X %02X %02X %02X\\n\",\n              masks[0], masks[1], masks[2], masks[3]);\n    }\n\n    msg = malloc(data_length + 1);\n    if (msg != NULL)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t)data_length;\n      msg[j] = '\\0';\n\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"Message unmasked and allocated with length: %zd\\n\", *length);\n      }\n    }\n    else\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"Memory allocation failed for message\\n\");\n      }\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Control close frame received\\n\");\n    }\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Other frame type: %d\\n\", *type);\n    }\n  }\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Exiting ws_receive_frame\\n\");\n    fclose(log_file);\n  }\n\n  return msg;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible if the function does not modify the data pointed to by the pointer. In the provided function ws_receive_frame, the pointer 'frame' is used only to read data -- the function reads bytes from 'frame' but does not modify the contents of the memory pointed to by 'frame'. Therefore, 'frame' should ideally be declared as 'const unsigned char *' to document that the function does not and should not modify the pointed data, in accordance with Rule 8.13. The agent A's observation that the pointer 'frame' points to data that is not modified is correct, and the usage of a non-const pointer violates the guideline of using const-qualified pointers when possible. Thus, the claim that the function violates MISRA C 2023 Rule 8.13 is correct. The failed compilation of the test code is unrelated to the core issue of const-correctness in pointer declaration; it does not invalidate the correctness of the report about the MISRA rule violation."
}