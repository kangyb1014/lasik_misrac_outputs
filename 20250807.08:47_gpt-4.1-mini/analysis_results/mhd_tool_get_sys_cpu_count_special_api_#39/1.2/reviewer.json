{
  "user_message": "An agent A claimed that the following mhd_tool_get_sys_cpu_count_special_api_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_sys_cpu_count_special_api_.\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of GetActiveProcessorCount and GetNativeSystemInfo via GetProcAddress and the Windows-specific WINAPI calling convention, which may involve language/compiler-specific extensions related to function pointer casting and WINAPI style calling conventions, potentially violating Rule 1.2 if these features are considered extensions by the compiler.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  FILE *log_file = fopen(\"/tmp/logs/312.txt\", \"w\");\n\n  int ret = -1;\n  if (log_file != NULL) fprintf(log_file, \"Initial ret = %d\\n\", ret);\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  {\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    /* Assuming pstat_getdynamic prototype: int pstat_getdynamic(struct pst_dynamic *, size_t, size_t, int); */\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n      if (log_file != NULL) fprintf(log_file, \"HAVE_PSTAT_GETDYNAMIC updated ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n\n#ifdef HAVE_VXCPUENABLEDGET\n  {\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    if (log_file != NULL) fprintf(log_file, \"HAVE_VXCPUENABLEDGET enb_set = %u\\n\", enb_set);\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n    {\n      ++ret;\n      if (log_file != NULL) fprintf(log_file, \"Counting CPUs, current ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (log_file != NULL) fprintf(log_file, \"Loaded kernel32.dll handle = %p\\n\", (void *)k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (log_file != NULL) fprintf(log_file, \"GetActiveProcessorCount ptr = %p\\n\", (void *)ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        /* ALL_PROCESSOR_GROUPS is defined in some windows headers, define it if missing. */\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (log_file != NULL) fprintf(log_file, \"Active processor count = %u, ret = %d\\n\", res, ret);\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (log_file != NULL) fprintf(log_file, \"GetNativeSystemInfo ptr = %p\\n\", (void *)ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (log_file != NULL) fprintf(log_file, \"Native system info processor count = %lu, ret = %d\\n\", (unsigned long)sysInfo.dwNumberOfProcessors, ret);\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary (k32hndl);\n      if (log_file != NULL) fprintf(log_file, \"Freed kernel32.dll handle\\n\");\n    }\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (log_file != NULL) fprintf(log_file, \"Fallback GetSystemInfo processor count = %lu, ret = %d\\n\", (unsigned long)sysInfo.dwNumberOfProcessors, ret);\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n\n  if (0 >= ret)\n  {\n    if (log_file != NULL) fprintf(log_file, \"Returning failure ret = -1\\n\");\n    if (log_file != NULL) fclose(log_file);\n    return -1;\n  }\n\n  if (log_file != NULL) fprintf(log_file, \"Returning success ret = %d\\n\", ret);\n  if (log_file != NULL) fclose(log_file);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 forbids use of compiler or language extensions explicitly documented as extensions. The code uses WINAPI calling conventions and function pointer casting to Windows API functions obtained dynamically via GetProcAddress. However, WINAPI calling convention macros and WinAPI function pointer casts are standard in Windows API usage and do not represent language or compiler extensions themselves; they are standard platform-specific calling conventions and pointer usages well documented and commonly used within the Windows development environment. The code does not employ any nonstandard language features beyond those supported by the compiler for Windows development, nor does it rely on undocumented or proprietary compiler extensions. Therefore, the use of WINAPI and such Windows API constructs does not violate MISRA C 2023 Rule 1.2, as these are part of the standard Windows development environment rather than compiler language extensions. Additionally, the failed compilation of the test code does not prove the presence of language extensions violating Rule 1.2. Hence, the report that this code violates MISRA C 2023 Rule 1.2 is incorrect."
}