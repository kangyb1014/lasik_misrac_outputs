{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified mhd_tool_get_sys_cpu_count_special_api_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/312.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_sys_cpu_count_special_api_ as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_sys_cpu_count_special_api_:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\nJudge whether the above mhd_tool_get_sys_cpu_count_special_api_ code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "Use of GetActiveProcessorCount and GetNativeSystemInfo via GetProcAddress and the Windows-specific WINAPI calling convention, which may involve language/compiler-specific extensions related to function pointer casting and WINAPI style calling conventions, potentially violating Rule 1.2 if these features are considered extensions by the compiler.",
  "test_code": "static int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  FILE *log_file = fopen(\"/tmp/logs/312.txt\", \"w\");\n\n  int ret = -1;\n  if (log_file != NULL) fprintf(log_file, \"Initial ret = %d\\n\", ret);\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n      if (log_file != NULL) fprintf(log_file, \"HAVE_PSTAT_GETDYNAMIC updated ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    if (log_file != NULL) fprintf(log_file, \"HAVE_VXCPUENABLEDGET enb_set = %u\\n\", enb_set);\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n    {\n      ++ret;\n      if (log_file != NULL) fprintf(log_file, \"Counting CPUs, current ret = %d\\n\", ret);\n    }\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (log_file != NULL) fprintf(log_file, \"Loaded kernel32.dll handle = %p\\n\", (void *)k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (log_file != NULL) fprintf(log_file, \"GetActiveProcessorCount ptr = %p\\n\", (void *)ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (log_file != NULL) fprintf(log_file, \"Active processor count = %u, ret = %d\\n\", res, ret);\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (log_file != NULL) fprintf(log_file, \"GetNativeSystemInfo ptr = %p\\n\", (void *)ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (log_file != NULL) fprintf(log_file, \"Native system info processor count = %lu, ret = %d\\n\", (unsigned long)sysInfo.dwNumberOfProcessors, ret);\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary (k32hndl);\n      if (log_file != NULL) fprintf(log_file, \"Freed kernel32.dll handle\\n\");\n    }\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (log_file != NULL) fprintf(log_file, \"Fallback GetSystemInfo processor count = %lu, ret = %d\\n\", (unsigned long)sysInfo.dwNumberOfProcessors, ret);\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n\n  if (0 >= ret)\n  {\n    if (log_file != NULL) fprintf(log_file, \"Returning failure ret = -1\\n\");\n    if (log_file != NULL) fclose(log_file);\n    return -1;\n  }\n\n  if (log_file != NULL) fprintf(log_file, \"Returning success ret = %d\\n\", ret);\n  if (log_file != NULL) fclose(log_file);\n  return ret;\n}\n"
}