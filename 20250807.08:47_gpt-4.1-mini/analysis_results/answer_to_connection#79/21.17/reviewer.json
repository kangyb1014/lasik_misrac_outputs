{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses strlen and memcmp to check lengths and contents of username and password strings in auth_info, which are obtained from a base64 decoded buffer with nul-termination set in MHD_basic_auth_get_username_password3. However, there is a potential risk if username_len or password_len do not correctly represent the valid length of the null-terminated strings, leading to memcmp or strlen accesses beyond the bounds of the objects. Specifically, if the decoded base64 data is malformed or username_len/password_len do not correspond to proper string lengths, use of strlen on a non-null-terminated pointer or memcmp with length exceeding the actual buffer could occur, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  FILE *log_file = fopen(\"/tmp/logs/639.txt\", \"a\");\n  if (log_file == NULL) return MHD_NO;\n  struct MHD_BasicAuthInfo *auth_info = NULL;\n  enum MHD_Result ret;\n  struct MHD_Response *response = NULL;\n  (void) cls;\n  (void) url;\n  (void) version;\n  (void) upload_data;\n  (void) upload_data_size;\n\n  fprintf(log_file, \"Entry answer_to_connection with method=%s\\n\", method);\n  if (0 != strcmp (method, \"GET\"))\n  {\n    fprintf(log_file, \"Method is not GET, returning MHD_NO\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    fprintf(log_file, \"Initializing req_cls with connection pointer\\n\");\n    *req_cls = connection;\n    fclose(log_file);\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    fprintf(log_file, \"auth_info is NULL, sending auth required response\\n\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer (strlen (page), (void*)page, MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    // Log username length and string safely\n    fprintf(log_file, \"auth_info->username_len = %zu\\n\", auth_info->username_len);\n    fprintf(log_file, \"auth_info->password_len = %zu\\n\", auth_info->password_len);\n\n    // Log first bytes of username and password safely\n    size_t i;\n    fprintf(log_file, \"auth_info->username: \");\n    for (i = 0U; i < auth_info->username_len && i < 32U; ++i)\n      fprintf(log_file, \"%c\", auth_info->username[i]);\n    fprintf(log_file, \"\\n\");\n\n    fprintf(log_file, \"auth_info->password: \");\n    for (i = 0U; i < auth_info->password_len && i < 32U; ++i)\n      fprintf(log_file, \"%c\", auth_info->password[i]);\n    fprintf(log_file, \"\\n\");\n\n    if ((strlen (\"root\") != auth_info->username_len) ||\n        (0 != memcmp (auth_info->username, \"root\",\n                      auth_info->username_len)) ||\n        (NULL == auth_info->password) ||\n        (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n        (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                      auth_info->password_len)))\n    {\n      fprintf(log_file, \"username or password invalid, sending auth required response\\n\");\n      static const char *page =\n        \"<html><body>Wrong username or password</body></html>\";\n      response = MHD_create_response_from_buffer (strlen (page), (void*)page, MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                     \"admins\",\n                                                     MHD_YES,\n                                                     response);\n    }\n    else\n    {\n      fprintf(log_file, \"username and password valid, sending secret response\\n\");\n      static const char *page = \"<html><body>A secret.</body></html>\";\n      response = MHD_create_response_from_buffer (strlen (page), (void*)page, MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    }\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  if (NULL != response)\n    MHD_destroy_response (response);\n  fprintf(log_file, \"Exiting answer_to_connection with ret=%d\\n\", ret);\n  fclose(log_file);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 requires that use of string handling functions from <string.h>, such as strlen and memcmp, must not access beyond the bounds of the objects pointed to by their pointers. In the provided code, the username and password pointers in auth_info are used with strlen and memcmp, relying on username_len and password_len to correctly represent their string lengths. However, there is no explicit check or guarantee that these length fields correspond to the actual allocated memory or that the strings are properly null-terminated. If these lengths are incorrect or if the strings are not null-terminated as expected, calls to strlen could read beyond the buffer bounds, or memcmp could compare beyond the valid memory area, violating Rule 21.17. The scenario described by agent A is plausible because the code trusts external data (from MHD_basic_auth_get_username_password3) without validating buffer boundaries or ensuring null-termination, thus potentially leading to out-of-bounds access. Therefore, the report of rule violation is correct based on the presented code and this risk scenario."
}