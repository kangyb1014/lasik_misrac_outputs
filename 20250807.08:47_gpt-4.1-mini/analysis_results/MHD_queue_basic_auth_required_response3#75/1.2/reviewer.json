{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of _MHD_EXTERN as a language extension that is likely a compiler-specific extension (not standard C). This identifier is not defined in standard C and may expand to a compiler-specific attribute or linkage specification, which is a language extension.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nsize_t MHD_str_quote(const char *src, size_t srclen, char *dst, size_t dstlen) {\n    /* For test, just copy src to dst (without quoting) if enough space */\n    if (dstlen < srclen) return 0;\n    memcpy(dst, src, srclen);\n    return srclen;\n}\nenum MHD_Result MHD_add_response_header(struct MHD_Response *response, const char *header, const char *value) {\n    (void)response; (void)header; (void)value;\n    return MHD_YES;\n}\nenum MHD_Result MHD_queue_response(struct MHD_Connection *connection, int status_code, struct MHD_Response *response) {\n    (void)connection; (void)status_code; (void)response;\n    return MHD_YES;\n}\n\nenum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  FILE *log = fopen(\"/tmp/logs/600.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entered MHD_queue_basic_auth_required_response3\\n\");\n  }\n\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len = MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n  {\n    if (log != NULL) fprintf(log, \"Response is NULL, returning MHD_NO\\n\");\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n    if (log != NULL) fprintf(log, \"Failed to allocate memory for header\\n\");\n#ifdef HAVE_MESSAGES\n    /* MHD_DLOG omitted for compilation */\n#endif /* HAVE_MESSAGES */\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n  if (log != NULL) fprintf(log, \"Constructed auth header: %s\\n\", h_str);\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    if (log != NULL) fprintf(log, \"Added response header, queuing response\\n\");\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    /* MHD_DLOG omitted for compilation */\n#endif /* HAVE_MESSAGES */\n    if (log != NULL) fprintf(log, \"Failed to add response header\\n\");\n  }\n\n  if (log != NULL) fclose(log);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation of MISRA C 2023 Rule 1.2 hinges on the use of the identifier '_MHD_EXTERN'. This identifier is not part of the standard C language, and it likely represents a macro defined elsewhere that may expand to compiler-specific attributes or linkage specifications. MISRA C Rule 1.2 prohibits using language extensions explicitly stated as such in compiler documentation. Given that '_MHD_EXTERN' is not a standard keyword and appears to be a macro potentially introducing compiler-specific extensions, its usage could indeed violate Rule 1.2 if it expands to such extensions. However, without the actual definition of '_MHD_EXTERN', it is impossible to categorically conclude that it constitutes a language extension. If '_MHD_EXTERN' expands to nothing or to a standard C keyword like 'extern', then the report would be incorrect. But considering typical naming conventions and common practice, such macros often encapsulate language extensions. Therefore, the claim by agent A is reasonable and likely correct regarding the violation of Rule 1.2 based on the use of '_MHD_EXTERN'. The failing to compile the test code that removes or replaces it does not invalidate the report, as the macro's nature is the crux. Thus, the report is correct in principle, pending verification of the macro definition which is absent here."
}