{
  "user_message": "An agent A claimed that the following file_reader code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of file_reader.\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the buffer 'buf' provided to the 'file_reader' function is smaller than the 'max' parameter passed to the string handling functions (like read or pread), this may cause buffer overflows leading to accesses beyond the bounds of the objects referenced by their pointer parameters.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  FILE *log = fopen(\"/tmp/logs/655.txt\", \"a\");\n  if (!log) return -2;\n\n  struct MHD_Response *response = cls;\n  ssize_t n = 0;\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  fprintf(log, \"Entering file_reader with pos=%lu, max=%zu, offset64=%ld\\n\", pos, max, offset64);\n\n  if (offset64 < 0) {\n    fprintf(log, \"Invalid offset64 < 0: %ld\\n\", offset64);\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n\n  if (max > SSIZE_MAX) {\n    fprintf(log, \"Clamping max from %zu to SSIZE_MAX=%zu\\n\", max, (size_t)SSIZE_MAX);\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n  }\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ((sizeof(off_t) < sizeof (uint64_t)) && (offset64 > (uint64_t) INT32_MAX)) {\n    fprintf(log, \"Offset64 too large for pread: %ld\\n\", offset64);\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n  }\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd, offset64, SEEK_SET) != offset64) {\n    fprintf(log, \"lseek64 failed for offset64: %ld\\n\", offset64);\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#else\n  if ((sizeof(off_t) < sizeof (uint64_t)) && (offset64 > (uint64_t) INT32_MAX)) {\n    fprintf(log, \"Offset64 too large for lseek: %ld\\n\", offset64);\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n  }\n  if (lseek(response->fd, (off_t)offset64, SEEK_SET) != (off_t)offset64) {\n    fprintf(log, \"lseek failed for offset64: %ld\\n\", offset64);\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n  }\n#endif\n  n = read(response->fd, buf, max);\n#endif\n\n  fprintf(log, \"Read returned %zd bytes\\n\", n);\n\n  if (n == 0) {\n    fprintf(log, \"End of stream\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (n < 0) {\n    fprintf(log, \"Read error\\n\");\n    fclose(log);\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  }\n\n  fprintf(log, \"Exiting file_reader with %zd bytes read\\n\", n);\n  fclose(log);\n  return n;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported MISRA C 2023 Rule 21.17 requires that calls to string handling functions do not access beyond the bounds of the objects referenced by their pointer parameters. In the provided code, the function file_reader reads data into a buffer 'buf' up to 'max' bytes using system calls such as pread, read, or ReadFile. The code ensures 'max' is clamped to a maximum value (SSIZE_MAX or INT32_MAX) to prevent excessive read sizes. However, the code does not itself verify that the buffer pointed to by 'buf' is at least 'max' bytes large before performing the read. The function interface assumes the caller provides a buffer of adequate size. Since the cause of possible buffer overrun is external to this function (from the caller providing an undersized buffer), and the function uses no string.h functions but rather read functions that trust the buffer size, the violation is indirect. Moreover, MISRA Rule 21.17 is specifically about string.h library functions; these are not called by file_reader. The system calls used (pread, read, ReadFile) are not part of <string.h> string handling functions. Therefore, this code does not violate MISRA C 2023 Rule 21.17. The agent's scenario mainly highlights a potential caller contract violation but not a direct Rule 21.17 violation in this code. Also, the provided test code fails to compile, so no concrete evidence is available. Hence, the report claiming a direct Rule 21.17 violation in this code is not correct."
}