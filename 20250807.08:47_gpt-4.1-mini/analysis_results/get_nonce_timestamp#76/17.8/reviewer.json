{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'noncelen' is modified inside the function 'get_nonce_timestamp' by assigning it a new value when it is zero. According to MISRA C 2023 Rule 17.8, a function parameter should not be modified. Although the object pointed to by a pointer parameter can be modified, the actual parameter variables themselves should remain unmodified. Here, 'noncelen' is a value parameter and is modified inside the function, thus violating Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic int toxdigitvalue(char ch)\n{\n  if (ch >= '0' && ch <= '9')\n    return ch - '0';\n  if (ch >= 'a' && ch <= 'f')\n    return ch - 'a' + 10;\n  if (ch >= 'A' && ch <= 'F')\n    return ch - 'A' + 10;\n  return -1;\n}\n\nstatic bool\nget_nonce_timestamp(const char *const nonce,\n                   size_t noncelen,\n                   uint64_t *const ptimestamp)\n{\n  FILE *log_file = fopen(\"/tmp/logs/613.txt\", \"a\");\n  if (log_file)\n  {\n    fprintf(log_file, \"Entering get_nonce_timestamp\\n\");\n    fprintf(log_file, \"Initial noncelen: %zu\\n\", noncelen);\n  }\n\n  if (0 == noncelen)\n  {\n    if (log_file) fprintf(log_file, \"noncelen is zero, computing strlen(nonce) without modification\\n\");\n    size_t effective_noncelen = strlen(nonce);  // Use local variable instead of modifying parameter\n    if (log_file) fprintf(log_file, \"Computed effective_noncelen: %zu\\n\", effective_noncelen);\n\n    if (true && (10 != effective_noncelen)) // Using 10 as dummy NONCE_STD_LEN value\n    {\n      if (log_file) fprintf(log_file, \"effective_noncelen does not match standard length, returning false\\n\");\n      if (log_file) fclose(log_file);\n      return false;\n    }\n\n    if (TIMESTAMP_CHARS_LEN !=\n        MHD_strx_to_uint64_n_(nonce + effective_noncelen - TIMESTAMP_CHARS_LEN,\n                              TIMESTAMP_CHARS_LEN,\n                              ptimestamp))\n    {\n      if (log_file) fprintf(log_file, \"Timestamp parsing failed, returning false\\n\");\n      if (log_file) fclose(log_file);\n      return false;\n    }\n  }\n  else\n  {\n    if (true && (10 != noncelen)) // Using 10 as dummy NONCE_STD_LEN value\n    {\n      if (log_file) fprintf(log_file, \"noncelen does not match standard length, returning false\\n\");\n      if (log_file) fclose(log_file);\n      return false;\n    }\n\n    if (TIMESTAMP_CHARS_LEN !=\n        MHD_strx_to_uint64_n_(nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                              TIMESTAMP_CHARS_LEN,\n                              ptimestamp))\n    {\n      if (log_file) fprintf(log_file, \"Timestamp parsing failed, returning false\\n\");\n      if (log_file) fclose(log_file);\n      return false;\n    }\n  }\n\n  if (log_file) fprintf(log_file, \"Successfully parsed timestamp, returning true\\n\");\n\n  if (log_file) fclose(log_file);\n\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter should not be modified. This typically applies to the value of the parameter variable itself, not the data pointed to by pointer parameters. In the given code, 'noncelen' is a parameter passed by value (not a pointer), and it is indeed assigned a new value inside the function when it is zero: 'noncelen = strlen(nonce);'. This assignment modifies the parameter variable 'noncelen', which violates Rule 17.8 because the parameter variable itself should remain unmodified throughout the function. The pointer parameter 'ptimestamp' is not modified (only the pointed-to object can be), so no issue there. Therefore, the agent A's claim that modifying 'noncelen' inside the function violates MISRA C 2023 Rule 17.8 is correct. Regarding the test code, its failure to compile does not affect the correctness of the analysis \u2014 the rule is clear about parameter modification. The proper fix would be to avoid modifying the parameter 'noncelen' and instead use a local variable for any adjusted length. Hence, agent A's report of violation is correct."
}