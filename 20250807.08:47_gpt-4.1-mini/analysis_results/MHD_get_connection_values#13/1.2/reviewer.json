{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a compiler-specific language extension __attribute__((visibility(\"default\"))) in the macro _MHD_EXTERN, which decorates the function declaration of MHD_get_connection_values. This GCC attribute is a language extension beyond standard C and thus violates MISRA C 2023 Rule 1.2 stating language extensions should not be used.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind {\n  MHD_KIND_HEADER = 1\n};\ntypedef enum MHD_Result (*MHD_KeyValueIterator)(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstruct rq_struct {\n  struct MHD_HTTP_Req_Header *headers_received;\n};\n\nint MHD_get_connection_values(struct MHD_Connection *connection,\n                              enum MHD_ValueKind kind,\n                              MHD_KeyValueIterator iterator,\n                              void *iterator_cls)\n{\n  FILE *log_file = fopen(\"/tmp/logs/104.txt\", \"a\");\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"Entered MHD_get_connection_values\\n\");\n  }\n\n  if (NULL == connection)\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"connection is NULL, returning -1\\n\");\n      fclose(log_file);\n    }\n    return -1;\n  }\n\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"Inspecting header with kind: %d\\n\", pos->kind);\n    }\n\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"Header kind matched filter: %d, increment ret to %d\\n\", pos->kind, ret);\n      }\n\n      if ((NULL != iterator) &&\n          (MHD_NO == iterator(iterator_cls,\n                              pos->kind,\n                              pos->header,\n                              pos->value)))\n      {\n        if (log_file != NULL)\n        {\n          fprintf(log_file, \"Iterator returned MHD_NO, returning ret=%d\\n\", ret);\n          fclose(log_file);\n        }\n        return ret;\n      }\n    }\n  }\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"No iterator interruption, returning ret=%d\\n\", ret);\n    fclose(log_file);\n  }\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of the macro _MHD_EXTERN, which, according to the scenario, expands to a compiler-specific language extension: __attribute__((visibility(\"default\"))). This attribute is a GNU GCC extension and is not part of standard C. MISRA C 2023 Rule 1.2 explicitly forbids the use of language extensions beyond the standard C language. Hence, usage of any compiler-specific language extensions such as GCC's __attribute__ indeed violates this rule. Therefore, if _MHD_EXTERN expands to this attribute, then the code does use a language extension, violating MISRA C 2023 Rule 1.2 as reported by agent A. The presence of the attribute in the macro is not standard C and is outside the scope of MISRA compliance. The test code failing to compile is a secondary issue and does not negate the fact that the original code uses a language extension through the macro _MHD_EXTERN. Hence the report is correct."
}