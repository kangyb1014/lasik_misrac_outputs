{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation of MISRA C 2023 Rule 21.17 will occur if the memcpy call copies more bytes than the size of the destination buffer nonce, causing an access beyond the bounds of nonce. This can happen if NONCE_STD_LEN(digest_size) is larger than the allocated size of nonce, or if the digest_size derived from da is incorrectly large. Since nonce is a char* passed into the function, it's assumed to be at least NONCE_STD_LEN(digest_size) bytes long. If not, copying with memcpy could overflow nonce.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nbool digest_ext_error(struct DigestAlgorithm *da) { (void)da; return false; }\nstruct Master {\n    int digest_auth_rand_size;\n    int nonce_nc_size;\n};\nstatic bool calculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  FILE *log_file = fopen(\"/tmp/logs/623.txt\", \"a\");\n  if (log_file == NULL)\n    return false; // Cannot log, fail safe\n\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  if (da->hashing) {\n      fclose(log_file);\n      return false;\n  }\n  fprintf(log_file, \"calculate_add_nonce_with_retry: started\\n\");\n  fprintf(log_file, \"timestamp1 = %llu, realm_len = %zu\\n\", (unsigned long long)timestamp1, realm_len);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    fprintf(log_file, \"Random value was not initialised by MHD_OPTION_DIGEST_AUTH_RANDOM or MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces are predictable.\\n\");\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da, nonce))\n  {\n    fprintf(log_file, \"calculate_add_nonce_with_retry: initial calculate_add_nonce failed\\n\");\n    const size_t digest_size = digest_get_size (da);\n    fprintf(log_file, \"digest_size = %zu\\n\", digest_size);\n    char nonce2[NONCE_STD_LEN (0) + 1] = {0};\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da)) {\n      fprintf(log_file, \"digest_ext_error true, returning false\\n\");\n      fclose(log_file);\n      return false; /* No need to re-try */\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size) {\n      fprintf(log_file, \"nonce_nc_size == 0, returning false\\n\");\n      fclose(log_file);\n      return false; /* No need to re-try */\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    fprintf(log_file, \"timestamp2 = %llu\\n\", (unsigned long long)timestamp2);\n    if (timestamp1 == timestamp2)\n    {\n      fprintf(log_file, \"timestamps equal, generating arbitrary difference\\n\");\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2;\n      fprintf(log_file, \"adjusted timestamp2 = %llu\\n\", (unsigned long long)timestamp2);\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da, nonce2))\n    {\n      fprintf(log_file, \"Failed 2nd calculate_add_nonce call, returning false\\n\");\n      fclose(log_file);\n      return false;\n    }\n\n    // Corrected memcpy size argument to digest_size\n    fprintf(log_file, \"About to memcpy nonce2 to nonce, length = %zu\\n\", digest_size);\n    memcpy (nonce, nonce2, digest_size);\n    fprintf(log_file, \"memcpy completed\\n\");\n  }\n  fprintf(log_file, \"calculate_add_nonce_with_retry: returning true\\n\");\n  fclose(log_file);\n  return true;\n}\n\nsize_t digest_get_size(struct DigestAlgorithm *da) { (void)da; return 16; }\nvoid digest_reset(struct DigestAlgorithm *da) { (void)da; }\nbool calculate_add_nonce(struct MHD_Connection *const conn, uint64_t timestamp, const char *realm, size_t realm_len, struct DigestAlgorithm *da, char *nonce) {\n    (void)conn; (void)timestamp; (void)realm; (void)realm_len; (void)da;\n    if (nonce) {\n        memset(nonce, 'A', NONCE_STD_LEN(0));\n        nonce[NONCE_STD_LEN(0) - 1] = '\\0';\n    }\n    return true;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported MISRA C:2023 Rule 21.17 violation concerns an overrun risk in the memcpy call copying from nonce2 to nonce. The rule forbids accesses beyond the bounds of objects when using string.h functions like memcpy. The memcpy uses NONCE_STD_LEN(digest_size) as the length argument. This implies the size of bytes copied depends on digest_size and the macro NONCE_STD_LEN(). The nonce pointer is passed into the function, but the code and scenario do not show any explicit guarantees or validations that nonce points to a buffer at least as large as NONCE_STD_LEN(digest_size). Thus, if the caller provides a smaller buffer or if digest_size is incorrectly large, copying that many bytes can overflow nonce, violating the rule. \n\nThe agent's scenario is plausible in that the function depends on the caller to provide a sufficiently large nonce buffer to avoid overflow. Without explicit size checking or stricter API contracts, this potential violation exists. The test code provided does not refute or confirm this, but demonstrates that mismatched sizes in memcpy length could cause problems.\n\nTherefore, the report is correct that this code potentially violates MISRA C:2023 Rule 21.17 due to the unchecked memcpy size argument which may cause accesses beyond the bounds of nonce."
}