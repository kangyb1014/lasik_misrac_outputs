{
  "user_message": "An agent A claimed that the following update_directory code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of update_directory.\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential buffer overrun when calling memcpy with INDEX_PAGE_FOOTER: the condition before memcpy only checks if the remaining buffer space is less than or equal to the length of INDEX_PAGE_FOOTER, but memcpy overwrites from the start of the buffer instead of offset, resulting in possible accesses beyond bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n  FILE *log_file = fopen(\"/tmp/logs/7.txt\", \"w\");\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    fprintf(log_file, \"malloc failed\\n\");\n    fclose(log_file);\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    fprintf(log_file, \"buffer too small for header: buf_len=%zu, len=%zu\\n\", rdc.buf_len, len);\n    free (rdc.buf);\n    update_cached_response (NULL);\n    fclose(log_file);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  fprintf(log_file, \"Copied header: len=%zu, off=%zu\\n\", len, rdc.off);\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n    {\n      fprintf(log_file, \"Skipping language dirname: %s (stat failed)\\n\", language->dirname);\n      continue; /* empty */\n    }\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    fprintf(log_file, \"snprintf language header: res=%d, off=%zu\\n\", res, rdc.off);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      fprintf(log_file, \"snprintf dir_name: '%s', res=%d\\n\", dir_name, res);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n      {\n        fprintf(log_file, \"Skipping dir_name: %s (stat failed)\\n\", dir_name);\n        continue;  /* empty */\n      }\n\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      fprintf(log_file, \"snprintf category header: res=%d, off=%zu\\n\", res, rdc.off);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        fprintf(log_file, \"list_directory failed for dir_name: %s\\n\", dir_name);\n        free (rdc.buf);\n        update_cached_response (NULL);\n        fclose(log_file);\n        return;\n      }\n    }\n  }\n\n  len = strlen (INDEX_PAGE_FOOTER);\n  fprintf(log_file, \"Footer length %zu, buffer remaining %zu\\n\", len, rdc.buf_len - rdc.off);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    fprintf(log_file, \"buffer too small for footer: buf_len=%zu, off=%zu, len=%zu\\n\", rdc.buf_len, rdc.off, len);\n    free (rdc.buf);\n    update_cached_response (NULL);\n    fclose(log_file);\n    return;\n  }\n\n  /* Corrected: copy footer at end of current buffer offset */\n  memcpy (rdc.buf + rdc.off, INDEX_PAGE_FOOTER, len);\n  fprintf(log_file, \"Copied footer at buffer offset %zu bytes\\n\", rdc.off);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n  fclose(log_file);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A asserts that a call to memcpy copying INDEX_PAGE_FOOTER is done incorrectly because it copies at the start of rdc.buf instead of at rdc.buf + rdc.off, which is where the footer should be appended. Indeed, in the original code, the line memcpy(rdc.buf, INDEX_PAGE_FOOTER, len); copies the footer into the beginning of the buffer, overwriting previous content and causing a buffer overrun concern or data corruption. The bounds check before that memcpy verifies that the remaining buffer space (rdc.buf_len - rdc.off) is at least len, indicating the footer should be written starting at rdc.buf + rdc.off, not at rdc.buf. Therefore, the identified issue is a genuine misuse of memcpy with a pointer parameter that leads to an out-of-bounds or unintended access, violating MISRA C 2023 Rule 21.17. Agent A\u2019s concern is valid. The provided test code attempts to fix this by changing memcpy(rdc.buf, INDEX_PAGE_FOOTER, len); to memcpy(rdc.buf + rdc.off, INDEX_PAGE_FOOTER, len); though compilation problems prevented testing, it does not negate the correctness of the original violation report. Hence, the report that this code violates MISRA C 2023 Rule 21.17 is correct."
}