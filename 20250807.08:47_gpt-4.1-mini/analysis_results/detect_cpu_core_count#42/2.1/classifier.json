{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified detect_cpu_core_count code that contains useful probe functions that print useful logs to a file \"/tmp/logs/337.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of detect_cpu_core_count as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of detect_cpu_core_count:\n```c\nstatic unsigned int\ndetect_cpu_core_count (void)\n{\n  int sys_cpu_count;\n  sys_cpu_count = mhd_tool_get_system_cpu_count ();\n  if (0 >= sys_cpu_count)\n  {\n    int proc_cpu_count;\n    fprintf (stderr, \"Failed to detect the number of logical CPU cores \"\n             \"available on the system.\\n\");\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (0 < proc_cpu_count)\n    {\n      fprintf (stderr, \"The number of CPU cores available for this process \"\n               \"is used as a fallback.\\n\");\n      sys_cpu_count = proc_cpu_count;\n    }\n#ifdef MHD_REAL_CPU_COUNT\n    if (0 >= sys_cpu_count)\n    {\n      fprintf (stderr, \"configure-detected hardcoded number is used \"\n               \"as a fallback.\\n\");\n      sys_cpu_count = MHD_REAL_CPU_COUNT;\n    }\n#endif\n    if (0 >= sys_cpu_count)\n      sys_cpu_count = 1;\n    printf (\"Assuming %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  else\n  {\n    printf (\"Detected %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  return (unsigned int) sys_cpu_count;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function detect_cpu_core_count:\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n#endif /* __linux__ || __GLIBC__  */\n\n  return -1; /* Cannot detect */\n}\n...\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n</additional code>\nJudge whether the above detect_cpu_core_count code violates the rule 2.1 or not.",
  "is_rule_violated": true,
  "scenario": "The function contains conditional blocks that might become unreachable depending on compile-time definitions, specifically the #ifdef MHD_REAL_CPU_COUNT block inside an else-if cascading structure. If MHD_REAL_CPU_COUNT is not defined, the intermediate condition checking (0 >= sys_cpu_count) after fallback calls could be unreachable since the preceding if would have already covered possible cases, leaving no path to execute that block, resulting in unreachable code.",
  "test_code": "#include <stdio.h>\n\nstatic unsigned int\nos_log_sys_cpu_count;  /* for logging detected sys_cpu_count state */\n\nstatic unsigned int\nos_log_proc_cpu_count; /* for logging detected proc_cpu_count state */\n\nstatic void log_state(const char* msg, int sys_cpu_count, int proc_cpu_count)\n{\n    FILE *log = fopen(\"/tmp/logs/337.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"%s: sys_cpu_count=%d, proc_cpu_count=%d\\n\", msg, sys_cpu_count, proc_cpu_count);\n        fclose(log);\n    }\n}\n\nstatic unsigned int\nfail_cpu_core_count_logging_fallback(int *sys_cpu_count_p)\n{\n    int proc_cpu_count;\n    fprintf(stderr, \"Failed to detect the number of logical CPU cores available on the system.\\n\");\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    log_state(\"After proc_cpu_count fetch\", *sys_cpu_count_p, proc_cpu_count);\n\n    if (0 < proc_cpu_count)\n    {\n        fprintf(stderr, \"The number of CPU cores available for this process is used as a fallback.\\n\");\n        *sys_cpu_count_p = proc_cpu_count;\n        log_state(\"Fallback sys_cpu_count assigned proc_cpu_count\", *sys_cpu_count_p, proc_cpu_count);\n    }\n\n#ifdef MHD_REAL_CPU_COUNT\n    if (0 >= *sys_cpu_count_p)\n    {\n        fprintf(stderr, \"configure-detected hardcoded number is used as a fallback.\\n\");\n        *sys_cpu_count_p = MHD_REAL_CPU_COUNT;\n        log_state(\"Fallback sys_cpu_count assigned MHD_REAL_CPU_COUNT\", *sys_cpu_count_p, proc_cpu_count);\n    }\n#endif\n    if (0 >= *sys_cpu_count_p)\n        *sys_cpu_count_p = 1;\n    printf(\"Assuming %d logical CPU core%s on this system.\\n\", *sys_cpu_count_p, (*sys_cpu_count_p == 1) ? \"\" : \"s\");\n    log_state(\"Final fallback sys_cpu_count\", *sys_cpu_count_p, proc_cpu_count);\n\n    return (unsigned int)*sys_cpu_count_p;\n}\n\nstatic unsigned int\n\n\ndetect_cpu_core_count(void)\n{\n    int sys_cpu_count;\n    sys_cpu_count = mhd_tool_get_system_cpu_count ();\n    log_state(\"Initial sys_cpu_count\", sys_cpu_count, -1);\n    if (0 >= sys_cpu_count)\n    {\n        return fail_cpu_core_count_logging_fallback(&sys_cpu_count);\n    }\n    else\n    {\n        printf (\"Detected %d logical CPU core%s on this system.\\n\", sys_cpu_count, (1 == sys_cpu_count) ? \"\" : \"s\");\n        log_state(\"Detected valid sys_cpu_count\", sys_cpu_count, -1);\n    }\n    return (unsigned int) sys_cpu_count;\n}\n"
}