{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified parse_cookies_string code that contains useful probe functions that print useful logs to a file \"/tmp/logs/191.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of parse_cookies_string as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of parse_cookies_string:\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function parse_cookies_string:\n#define mhd_assert(ignore) ((void)0)\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n</additional code>\nJudge whether the above parse_cookies_string code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function parse_cookies_string modifies the input string 'str' by zero-terminating cookie names and values using assignments such as 'str[name_start + name_len] = 0;' and 'str[value_start + value_len] = 0;'. These operations assume that the positions 'name_start + name_len' and 'value_start + value_len' are within the bounds of the string buffer of length 'str_len'. While the function performs assertions and checks to ensure these indices do not exceed 'str_len', there are scenarios where the checks rely on external conditions or prior validations that could be bypassed, potentially causing out-of-bounds writes. Specifically, if 'name_len' or 'value_len' reach 'str_len' exactly, writing a zero terminator at that position would exceed the buffer boundary, violating Rule 21.17. Therefore, without enforcing that the buffer is at least one byte larger than 'str_len' or confirming the string is null-terminated, the use of string handling (modifications and assignments) may result in accesses beyond the referenced object bounds, violating MISRA C 2023 Rule 21.17.",
  "test_code": "static enum _MHD_ParseCookie\nparse_cookies_string(char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/191.txt\", \"w\");\n  size_t i;\n  bool non_strict;\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  fprintf(log, \"Starting parse_cookies_string with str_len=%zu\\n\", str_len);\n\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (!allow_wsp_empty)\n      {\n        fprintf(log, \"Malformed due to whitespace at position %zu not allowed\\n\", i);\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n      if (i == str_len)\n      {\n        fprintf(log, \"Reached end of string after skipping whitespaces at %zu\\n\", i);\n        fclose(log);\n        return non_strict ? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n      }\n    }\n    name_start = i;\n    fprintf(log, \"Name start at index %zu\\n\", name_start);\n    do\n    {\n      const char l = str[i];\n      if (( '=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) || (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    fprintf(log, \"Name length calculated as %zu\\n\", name_len);\n\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (!wsp_around_eq)\n      {\n        fprintf(log, \"Malformed due to whitespace around '=' at position %zu not allowed\\n\", i);\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n    {\n      fprintf(log, \"Malformed due to incomplete cookie name at position %zu with name_len %zu\\n\", i, name_len);\n      fclose(log);\n      return MHD_PARSE_COOKIE_MALFORMED;\n    }\n\n    i++; // skip '='\n\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (!wsp_around_eq)\n      {\n        fprintf(log, \"Malformed due to whitespace after '=' at position %zu not allowed\\n\", i);\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n      val_quoted = false;\n      fprintf(log, \"Empty cookie value at end of string\\n\");\n    }\n    else\n    {\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted) i++;\n      value_start = i;\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || ('\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (!val_quoted)\n            break;\n          if (!wsp_in_quoted)\n          {\n            fprintf(log, \"Malformed due to whitespace within quoted value at position %zu not allowed\\n\", i);\n            fclose(log);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      fprintf(log, \"Value starts at %zu length %zu quoted=%d\\n\", value_start, value_len, val_quoted);\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n        {\n          fprintf(log, \"Malformed due to missing closing quote for value at position %zu\\n\", i);\n          fclose(log);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        i++;\n      }\n      while ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        i++;\n        if (str_len > i)\n        {\n          if (!allow_wsp_empty)\n          {\n            fprintf(log, \"Malformed due to whitespace at end of cookie value at position %zu not allowed\\n\", i);\n            fclose(log);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n      if (!(str_len == i || str[i] == ';'))\n      {\n        fprintf(log, \"Malformed due to invalid character at end of cookie value at position %zu\\n\", i);\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n    }\n\n    if (name_start + name_len > str_len)\n    {\n      fprintf(log, \"Error: name_start + name_len (%zu) exceeds str_len (%zu)\\n\", name_start + name_len, str_len);\n      fclose(log);\n      return MHD_PARSE_COOKIE_MALFORMED;\n    }\n    str[name_start + name_len] = 0; // zero terminate name\n    fprintf(log, \"Zero-terminated name at %zu\\n\", name_start + name_len);\n\n    if (value_len != 0)\n    {\n      if (value_start + value_len > str_len)\n      {\n        fprintf(log, \"Error: value_start + value_len (%zu) exceeds str_len (%zu)\\n\", value_start + value_len, str_len);\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      str[value_start + value_len] = 0; // zero terminate value\n      fprintf(log, \"Zero-terminated value at %zu\\n\", value_start + value_len);\n\n      if (MHD_NO == MHD_set_connection_value_n_nocheck_(connection, MHD_COOKIE_KIND, str + name_start, name_len, str + value_start, value_len))\n      {\n        fprintf(log, \"Failed to set connection value for cookie\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n    else\n    {\n      if (MHD_NO == MHD_set_connection_value_n_nocheck_(connection, MHD_COOKIE_KIND, str + name_start, name_len, \"\", 0))\n      {\n        fprintf(log, \"Failed to set connection value for cookie with empty value\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n\n    if (str_len > i)\n    {\n      i++;\n      if (str_len == i)\n      {\n        if (!allow_wsp_empty)\n        {\n          fprintf(log, \"Malformed due to no next cookie after semicolon at end of string\\n\");\n          fclose(log);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {\n        if ('\\t' == str[i] && tab_as_sp)\n          i++;\n        else if (!allow_no_space)\n        {\n          fprintf(log, \"Malformed due to no space after semicolon at position %zu not allowed\\n\", i);\n          fclose(log);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (!allow_wsp_empty)\n          {\n            fprintf(log, \"Malformed due to end of string after space after semicolon\\n\");\n            fclose(log);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n    }\n  }\n  fprintf(log, \"Finished parsing with result %d\\n\", non_strict ? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK);\n  fclose(log);\n  return non_strict ? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n"
}