{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified fill_v1_v2_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/543.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of fill_v1_v2_form as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of fill_v1_v2_form:\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function fill_v1_v2_form:\n#define SECOND_PAGE \"<html><head><title>Tell me more</title></head><body><a href=\\\"/\\\">previous</a> <form action=\\\"/S\\\" method=\\\"post\\\">%s, what is your job? <input type=\\\"text\\\" name=\\\"v2\\\" value=\\\"%s\\\" /><input type=\\\"submit\\\" value=\\\"Next\\\" /></form></body></html>\"\n</additional code>\nJudge whether the above fill_v1_v2_form code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The length for the reply buffer is calculated as the sum of the lengths of SECOND_PAGE plus session->value_1 plus session->value_2 using strlen, but SECOND_PAGE contains format specifiers \"%s\" which will be replaced by session->value_1 and session->value_2 in the snprintf call. The length calculation does not account for the reduction of literal \"%s\" placeholders (2 times 2 characters) and only adds the three string lengths, thus causing the allocated buffer size to be potentially insufficient and snprintf may write beyond the allocated buffer size, violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  FILE *log_file = fopen(\"/tmp/logs/543.txt\", \"a\");\n\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  fprintf(log_file, \"Start fill_v1_v2_form\\n\");\n  fprintf(log_file, \"session->value_1 length: %zu\\n\", strlen(session->value_1));\n  fprintf(log_file, \"session->value_2 length: %zu\\n\", strlen(session->value_2));\n  fprintf(log_file, \"SECOND_PAGE length: %zu\\n\", strlen(SECOND_PAGE));\n\n  slen = strlen(SECOND_PAGE) + strlen(session->value_1) + strlen(session->value_2);\n  fprintf(log_file, \"Calculated buffer length slen: %zu\\n\", slen);\n\n  reply = malloc(slen + 1);\n  if (NULL == reply)\n  {\n    fprintf(log_file, \"Memory allocation failed\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  fprintf(log_file, \"Calling snprintf with buffer size: %zu\\n\", slen + 1);\n  int n = snprintf(reply, slen + 1, SECOND_PAGE, session->value_1, session->value_2);\n  fprintf(log_file, \"snprintf returned: %d\\n\", n);\n\n  if (n < 0 || (size_t)n >= slen + 1) {\n    fprintf(log_file, \"snprintf overflow detected\\n\");\n    free(reply);\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_with_free_callback(slen, (void *)reply, &free);\n  if (NULL == response)\n  {\n    fprintf(log_file, \"Failed to create response\\n\");\n    free(reply);\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  add_session_cookie(session, response);\n\n  if (MHD_YES != MHD_add_response_header(response, MHD_HTTP_HEADER_CONTENT_ENCODING, mime))\n  {\n    fprintf(stderr, \"Failed to set content encoding header!\\n\");\n  }\n\n  ret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n  MHD_destroy_response(response);\n\n  fprintf(log_file, \"End fill_v1_v2_form\\n\");\n  fclose(log_file);\n  return ret;\n}\n"
}