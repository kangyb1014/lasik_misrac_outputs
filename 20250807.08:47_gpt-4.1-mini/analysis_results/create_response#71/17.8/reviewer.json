{
  "user_message": "An agent A claimed that the following create_response code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of create_response.\n```c\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer parameter 'method' is modified within the function 'create_response' by the assignment 'method = MHD_HTTP_METHOD_GET;' when processing a POST request. According to MISRA C 2023 Rule 17.8, a function parameter should not be modified; modifying the pointer itself violates the rule even if the pointed-to object is not modified. Changing 'method' to point to a different string literal is a modification of the pointer parameter itself, hence violating the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  FILE *log_file = fopen(\"/tmp/logs/573.txt\", \"a\");\n  if (log_file == NULL)\n  {\n    /* If logging fails, proceed without logging */\n  }\n\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (log_file) fprintf(log_file, \"Entering create_response\\n\");\n  request = *req_cls;\n  if (NULL == request)\n  {\n    if (log_file) fprintf(log_file, \"Request pointer is NULL, allocating new Request\\n\");\n\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      if (log_file) fprintf(log_file, \"calloc failed: %s\\n\", strerror(errno));\n      if (log_file) fclose(log_file);\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        if (log_file) fprintf(log_file, \"Failed to create post processor for %s\\n\", url);\n        if (log_file) fclose(log_file);\n        return MHD_NO; /* internal error */\n      }\n    }\n    if (log_file) fprintf(log_file, \"Initial request created and post processor set if POST\\n\");\n    if (log_file) fclose(log_file);\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    if (log_file) fprintf(log_file, \"Session is NULL, obtaining session\\n\");\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      if (log_file) fprintf(log_file, \"Failed to get session for %s\\n\", url);\n      if (log_file) fclose(log_file);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n\n  session->start = time (NULL);\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    if (log_file) fprintf(log_file, \"Processing POST data\\n\");\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n    {\n      if (log_file) fprintf(log_file, \"MHD_post_process failed\\n\");\n      if (log_file) fclose(log_file);\n      return MHD_NO;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (log_file) fprintf(log_file, \"Upload data size not zero, resetting and returning MHD_YES\\n\");\n      *upload_data_size = 0;\n      if (log_file) fclose(log_file);\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    if (log_file) fprintf(log_file, \"Destroyed post processor\\n\");\n    request->pp = NULL;\n\n    /* Do not modify the method parameter, use a local variable instead */\n    if (log_file) fprintf(log_file, \"Setting local method_string from POST to GET\\n\");\n    const char *method_string = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n\n    const char *effective_url = url;\n\n    if (NULL != request->post_url)\n    {\n      if (log_file) fprintf(log_file, \"Modifying effective URL to post_url '%s'\\n\", request->post_url);\n      effective_url = request->post_url;\n    }\n\n    if ((0 == strcmp(method_string, MHD_HTTP_METHOD_GET)) ||\n        (0 == strcmp(method_string, MHD_HTTP_METHOD_HEAD)))\n    {\n      if (log_file) fprintf(log_file, \"Serving GET or HEAD request for URL: %s\\n\", effective_url);\n      /* find out which page to serve */\n      i = 0;\n      while ((pages[i].url != NULL) &&\n             (0 != strcmp(pages[i].url, effective_url)))\n         i++;\n      ret = pages[i].handler (pages[i].handler_cls,\n                              pages[i].mime,\n                              session, connection);\n      if (ret != MHD_YES)\n        fprintf(stderr, \"Failed to create page for `%s'\\n\",\n                effective_url);\n      if (log_file) fclose(log_file);\n      return ret;\n    }\n\n    /* unsupported HTTP method for POST evaluated as GET/HEAD */\n    response = MHD_create_response_from_buffer_static (\n                    strlen(METHOD_ERROR),\n                    (const void *) METHOD_ERROR);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_ACCEPTABLE, response);\n    MHD_destroy_response(response);\n    if (log_file) fclose(log_file);\n    return ret;\n  }\n\n  if ((0 == strcmp(method, MHD_HTTP_METHOD_GET)) ||\n      (0 == strcmp(method, MHD_HTTP_METHOD_HEAD)))\n  {\n    if (log_file) fprintf(log_file, \"Serving GET or HEAD request for URL: %s\\n\", url);\n    /* find out which page to serve */\n    i = 0;\n    while ((pages[i].url != NULL) &&\n           (0 != strcmp(pages[i].url, url)))\n      i++;\n    ret = pages[i].handler(pages[i].handler_cls,\n                          pages[i].mime,\n                          session, connection);\n    if (ret != MHD_YES)\n      fprintf(stderr, \"Failed to create page for `%s'\\n\",\n              url);\n    if (log_file) fclose(log_file);\n    return ret;\n  }\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static(strlen(METHOD_ERROR),\n                                           (const void *)METHOD_ERROR);\n  ret = MHD_queue_response(connection,\n                           MHD_HTTP_NOT_ACCEPTABLE,\n                           response);\n  MHD_destroy_response(response);\n  if (log_file) fclose(log_file);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter itself should not be modified. In the given original code, the parameter 'method' has type \"const char *\" and within the function, it is assigned a new pointer value: 'method = MHD_HTTP_METHOD_GET;'. This changes the pointer parameter 'method' itself, not the object it points to. According to the rule, while the object pointed to by a pointer parameter may be modified, the pointer parameter itself must not be changed. Therefore, this assignment violates Rule 17.8.\n\nAgent A's violation scenario correctly identifies this as a violation. The report is correct. The test code attempts to fix this by using a local variable for the modified method string instead of reassigning the parameter, but since it failed to compile, it does not impact the correctness of the violation report for the original code."
}