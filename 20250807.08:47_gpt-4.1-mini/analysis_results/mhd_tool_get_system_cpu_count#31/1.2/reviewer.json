{
  "user_message": "An agent A claimed that the following mhd_tool_get_system_cpu_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_system_cpu_count.\n```c\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n#endif /* __linux__ || __GLIBC__  */\n\n  return -1; /* Cannot detect */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses conditional compilation and compiler-specific extensions such as __linux__, __GLIBC__, __CYGWIN__, and Windows API functions including LoadLibraryA, GetProcAddress, and WINAPI calling conventions. These elements represent language/compiler-specific extensions or platform-specific APIs that are outside the standard C language specification and could be considered language extensions as per compiler documentation. Thus, usage of these clearly documented compiler/platform extensions violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint\nmhd_tool_get_system_cpu_count(void)\n{\n    FILE *log_file = fopen(\"/tmp/logs/248.txt\", \"a\");\n    if (log_file == NULL)\n    {\n        return -1;\n    }\n\n    int res;\n\n    fprintf(log_file, \"Entered mhd_tool_get_system_cpu_count()\\n\");\n\n    /* Try specialised APIs first */\n    res = mhd_tool_get_sys_cpu_count_special_api_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_special_api_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning early from special API with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    /* Try sysctl*(). This is typically a direct interface to kernel values. */\n    res = mhd_tool_get_sys_cpu_count_sysctl_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning early from sysctl with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    /* Try sysconf() as the last resort as this is a generic interface\n       which can be implemented by parsing system files. */\n    res = mhd_tool_get_sys_cpu_count_sysconf_();\n    #if !defined(__linux__) && !defined(__GLIBC__)\n    fprintf(log_file, \"Non-linux/glibc path with res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from non-linux/glibc sysconf with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #else /* __linux__ || __GLIBC__ */\n    fprintf(log_file, \"Linux or glibc path with res=%d\\n\", res);\n    if (res > 2)\n    {\n        fprintf(log_file, \"Returning from linux/glibc sysconf with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    if (res > 0)\n    {\n        fprintf(log_file, \"Sysconf result is 1 or 2, checking proc cpu count\\n\");\n\n        int proc_cpu_count;\n\n        proc_cpu_count = mhd_tool_get_proc_cpu_count();\n        fprintf(log_file, \"Proc CPU count=%d\\n\", proc_cpu_count);\n        if (proc_cpu_count == res)\n        {\n            fprintf(log_file, \"Proc CPU count equals sysconf result, returning res=%d\\n\", res);\n            fclose(log_file);\n            return res;\n        }\n    }\n    #endif /* __linux__ || __GLIBC__  */\n\n    /* Try available fallbacks */\n\n    res = mhd_tool_get_sys_cpu_count_sysctl_fallback_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_fallback_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from sysctl fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    res = mhd_tool_get_sys_cpu_count_sysconf_fallback_();\n    #if !defined(__linux__) && !defined(__GLIBC__)\n    fprintf(log_file, \"Non-linux/glibc fallback path res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from non-linux/glibc sysconf fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #else /* __linux__ || __GLIBC__ */\n    fprintf(log_file, \"Linux/glibc fallback path res=%d\\n\", res);\n    if (res > 2)\n    {\n        fprintf(log_file, \"Returning from linux/glibc sysconf fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #endif /* __linux__ || __GLIBC__  */\n\n    fprintf(log_file, \"No method succeeded, returning -1\\n\");\n    fclose(log_file);\n    return -1; /* Cannot detect */\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 specifies that language extensions should not be used unless explicitly documented as compiler extensions. The provided code uses conditional compilation directives checking for macros like __linux__ and __GLIBC__, which are predefined macros indicating the target operating system or C library implementation. These macros are not language extensions; they are predefined feature test macros provided by compilers to allow portable source code to adapt to environments. Using such predefined macros for conditional compilation is a standard and widely accepted practice in portable and compliant C code, especially when writing system-specific code where behavior depends on the target platform. Additionally, the code does not directly use any compiler-specific language extensions such as non-standard keywords, attributes, or language constructs beyond standard C and standard preprocessor directives. The related platform-specific API calls and constructs mentioned by agent A (such as WINAPI, LoadLibraryA, etc.) are not present in the provided code snippet, which only shows standard C and correct use of predefined macros. Therefore, the use of these predefined macros in #if directives does not violate Rule 1.2 because they are not language extensions but standard predefined macros. The failed compilation of the test code (which adds logging) is unrelated to whether language extensions were used or not; compilation errors do not prove violations of MISRA rules by themselves. In conclusion, agent A's claim that the code violates Rule 1.2 based on the usage of __linux__, __GLIBC__, or platform API calls is incorrect for the code provided, as such usage does not constitute language extensions under the MISRA definition."
}