{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  FILE *log_file = fopen(\"/tmp/logs/248.txt\", \"a\");\n  if(NULL == log_file)\n  {\n    return -1;\n  }\n\n  int res;\n\n  fprintf(log_file, \"Entered mhd_tool_get_system_cpu_count()\\n\");\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_special_api_, res=%d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning early from special API with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  /* Try sysctl*(). This is typically a direct interface to kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_, res=%d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning early from sysctl with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  fprintf(log_file, \"Non-linux/glibc path with res=%d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning from non-linux/glibc sysconf with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n#else  /* __linux__ || __GLIBC__ */\n  fprintf(log_file, \"Linux or glibc path with res=%d\\n\", res);\n  if (2 < res)\n  {\n    fprintf(log_file, \"Returning from linux/glibc sysconf with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n  if (0 < res)\n  {\n    fprintf(log_file, \"Sysconf result is 1 or 2, checking proc cpu count\\n\");\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    fprintf(log_file, \"Proc CPU count=%d\\n\", proc_cpu_count);\n    if (proc_cpu_count == res)\n    {\n      fprintf(log_file, \"Proc CPU count equals sysconf result, returning res=%d\\n\", res);\n      fclose(log_file);\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_fallback_, res=%d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning from sysctl fallback with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  fprintf(log_file, \"Non-linux/glibc fallback path res=%d\\n\", res);\n  if (0 < res)\n  {\n    fprintf(log_file, \"Returning from non-linux/glibc sysconf fallback with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n#else  /* __linux__ || __GLIBC__ */\n  fprintf(log_file, \"Linux/glibc fallback path res=%d\\n\", res);\n  if (2 < res)\n  {\n    fprintf(log_file, \"Returning from linux/glibc sysconf fallback with res=%d\\n\", res);\n    fclose(log_file);\n    return res;\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  fprintf(log_file, \"No method succeeded, returning -1\\n\");\n  fclose(log_file);\n  return -1; /* Cannot detect */\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpcihijzi5/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_system_cpu_count as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "int\nmhd_tool_get_system_cpu_count(void)\n{\n    FILE *log_file = fopen(\"/tmp/logs/248.txt\", \"a\");\n    if (log_file == NULL)\n    {\n        return -1;\n    }\n\n    int res;\n\n    fprintf(log_file, \"Entered mhd_tool_get_system_cpu_count()\\n\");\n\n    /* Try specialised APIs first */\n    res = mhd_tool_get_sys_cpu_count_special_api_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_special_api_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning early from special API with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    /* Try sysctl*(). This is typically a direct interface to kernel values. */\n    res = mhd_tool_get_sys_cpu_count_sysctl_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning early from sysctl with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    /* Try sysconf() as the last resort as this is a generic interface\n       which can be implemented by parsing system files. */\n    res = mhd_tool_get_sys_cpu_count_sysconf_();\n    #if !defined(__linux__) && !defined(__GLIBC__)\n    fprintf(log_file, \"Non-linux/glibc path with res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from non-linux/glibc sysconf with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #else /* __linux__ || __GLIBC__ */\n    fprintf(log_file, \"Linux or glibc path with res=%d\\n\", res);\n    if (res > 2)\n    {\n        fprintf(log_file, \"Returning from linux/glibc sysconf with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    if (res > 0)\n    {\n        fprintf(log_file, \"Sysconf result is 1 or 2, checking proc cpu count\\n\");\n\n        int proc_cpu_count;\n\n        proc_cpu_count = mhd_tool_get_proc_cpu_count();\n        fprintf(log_file, \"Proc CPU count=%d\\n\", proc_cpu_count);\n        if (proc_cpu_count == res)\n        {\n            fprintf(log_file, \"Proc CPU count equals sysconf result, returning res=%d\\n\", res);\n            fclose(log_file);\n            return res;\n        }\n    }\n    #endif /* __linux__ || __GLIBC__  */\n\n    /* Try available fallbacks */\n\n    res = mhd_tool_get_sys_cpu_count_sysctl_fallback_();\n    fprintf(log_file, \"After mhd_tool_get_sys_cpu_count_sysctl_fallback_, res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from sysctl fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n\n    res = mhd_tool_get_sys_cpu_count_sysconf_fallback_();\n    #if !defined(__linux__) && !defined(__GLIBC__)\n    fprintf(log_file, \"Non-linux/glibc fallback path res=%d\\n\", res);\n    if (res > 0)\n    {\n        fprintf(log_file, \"Returning from non-linux/glibc sysconf fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #else /* __linux__ || __GLIBC__ */\n    fprintf(log_file, \"Linux/glibc fallback path res=%d\\n\", res);\n    if (res > 2)\n    {\n        fprintf(log_file, \"Returning from linux/glibc sysconf fallback with res=%d\\n\", res);\n        fclose(log_file);\n        return res;\n    }\n    #endif /* __linux__ || __GLIBC__  */\n\n    fprintf(log_file, \"No method succeeded, returning -1\\n\");\n    fclose(log_file);\n    return -1; /* Cannot detect */\n}\n",
  "explanation": "The original code snippet is syntactically correct for C code and only contains function definitions and conditional compilation. The reported build error is unrelated to this C source code; it is due to a missing external tool called 'makeinfo' required during documentation generation, which is managed outside of the code itself.\n\nIn other words, the compilation error is from the build environment, not from the code syntax. Therefore, the code as provided would compile correctly in a proper environment with the necessary tools installed.\n\nHowever, to ensure portability and maintain best practices, I replaced all occurrences of comparisons like \"0 < res\" and \"2 < res\" with the more conventional and clearer \"res > 0\" or \"res > 2\". This improves readability and prevents any potential warnings from some compilers regarding unusual comparison constructs.\n\nNo logic or functionality was changed, and no additional functions or macros were added or mocked up as per instructions.\n\nIf the build environment requires fixing, you should install the Texinfo package to provide 'makeinfo' or review the makefile and install GNU Make if needed. This is an environment setup issue, not a C code syntax issue."
}