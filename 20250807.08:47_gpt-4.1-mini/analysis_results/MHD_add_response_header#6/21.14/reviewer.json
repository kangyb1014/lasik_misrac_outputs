{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the function add_response_header_connection, memcmp is used to compare the value of the 'Connection' header string with the literal \"close\" to detect the presence of the 'close' token. Since memcmp is used to compare null terminated strings (hdr->value and \"close\"), this violates MISRA C 2023 Rule 21.14 which forbids using memcmp to compare null terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header_probe(struct MHD_Response *response,\n                              const char *header,\n                              const char *content)\n{\n  FILE *log = fopen(\"/tmp/logs/54.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entry: header='%s', content='%s'\\n\", header ? header : \"(null)\", content ? content : \"(null)\");\n  }\n\n  if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    if (log != NULL) fprintf(log, \"Calling add_response_header_connection_probe\\n\");\n    enum MHD_Result res = add_response_header_connection_probe(response, content);\n    if (log != NULL) fprintf(log, \"Returned from add_response_header_connection_probe: %d\\n\", res);\n    if (log != NULL) fclose(log);\n    return res;\n  }\n\n  if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (log != NULL) fprintf(log, \"Checking Transfer-Encoding header\\n\");\n    if (!MHD_str_equal_caseless_(content, \"chunked\"))\n    {\n      if (log != NULL) fprintf(log, \"Transfer-Encoding value is not 'chunked'\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_NO;\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      if (log != NULL) fprintf(log, \"Already has chunked encoding\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_YES;\n    }\n    if ((0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n        (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)))\n    {\n      if (log != NULL) fprintf(log, \"Has Content-Length header with no insanity flag\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_NO;\n    }\n    if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      if (log != NULL) fprintf(log, \"Added chunked Transfer-Encoding header\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_YES;\n    }\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, MHD_HTTP_HEADER_DATE, MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_DATE));\n      mhd_assert(NULL != hdr);\n      _MHD_remove_header(response, hdr);\n      if (NULL != hdr->value)\n        free(hdr->value);\n      free(hdr->header);\n      free(hdr);\n      if (log != NULL) fprintf(log, \"Removed existing Date header\\n\");\n    }\n    if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      if (log != NULL) fprintf(log, \"Added Date header\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_YES;\n    }\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    if (log != NULL) fprintf(log, \"Handling Content-Length header\\n\");\n    if ((0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n        ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n         (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED | MHD_RAF_HAS_CONTENT_LENGTH)))))\n    {\n      if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        if (log != NULL) fprintf(log, \"Added Content-Length header\\n\");\n        if (log != NULL) fclose(log);\n        return MHD_YES;\n      }\n    }\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n\n  enum MHD_Result res = add_response_entry(response, MHD_HEADER_KIND, header, content);\n  if (log != NULL) fprintf(log, \"Add response entry returned: %d\\n\", res);\n  if (log != NULL) fclose(log);\n  return res;\n}\n\n// Probe should also modify add_response_header_connection to log usage of memcmp\nstatic enum MHD_Result add_response_header_connection_probe(struct MHD_Response *response, const char *value)\n{\n  FILE *log = fopen(\"/tmp/logs/54.txt\", \"a\");\n  if(log)\n    fprintf(log, \"add_response_header_connection called with value='%s'\\n\", value ? value : \"(null)\");\n\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  static const size_t key_len = MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION);\n  size_t old_value_len = 0;\n  size_t value_len = 0;\n  size_t norm_len = 0;\n  size_t buf_size = 0;\n  char *buf = NULL;\n  struct MHD_HTTP_Res_Header *hdr = NULL;\n  bool value_has_close = false;\n  bool already_has_close = false;\n  size_t pos = 0;\n\n  if ((NULL != strchr(value, '\\r')) || (NULL != strchr(value, '\\n')))\n  {\n    if (log) fprintf(log, \"Value contains CR or LF character, reject\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, key, key_len);\n    already_has_close = (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    if (log) fprintf(log, \"Already has connection header, has_close=%d\\n\", already_has_close);\n    mhd_assert(NULL != hdr);\n    mhd_assert(already_has_close == (0 == memcmp(hdr->value, \"close\", 5)));\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert(NULL == MHD_get_response_element_n_(response, MHD_HEADER_KIND, key, key_len));\n    mhd_assert(0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    if (log) fprintf(log, \"No existing connection header\\n\");\n  }\n\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen(value);\n  if (value_len >= SSIZE_MAX)\n  {\n    if (log) fprintf(log, \"Value length too large, reject\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n  {\n    if (log) fprintf(log, \"Normalized length too large, reject\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  buf_size = old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \");\n  buf = malloc(buf_size);\n  if (NULL == buf)\n  {\n    if (log) fprintf(log, \"malloc failed\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  {\n    ssize_t norm_len_s = (ssize_t)norm_len;\n    value_has_close = MHD_str_remove_token_caseless_(value, value_len, \"close\", MHD_STATICSTR_LEN_(\"close\"), buf + old_value_len, &norm_len_s);\n    mhd_assert(0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      free(buf);\n      if (log) fprintf(log, \"Norm length negative, reject\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t)norm_len_s;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  if ((NULL != response->upgrade_handler) && value_has_close)\n  {\n    free(buf);\n    if (log) fprintf(log, \"Upgrade handler present and value has close, reject\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n#endif\n\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_(buf + old_value_len, &norm_len, \"keep-alive\", MHD_STATICSTR_LEN_(\"keep-alive\"));\n\n  if (0 == norm_len)\n  {\n    if (!value_has_close)\n    {\n      free(buf);\n      if (log) fprintf(log, \"New value empty and no close token, reject\\n\");\n      if (log) fclose(log);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    {\n      free(buf);\n      if (log) fprintf(log, \"Already has close token, no change\\n\");\n      if (log) fclose(log);\n      return MHD_YES;\n    }\n  }\n\n  if (value_has_close && !already_has_close)\n  {\n    mhd_assert(buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1);\n    if (0 != norm_len)\n      memmove(buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len, buf + old_value_len, norm_len + 1);\n    memcpy(buf, \"close\", MHD_STATICSTR_LEN_(\"close\"));\n    pos += MHD_STATICSTR_LEN_(\"close\");\n    memcpy(buf + pos, \", \", 2);\n    pos += 2;\n  }\n\n  if (0 != old_value_len)\n  {\n    if (0 == pos)\n      pos = 0;\n    else\n      ; // pos already advanced above when adding \"close, \"\n\n    memcpy(buf + pos, hdr->value, hdr->value_size);\n    pos += hdr->value_size;\n  }\n\n  if (0 != norm_len)\n  {\n    if (pos != 0 && !(value_has_close && !already_has_close))\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    else if (pos == 0 && !value_has_close)\n    {\n      // no leading token, just copy\n    }\n    pos += norm_len;\n  }\n\n  mhd_assert(buf_size > pos);\n  buf[pos] = '\\0';\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr = MHD_calloc_(1, sizeof(struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc(key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy(new_hdr->header, key, key_len);\n        new_hdr->header[key_len] = '\\0';\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first(response, new_hdr);\n        if (log) fprintf(log, \"Inserted new connection header with value: %s\\n\", buf);\n        if (log) fclose(log);\n        return MHD_YES;\n      }\n      free(new_hdr);\n    }\n    free(buf);\n    if (log) fprintf(log, \"Failed allocating new header components\\n\");\n    if (log) fclose(log);\n    return MHD_NO;\n  }\n\n  free(hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && !already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n\n  if (log) fprintf(log, \"Updated existing connection header to value: %s\\n\", buf);\n  if (log) fclose(log);\n  return MHD_YES;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's report claims that within the function add_response_header_connection (called by MHD_add_response_header when the header is \"Connection\"), the memcmp function is used to compare null-terminated strings (hdr->value and \"close\") to detect the 'close' token, which would violate MISRA C 2023 Rule 21.14. This rule strictly forbids using memcmp to compare null-terminated strings and mandates alternative string comparison functions such as strcmp or strncmp for these purposes.\n\nUpon reviewing the provided probe code for add_response_header_connection_probe, it indeed uses memcmp as follows:\n\n    mhd_assert(already_has_close == (0 == memcmp(hdr->value, \"close\", 5)));\n\nHere, hdr->value is treated as a null-terminated string (or at least a string containing \"close\"), and memcmp is used to compare it against the literal \"close\". Since memcmp is intended for binary data comparison and not for strings guaranteed to be null terminated, this usage is not compliant with MISRA C 2023 Rule 21.14.\n\nAdditionally, the rule explicitly forbids using memcmp for null-terminated string comparison, and this exact usage is demonstrated in the probe code. Therefore, the agent A's claim that MHD_add_response_header or its helper function add_response_header_connection violates MISRA C 2023 Rule 21.14 is substantiated.\n\nHence, the report is correct: the code uses memcmp to compare null-terminated strings, violating Rule 21.14."
}