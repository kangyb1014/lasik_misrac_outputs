{
  "user_message": "An agent A claimed that the following parse_options code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of parse_options.\n```c\nstatic enum MHD_Result\nparse_options (struct MHD_Daemon *daemon,\n               struct MHD_InterimParams_ *params,\n               ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n\n  va_start (ap, params);\n  ret = parse_options_va (daemon,\n                          params,\n                          ap);\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen on a potentially unbounded string pointer `pstr` parameter in MHD_OPTION_HTTPS_MEM_DHPARAMS case to get its length, without explicit bounds checking before accessing the string data. If `pstr` does not point to a valid null-terminated string or points beyond allocated memory, this could cause out-of-bounds access violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nparse_options (struct MHD_Daemon *daemon,\n               struct MHD_InterimParams_ *params,\n               ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  FILE *log_file = fopen(\"/tmp/logs/399.txt\", \"a\");\n\n  va_start (ap, params);\n  if (log_file != NULL)\n  {\n    /* Use %zu to print size_t type */\n    fprintf(log_file, \"parse_options called with params: num_opts=%zu\\n\", params->num_opts);\n    fflush(log_file);\n  }\n\n  ret = parse_options_va (daemon,\n                          params,\n                          ap);\n\n  va_end (ap);\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"parse_options return value: %d\\n\", ret);\n    fclose(log_file);\n  }\n\n  return ret;\n}\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  FILE *log_file = fopen(\"/tmp/logs/399.txt\", \"a\");\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    params->num_opts++;\n    switch (opt)\n    {\n    /* ... other cases unchanged ... */\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      {\n        const char *pstr = va_arg (ap, const char *);\n        if (log_file != NULL)\n        {\n          fprintf(log_file, \"MHD_OPTION_HTTPS_MEM_DHPARAMS option received, pstr pointer=%p\\n\", (void *)pstr);\n          fflush(log_file);\n        }\n        if (0 != (daemon->options & MHD_USE_TLS))\n        {\n          gnutls_datum_t dhpar;\n          size_t pstr_len;\n\n          if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n          {\n            if (log_file != NULL)\n            {\n              fprintf(log_file, \"Error initializing DH parameters.\\n\");\n              fflush(log_file);\n            }\n            return MHD_NO;\n          }\n\n          /* Potentially unsafe strlen on pstr - log length before use */\n          pstr_len = strlen (pstr);\n          if (log_file != NULL)\n          {\n            fprintf(log_file, \"Calculated pstr length: %zu\\n\", pstr_len);\n            fflush(log_file);\n          }\n\n          if (UINT_MAX < pstr_len)\n          {\n            if (log_file != NULL)\n            {\n              fprintf(log_file, \"Diffie-Hellman parameters string too long.\\n\");\n              fflush(log_file);\n            }\n            return MHD_NO;\n          }\n\n          dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n          dhpar.size = (unsigned int) pstr_len;\n          if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                             &dhpar,\n                                             GNUTLS_X509_FMT_PEM) < 0)\n          {\n            if (log_file != NULL)\n            {\n              fprintf(log_file, \"Bad Diffie-Hellman parameters format.\\n\");\n              fflush(log_file);\n            }\n            gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n            return MHD_NO;\n          }\n          daemon->have_dhparams = true;\n        }\n        else\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                       \"MHD_USE_TLS not set.\\n\"),\n                    opt);\n#endif\n          if (log_file != NULL)\n          {\n            fprintf(log_file, \"MHD_USE_TLS not set when MHD_OPTION_HTTPS_MEM_DHPARAMS received.\\n\");\n            fflush(log_file);\n          }\n        }\n      }\n      break;\n#endif\n    /* ... other cases unchanged ... */\n    }\n  }\n  if (log_file != NULL) fclose(log_file);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of strlen on the pointer `pstr` in the MHD_OPTION_HTTPS_MEM_DHPARAMS case without explicit prior validation that `pstr` points to a valid null-terminated string within allocated bounds. MISRA C 2023 Rule 21.17 specifically prohibits using string.h functions in a way that can cause out-of-bounds accesses. In the given code, there is no explicit check that `pstr` is non-NULL or that it points to a valid string of sufficient length before calling strlen, which may lead to undefined behavior or out-of-bounds access if `pstr` is invalid. Although the code checks the length returned by strlen for an upper bound (against UINT_MAX), it does not prevent strlen itself from causing out-of-bounds access if the string is not properly terminated or invalid. Therefore, the code can violate Rule 21.17 as it does not ensure that the use of strlen is safe with respect to the bounds of the string. The scenario provided by agent A is valid, and the report is correct. The failure to compile the test code is unrelated to the conceptual violation."
}