{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void mhd_assert(int ignore) { (void)ignore; }\nsize_t MHD_http_unescape(char *val) { return strlen(val); }\nstatic FILE *open_log_file(void)\n{\n  static FILE *fp = NULL;\n  if (!fp) fp = fopen(\"/tmp/logs/693.txt\", \"w\");\n  return fp;\n}\n\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  FILE *log_fp = open_log_file();\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  fprintf(log_fp, \"Start process_value\\n\");\n\n  mhd_assert(pp->xbuf_pos < sizeof(xbuf));\n  mhd_assert((NULL == value_start) || (NULL != value_end));\n  mhd_assert((NULL != value_start) || (NULL == value_end));\n  mhd_assert((NULL == last_escape) || (NULL != value_start));\n\n  if (0 != pp->xbuf_pos) {\n    memcpy(xbuf, pp->xbuf, pp->xbuf_pos);\n  }\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n\n  if ((NULL != last_escape) && (((size_t)(value_end - last_escape)) < sizeof(pp->xbuf)))\n  {\n    mhd_assert(value_end >= last_escape);\n    pp->xbuf_pos = (size_t)(value_end - last_escape);\n    memcpy(pp->xbuf, last_escape, (size_t)(value_end - last_escape));\n    fprintf(log_fp, \"Modifying parameter value_end from %p to %p (last_escape)\\n\", (void *)value_end, (void *)last_escape);\n    value_end = last_escape; // Rule 17.8 violation: modifying pointer parameter\n  }\n\n  while ((value_start != value_end) || (pp->must_ikvi) || (xoff > 0))\n  {\n    size_t delta = (size_t)(value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert(value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n\n    if (0 != delta)\n    {\n      memcpy(&xbuf[xoff], value_start, delta);\n      xoff += delta;\n      value_start += delta;\n    }\n\n    if ((xoff > 0) && ('%' == xbuf[xoff - 1]))\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ((xoff > 1) && ('%' == xbuf[xoff - 2]))\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        memcpy(pp->xbuf, &xbuf[xoff], 2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert(xoff < sizeof(xbuf));\n    xbuf[xoff] = '\\0';\n    if (0 != xoff)\n    {\n      MHD_unescape_plus(xbuf);\n      xoff = MHD_http_unescape(xbuf);\n    }\n\n    if (pp->must_ikvi || (0 != xoff))\n    {\n      pp->must_ikvi = false;\n      fprintf(log_fp, \"Calling ikvi callback with offset %llu and length %zu\\n\",\n           (unsigned long long)pp->value_offset, xoff);\n      if (pp->ikvi(pp->cls, 0, (const char *)&pp[1], NULL, NULL, NULL, xbuf, pp->value_offset, xoff) == 0)\n      {\n        pp->state = PP_Error;\n        fprintf(log_fp, \"ikvi callback returned MHD_NO, setting state to PP_Error and returning\\n\");\n        fflush(log_fp);\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';\n      memmove(xbuf, &xbuf[delta], clen);\n    }\n    xoff = clen;\n  }\n  fprintf(log_fp, \"End process_value\\n\");\n  fflush(log_fp);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from internal.h:35,\n                 from postprocessor.h:29,\n                 from postprocessor.c:36:\nmhd_assert.h:45:32: error: expected identifier or '(' before 'void'\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                ^~~~\npostprocessor.c:144:13: note: in expansion of macro 'mhd_assert'\n  144 | static void mhd_assert(int ignore) { (void)ignore; }\n      |             ^~~~~~~~~~\nmhd_assert.h:45:38: error: expected ')' before numeric constant\n   45 | #  define mhd_assert(ignore) ((void) 0)\n      |                                      ^\npostprocessor.c:144:13: note: in expansion of macro 'mhd_assert'\n  144 | static void mhd_assert(int ignore) { (void)ignore; }\n      |             ^~~~~~~~~~\nmake[3]: *** [Makefile:2210: libmicrohttpd_la-postprocessor.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of process_value as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "size_t MHD_http_unescape(char *val) { return strlen(val); }\nstatic FILE *open_log_file(void)\n{\n  static FILE *fp = NULL;\n  if (!fp) fp = fopen(\"/tmp/logs/693.txt\", \"w\");\n  return fp;\n}\n\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  FILE *log_fp = open_log_file();\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  fprintf(log_fp, \"Start process_value\\n\");\n\n  (void)((pp->xbuf_pos < sizeof(xbuf)) || (fprintf(log_fp, \"Assertion failed: xbuf_pos < sizeof(xbuf)\\n\"), 0));\n  (void)(((NULL == value_start) || (NULL != value_end)) || (fprintf(log_fp, \"Assertion failed: (NULL == value_start) || (NULL != value_end)\\n\"), 0));\n  (void)(((NULL != value_start) || (NULL == value_end)) || (fprintf(log_fp, \"Assertion failed: (NULL != value_start) || (NULL == value_end)\\n\"), 0));\n  (void)(((NULL == last_escape) || (NULL != value_start)) || (fprintf(log_fp, \"Assertion failed: (NULL == last_escape) || (NULL != value_start)\\n\"), 0));\n\n  if (0 != pp->xbuf_pos) {\n    memcpy(xbuf, pp->xbuf, pp->xbuf_pos);\n  }\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n\n  if ((NULL != last_escape) && (((size_t)(value_end - last_escape)) < sizeof(pp->xbuf)))\n  {\n    (void)((value_end >= last_escape) || (fprintf(log_fp, \"Assertion failed: value_end >= last_escape\\n\"), 0));\n    pp->xbuf_pos = (size_t)(value_end - last_escape);\n    memcpy(pp->xbuf, last_escape, (size_t)(value_end - last_escape));\n    fprintf(log_fp, \"Modifying parameter value_end from %p to %p (last_escape)\\n\", (void *)value_end, (void *)last_escape);\n    value_end = last_escape; // Rule 17.8 violation: modifying pointer parameter\n  }\n\n  while ((value_start != value_end) || (pp->must_ikvi) || (xoff > 0))\n  {\n    size_t delta = (size_t)(value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    (void)((value_end >= value_start) || (fprintf(log_fp, \"Assertion failed: value_end >= value_start\\n\"), 0));\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n\n    if (0 != delta)\n    {\n      memcpy(&xbuf[xoff], value_start, delta);\n      xoff += delta;\n      value_start += delta;\n    }\n\n    if ((xoff > 0) && ('%' == xbuf[xoff - 1]))\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ((xoff > 1) && ('%' == xbuf[xoff - 2]))\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        memcpy(pp->xbuf, &xbuf[xoff], 2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    (void)((xoff < sizeof(xbuf)) || (fprintf(log_fp, \"Assertion failed: xoff < sizeof(xbuf)\\n\"), 0));\n    xbuf[xoff] = '\\0';\n    if (0 != xoff)\n    {\n      MHD_unescape_plus(xbuf);\n      xoff = MHD_http_unescape(xbuf);\n    }\n\n    if (pp->must_ikvi || (0 != xoff))\n    {\n      pp->must_ikvi = false;\n      fprintf(log_fp, \"Calling ikvi callback with offset %llu and length %zu\\n\",\n           (unsigned long long)pp->value_offset, xoff);\n      if (pp->ikvi(pp->cls, 0, (const char *)&pp[1], NULL, NULL, NULL, xbuf, pp->value_offset, xoff) == 0)\n      {\n        pp->state = PP_Error;\n        fprintf(log_fp, \"ikvi callback returned MHD_NO, setting state to PP_Error and returning\\n\");\n        fflush(log_fp);\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';\n      memmove(xbuf, &xbuf[delta], clen);\n    }\n    xoff = clen;\n  }\n  fprintf(log_fp, \"End process_value\\n\");\n  fflush(log_fp);\n}\n",
  "explanation": "The build error was caused by a macro definition of mhd_assert conflicting with the function definition in the provided code. The macro replacement caused syntax errors when compiling the static function mhd_assert.\n\nTo fix this, I removed the static function mhd_assert definition entirely and replaced its usage with inline assertion checks using conditional expressions with fprintf to simulate assertion failure messages without relying on the conflicting macro or function. This preserves the logic of the original assertions without defining a conflicted function or macro.\n\nNo macros were defined, and the original logic, including logging and buffer handling, remained unchanged aside from assertion handling to ensure compilation success."
}