{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the function 'keepalive_possible', a pointer 'r' is declared as 'struct MHD_Response * const r', pointing to a 'struct MHD_Response' non-const type. However, all usages of 'r' in this function are read-only accesses; the function does not modify the object pointed to by 'r'. According to MISRA C 2023 Rule 8.13, pointer variables should point to const-qualified types whenever possible if the data is not modified. Since the pointer 'r' could (and should) be declared as 'const struct MHD_Response * const r', the current code violates Rule 8.13 by not qualifying the pointer to const when possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct Request {\n    int http_ver;\n};\nstruct Reply {\n    struct MHD_Response *response;\n};\nstatic void log_state(const char *message)\n{\n    FILE *log_fp = fopen(\"/tmp/logs/147.txt\", \"a\");\n    if (log_fp == NULL) return;\n    fprintf(log_fp, \"%s\\n\", message);\n    fclose(log_fp);\n}\nint MHD_lookup_header_s_token_ci(void *c, const char *h, const char *tkn)\n{\n    (void)c; (void)h; (void)tkn;\n    return 0; // stub\n}\nvoid mhd_assert(bool cond) { if (!cond) { log_state(\"Assertion failed\"); } }\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  /* Violation scenario: r pointer should be to const because it is not modified */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  log_state(\"Entered keepalive_possible\");\n  mhd_assert (NULL != r);\n\n  log_state(\"Checked for MHD_CONN_MUST_CLOSE\");\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    log_state(\"keepalive must close\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != r->upgrade_handler)\n  {\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    log_state(\"Must upgrade due to upgrade_handler\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    log_state(\"Must close due to read_closed or discard_request\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    log_state(\"Must close due to HTTP 1.0 strict flag\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    log_state(\"Must close due to connection close flag\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    log_state(\"Must close due to unsupported HTTP version\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    log_state(\"Must close due to close token in connection header\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      log_state(\"Use keepalive for HTTP 1.0 with Keep-Alive token\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    log_state(\"Must close due to HTTP 1.0 without Keep-Alive\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    log_state(\"Use keepalive due to HTTP 1.1 compatible version\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  log_state(\"Must close by default\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 promotes the use of pointers to const-qualified types whenever the pointed-to object is not modified in the function. In the function 'keepalive_possible', the pointer 'r' is declared as 'struct MHD_Response * const r', meaning 'r' itself is constant, but the pointed-to data is non-const and could theoretically be modified. However, in the function, all uses of 'r' access members only for reading; there is no modification of the pointed-to object. Therefore, the pointer 'r' could be declared as 'const struct MHD_Response * const r' to better express its intended usage and comply with the rule. The agent A's report notes this exact detail and hence is valid. While this is a relatively minor issue, strictly from a MISRA compliance perspective, the code as-is violates Rule 8.13 because it does not use const-qualified pointer to a type whenever possible. The failure of the provided test code to compile or produce logs does not invalidate the logic of the rule violation claim; it may reflect issues in the test environment or code snippet completeness but does not negate the factual const qualification requirement in the target code. Thus, the report that the code violates MISRA C 2023 Rule 8.13 is correct."
}