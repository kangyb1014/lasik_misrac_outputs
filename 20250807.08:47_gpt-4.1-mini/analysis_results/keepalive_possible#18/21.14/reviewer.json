{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function keepalive_possible uses MHD_lookup_header_s_token_ci to check for tokens like \"close\" or \"Keep-Alive\" in HTTP headers. Assuming MHD_lookup_header_s_token_ci uses memcmp internally to compare these tokens against null terminated strings (e.g., the header values), this would violate MISRA C 2023 Rule 21.14, which prohibits using memcmp to compare null terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int MHD_lookup_header_token_ci(const struct MHD_Connection *c, const char *header, size_t header_len, const char *token, size_t token_len) {\n    FILE *fp = fopen(\"/tmp/logs/150.txt\", \"a\");\n    if (fp) {\n        fprintf(fp, \"Entered MHD_lookup_header_token_ci with header='%s', token='%s'\\n\", header, token);\n        fclose(fp);\n    }\n\n    // Example violation: memcmp used to compare null terminated strings\n    // Note: This is the violation - directly comparing token with a null terminated string.\n    if (memcmp(token, \"close\", strlen(\"close\") + 1) == 0 || memcmp(token, \"Keep-Alive\", strlen(\"Keep-Alive\") + 1) == 0) {\n        fp = fopen(\"/tmp/logs/150.txt\", \"a\");\n        if (fp) {\n            fprintf(fp, \"memcmp used to compare null terminated strings - violation occurred\\n\");\n            fclose(fp);\n        }\n        return 1; // token found\n    }\n    return 0;\n}\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible(struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Reply *const r = c->rp;  /**< a short alias, changed type to MHD_Reply */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != r->upgrade_handler)\n  {\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ((! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.14 specifically prohibits using the standard library function memcmp to compare null terminated strings. The given code in keepalive_possible itself does not explicitly call memcmp; it calls a helper function MHD_lookup_header_s_token_ci to look up tokens in HTTP headers. The agent A hypothesizes that MHD_lookup_header_s_token_ci internally uses memcmp to compare null terminated strings (like \"close\" or \"Keep-Alive\" tokens) and thus violates Rule 21.14. However, the actual implementation of MHD_lookup_header_s_token_ci is not given in the target code, and the provided test code that attempts to demonstrate the violation by calling memcmp directly is a hypothetical construct, not the actual code. Also, the test code does not compile, so no real evidence shows this violation in the original or invoked code. Without concrete evidence or code showing that memcmp is used on null terminated strings inside MHD_lookup_header_s_token_ci, the claim is speculative. Therefore, the report is not confirmed as correct for the target_code itself. If MHD_lookup_header_s_token_ci were to use memcmp improperly as described, that function (not keepalive_possible) would violate the MISRA rule, but no conclusive proof exists from the given information."
}