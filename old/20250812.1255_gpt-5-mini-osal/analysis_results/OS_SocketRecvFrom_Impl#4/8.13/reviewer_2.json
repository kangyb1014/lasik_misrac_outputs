{
  "user_message": "An agent A claimed that the following OS_SocketRecvFrom_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketRecvFrom_Impl.\n```c\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n        }\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    return_code = OS_QUEUE_EMPTY;\n                }\n                else\n                {\n                    OS_DEBUG(\"recvfrom: %s\\n\", strerror(errno));\n                    return_code = OS_ERROR;\n                }\n            }\n            else\n            {\n                return_code = os_result;\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                }\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'impl' is declared as a mutable pointer (OS_impl_file_internal_record_t *impl) but in this function it is only read from (no modifications of *impl). Per MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. For example the declaration could be changed to: const OS_impl_file_internal_record_t *impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/35.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    /* Record entry and input parameters */\n    probe_log(\"ENTER OS_SocketRecvFrom_Impl: token=%p token_val=%p buffer=%p buflen=%zu RemoteAddr=%p timeout=%ld\\n\",\n              (const void *)token, (const void *)(token ? (const void *)token : NULL), buffer, buflen, (const void *)RemoteAddr, (long)timeout);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /* Log the impl pointer and some known fields used below (selectable, fd) */\n    probe_log(\"impl pointer=%p\\n\", (const void *)impl);\n    if (impl != NULL)\n    {\n        /* Access the fields that are used later for diagnostic purposes */\n        probe_log(\"impl->selectable=%d impl->fd=%d\\n\", (int)impl->selectable, (int)impl->fd);\n    }\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n        probe_log(\"RemoteAddr is NULL -> sa=NULL addrlen=0\\n\");\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n        probe_log(\"RemoteAddr provided -> sa=%p initial_addrlen=%u\\n\", (const void *)sa, (unsigned)addrlen);\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    probe_log(\"Initial operation mask=0x%08x\\n\", (unsigned)operation);\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        probe_log(\"impl->selectable true -> calling OS_SelectSingle_Impl with timeout=%ld\\n\", (long)timeout);\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n        probe_log(\"OS_SelectSingle_Impl returned %ld operation=0x%08x\\n\", (long)return_code, (unsigned)operation);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n            probe_log(\"impl->selectable false and timeout==0 -> waitflags=MSG_DONTWAIT\\n\");\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n            probe_log(\"impl->selectable false and timeout!=0 -> waitflags=0 (timeout not honored)\\n\");\n        }\n        return_code = OS_SUCCESS;\n        probe_log(\"Set return_code=OS_SUCCESS (no select)\\n\");\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            probe_log(\"operation not readable (operation=0x%08x) -> returning OS_ERROR_TIMEOUT\\n\", (unsigned)operation);\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            probe_log(\"About to call recvfrom: fd=%d buffer=%p buflen=%zu waitflags=0x%08x sa=%p addrlen=%u\\n\",\n                      impl->fd, buffer, buflen, (unsigned)waitflags, (const void *)sa, (unsigned)addrlen);\n\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n\n            probe_log(\"recvfrom returned os_result=%d errno=%d (%s) addrlen=%u\\n\",\n                      os_result, errno, strerror(errno), (unsigned)addrlen);\n\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    probe_log(\"recvfrom EAGAIN/EWOULDBLOCK -> OS_QUEUE_EMPTY\\n\");\n                    return_code = OS_QUEUE_EMPTY;\n                }\n                else\n                {\n                    OS_DEBUG(\"recvfrom: %s\\n\", strerror(errno));\n                    probe_log(\"recvfrom error -> OS_ERROR (errno=%d %s)\\n\", errno, strerror(errno));\n                    return_code = OS_ERROR;\n                }\n            }\n            else\n            {\n                return_code = os_result;\n                probe_log(\"recvfrom success -> return_code=%ld bytes_received=%d\\n\", (long)return_code, os_result);\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                    probe_log(\"Updated RemoteAddr->ActualLength=%u\\n\", (unsigned)addrlen);\n                }\n            }\n        }\n    }\n\n    probe_log(\"Exit OS_SocketRecvFrom_Impl -> return_code=%ld\\n\", (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketRecvFrom_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In this function the local pointer impl is only used to read fields (impl->selectable, impl->fd) and is never used to modify the object it points to. Per MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so declaring it as const OS_impl_file_internal_record_t *impl (or equivalently const-qualified in your style) would satisfy the rule. There are no uses in this function that require a mutable pointer (no writes through impl and it is not passed to a function requiring a non-const pointer), so changing the declaration is safe. (Note: other pointers in the function, e.g. sa, cannot be made const because they are passed to recvfrom which expects a non-const sockaddr pointer.)"
}