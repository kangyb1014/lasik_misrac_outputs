{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_SocketAddrGetPort_Impl:\n```c\nint32 OS_SocketAddrGetPort_Impl(uint16 *PortNum, const OS_SockAddr_t *Addr)\n{\n    in_port_t                     sa_port;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            sa_port = Accessor->sa_in.sin_port;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            sa_port = Accessor->sa_in6.sin6_port;\n            break;\n#endif\n        default:\n            return OS_ERR_BAD_ADDRESS;\n            break;\n    }\n\n    *PortNum = ntohs(sa_port);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_SocketAddrGetPort_Impl:\ntypedef struct\n{\n    size_t            ActualLength; /**< @brief Length of the actual address data */\n    OS_SockAddrData_t AddrData;     /**< @brief Abstract Address data */\n} OS_SockAddr_t\n...\ntypedef union\n{\n    char               data[OS_SOCKADDR_MAX_LEN];\n    struct sockaddr    sa;\n    struct sockaddr_in sa_in;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n    struct sockaddr_in6 sa_in6;\n#endif\n} OS_SockAddr_Accessor_t\n...\n#define OS_NETWORK_SUPPORTS_IPV6 \n...\n#define OS_ERR_BAD_ADDRESS (-34)\n...\n#define OS_SUCCESS (0)\n...\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n...\nint32 OS_SocketAddrGetPort(uint16 *PortNum, const OS_SockAddr_t *Addr)\n{\n    /* Check parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(PortNum);\n\n    return OS_SocketAddrGetPort_Impl(PortNum, Addr);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n        case AF_INET6:\n            sa_port = Accessor->sa_in6.sin6_port;\n            break;\n#endif\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The AF_INET6 case is conditionally compiled with #ifdef OS_NETWORK_SUPPORTS_IPV6. In the provided additional code OS_NETWORK_SUPPORTS_IPV6 is defined, so the AF_INET6 case is present in the build and is executed when Addr->AddrData.sa.sa_family == AF_INET6. Therefore the assignment sa_port = Accessor->sa_in6.sin6_port; is not dead code. If the macro were not defined the whole case block would be omitted at compile time (not left as executable dead code). No operation in the shown fragment is executed while being removable without changing program behaviour, so Rule 2.2 is not violated."
}