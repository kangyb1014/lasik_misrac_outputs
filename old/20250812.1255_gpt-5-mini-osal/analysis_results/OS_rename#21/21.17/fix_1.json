{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_rename(const char *old, const char *new)\n{\n    /* Probe helper: append a textual log line to /tmp/logs/175.txt. */\n    static void log_probe(const char *fmt, ...)\n    {\n        FILE *f = fopen(\"/tmp/logs/175.txt\", \"a\");\n        if (f == NULL)\n        {\n            return;\n        }\n\n        va_list ap;\n        va_start(ap, fmt);\n        vfprintf(f, fmt, ap);\n        va_end(ap);\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log entry with pointer addresses only for caller-provided pointers (safe). */\n    log_probe(\"OS_rename ENTRY: old_ptr=%p new_ptr=%p\", (const void *)old, (const void *)new);\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Safe to log old_path contents (bounded by old_path buffer size). */\n        size_t old_path_len = strnlen(old_path, sizeof(old_path));\n        log_probe(\"OS_TranslatePath(old) OK: old_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                  (void *)old_path, old_path_len, (int)old_path_len, old_path);\n\n        return_code = OS_TranslatePath(new, new_path);\n        if (return_code == OS_SUCCESS)\n        {\n            size_t new_path_len = strnlen(new_path, sizeof(new_path));\n            log_probe(\"OS_TranslatePath(new) OK: new_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                      (void *)new_path, new_path_len, (int)new_path_len, new_path);\n        }\n        else\n        {\n            log_probe(\"OS_TranslatePath(new) FAILED: return_code=%d\", return_code);\n        }\n    }\n    else\n    {\n        log_probe(\"OS_TranslatePath(old) FAILED: return_code=%d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n        log_probe(\"OS_FileRename_Impl returned %d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            /* Log iterator token and stream pointer and socket domain */\n            log_probe(\"ITER token=%u stream_ptr=%p socket_domain=%d\",\n                      (unsigned int)iter.token, (void *)stream, (int)stream->socket_domain);\n\n            /* Only call strcmp when socket domain matches, preserving original logic and avoiding extra reads. */\n            if (stream->socket_domain == OS_SocketDomain_INVALID)\n            {\n                /* Compute comparison result once (this preserves original behavior: strcmp only invoked when socket_domain matches). */\n                int cmp_res = strcmp(stream->stream_name, old);\n\n                /* Log stream_name safely (bounded) and comparison result. */\n                size_t sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                log_probe(\"STREAM name_addr=%p len=%zu name=\\\"%.*s\\\" strcmp_with_old=%d\",\n                          (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name, cmp_res);\n\n                if (cmp_res == 0)\n                {\n                    /* Before update, log the intended new value (bounded by stream buffer size). */\n                    size_t new_name_preview_len = strnlen(new, OS_MAX_LOCAL_PATH_LEN);\n                    log_probe(\"UPDATING stream->stream_name from %p to new (new_ptr=%p preview_len=%zu)\",\n                              (void *)stream->stream_name, (const void *)new, new_name_preview_len);\n\n                    /* Preserve original logic of update. */\n                    strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                    stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                    /* After update, log the stored value safely. */\n                    sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                    log_probe(\"UPDATED stream->stream_name addr=%p len=%zu name=\\\"%.*s\\\"\",\n                              (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name);\n                }\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    log_probe(\"OS_rename EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpdx9be0a8/src/src/os/shared/src/osapi-file.c: In function 'OS_rename':\n/tmp/tmpdx9be0a8/src/src/os/shared/src/osapi-file.c:354:17: error: invalid storage class for function 'log_probe'\n  354 |     static void log_probe(const char *fmt, ...)\n      |                 ^~~~~~~~~\n/tmp/tmpdx9be0a8/src/src/os/shared/src/osapi-file.c:420:23: error: aggregate value used where an integer was expected\n  420 |                       (unsigned int)iter.token, (void *)stream, (int)stream->socket_domain);\n      |                       ^\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_rename as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/* Helper probe function moved to file scope (nested functions are not valid in standard C). */\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/175.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log entry with pointer addresses only for caller-provided pointers (safe). */\n    log_probe(\"OS_rename ENTRY: old_ptr=%p new_ptr=%p\", (const void *)old, (const void *)new);\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Safe to log old_path contents (bounded by old_path buffer size). */\n        size_t old_path_len = strnlen(old_path, sizeof(old_path));\n        log_probe(\"OS_TranslatePath(old) OK: old_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                  (void *)old_path, old_path_len, (int)old_path_len, old_path);\n\n        return_code = OS_TranslatePath(new, new_path);\n        if (return_code == OS_SUCCESS)\n        {\n            size_t new_path_len = strnlen(new_path, sizeof(new_path));\n            log_probe(\"OS_TranslatePath(new) OK: new_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                      (void *)new_path, new_path_len, (int)new_path_len, new_path);\n        }\n        else\n        {\n            log_probe(\"OS_TranslatePath(new) FAILED: return_code=%d\", return_code);\n        }\n    }\n    else\n    {\n        log_probe(\"OS_TranslatePath(old) FAILED: return_code=%d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n        log_probe(\"OS_FileRename_Impl returned %d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            /* Log iterator token and stream pointer and socket domain */\n            /* iter.token may be an aggregate type; print its address instead of casting to integer. */\n            log_probe(\"ITER token=%p stream_ptr=%p socket_domain=%d\",\n                      (void *)&iter.token, (void *)stream, (int)stream->socket_domain);\n\n            /* Only call strcmp when socket domain matches, preserving original logic and avoiding extra reads. */\n            if (stream->socket_domain == OS_SocketDomain_INVALID)\n            {\n                /* Compute comparison result once (this preserves original behavior: strcmp only invoked when socket_domain matches). */\n                int cmp_res = strcmp(stream->stream_name, old);\n\n                /* Log stream_name safely (bounded) and comparison result. */\n                size_t sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                log_probe(\"STREAM name_addr=%p len=%zu name=\\\"%.*s\\\" strcmp_with_old=%d\",\n                          (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name, cmp_res);\n\n                if (cmp_res == 0)\n                {\n                    /* Before update, log the intended new value (bounded by stream buffer size). */\n                    size_t new_name_preview_len = strnlen(new, OS_MAX_LOCAL_PATH_LEN);\n                    log_probe(\"UPDATING stream->stream_name from %p to new (new_ptr=%p preview_len=%zu)\",\n                              (void *)stream->stream_name, (const void *)new, new_name_preview_len);\n\n                    /* Preserve original logic of update. */\n                    strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                    stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                    /* After update, log the stored value safely. */\n                    sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                    log_probe(\"UPDATED stream->stream_name addr=%p len=%zu name=\\\"%.*s\\\"\",\n                              (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name);\n                }\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    log_probe(\"OS_rename EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n",
  "explanation": "Two fixes to make the file compile:\n\n1) Moved the log_probe function out of OS_rename to file scope. Nested function definitions are not allowed in standard C, so placing the helper at file scope (static) fixes the \"invalid storage class for function\" error.\n\n2) The iter.token object was an aggregate type, so casting it to an integer caused \"aggregate value used where an integer was expected.\" Instead of casting the token to unsigned int, the code now logs the token's address with %p (using &iter.token). This avoids invalid casts while preserving the intent to log the token value for debugging.\n\nI kept the original OS_rename logic intact and only changed logging placement/formatting to resolve compilation errors."
}