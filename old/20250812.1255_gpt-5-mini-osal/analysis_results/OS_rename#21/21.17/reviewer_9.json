{
  "user_message": "An agent A claimed that the following OS_rename code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_rename.\n```c\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:True. The call memchr(name_ptr, 0, OS_MAX_FILE_NAME) can read up to OS_MAX_FILE_NAME bytes starting at name_ptr but the function only guaranteed that the entire VirtualPath string has a NUL within OS_MAX_PATH_LEN bytes. There is no guarantee that the number of bytes available from name_ptr to the end of the caller's object is >= OS_MAX_FILE_NAME. If, for example, the provided VirtualPath buffer is just big enough to hold the string (NUL terminator) and the remaining bytes after the last '/' are fewer than OS_MAX_FILE_NAME, memchr will attempt to read beyond the bounds of the VirtualPath object, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/175.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log entry with pointer addresses only for caller-provided pointers (safe). */\n    log_probe(\"OS_rename ENTRY: old_ptr=%p new_ptr=%p\", (const void *)old, (const void *)new);\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Safe to log old_path contents (bounded by old_path buffer size). */\n        size_t old_path_len = strnlen(old_path, sizeof(old_path));\n        log_probe(\"OS_TranslatePath(old) OK: old_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                  (void *)old_path, old_path_len, (int)old_path_len, old_path);\n\n        return_code = OS_TranslatePath(new, new_path);\n        if (return_code == OS_SUCCESS)\n        {\n            size_t new_path_len = strnlen(new_path, sizeof(new_path));\n            log_probe(\"OS_TranslatePath(new) OK: new_path_addr=%p len=%zu content=\\\"%.*s\\\"\",\n                      (void *)new_path, new_path_len, (int)new_path_len, new_path);\n        }\n        else\n        {\n            log_probe(\"OS_TranslatePath(new) FAILED: return_code=%d\", return_code);\n        }\n    }\n    else\n    {\n        log_probe(\"OS_TranslatePath(old) FAILED: return_code=%d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n        log_probe(\"OS_FileRename_Impl returned %d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            /* Log iterator token and stream pointer and socket domain */\n            /* iter.token may be an aggregate type; print its address instead of casting to integer. */\n            log_probe(\"ITER token=%p stream_ptr=%p socket_domain=%d\",\n                      (void *)&iter.token, (void *)stream, (int)stream->socket_domain);\n\n            /* Only call strcmp when socket domain matches, preserving original logic and avoiding extra reads. */\n            if (stream->socket_domain == OS_SocketDomain_INVALID)\n            {\n                /* Compute comparison result once (this preserves original behavior: strcmp only invoked when socket_domain matches). */\n                int cmp_res = strcmp(stream->stream_name, old);\n\n                /* Log stream_name safely (bounded) and comparison result. */\n                size_t sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                log_probe(\"STREAM name_addr=%p len=%zu name=\\\"%.*s\\\" strcmp_with_old=%d\",\n                          (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name, cmp_res);\n\n                if (cmp_res == 0)\n                {\n                    /* Before update, log the intended new value (bounded by stream buffer size). */\n                    size_t new_name_preview_len = strnlen(new, OS_MAX_LOCAL_PATH_LEN);\n                    log_probe(\"UPDATING stream->stream_name from %p to new (new_ptr=%p preview_len=%zu)\",\n                              (void *)stream->stream_name, (const void *)new, new_name_preview_len);\n\n                    /* Preserve original logic of update. */\n                    strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                    stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                    /* After update, log the stored value safely. */\n                    sname_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                    log_probe(\"UPDATED stream->stream_name addr=%p len=%zu name=\\\"%.*s\\\"\",\n                              (void *)stream->stream_name, sname_len, (int)sname_len, stream->stream_name);\n                }\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    log_probe(\"OS_rename EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_rename. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the code shown. The only uses of <string.h> functions in this function are strcmp(stream->stream_name, old) and strncpy(..., new, sizeof(stream->stream_name) - 1) (plus strnlen in the test scaffold). The strncpy call uses the destination buffer size minus one and then explicitly writes a terminating NUL \u2014 that is safe. The strcmp call reads from two strings: stream->stream_name (an internal fixed-size, NUL-terminated buffer) and old (a caller-supplied pointer). The code calls OS_TranslatePath(old, old_path) at the start and proceeds with the strcmp only if OS_TranslatePath returned OS_SUCCESS. The reasonable and intended contract of OS_TranslatePath is that it validates the caller-provided path and only returns success if it found a NUL within the allowed maximum path length (so the old pointer is known to be a properly terminated string within bounds). Under that contract the later strcmp cannot read beyond the bounds of the object referenced by old, and Rule 21.17 is satisfied.\n\nThe agent A\u2019s scenario refers to a memchr call with a mismatched size (OS_MAX_FILE_NAME vs OS_MAX_PATH_LEN) and a potential read beyond the caller buffer \u2014 that scenario does not appear in the OS_rename code shown. If there exists other code (e.g. inside OS_TranslatePath or some other helper) that uses memchr or another string function with an incorrect size constant that can exceed the actual object bounds, then that other code could violate Rule 21.17. But based on the OS_rename function as given, and assuming the expected contract of OS_TranslatePath (success => input is NUL-terminated within the permitted length), the report that OS_rename itself violates MISRA C 2023 Rule 21.17 is incorrect."
}