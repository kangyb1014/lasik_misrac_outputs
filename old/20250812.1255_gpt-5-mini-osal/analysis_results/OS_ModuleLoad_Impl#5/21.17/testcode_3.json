{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. memchr(name_ptr, 0, OS_MAX_FILE_NAME) may read up to OS_MAX_FILE_NAME bytes starting at name_ptr but the code does not ensure that the object containing VirtualPath (and therefore name_ptr) actually has OS_MAX_FILE_NAME bytes available. For example, if VirtualPath is stored in a buffer of length 32, the last '/' is at index 16 (so name_ptr points at index 17) and OS_MAX_FILE_NAME is 256, memchr would attempt to read well past the end of the buffer/array and so can access beyond the bounds of the object. Therefore this use can violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ModuleLoad_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/47.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ModuleLoad_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ModuleLoad_Impl:\n```c\nint32 OS_ModuleLoad_Impl(const OS_object_token_t *token, const char *translated_path)\n{\n    int32                             status = OS_ERROR;\n    int                               dl_mode;\n    OS_impl_module_internal_record_t *impl;\n    OS_module_internal_record_t *     module;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_module_table, *token);\n    module = OS_OBJECT_TABLE_GET(OS_module_table, *token);\n\n    /*\n     * RTLD_NOW should instruct dlopen() to resolve all the symbols in the\n     * module immediately, as opposed to waiting until they are used.\n     * The latter (lazy mode) is non-deterministic - a resolution error on\n     * a rarely-used symbol could cause a random failure far in the future.\n     */\n    dl_mode = RTLD_NOW;\n\n    if ((module->flags & OS_MODULE_FLAG_LOCAL_SYMBOLS) != 0)\n    {\n        /*\n         * Do not add the symbols in this module to the global symbol table.\n         * This mode helps prevent any unanticipated references into this\n         * module, which can in turn prevent unloading via dlclose().\n         */\n        dl_mode |= RTLD_LOCAL;\n    }\n    else\n    {\n        /*\n         * Default mode - add symbols to the global symbol table, so they\n         * will be available to resolve symbols in future module loads.\n         * However, any such references will prevent unloading of this\n         * module via dlclose().\n         */\n        dl_mode |= RTLD_GLOBAL;\n    }\n\n    dlerror();\n    impl->dl_handle = dlopen(translated_path, dl_mode);\n    if (impl->dl_handle != NULL)\n    {\n        status = OS_SUCCESS;\n    }\n    else\n    {\n        OS_DEBUG(\"Error loading shared library: %s\\n\", dlerror());\n    }\n\n    return status;\n}\n```\n</target_code>\nPlease provide the modified OS_ModuleLoad_Impl code.\n",
  "test_code": "int32 OS_ModuleLoad_Impl(const OS_object_token_t *token, const char *translated_path)\n{\n    int32                             status = OS_ERROR;\n    int                               dl_mode;\n    OS_impl_module_internal_record_t *impl;\n    OS_module_internal_record_t *     module;\n\n    /* Helper probe: append a single line of diagnostic information to the\n     * log file. The helper intentionally avoids dereferencing the\n     * translated_path pointer or any other potentially-bounded buffer so\n     * it does not introduce any out-of-bounds reads. It only logs pointer\n     * values and integer fields that are safe to read. */\n    {\n        /* Define as a local block-scoped function-like helper using a\n         * nested function is not standard; instead implement as a local\n         * static function via a function pointer wrapper to keep changes\n         * minimal and self-contained. */\n        static void (*probe)(const char *, const OS_object_token_t *,\n                             const OS_module_internal_record_t *,\n                             const OS_impl_module_internal_record_t *,\n                             const char *, int) = NULL;\n\n        /* If not already set, initialize probe to a local static function. */\n        if (probe == NULL)\n        {\n            /* Local function definition - placed in an immediately\n             * initialized function pointer to avoid adding global\n             * functions or macros. */\n            void local_probe(const char *label,\n                             const OS_object_token_t *ptoken,\n                             const OS_module_internal_record_t *pmodule,\n                             const OS_impl_module_internal_record_t *pimpl,\n                             const char *ppath,\n                             int p_dl_mode)\n            {\n                FILE *f = fopen(\"/tmp/logs/47.txt\", \"a\");\n                if (f == NULL)\n                {\n                    /* If logging fails, do not alter program flow. */\n                    return;\n                }\n\n                /* Print a compact record with stable fields. Avoid\n                 * dereferencing the translated_path pointer to prevent any\n                 * out-of-bounds access. Only the pointer value is logged. */\n                fprintf(f, \"[%s] token=%p module=%p impl=%p translated_path=%p dl_mode=%d\\n\",\n                        label,\n                        (void *)ptoken,\n                        (void *)pmodule,\n                        (void *)pimpl,\n                        (void *)ppath,\n                        p_dl_mode);\n\n                /* If module is non-NULL, print some safe integer fields. */\n                if (pmodule != NULL)\n                {\n                    /* module->flags is an integer flag field; printing it\n                     * is safe and useful to reproduce the scenario about\n                     * local/global symbol flags which influence dl_mode. */\n                    fprintf(f, \"[%s] module->flags=0x%08X\\n\",\n                            label,\n                            (unsigned int)pmodule->flags);\n                }\n\n                fflush(f);\n                fclose(f);\n            }\n\n            probe = &local_probe;\n        }\n\n        /* Acquire table entries exactly as original implementation. */\n        impl   = OS_OBJECT_TABLE_GET(OS_impl_module_table, *token);\n        module = OS_OBJECT_TABLE_GET(OS_module_table, *token);\n\n        /* Log entry state before any decisions. */\n        probe(\"ENTRY\", token, module, impl, translated_path, -1);\n    }\n\n    /*\n     * RTLD_NOW should instruct dlopen() to resolve all the symbols in the\n     * module immediately, as opposed to waiting until they are used.\n     * The latter (lazy mode) is non-deterministic - a resolution error on\n     * a rarely-used symbol could cause a random failure far in the future.\n     */\n    dl_mode = RTLD_NOW;\n\n    if ((module->flags & OS_MODULE_FLAG_LOCAL_SYMBOLS) != 0)\n    {\n        /*\n         * Do not add the symbols in this module to the global symbol table.\n         * This mode helps prevent any unanticipated references into this\n         * module, which can in turn prevent unloading via dlclose().\n         */\n        dl_mode |= RTLD_LOCAL;\n    }\n    else\n    {\n        /*\n         * Default mode - add symbols to the global symbol table, so they\n         * will be available to resolve symbols in future module loads.\n         * However, any such references will prevent unloading of this\n         * module via dlclose().\n         */\n        dl_mode |= RTLD_GLOBAL;\n    }\n\n    /* Log state just before calling dlopen so callers can correlate the\n     * translated_path pointer and the chosen dl_mode with any later\n     * observed behavior (e.g. memchr/strlen usage elsewhere). */\n    {\n        /* Reuse the local probe function pointer defined above. */\n        extern void (*probe)(const char *, const OS_object_token_t *,\n                             const OS_module_internal_record_t *,\n                             const OS_impl_module_internal_record_t *,\n                             const char *, int);\n        if (probe != NULL)\n        {\n            probe(\"BEFORE_DLOPEN\", token, module, impl, translated_path, dl_mode);\n        }\n    }\n\n    dlerror();\n    impl->dl_handle = dlopen(translated_path, dl_mode);\n    if (impl->dl_handle != NULL)\n    {\n        status = OS_SUCCESS;\n\n        /* Log success and the handle value. */\n        {\n            FILE *f = fopen(\"/tmp/logs/47.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"[AFTER_DLOPEN] success handle=%p token=%p translated_path=%p\\n\",\n                        impl->dl_handle, (void *)token, (void *)translated_path);\n                fflush(f);\n                fclose(f);\n            }\n        }\n    }\n    else\n    {\n        /* Log the dlerror() text along with other context to help\n         * reproduce the error scenario. Printing the dlerror() output\n         * is safe because dlerror() returns either NULL or a valid\n         * NUL-terminated string allocated by the runtime. */\n        const char *derr = dlerror();\n        {\n            FILE *f = fopen(\"/tmp/logs/47.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"[AFTER_DLOPEN] failure token=%p translated_path=%p dl_mode=%d dlerror=%s\\n\",\n                        (void *)token,\n                        (void *)translated_path,\n                        dl_mode,\n                        (derr != NULL) ? derr : \"(null)\");\n                fflush(f);\n                fclose(f);\n            }\n        }\n\n        OS_DEBUG(\"Error loading shared library: %s\\n\", derr);\n    }\n\n    /* Final log record to mark exit and return status. */\n    {\n        FILE *f = fopen(\"/tmp/logs/47.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"[EXIT] token=%p status=%d module=%p impl=%p translated_path=%p\\n\",\n                    (void *)token,\n                    (int)status,\n                    (void *)module,\n                    (void *)impl,\n                    (void *)translated_path);\n            fflush(f);\n            fclose(f);\n        }\n    }\n\n    return status;\n}\n"
}