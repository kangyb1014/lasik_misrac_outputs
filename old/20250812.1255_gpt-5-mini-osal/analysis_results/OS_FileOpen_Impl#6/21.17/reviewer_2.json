{
  "user_message": "An agent A claimed that the following OS_FileOpen_Impl code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpen_Impl.\n```c\nint32 OS_FileOpen_Impl(const OS_object_token_t *token, const char *local_path, int32 flags, int32 access_mode)\n{\n    int                             os_perm;\n    int                             os_mode;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n    ** Check for a valid access mode\n    ** For creating a file, OS_READ_ONLY does not make sense\n    */\n    switch (access_mode)\n    {\n        case OS_WRITE_ONLY:\n            os_perm = O_WRONLY;\n            break;\n        case OS_READ_ONLY:\n            os_perm = O_RDONLY;\n            break;\n        case OS_READ_WRITE:\n            os_perm = O_RDWR;\n            break;\n        default:\n            return OS_ERROR;\n    }\n\n    if (flags & OS_FILE_FLAG_CREATE)\n    {\n        os_perm |= O_CREAT;\n    }\n    if (flags & OS_FILE_FLAG_TRUNCATE)\n    {\n        os_perm |= O_TRUNC;\n    }\n\n    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;\n\n    os_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n    impl->fd = open(local_path, os_perm, os_mode);\n\n    if (impl->fd < 0)\n    {\n        OS_DEBUG(\"open(%s): %s\\n\", local_path, strerror(errno));\n        return OS_ERROR;\n    }\n\n    /*\n     * If the flags included O_NONBLOCK, then\n     * enable the \"select\" call on this handle.\n     */\n    impl->selectable = ((os_perm & O_NONBLOCK) != 0);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) can read up to OS_MAX_PATH_LEN bytes from VirtualPath. If the caller passes a buffer smaller than OS_MAX_PATH_LEN that does not contain a NUL within its bounds (for example a 16-byte buffer with no terminating \\0), the strnlen scan may access bytes beyond the actual array and up to OS_MAX_PATH_LEN, i.e. out-of-bounds access. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FileOpen_ProbeLog(const char *phase,\n                                 const void *token_ptr,\n                                 const void *impl_ptr,\n                                 const char *local_path_ptr,\n                                 int flags,\n                                 int access_mode,\n                                 int os_perm,\n                                 int fd)\n{\n    FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] phase=%s token_ptr=0x%lx impl_ptr=0x%lx local_path_ptr=0x%lx flags=0x%x access_mode=%d os_perm=0x%x fd=%d\\n\",\n            (long)t,\n            phase,\n            (unsigned long)(uintptr_t)token_ptr,\n            (unsigned long)(uintptr_t)impl_ptr,\n            (unsigned long)(uintptr_t)local_path_ptr,\n            flags,\n            access_mode,\n            os_perm,\n            fd);\n\n    /* In order to avoid dereferencing caller-supplied pointers (which could lead to\n     * additional out-of-bounds reads), do NOT print the contents of local_path or\n     * any token internals here. Only pointer values and numeric state are recorded.\n     */\n\n    fclose(f);\n}\n\nint32 OS_FileOpen_Impl(const OS_object_token_t *token, const char *local_path, int32 flags, int32 access_mode)\n{\n    int                             os_perm;\n    int                             os_mode;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /* Log entry state. Do NOT dereference local_path here. */\n    OS_FileOpen_ProbeLog(\"entry\", token, impl, local_path, flags, access_mode, 0, -1);\n\n    /*\n    ** Check for a valid access mode\n    ** For creating a file, OS_READ_ONLY does not make sense\n    */\n    switch (access_mode)\n    {\n        case OS_WRITE_ONLY:\n            os_perm = O_WRONLY;\n            break;\n        case OS_READ_ONLY:\n            os_perm = O_RDONLY;\n            break;\n        case OS_READ_WRITE:\n            os_perm = O_RDWR;\n            break;\n        default:\n            OS_FileOpen_ProbeLog(\"bad_access_mode\", token, impl, local_path, flags, access_mode, 0, -1);\n            return OS_ERROR;\n    }\n\n    if (flags & OS_FILE_FLAG_CREATE)\n    {\n        os_perm |= O_CREAT;\n    }\n    if (flags & OS_FILE_FLAG_TRUNCATE)\n    {\n        os_perm |= O_TRUNC;\n    }\n\n    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;\n\n    os_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n    /* Log just before the open syscall with computed permissions. */\n    OS_FileOpen_ProbeLog(\"pre_open\", token, impl, local_path, flags, access_mode, os_perm, -1);\n\n    impl->fd = open(local_path, os_perm, os_mode);\n\n    if (impl->fd < 0)\n    {\n        /* Log failure including errno. Avoid printing local_path contents. */\n        OS_FileOpen_ProbeLog(\"open_failed\", token, impl, local_path, flags, access_mode, os_perm, impl->fd);\n        OS_DEBUG(\"open(%p): %s\\n\", (void *)local_path, strerror(errno));\n        return OS_ERROR;\n    }\n\n    /*\n     * If the flags included O_NONBLOCK, then\n     * enable the \"select\" call on this handle.\n     */\n    impl->selectable = ((os_perm & O_NONBLOCK) != 0);\n\n    /* Log successful open and returned fd */\n    OS_FileOpen_ProbeLog(\"open_success\", token, impl, local_path, flags, access_mode, os_perm, impl->fd);\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpen_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the code shown. The claimed violation concerns a call to OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) possibly reading up to OS_MAX_PATH_LEN bytes beyond the actual buffer. The OS_FileOpen_Impl implementation you provided contains no call to strnlen (or any other string.h routine named in MISRA C:2023 Rule 21.17). The only potentially unsafe string use in the original snippet is the debug/printing of local_path via a %s format (OS_DEBUG(\"open(%s): %s\\n\", local_path, strerror(errno))); printing a non-terminated caller-supplied string could cause an out-of-bounds read, but that is not an instance of the string.h functions enumerated by Rule 21.17 and thus is not the specific violation claimed.\n\nIn short: the exact scenario (OS_strnlen scanning past a smaller buffer) does describe a real class of out-of-bounds risks, but it does not occur in the shown OS_FileOpen_Impl code, so the agent A report that this function violates MISRA C 2023 Rule 21.17 is incorrect. (Note: the modified probe version correctly avoids dereferencing local_path for logging, which removes the separate printf-based risk.)"
}