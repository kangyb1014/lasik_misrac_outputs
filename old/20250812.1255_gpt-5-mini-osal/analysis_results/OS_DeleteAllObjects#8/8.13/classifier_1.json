{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_DeleteAllObjects:\n```c\nvoid OS_DeleteAllObjects(void)\n{\n    uint32 ObjectCount;\n    uint32 TryCount;\n\n    /*\n     * Note - this is done in a loop because some objects depend on other objects\n     * and you will not be able to delete the object until the ref count becomes zero.\n     */\n    TryCount = 0;\n    while (true)\n    {\n        ObjectCount = 0;\n        ++TryCount;\n\n        /* Delete timers and tasks first, as they could be actively using other object types  */\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMECB, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMEBASE, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n        OS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TASK, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        /* Then try to delete all other remaining objects of any type */\n        OS_ForEachObject(OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n\n        if (ObjectCount == 0 || TryCount > 4)\n        {\n            break;\n        }\n        OS_TaskDelay(5);\n    }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_ForEachObjectOfType(OS_OBJECT_TYPE_OS_TIMECB, OS_OBJECT_CREATOR_ANY, OS_CleanUpObject, &ObjectCount);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The &ObjectCount argument is passed so the called callback (OS_CleanUpObject) / iterator can update the count; the pointer target is intentionally mutable and therefore must not be const. Rule 8.13 would only be violated if the called function\u2019s parameter were declared as pointing to a const-qualified type while the implementation actually modifies the pointed object (or if the pointed object is not modified but the parameter is declared non-const)."
}