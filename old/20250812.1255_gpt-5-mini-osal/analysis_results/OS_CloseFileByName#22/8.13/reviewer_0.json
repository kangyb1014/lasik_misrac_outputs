{
  "user_message": "An agent A claimed that the following OS_CloseFileByName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_CloseFileByName.\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro OS_OBJECT_TABLE_GET() returns a pointer to a modifiable table element (&tbl[...]) but callers (e.g. OS_CloseFileByName where stream is used only for read access, and OS_ObjectIdIteratorGetNext where record is only read) only need read access. These callers could (and should) use a pointer to const-qualified element type (const OS_stream_internal_record_t * or const OS_common_record_t *) so the pointer should point to a const-qualified type. Therefore the macro's return type enables non-const access where const would be appropriate.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_CloseFileByName_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/179.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fprintf(fp, \"\\n\");\n    fflush(fp);\n    fclose(fp);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    OS_CloseFileByName_Log(\"OS_CloseFileByName ENTRY: Filename=%p ('%s')\", (const void *)Filename, (Filename ? Filename : \"(null)\"));\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_CloseFileByName_Log(\"Initial return_code=%d (OS_FS_ERR_PATH_INVALID)\", (int)return_code);\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    /* Print the address of the token (token may be an aggregate type and cannot be cast to an integer) */\n    OS_CloseFileByName_Log(\"Iterator initialized: iter token (start)=%p\", (void *)&iter.token);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        /* capture token address before any possible side effects */\n        void *iter_token = (void *)&iter.token;\n\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        OS_CloseFileByName_Log(\"Iteration: iter.token=%p, stream_ptr=%p\", iter_token, (void *)stream);\n\n        if (stream != NULL)\n        {\n            /* Log stream fields that are relevant to the decision */\n            const char *sname = stream->stream_name ? stream->stream_name : \"(null)\";\n            OS_CloseFileByName_Log(\" stream->socket_domain=%d, stream->stream_name='%s'\", (int)stream->socket_domain, sname);\n\n            int cmp = 0;\n            /* Protect strcmp in case stream_name is NULL */\n            if (stream->stream_name != NULL && Filename != NULL)\n            {\n                cmp = strcmp(stream->stream_name, Filename);\n            }\n            else if (stream->stream_name == NULL && Filename == NULL)\n            {\n                cmp = 0;\n            }\n            else\n            {\n                /* not equal */\n                cmp = 1;\n            }\n\n            OS_CloseFileByName_Log(\" strcmp(stream->stream_name, Filename) result=%d\", cmp);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && (cmp == 0))\n            {\n                OS_CloseFileByName_Log(\" Match found: calling OS_ObjectIdIteratorProcessEntry for token=%p\", iter_token);\n\n                /* call OS_close() on the entry referred to by the iterator */\n                close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n                OS_CloseFileByName_Log(\" OS_ObjectIdIteratorProcessEntry returned close_code=%d\", (int)close_code);\n\n                if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n                {\n                    OS_CloseFileByName_Log(\" Updating return_code: old=%d, new=%d\", (int)return_code, (int)close_code);\n                    return_code = close_code;\n                }\n                else\n                {\n                    OS_CloseFileByName_Log(\" return_code unchanged: %d\", (int)return_code);\n                }\n            }\n            else\n            {\n                OS_CloseFileByName_Log(\" No match (socket_domain or name mismatch): socket_domain=%d, cmp=%d\", (int)stream->socket_domain, cmp);\n            }\n        }\n        else\n        {\n            OS_CloseFileByName_Log(\" stream pointer is NULL for token=%p\", iter_token);\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    OS_CloseFileByName_Log(\"Iterator destroyed; final return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_CloseFileByName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In the shown function the local variable stream is declared as OS_stream_internal_record_t * but it is only used for read-only access (fields are inspected, not modified). MISRA C:2023 Rule 8.13 recommends that pointers should point to a const-qualified type when possible, so stream should be declared as const OS_stream_internal_record_t * (or the macro OS_OBJECT_TABLE_GET could be typed to return a pointer-to-const for read-only uses). Assigning a non-const pointer (what the macro returns) to a pointer-to-const is permitted, so the simplest remediation for this function is to change the local declaration to const. If other code paths need a modifiable pointer, adjust those sites instead; but as written this function violates Rule 8.13."
}