{
  "user_message": "An agent A claimed that the following OS_CloseFileByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_CloseFileByName.\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strcmp(stream->stream_name, Filename). If stream_name is not guaranteed to be NUL-terminated (for example it was filled via strncpy(..., OS_MAX_PATH_LEN) or memcpy without explicitly writing a terminating '\\0'), strcmp will scan past the end of stream_name looking for a '\\0' and thus read beyond the bounds of the array. This causes a violation of MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef struct\n{\n    unsigned token_val;\n} OS_object_token_t;\ntypedef struct\n{\n    OS_object_token_t token;\n    size_t index; /* iterator position for our simple iterator implementation */\n} OS_object_iter_t;\ntypedef struct\n{\n    char stream_name[OS_MAX_PATH_LEN];\n    int socket_domain;\n} OS_stream_internal_record_t;\nstatic void OS_ObjectIdIterateActive(int unused, OS_object_iter_t *iter)\n{\n    (void)unused;\n    iter->index = 0;\n    iter->token.token_val = 0;\n}\nstatic int OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    /* iterate through the table entries; return true while there are entries */\n    if (iter->index < (sizeof(OS_stream_table) / sizeof(OS_stream_table[0])))\n    {\n        /* use token_val to identify the entry (aggregate token) */\n        iter->token.token_val = (unsigned)iter->index;\n        iter->index++;\n        return 1;\n    }\n    return 0;\n}\nstatic OS_stream_internal_record_t *OS_OBJECT_TABLE_GET(OS_stream_internal_record_t table[], OS_object_token_t token)\n{\n    /* Use token.token_val as the index into the table. Guard bounds for safety. */\n    unsigned idx = token.token_val;\n    if (idx >= (unsigned)(sizeof(OS_stream_table) / sizeof(OS_stream_table[0])))\n    {\n        return NULL;\n    }\n    return &table[idx];\n}\nstatic int OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int (*func)(void *))\n{\n    /* For the purposes of this test, find the stream by token and call the function. */\n    OS_stream_internal_record_t *stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter->token);\n    if (stream == NULL) return OS_FS_ERR_PATH_INVALID;\n    return func((void *)stream);\n}\nstatic void OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    (void)iter; /* nothing to do for this simple iterator */\n}\nstatic void OS_CloseFileByName_Log(const char *fmt, ...)\n{\n    FILE *fp;\n    va_list ap;\n\n    /* Ensure the directory exists. If it already exists, ignore the error. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    fp = fopen(\"/tmp/logs/183.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* Best-effort logging; do not change control flow on failure */\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nstatic int OS_FileIteratorClose(void *entry)\n{\n    (void)entry;\n    /* Pretend close succeeded */\n    return OS_SUCCESS;\n}\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters (explicit check in lieu of the original macro) */\n    if (Filename == NULL) return OS_FS_ERR_PATH_INVALID;\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(0, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* --- Probe logging: capture state immediately before the strcmp --- */\n        {\n            size_t fname_len = 0;\n            const char *fname_ptr = Filename;\n\n            if (Filename != NULL)\n            {\n                fname_len = strlen(Filename);\n            }\n\n            /*\n             * The original code attempted to print iter.token as an unsigned integer\n             * which fails when token is an aggregate type. To make the probe robust\n             * regardless of the token representation, print the address of the token\n             * as a pointer instead of treating it as an integer.\n             */\n            OS_CloseFileByName_Log(\"[probe] iter.token=%p stream_ptr=%p socket_domain=%d Filename_ptr=%p Filename_len=%zu\",\n                                   (void *)&iter.token, (void *)stream, (int)stream->socket_domain, (void *)fname_ptr, fname_len);\n\n            /* Check whether stream->stream_name contains a NUL within OS_MAX_PATH_LEN bytes */\n            {\n                const void *nulpos = memchr(stream->stream_name, '\\0', OS_MAX_PATH_LEN);\n                if (nulpos != NULL)\n                {\n                    ptrdiff_t pos = (const char *)nulpos - stream->stream_name;\n                    /* Print the printable portion of stream_name up to the NUL */\n                    OS_CloseFileByName_Log(\"[probe] stream_name is NUL-terminated at offset=%td; content=\\\"%.*s\\\"\",\n                                           pos, (int)pos, stream->stream_name);\n                }\n                else\n                {\n                    /* No NUL found within the assumed buffer size. Log that fact and dump the first bytes as hex to aid debugging. */\n                    int i, dump_len = (OS_MAX_PATH_LEN > 32) ? 32 : OS_MAX_PATH_LEN;\n                    char hexbuf[3 * 32 + 1];\n                    char *hp = hexbuf;\n                    size_t remaining = sizeof(hexbuf);\n\n                    for (i = 0; i < dump_len; ++i)\n                    {\n                        int n = snprintf(hp, remaining, \"%02X \", (unsigned char)stream->stream_name[i]);\n                        if (n <= 0) break;\n                        hp += n;\n                        remaining = (hp < hexbuf + sizeof(hexbuf)) ? (size_t)(hexbuf + sizeof(hexbuf) - hp) : 0;\n                        if (remaining == 0) break;\n                    }\n                    *hp = '\\0';\n\n                    OS_CloseFileByName_Log(\"[probe] stream_name NOT NUL-terminated within %d bytes; first %d bytes (hex): %s\",\n                                           OS_MAX_PATH_LEN, dump_len, hexbuf);\n                }\n            }\n        }\n\n        /* Original comparison retained to preserve original control flow; the probe logs before this call. */\n        if (stream != NULL && stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n\n            /* Log the result of the strcmp branch being taken and the close result */\n            OS_CloseFileByName_Log(\"[probe] strcmp matched; close_code=%d return_code=%d\", close_code, return_code);\n        }\n        else\n        {\n            /* Log when the strcmp did not match (or socket_domain not invalid). Print token as pointer for safety. */\n            OS_CloseFileByName_Log(\"[probe] strcmp did not match or socket_domain != INVALID for token=%p\", (void *)&iter.token);\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. strcmp(stream->stream_name, Filename) will scan stream->stream_name until it finds a NUL byte; if stream->stream_name is a fixed-size char array that is ever populated without guaranteeing a terminating '\\0' (for example via strncpy(..., OS_MAX_PATH_LEN) or via memcpy), strcmp can read past the end of the array and thus perform an out\u2011of\u2011bounds access. MISRA C 2023 Rule 21.17 requires that use of string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. The posted code does not show any invariant or explicit guarantee that stream->stream_name (or the caller-supplied Filename) is NUL-terminated within its allocated bounds, so the call to strcmp is potentially noncompliant. (If elsewhere in the system there is a documented, provable invariant that both buffers are NUL-terminated within their sizes, then the use would be compliant; absent that, it is a violation.) Recommended fixes: ensure the stream_name buffer is always NUL-terminated when written, or use a bounded comparison (e.g. strncmp with the buffer size or compare using a stored length) so that no out-of-bounds read can occur."
}