{
  "user_message": "An agent A claimed that the following OS_FileSysAddFixedMap code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysAddFixedMap.\n```c\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. memchr(dev_name, 0, sizeof(filesys->volume_name)) may read up to sizeof(filesys->volume_name) bytes starting at dev_name, but dev_name points into the phys_path string object. There is no guarantee the remaining bytes from dev_name to the end of the phys_path object are at least sizeof(filesys->volume_name). If the remaining length is smaller, memchr will access bytes beyond the bounds of phys_path, violating MISRA C 2023 Rule 21.17. (Safe alternatives: use strnlen(dev_name, sizeof(filesys->volume_name)) or bound the length by the remaining bytes in phys_path.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OSFS_ProbeLog(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    /*\n     * Probe/logging: record pointers, offsets and lengths relevant to the memchr call\n     * This helps reproduce the scenario where memchr(dev_name, 0, sizeof(filesys->volume_name))\n     * may read beyond the bounds of the phys_path object.\n     */\n    {\n        /* sizeof(filesys->volume_name) mirrors the original code's argument */\n        size_t target_len = sizeof(filesys->volume_name);\n\n        /* remaining length in the phys_path starting at dev_name (including NUL) */\n        size_t remaining_devlen = 0u;\n        if (dev_name != NULL)\n        {\n            /* strlen is safe here since dev_name points into phys_path, which is NUL-terminated */\n            remaining_devlen = strlen(dev_name) + 1u;\n        }\n\n        /* prepare short previews of the strings for the log (bounded to avoid overflow) */\n        char dev_preview[65];\n        char phys_preview[65];\n        if (dev_name != NULL)\n        {\n            strncpy(dev_preview, dev_name, sizeof(dev_preview) - 1);\n            dev_preview[sizeof(dev_preview) - 1] = '\\0';\n        }\n        else\n        {\n            dev_preview[0] = '\\0';\n        }\n        if (phys_path != NULL)\n        {\n            strncpy(phys_preview, phys_path, sizeof(phys_preview) - 1);\n            phys_preview[sizeof(phys_preview) - 1] = '\\0';\n        }\n        else\n        {\n            phys_preview[0] = '\\0';\n        }\n\n        OSFS_ProbeLog(\"[OS_FileSysAddFixedMap] phys_path=%p, dev_name=%p, dev_offset=%zu, remaining_devlen=%zu, target_len=%zu, phys_preview=\\\"%s\\\", dev_preview=\\\"%s\\\"\",\n                      (void *)phys_path,\n                      (void *)dev_name,\n                      (size_t)((dev_name != NULL && phys_path != NULL) ? (size_t)(dev_name - phys_path) : 0u),\n                      remaining_devlen,\n                      target_len,\n                      phys_preview,\n                      dev_preview);\n\n        /* perform the original memchr call and log its result */\n        void *memchr_res = memchr(dev_name, 0, target_len);\n\n        OSFS_ProbeLog(\"[OS_FileSysAddFixedMap] memchr(dev_name, 0, %zu) returned %p\",\n                      target_len,\n                      memchr_res);\n\n        /* additionally log whether the result (if non-NULL) lies within the known remaining range */\n        if (memchr_res != NULL)\n        {\n            const char *mr = (const char *)memchr_res;\n            int inside = 0;\n            if (dev_name != NULL && phys_path != NULL)\n            {\n                const char *phys_end = phys_path + remaining_devlen;\n                inside = (mr >= dev_name) && (mr < phys_end);\n            }\n            OSFS_ProbeLog(\"[OS_FileSysAddFixedMap] memchr_result_inside_phys_path_range=%d\", inside);\n        }\n        else\n        {\n            OSFS_ProbeLog(\"[OS_FileSysAddFixedMap] memchr returned NULL (name too long)\");\n        }\n\n        /* Preserve original control flow: if memchr returned NULL, return the same error */\n        if (memchr_res == NULL)\n        {\n            return OS_ERR_NAME_TOO_LONG;\n        }\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysAddFixedMap. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. memchr(dev_name, 0, sizeof(filesys->volume_name)) asks memchr to examine exactly sizeof(filesys->volume_name) bytes starting at dev_name. dev_name is a pointer into the phys_path object (basename of phys_path), so the accessible object bounds are from dev_name up to the terminating NUL of phys_path. Nothing in the shown code guarantees that the remaining number of bytes from dev_name to the end of phys_path is at least sizeof(filesys->volume_name). The earlier check OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), ...) only bounds the total phys_path length against sizeof(filesys->system_mountpt), not the remaining bytes from dev_name nor against sizeof(filesys->volume_name). If dev_name is near the end of phys_path the memchr call can read past the phys_path object, violating MISRA C 2023 Rule 21.17. The agent\u2019s suggested safe alternatives (use strnlen(dev_name, sizeof(filesys->volume_name)) or limit the memchr length to the actual remaining bytes) are appropriate mitigations."
}