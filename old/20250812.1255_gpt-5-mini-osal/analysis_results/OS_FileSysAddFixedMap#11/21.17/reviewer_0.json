{
  "user_message": "An agent A claimed that the following OS_FileSysAddFixedMap code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysAddFixedMap.\n```c\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1) can read up to (sizeof(filesys->virtual_mountpt) - 1) bytes from virt_path. If virt_path does not contain a NUL within that many bytes (for example if virt_path is a pointer to a shorter/non NUL-terminated buffer), strncpy will access bytes beyond the bounds of the source object, violating MISRA C 2023 Rule 21.17. (The destination write is bounded by the supplied size and so is not the issue; the potential out-of-bounds read of virt_path is the violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n    FILE *                        __os_log_file = NULL;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        /*\n         * Logging probe: capture key state prior to strncpy operations.\n         * This writes an append-only log to /tmp/logs/95.txt so external\n         * tools can inspect whether the virt_path contains a NUL within\n         * the number of bytes that will be read by strncpy.\n         *\n         * Note: the logging intentionally checks for a NUL within the\n         * same bound used by the subsequent strncpy to provide evidence\n         * of the potential read-beyond-source violation scenario.\n         */\n        __os_log_file = fopen(\"/tmp/logs/95.txt\", \"a\");\n        if (__os_log_file != NULL)\n        {\n            size_t __virt_bound = sizeof(filesys->virtual_mountpt) - 1u;\n            const void * __nulpos = memchr(virt_path, 0, __virt_bound);\n\n            fprintf(__os_log_file, \"[OS_FileSysAddFixedMap] token allocated; dev_name='%s'\\n\", dev_name ? dev_name : \"(null)\");\n            fprintf(__os_log_file, \"  phys_path='%s' phys_path_ptr=%p\\n\", phys_path ? phys_path : \"(null)\", (const void *)phys_path);\n            fprintf(__os_log_file, \"  virt_path_ptr=%p check_bound=%zu bytes\\n\", (const void *)virt_path, __virt_bound);\n\n            if (__nulpos == NULL)\n            {\n                fprintf(__os_log_file, \"  RESULT: No NUL found within first %zu bytes of virt_path -> potential out-of-bounds read when calling strncpy.\\n\", __virt_bound);\n            }\n            else\n            {\n                size_t __idx = (const char *)__nulpos - virt_path;\n                fprintf(__os_log_file, \"  RESULT: NUL found at index %zu within the first %zu bytes of virt_path.\\n\", __idx, __virt_bound);\n            }\n\n            fflush(__os_log_file);\n            fclose(__os_log_file);\n            __os_log_file = NULL;\n        }\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        /* Log the result of starting the volume */\n        __os_log_file = fopen(\"/tmp/logs/95.txt\", \"a\");\n        if (__os_log_file != NULL)\n        {\n            fprintf(__os_log_file, \"[OS_FileSysAddFixedMap] OS_FileSysStartVolume_Impl returned %ld\\n\", (long)return_code);\n            fflush(__os_log_file);\n            fclose(__os_log_file);\n            __os_log_file = NULL;\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        /* Log the result of mounting the volume */\n        __os_log_file = fopen(\"/tmp/logs/95.txt\", \"a\");\n        if (__os_log_file != NULL)\n        {\n            fprintf(__os_log_file, \"[OS_FileSysAddFixedMap] OS_FileSysMountVolume_Impl returned %ld\\n\", (long)return_code);\n            fflush(__os_log_file);\n            fclose(__os_log_file);\n            __os_log_file = NULL;\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n\n        /* Final log with overall return_code */\n        __os_log_file = fopen(\"/tmp/logs/95.txt\", \"a\");\n        if (__os_log_file != NULL)\n        {\n            fprintf(__os_log_file, \"[OS_FileSysAddFixedMap] finalize returned %ld; final filesys_id=%p\\n\", (long)return_code, (void *)filesys_id);\n            fflush(__os_log_file);\n            fclose(__os_log_file);\n            __os_log_file = NULL;\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysAddFixedMap. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct as stated given only the code shown. strncpy(dest, src, n) may read up to n bytes from src; if src is not NUL-terminated within those n bytes the call will access beyond the bounds of the source object (undefined behavior). MISRA C 2023 Rule 21.17 prohibits such out-of-bounds accesses by string.h functions. In the posted function, phys_path is checked with OS_CHECK_STRING (which appears intended to bound/validate it), but virt_path is only passed through OS_CHECK_PATHNAME whose behavior is not shown. Unless OS_CHECK_PATHNAME is guaranteed to verify that virt_path contains a NUL within sizeof(filesys->virtual_mountpt) - 1 bytes (or otherwise guarantees the source object is at least that large), the strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1) call is a potential violation of Rule 21.17. To be compliant, ensure a prior check enforces a NUL within the copied bound (e.g. use strnlen/memchr to test), or copy a bounded number of bytes determined from a safe strnlen and then write a terminating NUL."
}