{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nWhen Accessor->sa.sa_family == AF_INET6 the code takes addrbuffer = &Accessor->sa_in6.sin6_addr and passes it to inet_ntop without checking that the underlying Addr->AddrData actually contains a full IPv6 address. If Addr is truncated or actually contains an IPv4 address (e.g. Addr->ActualLength is smaller than sizeof(struct in6_addr) or the stored address is only sockaddr_in), inet_ntop will read the IPv6 address bytes beyond the bounds of Addr->AddrData, resulting in an out-of-bounds access. Because there is no validation of the contained address length/type before taking &sa_in6.sin6_addr, this can violate the requirement that string/memory-handling operations must not access beyond the bounds of the referenced objects.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SocketAddrToString_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/111.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SocketAddrToString_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SocketAddrToString_Impl:\n```c\nint32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr)\n{\n    const void *                  addrbuffer;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            addrbuffer = &Accessor->sa_in.sin_addr;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrbuffer = &Accessor->sa_in6.sin6_addr;\n            break;\n#endif\n        default:\n            return OS_ERR_BAD_ADDRESS;\n            break;\n    }\n\n    if (inet_ntop(Accessor->sa.sa_family, addrbuffer, buffer, buflen) == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_SocketAddrToString_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Probe helper - logs relevant state to /tmp/logs/111.txt without changing program logic */\nstatic void OS_SocketAddrToString_Impl_probe(const OS_SockAddr_t *Addr,\n                                              const OS_SockAddr_Accessor_t *Accessor,\n                                              int family,\n                                              const void *addrbuffer,\n                                              size_t buflen)\n{\n    FILE *f = fopen(\"/tmp/logs/111.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log basic control/state information */\n    fprintf(f, \"--- OS_SocketAddrToString_Impl probe ---\\n\");\n    fprintf(f, \"Addr=%p, Accessor=%p, family=%d, addrbuffer=%p, buflen=%zu\\n\",\n            (const void *)Addr, (const void *)Accessor, family, addrbuffer, buflen);\n\n    /* Log compile-time sizes of the address structures (type-only; sizeof will not dereference) */\n    fprintf(f, \"sizeof(sa_in.sin_addr) = %zu, sizeof(sa_in6.sin6_addr) = %zu\\n\",\n            sizeof(Accessor->sa_in.sin_addr), sizeof(Accessor->sa_in6.sin6_addr));\n\n    /* Size of the stored AddrData array (this is a compile-time/compile-layout value) */\n    fprintf(f, \"sizeof(Addr->AddrData) = %zu\\n\", sizeof(Addr->AddrData));\n\n    /* Hex dump up to a reasonable cap of the stored AddrData bytes to show actual contents */\n    {\n        const unsigned char *bytes = (const unsigned char *)Addr->AddrData;\n        size_t avail = sizeof(Addr->AddrData);\n        size_t cap = avail < 64 ? avail : 64; /* log at most 64 bytes */\n        size_t i;\n\n        fprintf(f, \"Addr->AddrData (first %zu bytes):\", cap);\n        for (i = 0; i < cap; ++i)\n        {\n            fprintf(f, \" %02X\", (unsigned)bytes[i]);\n        }\n        fprintf(f, \"\\n\");\n\n        /* If family indicates IPv6 but the stored data appears smaller than an IPv6 address, log a warning */\n        if (family == AF_INET6 && avail < sizeof(Accessor->sa_in6.sin6_addr))\n        {\n            fprintf(f, \"WARNING: family == AF_INET6 but sizeof(Addr->AddrData) (%zu) < sizeof(in6_addr) (%zu) - potential truncation/out-of-bounds read\\n\",\n                    avail, sizeof(Accessor->sa_in6.sin6_addr));\n        }\n    }\n\n    fprintf(f, \"--- end probe ---\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr)\n{\n    const void *                  addrbuffer;\n    const OS_SockAddr_Accessor_t *Accessor;\n\n    Accessor = (const OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            addrbuffer = &Accessor->sa_in.sin_addr;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrbuffer = &Accessor->sa_in6.sin6_addr;\n            break;\n#endif\n        default:\n            /* Log the unexpected family case as well */\n            OS_SocketAddrToString_Impl_probe(Addr, Accessor, Accessor->sa.sa_family, NULL, buflen);\n            return OS_ERR_BAD_ADDRESS;\n            break;\n    }\n\n    /* Probe/log the chosen address buffer and surrounding state before calling inet_ntop */\n    OS_SocketAddrToString_Impl_probe(Addr, Accessor, Accessor->sa.sa_family, addrbuffer, buflen);\n\n    if (inet_ntop(Accessor->sa.sa_family, addrbuffer, buffer, buflen) == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n"
}