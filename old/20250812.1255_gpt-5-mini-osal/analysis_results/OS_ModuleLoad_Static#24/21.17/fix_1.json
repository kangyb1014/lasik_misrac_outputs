{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef int32_t int32;\ntypedef struct\n{\n    const char *Name;\n    const char *Module;\n} OS_static_symbol_record_t;\nstatic OS_static_symbol_record_t OS_STATIC_SYMTABLE_SOURCE[] =\n{\n    { \"SymbolA\", \"ModuleA\" },\n    { \"SymbolB\", \"ModuleB\" },\n    { NULL, NULL } /* sentinel */\n};\n\nint32 OS_ModuleLoad_Static(const char *ModuleName)\n{\n    int32                      return_code = (int32)-1; /* OS_ERR_NAME_NOT_FOUND */\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n    FILE *logf = NULL;\n    size_t iter = 0;\n\n    /* Open log file (append) to record the control path and relevant pointers. */\n    logf = fopen(\"/tmp/logs/199.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_ModuleLoad_Static entry: ModuleName pointer=%p\\n\", (const void *)ModuleName);\n        fflush(logf);\n    }\n\n    while (StaticSym != NULL)\n    {\n        if (logf != NULL)\n        {\n            fprintf(logf, \"  Loop iter=%zu: StaticSym=%p, Name=%p, Module=%p\\n\",\n                    iter, (void *)StaticSym, (const void *)StaticSym->Name, (const void *)StaticSym->Module);\n            fflush(logf);\n        }\n\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list  */\n            if (logf != NULL)\n            {\n                fprintf(logf, \"  End of static symbol list encountered (Name == NULL). Breaking.\\n\");\n                fflush(logf);\n            }\n            break;\n        }\n\n        /*\n         * NOTE: The original code called strcmp without validating ModuleName.\n         * We preserve that behavior here so that if ModuleName is NULL (or\n         * points to memory without a terminating '\\0'), the resulting crash or\n         * over-read can be observed. We log the intent to call strcmp and the\n         * pointer values immediately before calling it.\n         */\n        if (StaticSym->Module != NULL)\n        {\n            if (logf != NULL)\n            {\n                fprintf(logf, \"  About to call strcmp(StaticSym->Module=%p, ModuleName=%p)\\n\",\n                        (const void *)StaticSym->Module, (const void *)ModuleName);\n                fflush(logf);\n            }\n\n            /* Original comparison (preserved) */\n            if (strcmp(StaticSym->Module, ModuleName) == 0)\n            {\n                /* found matching module name */\n                return_code = 0; /* OS_SUCCESS */\n\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"  strcmp returned 0 -> match found for ModuleName=%p at StaticSym=%p\\n\",\n                            (const void *)ModuleName, (void *)StaticSym);\n                    fflush(logf);\n                }\n\n                break;\n            }\n            else\n            {\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"  strcmp did not match for ModuleName=%p with StaticSym->Module=%p\\n\",\n                            (const void *)ModuleName, (const void *)StaticSym->Module);\n                    fflush(logf);\n                }\n            }\n        }\n\n        ++StaticSym;\n        ++iter;\n    }\n\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_ModuleLoad_Static exit: return_code=%d\\n\", (int)return_code);\n        fclose(logf);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:140:3: error: conflicting type qualifiers for 'OS_static_symbol_record_t'\n  140 | } OS_static_symbol_record_t;\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpauccmlcp/src/src/os/shared/inc/os-shared-module.h:29,\n                 from /tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:47:\n/tmp/tmpauccmlcp/src/src/os/inc/osapi-module.h:118:3: note: previous declaration of 'OS_static_symbol_record_t' with type 'OS_static_symbol_record_t'\n  118 | } OS_static_symbol_record_t;\n      |   ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:82:35: error: conflicting types for 'OS_STATIC_SYMBOL_TABLE'; have 'OS_static_symbol_record_t[]'\n   82 | #define OS_STATIC_SYMTABLE_SOURCE OS_STATIC_SYMBOL_TABLE\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:141:34: note: in expansion of macro 'OS_STATIC_SYMTABLE_SOURCE'\n  141 | static OS_static_symbol_record_t OS_STATIC_SYMTABLE_SOURCE[] =\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:82:35: note: previous declaration of 'OS_STATIC_SYMBOL_TABLE' with type 'const OS_static_symbol_record_t[]'\n   82 | #define OS_STATIC_SYMTABLE_SOURCE OS_STATIC_SYMBOL_TABLE\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpauccmlcp/src/src/os/shared/src/osapi-module.c:87:34: note: in expansion of macro 'OS_STATIC_SYMTABLE_SOURCE'\n   87 | extern OS_static_symbol_record_t OS_STATIC_SYMTABLE_SOURCE[];\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:230: CMakeFiles/osal.dir/src/os/shared/src/osapi-module.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_ModuleLoad_Static as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef int32_t int32;\n\n/*\n * Use a locally-named record type to avoid conflicting with a project-wide\n * definition of OS_static_symbol_record_t that may exist in included headers.\n * The structure layout is identical to the original so the logic is preserved.\n */\ntypedef struct\n{\n    const char *Name;\n    const char *Module;\n} OS_static_symbol_record_local_t;\n\nstatic OS_static_symbol_record_local_t OS_STATIC_SYMTABLE_SOURCE[] =\n{\n    { \"SymbolA\", \"ModuleA\" },\n    { \"SymbolB\", \"ModuleB\" },\n    { NULL, NULL } /* sentinel */\n};\n\nint32 OS_ModuleLoad_Static(const char *ModuleName)\n{\n    int32                            return_code = (int32)-1; /* OS_ERR_NAME_NOT_FOUND */\n    OS_static_symbol_record_local_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n    FILE *logf = NULL;\n    size_t iter = 0;\n\n    /* Open log file (append) to record the control path and relevant pointers. */\n    logf = fopen(\"/tmp/logs/199.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_ModuleLoad_Static entry: ModuleName pointer=%p\\n\", (const void *)ModuleName);\n        fflush(logf);\n    }\n\n    while (StaticSym != NULL)\n    {\n        if (logf != NULL)\n        {\n            fprintf(logf, \"  Loop iter=%zu: StaticSym=%p, Name=%p, Module=%p\\n\",\n                    iter, (void *)StaticSym, (const void *)StaticSym->Name, (const void *)StaticSym->Module);\n            fflush(logf);\n        }\n\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list  */\n            if (logf != NULL)\n            {\n                fprintf(logf, \"  End of static symbol list encountered (Name == NULL). Breaking.\\n\");\n                fflush(logf);\n            }\n            break;\n        }\n\n        /*\n         * NOTE: The original code called strcmp without validating ModuleName.\n         * We preserve that behavior here so that if ModuleName is NULL (or\n         * points to memory without a terminating '\\0'), the resulting crash or\n         * over-read can be observed. We log the intent to call strcmp and the\n         * pointer values immediately before calling it.\n         */\n        if (StaticSym->Module != NULL)\n        {\n            if (logf != NULL)\n            {\n                fprintf(logf, \"  About to call strcmp(StaticSym->Module=%p, ModuleName=%p)\\n\",\n                        (const void *)StaticSym->Module, (const void *)ModuleName);\n                fflush(logf);\n            }\n\n            /* Original comparison (preserved) */\n            if (strcmp(StaticSym->Module, ModuleName) == 0)\n            {\n                /* found matching module name */\n                return_code = 0; /* OS_SUCCESS */\n\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"  strcmp returned 0 -> match found for ModuleName=%p at StaticSym=%p\\n\",\n                            (const void *)ModuleName, (void *)StaticSym);\n                    fflush(logf);\n                }\n\n                break;\n            }\n            else\n            {\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"  strcmp did not match for ModuleName=%p with StaticSym->Module=%p\\n\",\n                            (const void *)ModuleName, (const void *)StaticSym->Module);\n                    fflush(logf);\n                }\n            }\n        }\n\n        ++StaticSym;\n        ++iter;\n    }\n\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_ModuleLoad_Static exit: return_code=%d\\n\", (int)return_code);\n        fclose(logf);\n    }\n\n    return return_code;\n}\n",
  "explanation": "The original compilation error was caused by redeclaring OS_static_symbol_record_t and the static symbol table in a translation unit that already had those declarations in project headers. To avoid that conflict while preserving the logic, I introduced a locally-named struct type (OS_static_symbol_record_local_t) with the same layout and used it for the static table and the function internals. No macros or main function were added. The function logic and logging behavior are preserved exactly."
}