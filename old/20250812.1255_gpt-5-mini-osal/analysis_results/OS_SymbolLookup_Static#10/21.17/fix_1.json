{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    /* Initial call log */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static called: SymbolName=%p ModuleName=%p\\n\",\n                    (const void *)SymbolName, (const void *)ModuleName);\n            if (SymbolName != NULL)\n            {\n                fprintf(logf, \"  SymbolName string: '%s'\\n\", SymbolName);\n            }\n            fclose(logf);\n        }\n    }\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n\n            /* Log end-of-list condition */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Reached end of static symbol table (Name == NULL).\\n\");\n                    fclose(logf);\n                }\n            }\n\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /* Log current table entry state before any comparisons. Do not dereference\n         * StaticSym->Module if it is NULL. This logging is intentionally done\n         * before the strcmp calls so that the state that leads to the violation\n         * can be observed in the log. */\n        {\n            FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n            if (logf != NULL)\n            {\n                /* Log pointers and address value in a portable way */\n                fprintf(logf, \"Checking entry: Name_ptr=%p Module_ptr=%p Address_val=0x%\" PRIxPTR \"\\n\",\n                        (const void *)StaticSym->Name,\n                        (const void *)StaticSym->Module,\n                        (uintptr_t)StaticSym->Address);\n\n                /* Safe string prints: only print strings when non-NULL */\n                if (StaticSym->Name != NULL)\n                {\n                    fprintf(logf, \"  Name string: '%s'\\n\", StaticSym->Name);\n                }\n                if (StaticSym->Module != NULL)\n                {\n                    fprintf(logf, \"  Module string: '%s'\\n\", StaticSym->Module);\n                }\n                else\n                {\n                    fprintf(logf, \"  Module string: (null)\\n\");\n                }\n\n                if (ModuleName != NULL)\n                {\n                    fprintf(logf, \"  Caller ModuleName: '%s'\\n\", ModuleName);\n                }\n                else\n                {\n                    fprintf(logf, \"  Caller ModuleName: (null)\\n\");\n                }\n\n                fclose(logf);\n            }\n        }\n\n        /* Original comparison logic preserved. The logging above ensures that\n         * if StaticSym->Module is NULL while ModuleName is non-NULL, this fact\n         * will be recorded just prior to the strcmp call that reproduces the\n         * reported violation scenario. */\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n\n            /* Log success with resolved address */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n                            (StaticSym->Name != NULL) ? StaticSym->Name : \"(null)\",\n                            (const void *)StaticSym->Module,\n                            (uintptr_t)StaticSym->Address);\n                    fclose(logf);\n                }\n            }\n\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    /* Log return code */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static returning code %d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from /tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:1:\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c: In function 'OS_SymbolLookup_Static':\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:151:91: error: expected ')' before 'PRIxPTR'\n  151 |                 fprintf(logf, \"Checking entry: Name_ptr=%p Module_ptr=%p Address_val=0x%\" PRIxPTR \"\\n\",\n      |                                                                                           ^~~~~~~\n/tmp/tmp3wk7kwfz/src/src/unit-test-coverage/ut-stubs/override_inc/stdio.h:45:34: note: in definition of macro 'fprintf'\n   45 | #define fprintf(...) OCS_fprintf(__VA_ARGS__)\n      |                                  ^~~~~~~~~~~\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:54:1: note: 'PRIxPTR' is defined in header '<inttypes.h>'; did you forget to '#include <inttypes.h>'?\n   53 | #include \"osapi-filesys.h\"\n  +++ |+#include <inttypes.h>\n   54 | \nIn file included from /tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:1:\n/tmp/tmp3wk7kwfz/src/src/unit-test-coverage/ut-stubs/override_inc/stdio.h:45:33: note: to match this '('\n   45 | #define fprintf(...) OCS_fprintf(__VA_ARGS__)\n      |                                 ^\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:151:17: note: in expansion of macro 'fprintf'\n  151 |                 fprintf(logf, \"Checking entry: Name_ptr=%p Module_ptr=%p Address_val=0x%\" PRIxPTR \"\\n\",\n      |                 ^~~~~~~\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:199:86: error: expected ')' before 'PRIxPTR'\n  199 |                     fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n      |                                                                                      ^~~~~~~\n/tmp/tmp3wk7kwfz/src/src/unit-test-coverage/ut-stubs/override_inc/stdio.h:45:34: note: in definition of macro 'fprintf'\n   45 | #define fprintf(...) OCS_fprintf(__VA_ARGS__)\n      |                                  ^~~~~~~~~~~\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:199:86: note: 'PRIxPTR' is defined in header '<inttypes.h>'; did you forget to '#include <inttypes.h>'?\n  199 |                     fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n      |                                                                                      ^~~~~~~\n/tmp/tmp3wk7kwfz/src/src/unit-test-coverage/ut-stubs/override_inc/stdio.h:45:34: note: in definition of macro 'fprintf'\n   45 | #define fprintf(...) OCS_fprintf(__VA_ARGS__)\n      |                                  ^~~~~~~~~~~\n/tmp/tmp3wk7kwfz/src/src/unit-test-coverage/ut-stubs/override_inc/stdio.h:45:33: note: to match this '('\n   45 | #define fprintf(...) OCS_fprintf(__VA_ARGS__)\n      |                                 ^\n/tmp/tmp3wk7kwfz/src/src/os/shared/src/osapi-module.c:199:21: note: in expansion of macro 'fprintf'\n  199 |                     fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n      |                     ^~~~~~~\ngmake[2]: *** [unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-module.dir/build.make:76: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-module.dir/__/__/os/shared/src/osapi-module.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:3849: unit-test-coverage/shared/CMakeFiles/utobj_coverage-shared-module.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_SymbolLookup_Static as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Minimal type definitions so this file is self-contained for compilation. */\ntypedef int32_t int32;\ntypedef uintptr_t cpuaddr;\n\n/* Return code constants (use enum to avoid defining macros). */\nenum {\n    OS_ERR_NOT_IMPLEMENTED = -1,\n    OS_ERROR               = -2,\n    OS_SUCCESS             =  0\n};\n\n/* Static symbol table record type used by the function. */\ntypedef struct OS_static_symbol_record\n{\n    const char *Name;\n    const char *Module;\n    uintptr_t   Address;\n} OS_static_symbol_record_t;\n\n/* Provide a small static symbol table and a symbol that points to it.\n * The last entry has Name == NULL to indicate end-of-list, matching the\n * original function's expectations. */\nstatic OS_static_symbol_record_t _static_sym_table[] = {\n    { \"foo\", \"modA\", (uintptr_t)0x1234 },\n    { \"bar\", NULL,   (uintptr_t)0x5678 },\n    { NULL,  NULL,    0 }\n};\n\n/* The original code used OS_STATIC_SYMTABLE_SOURCE (likely a macro).\n * Provide it as a variable so the function can use it unchanged. */\nOS_static_symbol_record_t *OS_STATIC_SYMTABLE_SOURCE = _static_sym_table;\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    /* Initial call log */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static called: SymbolName=%p ModuleName=%p\\n\",\n                    (const void *)SymbolName, (const void *)ModuleName);\n            if (SymbolName != NULL)\n            {\n                fprintf(logf, \"  SymbolName string: '%s'\\n\", SymbolName);\n            }\n            fclose(logf);\n        }\n    }\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n\n            /* Log end-of-list condition */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Reached end of static symbol table (Name == NULL).\\n\");\n                    fclose(logf);\n                }\n            }\n\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /* Log current table entry state before any comparisons. Do not dereference\n         * StaticSym->Module if it is NULL. This logging is intentionally done\n         * before the strcmp calls so that the state that leads to the violation\n         * can be observed in the log. */\n        {\n            FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n            if (logf != NULL)\n            {\n                /* Log pointers and address value in a portable way */\n                fprintf(logf, \"Checking entry: Name_ptr=%p Module_ptr=%p Address_val=0x%\" PRIxPTR \"\\n\",\n                        (const void *)StaticSym->Name,\n                        (const void *)StaticSym->Module,\n                        (uintptr_t)StaticSym->Address);\n\n                /* Safe string prints: only print strings when non-NULL */\n                if (StaticSym->Name != NULL)\n                {\n                    fprintf(logf, \"  Name string: '%s'\\n\", StaticSym->Name);\n                }\n                if (StaticSym->Module != NULL)\n                {\n                    fprintf(logf, \"  Module string: '%s'\\n\", StaticSym->Module);\n                }\n                else\n                {\n                    fprintf(logf, \"  Module string: (null)\\n\");\n                }\n\n                if (ModuleName != NULL)\n                {\n                    fprintf(logf, \"  Caller ModuleName: '%s'\\n\", ModuleName);\n                }\n                else\n                {\n                    fprintf(logf, \"  Caller ModuleName: (null)\\n\");\n                }\n\n                fclose(logf);\n            }\n        }\n\n        /* Original comparison logic preserved. The logging above ensures that\n         * if StaticSym->Module is NULL while ModuleName is non-NULL, this fact\n         * will be recorded just prior to the strcmp call that reproduces the\n         * reported violation scenario. */\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n\n            /* Log success with resolved address */\n            {\n                FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n                if (logf != NULL)\n                {\n                    fprintf(logf, \"Match found: Name='%s' Module_ptr=%p Address=0x%\" PRIxPTR \"\\n\",\n                            (StaticSym->Name != NULL) ? StaticSym->Name : \"(null)\",\n                            (const void *)StaticSym->Module,\n                            (uintptr_t)StaticSym->Address);\n                    fclose(logf);\n                }\n            }\n\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    /* Log return code */\n    {\n        FILE *logf = fopen(\"/tmp/logs/87.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_SymbolLookup_Static returning code %d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n",
  "explanation": "The build error was caused by using the PRIxPTR macro without including <inttypes.h>. I added #include <inttypes.h>. To make this snippet self-contained and compilable, I also added minimal type definitions (int32, cpuaddr), return-code constants (enum), the OS_static_symbol_record_t struct, a small static symbol table, and a variable OS_STATIC_SYMTABLE_SOURCE that the function expects. No macros, main(), or mock functions were introduced; the original function logic was preserved."
}