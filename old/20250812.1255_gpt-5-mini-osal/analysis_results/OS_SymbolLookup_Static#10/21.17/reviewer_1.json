{
  "user_message": "An agent A claimed that the following OS_SymbolLookup_Static code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SymbolLookup_Static.\n```c\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n            return_code = OS_ERROR;\n            break;\n        }\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs if either input pointers are NULL: (1) If SymbolName == NULL then strcmp(StaticSym->Name, SymbolName) dereferences a NULL pointer (undefined behavior / access beyond bounds). (2) If ModuleName != NULL but StaticSym->Module == NULL then strcmp(StaticSym->Module, ModuleName) dereferences a NULL pointer. The code only checks StaticSym->Name for NULL (terminator) but does not validate SymbolName or StaticSym->Module before calling strcmp.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_ptr_and_str(FILE *f, const char *label, const char *s)\n{\n    fprintf(f, \"%s: ptr=%p\", label, (const void *)s);\n    if (s != NULL)\n    {\n        /* Safe to print when non-NULL */\n        fprintf(f, \" str=\\\"%s\\\"\", s);\n    }\n    else\n    {\n        fprintf(f, \" str=(null)\");\n    }\n    fprintf(f, \"\\n\");\n}\nstatic void probe_log(const char *phase, OS_static_symbol_record_t *sym, const char *SymbolName, const char *ModuleName)\n{\n    FILE *f = fopen(\"/tmp/logs/87.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, do nothing to avoid changing behavior. */\n        return;\n    }\n\n    fprintf(f, \"=== %s ===\\n\", phase);\n    fprintf(f, \"StaticSym ptr=%p\\n\", (void *)sym);\n    if (sym != NULL)\n    {\n        /* Print fields of the static symbol record safely */\n        log_ptr_and_str(f, \"StaticSym->Name\", sym->Name);\n        log_ptr_and_str(f, \"StaticSym->Module\", sym->Module);\n        fprintf(f, \"StaticSym->Address=%p\\n\", (void *)sym->Address);\n    }\n    log_ptr_and_str(f, \"SymbolName\", SymbolName);\n    log_ptr_and_str(f, \"ModuleName\", ModuleName);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SymbolLookup_Static(cpuaddr *SymbolAddress, const char *SymbolName, const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NOT_IMPLEMENTED;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    probe_log(\"entry\", StaticSym, SymbolName, ModuleName);\n\n    while (StaticSym != NULL)\n    {\n        probe_log(\"loop-start\", StaticSym, SymbolName, ModuleName);\n\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list --\n             * Return \"OS_ERROR\" to indicate that an actual search was done\n             * with a not-found result, vs. not searching at all. */\n            probe_log(\"name-null-end-of-list\", StaticSym, SymbolName, ModuleName);\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /* Log immediately before the strcmp comparisons so the exact pointer\n         * state that leads to any undefined behavior (e.g. NULL inputs) is\n         * recorded. We intentionally do NOT change the original strcmp calls\n         * to preserve original behavior. */\n        probe_log(\"before-strcmp\", StaticSym, SymbolName, ModuleName);\n\n        if (strcmp(StaticSym->Name, SymbolName) == 0 &&\n            (ModuleName == NULL || strcmp(StaticSym->Module, ModuleName) == 0))\n        {\n            /* found matching symbol */\n            probe_log(\"found-match\", StaticSym, SymbolName, ModuleName);\n            *SymbolAddress = (cpuaddr)StaticSym->Address;\n            return_code    = OS_SUCCESS;\n            break;\n        }\n\n        probe_log(\"no-match-next\", StaticSym, SymbolName, ModuleName);\n\n        ++StaticSym;\n    }\n\n    probe_log(\"exit\", StaticSym, SymbolName, ModuleName);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SymbolLookup_Static. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code calls strcmp(StaticSym->Name, SymbolName) and (when ModuleName != NULL) strcmp(StaticSym->Module, ModuleName) without first ensuring that the pointer arguments are valid non-NULL C-strings. While the loop checks StaticSym->Name == NULL to detect end-of-list, it does not check SymbolName for NULL before passing it to strcmp, so a caller-provided SymbolName == NULL would cause strcmp to dereference a NULL pointer (undefined behavior / out-of-bounds access). Similarly, when ModuleName != NULL, the code assumes StaticSym->Module is non-NULL; if a table entry has Module == NULL this will pass a NULL first-argument to strcmp and again invoke undefined behavior. Under MISRA C 2023 Rule 21.17, these calls may result in accesses beyond the bounds of the objects referenced by their pointer parameters and therefore violate the rule unless the API formally guarantees (and enforces) non-NULL string inputs. To remedy this, validate pointers before calling strcmp (or document and enforce non-NULL preconditions), thereby avoiding potential out-of-bounds accesses."
}