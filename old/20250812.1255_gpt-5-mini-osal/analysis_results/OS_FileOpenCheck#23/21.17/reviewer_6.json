{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The strcmp(stream->stream_name, Filename) call can read past the end of either operand because neither side is guaranteed to be NUL-terminated or limited to its buffer length. OS_CHECK_POINTER only checks Filename != NULL; it does not ensure the caller-supplied Filename is a valid NUL-terminated string nor does the shown code guarantee stream->stream_name contains a terminating '\\0' (for example if it was previously filled with strncpy without appending a NUL). In such cases strcmp will continue scanning past the bounds of stream->stream_name or past the caller's Filename buffer until a NUL is found, causing an out-of-bounds access. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE *log = NULL;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    /* Open probe log. It's safe to attempt to open the log file; if it fails the function will continue normally. */\n    log = fopen(\"/tmp/logs/191.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck ENTER: Filename=%p\\n\", (void *)Filename);\n        fflush(log);\n    }\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (log)\n        {\n            /* Log iterator token and stream pointers; do not dereference string contents here to avoid introducing new out-of-bounds reads. */\n            fprintf(log, \"ITER token=%p stream_ptr=%p stream_name_ptr=%p socket_domain=%d\\n\",\n                    (void *)&iter.token,\n                    (void *)stream,\n                    (void *)stream->stream_name,\n                    (int)stream->socket_domain);\n            fflush(log);\n        }\n\n        /* Preserve original logic: only consider streams in the invalid socket domain\n         * The strcmp call from the original code is preserved; additional logging wraps it\n         * but does not alter the decision semantics. */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            int cmp_result = 0;\n\n            if (log)\n            {\n                fprintf(log, \"About to call strcmp(stream->stream_name, Filename) with stream_name=%p Filename=%p\\n\",\n                        (void *)stream->stream_name, (void *)Filename);\n                fflush(log);\n            }\n\n            /* ORIGINAL UNSAFE CALL (preserved): Potentially reads past the end of either operand if not NUL-terminated. */\n            cmp_result = strcmp(stream->stream_name, Filename);\n\n            if (log)\n            {\n                fprintf(log, \"strcmp returned %d for token=%p\\n\", cmp_result, (void *)&iter.token);\n                fflush(log);\n            }\n\n            if (cmp_result == 0)\n            {\n                if (log)\n                {\n                    fprintf(log, \"MATCH found: token=%p stream_name_ptr=%p Filename=%p\\n\",\n                            (void *)&iter.token,\n                            (void *)stream->stream_name,\n                            (void *)Filename);\n                    fflush(log);\n                }\n\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck EXIT: return_code=%d\\n\", (int)return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 21.17 applies to strcmp and requires that its pointer operands cannot cause reads beyond the bounds of the referenced objects. In the shown code only Filename is checked for non-NULL; there is no guarantee in this function that Filename is a valid NUL-terminated string nor that stream->stream_name is NUL-terminated (e.g. it might have been populated with strncpy without appending a '\\0' or could otherwise be non-terminated). In that case strcmp may scan past the end of one or both buffers, producing an out-of-bounds access and violating Rule 21.17. The provided test/instrumentation does not change this fact (it simply preserves the unsafe call). To fix, ensure both operands are proven NUL-terminated before calling strcmp or use a bounded comparison (e.g. strncmp with the known buffer size after ensuring termination, or compare lengths and use memcmp), and document/verify the invariants so the call can be proven safe."
}