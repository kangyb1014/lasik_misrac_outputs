{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_FileOpenCheck obtains a pointer via OS_OBJECT_TABLE_GET and stores it in a non-const variable (OS_stream_internal_record_t *stream) even though the function only reads fields (socket_domain and stream_name). The macro expands to &tbl[index] producing a non-const pointer; in this read-only use the pointer should be const-qualified (const OS_stream_internal_record_t *stream) to comply with MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_fileopen_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/187.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    os_fileopen_log(\"OS_FileOpenCheck: start; Filename='%s'\", Filename ? Filename : \"(null)\");\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        /* Capture the pointer as done in the original code (non-const pointer).\n         * Log the pointer value and the fields read to provide evidence of\n         * the read-only use and to reproduce the reported scenario. */\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log control/state information for this iteration */\n        /* Use the address of iter.token for logging since iter.token may be an aggregate type. */\n        os_fileopen_log(\"OS_FileOpenCheck: iter.token=%p, stream_ptr=%p\",\n                        (void *)&iter.token, (void *)stream);\n\n        if (stream != NULL)\n        {\n            /* Log the relevant fields that are inspected in the condition */\n            /* socket_domain is logged as integer; stream_name as a string */\n            os_fileopen_log(\"OS_FileOpenCheck: stream->socket_domain=%d, stream->stream_name='%s'\",\n                            (int)stream->socket_domain,\n                            stream->stream_name ? stream->stream_name : \"(null)\");\n\n            int cmp = strcmp(stream->stream_name, Filename);\n            os_fileopen_log(\"OS_FileOpenCheck: strcmp(stream->stream_name, Filename)=%d\", cmp);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && (cmp == 0))\n            {\n                os_fileopen_log(\"OS_FileOpenCheck: match found; setting return_code=OS_SUCCESS and breaking\");\n                return_code = OS_SUCCESS;\n                break;\n            }\n            else\n            {\n                os_fileopen_log(\"OS_FileOpenCheck: no match; continuing\");\n            }\n        }\n        else\n        {\n            /* Use the address of iter.token for logging since iter.token may be an aggregate type. */\n            os_fileopen_log(\"OS_FileOpenCheck: stream is NULL for token=%p\", (void *)&iter.token);\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    os_fileopen_log(\"OS_FileOpenCheck: end; return_code=%d\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. MISRA C 2023 Rule 8.13 advises that a pointer shall point to a const-qualified type whenever possible. In OS_FileOpenCheck the local variable stream is declared as OS_stream_internal_record_t * but is only used for read-only access (reading socket_domain and stream_name and passing those to strcmp, which accepts const char *). The expression OS_OBJECT_TABLE_GET(...) yields a non-const pointer to an object in a (non-const) table, but assigning that to a const-qualified pointer is allowed (implicit conversion from T * to const T *). Therefore the local pointer should be declared const OS_stream_internal_record_t *stream to comply with the guideline. The empty test log is unrelated to the rule validity \u2014 it only shows the function may not have been exercised. If there is an intended reason why the pointer must be non-const (e.g. this function later needs to modify the object, or other API constraints), that would justify not making it const; absent such a reason, the report is correct and the code violates the intent of Rule 8.13."
}