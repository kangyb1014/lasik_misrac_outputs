{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nThe call OS_NetworkGetID_Impl(&IdBuf) unconditionally returns OS_SUCCESS (the implementation does \"*IdBuf = gethostid(); return OS_SUCCESS;\" and OS_SUCCESS is defined as 0). Therefore the condition (OS_NetworkGetID_Impl(&IdBuf) != OS_SUCCESS) can never be true and the consequent statement \"return -1;\" is unreachable.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_NetworkGetID code that contains useful probe functions that print useful logs to a file \"/tmp/logs/17.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_NetworkGetID as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_NetworkGetID:\n```c\nint32 OS_NetworkGetID(void)\n{\n    int32 IdBuf;\n\n    /* always delegate to low-level API */\n    if (OS_NetworkGetID_Impl(&IdBuf) != OS_SUCCESS)\n    {\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    return IdBuf;\n}\n```\n</target_code>\nPlease provide the modified OS_NetworkGetID code.\n",
  "test_code": "#include <stdio.h>\n\n/* Probe helper: append a log line to /tmp/logs/17.txt. If the log file\n * cannot be opened, the probe is a no-op so it does not affect normal flow.\n */\nstatic void OS_NetworkGetID_Probe(const char *tag, int32 IdBuf, int32 ret)\n{\n    FILE *f = fopen(\"/tmp/logs/17.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Print the tag, IdBuf and return code. Cast to long for portability\n         * when printing fixed-width integer typedefs like int32.\n         */\n        fprintf(f, \"%s: IdBuf=%ld ret=%ld\\n\", tag, (long)IdBuf, (long)ret);\n        fclose(f);\n    }\n}\n\nint32 OS_NetworkGetID(void)\n{\n    int32 IdBuf;\n    int32 ret;\n\n    /* Log entry into the function */\n    OS_NetworkGetID_Probe(\"ENTER OS_NetworkGetID\", 0, 0);\n\n    /* always delegate to low-level API (call once and capture the return)\n     * The original logic compared the call result directly; to preserve the\n     * behavior while allowing logging we store the result in 'ret'.\n     */\n    ret = OS_NetworkGetID_Impl(&IdBuf);\n\n    /* Log the result of the low-level call and the IdBuf value captured */\n    OS_NetworkGetID_Probe(\"After OS_NetworkGetID_Impl\", IdBuf, ret);\n\n    if (ret != OS_SUCCESS)\n    {\n        /* Log the branch that would return the hardcoded failure value */\n        OS_NetworkGetID_Probe(\"Branch: ret != OS_SUCCESS -> returning -1\", IdBuf, ret);\n\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    /* Log the successful return value */\n    OS_NetworkGetID_Probe(\"Branch: ret == OS_SUCCESS -> returning IdBuf\", IdBuf, ret);\n\n    return IdBuf;\n}\n"
}