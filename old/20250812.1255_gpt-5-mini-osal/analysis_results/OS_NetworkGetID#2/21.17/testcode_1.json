{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) can dereference or read past the end of the objects pointed to by its arguments. For example, if StubPtr->Data.Buff.ContentTypeStr is NULL (e.g. the entry was zeroed/cleared or never initialized) or if either TypeName or ContentTypeStr does not point to a null-terminated buffer, strcmp will read beyond the object bounds (or dereference NULL). Therefore use of strcmp here can violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_NetworkGetID code that contains useful probe functions that print useful logs to a file \"/tmp/logs/23.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_NetworkGetID as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_NetworkGetID:\n```c\nint32 OS_NetworkGetID(void)\n{\n    int32 IdBuf;\n\n    /* always delegate to low-level API */\n    if (OS_NetworkGetID_Impl(&IdBuf) != OS_SUCCESS)\n    {\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    return IdBuf;\n}\n```\n</target_code>\nPlease provide the modified OS_NetworkGetID code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n\n/*\n * Probe/logger helper. Appends compact records to /tmp/logs/23.txt\n * Records: timestamp stage pointer_to_IdBuf (if non-NULL) IdBuf_value (if readable) impl_ret\n */\nstatic void os_network_log(const char *stage, void *pIdBuf, int impl_ret)\n{\n    FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* best-effort logging only; do not alter program control flow on failure */\n        return;\n    }\n\n    time_t now = time(NULL);\n    fprintf(f, \"%ld %s: pIdBuf=%p\", (long)now, stage, pIdBuf);\n    if (pIdBuf != NULL)\n    {\n        /* Attempt to print the current IdBuf value. This mirrors program state and\n         * helps reproduce timing/control-flow when the low-level implementation is called.\n         * This read is safe because pIdBuf points to a local stack object in OS_NetworkGetID.\n         */\n        fprintf(f, \" IdBuf=%d\", *(int *)pIdBuf);\n    }\n    fprintf(f, \" impl_ret=%d\\n\", impl_ret);\n    fclose(f);\n}\n\n/* Forward declaration of the platform-specific implementation. This matches the original\n * call site; the definition is expected to exist elsewhere in the codebase.\n */\nextern int32_t OS_NetworkGetID_Impl(int32_t *IdBuf);\n\n/* Preserve original logic of OS_NetworkGetID while adding probes. */\nint32_t OS_NetworkGetID(void)\n{\n    int32_t IdBuf;\n    int32_t impl_ret;\n\n    /* log entry and the address/value of the local buffer before delegating */\n    os_network_log(\"enter\", &IdBuf, 0);\n\n    /* always delegate to low-level API */\n    impl_ret = OS_NetworkGetID_Impl(&IdBuf);\n\n    /* log after the low-level call: buffer (if any) and return code */\n    os_network_log(\"after_impl\", &IdBuf, (int)impl_ret);\n\n    if (impl_ret != OS_SUCCESS)\n    {\n        /* log the failure path before returning the hardcoded value */\n        os_network_log(\"impl_failure\", &IdBuf, (int)impl_ret);\n        /* return a hardcoded value on failure */\n        return -1;\n    }\n\n    /* log successful return value */\n    os_network_log(\"return_success\", &IdBuf, (int)IdBuf);\n\n    return IdBuf;\n}\n"
}