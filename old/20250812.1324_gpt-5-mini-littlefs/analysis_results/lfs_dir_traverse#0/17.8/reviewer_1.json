{
  "user_message": "An agent A claimed that the following lfs_dir_traverse code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_traverse.\n```c\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'data' (declared as void *data) is assigned to: data = &stack[sp-1].tag; \u2014 this modifies the pointer parameter itself (changes its value to point into the local stack), which violates MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void lfs_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/5.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    /* Log entry and initial important parameters */\n    lfs_log_probe(\"ENTER lfs_dir_traverse: data=%p ptag=0x%08x tmask=0x%08x ttag=0x%08x begin=%u end=%u diff=%d\",\n            data, (unsigned)ptag, (unsigned)tmask, (unsigned)ttag, (unsigned)begin, (unsigned)end, (int)diff);\n\n    /* This function in inherently recursive, but bounded. To allow tool-based\n    /* analysis without unnecessary code-cost we use an explicit stack */\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    /* iterate over directory and attrs */\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    lfs_log_probe(\"ERR lfs_bd_read returned %d while reading tag (data=%p)\", err, data);\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                /* finished traversal, pop from stack? */\n                res = 0;\n                break;\n            }\n\n            /* do we need to filter? */\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                /* recurse, scan for duplicates, and update tag based on\n                /* creates/deletes */\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n\n                /* Log the push for filtering */\n                lfs_log_probe(\"PUSH filter: sp=%u saved_data=%p saved_tag=0x%08x\", sp, data, (unsigned)tag);\n\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n\n                /* Log before assigning data to point into stack element */\n                lfs_log_probe(\"ASSIGN data (filter): prev_data=%p will_set_to=&stack[%u].tag (addr=%p) saved_tag=0x%08x\",\n                        data, sp-1, (void *)&stack[sp-1].tag, (unsigned)stack[sp-1].tag);\n\n                data = &stack[sp-1].tag;\n\n                /* Log after assignment */\n                lfs_log_probe(\"ASSIGN data (filter) COMPLETE: new_data=%p (points_at_tag=0x%08x)\",\n                        data, (unsigned)stack[sp-1].tag);\n\n                continue;\n            }\n        }\n\npopped:\n        /* in filter range? */\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        /* handle special cases for mcu-side operations */\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            /* do nothing */\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            /* Without this condition, lfs_dir_traverse can exhibit an\n            /* extremely expensive O(n^3) of nested loops when renaming.\n            /* This happens because lfs_dir_traverse tries to filter tags by\n            /* the tags in the source directory, triggering a second\n            /* lfs_dir_traverse with its own filter operation.\n            /*\n            /* traverse with commit\n            /* '-> traverse with filter\n            /*     '-> traverse with move\n            /*         '-> traverse with filter\n            /*\n            /* However we don't actually care about filtering the second set of\n            /* tags, since duplicate tags have no effect when filtering.\n            /*\n            /* This check skips this unnecessary recursive filtering explicitly,\n            /* reducing this runtime from O(n^3) to O(n^2).\n            */\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            /* recurse into move */\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n\n            /* Log the push for move recursion (saved data pointer) */\n            lfs_log_probe(\"PUSH move: sp=%u saved_data=%p\", sp, data);\n\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n\n                /* Log callback invocation for a userattr element */\n                lfs_log_probe(\"CALL_CB userattr: data=%p tag=0x%08x element_index=%u size=%u\",\n                        data, (unsigned)LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), i, (unsigned)a[i].size);\n\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    lfs_log_probe(\"CALL_CB returned error %d (data=%p)\", res, data);\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            /* Log callback invocation for general tag */\n            lfs_log_probe(\"CALL_CB: data=%p tag=0x%08x\", data, (unsigned)(tag + LFS_MKTAG(0, diff, 0)));\n\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                lfs_log_probe(\"CALL_CB returned error %d (data=%p)\", res, data);\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        /* pop from the stack and return, fortunately all pops share\n        /* a destination */\n        lfs_log_probe(\"POP: sp=%u about_to_restore_from_stack_index=%u saved_data=%p\", sp, sp-1, (void *)stack[sp-1].data);\n\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n\n        /* Log previous data pointer and the saved one in the stack */\n        lfs_log_probe(\"POP: pre_restore_data=%p restoring_saved_data=%p\", data, (void *)stack[sp-1].data);\n\n        data        = stack[sp-1].data;\n\n        lfs_log_probe(\"POP: post_restore_data=%p\", data);\n\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        lfs_log_probe(\"EXIT lfs_dir_traverse: returning res=%d\", res);\n        return res;\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER lfs_dir_traverse: data=0x7ffee2cb8b90 ptag=0xffffffff tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0\nPUSH filter: sp=0 saved_data=0x7ffee2cb8b90 saved_tag=0x0ff00008\nASSIGN data (filter): prev_data=0x7ffee2cb8b90 will_set_to=&stack[0].tag (addr=0x7ffee2cb8a68) saved_tag=0x0ff00008\nASSIGN data (filter) COMPLETE: new_data=0x7ffee2cb8a68 (points_at_tag=0x0ff00008)\nCALL_CB: data=0x7ffee2cb8a68 tag=0x20100018\nPOP: sp=1 about_to_restore_from_stack_index=0 saved_data=0x7ffee2cb8b90\nPOP: pre_restore_data=0x7ffee2cb8a68 restoring_saved_data=0x7ffee2cb8b90\nPOP: post_restore_data=0x7ffee2cb8b90\nCALL_CB: data=0x7ffee2cb8b90 tag=0x0ff00008\nPUSH filter: sp=0 saved_data=0x7ffee2cb8b90 saved_tag=0x20100018\nASSIGN data (filter): prev_data=0x7ffee2cb8b90 will_set_to=&stack[0].tag (addr=0x7ffee2cb8a68) saved_tag=0x20100018\nASSIGN data (filter) COMPLETE: new_data=0x7ffee2cb8a68 (points_at_tag=0x20100018)\nPOP: sp=1 about_to_restore_from_stack_index=0 saved_data=0x7ffee2cb8b90\nPOP: pre_restore_data=0x7ffee2cb8a68 restoring_saved_data=0x7ffee2cb8b90\nPOP: post_restore_data=0x7ffee2cb8b90\nCALL_CB: data=0x7ffee2cb8b90 tag=0x20100018\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8b90 ptag=0xffffffff tmask=0x400ffc00 ttag=0x00000000 begin=0 end=1 diff=0\nPUSH filter: sp=0 saved_data=0x7ffee2cb8b90 saved_tag=0x8ff00008\nASSIGN data (filter): prev_data=0x7ffee2cb8b90 will_set_to=&stack[0].tag (addr=0x7ffee2cb8a68) saved_tag=0x8ff00008\nASSIGN data (filter) COMPLETE: new_data=0x7ffee2cb8a68 (points_at_tag=0x8ff00008)\nCALL_CB: data=0x7ffee2cb8a68 tag=0xa0100018\nCALL_CB: data=0x7ffee2cb8a68 tag=0xdffffc08\nCALL_CB: data=0x7ffee2cb8a68 tag=0xd00ffc04\nPOP: sp=1 about_to_restore_from_stack_index=0 saved_data=0x7ffee2cb8b90\nPOP: pre_restore_data=0x7ffee2cb8a68 restoring_saved_data=0x7ffee2cb8b90\nPOP: post_restore_data=0x7ffee2cb8b90\nCALL_CB: data=0x7ffee2cb8b90 tag=0x8ff00008\nPUSH filter: sp=0 saved_data=0x7ffee2cb8b90 saved_tag=0xa0100018\nASSIGN data (filter): prev_data=0x7ffee2cb8b90 will_set_to=&stack[0].tag (addr=0x7ffee2cb8a68) saved_tag=0xa0100018\nASSIGN data (filter) COMPLETE: new_data=0x7ffee2cb8a68 (points_at_tag=0xa0100018)\nCALL_CB: data=0x7ffee2cb8a68 tag=0xdffffc08\nCALL_CB: data=0x7ffee2cb8a68 tag=0xd00ffc04\nPOP: sp=1 about_to_restore_from_stack_index=0 saved_data=0x7ffee2cb8b90\nPOP: pre_restore_data=0x7ffee2cb8a68 restoring_saved_data=0x7ffee2cb8b90\nPOP: post_restore_data=0x7ffee2cb8b90\nCALL_CB: data=0x7ffee2cb8b90 tag=0xa0100018\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8b20 ptag=0xffffffff tmask=0x400ffc00 ttag=0x00000000 begin=0 end=0 diff=0\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8c30 ptag=0x500ffc04 tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0\nCALL_CB: data=0x7ffee2cb8c30 tag=0x40100400\nCALL_CB: data=0x7ffee2cb8c30 tag=0x00200409\nCALL_CB: data=0x7ffee2cb8c30 tag=0x20000408\nCALL_CB: data=0x7ffee2cb8c30 tag=0x600ffc08\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8c90 ptag=0x500ffc0c tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0\nCALL_CB: data=0x7ffee2cb8c90 tag=0x40100000\nCALL_CB: data=0x7ffee2cb8c90 tag=0x00100005\nCALL_CB: data=0x7ffee2cb8c90 tag=0x20100000\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8c90 ptag=0x500ffc0f tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0\nCALL_CB: data=0x7ffee2cb8c90 tag=0x40100400\nCALL_CB: data=0x7ffee2cb8c90 tag=0x00100404\nCALL_CB: data=0x7ffee2cb8c90 tag=0x20100400\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8c90 ptag=0x500ffc10 tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0\nCALL_CB: data=0x7ffee2cb8c90 tag=0x40100800\nCALL_CB: data=0x7ffee2cb8c90 tag=0x00100808\nCALL_CB: data=0x7ffee2cb8c90 tag=0x20100800\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7ffee2cb8ca0 ptag=0x500ffc0c tmask=0x00000000 ttag=0x00000000 begin=0 end=0 diff=0\nCALL_CB: data=0x7ffee2cb8ca0 tag=0x20200008\nEXIT lfs_dir_traverse: returning res=0\nENTER lfs_dir_traverse: data=0x7\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 states that function parameters shall not be modified (the object pointed to by a pointer parameter may be modified, but the pointer itself shall not be). In lfs_dir_traverse the formal parameter data (declared as void *data) is explicitly assigned to (data = &stack[sp-1].tag;), which changes the value of the pointer parameter itself. The provided logs demonstrate the assignment and subsequent restoration, but that does not avoid the rule \u2014 the parameter is still being modified. (Note: several other formal parameters such as cb, dir, attrs, attrcount, tmask, etc. are also reassigned within the function and would likewise violate Rule 17.8.)"
}