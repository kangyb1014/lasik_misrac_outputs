{
  "user_message": "An agent A claimed that the following lfs_dir_traverse code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of lfs_dir_traverse.\n```c\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    // This function in inherently recursive, but bounded. To allow tool-based\n    // analysis without unnecessary code-cost we use an explicit stack\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    // iterate over directory and attrs\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                // finished traversal, pop from stack?\n                res = 0;\n                break;\n            }\n\n            // do we need to filter?\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                // recurse, scan for duplicates, and update tag based on\n                // creates/deletes\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        // in filter range?\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        // handle special cases for mcu-side operations\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            // do nothing\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            // Without this condition, lfs_dir_traverse can exhibit an\n            // extremely expensive O(n^3) of nested loops when renaming.\n            // This happens because lfs_dir_traverse tries to filter tags by\n            // the tags in the source directory, triggering a second\n            // lfs_dir_traverse with its own filter operation.\n            //\n            // traverse with commit\n            // '-> traverse with filter\n            //     '-> traverse with move\n            //         '-> traverse with filter\n            //\n            // However we don't actually care about filtering the second set of\n            // tags, since duplicate tags have no effect when filtering.\n            //\n            // This check skips this unnecessary recursive filtering explicitly,\n            // reducing this runtime from O(n^3) to O(n^2).\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            // recurse into move\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        // pop from the stack and return, fortunately all pops share\n        // a destination\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function assigns to the function-pointer parameter 'cb' (cb = lfs_dir_traverse_filter;) inside lfs_dir_traverse, i.e. it modifies the pointer parameter by reassigning it to another function pointer. This is a direct violation of MISRA C 2023 Rule 17.8, which forbids modifying function parameters (the pointer itself shall not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void lfs_logf(const char *fmt, ...) {\n    FILE *f = fopen(\"/tmp/logs/5.txt\", \"a\");\n    if (!f) { return; }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void lfs_log_enter(const void *cb, const void *data) {\n    /* Cast function pointer to integer-sized pointer for printing */\n    lfs_logf(\"ENTER lfs_dir_traverse: cb=%p data=%p\", (void*)(uintptr_t)cb, data);\n}\nstatic void lfs_log_assign_cb(const void *oldcb, const void *newcb, const void *data) {\n    lfs_logf(\"ASSIGN cb: old=%p new=%p data=%p\", (void*)(uintptr_t)oldcb, (void*)(uintptr_t)newcb, data);\n}\nstatic void lfs_log_check_cb_eq(const char *context, int eq) {\n    lfs_logf(\"CHECK cb == lfs_dir_traverse_filter (%s): %s\", context, eq ? \"true\" : \"false\");\n}\nstatic void lfs_log_call_cb(const void *cb, unsigned long long tag, const void *buffer, const void *data) {\n    lfs_logf(\"CALL cb=%p tag=%llu buffer=%p data=%p\", (void*)(uintptr_t)cb, tag, buffer, data);\n}\n\nstatic int lfs_dir_traverse(lfs_t *lfs,\n        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,\n        const struct lfs_mattr *attrs, int attrcount,\n        lfs_tag_t tmask, lfs_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {\n    /* Log entry state */\n    lfs_log_enter(cb, data);\n\n    /* This function in inherently recursive, but bounded. To allow tool-based\n    * analysis without unnecessary code-cost we use an explicit stack */\n    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    /* iterate over directory and attrs */\n    lfs_tag_t tag;\n    const void *buffer;\n    struct lfs_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs_tag_dsize(ptag) < dir->off) {\n                off += lfs_tag_dsize(ptag);\n                int err = lfs_bd_read(lfs,\n                        NULL, &lfs->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                /* finished traversal, pop from stack? */\n                res = 0;\n                break;\n            }\n\n            /* do we need to filter? */\n            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs_tag_id(tmask) != 0) {\n                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);\n                /* recurse, scan for duplicates, and update tag based on\n                 * creates/deletes */\n                stack[sp] = (struct lfs_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                /* Log the impending assignment to the function-parameter 'cb' */\n                lfs_log_assign_cb(cb, lfs_dir_traverse_filter, data);\n                cb = lfs_dir_traverse_filter;\n                /* Log the fact that we performed the assignment */\n                lfs_logf(\"PERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=%p)\", data);\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        /* in filter range? */\n        if (lfs_tag_id(tmask) != 0 &&\n                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {\n            continue;\n        }\n\n        /* handle special cases for mcu-side operations */\n        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {\n            /* do nothing */\n        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {\n            /* Without this condition, lfs_dir_traverse can exhibit an\n             * extremely expensive O(n^3) of nested loops when renaming.\n             * This happens because lfs_dir_traverse tries to filter tags by\n             * the tags in the source directory, triggering a second\n             * lfs_dir_traverse with its own filter operation.\n             *\n             * However we don't actually care about filtering the second set of\n             * tags, since duplicate tags have no effect when filtering.\n             *\n             * This check skips this unnecessary recursive filtering explicitly,\n             * reducing this runtime from O(n^3) to O(n^2).\n             */\n            /* Log comparison: are we calling the filter callback? */\n            lfs_log_check_cb_eq(\"move-special-case\", cb == lfs_dir_traverse_filter);\n            if (cb == lfs_dir_traverse_filter) {\n                continue;\n            }\n\n            /* recurse into move */\n            stack[sp] = (struct lfs_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs_tag_size(tag);\n            uint16_t toid = lfs_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {\n                const struct lfs_attr *a = buffer;\n                /* Log before invoking cb for user attributes */\n                lfs_log_call_cb(cb, (unsigned long long)LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer, data);\n                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,\n                        lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            /* Log before invoking cb for regular tags */\n            lfs_log_call_cb(cb, (unsigned long long)(tag + LFS_MKTAG(0, diff, 0)), buffer, data);\n            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        /* pop from the stack and return, fortunately all pops share\n         * a destination */\n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        /* Log cb restore from stack */\n        lfs_logf(\"RESTORE cb from stack: old=%p restored=%p data=%p\", (void*)(uintptr_t)cb, (void*)(uintptr_t)stack[sp-1].cb, data);\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        lfs_logf(\"EXIT lfs_dir_traverse: res=%d\", res);\n        return res;\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7960\nASSIGN cb: old=0x55ad6351bbb0 new=0x55ad635185e4 data=0x7ffde03a7960\nPERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=0x7ffde03a7960)\nCALL cb=0x55ad635185e4 tag=537919512 buffer=0x7ffde03a7c00 data=0x7ffde03a7838\nRESTORE cb from stack: old=0x55ad635185e4 restored=0x55ad6351bbb0 data=0x7ffde03a7838\nCALL cb=0x55ad6351bbb0 tag=267386888 buffer=0x55ad6354b9f7 data=0x7ffde03a7960\nASSIGN cb: old=0x55ad6351bbb0 new=0x55ad635185e4 data=0x7ffde03a7960\nPERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=0x7ffde03a7960)\nRESTORE cb from stack: old=0x55ad635185e4 restored=0x55ad6351bbb0 data=0x7ffde03a7838\nCALL cb=0x55ad6351bbb0 tag=537919512 buffer=0x7ffde03a7c00 data=0x7ffde03a7960\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7960\nASSIGN cb: old=0x55ad6351bbb0 new=0x55ad635185e4 data=0x7ffde03a7960\nPERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=0x7ffde03a7960)\nCALL cb=0x55ad635185e4 tag=2685403160 buffer=0x7ffde03a77f0 data=0x7ffde03a7838\nCALL cb=0x55ad635185e4 tag=3758095368 buffer=0x7ffde03a77f0 data=0x7ffde03a7838\nCALL cb=0x55ad635185e4 tag=3490708484 buffer=0x7ffde03a77f0 data=0x7ffde03a7838\nRESTORE cb from stack: old=0x55ad635185e4 restored=0x55ad6351bbb0 data=0x7ffde03a7838\nCALL cb=0x55ad6351bbb0 tag=2414870536 buffer=0x7ffde03a77f0 data=0x7ffde03a7960\nASSIGN cb: old=0x55ad6351bbb0 new=0x55ad635185e4 data=0x7ffde03a7960\nPERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=0x7ffde03a7960)\nCALL cb=0x55ad635185e4 tag=3758095368 buffer=0x7ffde03a77f0 data=0x7ffde03a7838\nCALL cb=0x55ad635185e4 tag=3490708484 buffer=0x7ffde03a77f0 data=0x7ffde03a7838\nRESTORE cb from stack: old=0x55ad635185e4 restored=0x55ad6351bbb0 data=0x7ffde03a7838\nCALL cb=0x55ad6351bbb0 tag=2685403160 buffer=0x7ffde03a77f0 data=0x7ffde03a7960\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a78f0\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a00\nCALL cb=0x55ad6351bbb0 tag=1074791424 buffer=(nil) data=0x7ffde03a7a00\nCALL cb=0x55ad6351bbb0 tag=2098185 buffer=0x55ad6354806c data=0x7ffde03a7a00\nCALL cb=0x55ad6351bbb0 tag=536871944 buffer=0x7ffde03a7bb0 data=0x7ffde03a7a00\nCALL cb=0x55ad6351bbb0 tag=1611660296 buffer=0x7ffde03a7bb0 data=0x7ffde03a7a00\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1074790400 buffer=(nil) data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1048581 buffer=0x7ffde03a83c2 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=537919488 buffer=(nil) data=0x7ffde03a7a60\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1074791424 buffer=(nil) data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1049604 buffer=0x7ffde03a83c2 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=537920512 buffer=(nil) data=0x7ffde03a7a60\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1074792448 buffer=(nil) data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=1050632 buffer=0x7ffde03a83c2 data=0x7ffde03a7a60\nCALL cb=0x55ad6351bbb0 tag=537921536 buffer=(nil) data=0x7ffde03a7a60\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a70\nCALL cb=0x55ad6351bbb0 tag=538968072 buffer=0x7ffde03a7bf8 data=0x7ffde03a7a70\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a70\nCALL cb=0x55ad6351bbb0 tag=538969096 buffer=0x7ffde03a7bf8 data=0x7ffde03a7a70\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7a70\nCALL cb=0x55ad6351bbb0 tag=538970120 buffer=0x7ffde03a7bf8 data=0x7ffde03a7a70\nEXIT lfs_dir_traverse: res=0\nENTER lfs_dir_traverse: cb=0x55ad6351bbb0 data=0x7ffde03a7960\nASSIGN cb: old=0x55ad6351bbb0 new=0x55ad635185e4 data=0x7ffde03a7960\nPERFORMED ASSIGNMENT: cb now set to lfs_dir_traverse_filter (data=0x7ffde03a7960)\nCALL cb=0x55ad635185e4 tag=537\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function assigns to the function-parameter cb (cb = lfs_dir_traverse_filter; and later cb = stack[sp-1].cb;), which directly modifies the pointer parameter itself. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (and explicitly states that while the object pointed to may be modified, the pointer parameter itself shall not be modified). The provided test logs show the assignments and restores of cb (ASSIGN cb / PERFORMED ASSIGNMENT / RESTORE cb from stack), confirming the behavior. (Note: the function also modifies several other parameters such as attrs, attrcount, tmask, begin, end, diff and data, which are additional violations of the same rule.)"
}