{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nThe code calls memcmp(name, \".\", 1) to test whether a path component equals the string \".\". Here 'name' points into a null-terminated path buffer and the second argument is a string literal (\".\") \u2014 i.e. this is using memcmp to compare string data. (The same pattern also appears elsewhere in the file for \"..\" and suffix checks.) According to MISRA C 2023 Rule 21.14, memcmp shall not be used to compare null-terminated strings, so this use violates the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_opencfg code that contains useful probe functions that print useful logs to a file \"/tmp/logs/214.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_opencfg as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_opencfg:\n```c\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs, (void*)file, path, (unsigned)flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);\n\n    LFS_TRACE(\"lfs_file_opencfg -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_opencfg code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Probe helper: append logs to /tmp/logs/214.txt. */\nstatic void lfs_probe_log(const char *msg) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n}\n\n/* Probe helper: log pointer and numeric state in a compact form. */\nstatic void lfs_probe_log_state(const char *prefix, const void *lfs, const void *file,\n        const char *path, int flags, const void *cfg, const void *buffer,\n        const void *attrs, unsigned long attr_count) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    fprintf(f, \"%s: lfs=%p file=%p path=%p(\\\"%s\\\") flags=0x%X cfg=%p buffer=%p attrs=%p attr_count=%lu\\n\",\n            prefix, lfs, file, (const void*)path, path ? path : \"(null)\", (unsigned)flags,\n            cfg, buffer, attrs, attr_count);\n    fclose(f);\n}\n\n/* Probe helper: scan path components and log occurrences of \".\" and \"..\"\n   This reproduces evidence for scenarios where string comparisons on null-terminated\n   path components are relevant. Uses character checks (not memcmp) to avoid\n   introducing the same rule violation. */\nstatic void lfs_probe_scan_path_for_dot_components(const char *path) {\n    FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    if (!path) {\n        fprintf(f, \"scan_path: path is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    const char *p = path;\n    unsigned comp_index = 0;\n    while (*p) {\n        /* skip leading slashes */\n        while (*p == '/') {\n            p++;\n        }\n        if (!*p) break;\n        /* find end of component */\n        const char *q = p;\n        while (*q && *q != '/') q++;\n        size_t len = (size_t)(q - p);\n\n        /* check for \".\" and \"..\" without using memcmp */\n        if (len == 1 && p[0] == '.') {\n            fprintf(f, \"scan_path: component[%u] == \\\".\\\" at offset %td\\n\", comp_index, (ptrdiff_t)(p - path));\n        }\n        else if (len == 2 && p[0] == '.' && p[1] == '.') {\n            fprintf(f, \"scan_path: component[%u] == \\\"..\\\" at offset %td\\n\", comp_index, (ptrdiff_t)(p - path));\n        }\n        else {\n            /* log suffixes that might be checked elsewhere (e.g., trailing \".\" patterns) */\n            if (len > 0) {\n                /* log a small preview (up to 16 chars) to avoid large output */\n                size_t preview = len > 16 ? 16 : len;\n                char buf[17];\n                for (size_t i = 0; i < preview; i++) buf[i] = p[i];\n                buf[preview] = '\\0';\n                fprintf(f, \"scan_path: component[%u] (len=%zu) preview=\\\"%s\\\" offset=%td\\n\",\n                        comp_index, len, buf, (ptrdiff_t)(p - path));\n            }\n        }\n\n        comp_index++;\n        p = q;\n    }\n\n    fclose(f);\n}\n\n/* Modified lfs_file_opencfg preserving original logic but with probes. */\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        /* log the lock failure */\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"lfs_file_opencfg: LFS_LOCK failed -> %d\", err);\n        lfs_probe_log(buf);\n        return err;\n    }\n\n    /* Original trace retained */\n    LFS_TRACE(\"lfs_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs, (void*)file, path, (unsigned)flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n\n    /* Assertion retained */\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    /* Probe: log state before calling the internal open function */\n    lfs_probe_log_state(\"lfs_file_opencfg:entry\", lfs, file, path, flags,\n            cfg, cfg ? cfg->buffer : NULL, cfg ? cfg->attrs : NULL,\n            cfg ? (unsigned long)cfg->attr_count : 0UL);\n\n    /* Probe: scan the path and record any '.' or '..' components\n       to provide evidence for string comparison cases. */\n    lfs_probe_scan_path_for_dot_components(path);\n\n    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);\n\n    /* Probe: log the return value and state after the internal call */\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"lfs_file_opencfg: exit -> %d\", err);\n    lfs_probe_log(buf);\n\n    LFS_TRACE(\"lfs_file_opencfg -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n"
}