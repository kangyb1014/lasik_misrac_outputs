{
  "user_message": "An agent A claimed that the following lfs_fs_grow code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of lfs_fs_grow.\n```c\nint lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_fs_grow(%p, %\"PRIu32\")\", (void*)lfs, block_count);\n\n    err = lfs_fs_grow_(lfs, block_count);\n\n    LFS_TRACE(\"lfs_fs_grow -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'block_count' (a non-pointer scalar) is potentially modified via its address when passed to lfs_fs_traverse_: lfs_fs_traverse_(lfs, lfs_shrink_checkblock, &block_count, true). This changes the parameter variable itself (when LFS_SHRINKNONRELOCATING is defined), violating Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void lfs_probe_log_state(const char *stage, const lfs_t *lfs,\n                                lfs_size_t block_count, const void *addr,\n                                int err) {\n    FILE *f = fopen(\"/tmp/logs/197.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n    /* Log stage, pointer to lfs, value of block_count, address of block_count, and err */\n    fprintf(f, \"%s: lfs=%p block_count=%\" PRIu32 \" addr_block_count=%p err=%d\\n\",\n            stage, (void*)lfs, block_count, addr, err);\n    fflush(f);\n    fclose(f);\n}\n\nint lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_fs_grow(%p, %\"PRIu32\")\", (void*)lfs, block_count);\n\n    /* Log the incoming parameter state and its address before calling the internal function.\n       This captures the original value and location so we can detect if the callee\n       modifies the parameter via its address (the violation scenario). */\n    lfs_probe_log_state(\"lfs_fs_grow - before lfs_fs_grow_\", lfs, block_count, &block_count, 0);\n\n    /* Keep a local copy of the original value for easy comparison after the call. */\n    lfs_size_t orig_block_count = block_count;\n\n    err = lfs_fs_grow_(lfs, block_count);\n\n    /* Log the state after the call to observe any changes to the parameter's value\n       or to provide evidence that it was modified via its address. */\n    lfs_probe_log_state(\"lfs_fs_grow - after lfs_fs_grow_\", lfs, block_count, &block_count, err);\n\n    /* Additional note in the log if the value changed (helps reproduce the violation). */\n    if (block_count != orig_block_count) {\n        lfs_probe_log_state(\"lfs_fs_grow - DETECTED_MODIFICATION\", lfs, block_count, &block_count, err);\n    }\n\n    LFS_TRACE(\"lfs_fs_grow -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for lfs_fs_grow. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. lfs_fs_grow takes block_count by value and does not take its address or assign to it anywhere in the shown code. In C, passing a scalar by value gives the callee its own copy; any modifications to a parameter inside lfs_fs_grow_ (or to that function\u2019s parameter via &param passed to deeper callees) affect only the callee\u2019s local parameter, not the caller\u2019s local variable. Rule 17.8 forbids modifying a function\u2019s own parameter (including taking its address and letting a callee write to it), but nothing in the provided lfs_fs_grow modifies its block_count parameter or passes &block_count. If a violation exists it would be in lfs_fs_grow_ (or whatever function actually takes &block_count and writes to it), not in lfs_fs_grow. The empty log is consistent with the test not exercising the code path or the misattribution of which function\u2019s parameter is being modified."
}