{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of lfs_fs_traverse:\n```c\nint lfs_fs_traverse(lfs_t *lfs, int (*cb)(void *, lfs_block_t), void *data) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_fs_traverse(%p, %p, %p)\",\n            (void*)lfs, (void*)(uintptr_t)cb, data);\n\n    err = lfs_fs_traverse_(lfs, cb, data, true);\n\n    LFS_TRACE(\"lfs_fs_traverse -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_traverse:\nint lfs_fs_traverse_(lfs_t *lfs,\n        int (*cb)(void *data, lfs_block_t block), void *data,\n        bool includeorphans) {\n    // iterate over metadata pairs\n    lfs_mdir_t dir = {.tail = {0, 1}};\n\n#ifdef LFS_MIGRATE\n    // also consider v1 blocks during migration\n    if (lfs->lfs1) {\n        int err = lfs1_traverse(lfs, cb, data);\n        if (err) {\n            return err;\n        }\n\n        dir.tail[0] = lfs->root[0];\n        dir.tail[1] = lfs->root[1];\n    }\n#endif\n\n    struct lfs_tortoise_t tortoise = {\n        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},\n        .i = 1,\n        .period = 1,\n    };\n    int err = LFS_ERR_OK;\n    while (!lfs_pair_isnull(dir.tail)) {\n        err = lfs_tortoise_detectcycles(&dir, &tortoise);\n        if (err < 0) {\n            return LFS_ERR_CORRUPT;\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int err = cb(data, dir.tail[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        // iterate through ids in directory\n        int err = lfs_dir_fetch(lfs, &dir, dir.tail);\n        if (err) {\n            return err;\n        }\n\n        for (uint16_t id = 0; id < dir.count; id++) {\n            struct lfs_ctz ctz;\n            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n            if (tag < 0) {\n                if (tag == LFS_ERR_NOENT) {\n                    continue;\n                }\n                return tag;\n            }\n            lfs_ctz_fromle32(&ctz);\n\n            if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {\n                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,\n                        ctz.head, ctz.size, cb, data);\n                if (err) {\n                    return err;\n                }\n            } else if (includeorphans &&\n                    lfs_tag_type3(tag) == LFS_TYPE_DIRSTRUCT) {\n                for (int i = 0; i < 2; i++) {\n                    err = cb(data, (&ctz.head)[i]);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n        }\n    }\n\n#ifndef LFS_READONLY\n    // iterate over any open files\n    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {\n        if (f->type != LFS_TYPE_REG) {\n            continue;\n        }\n\n        if ((f->flags & LFS_F_DIRTY) && !(f->flags & LFS_F_INLINE)) {\n            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,\n                    f->ctz.head, f->ctz.size, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n\n        if ((f->flags & LFS_F_WRITING) && !(f->flags & LFS_F_INLINE)) {\n            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,\n                    f->block, f->pos, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n    }\n#endif\n\n    return 0;\n}\n...\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define LFS_LOCK(cfg) ((void)cfg,0)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The macro LFS_LOCK(cfg) expands to '((void)cfg, 0)'. The subexpression '(void)cfg' is executed but has no effect (and LFS_UNLOCK(cfg) is similarly '((void)cfg)'). Removing these no-op evaluations would not change program behaviour, so they constitute dead code."
}