{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe LFS_TRACE macro is defined as empty (#define LFS_TRACE(__VA_ARGS__) ). The call LFS_TRACE(\"lfs_file_sync -> %d\", err); therefore expands to an empty statement (a null statement) which is executed but has no effect. Removing that statement would not change program behaviour, so it constitutes dead code under MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified lfs_file_sync code that contains useful probe functions that print useful logs to a file \"/tmp/logs/66.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of lfs_file_sync as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of lfs_file_sync:\n```c\nint lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_sync(%p, %p)\", (void*)lfs, (void*)file);\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_sync_(lfs, file);\n\n    LFS_TRACE(\"lfs_file_sync -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\nPlease provide the modified lfs_file_sync code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\n/* Minimal forward declarations to keep this compilation unit self-contained.\n   We avoid defining macros (per constraints). If any of these are provided\n   by the larger project as macros, the #ifndef guards below prevent conflicts. */\n\nstruct lfs_mlist;\ntypedef struct lfs { void *cfg; void *mlist; } lfs_t;\ntypedef struct lfs_file { void *reserved; } lfs_file_t;\n\n#ifndef LFS_LOCK\n/* If LFS_LOCK is a macro in the real project, it will shadow this prototype. */\nextern int LFS_LOCK(void *cfg);\n#endif\n\n#ifndef LFS_UNLOCK\nextern void LFS_UNLOCK(void *cfg);\n#endif\n\n#ifndef LFS_ASSERT\nextern void LFS_ASSERT(int expr);\n#endif\n\n/* The real project may define LFS_TRACE as a macro (possibly empty). We do not\n   define it here. If it is not defined by the build system, provide a prototype\n   so a function-call form will compile. If it is defined (even empty), the\n   prototype is skipped to avoid preprocessor substitution problems. */\n#ifndef LFS_TRACE\nextern int LFS_TRACE(const char *fmt, ...);\n#endif\n\n#ifndef lfs_mlist_isopen\nextern int lfs_mlist_isopen(void *mlist, struct lfs_mlist *file);\n#endif\n\n#ifndef lfs_file_sync_\nextern int lfs_file_sync_(lfs_t *lfs, lfs_file_t *file);\n#endif\n\n/* Probe logger: append human-readable control-flow and state information to\n   the required file. This preserves original behaviour (only side-effect is\n   writing additional logs) and keeps the original logic of lfs_file_sync. */\nstatic void lfs_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/66.txt\", \"a\");\n    if (f == NULL) {\n        /* best-effort: if logging fails, do not change program behaviour */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\n/* Modified lfs_file_sync with probes that log the control path and state\n   information relevant to the reported violation scenario. The original\n   logic and ordering are preserved. */\nint lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {\n    /* record entry and inputs */\n    lfs_probe_log(\"ENTER lfs_file_sync: lfs=%p file=%p\", (void*)lfs, (void*)file);\n\n    int err = LFS_LOCK(lfs->cfg);\n    lfs_probe_log(\"LFS_LOCK returned: %d\", err);\n    if (err) {\n        lfs_probe_log(\"EXIT lfs_file_sync early with err=%d (lock failure)\", err);\n        return err;\n    }\n\n    /* Log immediately before the LFS_TRACE call so observers can see whether\n       any trace output produced by LFS_TRACE appears in the logs. If the\n       project's LFS_TRACE is an empty macro, it will not produce any output,\n       and only the probe logs will be present. */\n    lfs_probe_log(\"ABOUT TO CALL LFS_TRACE for entry: lfs_file_sync(%p, %p)\", (void*)lfs, (void*)file);\n\n    /* Original trace call retained (may be a macro that expands to nothing).\n       We do not change or remove it: we only add probes around it. */\n    LFS_TRACE(\"lfs_file_sync(%p, %p)\", (void*)lfs, (void*)file);\n\n    lfs_probe_log(\"RETURN FROM LFS_TRACE (entry) -- continue with assert and sync\");\n\n    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n    lfs_probe_log(\"LFS_ASSERT passed (file reportedly open)\");\n\n    err = lfs_file_sync_(lfs, file);\n    lfs_probe_log(\"lfs_file_sync_ returned: %d\", err);\n\n    /* Second trace call retained; probe logs surrounding it capture the\n       presence or absence of LFS_TRACE output in the file. */\n    lfs_probe_log(\"ABOUT TO CALL LFS_TRACE for exit: lfs_file_sync -> %d\", err);\n    LFS_TRACE(\"lfs_file_sync -> %d\", err);\n    lfs_probe_log(\"RETURN FROM LFS_TRACE (exit)\");\n\n    LFS_UNLOCK(lfs->cfg);\n    lfs_probe_log(\"LFS_UNLOCK called; returning err=%d\", err);\n\n    return err;\n}\n"
}