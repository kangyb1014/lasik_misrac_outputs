{
  "user_message": "An agent A claimed that the following UtTest_AddSubTest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_AddSubTest.\n```c\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The UtList_Add API takes a void *Data parameter but the call passes the address of a local entry (&UtTestDataBaseEntry) which is only read to create a new list node. Because the data is used as an input/source buffer (copied) and is not modified, the pointer parameter should be const-qualified (const void *Data). As written, the pointer is not const-qualified even though it could be, so Rule 8.13 is violated. Change the prototypes (e.g. UtList_Add and UtList_NewNode) to accept const void *Data to fix the violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UtTest_Log(const char *fmt, ...)\n{\n    const char logfile[] = \"/tmp/logs/2603.txt\"; /* const-qualified to avoid accidental modification */\n    va_list ap;\n    FILE *fp = fopen(logfile, \"a\");\n    if (fp == NULL)\n    {\n        return; /* If logging fails, do not affect the tested logic */\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Log entry and input state */\n    UtTest_Log(\"Enter UtTest_AddSubTest: GroupName=\\\"%s\\\", TestName=\\\"%s\\\"\",\n               GroupName ? GroupName : \"(null)\", TestName ? TestName : \"(null)\");\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n\n    /* Count how many characters are advanced while skipping common prefix */\n    int prefixMatchCount = 0;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n        ++prefixMatchCount;\n    }\n    UtTest_Log(\"After common-prefix loop: prefixMatchCount=%d, GroupPtr char=%c (%d), TestPtr char=%c (%d)\",\n               prefixMatchCount,\n               (*GroupPtr != '\\0') ? *GroupPtr : '#', (int)(*GroupPtr),\n               (*TestPtr != '\\0') ? *TestPtr : '#', (int)(*TestPtr));\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    int backtrackSteps = 0;\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n        ++backtrackSteps;\n    }\n    UtTest_Log(\"After backtrack loop: backtrackSteps=%d, TestPtr now points to char=%c (%d), offset=%td\",\n               backtrackSteps,\n               (*TestPtr != '\\0') ? *TestPtr : '#', (int)(*TestPtr),\n               TestPtr - TestName);\n\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n        UtTest_Log(\"Underscore found; advanced TestPtr to point to char=%c (%d), offset=%td\",\n                   (*TestPtr != '\\0') ? *TestPtr : '#', (int)(*TestPtr), TestPtr - TestName);\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName; /* restore to beginning of GroupName as original logic */\n    UtTest_Log(\"Reset GroupPtr to GroupName start: GroupPtr char=%c (%d)\",\n               (*GroupPtr != '\\0') ? *GroupPtr : '#', (int)(*GroupPtr));\n\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n        UtTest_Log(\"Removed leading \\\"Test_\\\" from GroupName; GroupPtr now starts with \\\"%s\\\"\",\n                   GroupPtr ? GroupPtr : \"(null)\");\n    }\n    else\n    {\n        UtTest_Log(\"No leading \\\"Test_\\\" on GroupName\");\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n    UtTest_Log(\"CompleteTestName constructed: \\\"%s\\\" (buffer size=%zu)\", CompleteTestName, sizeof(CompleteTestName));\n\n    /* Log which callbacks are non-NULL (do not print function pointer values to avoid portability issues) */\n    UtTest_Log(\"Callbacks state: Test=%s, Setup=%s, Teardown=%s\",\n               (Test != NULL) ? \"present\" : \"NULL\",\n               (Setup != NULL) ? \"present\" : \"NULL\",\n               (Teardown != NULL) ? \"present\" : \"NULL\");\n\n    UtTest_Log(\"Calling UtTest_AddCommon with CompleteTestName=\\\"%s\\\"\", CompleteTestName);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n\n    UtTest_Log(\"Exit UtTest_AddSubTest for CompleteTestName=\\\"%s\\\"\", CompleteTestName);\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for UtTest_AddSubTest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the provided UtTest_AddSubTest code. The function already declares its input string parameters as const char * (GroupName, TestName) and uses const char * pointers (GroupPtr, TestPtr) to scan them; this already satisfies the intent of MISRA C 2023 Rule 8.13 for those inputs. The local array CompleteTestName is a writable buffer (char[128]) that is filled with snprintf \u2014 it must be non-const because it is modified. Agent A's scenario describes passing the address of a local entry to an API taking void *Data (UtList_Add / UtList_NewNode) and suggests changing those prototypes to accept const void *Data; that issue and those APIs do not appear in the UtTest_AddSubTest code shown, so the claim does not apply to this function as provided. If there is a separate API (e.g. UtTest_AddCommon or UtList_Add) that accepts a non-const pointer but does not modify the pointed-to data, then that API\u2019s prototype could be improved by using a const-qualified pointer; however, no evidence in the supplied code demonstrates such a misuse. Therefore the specific violation reported against UtTest_AddSubTest is not supported by the supplied code."
}