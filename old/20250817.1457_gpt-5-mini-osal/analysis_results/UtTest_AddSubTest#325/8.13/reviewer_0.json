{
  "user_message": "An agent A claimed that the following UtTest_AddSubTest code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_AddSubTest.\n```c\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The 'Data' parameter is declared as void * but the function does not (and should not) modify the pointee; callers (e.g. UtTest_AddCommon passing &UtTestDataBaseEntry) expect UtList_Add to copy the data rather than alter it. Therefore the parameter should be declared as const void *Data (e.g. void UtList_Add(UtListHead_t *ListHead, const void *Data, uint32 DataSize, uint32 Tag)). As written (void *Data) Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UtTest_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2603.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nvoid UtTest_AddSubTest(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *GroupName,\n                       const char *TestName)\n{\n    char        CompleteTestName[128];\n    const char *GroupPtr;\n    const char *TestPtr;\n\n    /* Save originals for logging */\n    const char *OrigGroup = GroupName;\n    const char *OrigTest  = TestName;\n\n    UtTest_LogProbe(\"ENTER UtTest_AddSubTest: GroupName=\\\"%s\\\", TestName=\\\"%s\\\", GroupName_ptr=%p, TestName_ptr=%p\",\n                    GroupName ? GroupName : \"(null)\", TestName ? TestName : \"(null)\", (const void *)GroupName, (const void *)TestName);\n\n    /* Remove any common prefix between the two names.\n     * They are often function names that all start with \"Test_XXX\"\n     * and this repetitive information just becomes clutter.\n     */\n    GroupPtr = GroupName;\n    TestPtr  = TestName;\n    while (*GroupPtr != 0 && *GroupPtr == *TestPtr)\n    {\n        ++GroupPtr;\n        ++TestPtr;\n    }\n\n    /* Log where the common prefix ended */\n    UtTest_LogProbe(\"After common-prefix strip: GroupPtr=%p, TestPtr=%p, prefix_len=%td\",\n                    (const void *)GroupPtr, (const void *)TestPtr, (ptrdiff_t)(GroupPtr - OrigGroup));\n\n    /*\n     * Only break at an underscore(_) to avoid weird effects\n     */\n    while (TestPtr > TestName && *TestPtr != '_')\n    {\n        --TestPtr;\n    }\n\n    UtTest_LogProbe(\"After searching for underscore: TestPtr=%p, char_at_TestPtr='%c', TestPtr_offset=%td\",\n                    (const void *)TestPtr,\n                    (TestPtr && *TestPtr) ? *TestPtr : '\\0',\n                    (ptrdiff_t)(TestPtr - OrigTest));\n\n    if (*TestPtr == '_')\n    {\n        ++TestPtr;\n        UtTest_LogProbe(\"Underscore found and skipped: New TestPtr=%p, New offset=%td\",\n                        (const void *)TestPtr, (ptrdiff_t)(TestPtr - OrigTest));\n    }\n\n    /*\n     * Remove a remaining \"Test_\" prefix on the group name.\n     * Again just to remove common repetitive content\n     */\n    GroupPtr = GroupName;\n    if (strncmp(GroupPtr, \"Test_\", 5) == 0)\n    {\n        GroupPtr += 5;\n        UtTest_LogProbe(\"Removed \\\"Test_\\\" prefix from GroupName: GroupPtr=%p, offset=%td\",\n                        (const void *)GroupPtr, (ptrdiff_t)(GroupPtr - OrigGroup));\n    }\n    else\n    {\n        UtTest_LogProbe(\"No \\\"Test_\\\" prefix on GroupName: GroupPtr=%p, offset=%td\",\n                        (const void *)GroupPtr, (ptrdiff_t)(GroupPtr - OrigGroup));\n    }\n\n    (void)snprintf(CompleteTestName, sizeof(CompleteTestName), \"%s.%s\", GroupPtr, TestPtr);\n\n    UtTest_LogProbe(\"CompleteTestName formed: \\\"%s\\\" (buffer_addr=%p)\", CompleteTestName, (void *)CompleteTestName);\n\n    /* Log the parameters being passed to UtTest_AddCommon for traceability */\n    UtTest_LogProbe(\"Calling UtTest_AddCommon: Test_ptr=%p, Setup_ptr=%p, Teardown_ptr=%p, CompleteTestName=\\\"%s\\\"\",\n                    (void *)Test, (void *)Setup, (void *)Teardown, CompleteTestName);\n\n    UtTest_AddCommon(Test, Setup, Teardown, CompleteTestName, UTASSERT_GROUP_TEST);\n\n    UtTest_LogProbe(\"EXIT UtTest_AddSubTest: CompleteTestName=\\\"%s\\\"\", CompleteTestName);\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for UtTest_AddSubTest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the provided UtTest_AddSubTest code. The MISRA C 2023 Rule 8.13 requires that a pointer should point to a const-qualified type whenever the function does not need to modify the pointee. In the shown function: GroupName and TestName are declared as const char * (and GroupPtr/TestPtr are also const char *), and the code only advances the pointers \u2014 it does not modify the characters they point to. The function-pointer parameters are function pointers (void (*)(void)) and are not data pointers subject to this rule. The agent's scenario refers to a 'Data' parameter and UtList_Add (declared as void *Data) which is not present in the provided UtTest_AddSubTest code; that claim therefore addresses a different function and cannot be used to show a violation in UtTest_AddSubTest. If there is a separate UtList_Add implementation taking void *Data and it does not modify the pointee, then that separate function might merit changing its parameter to const void * to satisfy Rule 8.13, but that is outside the scope of the presented code. Therefore the reported violation for UtTest_AddSubTest is false."
}