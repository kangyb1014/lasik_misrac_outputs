{
  "user_message": "An agent A claimed that the following OS_BinSemGetInfo_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGetInfo_Impl.\n```c\nint32 OS_BinSemGetInfo_Impl(const OS_object_token_t *token, OS_bin_sem_prop_t *sem_prop)\n{\n    OS_impl_binsem_internal_record_t *sem;\n\n    sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n\n    /* put the info into the structure */\n    sem_prop->value = sem->current_value;\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer is declared as a non-const: 'OS_impl_binsem_internal_record_t *sem;'. In the function it is only used to read data (sem->current_value) and is never used to modify the pointed object, so per MISRA C 2023 Rule 8.13 it should be declared as a pointer to const, e.g. 'const OS_impl_binsem_internal_record_t *sem;'. Assigning the table element (returned as a non-const pointer by OS_OBJECT_TABLE_GET) to a 'const' pointer is allowed, and the member current_value remains volatile, so qualifying the pointer as const is appropriate. Therefore the current declaration violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_BinSemGetInfo_LogProbe(const char *stage,\n                                      const OS_impl_binsem_internal_record_t *sem,\n                                      const OS_object_token_t *token,\n                                      const OS_bin_sem_prop_t *sem_prop)\n{\n    FILE *f = fopen(\"/tmp/logs/99.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging; do not alter main logic on failure */\n    }\n\n    fprintf(f, \"[OS_BinSemGetInfo_Impl] %s\\n\", stage);\n    fprintf(f, \"  token ptr = %p\\n\", (void *)token);\n    fprintf(f, \"  sem ptr   = %p\\n\", (void *)sem);\n\n    if (sem != NULL)\n    {\n        /* current_value is assumed to be an integer-like scalar; use long long to safely capture typical integer sizes */\n        fprintf(f, \"  sem->current_value = %lld\\n\", (long long)sem->current_value);\n    }\n    else\n    {\n        fprintf(f, \"  sem is NULL\\n\");\n    }\n\n    if (sem_prop != NULL)\n    {\n        fprintf(f, \"  sem_prop ptr = %p\\n\", (void *)sem_prop);\n        /* sem_prop->value mirrors sem->current_value after assignment; print if available */\n        fprintf(f, \"  sem_prop->value = %lld\\n\", (long long)sem_prop->value);\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_BinSemGetInfo_Impl(const OS_object_token_t *token, OS_bin_sem_prop_t *sem_prop)\n{\n    OS_impl_binsem_internal_record_t *sem;\n\n    /* log entry state */\n    OS_BinSemGetInfo_LogProbe(\"entry (before table lookup)\", NULL, token, sem_prop);\n\n    sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token);\n\n    /* log after lookup, before using sem */\n    OS_BinSemGetInfo_LogProbe(\"after table lookup (before reading current_value)\", sem, token, sem_prop);\n\n    /* put the info into the structure */\n    sem_prop->value = sem->current_value;\n\n    /* log after assignment to capture final state */\n    OS_BinSemGetInfo_LogProbe(\"after assignment (exit)\", sem, token, sem_prop);\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_BinSemGetInfo_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the function the local pointer sem is only used to read sem->current_value and never used to modify the pointed object, so per MISRA C 2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. const OS_impl_binsem_internal_record_t *sem;). Assigning a non-const pointer (the result of OS_OBJECT_TABLE_GET) to a pointer-to-const is allowed and safer. The only caveats that would invalidate the finding are (a) if sem is later used to modify the object (not shown here), or (b) if some macro/ABI requires sem to be a non-const pointer (which would be unusual for a local read-only use). If the struct has volatile members, those member qualifiers remain in effect; you can use const volatile if that better reflects semantics. Otherwise this is a valid MISRA 8.13 violation. "
}