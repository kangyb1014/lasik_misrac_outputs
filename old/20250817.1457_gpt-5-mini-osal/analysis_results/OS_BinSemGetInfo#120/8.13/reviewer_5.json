{
  "user_message": "An agent A claimed that the following OS_BinSemGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGetInfo.\n```c\nint32 OS_BinSemGetInfo(osal_id_t sem_id, OS_bin_sem_prop_t *bin_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(bin_prop);\n\n    memset(bin_prop, 0, sizeof(OS_bin_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_bin_sem_table, token);\n\n        strncpy(bin_prop->name, record->name_entry, sizeof(bin_prop->name) - 1);\n        bin_prop->creator = record->creator;\n        return_code       = OS_BinSemGetInfo_Impl(&token, bin_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'sem' is declared as a non-const pointer (OS_impl_binsem_internal_record_t *sem) but is only used for read access (sem->current_value). It could and should be declared as pointing to a const-qualified type (const OS_impl_binsem_internal_record_t *sem), so Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_BinSemGetInfo_Log(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/963.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    /* Write formatted message and newline */\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\nint32 OS_BinSemGetInfo(osal_id_t sem_id, OS_bin_sem_prop_t *bin_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    OS_BinSemGetInfo_Log(\"ENTER: OS_BinSemGetInfo sem_id=%ld bin_prop=%p\", (long)sem_id, (void *)bin_prop);\n\n    /* Check parameters */\n    if (bin_prop == NULL)\n    {\n        OS_BinSemGetInfo_Log(\"PARAM ERROR: bin_prop is NULL\");\n    }\n\n    OS_CHECK_POINTER(bin_prop);\n\n    memset(bin_prop, 0, sizeof(OS_bin_sem_prop_t));\n    OS_BinSemGetInfo_Log(\"After memset: bin_prop zeroed\");\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    OS_BinSemGetInfo_Log(\"OS_ObjectIdGetById returned %d, token_address=%p\", return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_bin_sem_table, token);\n        if (record == NULL)\n        {\n            OS_BinSemGetInfo_Log(\"ERROR: OS_OBJECT_TABLE_GET returned NULL record for token=%p\", (void *)&token);\n        }\n        else\n        {\n            /* Log record state observed (name and creator) before copying */\n            OS_BinSemGetInfo_Log(\"record=%p name_entry=\\\"%s\\\" creator=%u\",\n                                 (void *)record,\n                                 (record->name_entry != NULL) ? record->name_entry : \"(null)\",\n                                 (unsigned int)record->creator);\n        }\n\n        /* Preserve original logic: copy name and creator into bin_prop */\n        strncpy(bin_prop->name, record->name_entry, sizeof(bin_prop->name) - 1);\n        bin_prop->name[sizeof(bin_prop->name) - 1] = '\\0';\n        bin_prop->creator = record->creator;\n\n        OS_BinSemGetInfo_Log(\"After copy: bin_prop->name=\\\"%s\\\" bin_prop->creator=%u\",\n                             bin_prop->name, (unsigned int)bin_prop->creator);\n\n        OS_BinSemGetInfo_Log(\"Calling OS_BinSemGetInfo_Impl with token_address=%p bin_prop=%p\", (void *)&token, (void *)bin_prop);\n        return_code = OS_BinSemGetInfo_Impl(&token, bin_prop);\n        OS_BinSemGetInfo_Log(\"OS_BinSemGetInfo_Impl returned %d\", return_code);\n\n        OS_ObjectIdRelease(&token);\n        OS_BinSemGetInfo_Log(\"Released token for sem_id=%ld\", (long)sem_id);\n    }\n    else\n    {\n        OS_BinSemGetInfo_Log(\"OS_ObjectIdGetById failed for sem_id=%ld with code %d\", (long)sem_id, return_code);\n    }\n\n    OS_BinSemGetInfo_Log(\"EXIT: OS_BinSemGetInfo return_code=%d\", return_code);\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER: OS_BinSemGetInfo sem_id=3735928559 bin_prop=0x7ffd51f41200\nAfter memset: bin_prop zeroed\nOS_ObjectIdGetById returned -35, token_address=0x7ffd51f411b0\nOS_ObjectIdGetById failed for sem_id=3735928559 with code -35\nEXIT: OS_BinSemGetInfo return_code=-35\nENTER: OS_BinSemGetInfo sem_id=0 bin_prop=0x7ffd51f41200\nAfter memset: bin_prop zeroed\nOS_ObjectIdGetById returned -35, token_address=0x7ffd51f411b0\nOS_ObjectIdGetById failed for sem_id=0 with code -35\nEXIT: OS_BinSemGetInfo return_code=-35\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's report is not correct. The target function OS_BinSemGetInfo as shown does not declare any pointer named 'sem' or a type OS_impl_binsem_internal_record_t; the local pointer present is OS_common_record_t *record. The agent's scenario refers to a different identifier and type, so the claim does not match the provided code. Furthermore, in the logged runs the error path from OS_ObjectIdGetById prevents the code from reaching the point where record would be read, so the test output gives no evidence of the claimed issue. Separately, although the local 'record' pointer is only used for read access in the shown code and could be declared as const OS_common_record_t *record as a defensive improvement, the agent did not identify that symbol and provided no proof that the existing code actually modifies the pointee. Therefore the specific violation reported by agent A (about a non-const 'sem') is not supported by the supplied code and logs."
}