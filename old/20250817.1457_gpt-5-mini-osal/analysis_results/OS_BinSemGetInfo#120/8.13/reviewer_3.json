{
  "user_message": "An agent A claimed that the following OS_BinSemGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGetInfo.\n```c\nint32 OS_BinSemGetInfo(osal_id_t sem_id, OS_bin_sem_prop_t *bin_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(bin_prop);\n\n    memset(bin_prop, 0, sizeof(OS_bin_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_bin_sem_table, token);\n\n        strncpy(bin_prop->name, record->name_entry, sizeof(bin_prop->name) - 1);\n        bin_prop->creator = record->creator;\n        return_code       = OS_BinSemGetInfo_Impl(&token, bin_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In OS_BinSemGetInfo_Impl the local variable 'sem' is declared as a non-const pointer (OS_impl_binsem_internal_record_t *sem) but is assigned from OS_OBJECT_TABLE_GET(...) and only used for read-only access (sem->current_value). Per MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible (i.e. const OS_impl_binsem_internal_record_t *sem). Thus the code fragment sem = OS_OBJECT_TABLE_GET(OS_impl_bin_sem_table, *token); results in a non-const pointer where a const-qualified pointer would be appropriate, violating Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_BinSemGetInfo_Log(const char *stage,\n                                 unsigned long long sem_id_val,\n                                 const void *record_ptr,\n                                 const char *record_name,\n                                 unsigned int record_creator,\n                                 const void *token_ptr,\n                                 int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/963.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t t = time(NULL);\n        fprintf(f, \"[%ld] stage=%s sem_id=%llu token_ptr=%p record_ptr=%p return_code=%d\\n\",\n                (long)t, stage, sem_id_val, token_ptr, record_ptr, return_code);\n        if (record_name != NULL)\n        {\n            /* record_name is printed safely as a C-string previously used by the system */\n            fprintf(f, \"    record->name_entry=\\\"%s\\\" record->creator=%u\\n\",\n                    record_name, record_creator);\n        }\n        fclose(f);\n    }\n}\n\nint32 OS_BinSemGetInfo(osal_id_t sem_id, OS_bin_sem_prop_t *bin_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(bin_prop);\n\n    /* Log start state */\n    OS_BinSemGetInfo_Log(\"start\", (unsigned long long)sem_id, NULL, NULL, 0, &token, 0);\n\n    memset(bin_prop, 0, sizeof(OS_bin_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log result of ObjectIdGetById */\n    OS_BinSemGetInfo_Log(\"after_ObjectIdGetById\", (unsigned long long)sem_id, NULL, NULL, 0, &token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_bin_sem_table, token);\n\n        /* Log the record pointer and some of its fields (name_entry and creator) */\n        OS_BinSemGetInfo_Log(\"after_OBJECT_TABLE_GET\",\n                             (unsigned long long)sem_id,\n                             (const void *)record,\n                             record ? record->name_entry : NULL,\n                             record ? (unsigned int)record->creator : 0u,\n                             &token,\n                             return_code);\n\n        strncpy(bin_prop->name, record->name_entry, sizeof(bin_prop->name) - 1);\n        bin_prop->creator = record->creator;\n\n        /* Log before calling the implementation helper */\n        OS_BinSemGetInfo_Log(\"before_ImplCall\",\n                             (unsigned long long)sem_id,\n                             (const void *)record,\n                             record ? record->name_entry : NULL,\n                             record ? (unsigned int)record->creator : 0u,\n                             &token,\n                             return_code);\n\n        return_code       = OS_BinSemGetInfo_Impl(&token, bin_prop);\n\n        /* Log after Impl call and before releasing token */\n        OS_BinSemGetInfo_Log(\"after_ImplCall\",\n                             (unsigned long long)sem_id,\n                             (const void *)record,\n                             record ? record->name_entry : NULL,\n                             record ? (unsigned int)record->creator : 0u,\n                             &token,\n                             return_code);\n\n        OS_ObjectIdRelease(&token);\n\n        /* Final log: token released */\n        OS_BinSemGetInfo_Log(\"end\", (unsigned long long)sem_id, (const void *)record,\n                             record ? record->name_entry : NULL,\n                             record ? (unsigned int)record->creator : 0u,\n                             &token,\n                             return_code);\n    }\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[1755443792] stage=start sem_id=3735928559 token_ptr=0x7ffc55b0a330 record_ptr=(nil) return_code=0\n[1755443792] stage=after_ObjectIdGetById sem_id=3735928559 token_ptr=0x7ffc55b0a330 record_ptr=(nil) return_code=-35\n[1755443792] stage=start sem_id=0 token_ptr=0x7ffc55b0a330 record_ptr=(nil) return_code=0\n[1755443792] stage=after_ObjectIdGetById sem_id=0 token_ptr=0x7ffc55b0a330 record_ptr=(nil) return_code=-35\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A claims a Rule 8.13 violation inside OS_BinSemGetInfo_Impl (a local pointer 'sem' declared non-const while only used for read-only access). The provided test logs, however, show that OS_ObjectIdGetById failed (return_code = -35) and the record pointer printed is NULL, so the code never proceeded to the branch that would obtain the record or call the implementation helper. Therefore the test evidence does not exercise or demonstrate the alleged non-const read-only usage and does not support the claimed violation. Based on the supplied test output and the requirement to accept it as exhaustive, the report is not correct."
}