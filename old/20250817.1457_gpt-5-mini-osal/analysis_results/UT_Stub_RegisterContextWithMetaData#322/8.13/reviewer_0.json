{
  "user_message": "An agent A claimed that the following UT_Stub_RegisterContextWithMetaData code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_RegisterContextWithMetaData.\n```c\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignment stores a const void * (ParamPtr) into ArgPtr[] which is likely a non-const pointer (e.g. void *ArgPtr[...]). This discards the const qualifier on the pointee. Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so ArgPtr elements should be declared as const void * to preserve the const qualification.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /* Open log file for probe output - append so multiple calls accumulate */\n    {\n        FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n        if (log != NULL)\n        {\n            /* Log function entry and key parameters */\n            fprintf(log, \"UT_Stub_RegisterContextWithMetaData entry: FuncKey=%lu, Name=%p, ParamType=%d, ParamPtr=%p, ParamSize=%zu\\n\",\n                    (unsigned long)FuncKey, (const void *)Name, (int)ParamType, (const void *)ParamPtr, ParamSize);\n            fclose(log);\n        }\n    }\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        /* Log the abort condition for repro */\n        {\n            FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"UT_Stub_RegisterContextWithMetaData: No StubPtr found for FuncKey=%lu - aborting\\n\", (unsigned long)FuncKey);\n                fclose(log);\n            }\n        }\n\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            /* Probe: log the target index and pointer to be stored (captures potential const discard) */\n            {\n                unsigned int idx = StubPtr->Data.Context.ArgCount;\n                FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"About to assign ParamPtr=%p to StubPtr->Data.Context.ArgPtr[%u] (ArgCount=%u)\\n\",\n                            (const void *)ParamPtr, idx, idx);\n                    fclose(log);\n                }\n            }\n\n            /* The assignment that is the subject of the reported violation */\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            /* Log after assignment to capture that the pointer value was stored into the (likely non-const) array element */\n            {\n                unsigned int idx = StubPtr->Data.Context.ArgCount;\n                FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"Performed assignment: StubPtr->Data.Context.ArgPtr[%u] == %p\\n\",\n                            idx, (const void *)StubPtr->Data.Context.ArgPtr[idx]);\n                    fclose(log);\n                }\n            }\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /* Log metadata after setting size and type */\n            {\n                unsigned int idx = StubPtr->Data.Context.ArgCount;\n                FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"Meta for index %u: Size=%zu, Type=%d, Name(ptr)=%p\\n\",\n                            idx, MetaPtr->Size, (int)MetaPtr->Type, (const void *)MetaPtr->Name);\n                    fclose(log);\n                }\n            }\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n\n                /* Log original name string */\n                {\n                    FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                    if (log != NULL)\n                    {\n                        fprintf(log, \"Name processing start: original Name=\");\n                        /* print as string but handle non-null safely */\n                        if (Name[0] != '\\0')\n                        {\n                            fprintf(log, \"%s\", Name);\n                        }\n                        else\n                        {\n                            fprintf(log, \"(empty)\");\n                        }\n                        fprintf(log, \"\\n\");\n                        fclose(log);\n                    }\n                }\n\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n\n                        /* Log detection of '&' */\n                        {\n                            FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                            if (log != NULL)\n                            {\n                                fprintf(log, \"Detected leading '&' in Name; marking Type=INDIRECT\\n\");\n                                fclose(log);\n                            }\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n\n                    /* Log defaulting to DIRECT */\n                    {\n                        FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                        if (log != NULL)\n                        {\n                            fprintf(log, \"No '&' found and not specified: setting Type=DIRECT\\n\");\n                            fclose(log);\n                        }\n                    }\n                }\n\n                /* Log the final Name pointer and the first few characters after trimming */\n                {\n                    FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                    if (log != NULL)\n                    {\n                        fprintf(log, \"Final MetaPtr->Name ptr=%p\", (const void *)MetaPtr->Name);\n                        if (*MetaPtr->Name != '\\0')\n                        {\n                            fprintf(log, \", starts with: '%c'\\n\", *MetaPtr->Name);\n                        }\n                        else\n                        {\n                            fprintf(log, \", (empty)\\n\");\n                        }\n                        fclose(log);\n                    }\n                }\n            }\n\n            ++StubPtr->Data.Context.ArgCount;\n\n            /* Log final ArgCount */\n            {\n                FILE *log = fopen(\"/tmp/logs/2579.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"ArgCount incremented to %u\\n\", StubPtr->Data.Context.ArgCount);\n                    fclose(log);\n                }\n            }\n        }\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4de, ParamType=2, ParamPtr=0x7ffcfb09fd4c, ParamSize=4\nAbout to assign ParamPtr=0x7ffcfb09fd4c to StubPtr->Data.Context.ArgPtr[0] (ArgCount=0)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[0] == 0x7ffcfb09fd4c\nMeta for index 0: Size=4, Type=2, Name(ptr)=(nil)\nName processing start: original Name=milli_seconds\nFinal MetaPtr->Name ptr=0x55d38815c4de, starts with: 'm'\nArgCount incremented to 1\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4ec, ParamType=2, ParamPtr=0x7ffcfb09fd40, ParamSize=8\nAbout to assign ParamPtr=0x7ffcfb09fd40 to StubPtr->Data.Context.ArgPtr[1] (ArgCount=1)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[1] == 0x7ffcfb09fd40\nMeta for index 1: Size=8, Type=2, Name(ptr)=(nil)\nName processing start: original Name=ticks\nFinal MetaPtr->Name ptr=0x55d38815c4ec, starts with: 't'\nArgCount incremented to 2\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4de, ParamType=2, ParamPtr=0x7ffcfb09fd4c, ParamSize=4\nAbout to assign ParamPtr=0x7ffcfb09fd4c to StubPtr->Data.Context.ArgPtr[0] (ArgCount=0)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[0] == 0x7ffcfb09fd4c\nMeta for index 0: Size=4, Type=2, Name(ptr)=(nil)\nName processing start: original Name=milli_seconds\nFinal MetaPtr->Name ptr=0x55d38815c4de, starts with: 'm'\nArgCount incremented to 1\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4ec, ParamType=2, ParamPtr=0x7ffcfb09fd40, ParamSize=8\nAbout to assign ParamPtr=0x7ffcfb09fd40 to StubPtr->Data.Context.ArgPtr[1] (ArgCount=1)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[1] == 0x7ffcfb09fd40\nMeta for index 1: Size=8, Type=2, Name(ptr)=(nil)\nName processing start: original Name=ticks\nFinal MetaPtr->Name ptr=0x55d38815c4ec, starts with: 't'\nArgCount incremented to 2\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4de, ParamType=2, ParamPtr=0x7ffcfb09fd4c, ParamSize=4\nAbout to assign ParamPtr=0x7ffcfb09fd4c to StubPtr->Data.Context.ArgPtr[0] (ArgCount=0)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[0] == 0x7ffcfb09fd4c\nMeta for index 0: Size=4, Type=2, Name(ptr)=(nil)\nName processing start: original Name=milli_seconds\nFinal MetaPtr->Name ptr=0x55d38815c4de, starts with: 'm'\nArgCount incremented to 1\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94367009541696, Name=0x55d38815c4ec, ParamType=2, ParamPtr=0x7ffcfb09fd40, ParamSize=8\nAbout to assign ParamPtr=0x7ffcfb09fd40 to StubPtr->Data.Context.ArgPtr[1] (ArgCount=1)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[1] == 0x7ffcfb09fd40\nMeta for index 1: Size=8, Type=2, Name(ptr)=(nil)\nName processing start: original Name=ticks\nFinal MetaPtr->Name ptr=0x55d38815c4ec, starts with: 't'\nArgCount incremented to 2\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94411864819071, Name=0x55ddf9ab2506, ParamType=2, ParamPtr=0x7fffa42aabcc, ParamSize=4\nAbout to assign ParamPtr=0x7fffa42aabcc to StubPtr->Data.Context.ArgPtr[0] (ArgCount=0)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[0] == 0x7fffa42aabcc\nMeta for index 0: Size=4, Type=2, Name(ptr)=(nil)\nName processing start: original Name=lock_mode\nFinal MetaPtr->Name ptr=0x55ddf9ab2506, starts with: 'l'\nArgCount incremented to 1\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94411864819071, Name=0x55ddf9ab23b7, ParamType=2, ParamPtr=0x7fffa42aabc8, ParamSize=4\nAbout to assign ParamPtr=0x7fffa42aabc8 to StubPtr->Data.Context.ArgPtr[1] (ArgCount=1)\nPerformed assignment: StubPtr->Data.Context.ArgPtr[1] == 0x7fffa42aabc8\nMeta for index 1: Size=4, Type=2, Name(ptr)=(nil)\nName processing start: original Name=idtype\nFinal MetaPtr->Name ptr=0x55ddf9ab23b7, starts with: 'i'\nArgCount incremented to 2\nUT_Stub_RegisterContextWithMetaData entry: FuncKey=94411864819071, Name=0x55ddf9ab2510, ParamType=2, ParamPtr=0x7fffa42aabc4, ParamSize=4\nAbout to assign ParamPtr=0x7fffa42aabc4 to StubPtr->Data.Context.ArgPtr[2] (ArgCount=2)\nPerformed assignment: StubPtr->Data.Context.ArgPt\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is incorrect. The function parameter ParamPtr is declared as const void * and the code assigns it to StubPtr->Data.Context.ArgPtr[...] without any cast. If ArgPtr were a non-const void * this assignment would discard the const qualifier and require an explicit cast (and the compiler would normally emit a diagnostic). Because the assignment is performed directly (and the test output shows the pointer values being stored without casts or diagnostics), the only consistent interpretation is that ArgPtr is declared as const void * (so no const is discarded). Similarly, Name is passed as const char * and stored/used via MetaPtr->Name without casts, implying MetaPtr->Name is const char *. Therefore Rule 8.13 (prefer pointers to point to const-qualified types when possible) is not violated here \u2014 the code already preserves const qualification."
}