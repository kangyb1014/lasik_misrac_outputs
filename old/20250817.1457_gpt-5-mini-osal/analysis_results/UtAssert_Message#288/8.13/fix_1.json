{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef unsigned char uint8;\ntypedef unsigned int  uint32;\nvoid UT_BSP_DoText(uint8 MessageType, const char *Text)\n{\n    /* Preserve original observable behavior by printing to stdout. */\n    if (Text != NULL)\n    {\n        (void)printf(\"UT_BSP_DoText (%u): %s\\n\", (unsigned int)MessageType, Text);\n    }\n}\nstatic void UtAssert_Message_Log(uint8 MessageType,\n                                const char *File,\n                                uint32 Line,\n                                const char *Spec,\n                                const char *BaseName,\n                                size_t MsgLen,\n                                const char *FinalMessage)\n{\n    FILE *fp = fopen(\"/tmp/logs/2307.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails, do not alter program flow; just return. */\n        return;\n    }\n\n    (void)fprintf(fp, \"--- UtAssert_Message probe ---\\n\");\n    (void)fprintf(fp, \"MessageType: %u\\n\", (unsigned int)MessageType);\n    (void)fprintf(fp, \"File ptr: %p\\n\", (const void *)File);\n    (void)fprintf(fp, \"File str: %s\\n\", (File != NULL) ? File : \"(null)\");\n    (void)fprintf(fp, \"Line: %u\\n\", (unsigned int)Line);\n    (void)fprintf(fp, \"Spec ptr: %p\\n\", (const void *)Spec);\n    (void)fprintf(fp, \"Spec str: %s\\n\", (Spec != NULL) ? Spec : \"(null)\");\n    (void)fprintf(fp, \"BaseName ptr: %p\\n\", (const void *)BaseName);\n    (void)fprintf(fp, \"BaseName str: %s\\n\", (BaseName != NULL) ? BaseName : \"(null)\");\n    (void)fprintf(fp, \"MsgLen: %zu\\n\", MsgLen);\n    (void)fprintf(fp, \"FinalMessage (len %zu): %s\\n\", strlen(FinalMessage), FinalMessage);\n\n    /* Additional contextual note: this probe logs the pointers and strings that\n       can help other agents infer whether string data might be immutable (e.g.,\n       string literals) by examining pointer addresses and content. */\n    (void)fprintf(fp, \"--- end probe ---\\n\\n\");\n\n    (void)fclose(fp);\n}\n\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n        BaseName = NULL;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    /* Insert probe logging here so the composed message and relevant state are\n       recorded for later inspection without changing the original behavior. */\n    UtAssert_Message_Log(MessageType, File, Line, Spec, BaseName, MsgLen, FinalMessage);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/usr/bin/ld: ../../ut_assert/libut_assert.a(utbsp.c.o): in function `UT_BSP_DoText':\n/tmp/tmpeq9fzb0h/src/ut_assert/src/utbsp.c:116: multiple definition of `UT_BSP_DoText'; ../../ut_assert/libut_assert.a(utassert.c.o):/tmp/tmpeq9fzb0h/src/ut_assert/src/utassert.c:311: first defined here\ncollect2: error: ld returned 1 exit status\ngmake[2]: *** [unit-test-coverage/vxworks/CMakeFiles/coverage-vxworks-binsem-testrunner.dir/build.make:111: unit-test-coverage/vxworks/coverage-vxworks-binsem-testrunner] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:1170: unit-test-coverage/vxworks/CMakeFiles/coverage-vxworks-binsem-testrunner.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UtAssert_Message as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stddef.h>\n\ntypedef unsigned char uint8;\ntypedef unsigned int  uint32;\n\n/* Make this static to avoid multiple-definition at link time when the\n   same symbol exists in other translation units (e.g. libut_assert). */\nstatic void UT_BSP_DoText(uint8 MessageType, const char *Text)\n{\n    /* Preserve original observable behavior by printing to stdout. */\n    if (Text != NULL)\n    {\n        (void)printf(\"UT_BSP_DoText (%u): %s\\n\", (unsigned int)MessageType, Text);\n    }\n}\n\nstatic void UtAssert_Message_Log(uint8 MessageType,\n                                const char *File,\n                                uint32 Line,\n                                const char *Spec,\n                                const char *BaseName,\n                                size_t MsgLen,\n                                const char *FinalMessage)\n{\n    FILE *fp = fopen(\"/tmp/logs/2307.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails, do not alter program flow; just return. */\n        return;\n    }\n\n    (void)fprintf(fp, \"--- UtAssert_Message probe ---\\n\");\n    (void)fprintf(fp, \"MessageType: %u\\n\", (unsigned int)MessageType);\n    (void)fprintf(fp, \"File ptr: %p\\n\", (const void *)File);\n    (void)fprintf(fp, \"File str: %s\\n\", (File != NULL) ? File : \"(null)\");\n    (void)fprintf(fp, \"Line: %u\\n\", (unsigned int)Line);\n    (void)fprintf(fp, \"Spec ptr: %p\\n\", (const void *)Spec);\n    (void)fprintf(fp, \"Spec str: %s\\n\", (Spec != NULL) ? Spec : \"(null)\");\n    (void)fprintf(fp, \"BaseName ptr: %p\\n\", (const void *)BaseName);\n    (void)fprintf(fp, \"BaseName str: %s\\n\", (BaseName != NULL) ? BaseName : \"(null)\");\n    (void)fprintf(fp, \"MsgLen: %zu\\n\", MsgLen);\n    (void)fprintf(fp, \"FinalMessage (len %zu): %s\\n\", strlen(FinalMessage), FinalMessage);\n\n    /* Additional contextual note: this probe logs the pointers and strings that\n       can help other agents infer whether string data might be immutable (e.g.,\n       string literals) by examining pointer addresses and content. */\n    (void)fprintf(fp, \"--- end probe ---\\n\\n\");\n\n    (void)fclose(fp);\n}\n\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n        BaseName = NULL;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    /* Insert probe logging here so the composed message and relevant state are\n       recorded for later inspection without changing the original behavior. */\n    UtAssert_Message_Log(MessageType, File, Line, Spec, BaseName, MsgLen, FinalMessage);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n",
  "explanation": "The link error was caused by a duplicate global symbol UT_BSP_DoText already defined in another object/library. I changed UT_BSP_DoText to have internal linkage by making it static so it won't collide at link time. I also added the necessary includes (stdio.h, stdarg.h, string.h, stddef.h) so the code compiles cleanly. The original logic of UtAssert_Message was preserved."
}