{
  "user_message": "An agent A claimed that the following UtAssert_Message code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_Message.\n```c\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If UtAssert_GetCaseTypeAbbrev has the signature 'char *UtAssert_GetCaseTypeAbbrev(uint8)' (i.e. returns a non-const pointer) while it actually returns pointers to string literals or other immutable data, then Rule 8.13 is violated: the pointer should be declared 'const char *'. If, however, UtAssert_GetCaseTypeAbbrev is declared to return 'const char *', there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned char uint8;\ntypedef unsigned int  uint32;\nstatic void UT_BSP_DoText(uint8 MessageType, const char *Text)\n{\n    /* Preserve original observable behavior by printing to stdout. */\n    if (Text != NULL)\n    {\n        (void)printf(\"UT_BSP_DoText (%u): %s\\n\", (unsigned int)MessageType, Text);\n    }\n}\nstatic void UtAssert_Message_Log(uint8 MessageType,\n                                const char *File,\n                                uint32 Line,\n                                const char *Spec,\n                                const char *BaseName,\n                                size_t MsgLen,\n                                const char *FinalMessage)\n{\n    FILE *fp = fopen(\"/tmp/logs/2307.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails, do not alter program flow; just return. */\n        return;\n    }\n\n    (void)fprintf(fp, \"--- UtAssert_Message probe ---\\n\");\n    (void)fprintf(fp, \"MessageType: %u\\n\", (unsigned int)MessageType);\n    (void)fprintf(fp, \"File ptr: %p\\n\", (const void *)File);\n    (void)fprintf(fp, \"File str: %s\\n\", (File != NULL) ? File : \"(null)\");\n    (void)fprintf(fp, \"Line: %u\\n\", (unsigned int)Line);\n    (void)fprintf(fp, \"Spec ptr: %p\\n\", (const void *)Spec);\n    (void)fprintf(fp, \"Spec str: %s\\n\", (Spec != NULL) ? Spec : \"(null)\");\n    (void)fprintf(fp, \"BaseName ptr: %p\\n\", (const void *)BaseName);\n    (void)fprintf(fp, \"BaseName str: %s\\n\", (BaseName != NULL) ? BaseName : \"(null)\");\n    (void)fprintf(fp, \"MsgLen: %zu\\n\", MsgLen);\n    (void)fprintf(fp, \"FinalMessage (len %zu): %s\\n\", strlen(FinalMessage), FinalMessage);\n\n    /* Additional contextual note: this probe logs the pointers and strings that\n       can help other agents infer whether string data might be immutable (e.g.,\n       string literals) by examining pointer addresses and content. */\n    (void)fprintf(fp, \"--- end probe ---\\n\\n\");\n\n    (void)fclose(fp);\n}\n\nvoid UtAssert_Message(uint8 MessageType, const char *File, uint32 Line, const char *Spec, ...)\n{\n    va_list     va;\n    char        FinalMessage[256];\n    const char *BaseName;\n    size_t      MsgLen;\n\n    if (File != NULL)\n    {\n        BaseName = strrchr(File, '/');\n        if (BaseName == NULL)\n        {\n            BaseName = File;\n        }\n        else\n        {\n            ++BaseName;\n        }\n        snprintf(FinalMessage, sizeof(FinalMessage), \"%s:%u:\", BaseName, (unsigned int)Line);\n        MsgLen = strlen(FinalMessage);\n    }\n    else\n    {\n        MsgLen = 0;\n        BaseName = NULL;\n    }\n\n    va_start(va, Spec);\n    vsnprintf(&FinalMessage[MsgLen], sizeof(FinalMessage) - MsgLen, Spec, va);\n    va_end(va);\n\n    /* Insert probe logging here so the composed message and relevant state are\n       recorded for later inspection without changing the original behavior. */\n    UtAssert_Message_Log(MessageType, File, Line, Spec, BaseName, MsgLen, FinalMessage);\n\n    UT_BSP_DoText(MessageType, FinalMessage);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the presented UtAssert_Message code. In the shown function all character pointers that refer to input or literal text are declared as const char * (File, Spec, BaseName) and UT_BSP_DoText expects a const char *; the local buffer FinalMessage is a char array as it should be. The use of strrchr (which in the C library returns char *) and assigning its result to const char *BaseName is permissible and is actually the const-correct choice here. The agent\u2019s scenario describes a different function (UtAssert_GetCaseTypeAbbrev) returning char * while actually producing pointers to immutable data; if such a function exists elsewhere and returns a non-const pointer to string literals, that function\u2019s declaration would indeed violate MISRA C:2023 Rule 8.13. However, no such function or call appears in the provided UtAssert_Message code, so the claim that UtAssert_Message itself violates Rule 8.13 is incorrect. (The test probe code failing to compile also means no runtime evidence was produced.)"
}