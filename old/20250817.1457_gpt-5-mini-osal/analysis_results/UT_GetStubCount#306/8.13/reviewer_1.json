{
  "user_message": "An agent A claimed that the following UT_GetStubCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubCount.\n```c\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        Count = StubPtr->Data.Rc.Count;\n    }\n    else\n    {\n        Count = 0;\n    }\n\n    return Count;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer is used only for read access (StubPtr->Data.Rc.Count) and the function does not modify the pointed-to object, yet it is declared as a non-const pointer: UT_StubTableEntry_t *StubPtr;. According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type when possible (for example: const UT_StubTableEntry_t *StubPtr;), so this declaration violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogStubCount(UT_EntryKey_t FuncKey, const UT_StubTableEntry_t *StubPtr, uint32 Count)\n{\n    FILE *fp = fopen(\"/tmp/logs/2451.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* best-effort logging, do not affect original behavior */\n    }\n\n    /* Log entry and key */\n    fprintf(fp, \"UT_GetStubCount: FuncKey=%llu\\n\", (unsigned long long)FuncKey);\n\n    if (StubPtr != NULL)\n    {\n        /* Log pointer address and observed counts. Do not modify StubPtr. */\n        fprintf(fp, \"  StubPtr=%p\\n\", (void *)StubPtr);\n        fprintf(fp, \"  Observed Count (returned)=%llu\\n\", (unsigned long long)Count);\n        fprintf(fp, \"  Underlying Stub Data Rc.Count=%llu\\n\", (unsigned long long)StubPtr->Data.Rc.Count);\n    }\n    else\n    {\n        fprintf(fp, \"  StubPtr=NULL\\n\");\n        fprintf(fp, \"  Observed Count (returned)=%llu\\n\", (unsigned long long)Count);\n    }\n\n    fclose(fp);\n}\n\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        Count = StubPtr->Data.Rc.Count;\n    }\n    else\n    {\n        Count = 0;\n    }\n\n    /* Log the control path and the relevant state for reproducing the violation scenario */\n    UT_LogStubCount(FuncKey, StubPtr, Count);\n\n    return Count;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_GetStubCount: FuncKey=93985740416807\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=93985740416807\n  StubPtr=0x557ac2ad7100\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=93985740415631\n  StubPtr=0x557ac2ad8540\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94899049767353\n  StubPtr=0x564f682833e0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94899049767353\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=94899049767353\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=94748081579849\n  StubPtr=0x562c41c026e0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94748081579849\n  StubPtr=0x562c41c026e0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94748081579946\n  StubPtr=0x562c41c09400\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94748081579946\n  StubPtr=0x562c41c09400\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94612902223215\n  StubPtr=0x560cc86fb800\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94496514117777\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=94496514121475\n  StubPtr=0x55f1af2ad300\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94496514121741\n  StubPtr=0x55f1af2a3e80\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94496514117777\n  StubPtr=NULL\n  Observed Count (returned)=0\nUT_GetStubCount: FuncKey=94496514121475\n  StubPtr=0x55f1af2ad300\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94496514121741\n  StubPtr=0x55f1af2a3e80\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=3\n  Underlying Stub Data Rc.Count=3\nUT_GetStubCount: FuncKey=94496514117777\n  StubPtr=0x55f1af2a51a0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94496514121475\n  StubPtr=0x55f1af2ad300\n  Observed Count (returned)=3\n  Underlying Stub Data Rc.Count=3\nUT_GetStubCount: FuncKey=94496514121741\n  StubPtr=0x55f1af2a3e80\n  Observed Count (returned)=3\n  Underlying Stub Data Rc.Count=3\nUT_GetStubCount: FuncKey=94496514116917\n  StubPtr=0x55f1af2aeaa0\n  Observed Count (returned)=3\n  Underlying Stub Data Rc.Count=3\nUT_GetStubCount: FuncKey=94496514115788\n  StubPtr=0x55f1af2a51a0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=93893298624500\n  StubPtr=0x55653cb803a0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=93893298624500\n  StubPtr=0x55653cb803a0\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94397552264327\n  StubPtr=0x55daa4937000\n  Observed Count (returned)=1\n  Underlying Stub Data Rc.Count=1\nUT_GetStubCount: FuncKey=94148336174928\n  StubPtr=0x55a09e23d440\n  Observed Count (returned)=3\n  Underlying Stub Data Rc.Count=3\nUT_GetStubCount: FuncKey=94148336175954\n  StubPtr=0x55a09e23f600\n  Observed Count (returned)=2\n  Underlying Stub Data Rc.Count=2\nUT_GetStubCount: FuncKey=94148336174928\n  StubPtr=0x55a09e23d440\n  Observed Count (returned)=6\n  Underl\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In UT_GetStubCount the local pointer StubPtr is only used to read the pointed-to object (StubPtr->Data.Rc.Count) and no modification is performed through it. Therefore it can and should be declared to point to a const-qualified type (e.g. const UT_StubTableEntry_t *StubPtr;). Assigning the non-const return of UT_GetStubEntry to a const-qualified pointer is permitted without a cast, so there is no impediment to making this change. The provided runtime logs show only read accesses (returned Count equals the underlying Rc.Count), which confirms the pointer is not being used for modification; thus Agent A\u2019s report that this violates MISRA C 2023 Rule 8.13 is correct."
}