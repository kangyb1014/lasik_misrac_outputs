{
  "user_message": "An agent A claimed that the following UT_GetStubCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubCount.\n```c\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        Count = StubPtr->Data.Rc.Count;\n    }\n    else\n    {\n        Count = 0;\n    }\n\n    return Count;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer StubPtr is declared as UT_StubTableEntry_t * but in this function it is only used for read access (Count = StubPtr->Data.Rc.Count;). According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible. Declaring it as const UT_StubTableEntry_t *StubPtr (and allowing assignment from UT_GetStubEntry) would satisfy the rule. This change is only inappropriate if StubPtr is later used to modify the pointed-to object; given the shown fragment it is not, so the current non-const declaration violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n    FILE *log = NULL;\n\n    /* Preserve original logic: obtain the stub entry */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n\n    /* Attempt to open the log file; if the directory does not exist try to create it */\n    log = fopen(\"/tmp/logs/2451.txt\", \"a\");\n    if (log == NULL)\n    {\n        if ((mkdir(\"/tmp/logs\", 0777) == 0) || (errno == EEXIST))\n        {\n            log = fopen(\"/tmp/logs/2451.txt\", \"a\");\n        }\n    }\n\n    if (StubPtr != NULL)\n    {\n        /* Read the count from the stub as in original implementation */\n        Count = StubPtr->Data.Rc.Count;\n\n        /* Log the control path and relevant state for reproduction of the violation scenario */\n        if (log != NULL)\n        {\n            /* Log function key, pointer value, and the read-only access to the count */\n            fprintf(log, \"UT_GetStubCount: FuncKey=%lu, StubPtr=%p, Read Count=%u\\n\",\n                    (unsigned long)FuncKey,\n                    (void *)StubPtr,\n                    (unsigned)Count);\n            fclose(log);\n        }\n    }\n    else\n    {\n        Count = 0u;\n\n        /* Log the NULL path */\n        if (log != NULL)\n        {\n            fprintf(log, \"UT_GetStubCount: FuncKey=%lu, StubPtr=NULL, Count=0\\n\",\n                    (unsigned long)FuncKey);\n            fclose(log);\n        }\n    }\n\n    return Count;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_GetStubCount: FuncKey=94131115296551, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94131115296551, StubPtr=0x559c9bb1f800, Read Count=1\nUT_GetStubCount: FuncKey=94131115295375, StubPtr=0x559c9bb20c40, Read Count=1\nUT_GetStubCount: FuncKey=94280375898553, StubPtr=0x55bf5c528460, Read Count=1\nUT_GetStubCount: FuncKey=94280375898553, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94280375898553, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94092694341449, StubPtr=0x5593a9a06da0, Read Count=1\nUT_GetStubCount: FuncKey=94092694341449, StubPtr=0x5593a9a06da0, Read Count=1\nUT_GetStubCount: FuncKey=94092694341546, StubPtr=0x5593a9a0dac0, Read Count=1\nUT_GetStubCount: FuncKey=94092694341546, StubPtr=0x5593a9a0dac0, Read Count=1\nUT_GetStubCount: FuncKey=94449647369583, StubPtr=0x55e6c5b06d20, Read Count=1\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=1\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=2\nUT_GetStubCount: FuncKey=94861353394321, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94861353398019, StubPtr=0x5646a14822a0, Read Count=1\nUT_GetStubCount: FuncKey=94861353398285, StubPtr=0x5646a1486e00, Read Count=1\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=2\nUT_GetStubCount: FuncKey=94861353394321, StubPtr=NULL, Count=0\nUT_GetStubCount: FuncKey=94861353398019, StubPtr=0x5646a14822a0, Read Count=2\nUT_GetStubCount: FuncKey=94861353398285, StubPtr=0x5646a1486e00, Read Count=2\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=2\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=3\nUT_GetStubCount: FuncKey=94861353394321, StubPtr=0x5646a1488120, Read Count=1\nUT_GetStubCount: FuncKey=94861353398019, StubPtr=0x5646a14822a0, Read Count=3\nUT_GetStubCount: FuncKey=94861353398285, StubPtr=0x5646a1486e00, Read Count=3\nUT_GetStubCount: FuncKey=94861353393461, StubPtr=0x5646a1483a40, Read Count=3\nUT_GetStubCount: FuncKey=94861353392332, StubPtr=0x5646a1488120, Read Count=1\nUT_GetStubCount: FuncKey=94652294318068, StubPtr=0x5615f462ac60, Read Count=1\nUT_GetStubCount: FuncKey=94652294318068, StubPtr=0x5615f462ac60, Read Count=1\nUT_GetStubCount: FuncKey=94555572089991, StubPtr=0x55ff6f4b3c20, Read Count=1\nUT_GetStubCount: FuncKey=94479702546256, StubPtr=0x55edc51d45a0, Read Count=3\nUT_GetStubCount: FuncKey=94479702547282, StubPtr=0x55edc51d6760, Read Count=2\nUT_GetStubCount: FuncKey=94479702546256, StubPtr=0x55edc51d45a0, Read Count=6\nUT_GetStubCount: FuncKey=94479702547282, StubPtr=0x55edc51d6760, Read Count=3\nUT_GetStubCount: FuncKey=94811875290617, StubPtr=0x563b1c27e880, Read Count=1\nUT_GetStubCount: FuncKey=94811875290617, StubPtr=0x563b1c27e880, Read Count=2\nUT_GetStubCount: FuncKey=94811875290617, StubPtr=0x563b1c27e760, Read Count=2\nUT_GetStubCount: FuncKey=94423929580591, StubPtr=0x55e0c8c9c2e0, Read Count=1\nUT_GetStubCount: FuncKey=94287145430323, StubPtr=0x55c0efd1e120, Read Count=1\nUT_GetStubCount: FuncKey=94287145425648, StubPtr=0x55c0efd252c0, Read Count=1\nUT_GetStubCount: FuncKey=94287145400556, StubPtr=0x55c0efd23e80, Read Count=1\nUT_GetStubCount: FuncKey=94287145394428, StubPtr=0x55c0efd26ca0, Read Count=1\nUT_GetStubCount: FuncKey=94287145421261, StubPtr=0x55c0efd248a0, Read Count=1\nUT_GetStubCount: FuncKey=94287145408268, StubPtr=0x55c0efd20760, Read Count=1\nUT_GetStubCount: FuncKey=94287145403350, StubPtr=0x55c0efd24780, Read Count=1\nUT_GetStubCount: FuncKey=94287145437938, StubPtr=0x55c0efd21cc0, Read Count=1\nUT_GetStubCount: FuncKey=94287145434962, StubPtr=0x55c0efd226e0, Read Count=1\nUT_GetStubCount: FuncKey=94287145418554, StubPtr=0x55c0efd1c1a0, Read Count=1\nUT_GetStubCount: FuncKey=94287145376805, StubPtr=0x55c0efd1ed80, Read Count=1\nUT_GetStubCount: FuncKey=94287145442410, StubPtr=0x55c0efd28440, Read Count=2\nUT_GetStubCount: FuncKey=94287145368045, StubPtr=0x55c0efd1e900, Read Count=1\nUT_GetStubCount: FuncKey=94287145368045, StubPtr=0x55c0efd1e900, Read Count=2\nUT_GetStubCount: FuncKey=94757149997417, StubPtr=0x5\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 8.13 advises that a pointer should point to a const-qualified type whenever possible. In the shown function StubPtr is only used for read access (Count = StubPtr->Data.Rc.Count;) and the test log confirms only read access (and NULL-path handling). Declaring the local variable as const UT_StubTableEntry_t *StubPtr would satisfy the rule and is permitted in C (assigning a non-const pointer to a pointer-to-const is allowed). The current non-const declaration therefore violates the intent of Rule 8.13 in this context."
}