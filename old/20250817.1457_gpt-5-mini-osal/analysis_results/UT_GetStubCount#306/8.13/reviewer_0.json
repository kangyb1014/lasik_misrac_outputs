{
  "user_message": "An agent A claimed that the following UT_GetStubCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubCount.\n```c\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        Count = StubPtr->Data.Rc.Count;\n    }\n    else\n    {\n        Count = 0;\n    }\n\n    return Count;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer StubPtr is declared as a non-const UT_StubTableEntry_t * but is only used for read access (Count = StubPtr->Data.Rc.Count;). Per MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type when possible (e.g. const UT_StubTableEntry_t *StubPtr), so the code violates the rule. If UT_GetStubEntry does not need to return a modifiable pointer, it should return a pointer-to-const as well.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogStubAccess(UT_EntryKey_t FuncKey, const UT_StubTableEntry_t *StubPtr, uint32 Count)\n{\n    FILE *f = fopen(\"/tmp/logs/2451.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    /* Log time as epoch seconds to avoid locale/thread issues */\n    fprintf(f, \"[%ld] UT_GetStubCount called: FuncKey=%ld, StubPtr=%p\",\n            (long)t, (long)FuncKey, (void *)StubPtr);\n\n    if (StubPtr != NULL)\n    {\n        /* Log the observed stored count and the value that will be returned */\n        fprintf(f, \", Data.Rc.Count=%lu, Returned Count=%lu\\n\",\n                (unsigned long)StubPtr->Data.Rc.Count,\n                (unsigned long)Count);\n    }\n    else\n    {\n        fprintf(f, \", StubPtr=NULL, Returned Count=%lu\\n\", (unsigned long)Count);\n    }\n\n    fclose(f);\n}\n\nuint32 UT_GetStubCount(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n    uint32               Count;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        Count = StubPtr->Data.Rc.Count;\n    }\n    else\n    {\n        Count = 0;\n    }\n\n    /* Probe: record the control path and state so the non-const pointer usage\n       (StubPtr used only for read access) can be observed in the logs. */\n    UT_LogStubAccess(FuncKey, StubPtr, Count);\n\n    return Count;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[1755445218] UT_GetStubCount called: FuncKey=94535221667655, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94535221667655, StubPtr=0x55fab24fc880, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94535221666479, StubPtr=0x55fab24fdcc0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94524373000665, StubPtr=0x55f82baed800, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94524373000665, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94524373000665, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94096623585129, StubPtr=0x559493d407c0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94096623585129, StubPtr=0x559493d407c0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94096623585226, StubPtr=0x559493d474e0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94096623585226, StubPtr=0x559493d474e0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94297184611727, StubPtr=0x55c346338160, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94797439627441, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94797439631139, StubPtr=0x5637bfb98060, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94797439631405, StubPtr=0x5637bfb9cbc0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94797439627441, StubPtr=(nil), StubPtr=NULL, Returned Count=0\n[1755445218] UT_GetStubCount called: FuncKey=94797439631139, StubPtr=0x5637bfb98060, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94797439631405, StubPtr=0x5637bfb9cbc0, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=3, Returned Count=3\n[1755445218] UT_GetStubCount called: FuncKey=94797439627441, StubPtr=0x5637bfb9dee0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94797439631139, StubPtr=0x5637bfb98060, Data.Rc.Count=3, Returned Count=3\n[1755445218] UT_GetStubCount called: FuncKey=94797439631405, StubPtr=0x5637bfb9cbc0, Data.Rc.Count=3, Returned Count=3\n[1755445218] UT_GetStubCount called: FuncKey=94797439626581, StubPtr=0x5637bfb99800, Data.Rc.Count=3, Returned Count=3\n[1755445218] UT_GetStubCount called: FuncKey=94797439625452, StubPtr=0x5637bfb9dee0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94504843847700, StubPtr=0x55f39fa77660, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94504843847700, StubPtr=0x55f39fa77660, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94865128207527, StubPtr=0x564782465de0, Data.Rc.Count=1, Returned Count=1\n[1755445218] UT_GetStubCount called: FuncKey=94310494807920, StubPtr=0x55c65f8c9e00, Data.Rc.Count=3, Returned Count=3\n[1755445218] UT_GetStubCount called: FuncKey=94310494808946, StubPtr=0x55c65f8bdfe0, Data.Rc.Count=2, Returned Count=2\n[1755445218] UT_GetStubCount called: FuncKey=94310494807920, StubPtr=0x55c65f8c9e00, Data.Rc.Count=6, Returned Count=6\n[1755445218] UT_GetStubCount called: FuncKey=94310494808946, StubPtr=0x55c65f8bdfe0, Data.Rc.Count=3, Returned Count=3\n[17\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In UT_GetStubCount the local pointer StubPtr is only used to read data (Count = StubPtr->Data.Rc.Count) and is never used to modify the pointee. MISRA C 2023 Rule 8.13 requires a pointer to be const-qualified whenever possible; therefore the local declaration should be const UT_StubTableEntry_t *StubPtr. Assigning a non-const UT_StubTableEntry_t * (the return from UT_GetStubEntry) to a const-qualified pointer is allowed, so the current non-const declaration is unnecessary and constitutes a violation. The provided logs only show read accesses and do not invalidate the rule \u2014 they support that the pointer is used only for reads."
}