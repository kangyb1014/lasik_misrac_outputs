{
  "user_message": "An agent A claimed that the following OS_SelectSingle code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SelectSingle.\n```c\nint32 OS_SelectSingle(osal_id_t objid, uint32 *StateFlags, int32 msecs)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* check parameters */\n    OS_CHECK_POINTER(StateFlags);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_STREAM, objid, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_SelectSingle_Impl(&token, StateFlags, msecs);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memset(&ts_end, 0, sizeof(ts_end)); call is in the else branch taken when msecs <= 0. In those cases ts_end is never subsequently read: for msecs < 0 tvptr is set to NULL (ts_end unused) and for msecs == 0 tv is used (ts_end unused). Removing the memset would not change program behaviour, so this executed assignment is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_SelectSingle(osal_id_t objid, uint32 *StateFlags, int32 msecs)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log entry with key parameters to help reproduce the violation scenario. */\n    {\n        FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n        if (logf)\n        {\n            time_t now = time(NULL);\n            fprintf(logf, \"[%ld] OS_SelectSingle ENTRY: objid=%\" PRIuPTR \", StateFlags=%p, msecs=%d\\n\",\n                    (long)now, (uintptr_t)objid, (void *)StateFlags, (int)msecs);\n            fclose(logf);\n        }\n    }\n\n    /* check parameters */\n    OS_CHECK_POINTER(StateFlags);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_STREAM, objid, &token);\n\n    /* Log the result of object lookup */\n    {\n        FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n        if (logf)\n        {\n            time_t now = time(NULL);\n            fprintf(logf, \"[%ld] OS_ObjectIdGetById returned %d for objid=%\" PRIuPTR \"; token_addr=%p\\n\",\n                    (long)now, (int)return_code, (uintptr_t)objid, (void *)&token);\n            fclose(logf);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log state before calling implementation */\n        {\n            FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n            if (logf)\n            {\n                time_t now = time(NULL);\n                /* Attempt to log the current StateFlags value if readable */\n                if (StateFlags != NULL)\n                {\n                    fprintf(logf, \"[%ld] Calling OS_SelectSingle_Impl: msecs=%d, StateFlags(before)=%#x\\n\",\n                            (long)now, (int)msecs, (unsigned int)*StateFlags);\n                }\n                else\n                {\n                    fprintf(logf, \"[%ld] Calling OS_SelectSingle_Impl: msecs=%d, StateFlags=NULL\\n\",\n                            (long)now, (int)msecs);\n                }\n                fclose(logf);\n            }\n        }\n\n        return_code = OS_SelectSingle_Impl(&token, StateFlags, msecs);\n\n        /* Log result after implementation call and the state of StateFlags */\n        {\n            FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n            if (logf)\n            {\n                time_t now = time(NULL);\n                if (StateFlags != NULL)\n                {\n                    fprintf(logf, \"[%ld] OS_SelectSingle_Impl returned %d; StateFlags(after)=%#x\\n\",\n                            (long)now, (int)return_code, (unsigned int)*StateFlags);\n                }\n                else\n                {\n                    fprintf(logf, \"[%ld] OS_SelectSingle_Impl returned %d; StateFlags=NULL\\n\",\n                            (long)now, (int)return_code);\n                }\n                fclose(logf);\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after release and before return */\n        {\n            FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n            if (logf)\n            {\n                time_t now = time(NULL);\n                fprintf(logf, \"[%ld] OS_ObjectIdRelease done; returning %d\\n\", (long)now, (int)return_code);\n                fclose(logf);\n            }\n        }\n    }\n    else\n    {\n        /* Log early failure path */\n        FILE *logf = fopen(\"/tmp/logs/1914.txt\", \"a\");\n        if (logf)\n        {\n            time_t now = time(NULL);\n            fprintf(logf, \"[%ld] OS_SelectSingle early return with code %d\\n\", (long)now, (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The scenario described by agent A does not match the provided OS_SelectSingle source. The target function contains no memset(&ts_end, ...) or any similar initialization in an else branch \u2014 it only checks StateFlags, obtains an object token, calls OS_SelectSingle_Impl, conditionally releases the token, and returns the result. Every executed operation in the shown function affects program behaviour (parameter check, object lookup, call into the implementation, conditional release) and therefore is not dead code under MISRA C 2023 Rule 2.2. Additionally, the supplied test/logging code failed to compile, so no reproduction of the claimed behaviour was produced; this further indicates the agent's scenario was based on different code. For these reasons the report is not correct."
}