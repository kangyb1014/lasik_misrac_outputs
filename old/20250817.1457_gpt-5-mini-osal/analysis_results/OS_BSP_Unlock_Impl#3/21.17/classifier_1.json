{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_BSP_Unlock_Impl:\n```c\nvoid OS_BSP_Unlock_Impl(void)\n{\n    int status;\n\n    status = pthread_mutex_unlock(&OS_BSP_GenericLinuxGlobal.AccessMutex);\n    if (status < 0)\n    {\n        BSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status));\n    }\n    else\n    {\n        /* Restore previous cancellability state */\n        pthread_setcancelstate(OS_BSP_GenericLinuxGlobal.AccessCancelState, NULL);\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_BSP_Unlock_Impl:\nOS_BSP_GenericLinuxGlobalData_t OS_BSP_GenericLinuxGlobal\n...\n#define BSP_DEBUG(__VA_ARGS__) \n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nBSP_DEBUG(\"pthread_mutex_unlock: %s\\n\", strerror(status));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "Calling strerror(status) when status may be negative. If pthread_mutex_unlock returns a negative value (so the if (status < 0) branch is taken), passing a negative errnum to strerror can cause the implementation to index its internal message table out of bounds (or otherwise behave undefinedly). This can result in accesses beyond the bounds of objects referenced by pointer parameters of string-handling code and thus violates MISRA C 2023 Rule 21.17. A safe fix is to use the correct error check (pthread functions return zero on success and a positive error number on failure) and only call strerror for valid (non-negative) errnos, or use a safer variant such as strerror_r."
}