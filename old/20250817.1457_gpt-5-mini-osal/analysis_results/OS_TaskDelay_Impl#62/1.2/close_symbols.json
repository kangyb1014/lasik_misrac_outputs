{
  "user_message": "Target function code is:\n```c\nint32 OS_TaskDelay_Impl(uint32 millisecond)\n{\n    struct timespec sleep_end;\n    int             status;\n\n    clock_gettime(CLOCK_MONOTONIC, &sleep_end);\n    sleep_end.tv_sec += millisecond / 1000;\n    sleep_end.tv_nsec += 1000000 * (millisecond % 1000);\n\n    if (sleep_end.tv_nsec >= 1000000000)\n    {\n        sleep_end.tv_nsec -= 1000000000;\n        ++sleep_end.tv_sec;\n    }\n\n    do\n    {\n        status = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &sleep_end, NULL);\n    } while (status == EINTR);\n\n    if (status != 0)\n    {\n        return OS_ERROR;\n    }\n    else\n    {\n        return OS_SUCCESS;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_TaskDelay_Impl': {'callees': [], 'callers': ['OS_TaskDelay', 'OS_TimeBase_CallbackThread']}, 'OS_TaskDelay': {'callees': ['OS_TaskDelay_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': ['OS_DeleteAllObjects']}, 'OS_TimeBase_CallbackThread': {'callees': ['OS_TaskRegister_Impl', 'OS_ObjectIdGetById', 'OS_ObjectIndexFromToken', 'OS_ObjectIdRelease', 'OS_TaskDelay_Impl', 'OS_TimeBaseLock_Impl', 'OS_ObjectIdEqual', 'OS_TimeBaseUnlock_Impl', 'OS_ObjectIdFromToken'], 'callers': ['OS_TimeBasePthreadEntry']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct timespec",
    "clock_gettime",
    "clock_nanosleep",
    "CLOCK_MONOTONIC",
    "TIMER_ABSTIME",
    "EINTR",
    "NULL",
    "uint32",
    "int32",
    "OS_ERROR",
    "OS_SUCCESS",
    "time_t"
  ],
  "explanation": "For checking whether the target function uses any compiler/language extensions you must inspect the exact definitions and declarations of the identifiers/types/macros used in the function. Each listed symbol is required for the following reasons:\n\n- struct timespec: The function manipulates a struct timespec instance (tv_sec, tv_nsec). You must see the full struct definition to ensure it doesn't use nonstandard extension members or compiler-specific attributes.\n- clock_gettime: Declaration/signature may include implementation-specific attributes or calling conventions (e.g. __attribute__ or nonstandard prototypes). Verify it's a standard POSIX declaration and not an extension.\n- clock_nanosleep: Same as clock_gettime \u2014 implementations sometimes expose nonstandard variants; the prototype or attributes could be compiler extensions.\n- CLOCK_MONOTONIC: Macro/constant definition must be checked to ensure it isn't provided via a compiler extension or platform-specific header that uses extension features.\n- TIMER_ABSTIME: As above, confirm it's a standard macro and not an extension or alias implemented with nonstandard constructs.\n- EINTR: Errno macros come from <errno.h>; verify the definition is standard and not an extension that uses compiler-specific syntax.\n- NULL: Confirm how NULL is defined in the environment (macro or language keyword) to ensure no extension is used in its definition.\n- uint32: This typedef is not a standard C99 name (uint32_t is standard). You must inspect its typedef/definition to ensure it was not created using compiler-specific extensions (e.g. nonstandard keywords, bit-field tricks, or attributes).\n- int32: Same as uint32 \u2014 inspect the typedef/definition for any use of language extensions.\n- OS_ERROR: Macro/enum constant returned by the function; its definition could hide extension usage (attributes, unusual macros).\n- OS_SUCCESS: Same as OS_ERROR \u2014 check its definition for extensions.\n- time_t: The type of timespec.tv_sec; its underlying definition (typedef to builtin type or implementation-specific type) must be checked for nonstandard constructs.\n\nCollecting these symbol definitions (from the headers and platform/OS-specific headers where they are defined) lets you determine whether any language/compiler-specific extensions are used in the code paths and declarations referenced by the function."
}