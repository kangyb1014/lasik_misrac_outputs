{
  "user_message": "Target function code is:\n```c\nvoid OS_WaitForStateChange_Impl(osal_objtype_t idtype, uint32 attempts)\n{\n    OS_impl_objtype_lock_t *impl;\n    struct timespec         ts;\n\n    impl = OS_impl_objtype_lock_table[idtype];\n\n    /*\n     * because pthread_cond_timedwait() is also a cancellation point,\n     * this pushes a cleanup handler to ensure that if canceled during this call,\n     * the mutex will be released.\n     */\n    pthread_cleanup_push(OS_Posix_ReleaseTableMutex, &impl->mutex);\n\n    clock_gettime(CLOCK_REALTIME, &ts);\n\n    if (attempts <= 10)\n    {\n        /* Wait an increasing amount of time, starting at 10ms */\n        ts.tv_nsec += attempts * attempts * 10000000;\n        if (ts.tv_nsec >= 1000000000)\n        {\n            ts.tv_nsec -= 1000000000;\n            ++ts.tv_sec;\n        }\n    }\n    else\n    {\n        /* wait 1 second (max for polling) */\n        ++ts.tv_sec;\n    }\n\n    pthread_cond_timedwait(&impl->cond, &impl->mutex, &ts);\n\n    pthread_cleanup_pop(false);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_WaitForStateChange_Impl': {'callees': [], 'callers': ['OS_WaitForStateChange']}, 'OS_WaitForStateChange': {'callees': ['OS_WaitForStateChange_Impl'], 'callers': ['OS_ObjectIdConvertToken']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pthread_cleanup_push",
    "pthread_cleanup_pop",
    "pthread.h",
    "OS_Posix_ReleaseTableMutex",
    "OS_impl_objtype_lock_t",
    "OS_impl_objtype_lock_table",
    "pthread_mutex_t",
    "pthread_cond_t",
    "struct timespec",
    "clock_gettime",
    "CLOCK_REALTIME",
    "osal_objtype_t",
    "uint32",
    "false"
  ],
  "explanation": "To determine whether OS_WaitForStateChange_Impl uses any compiler language extensions you must inspect not only the local source but also the definitions/macros/types it relies on. Reason for each symbol:\n\n- pthread_cleanup_push: This is a macro in many pthread implementations that is known to expand into non-standard constructs (matched-pair macros, statement blocks, or compiler-specific helpers). You must examine its exact expansion to see if it uses compiler-only extensions (statement-expressions, nested functions, gcc __extension__ constructs, or attributes).\n\n- pthread_cleanup_pop: Same as pthread_cleanup_push \u2014 the paired macro expansion must be inspected for use of compiler-specific language extensions and for the matched-pair macro pattern.\n\n- pthread.h: The header contains the definitions or macros for pthread_cleanup_push/pop and the pthread types; inspecting the header (or the concrete platform headers used to compile this code) is required to find any extension usage.\n\n- OS_Posix_ReleaseTableMutex: The cleanup handler passed to pthread_cleanup_push; its prototype/definition must be inspected to ensure it does not itself use compiler extensions (attributes, nonstandard calling conventions, or inline assembly) and to verify it matches the macro's expected signature.\n\n- OS_impl_objtype_lock_t: The struct type of *impl must be examined to ensure its declaration does not include compiler extensions (attribute((...)), packed/aligned nonstandard pragmas, GCC bit-field extensions, or other non\u2011standard features).\n\n- OS_impl_objtype_lock_table: The declaration/definition of this global table must be checked for any use of compiler-specific attributes or extensions (section attributes, visibility attributes, or nonstandard initializers).\n\n- pthread_mutex_t: The concrete typedef/implementation of pthread_mutex_t on the target platform should be checked in case the type is implemented with compiler-specific extensions (e.g., as a struct with attributes or using builtins).\n\n- pthread_cond_t: Same rationale as pthread_mutex_t \u2014 check the actual typedef/implementation used by the platform headers for any extensions.\n\n- struct timespec: The timespec layout and any macros around it (e.g., extension-provided fields) should be inspected to ensure no nonstandard language constructs are relied upon.\n\n- clock_gettime: This library function is POSIX (not ISO C); inspect its declaration for attributes or macros that may use compiler extensions (visibility, weak aliasing, or special linkage attributes).\n\n- CLOCK_REALTIME: A macro/constant defined in headers; inspect to ensure it does not expand to or rely on nonstandard constructs.\n\n- osal_objtype_t: The type of the idtype parameter (likely an enum or typedef) must be checked: some codebases use compiler extensions in enum/typedef declarations (packed enums, explicit underlying types, or attributes).\n\n- uint32: The typedef used for attempts must be checked to see if it is a standard typedef (e.g., uint32_t) or a nonstandard compiler-defined type or alias that relies on extensions.\n\n- false: The boolean literal used in pthread_cleanup_pop(false) comes from stdbool.h (or a project macro). Verify its definition to ensure it is the standard macro and not a project/compiler extension.\n\nInspecting these symbols/headers will allow an accurate determination whether any of the constructs used by OS_WaitForStateChange_Impl expand to or require compiler-specific language extensions that would violate the MISRA rule."
}