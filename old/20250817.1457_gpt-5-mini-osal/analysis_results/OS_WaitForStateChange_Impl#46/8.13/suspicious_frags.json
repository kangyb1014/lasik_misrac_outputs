{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_WaitForStateChange_Impl:\n```c\nvoid OS_WaitForStateChange_Impl(osal_objtype_t idtype, uint32 attempts)\n{\n    OS_impl_objtype_lock_t *impl;\n    struct timespec         ts;\n\n    impl = OS_impl_objtype_lock_table[idtype];\n\n    /*\n     * because pthread_cond_timedwait() is also a cancellation point,\n     * this pushes a cleanup handler to ensure that if canceled during this call,\n     * the mutex will be released.\n     */\n    pthread_cleanup_push(OS_Posix_ReleaseTableMutex, &impl->mutex);\n\n    clock_gettime(CLOCK_REALTIME, &ts);\n\n    if (attempts <= 10)\n    {\n        /* Wait an increasing amount of time, starting at 10ms */\n        ts.tv_nsec += attempts * attempts * 10000000;\n        if (ts.tv_nsec >= 1000000000)\n        {\n            ts.tv_nsec -= 1000000000;\n            ++ts.tv_sec;\n        }\n    }\n    else\n    {\n        /* wait 1 second (max for polling) */\n        ++ts.tv_sec;\n    }\n\n    pthread_cond_timedwait(&impl->cond, &impl->mutex, &ts);\n\n    pthread_cleanup_pop(false);\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "pthread_cleanup_push(OS_Posix_ReleaseTableMutex, &impl->mutex);",
    "pthread_cond_timedwait(&impl->cond, &impl->mutex, &ts);",
    "OS_impl_objtype_lock_t *impl;",
    "impl = OS_impl_objtype_lock_table[idtype];"
  ],
  "explanation": "The MISRA rule targets pointer declarations that could/should point to const-qualified types. The fragments above involve a pointer variable (impl), its assignment from a global table, and taking addresses of members via that pointer. These should be investigated to determine whether impl (or the table element type) could/should be a pointer to a const-qualified type or whether const correctness is violated when passing member addresses to APIs. Other code fragments do not need investigation for this rule: - struct timespec ts and its use: ts is written to and adjusted locally before being passed (and the API expects a const struct timespec*), so ts cannot be declared const. - Passing &impl->mutex and &impl->cond to pthread APIs: these APIs require non-const pointers because they modify the mutex/cond; making the pointee const would be incompatible. - The timing arithmetic, clock_gettime call, attempts check, and pthread_cleanup_pop(false) are unrelated to whether pointers should point to const-qualified types and thus do not need further review for Rule 8.13."
}