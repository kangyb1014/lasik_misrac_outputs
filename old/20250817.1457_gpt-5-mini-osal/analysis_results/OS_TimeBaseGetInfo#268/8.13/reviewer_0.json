{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetInfo.\n```c\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignment reads from record->creator but the local pointer 'record' is declared as a non-const pointer (OS_common_record_t *record). The function only reads the referenced object, so the pointer should be const-qualified (e.g. const OS_common_record_t *record). Likewise 'timebase' could be const OS_timebase_internal_record_t *timebase. Using a non-const pointer for read-only access violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct OS_object_token\n{\n    uint32_t id;\n};\nstruct OS_common_record\n{\n    char     name_entry[64];\n    uint32_t creator;\n    /* This member is referenced elsewhere in the file. */\n    uint32_t active_id;\n};\nstruct OS_timebase_internal_record\n{\n    uint32_t nominal_interval_time;\n    uint32_t freerun_time;\n    uint32_t accuracy_usec;\n\n    /* Members used by other functions in the same source file */\n    uint32_t first_cb; /* osal_id_t typically */\n    void (*external_sync)(void); /* approximate type for external sync callback */\n};\nstruct OS_timebase_prop\n{\n    char     name[64];\n    uint32_t creator;\n    uint32_t nominal_interval_time;\n    uint32_t freerun_time;\n    uint32_t accuracy;\n};\nextern struct OS_common_record OS_global_timebase_table_storage[];\nextern struct OS_timebase_internal_record OS_timebase_table_storage[];\nstatic void os_log_probe(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    fputc('\\n', fp);\n    va_end(args);\n\n    fclose(fp);\n}\n\nint32_t OS_TimeBaseGetInfo(uint32_t timebase_id, struct OS_timebase_prop *timebase_prop)\n{\n    struct OS_common_record *record;\n    int32_t                  return_code = -1;\n    unsigned int             objtype;\n    struct OS_object_token   token;\n    struct OS_timebase_internal_record *timebase;\n\n    /* Log function entry and parameters */\n    os_log_probe(\"ENTRY: OS_TimeBaseGetInfo called with timebase_id=%u, timebase_prop=%p\", (unsigned)timebase_id, (void *)timebase_prop);\n\n    /* Check parameters (in original code this was a macro). */\n    if (timebase_prop == NULL)\n    {\n        os_log_probe(\"PARAMETER_CHECK: timebase_prop is NULL -> returning %d\", (int)-2);\n        return -2; /* OS_INVALID_POINTER equivalent placeholder */\n    }\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.  The real implementation of\n     * OS_ObjectIdToType_Impl and OS_TaskGetId_Impl is provided by the system.\n     */\n    objtype = (unsigned int)OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    os_log_probe(\"CONTEXT_CHECK: OS_ObjectIdToType_Impl returned objtype=%u\", objtype);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        os_log_probe(\"CONTEXT_VIOLATION: called from a timebase callback context -> returning %d\", (int)-3);\n        return -3; /* OS_ERR_INCORRECT_OBJ_STATE equivalent placeholder */\n    }\n\n    memset(timebase_prop, 0, sizeof(struct OS_timebase_prop));\n    os_log_probe(\"ZEROED_OUTPUT: timebase_prop at %p zeroed\", (void *)timebase_prop);\n\n    return_code = OS_ObjectIdGetById(0, 0, timebase_id, &token);\n    os_log_probe(\"LOOKUP: OS_ObjectIdGetById returned %d (token.id=%u)\", (int)return_code, (unsigned)token.id);\n    if (return_code == 0)\n    {\n        /* Retrieve records from the tables using project-provided helpers */\n        record = OS_OBJECT_TABLE_GET_common(OS_global_timebase_table_storage, &token);\n        timebase = OS_OBJECT_TABLE_GET_timebase(OS_timebase_table_storage, &token);\n\n        os_log_probe(\"TABLE_ACCESS: record=%p, timebase=%p\", (void *)record, (void *)timebase);\n\n        if (record != NULL)\n        {\n            /* Log the fields we are about to read from the non-const pointer 'record' */\n            os_log_probe(\"RECORD_READ_BEFORE: record->name_entry='%s', record->creator=%u\", record->name_entry, (unsigned)record->creator);\n\n            strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n            timebase_prop->creator = record->creator; /* <-- read-only access to record */\n\n            os_log_probe(\"RECORD_READ_AFTER: copied name='%s', creator=%u\", timebase_prop->name, (unsigned)timebase_prop->creator);\n        }\n        else\n        {\n            os_log_probe(\"RECORD_NULL: record pointer was NULL for token.id=%u\", (unsigned)token.id);\n        }\n\n        if (timebase != NULL)\n        {\n            /* Log the fields we are about to read from the non-const pointer 'timebase' */\n            os_log_probe(\"TIMEBASE_READ_BEFORE: nominal_interval_time=%u, freerun_time=%u, accuracy_usec=%u\",\n                         (unsigned)timebase->nominal_interval_time,\n                         (unsigned)timebase->freerun_time,\n                         (unsigned)timebase->accuracy_usec);\n\n            timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n            timebase_prop->freerun_time          = timebase->freerun_time;\n            timebase_prop->accuracy              = timebase->accuracy_usec;\n\n            os_log_probe(\"TIMEBASE_READ_AFTER: copied nominal=%u, freerun=%u, accuracy=%u\",\n                         (unsigned)timebase_prop->nominal_interval_time,\n                         (unsigned)timebase_prop->freerun_time,\n                         (unsigned)timebase_prop->accuracy);\n        }\n        else\n        {\n            os_log_probe(\"TIMEBASE_NULL: timebase pointer was NULL for token.id=%u\", (unsigned)token.id);\n        }\n\n        /* Call platform-specific implementation and log its result */\n        os_log_probe(\"IMPL_CALL: Calling OS_TimeBaseGetInfo_Impl with token.id=%u\", (unsigned)token.id);\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n        os_log_probe(\"IMPL_RETURN: OS_TimeBaseGetInfo_Impl returned %d\", (int)return_code);\n\n        OS_ObjectIdRelease(&token);\n        os_log_probe(\"RELEASE: OS_ObjectIdRelease called for token.id=%u\", (unsigned)token.id);\n    }\n\n    os_log_probe(\"EXIT: OS_TimeBaseGetInfo returning %d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown function the local pointers 'record' and 'timebase' are only used to read fields (they are not written through or passed to functions that would modify the referenced objects). Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so these should be declared as const OS_common_record_t *record and const OS_timebase_internal_record_t *timebase. Changing the declarations is legal (a pointer-to-non-const can be converted to pointer-to-const) and does not affect other calls in this function. The test harness failing to compile is unrelated to the correctness of the rule violation claim. Note: if the project macros or other code in the same translation unit require the non-const type (e.g. other code in this file writes via those pointers or the OS_OBJECT_TABLE_GET macro has constraints), then making them const might be infeasible; based on the provided snippet, however, the report is correct."
}