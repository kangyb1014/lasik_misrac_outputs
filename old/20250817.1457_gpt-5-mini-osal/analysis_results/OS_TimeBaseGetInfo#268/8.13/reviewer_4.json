{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetInfo.\n```c\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'timebase' is declared as OS_timebase_internal_record_t * but is only used for read-only accesses (timebase->nominal_interval_time, timebase->freerun_time, timebase->accuracy_usec). Per MISRA C 2023 Rule 8.13 it should be const-qualified (e.g. const OS_timebase_internal_record_t *timebase) to indicate read-only use and prevent accidental modification. The assignment from OS_OBJECT_TABLE_GET (a non-const object array) can be implicitly converted to a pointer-to-const, so making it const is possible here.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TimeBaseGetInfo_Log(const char *stage, osal_objtype_t objtype, int32 return_code, OS_common_record_t *record, OS_timebase_internal_record_t *timebase)\n{\n    FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Log basic control-flow stage and codes */\n    fprintf(fp, \"OS_TimeBaseGetInfo - stage=%s, objtype=%d, return_code=%ld\\n\",\n            stage, (int)objtype, (long)return_code);\n\n    /* If record is available, log identifying information */\n    if (record != NULL)\n    {\n        /* name_entry is expected to be a NUL-terminated string; protect against NULL */\n        fprintf(fp, \"  record->name_entry=\\\"%s\\\", record->creator=%lu\\n\",\n                (record->name_entry != NULL) ? record->name_entry : \"(null)\", (unsigned long)record->creator);\n    }\n\n    /* If timebase is available, log the read-only fields observed in the violation scenario */\n    if (timebase != NULL)\n    {\n        fprintf(fp, \"  timebase @ %p: nominal_interval_time=%ld, freerun_time=%ld, accuracy_usec=%ld\\n\",\n                (const void *)timebase,\n                (long)timebase->nominal_interval_time,\n                (long)timebase->freerun_time,\n                (long)timebase->accuracy_usec);\n    }\n\n    fclose(fp);\n}\n\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n\n    /* Log the context check result */\n    OS_TimeBaseGetInfo_Log(\"after_context_check\", objtype, 0, NULL, NULL);\n\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        /* Log the incorrect object-state return path */\n        OS_TimeBaseGetInfo_Log(\"incorrect_obj_state\", objtype, OS_ERR_INCORRECT_OBJ_STATE, NULL, NULL);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    /* Log prior to attempting to get the object by id */\n    OS_TimeBaseGetInfo_Log(\"before_ObjectIdGetById\", objtype, 0, NULL, NULL);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        /* Log the state immediately after obtaining the record and timebase pointer */\n        OS_TimeBaseGetInfo_Log(\"after_table_get\", objtype, return_code, record, timebase);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        /* Log the values being copied into the public prop structure */\n        OS_TimeBaseGetInfo_Log(\"before_impl_call\", objtype, return_code, record, timebase);\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        /* Log the result from the implementation-specific call */\n        OS_TimeBaseGetInfo_Log(\"after_impl_call\", objtype, return_code, record, timebase);\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        /* Log the failure to find the object id */\n        OS_TimeBaseGetInfo_Log(\"objectid_get_failed\", objtype, return_code, NULL, NULL);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBaseGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct. In OS_TimeBaseGetInfo the local variable timebase is only used for read-only accesses (reading nominal_interval_time, freerun_time and accuracy_usec) and is never modified or passed to an API that requires a non-const pointer. Converting the declaration to const OS_timebase_internal_record_t *timebase is allowed (an object pointer-to-T* can be assigned to a pointer-to-const T), and communicates the intent while preventing accidental modification. Thus the code fails to follow the guidance of MISRA C 2023 Rule 8.13 (pointer should point to a const-qualified type whenever possible). Note: similar read-only local pointers (e.g. record) could also be const; if there are project-specific reasons or macros that require a non-const type then that should be documented or an explicit cast used, but no such reason is visible in the provided code."
}