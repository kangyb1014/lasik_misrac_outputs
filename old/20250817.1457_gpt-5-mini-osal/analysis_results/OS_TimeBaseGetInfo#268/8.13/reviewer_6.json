{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetInfo.\n```c\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'timebase' is declared as OS_timebase_internal_record_t *timebase but is only used for read access (e.g. timebase_prop->freerun_time = timebase->freerun_time). According to MISRA C 2023 Rule 8.13 the pointer should be declared to point to a const-qualified type (const OS_timebase_internal_record_t *) when modification is not required.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TimeBase_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp for ease of tracing */\n    time_t t = time(NULL);\n    struct tm tm;\n    if (localtime_r(&t, &tm) != NULL)\n    {\n        char timestr[64];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm) > 0)\n        {\n            fprintf(fp, \"%s - \", timestr);\n        }\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Log entry and incoming parameters */\n    OS_TimeBase_Log(\"Entered OS_TimeBaseGetInfo: timebase_id=%llu, timebase_prop=%p\",\n                    (unsigned long long)timebase_id, (void *)timebase_prop);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    OS_TimeBase_Log(\"Object type of caller: %d\", (int)objtype);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        OS_TimeBase_Log(\"Early return: caller is a timebase callback (OS_ERR_INCORRECT_OBJ_STATE)\");\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n    OS_TimeBase_Log(\"Cleared timebase_prop at %p\", (void *)timebase_prop);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    OS_TimeBase_Log(\"OS_ObjectIdGetById returned %d for id=%llu\", (int)return_code, (unsigned long long)timebase_id);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        /* Log pointers and some internal state observed (read-only) */\n        OS_TimeBase_Log(\"Obtained record=%p, timebase=%p, token=%p\", (void *)record, (void *)timebase, (void *)&token);\n        if (record != NULL)\n        {\n            /* record->name_entry may not be NUL-terminated, so copy safely for logging */\n            char name_buf[sizeof(timebase_prop->name)];\n            memset(name_buf, 0, sizeof(name_buf));\n            strncpy(name_buf, record->name_entry, sizeof(name_buf) - 1);\n            OS_TimeBase_Log(\"record->name_entry='%s', record->creator=%u\", name_buf, (unsigned)record->creator);\n        }\n        if (timebase != NULL)\n        {\n            /* Avoid referencing fields that might not be visible here; log pointer instead */\n            OS_TimeBase_Log(\"timebase=%p\", (void *)timebase);\n        }\n\n        /* If available, copy out the name and creator into the public properties. Preserve original logic of zeroing/copying name. */\n        if (record != NULL)\n        {\n            strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n            timebase_prop->name[sizeof(timebase_prop->name) - 1] = '\\0';\n            timebase_prop->creator = record->creator;\n        }\n\n        /* Release the object lock/token and return success */\n        OS_ObjectIdRelease(token);\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. In the shown function the local pointer timebase is only used to read fields (timebase->nominal_interval_time, timebase->freerun_time, timebase->accuracy_usec) and is never used to modify the pointed object or passed to an API that requires a non-const pointer. MISRA C 2023 Rule 8.13 advises that pointers should point to const-qualified types whenever possible, so declaring it as const OS_timebase_internal_record_t *timebase would conform to the guideline. (Note: this is a \"should\" guideline \u2014 not an absolute prohibition \u2014 but the agent A's report that the current code violates Rule 8.13 is correct. Also consider applying the same const qualification to record if it is only read.)"
}