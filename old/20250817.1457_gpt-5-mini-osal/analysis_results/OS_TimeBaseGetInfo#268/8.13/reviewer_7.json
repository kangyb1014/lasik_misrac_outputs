{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetInfo.\n```c\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'record' is declared as OS_common_record_t *record and is only used for read access (e.g. record->name_entry is used as the source to strncpy). The name_entry member is a non-const char array, so the pointer that refers to it (via record) is not const-qualified even though it could be (e.g. const OS_common_record_t *record or const char *src). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible, so this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_timebase_log_probe(const char *event,\n                                  const OS_common_record_t *record,\n                                  const OS_timebase_internal_record_t *timebase,\n                                  const OS_object_token_t *token,\n                                  osal_id_t timebase_id,\n                                  osal_objtype_t objtype,\n                                  int32 return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/2147.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"EVENT: %s\\n\", event);\n    fprintf(f, \"  timebase_id: %u\\n\", (unsigned)timebase_id);\n    fprintf(f, \"  objtype: %d\\n\", (int)objtype);\n    fprintf(f, \"  return_code: %d\\n\", (int)return_code);\n    fprintf(f, \"  token_addr: %p\\n\", (void *)token);\n    fprintf(f, \"  record_addr: %p\\n\", (const void *)record);\n    if (record != NULL)\n    {\n        /* name_entry is a non-const char array in the real structure; log it as read-only here */\n        fprintf(f, \"  record->name_entry: '%s'\\n\", record->name_entry);\n        fprintf(f, \"  record->creator: %u\\n\", (unsigned)record->creator);\n    }\n    fprintf(f, \"  timebase_addr: %p\\n\", (const void *)timebase);\n    if (timebase != NULL)\n    {\n        fprintf(f, \"  timebase->nominal_interval_time: %llu\\n\", (unsigned long long)timebase->nominal_interval_time);\n        fprintf(f, \"  timebase->freerun_time: %llu\\n\", (unsigned long long)timebase->freerun_time);\n        fprintf(f, \"  timebase->accuracy_usec: %u\\n\", (unsigned)timebase->accuracy_usec);\n    }\n\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    os_timebase_log_probe(\"entry_after_param_check\", NULL, NULL, NULL, timebase_id, 0, 0);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    os_timebase_log_probe(\"after_objtype_check\", NULL, NULL, NULL, timebase_id, objtype, 0);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        os_timebase_log_probe(\"error_incorrect_obj_state\", NULL, NULL, NULL, timebase_id, objtype, (int32)OS_ERR_INCORRECT_OBJ_STATE);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n    os_timebase_log_probe(\"after_memset\", NULL, NULL, NULL, timebase_id, objtype, 0);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    os_timebase_log_probe(\"after_ObjectIdGetById\", NULL, NULL, &token, timebase_id, objtype, return_code);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        /* Log state just before performing the strncpy so callers can observe the read-only usage */\n        os_timebase_log_probe(\"before_strncpy\", record, timebase, &token, timebase_id, objtype, return_code);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n\n        /* Ensure NUL termination as original code intended */\n        timebase_prop->name[sizeof(timebase_prop->name) - 1] = '\\0';\n\n        /* Log state after copy */\n        os_timebase_log_probe(\"after_strncpy\", record, timebase, &token, timebase_id, objtype, return_code);\n\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        os_timebase_log_probe(\"before_impl_call\", record, timebase, &token, timebase_id, objtype, return_code);\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n        os_timebase_log_probe(\"after_impl_call\", record, timebase, &token, timebase_id, objtype, return_code);\n\n        OS_ObjectIdRelease(&token);\n        os_timebase_log_probe(\"after_release\", record, timebase, &token, timebase_id, objtype, return_code);\n    }\n\n    os_timebase_log_probe(\"exit\", NULL, NULL, NULL, timebase_id, objtype, return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBaseGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_TimeBaseGetInfo the local variable \"record\" is only used for read-only accesses (record->name_entry, record->creator) and never used to modify the referred object. Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the local declaration could (and should) be changed to const OS_common_record_t *record. Assigning the non-const result of the OS_OBJECT_TABLE_GET macro to a pointer-to-const is permitted and does not require casts. The same observation applies to the local timebase pointer (it is only read and could be declared const). If some called function needed to modify the object via this local pointer, then adding const would be inappropriate; but in the presented code there is no such use, so the agent A's claim of a Rule 8.13 violation is valid."
}