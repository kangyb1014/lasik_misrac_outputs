{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetInfo.\n```c\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable timebase is declared as a non-const pointer (OS_timebase_internal_record_t *timebase) and is assigned from OS_OBJECT_TABLE_GET(OS_timebase_table, token). In OS_TimeBaseGetInfo the pointer is only used to read fields (nominal_interval_time, freerun_time, accuracy_usec) and is never used to modify the referenced object. Therefore the pointer could and should be declared as a pointer to const (const OS_timebase_internal_record_t *timebase) to express read-only intent and satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_TimeBaseGetInfo(osal_id_t timebase_id, OS_timebase_prop_t *timebase_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Probe: log function entry and parameter */\n    {\n        FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"ENTER OS_TimeBaseGetInfo: timebase_prop=%p\\n\", (void *)timebase_prop);\n            fclose(fp);\n        }\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timebase_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n\n    /* Probe: log objtype */\n    {\n        FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"OS_TimeBaseGetInfo: objtype=%u\\n\", (unsigned int)objtype);\n            fclose(fp);\n        }\n    }\n\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        /* Probe: log incorrect object state path */\n        FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"OS_TimeBaseGetInfo: early return - incorrect object state (called from timebase)\\n\");\n            fclose(fp);\n        }\n\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timebase_prop, 0, sizeof(OS_timebase_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, timebase_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        /* Probe: log pointers and read-only fields observed from the timebase object */\n        {\n            FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n            if (fp != NULL)\n            {\n                /* Log addresses and values used by this function. Casts used to avoid format warnings. */\n                fprintf(fp, \"OS_TimeBaseGetInfo: token=%p record=%p name=\\\"%s\\\" timebase=%p\\n\",\n                        (void *)&token,\n                        (void *)record,\n                        (record && record->name_entry) ? record->name_entry : \"(null)\",\n                        (void *)timebase);\n\n                if (timebase != NULL)\n                {\n                    fprintf(fp, \"OS_TimeBaseGetInfo: nominal_interval_time=%llu freerun_time=%llu accuracy_usec=%u\\n\",\n                            (unsigned long long)timebase->nominal_interval_time,\n                            (unsigned long long)timebase->freerun_time,\n                            (unsigned int)timebase->accuracy_usec);\n                }\n                else\n                {\n                    fprintf(fp, \"OS_TimeBaseGetInfo: timebase pointer is NULL\\n\");\n                }\n\n                fclose(fp);\n            }\n        }\n\n        strncpy(timebase_prop->name, record->name_entry, sizeof(timebase_prop->name) - 1);\n        timebase_prop->creator               = record->creator;\n        timebase_prop->nominal_interval_time = timebase->nominal_interval_time;\n        timebase_prop->freerun_time          = timebase->freerun_time;\n        timebase_prop->accuracy              = timebase->accuracy_usec;\n\n        return_code = OS_TimeBaseGetInfo_Impl(&token, timebase_prop);\n\n        /* Probe: log return_code from platform-specific implementation */\n        {\n            FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n            if (fp != NULL)\n            {\n                fprintf(fp, \"OS_TimeBaseGetInfo: after Impl return_code=%d\\n\", (int)return_code);\n                fclose(fp);\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        /* Probe: log failure to get object by id */\n        FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"OS_TimeBaseGetInfo: OS_ObjectIdGetById failed return_code=%d\\n\", (int)return_code);\n            fclose(fp);\n        }\n    }\n\n    /* Probe: log final return value */\n    {\n        FILE *fp = fopen(\"/tmp/logs/2147.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"EXIT OS_TimeBaseGetInfo: return_code=%d\\n\", (int)return_code);\n            fclose(fp);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBaseGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_TimeBaseGetInfo the local variable timebase is only used to read fields (nominal_interval_time, freerun_time, accuracy_usec) and never used to modify the referenced object. Per MISRA C:2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so timebase could and should be declared as const OS_timebase_internal_record_t *timebase to express read-only intent. (Note: assigning the non-const result of OS_OBJECT_TABLE_GET to a const-qualified pointer is permitted; the change documents intent and improves compliance. The same observation applies to record, which is also only read and could be const.)"
}