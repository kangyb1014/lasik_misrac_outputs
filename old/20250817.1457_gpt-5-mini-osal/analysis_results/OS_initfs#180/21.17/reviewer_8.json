{
  "user_message": "An agent A claimed that the following OS_initfs code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_initfs.\n```c\nint32 OS_initfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, false);\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the OS_CHECK_STRING macro uses unbounded string functions (e.g. strlen) on fsvolname, then a non\u2011null\u2011terminated or overly long fsvolname will cause the function to read past the bounds of the caller\u2019s object. For example, if the caller passes a pointer to a character array that does not contain a NUL within sizeof(filesys->volume_name) bytes, strlen(fsvolname) (or any unbounded strcpy/strcat/memcpy using the length) will scan beyond the intended limit and violate MISRA C 2023 Rule 21.17. OS_CHECK_STRING must use a bounded operation (e.g. strnlen/memchr with the provided size) to avoid this violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_append(const char *line)\n{\n    FILE *f = fopen(\"/tmp/logs/1447.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    fprintf(f, \"%s\\n\", line);\n    fclose(f);\n}\nstatic void probe_log_ptr(const char *name, const void *ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/1447.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    fprintf(f, \"%s: %p\\n\", name, ptr);\n    fclose(f);\n}\nstatic void probe_log_numeric(const char *name, unsigned long value)\n{\n    FILE *f = fopen(\"/tmp/logs/1447.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    fprintf(f, \"%s: %lu\\n\", name, value);\n    fclose(f);\n}\nstatic void probe_log_string_limited(const char *name, const char *s, size_t maxlen)\n{\n    FILE *f = fopen(\"/tmp/logs/1447.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    if (s == NULL)\n    {\n        fprintf(f, \"%s: (NULL)\\n\", name);\n        fclose(f);\n        return;\n    }\n\n    size_t len = strnlen(s, maxlen);\n    fprintf(f, \"%s: length=%zu\\n\", name, len);\n\n    /* Write the contents up to len bytes. Mark as truncated if len == maxlen. */\n    if (len > 0)\n    {\n        fwrite(\"value=\\\"\", 1, 8, f);\n        fwrite(s, 1, len, f);\n        if (len == maxlen)\n        {\n            fwrite(\"..(truncated)\", 1, 13, f);\n        }\n        fwrite(\"\\\"\\n\", 1, 2, f);\n    }\n    else\n    {\n        fwrite(\"value=\\\"\\\"\\n\", 1, 9, f);\n    }\n\n    fclose(f);\n}\n\nint32 OS_initfs(char *address, const char *devname, const char *volname, size_t blocksize, osal_blockcount_t numblocks)\n{\n    int32 return_code;\n\n    /* Log entry and parameter pointers */\n    probe_log_append(\"---- OS_initfs ENTRY ----\");\n    probe_log_ptr(\"address\", (const void *)address);\n    probe_log_ptr(\"devname\", (const void *)devname);\n    probe_log_ptr(\"volname\", (const void *)volname);\n    probe_log_numeric(\"blocksize\", (unsigned long)blocksize);\n    probe_log_numeric(\"numblocks\", (unsigned long)numblocks);\n\n    /* Log limited snapshots of the string parameters. Use a conservative\n     * max length to avoid large or unbounded reads. Adjust MAX_SNAP_LEN if\n     * project-specific limits are known (e.g. filesys->volume_name size).\n     */\n    enum { MAX_SNAP_LEN = 256 };\n    probe_log_string_limited(\"devname_snapshot\", devname, MAX_SNAP_LEN);\n    probe_log_string_limited(\"volname_snapshot\", volname, MAX_SNAP_LEN);\n\n    /* Call the original initialization routine */\n    return_code = OS_FileSys_Initialize(address, devname, volname, blocksize, numblocks, false);\n\n    /* Log the raw return code from the filesystem initializer */\n    {\n        char buf[128];\n        snprintf(buf, sizeof(buf), \"OS_FileSys_Initialize returned: %ld\", (long)return_code);\n        probe_log_append(buf);\n    }\n\n    if (return_code == OS_ERR_INCORRECT_OBJ_STATE || return_code == OS_ERR_NO_FREE_IDS)\n    {\n        probe_log_append(\"Mapping historic filesystem-specific error to OS_FS_ERR_DEVICE_NOT_FREE\");\n\n        /*\n         * This is the historic filesystem-specific error code generated when\n         * attempting to mkfs()/initfs() on a filesystem that was\n         * already initialized, or if there were no free slots in the table.\n         *\n         * This code preserved just in case application code was checking for it.\n         */\n        return_code = OS_FS_ERR_DEVICE_NOT_FREE;\n\n        {\n            char buf[128];\n            snprintf(buf, sizeof(buf), \"Return code adjusted to: %ld\", (long)return_code);\n            probe_log_append(buf);\n        }\n    }\n\n    probe_log_append(\"---- OS_initfs EXIT ----\");\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_initfs. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the shown OS_initfs function. The original OS_initfs implementation does not call any of the <string.h> routines itself \u2014 it merely forwards the pointers devname and volname to OS_FileSys_Initialize. MISRA C:2023 Rule 21.17 concerns unsafe use of string.h functions (e.g. strlen/strcpy) that can read past the bounds of the objects referenced by pointer parameters. Any violation of 21.17 would therefore be located in OS_FileSys_Initialize (or in any macro it uses, such as an OS_CHECK_STRING macro), not in the OS_initfs wrapper shown. Agent A\u2019s scenario is a plausible hazard if OS_FileSys_Initialize/OS_CHECK_STRING uses unbounded string functions, but the claim that OS_initfs itself violates 21.17 is unsupported by the code shown. To be compliant, any string handling inside OS_FileSys_Initialize/OS_CHECK_STRING must use bounded operations (strnlen, memchr, strncat/strncpy with careful sizing, etc.) or otherwise ensure the objects are NUL-terminated and within bounds."
}