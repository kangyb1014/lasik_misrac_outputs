{
  "user_message": "An agent A claimed that the following UT_Stub_GetReturnValuePtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_GetReturnValuePtr.\n```c\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer StubPtr is declared as a pointer to a non-const UT_StubTableEntry_t but in UT_Stub_GetReturnValuePtr it is only used for reads (accessing EntryType, FuncKey, Data.Buff.*). Therefore it could and should be declared as const UT_StubTableEntry_t *StubPtr to convey immutability and satisfy MISRA C 2023 Rule 8.13. Assigning the non-const return of UT_GetStubEntry to a pointer-to-const is allowed, so no other API change is required.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogProbe(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2563.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n\n    /* Log entry parameters (avoid assumptions about FuncKey type) */\n    UT_LogProbe(\"UT_Stub_GetReturnValuePtr entry: ReturnSize=%lu TypeName=%s\", (unsigned long)ReturnSize,\n                TypeName ? TypeName : \"(null)\");\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    UT_LogProbe(\"UT_GetStubEntry returned StubPtr=%p\", (void *)StubPtr);\n\n    if (StubPtr == NULL)\n    {\n        /* Log before aborting so there is evidence in the file */\n        UT_LogProbe(\"StubPtr is NULL - calling UtAssert_Abort (Return buffer invalid)\");\n\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /* Log the read-only fields that are used by this function */\n        UT_LogProbe(\"StubPtr->Data.Buff.BasePtr=%p Position=%lu ContentTypeStr=%s\",\n                    ReturnPtr,\n                    (unsigned long)StubPtr->Data.Buff.Position,\n                    StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\");\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            /* Log mismatch details before asserting to provide evidence */\n            UT_LogProbe(\"Return value mismatch detected: expected %s(%lu) got %s(%lu)\",\n                        TypeName ? TypeName : \"(null)\", (unsigned long)ReturnSize,\n                        StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\",\n                        (unsigned long)StubPtr->Data.Buff.Position);\n\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    UT_LogProbe(\"UT_Stub_GetReturnValuePtr exiting, ReturnPtr=%p\", ReturnPtr);\n\n    return ReturnPtr;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55b40db43720\nStubPtr->Data.Buff.BasePtr=0x55b429789cb0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55b429789cb0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55b40db43720\nStubPtr->Data.Buff.BasePtr=0x55b429789cb0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55b429789cb0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55b40db43720\nStubPtr->Data.Buff.BasePtr=0x55b429789cb0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55b429789cb0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55bc28ae0a40\nStubPtr->Data.Buff.BasePtr=0x55bc67faaa80 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55bc67faaa80\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55bc28ae0a40\nStubPtr->Data.Buff.BasePtr=0x55bc67faaa80 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55bc67faaa80\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55bc28ae0a40\nStubPtr->Data.Buff.BasePtr=0x55bc67faaa80 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55bc67faaa80\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55df7c1853a0\nStubPtr->Data.Buff.BasePtr=0x55dfb03fec40 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55dfb03fec40\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55df7c1853a0\nStubPtr->Data.Buff.BasePtr=0x55dfb03fec40 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55dfb03fec40\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55c4db11cf20\nStubPtr->Data.Buff.BasePtr=0x55c4f9ea5bd0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55c4f9ea5bd0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55c4db11cf20\nStubPtr->Data.Buff.BasePtr=0x55c4f9ea5bd0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55c4f9ea5bd0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=osal_id_t\nUT_GetStubEntry returned StubPtr=0x55a8845f27c0\nStubPtr->Data.Buff.BasePtr=0x55a8a61679a0 Position=4 ContentTypeStr=osal_id_t\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a61679a0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55a8845f2b20\nStubPtr->Data.Buff.BasePtr=0x55a8a61679c0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a61679c0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55a8845fe5e0\nStubPtr->Data.Buff.BasePtr=0x55a8a61679e0 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a61679e0\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55a8845fcd20\nStubPtr->Data.Buff.BasePtr=0x55a8a6167a00 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a6167a00\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55a8845f9600\nStubPtr->Data.Buff.BasePtr=0x55a8a6167a20 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a6167a20\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=int32\nUT_GetStubEntry returned StubPtr=0x55a8845fe040\nStubPtr->Data.Buff.BasePtr=0x55a8a6167a40 Position=4 ContentTypeStr=int32\nUT_Stub_GetReturnValuePtr exiting, ReturnPtr=0x55a8a6167a40\nUT_Stub_GetReturnValuePtr entry: ReturnSize=4 TypeName=osal_id_t\nUT_GetStubEntry returned StubPtr=0x55a8845f27c0\nStubPtr->Data.Buff.BasePtr=0x55a8a61679a0 Position=4 ContentTypeStr=osal_id_t\nUT_Stub_G\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In UT_Stub_GetReturnValuePtr the local StubPtr is only used to read fields (BasePtr, Position, ContentTypeStr) and never to modify the pointed-to UT_StubTableEntry_t. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible, so StubPtr should be declared as const UT_StubTableEntry_t *StubPtr. Assigning the non-const result of UT_GetStubEntry to a pointer-to-const is allowed and requires no API change. The provided test log shows only read accesses and no writes, which confirms the pointer could be const; therefore the report that the code violates Rule 8.13 is correct (noting that 8.13 is a \"should\" guideline rather than a mandatory \"shall\")."
}