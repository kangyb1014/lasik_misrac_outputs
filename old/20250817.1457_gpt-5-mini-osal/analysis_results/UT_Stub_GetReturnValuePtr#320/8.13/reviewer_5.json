{
  "user_message": "An agent A claimed that the following UT_Stub_GetReturnValuePtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_GetReturnValuePtr.\n```c\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable StubPtr is declared as UT_StubTableEntry_t * and assigned from UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER). In UT_Stub_GetReturnValuePtr StubPtr is only used for read-only access (inspecting fields), so it could and should be declared as a pointer to const (const UT_StubTableEntry_t *StubPtr). Therefore Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned long UT_EntryKey_t;\ntypedef struct {\n    void *BasePtr;\n    size_t Position;\n    const char *ContentTypeStr;\n} UT_BufferData_t;\nextern void UtAssert_Abort(const char *Message);\nextern void UtAssert_Failed(const char *Format, ...);\nstatic void UT_Probe_Log_ReturnValue(const char *stage, UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName, UT_StubTableEntry_t *StubPtr)\n{\n    FILE *f = fopen(\"/tmp/logs/2563.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be performed, do not change program behavior. */\n        return;\n    }\n\n    fprintf(f, \"[UT_Stub_GetReturnValuePtr] stage=%s\\n\", stage);\n    fprintf(f, \"  FuncKey=%lu\\n\", (unsigned long)FuncKey);\n    fprintf(f, \"  ReturnSize=%lu\\n\", (unsigned long)ReturnSize);\n    fprintf(f, \"  TypeName=%s\\n\", TypeName ? TypeName : \"(null)\");\n    fprintf(f, \"  StubPtr=%p\\n\", (void *)StubPtr);\n\n    if (StubPtr != NULL)\n    {\n        /* Log the fields that are inspected in the function */\n        fprintf(f, \"  Data.Buff.BasePtr=%p\\n\", (void *)StubPtr->Data.Buff.BasePtr);\n        fprintf(f, \"  Data.Buff.Position=%lu\\n\", (unsigned long)StubPtr->Data.Buff.Position);\n        fprintf(f, \"  Data.Buff.ContentTypeStr=%s\\n\", StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\");\n\n        /* Log the result of comparisons used later so callers can reproduce mismatch */\n        fprintf(f, \"  Position_matches=%s\\n\", (StubPtr->Data.Buff.Position == ReturnSize) ? \"true\" : \"false\");\n        fprintf(f, \"  Type_matches=%s\\n\", (StubPtr->Data.Buff.ContentTypeStr && TypeName && strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) == 0) ? \"true\" : \"false\");\n    }\n    fprintf(f, \"----\\n\");\n\n    fclose(f);\n}\n\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    /* Log initial state after obtaining the stub entry */\n    UT_Probe_Log_ReturnValue(\"after_get_entry\", FuncKey, ReturnSize, TypeName, StubPtr);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UT_Probe_Log_ReturnValue(\"about_to_abort\", FuncKey, ReturnSize, TypeName, StubPtr);\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            /* Log the mismatch details before asserting failure */\n            UT_Probe_Log_ReturnValue(\"mismatch_detected\", FuncKey, ReturnSize, TypeName, StubPtr);\n\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    /* Final state/log before returning */\n    UT_Probe_Log_ReturnValue(\"returning\", FuncKey, ReturnSize, TypeName, StubPtr);\n\n    return ReturnPtr;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the function StubPtr is only used to read fields (no writes through StubPtr), so it can and should be declared as a pointer to const (const UT_StubTableEntry_t *StubPtr) to satisfy MISRA C 2023 Rule 8.13. Converting UT_StubTableEntry_t * to const UT_StubTableEntry_t * is allowed without a cast and does not change the observable behavior (members may still be read; attempts to modify via StubPtr would be prohibited). The failing test/logging compile is unrelated to the correctness of the rule violation claim. Therefore the report is correct."
}