{
  "user_message": "An agent A claimed that the following OS_SocketOpen code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketOpen.\n```c\nint32 OS_SocketOpen(osal_id_t *sock_id, OS_SocketDomain_t Domain, OS_SocketType_t Type)\n{\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n\n    /* Check for NULL pointers */\n    OS_CHECK_POINTER(sock_id);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Save all the data to our own internal table */\n        memset(stream, 0, sizeof(OS_stream_internal_record_t));\n        stream->socket_domain = Domain;\n        stream->socket_type   = Type;\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_SocketOpen_Impl(&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sock_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the callee OS_SocketOpen_Impl is declared to take a pointer to a non-const token (e.g. int32 OS_SocketOpen_Impl(OS_object_token_t *token)) but does not modify the token, then this violates MISRA C 2023 Rule 8.13. The pointer parameter should be const-qualified (e.g. const OS_object_token_t *token) when the function only reads the token. If, however, OS_SocketOpen_Impl actually needs to modify the token, then the non-const pointer is appropriate and no violation occurs.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_append(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1995.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    (void)vfprintf(f, fmt, args);\n    va_end(args);\n\n    (void)fclose(f);\n}\nstatic void probe_log_token(const char *label, const void *token_ptr, size_t token_size)\n{\n    const unsigned char *p = (const unsigned char *)token_ptr;\n    /* Prepare a hex representation. Limit to 128 bytes to avoid huge logs. */\n    const size_t max_bytes = 128U;\n    size_t bytes_to_log = (token_size < max_bytes) ? token_size : max_bytes;\n    char hexbuf[256]; /* 2 hex chars per byte + NUL */\n    size_t i;\n\n    for (i = 0U; i < bytes_to_log; ++i)\n    {\n        /* Each byte writes two chars, ensure we don't overflow hexbuf. */\n        unsigned int v = p[i];\n        (void)sprintf(&hexbuf[i * 2], \"%02X\", v);\n    }\n    hexbuf[bytes_to_log * 2] = '\\0';\n\n    log_append(\"%s: token_addr=%p token_size=%zu bytes_logged=%zu hex=%s\\n\",\n               label, token_ptr, token_size, bytes_to_log, hexbuf);\n}\nstatic void probe_log_stream(const void *stream_ptr, int domain, int type)\n{\n    log_append(\"stream_addr=%p socket_domain=%d socket_type=%d\\n\",\n               stream_ptr, domain, type);\n}\n\nint32 OS_SocketOpen(osal_id_t *sock_id, OS_SocketDomain_t Domain, OS_SocketType_t Type)\n{\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n\n    /* Check for NULL pointers */\n    OS_CHECK_POINTER(sock_id);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Save all the data to our own internal table */\n        memset(stream, 0, sizeof(OS_stream_internal_record_t));\n        stream->socket_domain = Domain;\n        stream->socket_type   = Type;\n\n        /* Log state before calling OS-specific implementation */\n        probe_log_stream((const void *)stream, (int)stream->socket_domain, (int)stream->socket_type);\n        probe_log_token(\"before_OS_SocketOpen_Impl\", (const void *)&token, sizeof(token));\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_SocketOpen_Impl(&token);\n\n        /* Log results right after the OS-specific implementation returns */\n        log_append(\"OS_SocketOpen_Impl returned %ld\\n\", (long)return_code);\n        probe_log_token(\"after_OS_SocketOpen_Impl\", (const void *)&token, sizeof(token));\n        probe_log_stream((const void *)stream, (int)stream->socket_domain, (int)stream->socket_type);\n\n        /* Check result, finalize record, and unlock global table. */\n        log_append(\"calling OS_ObjectIdFinalizeNew with rc=%ld\\n\", (long)return_code);\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sock_id);\n        log_append(\"OS_ObjectIdFinalizeNew returned %ld\\n\", (long)return_code);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketOpen. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's reasoning about const-correctness is conceptually correct: MISRA C 2023 Rule 8.13 calls for pointer types to be const-qualified when the pointed-to object is not modified, so a function parameter declared as OS_object_token_t * that does not modify the token should instead be declared const OS_object_token_t *.\n\nHowever, the code shown (the OS_SocketOpen caller) does not itself demonstrate a violation. The rule applies to the function declaration/definition that takes the pointer (i.e. OS_SocketOpen_Impl), and whether that function modifies the token must be determined by inspecting its prototype/body. Since the OS_SocketOpen_Impl declaration/definition is not provided, one cannot conclude from the caller alone that a MISRA 8.13 violation exists. It is also valid for the caller to pass the address of a non-const object to a function that accepts either a const or non-const pointer; the violation would be in the callee's signature if it promises mutability (non-const) but in fact does not mutate.\n\nRecommendation: examine the OS_SocketOpen_Impl prototype and implementation. If it does not modify the token, change its parameter to const OS_object_token_t * (and update all callers) to satisfy Rule 8.13. If it does modify the token (or must by API design), then the non-const parameter is appropriate and no MISRA violation occurs."
}