{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nLENGTHCHECK(name, OS_MAX_API_NAME, ...) likely computes the length of the C string (e.g. via strlen(name)) and compares to OS_MAX_API_NAME. ARGCHECK only ensures name != NULL, it does not guarantee the buffer is null-terminated or that the accessible object is at least OS_MAX_API_NAME+1 bytes long. If LENGTHCHECK uses an unbounded routine such as strlen(name) (or any other <string.h> function that scans until NUL), and the caller supplies a non\u2011terminated or too\u2011short buffer, the scan can read past the end of the object \u2014 violating MISRA C 2023 Rule 21.17. A compliant implementation must use a bounded operation (e.g. strnlen/strnlen_s or otherwise ensure the buffer length is known) or otherwise guarantee the referenced object is NUL-terminated within bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CountSemGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1159.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CountSemGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CountSemGetIdByName:\n```c\nint32 OS_CountSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_POINTER(sem_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CountSemGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Probe logging helper: append control-flow and state info to /tmp/logs/1159.txt */\nstatic void os_countsem_log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1159.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging, do not change program behavior on failure */\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_CountSemGetIdByName(osal_id_t *sem_id, const char *sem_name)\n{\n    int32 return_code;\n\n    /* Log entry and raw pointer values (do not dereference sem_name to avoid introducing extra reads) */\n    os_countsem_log_probe(\"ENTER OS_CountSemGetIdByName: sem_id=%p, sem_name=%p\", (void *)sem_id, (const void *)sem_name);\n\n    /* Check parameters (preserve original checks) */\n    OS_CHECK_POINTER(sem_id);\n    os_countsem_log_probe(\"After OS_CHECK_POINTER(sem_id): sem_id=%p\", (void *)sem_id);\n\n    OS_CHECK_POINTER(sem_name);\n    os_countsem_log_probe(\"After OS_CHECK_POINTER(sem_name): sem_name=%p\", (const void *)sem_name);\n\n    /* Log intent to call the lookup routine (this is where an unbounded scan such as strlen might occur) */\n    os_countsem_log_probe(\"Calling OS_ObjectIdFindByName with sem_name=%p\", (const void *)sem_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, sem_name, sem_id);\n\n    /* Log result and, if sem_id pointer is non-NULL, the value stored there (best-effort, do not alter behavior) */\n    if (sem_id != NULL)\n    {\n        /* Cast to integer for printing; do not assume size of osal_id_t, present best-effort value */\n        os_countsem_log_probe(\"OS_ObjectIdFindByName returned %ld, *sem_id=%lu\", (long) return_code, (unsigned long) (uintptr_t) *sem_id);\n    }\n    else\n    {\n        os_countsem_log_probe(\"OS_ObjectIdFindByName returned %ld, sem_id was NULL\", (long) return_code);\n    }\n\n    return return_code;\n}\n"
}