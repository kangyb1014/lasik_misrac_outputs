{
  "user_message": "An agent A claimed that the following OS_GetResourceName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_GetResourceName.\n```c\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        if (record->name_entry != NULL)\n        {\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'record' is declared as a non-const pointer (OS_common_record_t *record) but in this function it is only used for read-only access (record = OS_ObjectIdGlobalFromToken(&token); check record->name_entry; memcpy from record->name_entry). Since the object is not modified via this pointer, MISRA C 2023 Rule 8.13 requires it should be declared to point to a const-qualified type (const OS_common_record_t *record). Thus the current declaration violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* Probe: log function entry and initial parameters */\n    {\n        FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"OS_GetResourceName ENTRY: buffer=%p buffer_size=%zu\\n\", (void *)buffer, buffer_size);\n            fclose(f);\n        }\n    }\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n\n    /* Probe: log result of ObjectIdGetById */\n    {\n        FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"OS_ObjectIdGetById returned %d\\n\", (int)return_code);\n            fclose(f);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        /* Probe: log the obtained record pointer */\n        {\n            FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"record pointer=%p\\n\", (void *)record);\n                fclose(f);\n            }\n        }\n\n        if (record->name_entry != NULL)\n        {\n            /* Probe: log name_entry pointer and a truncated preview of the name */\n            {\n                FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n                if (f != NULL)\n                {\n                    /* limit preview length to avoid overly large logs */\n                    size_t preview_len = 0u;\n                    const char *name_ptr = record->name_entry;\n                    if (name_ptr != NULL)\n                    {\n                        preview_len = strlen(name_ptr);\n                        if (preview_len > 128u)\n                        {\n                            preview_len = 128u;\n                        }\n                    }\n\n                    fprintf(f, \"record->name_entry=%p preview_len=%zu \");\n                    if (name_ptr != NULL)\n                    {\n                        /* print safe truncated preview */\n                        fprintf(f, \"preview=\\\"\");\n                        fwrite(name_ptr, 1, preview_len, f);\n                        if (strlen(name_ptr) > preview_len)\n                        {\n                            fprintf(f, \"...\\\"\");\n                        }\n                        else\n                        {\n                            fprintf(f, \"\\\"\");\n                        }\n                    }\n                    else\n                    {\n                        fprintf(f, \"(null)\");\n                    }\n                    fprintf(f, \"\\n\");\n                    fclose(f);\n                }\n            }\n\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n\n                /* Probe: log name too long condition */\n                {\n                    FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n                    if (f != NULL)\n                    {\n                        fprintf(f, \"Name too long: original_len=%zu truncated_len=%zu\\n\", name_len + 1u, name_len);\n                        fclose(f);\n                    }\n                }\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n\n            /* Probe: log final buffer contents (truncated) */\n            {\n                FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n                if (f != NULL)\n                {\n                    size_t preview = strlen(buffer);\n                    if (preview > 256u)\n                    {\n                        preview = 256u;\n                    }\n                    fprintf(f, \"Final buffer (len=%zu) preview=\\\"\", strlen(buffer));\n                    fwrite(buffer, 1, preview, f);\n                    if (strlen(buffer) > preview)\n                    {\n                        fprintf(f, \"...\\\"\\n\");\n                    }\n                    else\n                    {\n                        fprintf(f, \"\\\"\\n\");\n                    }\n                    fclose(f);\n                }\n            }\n        }\n        else\n        {\n            /* Probe: log missing name_entry */\n            FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"record->name_entry is NULL\\n\");\n                fclose(f);\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Probe: log token release and return code */\n        {\n            FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"OS_ObjectIdRelease called, returning %d\\n\", (int)return_code);\n                fclose(f);\n            }\n        }\n    }\n    else\n    {\n        /* Probe: log early failure return code */\n        FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"Early exit with return_code=%d\\n\", (int)return_code);\n            fclose(f);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_GetResourceName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever it is only used for read-only access. In OS_GetResourceName the local pointer record is assigned from OS_ObjectIdGlobalFromToken(&token) and is only used to read record->name_entry (no writes through record or to its members occur in this function). Therefore declaring it as const OS_common_record_t *record would be appropriate and would satisfy Rule 8.13. Assigning the non-const return value of OS_ObjectIdGlobalFromToken to a pointer-to-const is permitted and does not change the member types (e.g. name_entry remains its declared type), so the memcpy usage remains valid. The only caveat is if other callers or subsequent changes require modifying the object via this pointer or passing it to APIs that take a non-const pointer; in that case making it const would be incompatible and a deviation would be needed. Given the shown code though, agent A\u2019s identification of a Rule 8.13 violation is correct."
}