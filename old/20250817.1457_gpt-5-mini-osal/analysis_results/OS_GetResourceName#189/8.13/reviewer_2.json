{
  "user_message": "An agent A claimed that the following OS_GetResourceName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_GetResourceName.\n```c\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        if (record->name_entry != NULL)\n        {\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:This line passes record->name_entry as the source to memcpy. If record->name_entry is declared as a non-const pointer (e.g. char *name_entry) but the pointed-to string is not modified through that pointer, then Rule 8.13 is violated \u2014 the pointer should be declared const char *name_entry (or otherwise const-qualified) because it is used as read-only data. If, instead, record->name_entry is already declared as const char * (or equivalent const-qualified type), no rule violation occurs.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_GetResourceName_LogProbe(const char *stage,\n                                       void *object_id_ptr,\n                                       const void *record_ptr,\n                                       const char *name_entry,\n                                       const char *buffer_ptr,\n                                       size_t buffer_size,\n                                       size_t name_len,\n                                       int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1515.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Best-effort logging; do not alter program flow on failure */\n    }\n\n    fprintf(f, \"[OS_GetResourceName] Stage: %s\\n\", stage);\n    fprintf(f, \"  object_id ptr: %p\\n\", object_id_ptr);\n    fprintf(f, \"  record ptr: %p\\n\", record_ptr);\n    fprintf(f, \"  name_entry ptr: %p\\n\", (const void *)name_entry);\n    if (name_entry != NULL)\n    {\n        /* Print up to name_len characters to avoid overruns */\n        fprintf(f, \"  name_entry (len=%zu): '%.*s'\\n\", name_len, (int)name_len, name_entry);\n    }\n    else\n    {\n        fprintf(f, \"  name_entry: NULL\\n\");\n    }\n    fprintf(f, \"  buffer ptr: %p\\n\", (const void *)buffer_ptr);\n    fprintf(f, \"  buffer_size: %zu\\n\", buffer_size);\n    fprintf(f, \"  name_len used for copy: %zu\\n\", name_len);\n    fprintf(f, \"  return_code: %d\\n\", (int)return_code);\n    fprintf(f, \"----------------------------------------\\n\");\n\n    fclose(f);\n}\n\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /* Log entry state */\n    OS_GetResourceName_LogProbe(\"entry\", (void *)(uintptr_t)object_id, NULL, NULL, buffer, buffer_size, 0u, 0);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n\n    /* Log after attempting to get object by id */\n    OS_GetResourceName_LogProbe(\"after_ObjectIdGetById\", (void *)(uintptr_t)object_id, NULL, NULL, buffer, buffer_size, 0u, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        /* Log record pointer obtained */\n        OS_GetResourceName_LogProbe(\"got_record\", (void *)(uintptr_t)object_id, (void *)record, NULL, buffer, buffer_size, 0u, return_code);\n\n        if (record->name_entry != NULL)\n        {\n            /* Measure the name length (bounded) */\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n\n            /* Log name and measured length before potential truncation */\n            OS_GetResourceName_LogProbe(\"before_truncate_check\", (void *)(uintptr_t)object_id, (void *)record, record->name_entry, buffer, buffer_size, name_len, return_code);\n\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1u;\n\n                /* Log the truncation decision */\n                OS_GetResourceName_LogProbe(\"name_too_long_truncating\", (void *)(uintptr_t)object_id, (void *)record, record->name_entry, buffer, buffer_size, name_len, return_code);\n            }\n\n            /* Log the memcpy details just before copy */\n            OS_GetResourceName_LogProbe(\"before_memcpy\", (void *)(uintptr_t)object_id, (void *)record, record->name_entry, buffer, buffer_size, name_len, return_code);\n\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n\n            /* Log buffer contents after copy (bounded) */\n            OS_GetResourceName_LogProbe(\"after_memcpy\", (void *)(uintptr_t)object_id, (void *)record, record->name_entry, buffer, buffer_size, name_len, return_code);\n        }\n        else\n        {\n            /* Log that there was no name entry */\n            OS_GetResourceName_LogProbe(\"name_entry_null\", (void *)(uintptr_t)object_id, (void *)record, NULL, buffer, buffer_size, 0u, return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after releasing token */\n        OS_GetResourceName_LogProbe(\"after_release\", (void *)(uintptr_t)object_id, (void *)record, (record != NULL) ? record->name_entry : NULL, buffer, buffer_size, (record != NULL) ? OS_strnlen(record->name_entry, buffer_size) : 0u, return_code);\n    }\n\n    /* Final return - log final state */\n    OS_GetResourceName_LogProbe(\"exit\", (void *)(uintptr_t)object_id, (void *)((return_code == OS_SUCCESS) ? record : NULL), (return_code == OS_SUCCESS && record != NULL) ? record->name_entry : NULL, buffer, buffer_size, (return_code == OS_SUCCESS && record != NULL) ? OS_strnlen(buffer, buffer_size) : 0u, return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_GetResourceName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s concern is plausible but cannot be confirmed from the snippet alone. MISRA C:2023 Rule 8.13 advises that a pointer should point to a const-qualified type whenever that is possible. The mere use of record->name_entry as the source argument to memcpy does not by itself violate the rule (memcpy expects a const void *src). Whether a rule violation exists depends on the declaration of name_entry in OS_common_record_t:\n\n- If name_entry is declared as a non-const pointer (e.g. char *name_entry) but the pointed-to string is never modified through that pointer (it is effectively read-only), then Rule 8.13 is being violated and name_entry should be declared const char * (or otherwise const-qualified).\n- If name_entry is already declared const char * (or another const-qualified type), then there is no violation.\n- If name_entry is intentionally mutable and other code modifies the contents, then it must remain non-const and no violation occurs.\n\nTherefore the report is inconclusive given the provided code: it is correct as a possible scenario but cannot be established as an actual violation without inspecting the declaration and usage of OS_common_record_t::name_entry. Recommendations: inspect the definition and all usages of name_entry; if it is never modified, change its type to const char * to satisfy Rule 8.13; if it is modified elsewhere, leave it non-const and document why const cannot be used."
}