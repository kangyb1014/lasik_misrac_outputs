{
  "user_message": "An agent A claimed that the following OS_GetResourceName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_GetResourceName.\n```c\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /*\n     * Initially set the output string to empty.\n     * This avoids undefined behavior in case the function fails\n     * and the caller does not check the return code.\n     */\n    buffer[0] = 0;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n\n        if (record->name_entry != NULL)\n        {\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If record->name_entry refers to a char object whose storage is smaller than the caller-supplied buffer_size (for example name_entry is a 16-byte array or points to a shorter allocation but buffer_size is 32) and there is no NUL within the first buffer_size bytes, OS_strnlen(record->name_entry, buffer_size) may read beyond the end of the object. Passing the destination buffer size instead of the actual size of the source object allows the strnlen implementation to access bytes past the source object, which violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_probe(const char *stage,\n                         osal_id_t object_id,\n                         const void *buffer,\n                         size_t buffer_size,\n                         const OS_common_record_t *record,\n                         const char *name_entry,\n                         int return_code,\n                         size_t name_len)\n{\n    FILE *f = fopen(\"/tmp/logs/1519.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, do not change program behavior. */\n        return;\n    }\n\n    /* Write a concise line containing the probe stage and key state. Do not\n       dereference name_entry (to avoid further out-of-bounds reads); only log\n       the pointer value and the sizes involved. */\n    (void)fprintf(f,\n                  \"stage=%s object_id=0x%lx buffer=%p buffer_size=%zu record=%p name_entry=%p return_code=%d name_len=%zu\\n\",\n                  stage,\n                  (unsigned long)object_id,\n                  buffer,\n                  buffer_size,\n                  (const void *)record,\n                  (const void *)name_entry,\n                  return_code,\n                  name_len);\n\n    fclose(f);\n}\n\nint32 OS_GetResourceName(osal_id_t object_id, char *buffer, size_t buffer_size)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    size_t              name_len;\n    OS_object_token_t   token;\n\n    /* sanity check the passed-in buffer and size */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buffer_size);\n\n    /* Initially set the output string to empty. */\n    buffer[0] = 0;\n\n    /* Log entry to function with initial arguments. */\n    os_log_probe(\"entry\", object_id, buffer, buffer_size, NULL, NULL, 0, 0);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_ObjectIdToType_Impl(object_id), object_id, &token);\n    os_log_probe(\"after_ObjectIdGetById\", object_id, buffer, buffer_size, NULL, NULL, (int)return_code, 0);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_ObjectIdGlobalFromToken(&token);\n        os_log_probe(\"after_ObjectIdGlobalFromToken\", object_id, buffer, buffer_size, record, NULL, (int)return_code, 0);\n\n        if (record->name_entry != NULL)\n        {\n            /* Log before calling OS_strnlen so callers can see the exact parameters that may lead\n               to an out-of-bounds read in some configurations. Do NOT attempt to read the contents\n               of name_entry here; only log the pointer and sizes. */\n            os_log_probe(\"before_strnlen\", object_id, buffer, buffer_size, record, record->name_entry, (int)return_code, 0);\n\n            name_len = OS_strnlen(record->name_entry, buffer_size);\n\n            /* Log result returned by OS_strnlen. This, combined with the prior log, documents\n               the values involved in the potential violation scenario. */\n            os_log_probe(\"after_strnlen\", object_id, buffer, buffer_size, record, record->name_entry, (int)return_code, name_len);\n\n            if (buffer_size <= name_len)\n            {\n                /* indicates the name does not fit into supplied buffer */\n                return_code = OS_ERR_NAME_TOO_LONG;\n                name_len    = buffer_size - 1;\n                os_log_probe(\"name_too_long\", object_id, buffer, buffer_size, record, record->name_entry, (int)return_code, name_len);\n            }\n            memcpy(buffer, record->name_entry, name_len);\n            buffer[name_len] = 0;\n\n            os_log_probe(\"after_memcpy\", object_id, buffer, buffer_size, record, record->name_entry, (int)return_code, name_len);\n        }\n        else\n        {\n            os_log_probe(\"name_entry_null\", object_id, buffer, buffer_size, record, NULL, (int)return_code, 0);\n        }\n\n        OS_ObjectIdRelease(&token);\n        os_log_probe(\"after_release\", object_id, buffer, buffer_size, record, (record != NULL) ? record->name_entry : NULL, (int)return_code, name_len);\n    }\n\n    os_log_probe(\"exit\", object_id, buffer, buffer_size, (return_code == OS_SUCCESS) ? record : NULL, (return_code == OS_SUCCESS && record != NULL) ? record->name_entry : NULL, (int)return_code, (return_code == OS_SUCCESS) ? name_len : 0);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_GetResourceName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 21.17 forbids calling the string-handling functions in a way that can access beyond the bounds of the object(s) referenced by their pointer parameters. In the code shown, OS_strnlen(record->name_entry, buffer_size) uses the caller-supplied destination buffer_size as the maximum number of bytes to examine in the source string record->name_entry. There is no evidence in the function that record->name_entry has storage at least buffer_size bytes long (or contains a NUL within the first buffer_size bytes). If record->name_entry actually refers to a smaller object (for example an array or allocation smaller than buffer_size) and no NUL appears within the first buffer_size bytes, the strnlen implementation may read past the end of the source object \u2014 which is an out-of-bounds access and therefore violates Rule 21.17.\n\nThe subsequent memcpy is not the primary problem here; memcpy uses name_len computed from OS_strnlen and is guarded so it won\u2019t write past the destination, but the call to OS_strnlen itself can produce an out-of-bounds read of the source. To fix this the code must ensure the second argument to strnlen is an upper bound that does not exceed the actual storage size of record->name_entry (for example a stored source-size field or a compile-time known maximum for name_entry), or otherwise guarantee that name_entry is NUL-terminated within a known maximum and use that known maximum instead of the caller-supplied buffer_size."
}