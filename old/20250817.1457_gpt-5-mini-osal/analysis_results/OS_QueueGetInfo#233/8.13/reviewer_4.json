{
  "user_message": "An agent A claimed that the following OS_QueueGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGetInfo.\n```c\nint32 OS_QueueGetInfo(osal_id_t queue_id, OS_queue_prop_t *queue_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(queue_prop);\n\n    memset(queue_prop, 0, sizeof(OS_queue_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_queue_table, token);\n\n        strncpy(queue_prop->name, record->name_entry, sizeof(queue_prop->name) - 1);\n        queue_prop->creator = record->creator;\n\n        /*\n         * Currently there are no additional queue details provided by the impl layer -\n         * But this could be added in the future (i.e. current/max depth, msg size, etc)\n         */\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'record' is declared as OS_common_record_t * but is only used to read fields (record->name_entry and record->creator). It could and should be declared as const OS_common_record_t *record to reflect read-only access. Assigning the result of OS_OBJECT_TABLE_GET (which yields OS_common_record_t *) to a pointer-to-const is allowed, so the current non-const declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OSAL_log_queue_get_info(const char *stage, osal_id_t queue_id, OS_common_record_t *record, int32 return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1867.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log basic control-flow information */\n    fprintf(f, \"OS_QueueGetInfo: stage=%s, queue_id=%lu, return_code=%ld, record=%p\\n\",\n            stage, (unsigned long)queue_id, (long)return_code, (void *)record);\n\n    /* If a record pointer is available, log the read-only fields used by the function */\n    if (record != NULL)\n    {\n        /* Protect against missing/invalid strings by printing up to a reasonable length */\n        if (record->name_entry != NULL)\n        {\n            fprintf(f, \"  record->name_entry=\\\"%s\\\"\\n\", record->name_entry);\n        }\n        else\n        {\n            fprintf(f, \"  record->name_entry=(NULL)\\n\");\n        }\n\n        fprintf(f, \"  record->creator=%lu\\n\", (unsigned long)record->creator);\n    }\n\n    fclose(f);\n}\n\nint32 OS_QueueGetInfo(osal_id_t queue_id, OS_queue_prop_t *queue_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Log entry into function and parameter values */\n    OSAL_log_queue_get_info(\"entry\", queue_id, NULL, -1);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(queue_prop);\n\n    memset(queue_prop, 0, sizeof(OS_queue_prop_t));\n\n    /* Log just before calling OS_ObjectIdGetById */\n    OSAL_log_queue_get_info(\"before_ObjectIdGetById\", queue_id, NULL, -1);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, queue_id, &token);\n\n    /* Log the result of OS_ObjectIdGetById */\n    OSAL_log_queue_get_info(\"after_ObjectIdGetById\", queue_id, NULL, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_queue_table, token);\n\n        /* Log the record returned from the object table (reads only) */\n        OSAL_log_queue_get_info(\"after_OBJECT_TABLE_GET\", queue_id, record, return_code);\n\n        strncpy(queue_prop->name, record->name_entry, sizeof(queue_prop->name) - 1);\n        queue_prop->creator = record->creator;\n\n        /* Log after copying fields into queue_prop */\n        OSAL_log_queue_get_info(\"after_copy_fields\", queue_id, record, return_code);\n\n        /*\n         * Currently there are no additional queue details provided by the impl layer -\n         * But this could be added in the future (i.e. current/max depth, msg size, etc)\n         */\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after releasing the object token */\n        OSAL_log_queue_get_info(\"after_ObjectIdRelease\", queue_id, record, return_code);\n    }\n\n    /* Log exit from function */\n    OSAL_log_queue_get_info(\"exit\", queue_id, NULL, return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nOS_QueueGetInfo: stage=entry, queue_id=3735928559, return_code=-1, record=(nil)\nOS_QueueGetInfo: stage=before_ObjectIdGetById, queue_id=3735928559, return_code=-1, record=(nil)\nOS_QueueGetInfo: stage=after_ObjectIdGetById, queue_id=3735928559, return_code=-35, record=(nil)\nOS_QueueGetInfo: stage=exit, queue_id=3735928559, return_code=-35, record=(nil)\nOS_QueueGetInfo: stage=entry, queue_id=0, return_code=-1, record=(nil)\nOS_QueueGetInfo: stage=before_ObjectIdGetById, queue_id=0, return_code=-1, record=(nil)\nOS_QueueGetInfo: stage=after_ObjectIdGetById, queue_id=0, return_code=-35, record=(nil)\nOS_QueueGetInfo: stage=exit, queue_id=0, return_code=-35, record=(nil)\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_QueueGetInfo the local pointer record is only used to read fields (record->name_entry and record->creator) and is never used to modify the pointed-to object. MISRA C 2023 Rule 8.13 requires a pointer to point to a const-qualified type whenever possible; therefore record should be declared as const OS_common_record_t *record. Assigning the non-const result of OS_OBJECT_TABLE_GET to a pointer-to-const is permitted in C, so the current non-const declaration violates Rule 8.13."
}