{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "memcpy",
    "size_t"
  ],
  "explanation": "- UT_StubTableEntry_t: The full struct definition (including nested Data/Buff/BasePtr/Position/TotalSize fields and their types) is required to see whether any non\u2011standard language constructs (e.g. flexible array members used as extensions, bit\u2011fields with implementation\u2011defined widths, compiler specific attributes on members) are present. These details determine if the code is relying on compiler extensions when accessing members (BasePtr[Position], arithmetic on Position/TotalSize).\n- UT_EntryKey_t: The typedef for the function key is needed to check whether it uses any compiler extensions (e.g. unusual integer types, typedefs with attributes) that would violate the MISRA rule.\n- UT_ENTRYTYPE_DATA_BUFFER: The macro/enum value used as the second argument to UT_GetStubEntry must be inspected to ensure it is a simple compile\u2011time constant and not produced by a compiler extension or exotic macro construct.\n- UT_GetStubEntry: The prototype/definition is required to confirm it uses only standard C syntax (no compiler extensions in its declaration, return type, parameter attributes, or calling convention) and to see any attributes that could affect how the returned pointer is used.\n- UT_ClearStubEntry: The prototype/definition is needed to check for attributes or nonstandard linkage/extension use in its declaration/implementation, since it is called conditionally and could introduce extensions.\n- memcpy: The standard library declaration (typically from <string.h>) is required to verify that the function used is the standard memcpy (not a macro or an implementation extension) and that its prototype matches standard C (ensuring no use of compiler-specific overloads or attributes).\n- size_t: The typedef (from <stddef.h>) is necessary to ensure the size type used is the standard one and not a compiler-specific extension or nonstandard width/type definition.\n\nCollecting these symbols (the struct/type definitions and the function prototypes/constants) lets the next analyst determine whether any language/compiler extensions are present in the types, macros, or function declarations used by UT_Stub_CopyFromLocal."
}