{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_StubTable",
    "memcmp",
    "memcpy"
  ],
  "explanation": "List and rationale for each required symbol to determine whether the MISRA rule (\"memcmp shall not be used to compare null terminated strings\") is violated by UT_Stub_CopyFromLocal:\n\n- UT_GetStubEntry: The target calls this function. If UT_GetStubEntry uses memcmp internally to compare keys or strings (e.g., comparing entry keys or names), that would be a violation reachable from the target. We need the implementation to see if memcmp is used and whether it compares null-terminated strings.\n\n- UT_ClearStubEntry: The target calls this function when the buffer has been fully copied. UT_ClearStubEntry might use memcmp (for example to match entries) or otherwise perform comparisons of strings; its implementation must be inspected for memcmp usage.\n\n- UT_StubTableEntry_t: The target accesses fields of this struct (Data.Buff.BasePtr, Position, TotalSize). We need the exact types (e.g., is BasePtr a char * or void *) and semantics (is the buffer a string/NTBS) to judge whether any comparisons (in called code) would be comparing null-terminated strings and whether memcpy usage here is operating on raw bytes or string data.\n\n- UT_EntryKey_t: The key type used to look up stub entries may be a string type (or contain strings). If UT_GetStubEntry compares keys with memcmp, knowing the key type tells us whether that memcmp would be comparing null-terminated strings.\n\n- UT_ENTRYTYPE_DATA_BUFFER: The constant passed to UT_GetStubEntry may influence how entries are searched/compared. Its meaning could change which code-path in UT_GetStubEntry is executed (and whether memcmp is used on string data).\n\n- UT_StubTable (global storage referenced by UT_GetStubEntry/UT_ClearStubEntry): If the lookup/clear implementations iterate/search a global table and compare stored keys or names with the provided key, the table definition (element types) is required to see if string comparisons occur and if memcmp is used on NTBS.\n\n- memcmp: The MISRA rule is about use of memcmp on null-terminated strings; include the symbol so the analyzer can identify any use sites and check the argument types and semantics (whether arguments are NTBS).\n\n- memcpy: The target uses memcpy. While memcpy itself is not the subject of this MISRA rule, knowing its prototype and how it is used (arguments, lengths) helps confirm that the function performs byte-wise copying rather than string comparison. Also useful to ensure no misuse that might indirectly involve string semantics.\n\nIn short: inspect UT_GetStubEntry and UT_ClearStubEntry implementations and the related data types/globals (entry struct, key type and entry-type constant) to find any memcmp usage and to determine whether such usages compare null-terminated strings. Also include memcmp/memcpy prototypes to reason about argument types and semantics."
}