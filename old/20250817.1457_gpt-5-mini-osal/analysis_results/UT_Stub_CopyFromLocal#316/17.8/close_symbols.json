{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyFromLocal(UT_EntryKey_t FuncKey, const void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], LocalBuffer, ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyFromLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_SetLocalTime', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_printf', 'UT_DefaultHandler_OS_SocketSendTo']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_SetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_printf': {'callees': ['UT_Hook_GetArgPtr', 'UtAssert_Message', 'UT_Stub_CopyFromLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t (typedef/declaration)",
    "UT_StubTableEntry_t (complete struct/union definition, including Data and Buff sub-structure and fields BasePtr, Position, TotalSize)",
    "UT_GetStubEntry (prototype)",
    "UT_ClearStubEntry (prototype)",
    "memcpy (prototype from <string.h>)",
    "size_t (typedef)"
  ],
  "explanation": "- UT_EntryKey_t: needed to know the underlying type of the FuncKey parameter (scalar, pointer, struct). MISRA C forbids modifying a function parameter itself; if UT_EntryKey_t were a pointer type or an array type passed as pointer, that affects whether operations could modify the parameter object vs. the object it points to. The declaration/prototype shows whether FuncKey is passed by value or by reference-like type.\n\n- UT_StubTableEntry_t (full definition): the function dereferences StubPtr and updates StubPtr->Data.Buff.Position and writes into StubPtr->Data.Buff.BasePtr. To judge compliance we must see the types of BasePtr, Position and TotalSize (e.g., whether Position/TotalSize are size_t, and BasePtr is a pointer) and confirm these are not aliases of any function parameter. This struct definition is required to determine whether any modifications affect a parameter object (disallowed) or an object reachable via a non-parameter pointer (allowed).\n\n- UT_GetStubEntry (prototype): the call UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER) might modify arguments if its prototype takes pointers/refs. The prototype shows if FuncKey is passed by value or by pointer and whether UT_GetStubEntry could itself modify the FuncKey parameter passed to UT_Stub_CopyFromLocal (e.g., if it expects a pointer-to-key). We need this to ensure the target function does not indirectly modify its parameter via that call.\n\n- UT_ClearStubEntry (prototype): called with StubPtr; include to confirm it does not take or modify any of the target function parameters and to understand its signature (e.g., if it takes a pointer into StubPtr). This helps demonstrate that no call in the function modifies the function parameters.\n\n- memcpy (prototype): to confirm semantics (memcpy takes void *dest, const void *src, size_t n) so that the call memcpy(..., LocalBuffer, ActualCopy) does not modify the pointer variable LocalBuffer itself (it copies from the memory pointed to, but does not change the pointer parameter). This establishes that passing LocalBuffer to memcpy does not violate the rule by modifying the pointer parameter.\n\n- size_t (typedef): to understand types of MaxSize, ActualCopy, and struct fields Position/TotalSize so we can see whether arithmetic assignments (e.g., Position += ActualCopy) interact with parameter types or could represent aliasing to a parameter object. Knowing the exact typedef ensures correct classification of modified objects vs. parameters.\n\nIncluding these symbols (their declarations/signatures) allows an analyzer to determine whether any assignment or call in UT_Stub_CopyFromLocal modifies a function parameter variable itself (which would violate MISRA) versus modifying objects pointed to by pointer parameters (which is allowed)."
}