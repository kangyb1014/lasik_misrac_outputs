{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CondVarWait:\n```c\nint32 OS_CondVarWait(osal_id_t var_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_CondVarWait_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nreturn_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The &token argument is an output parameter: OS_ObjectIdGetById is expected to store the lookup result into token, so the function needs a mutable pointer. Rule 8.13 requires pointers to be const-qualified only when they are not modified; since this pointer is intended to be modified, no const can be used and there is no violation. (If, conversely, the function did not modify the pointed object, the prototype should have used a pointer to const and that would be a violation.)"
}