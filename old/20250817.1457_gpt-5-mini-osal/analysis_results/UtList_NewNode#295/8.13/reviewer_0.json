{
  "user_message": "An agent A claimed that the following UtList_NewNode code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_NewNode.\n```c\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'void *Data' is used only as the source for memcpy (read-only) and therefore can and should be declared as 'const void *Data'. In the fragment memcpy(AllocNode->Node.Data, Data, DataSize); a non-const pointer is used where a const-qualified pointer is possible (the source argument), so Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } *AllocNode;\n\n    /* Open log file (append) and write initial probe information. */\n    FILE *log = fopen(\"/tmp/logs/2363.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"--- UtList_NewNode ENTRY ---\\n\");\n        fprintf(log, \"Data (source ptr): %p\\n\", (void *)Data);\n        fprintf(log, \"DataSize: %u\\n\", (unsigned)DataSize);\n    }\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + (size_t)DataSize);\n\n    if (log != NULL)\n    {\n        fprintf(log, \"malloc returned: %p (requested %zu bytes)\\n\",\n                (void *)AllocNode,\n                sizeof(union NodeAllocator) + (size_t)DataSize);\n    }\n\n    if (AllocNode == NULL)\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \"malloc failed\\n\");\n            fclose(log);\n        }\n        return NULL;\n    }\n\n    /* Preserve original behavior: still zero the union header only. */\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n\n    /* Compute data storage pointer inside allocated block. */\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n\n    if (log != NULL)\n    {\n        fprintf(log, \"AllocNode address: %p\\n\", (void *)AllocNode);\n        fprintf(log, \"Allocated node payload addr (&AllocNode[1]): %p\\n\",\n                (void *)AllocNode->Node.Data);\n\n        /* Log first up to 64 bytes at source pointer (if readable). */\n        if (Data != NULL && DataSize > 0)\n        {\n            const unsigned char *bytes = (const unsigned char *)Data;\n            unsigned int to_dump = (DataSize > 64u) ? 64u : (unsigned int)DataSize;\n            fprintf(log, \"Dumping first %u bytes of source Data (%p):\\n\", to_dump, (void *)Data);\n            for (unsigned int i = 0; i < to_dump; ++i)\n            {\n                fprintf(log, \"%02X \", bytes[i]);\n                if (((i + 1) % 16) == 0)\n                {\n                    fprintf(log, \"\\n\");\n                }\n            }\n            if ((to_dump % 16) != 0)\n            {\n                fprintf(log, \"\\n\");\n            }\n        }\n        else\n        {\n            fprintf(log, \"No source data to dump (Data is NULL or DataSize==0).\\n\");\n        }\n\n        /* Log intent to call memcpy with these parameters. */\n        fprintf(log, \"About to call memcpy(dest=%p, src=%p, n=%u)\\n\",\n                (void *)AllocNode->Node.Data, (void *)Data, (unsigned)DataSize);\n    }\n\n    /* Perform the copy exactly as original code. */\n    memcpy(AllocNode->Node.Data, Data, (size_t)DataSize);\n\n    if (log != NULL)\n    {\n        fprintf(log, \"memcpy completed.\\n\");\n\n        /* Log the first up to 64 bytes of the destination to confirm copy. */\n        if (AllocNode->Node.Data != NULL && AllocNode->Node.DataSize > 0)\n        {\n            const unsigned char *dst_bytes = (const unsigned char *)AllocNode->Node.Data;\n            unsigned int to_dump = (AllocNode->Node.DataSize > 64u) ? 64u : (unsigned int)AllocNode->Node.DataSize;\n            fprintf(log, \"Dumping first %u bytes of destination (%p):\\n\", to_dump, (void *)AllocNode->Node.Data);\n            for (unsigned int i = 0; i < to_dump; ++i)\n            {\n                fprintf(log, \"%02X \", dst_bytes[i]);\n                if (((i + 1) % 16) == 0)\n                {\n                    fprintf(log, \"\\n\");\n                }\n            }\n            if ((to_dump % 16) != 0)\n            {\n                fprintf(log, \"\\n\");\n            }\n        }\n\n        fprintf(log, \"--- UtList_NewNode EXIT (about to init links & return) ---\\n\\n\");\n        fclose(log);\n    }\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n--- UtList_NewNode ENTRY ---\nData (source ptr): 0x7fff007a2ac0\nDataSize: 64\nmalloc returned: 0x5595060ea940 (requested 96 bytes)\nAllocNode address: 0x5595060ea940\nAllocated node payload addr (&AllocNode[1]): 0x5595060ea960\nDumping first 64 bytes of source Data (0x7fff007a2ac0):\n79 F8 D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 56 78 57 6F 72 \n6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 \n6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00 \nAbout to call memcpy(dest=0x5595060ea960, src=0x7fff007a2ac0, n=64)\nmemcpy completed.\nDumping first 64 bytes of destination (0x5595060ea960):\n79 F8 D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 56 78 57 6F 72 \n6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 \n6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00 \n--- UtList_NewNode EXIT (about to init links & return) ---\n\n--- UtList_NewNode ENTRY ---\nData (source ptr): 0x7fff007a2ac0\nDataSize: 64\nmalloc returned: 0x5595060ea9b0 (requested 96 bytes)\nAllocNode address: 0x5595060ea9b0\nAllocated node payload addr (&AllocNode[1]): 0x5595060ea9d0\nDumping first 64 bytes of source Data (0x7fff007a2ac0):\n41 F9 D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \nAbout to call memcpy(dest=0x5595060ea9d0, src=0x7fff007a2ac0, n=64)\nmemcpy completed.\nDumping first 64 bytes of destination (0x5595060ea9d0):\n41 F9 D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n--- UtList_NewNode EXIT (about to init links & return) ---\n\n--- UtList_NewNode ENTRY ---\nData (source ptr): 0x7fff007a2ac0\nDataSize: 64\nmalloc returned: 0x5595060eaa20 (requested 96 bytes)\nAllocNode address: 0x5595060eaa20\nAllocated node payload addr (&AllocNode[1]): 0x5595060eaa40\nDumping first 64 bytes of source Data (0x7fff007a2ac0):\n31 FB D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \nAbout to call memcpy(dest=0x5595060eaa40, src=0x7fff007a2ac0, n=64)\nmemcpy completed.\nDumping first 64 bytes of destination (0x5595060eaa40):\n31 FB D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n--- UtList_NewNode EXIT (about to init links & return) ---\n\n--- UtList_NewNode ENTRY ---\nData (source ptr): 0x7fff007a2ac0\nDataSize: 64\nmalloc returned: 0x5595060eaa90 (requested 96 bytes)\nAllocNode address: 0x5595060eaa90\nAllocated node payload addr (&AllocNode[1]): 0x5595060eaab0\nDumping first 64 bytes of source Data (0x7fff007a2ac0):\n41 FC D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \nAbout to call memcpy(dest=0x5595060eaab0, src=0x7fff007a2ac0, n=64)\nmemcpy completed.\nDumping first 64 bytes of destination (0x5595060eaab0):\n41 FC D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n--- UtList_NewNode EXIT (about to init links & return) ---\n\n--- UtList_NewNode ENTRY ---\nData (source ptr): 0x7fff007a2ac0\nDataSize: 64\nmalloc returned: 0x5595060eab00 (requested 96 bytes)\nAllocNode address: 0x5595060eab00\nAllocated node payload addr (&AllocNode[1]): 0x5595060eab20\nDumping first 64 bytes of source Data (0x7fff007a2ac0):\n1D FE D2 E2 94 55 00 00 ED 04 D3 E2 94 55 00 00 \n73 05 D3 E2 94 55 00 00 4F 53 5F 42 69 6E 53 65 \n6D 46 6C 75 73 68 5F 49 6D 70 6C 00 00 00 00 00 \n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \nAbout to call memcpy(dest=0x5595060eab20, src=0x7fff007a2ac0, n=64)\nmemcpy completed.\nDumping first 64 bytes of destination (0x55\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function parameter Data is only used as the source for memcpy (read-only) and is not modified or retained; therefore it should be declared as const void *Data to reflect that intent. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible, so the current declaration void *Data violates Rule 8.13. (Note: memcpy's prototype already takes a const void * for the source, reinforcing that the source parameter should be const-qualified.)"
}