{
  "user_message": "An agent A claimed that the following UtList_NewNode code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_NewNode.\n```c\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'Data' is declared as void * but is only read (used as the source for memcpy) and is not modified inside UtList_NewNode. According to MISRA C 2023 Rule 8.13, such a pointer should be declared to point to a const-qualified type. The function should be declared as: UtListNode_t *UtList_NewNode(const void *Data, uint32 DataSize).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    FILE *fp = fopen(\"/tmp/logs/2363.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"UtList_NewNode ENTER: Data=%p DataSize=%u\\n\", (void *)Data, (unsigned)DataSize);\n    }\n\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    size_t alloc_size = sizeof(union NodeAllocator) + (size_t)DataSize;\n    if (fp != NULL)\n    {\n        fprintf(fp, \"Requested allocation size: %zu\\n\", alloc_size);\n    }\n\n    AllocNode = malloc(alloc_size);\n    if (fp != NULL)\n    {\n        fprintf(fp, \"malloc returned: %p\\n\", (void *)AllocNode);\n    }\n\n    /* Preserve original behavior: perform the same memset as original code */\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n\n    if (fp != NULL)\n    {\n        fprintf(fp, \"Node.Data set to: %p Node.DataSize=%u\\n\", (void *)AllocNode->Node.Data, (unsigned)AllocNode->Node.DataSize);\n\n        /* Log a small sample of the source data (up to 64 bytes) for evidence. */\n        unsigned int sample_len = (DataSize > 64u) ? 64u : (unsigned)DataSize;\n        if ((Data != NULL) && (sample_len > 0u))\n        {\n            const unsigned char *src = (const unsigned char *)Data;\n            unsigned int i;\n            fprintf(fp, \"Source sample (%u bytes):\", sample_len);\n            for (i = 0u; i < sample_len; i++)\n            {\n                fprintf(fp, \" %02X\", (unsigned)src[i]);\n            }\n            fprintf(fp, \"\\n\");\n        }\n        else\n        {\n            fprintf(fp, \"Source sample: Data is NULL or size is zero\\n\");\n        }\n\n        fprintf(fp, \"About to memcpy %u bytes from %p to %p\\n\", (unsigned)DataSize, (void *)Data, (void *)AllocNode->Node.Data);\n    }\n\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    if (fp != NULL)\n    {\n        unsigned int sample_len2 = (DataSize > 64u) ? 64u : (unsigned)DataSize;\n        if ((AllocNode->Node.Data != NULL) && (sample_len2 > 0u))\n        {\n            const unsigned char *dst = (const unsigned char *)AllocNode->Node.Data;\n            unsigned int i;\n            fprintf(fp, \"Destination sample after memcpy (%u bytes):\", sample_len2);\n            for (i = 0u; i < sample_len2; i++)\n            {\n                fprintf(fp, \" %02X\", (unsigned)dst[i]);\n            }\n            fprintf(fp, \"\\n\");\n\n            /* Compare the first sample_len2 bytes of source and destination */\n            if (Data != NULL)\n            {\n                const unsigned char *src = (const unsigned char *)Data;\n                unsigned int mismatch = 0u;\n                for (i = 0u; i < sample_len2; i++)\n                {\n                    if (src[i] != dst[i])\n                    {\n                        mismatch = 1u;\n                        break;\n                    }\n                }\n                fprintf(fp, \"Source vs Dest (first %u bytes): %s\\n\", sample_len2, (mismatch ? \"DIFFER\" : \"EQUAL\"));\n            }\n        }\n        else\n        {\n            fprintf(fp, \"Destination sample: Data pointer is NULL or size is zero\\n\");\n        }\n    }\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    if (fp != NULL)\n    {\n        fprintf(fp, \"Returning node at %p\\n\", (void *)&AllocNode->Node);\n        fclose(fp);\n    }\n\n    return &AllocNode->Node;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d3940\nNode.Data set to: 0x563ed61d3960 Node.DataSize=64\nSource sample (64 bytes): 79 D8 AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 56 78 57 6F 72 6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00\nAbout to memcpy 64 bytes from 0x7ffd45738d80 to 0x563ed61d3960\nDestination sample after memcpy (64 bytes): 79 D8 AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 56 78 57 6F 72 6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70 6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00\nSource vs Dest (first 64 bytes): EQUAL\nReturning node at 0x563ed61d3940\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d39b0\nNode.Data set to: 0x563ed61d39d0 Node.DataSize=64\nSource sample (64 bytes): 41 D9 AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAbout to memcpy 64 bytes from 0x7ffd45738d80 to 0x563ed61d39d0\nDestination sample after memcpy (64 bytes): 41 D9 AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSource vs Dest (first 64 bytes): EQUAL\nReturning node at 0x563ed61d39b0\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d3a20\nNode.Data set to: 0x563ed61d3a40 Node.DataSize=64\nSource sample (64 bytes): 31 DB AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAbout to memcpy 64 bytes from 0x7ffd45738d80 to 0x563ed61d3a40\nDestination sample after memcpy (64 bytes): 31 DB AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSource vs Dest (first 64 bytes): EQUAL\nReturning node at 0x563ed61d3a20\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d3a90\nNode.Data set to: 0x563ed61d3ab0 Node.DataSize=64\nSource sample (64 bytes): 41 DC AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAbout to memcpy 64 bytes from 0x7ffd45738d80 to 0x563ed61d3ab0\nDestination sample after memcpy (64 bytes): 41 DC AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSource vs Dest (first 64 bytes): EQUAL\nReturning node at 0x563ed61d3a90\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d3b00\nNode.Data set to: 0x563ed61d3b20 Node.DataSize=64\nSource sample (64 bytes): 1D DE AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 46 6C 75 73 68 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nAbout to memcpy 64 bytes from 0x7ffd45738d80 to 0x563ed61d3b20\nDestination sample after memcpy (64 bytes): 1D DE AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 46 6C 75 73 68 5F 49 6D 70 6C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSource vs Dest (first 64 bytes): EQUAL\nReturning node at 0x563ed61d3b00\nUtList_NewNode ENTER: Data=0x7ffd45738d80 DataSize=64\nRequested allocation size: 96\nmalloc returned: 0x563ed61d3b70\nNode.Data set to: 0x563ed61d3b90 Node.DataSize=64\nSource sample (64 bytes): F9 DF AB C7 3E 56 00 00 ED E4 AB C7 3E 56 00 00 73 E5 AB C7 3E 56 00 00 4F 53 5F 42 69 6E 53 65 6D 54 61 6B 65 5F 49 6D 70 6C 00 \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The parameter Data is only read (used as the source for memcpy and inspected in logging) and is never modified in UtList_NewNode. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible; therefore Data should be declared const void *Data (i.e. UtListNode_t *UtList_NewNode(const void *Data, uint32 DataSize)). The provided test logs show only reads from Data (source samples and memcpy), which supports this conclusion."
}