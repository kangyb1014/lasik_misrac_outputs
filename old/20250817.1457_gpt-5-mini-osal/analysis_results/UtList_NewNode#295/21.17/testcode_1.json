{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call memcpy(AllocNode->Node.Data, Data, DataSize) can access beyond the bounds of the objects referenced by its pointer parameters in realistic error situations. Example violation scenarios: (1) malloc(sizeof(union NodeAllocator) + DataSize) can overflow size_t (or otherwise fail to allocate the requested size) so the allocated region after the union is smaller than DataSize; memcpy then writes past the allocated destination. (2) malloc can return NULL (no check is performed); subsequent use of AllocNode (and &AllocNode[1]) is invalid and memcpy will access out-of-bounds memory. (3) The source pointer Data may be NULL or point to an object smaller than DataSize (caller error), causing memcpy to read beyond the source object. Any of these lead to a Rule 21.17 violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtList_NewNode code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2367.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtList_NewNode as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtList_NewNode:\n```c\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n```\n</target_code>\nPlease provide the modified UtList_NewNode code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n/* Minimal type definitions so this translation unit compiles standalone. */\ntypedef unsigned int uint32;\n\ntypedef struct UtListNode\n{\n    void *      Data;\n    uint32      DataSize;\n    struct UtListNode *Next;\n    struct UtListNode *Prev;\n} UtListNode_t;\n\n/* Probe: append log line(s) to file. Keep this small and non-intrusive. */\nstatic void UtList_Log(const char *msg)\n{\n    FILE *log = fopen(\"/tmp/logs/2367.txt\", \"a\");\n    if (log)\n    {\n        fputs(msg, log);\n        fputc('\\n', log);\n        fclose(log);\n    }\n}\n\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    /* Log entry and parameters. */\n    {\n        char buf[256];\n        size_t req = sizeof(union NodeAllocator) + (size_t)DataSize;\n        (void)snprintf(buf, sizeof(buf), \"ENTER: UtList_NewNode: Data=%p, DataSize=%u, requested_malloc=%zu\", Data, DataSize, req);\n        UtList_Log(buf);\n    }\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n\n    /* Log result of malloc (pointer value, errno if any). */\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"malloc returned %p (errno=%d)\", (void *)AllocNode, errno);\n        UtList_Log(buf);\n    }\n\n    /* Log that we will call memset (size of union part). */\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"calling memset on AllocNode for %zu bytes\", sizeof(union NodeAllocator));\n        UtList_Log(buf);\n    }\n\n    /* Preserve original logic: do the memset regardless of malloc result. */\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n\n    /* Compute and log destination pointer for memcpy only if AllocNode is non-NULL to avoid UB in logging. */\n    void *dest_ptr = NULL;\n    if (AllocNode != NULL)\n    {\n        dest_ptr = &AllocNode[1];\n    }\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"after memset: AllocNode=%p, dest_ptr=%p, Data=%p, DataSize=%u\", (void *)AllocNode, dest_ptr, Data, DataSize);\n        UtList_Log(buf);\n    }\n\n    /* Preserve original assignments and memcpy (these will reproduce any faulty behavior as in original). */\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n\n    /* Log just before memcpy. We avoid dereferencing pointers here except for printing their values. */\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"about to memcpy: dest=%p, src=%p, size=%u\", (AllocNode != NULL) ? (void *)&AllocNode[1] : NULL, Data, DataSize);\n        UtList_Log(buf);\n    }\n\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"EXIT: UtList_NewNode returning %p\", (void *)&AllocNode->Node);\n        UtList_Log(buf);\n    }\n\n    return &AllocNode->Node;\n}\n"
}