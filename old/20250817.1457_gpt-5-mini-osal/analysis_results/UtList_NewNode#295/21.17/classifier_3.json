{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UtList_NewNode:\n```c\nUtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    union NodeAllocator\n    {\n        UtListNode_t Node;\n        double       AlignDbl;\n        void *       AlignPtr;\n        long         AlignLong;\n    } * AllocNode;\n\n    AllocNode = malloc(sizeof(union NodeAllocator) + DataSize);\n    memset(AllocNode, 0, sizeof(union NodeAllocator));\n    AllocNode->Node.Data     = &AllocNode[1];\n    AllocNode->Node.DataSize = DataSize;\n    memcpy(AllocNode->Node.Data, Data, DataSize);\n\n    AllocNode->Node.Next = &AllocNode->Node;\n    AllocNode->Node.Prev = &AllocNode->Node;\n\n    return &AllocNode->Node;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UtList_NewNode:\ntypedef struct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    void *                Data;\n    uint32                DataSize;\n    uint32                Tag;\n} UtListNode_t\n...\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n...\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset(AllocNode, 0, sizeof(union NodeAllocator));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "If malloc fails (returns NULL) then memset(AllocNode, 0, sizeof(union NodeAllocator)) will dereference a NULL pointer and access memory out of bounds. Also if the expression sizeof(union NodeAllocator) + DataSize passed to malloc overflows (DataSize very large) the allocated size may be smaller than sizeof(union NodeAllocator), causing the subsequent memset to write beyond the allocated object. In those cases the use of memset can access beyond the bounds of the object referenced by AllocNode, violating MISRA C 2023 Rule 21.17."
}