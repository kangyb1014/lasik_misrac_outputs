{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CountSemTimedWait_Impl:\n```c\nint32 OS_CountSemTimedWait_Impl(const OS_object_token_t *token, uint32 msecs)\n{\n    struct timespec                     ts;\n    int                                 result;\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n\n    /*\n     ** Compute an absolute time for the delay\n     */\n    OS_Posix_CompAbsDelayTime(msecs, &ts);\n\n    if (sem_timedwait(&impl->id, &ts) == 0)\n    {\n        result = OS_SUCCESS;\n    }\n    else if (errno == ETIMEDOUT)\n    {\n        result = OS_SEM_TIMEOUT;\n    }\n    else\n    {\n        /* unspecified failure */\n        result = OS_SEM_FAILURE;\n    }\n\n    return result;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CountSemTimedWait_Impl:\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_countsem_internal_record_t OS_impl_count_sem_table[OS_MAX_COUNT_SEMAPHORES]\n...\ntypedef struct\n{\n    sem_t id;\n} OS_impl_countsem_internal_record_t\n...\nvoid OS_Posix_CompAbsDelayTime(uint32 msecs, struct timespec *tm)\n{\n    clock_gettime(CLOCK_REALTIME, tm);\n\n    /* add the delay to the current time */\n    tm->tv_sec += (time_t)(msecs / 1000);\n    /* convert residue ( msecs )  to nanoseconds */\n    tm->tv_nsec += (msecs % 1000) * 1000000L;\n\n    if (tm->tv_nsec >= 1000000000L)\n    {\n        tm->tv_nsec -= 1000000000L;\n        tm->tv_sec++;\n    }\n}\n...\n#define OS_SUCCESS (0)\n...\n#define OS_SEM_TIMEOUT (-7)\n...\n#define OS_SEM_FAILURE (-6)\n...\ntypedef struct OS_object_token OS_object_token_t\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ntypedef struct\n{\n    sem_t id;\n} OS_impl_countsem_internal_record_t\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the typedef declares OS_impl_countsem_internal_record_t (containing sem_t id) which is used to define OS_impl_count_sem_table and accessed by OS_CountSemTimedWait_Impl. A type definition is not an executable operation and is therefore not dead code; removing it would affect program behaviour (objects and functions that use the type)."
}