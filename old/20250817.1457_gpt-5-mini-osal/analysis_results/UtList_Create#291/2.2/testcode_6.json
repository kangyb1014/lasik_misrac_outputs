{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe call to memset(NewList, 0, ActualSize) is redundant: immediately after allocation the code assigns NewList->Head.Tags and NewList->Head.NumberOfTags, and the for-loop initializes every Tag node\u2019s Tag, Next and Prev fields. Therefore removing the memset would not change observable program behaviour (for both NumTags == 0 and NumTags > 0). Hence the memset is executed but unnecessary and constitutes dead code under MISRA C 2023 Rule 2.2. (Note: the function also lacks a malloc(NULL) check, which is a separate safety issue.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtList_Create code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2330.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtList_Create as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtList_Create:\n```c\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n    NewList    = (struct ListAllocator *)malloc(ActualSize);\n\n    memset(NewList, 0, ActualSize);\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n    }\n\n    return &NewList->Head;\n}\n```\n</target_code>\nPlease provide the modified UtList_Create code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Helper: append formatted log to /tmp/logs/2330.txt */\nstatic void ut_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2330.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Helper: dump up to 'len' bytes (hex) of a memory region to the log */\nstatic void ut_dump_bytes(const void *p, size_t len)\n{\n    const unsigned char *b = (const unsigned char *)p;\n    size_t i;\n    FILE *f = fopen(\"/tmp/logs/2330.txt\", \"a\");\n    if (!f) return;\n    for (i = 0; i < len; ++i)\n    {\n        fprintf(f, \"%02X\", (unsigned)b[i]);\n        if (i + 1 < len) fputc(' ', f);\n    }\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Modified function with probes added. Original logic preserved. */\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n\n    ut_log(\"[UtList_Create] Enter: NumTags=%u, Calculated ActualSize=%zu\", (unsigned)NumTags, ActualSize);\n\n    NewList    = (struct ListAllocator *)malloc(ActualSize);\n\n    ut_log(\"[UtList_Create] malloc(ActualSize) returned %p\", (void *)NewList);\n\n    /* Log memory region before memset is not performed (note: contents are indeterminate) */\n    ut_log(\"[UtList_Create] About to memset NewList=%p size=%zu\", (void *)NewList, ActualSize);\n\n    memset(NewList, 0, ActualSize);\n\n    /* Dump up to the first 128 bytes after memset to show zeroing */\n    if (NewList != NULL)\n    {\n        size_t dump_len = ActualSize < 128 ? ActualSize : 128;\n        ut_log(\"[UtList_Create] Dump of first %zu bytes after memset:\", dump_len);\n        ut_dump_bytes((const void *)NewList, dump_len);\n    }\n    else\n    {\n        ut_log(\"[UtList_Create] NewList is NULL after malloc; skipping dump\");\n    }\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    ut_log(\"[UtList_Create] After assignments: Head.Tags=%p, Head.NumberOfTags=%u\",\n           (void *)NewList->Head.Tags, (unsigned)NewList->Head.NumberOfTags);\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        /* Log the node pointer and values written */\n        ut_log(\"[UtList_Create] Initializing Tag node index=%u at %p\", (unsigned)i, (void *)TagHead);\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n        ut_log(\"[UtList_Create] After init: node=%p, Tag=%u, Next=%p, Prev=%p\",\n               (void *)TagHead, (unsigned)TagHead->Tag, (void *)TagHead->Next, (void *)TagHead->Prev);\n    }\n\n    /* Dump first 128 bytes after initialization to show which bytes remain zero vs. which changed */\n    if (NewList != NULL)\n    {\n        size_t dump_len = ActualSize < 128 ? ActualSize : 128;\n        ut_log(\"[UtList_Create] Dump of first %zu bytes after initialization:\", dump_len);\n        ut_dump_bytes((const void *)NewList, dump_len);\n    }\n\n    ut_log(\"[UtList_Create] Returning Head pointer %p\", (void *)&NewList->Head);\n\n    return &NewList->Head;\n}\n"
}