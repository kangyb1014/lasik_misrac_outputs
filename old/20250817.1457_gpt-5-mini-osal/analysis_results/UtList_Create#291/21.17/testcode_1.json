{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call memset(NewList, 0, ActualSize) can write beyond the bounds of the object pointed to by NewList. If malloc fails NewList == NULL and memset(NULL, ActualSize) is undefined (out-of-bounds). Also ActualSize calculation (sizeof(struct ListAllocator) + sizeof(UtListNode_t)*NumTags) can overflow size_t for large NumTags leading to a smaller allocation than ActualSize; memset would then write past the allocated buffer. No checks for malloc failure or integer overflow are present, so the rule is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtList_Create code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2335.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtList_Create as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtList_Create:\n```c\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n    NewList    = (struct ListAllocator *)malloc(ActualSize);\n\n    memset(NewList, 0, ActualSize);\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n    }\n\n    return &NewList->Head;\n}\n```\n</target_code>\nPlease provide the modified UtList_Create code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Minimal local typedefs/structures to make this test code self-contained. */\ntypedef unsigned int uint32;\n\ntypedef struct UtListNode_tag\n{\n    uint32 Tag;\n    struct UtListNode_tag *Next;\n    struct UtListNode_tag *Prev;\n} UtListNode_t;\n\ntypedef struct\n{\n    UtListNode_t *Tags;\n    uint32 NumberOfTags;\n} UtListHead_t;\n\n/* Probe/logging helper. Creates directory /tmp/logs if needed and appends logs. */\nstatic void UtList_log_state(const char *label, uint32 NumTags, size_t ActualSize, void *NewList, int overflow)\n{\n    /* Try to create directory if it doesn't exist. Ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    FILE *f = fopen(\"/tmp/logs/2335.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging fails, do not change program behavior. */\n        return;\n    }\n\n    fprintf(f, \"[UtList_Create] %s\\n\", label);\n    fprintf(f, \"  NumTags: %u\\n\", NumTags);\n    fprintf(f, \"  sizeof(UtListNode_t): %zu\\n\", sizeof(UtListNode_t));\n    fprintf(f, \"  Calculated ActualSize: %zu\\n\", ActualSize);\n    fprintf(f, \"  malloc returned: %p\\n\", NewList);\n    fprintf(f, \"  potential size overflow detected: %s\\n\", overflow ? \"YES\" : \"NO\");\n    fprintf(f, \"--------------------------------------------------\\n\");\n    fclose(f);\n}\n\nUtListHead_t *UtList_Create(uint32 NumTags)\n{\n    struct ListAllocator\n    {\n        UtListHead_t Head;\n        UtListNode_t Tags[];\n    };\n    struct ListAllocator *NewList;\n    UtListNode_t *        TagHead;\n    size_t                ActualSize;\n    uint32                i;\n\n    /* Compute ActualSize similarly to original code. */\n    ActualSize = sizeof(struct ListAllocator) + (sizeof(UtListNode_t) * NumTags);\n\n    /* Detect potential integer overflow in the size calculation for logging purposes. */\n    int overflow = 0;\n    if (NumTags != 0)\n    {\n        /* Check if sizeof(UtListNode_t) * NumTags would overflow size_t. */\n        if ((size_t)NumTags > SIZE_MAX / sizeof(UtListNode_t))\n        {\n            overflow = 1;\n        }\n    }\n\n    /* Log before allocation. */\n    UtList_log_state(\"before malloc\", NumTags, ActualSize, NULL, overflow);\n\n    NewList = (struct ListAllocator *)malloc(ActualSize);\n\n    /* Log result of malloc. */\n    UtList_log_state(\"after malloc\", NumTags, ActualSize, (void *)NewList, overflow);\n\n    /* Preserve original behavior: call memset even if NewList is NULL (this is the problematic call). */\n    memset(NewList, 0, ActualSize);\n\n    /* Log after memset to capture that memset was invoked and what NewList was. */\n    UtList_log_state(\"after memset\", NumTags, ActualSize, (void *)NewList, overflow);\n\n    NewList->Head.Tags         = NewList->Tags;\n    NewList->Head.NumberOfTags = NumTags;\n\n    for (i = 0; i < NumTags; ++i)\n    {\n        TagHead       = &NewList->Head.Tags[i];\n        TagHead->Tag  = i;\n        TagHead->Next = TagHead;\n        TagHead->Prev = TagHead;\n    }\n\n    return &NewList->Head;\n}\n"
}