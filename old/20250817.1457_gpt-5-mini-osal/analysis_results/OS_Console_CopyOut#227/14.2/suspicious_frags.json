{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_Console_CopyOut:\n```c\nstatic int32 OS_Console_CopyOut(OS_console_internal_record_t *console, const char *Str, size_t *NextWritePos)\n{\n    const char *pmsg;\n    size_t      WriteOffset;\n    int32       return_code;\n\n    return_code = OS_ERROR;\n    pmsg        = Str;\n    WriteOffset = *NextWritePos;\n    while (true)\n    {\n        if (*pmsg == 0)\n        {\n            /* String is complete */\n            *NextWritePos = WriteOffset;\n            return_code   = OS_SUCCESS;\n            break;\n        }\n        console->BufBase[WriteOffset] = *pmsg;\n        WriteOffset                   = WriteOffset + 1;\n        if (WriteOffset >= console->BufSize)\n        {\n            WriteOffset = 0;\n        }\n\n        if (WriteOffset == console->ReadPos)\n        {\n            /* out of space */\n            return_code = OS_QUEUE_FULL;\n            break;\n        }\n\n        ++pmsg;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_Console_CopyOut:\ntypedef struct\n{\n    char device_name[OS_MAX_API_NAME];\n\n    char *          BufBase;        /**< Start of the buffer memory */\n    size_t          BufSize;        /**< Total size of the buffer */\n    volatile size_t ReadPos;        /**< Offset of next byte to read */\n    volatile size_t WritePos;       /**< Offset of next byte to write */\n    uint32          OverflowEvents; /**< Number of lines dropped due to overflow */\n    bool            IsAsync;        /**< Whether to write data via deferred utility task */\n} OS_console_internal_record_t\n...\n#define OS_ERROR (-1)\n...\n#define OS_SUCCESS (0)\n...\n#define OS_QUEUE_FULL (-9)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "++pmsg;",
    "while (true)\n    {",
    "pmsg        = Str;",
    "WriteOffset                   = WriteOffset + 1;",
    "if (WriteOffset >= console->BufSize)\n        {\n            WriteOffset = 0;\n        }",
    "console->BufBase[WriteOffset] = *pmsg;",
    "WriteOffset = *NextWritePos;",
    "if (WriteOffset == console->ReadPos)\n        {\n            /* out of space */\n            return_code = OS_QUEUE_FULL;\n            break;\n        }",
    "if (*pmsg == 0)\n        {\n            /* String is complete */\n            *NextWritePos = WriteOffset;\n            return_code   = OS_SUCCESS;\n            break;\n        }"
  ],
  "explanation": "Rule 14.2 addresses well-formed loop control. There is no for-statement in this function, but the while(true) loop and the way variables are used/modified in its clauses are the relevant places to investigate for compliance with the intent of the rule (single loop counter, no other objects modified in the loop control, etc.). The fragments above capture the loop header, the loop termination check, the pointer increment, the buffer-write and wrap code, and the initialization of the loop-like variables \u2014 all of which may affect whether the loop has a single, well-defined loop counter and whether objects used in loop control are modified in the loop body.\n\nOther parts of the function do not merit investigation for Rule 14.2: variable declarations and typedefs are ordinary; the return_code initial assignment and the final \"return return_code;\" are unrelated to loop formation; the macro definitions and struct field declarations provided in the additional code are declarations, not loop control expressions. The only statements that can influence whether the loop is well-formed are the loop header, the loop condition/termination handling, and the statements that modify potential loop counters or loop-control flags \u2014 these are the fragments reported above."
}