{
  "user_message": "An agent A claimed that the following OS_SelectMultiple code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SelectMultiple.\n```c\nint32 OS_SelectMultiple(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    int32 return_code;\n\n    /*\n     * Check parameters\n     *\n     * Note \"ReadSet\" and \"WriteSet\" are not checked, because in certain configurations they can be validly null.\n     */\n\n    /*\n     * This does not currently increment any refcounts.\n     * That means a file/socket can be closed while actively inside a\n     * OS_SelectMultiple() call in another thread.\n     */\n    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In OS_API_Init() there is a switch over idtype whose default arm contains only \"break;\" (i.e. \"default: break;\"). That break is executed only if none of the case labels match, but it has no effect on program flow because control would fall out of the switch in the same way if the default arm were removed. Thus the operation is executed but removable without changing program behaviour, constituting dead code and violating MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\nstruct OS_FdSet { int dummy; };\ntypedef struct OS_FdSet { int dummy; } OS_FdSet;\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs);\nstatic void OS_Probe_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1906.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* Best effort logging only. */\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm *tm_info = localtime(&t);\n    if (tm_info != NULL)\n    {\n        char buf[32];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm_info) > 0)\n        {\n            fprintf(fp, \"[%s] \", buf);\n        }\n    }\n\n    /* Message */\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast to (va_list) to avoid potential typedef mismatches in some build environments. */\n    vfprintf(fp, fmt, (va_list)ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_SelectMultiple(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    int32 return_code;\n\n    /* Probe: log entry and input state so other agents can reproduce/control the scenario. */\n    OS_Probe_Log(\"OS_SelectMultiple entry: ReadSet=%p WriteSet=%p msecs=%\" PRId32,\n                 (void *)ReadSet, (void *)WriteSet, msecs);\n\n    /*\n     * NOTE (investigation aid): The reported MISRA Rule 2.2 violation referenced\n     * a separate function OS_API_Init() whose switch(default) arm contains only\n     * \"break;\". That default break is executed but removable without changing\n     * behaviour. This probe cannot inspect OS_API_Init() internals, but records\n     * that this API was exercised so the timeline can be correlated with logs\n     * from OS_API_Init (if those are also instrumented).\n     */\n    OS_Probe_Log(\"Probe note: OS_SelectMultiple called; if OS_API_Init default: break scenario occurred earlier, correlate timestamps in /tmp/logs/1906.txt\");\n\n    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);\n\n    /* Probe: log return and relevant state after call. */\n    OS_Probe_Log(\"OS_SelectMultiple exit: return_code=%\" PRId32, return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the OS_SelectMultiple code shown. The function simply calls OS_SelectMultiple_Impl, stores its result in return_code and returns it; none of the executed operations are removable without changing behaviour, so there is no dead code in this function. Agent A\u2019s scenario describes a different function (OS_API_Init) whose switch default arm contains only \u201cbreak;\u201d. That default arm, if reached, is redundant (removing it would not change control flow) and therefore could be considered dead in the strict sense of Rule 2.2, but that is a separate issue and is not present in the OS_SelectMultiple code provided. The added probe code does not demonstrate dead code in OS_SelectMultiple and the compilation failure of the test code does not affect this conclusion."
}