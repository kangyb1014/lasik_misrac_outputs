{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorProcessEntry code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorProcessEntry.\n```c\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The iterator holds iter->arg as a plain void * and OS_ObjectIdIteratorProcessEntry passes it to a callback declared as int32 (*func)(osal_id_t, void *). If the callback does not need to modify the pointed-to object (which is typical for user 'context' arguments in iterator callbacks), both the iter->arg member and the callback parameter should be const-qualified (const void *). As written the pointer is not const-qualified and therefore violates MISRA C 2023 Rule 8.13 (pointer should point to a const-qualified type whenever possible).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_Iterator_LogStage(const char *stage, OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *), const char *note)\n{\n    FILE *fp = fopen(\"/tmp/logs/1619.txt\", \"a\");\n    if (fp != NULL)\n    {\n        /* Log stage, iterator pointer, token pointer, argument pointer, and whether func is NULL */\n        fprintf(fp, \"stage=%s iter=%p token=%p arg=%p func_nonnull=%d note=%s\\n\",\n                stage,\n                (void *)iter,\n                (void *)&iter->token,\n                (void *)iter->arg,\n                (func != NULL) ? 1 : 0,\n                (note != NULL) ? note : \"\");\n        fclose(fp);\n    }\n}\n\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /* Log entry and state before unlocking */\n    OS_Iterator_LogStage(\"entry_before_unlock\", iter, func, NULL);\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n\n    /* Log state immediately after unlocking and before calling the callback */\n    OS_Iterator_LogStage(\"after_unlock_before_call\", iter, func, NULL);\n\n    /* Call the callback exactly as before, preserving original control flow */\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n\n    /* Log the return status from the callback and the argument pointer that was passed */\n    {\n        FILE *fp = fopen(\"/tmp/logs/1619.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"callback_return status=%d iter=%p arg=%p\\n\",\n                    (int)status,\n                    (void *)iter,\n                    (void *)iter->arg);\n            fclose(fp);\n        }\n    }\n\n    OS_Lock_Global(&iter->token);\n\n    /* Final log after re-locking */\n    OS_Iterator_LogStage(\"after_lock\", iter, func, NULL);\n\n    return status;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdIteratorProcessEntry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the evidence. MISRA C:2023 Rule 8.13 recommends that pointers should point to const-qualified types when they are not used to modify the pointed-to object. In this function the callback is declared as int32 (*func)(osal_id_t, void *), and iter->arg is a void * that is passed exactly as that prototype requires. There is no indication in the snippet that the pointed-to object is never modified \u2014 and the callback prototype and the iterator storage (iter->arg) may intentionally be non-const to permit modification or to preserve API compatibility. Without evidence that the pointed-to object is only read and could safely be const-qualified, you cannot conclude a MISRA 8.13 violation. In short: the claim is speculative; changing to const void * would be an API change and is not provably required. Therefore the report is incorrect."
}