{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdIteratorProcessEntry:\n```c\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_Lock_Global(&iter->token);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the statement OS_Lock_Global(&iter->token); immediately follows the call to func(...) and will be executed when that function pointer returns. There is no return, goto, or conditional that makes this line syntactically unreachable. Only if the supplied handler is non\u2011returning (e.g. annotated noreturn, calls longjmp/exit) would the lock not be reached at runtime, but that is a dynamic behavior and does not make the source line statically unreachable (so it does not violate MISRA C 2023 Rule 2.1)."
}