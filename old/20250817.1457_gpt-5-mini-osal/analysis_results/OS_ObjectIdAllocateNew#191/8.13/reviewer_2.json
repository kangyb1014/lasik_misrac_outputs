{
  "user_message": "An agent A claimed that the following OS_ObjectIdAllocateNew code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdAllocateNew.\n```c\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. OS_ObjectIdFindNextMatch takes a non-const void *arg and forwards it to a MatchFunc whose first parameter is also a non-const void *. In practice the match function OS_ObjectNameMatch treats the argument as a const char * (it calls strcmp((const char *)ref, ...)) and the caller casts a const char *name to (void *) when calling OS_ObjectIdFindNextMatch. This casts away const and uses non-const pointer types for input-only data, which violates MISRA C 2023 Rule 8.13. A fix is to change the signatures to use const void *arg (and the MatchFunc typedef/parameter to const void *), removing the need to cast away const.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_Probe_LogState(const char *stage, int32 rc, const char *name, OS_object_token_t *token)\n{\n    FILE *f = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Log stage, return code, name pointer, and name string if available. */\n        fprintf(f, \"Stage=%s, rc=%ld, name_ptr=%p\", stage, (long)rc, (const void *)name);\n        if (name != NULL)\n        {\n            /* Print the name string - this mirrors how the name is treated by callers. */\n            fprintf(f, \", name_str=\\\"%s\\\"\", name);\n        }\n\n        /* Log token pointer and obj_id when available. */\n        if (token != NULL)\n        {\n            fprintf(f, \", token_ptr=%p\", (void *)token);\n            /* token->obj_id is accessed in the original function; print it if present. */\n            fprintf(f, \", obj_id=%lu\", (unsigned long)token->obj_id);\n        }\n\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /* Log entry into the function with initial parameters */\n    OS_Probe_LogState(\"entry\", 0, name, token);\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        OS_Probe_LogState(\"shutdown_check_failed\", OS_ERR_INCORRECT_OBJ_STATE, name, token);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    OS_Probe_LogState(\"after_transaction_init\", return_code, name, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        /* Log the intent to check name match. The original code casts name to (void *).\n         * We log the const name pointer without casting away const. */\n        OS_Probe_LogState(\"before_find_next_match\", 0, name, token);\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n        OS_Probe_LogState(\"after_find_next_match\", return_code, name, token);\n    }\n    else\n    {\n        OS_Probe_LogState(\"name_null\", OS_ERR_NAME_NOT_FOUND, name, token);\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_Probe_LogState(\"name_taken_detected\", OS_ERR_NAME_TAKEN, name, token);\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        OS_Probe_LogState(\"finding_next_free\", 0, name, token);\n        return_code = OS_ObjectIdFindNextFree(token);\n        OS_Probe_LogState(\"after_find_next_free\", return_code, name, token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_Probe_LogState(\"allocation_failed_before_notify\", return_code, name, token);\n        OS_ObjectIdTransactionCancel(token);\n        OS_Probe_LogState(\"transaction_cancelled\", return_code, name, token);\n        return return_code;\n    }\n    else\n    {\n        OS_Probe_LogState(\"before_notify\", 0, name, token);\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n        OS_Probe_LogState(\"after_notify\", return_code, name, token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_Probe_LogState(\"before_convert_token\", 0, name, token);\n        return_code = OS_ObjectIdConvertToken(token);\n        OS_Probe_LogState(\"after_convert_token\", return_code, name, token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_Probe_LogState(\"finalize_new_due_to_error\", return_code, name, token);\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n        OS_Probe_LogState(\"after_finalize_new\", return_code, name, token);\n    }\n\n    OS_Probe_LogState(\"exit\", return_code, name, token);\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nStage=entry, rc=0, name_ptr=0x562fae8f4992, name_str=\"Queue A\", token_ptr=0x7ffccb8e26e0, obj_id=2567868480\nStage=after_transaction_init, rc=-1, name_ptr=0x562fae8f4992, name_str=\"Queue A\", token_ptr=0x7ffccb8e26e0, obj_id=0\nStage=entry, rc=0, name_ptr=0x562fae8f4a1e, name_str=\"BinSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=2928626136\nStage=after_transaction_init, rc=-1, name_ptr=0x562fae8f4a1e, name_str=\"BinSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=0\nStage=entry, rc=0, name_ptr=0x562fae8f4a6a, name_str=\"CountSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=2928626136\nStage=after_transaction_init, rc=-1, name_ptr=0x562fae8f4a6a, name_str=\"CountSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=0\nStage=entry, rc=0, name_ptr=0x562fae8f4abe, name_str=\"MutexSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=2928626136\nStage=after_transaction_init, rc=-1, name_ptr=0x562fae8f4abe, name_str=\"MutexSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=0\nStage=entry, rc=0, name_ptr=0x562fae8f4992, name_str=\"Queue A\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f4992, name_str=\"Queue A\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f4a1e, name_str=\"BinSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f4a1e, name_str=\"BinSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f4a6a, name_str=\"CountSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f4a6a, name_str=\"CountSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f4abe, name_str=\"MutexSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f4abe, name_str=\"MutexSem 1\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x7ffccb8e2700, name_str=\"BINSEM0\", token_ptr=0x7ffccb8e2660, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x7ffccb8e2700, name_str=\"BINSEM0\", token_ptr=0x7ffccb8e2660, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f41dd, name_str=\"DUPLICATE\", token_ptr=0x7ffccb8e2660, obj_id=0\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f41dd, name_str=\"DUPLICATE\", token_ptr=0x7ffccb8e2660, obj_id=0\nStage=entry, rc=0, name_ptr=0x562fae8f4246, name_str=\"Good\", token_ptr=0x7ffccb8e2660, obj_id=2928623680\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f4246, name_str=\"Good\", token_ptr=0x7ffccb8e2660, obj_id=2928623680\nStage=entry, rc=0, name_ptr=0x562fae8f42e0, name_str=\"DeleteTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f42e0, name_str=\"DeleteTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f438f, name_str=\"FlushTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f438f, name_str=\"FlushTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f443e, name_str=\"GiveTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f443e, name_str=\"GiveTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f44e6, name_str=\"TakeTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f44e6, name_str=\"TakeTest\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f45a1, name_str=\"TimedWait\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f45a1, name_str=\"TimedWait\", token_ptr=0x7ffccb8e2710, obj_id=3415091024\nStage=entry, rc=0, name_ptr=0x562fae8f45a1, name_str=\"TimedWait\", token_ptr=0x7ffccb8e2710, obj_id=2928623680\nStage=shutdown_check_failed, rc=-35, name_ptr=0x562fae8f45a1, name_str=\"TimedWait\", token_ptr=0x7ffccb8e2710, obj_id=2928623680\nStage=entry, rc=0, name_ptr=0x562fae8f470a, name_str=\"GetIDByName\", token_ptr=0x7ffccb8e26e0, obj_id=3415091024\nStage=shutdo\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The function casts away const when calling OS_ObjectIdFindNextMatch: it passes (void *)name where name is declared const char *. That forwards a const-qualified object through a non-const pointer parameter (and the match callback also takes a non-const void *), which uses a non-const pointer for input-only data and requires discarding the const qualifier. MISRA C 2023 R8.13 expects pointers to be const-qualified when possible, so the API (OS_ObjectIdFindNextMatch / MatchFunc / OS_ObjectNameMatch) should accept const void * (and the callback parameter should be const) instead of non-const void *. Changing those signatures removes the need to cast away const and resolves the violation."
}