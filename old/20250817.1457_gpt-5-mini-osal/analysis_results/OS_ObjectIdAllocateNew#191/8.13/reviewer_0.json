{
  "user_message": "An agent A claimed that the following OS_ObjectIdAllocateNew code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdAllocateNew.\n```c\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'ref' is declared as void * but is only read and immediately cast to const char * for strcmp; it should be declared to point to a const-qualified type (e.g. const void *ref or const char *ref). Because the function does not modify the data pointed to by ref, the current declaration violates MISRA C 2023 Rule 8.13. (Note: fixing this may require updating the OS_ObjectMatchFunc_t typedef and callers to use a const-qualified pointer.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n    FILE *logf = NULL;\n\n    /* Helper: open log file (append) and write a header for this invocation. */\n    logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"\\n--- OS_ObjectIdAllocateNew entry ---\\n\");\n        fprintf(logf, \"idtype=%p, name_ptr=%p, name=%s, token_ptr=%p\\n\",\n                (void *) (uintptr_t) idtype, (void *) name, (name != NULL) ? name : \"<NULL>\", (void *) token);\n        fclose(logf);\n    }\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        /* Log the shutdown branch */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Early return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning %d\\n\", (int)OS_ERR_INCORRECT_OBJ_STATE);\n            fclose(logf);\n        }\n\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n\n    /* Log the result of TransactionInit */\n    logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"After OS_ObjectIdTransactionInit: return_code=%d\\n\", (int)return_code);\n        fclose(logf);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        /* Log that we are about to cast the const char * to void * and call the matcher */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Calling OS_ObjectIdFindNextMatch with OS_ObjectNameMatch, ref=(void*)name -> ref_ptr=%p, name=\\\"%s\\\"\\n\",\n                    (void *) name, name);\n            fprintf(logf, \"Note: original parameter 'name' is const char *, cast to (void *) for the matcher.\\n\");\n            fclose(logf);\n        }\n\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n\n        /* Log the result of FindNextMatch */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"After OS_ObjectIdFindNextMatch: return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Name is NULL, setting return_code=OS_ERR_NAME_NOT_FOUND (%d)\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Name match found; setting return_code=OS_ERR_NAME_TAKEN (%d)\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Name not found; called OS_ObjectIdFindNextFree, return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        /* Log the failure before cancelling */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Allocation failed before finalization, return_code=%d. Calling OS_ObjectIdTransactionCancel.\\n\", (int)return_code);\n            if (token != NULL)\n            {\n                fprintf(logf, \"Token obj_id (pre-cancel) = %ld\\n\", (long) token->obj_id);\n            }\n            fclose(logf);\n        }\n\n        OS_ObjectIdTransactionCancel(token);\n\n        /* Log after cancel */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Transaction cancelled. Returning return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n\n        return return_code;\n    }\n    else\n    {\n        /* Log successful allocation event notification attempt */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            if (token != NULL)\n            {\n                fprintf(logf, \"Allocation succeeded. Calling OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, obj_id=%ld)\\n\", (long) token->obj_id);\n            }\n            else\n            {\n                fprintf(logf, \"Allocation succeeded. Calling OS_NotifyEvent with NULL token.\\n\");\n            }\n            fclose(logf);\n        }\n\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n\n        /* Log result of notify */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"After OS_NotifyEvent: return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"After OS_ObjectIdConvertToken: return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /* Log finalization call with the failing return_code */\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Finalizing new object (failure path). Calling OS_ObjectIdFinalizeNew(return_code=%d)\\n\", (int)return_code);\n            fclose(logf);\n        }\n\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n\n        logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"After OS_ObjectIdFinalizeNew: return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n        }\n    }\n\n    /* Log the final return value */\n    logf = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"Exiting OS_ObjectIdAllocateNew with return_code=%d\\n\", (int)return_code);\n        fclose(logf);\n    }\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x2, name_ptr=0x55a20c48d992, name=Queue A, token_ptr=0x7ffd0c5ec830\nAfter OS_ObjectIdTransactionInit: return_code=-1\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48da1e, name=BinSem 1, token_ptr=0x7ffd0c5ec830\nAfter OS_ObjectIdTransactionInit: return_code=-1\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, name_ptr=0x55a20c48da6a, name=CountSem 1, token_ptr=0x7ffd0c5ec830\nAfter OS_ObjectIdTransactionInit: return_code=-1\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x5, name_ptr=0x55a20c48dabe, name=MutexSem 1, token_ptr=0x7ffd0c5ec830\nAfter OS_ObjectIdTransactionInit: return_code=-1\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x2, name_ptr=0x55a20c48d992, name=Queue A, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48da1e, name=BinSem 1, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, name_ptr=0x55a20c48da6a, name=CountSem 1, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x5, name_ptr=0x55a20c48dabe, name=MutexSem 1, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x7ffd0c5ec850, name=BINSEM0, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d1dd, name=DUPLICATE, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d246, name=Good, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d2e0, name=DeleteTest, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d38f, name=FlushTest, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d43e, name=GiveTest, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d4e6, name=TakeTest, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d5a1, name=TimedWait, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d5a1, name=TimedWait, token_ptr=0x7ffd0c5ec860\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d70a, name=GetIDByName, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d7f8, name=GetInfo, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x4, name_ptr=0x55a20c48d7f8, name=GetInfo, token_ptr=0x7ffd0c5ec830\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, name_ptr=0x7ffd0c5ec850, name=COUNTSEM0, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, name_ptr=0x55a20c48fad5, name=DUPLICATE, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, name_ptr=0x55a20c48fb8c, name=Good, token_ptr=0x7ffd0c5ec7b0\nEarly return: OS_SHUTDOWN_MAGIC_NUMBER detected. Returning -35\n\n--- OS_ObjectIdAllocateNew entry ---\nidtype=0x3, na\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. OS_ObjectIdAllocateNew takes a const char *name but calls OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token), explicitly casting away the const qualifier. That indicates the matcher callback (and/or the OS_ObjectIdFindNextMatch prototype) uses a non-const void * parameter even though the data is only read. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible; here the API should use const void * (or const char *) for the reference parameter and callers should pass the const pointer without casting. The cast-away-const in this function therefore demonstrates the rule violation. Recommended fix: change the match-function typedef and related prototypes to accept a const-qualified pointer and update callers accordingly."
}