{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call casts away const: name is const char * but is passed as (void *)name to OS_ObjectIdFindNextMatch, which takes a non-const void *arg. This discards the const qualifier and therefore violates the intent of Rule 8.13. Fix by changing the match API to take a const-qualified pointer (e.g. OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, const void *arg, ... ) and OS_ObjectNameMatch to accept const void *ref), then call without a cast.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdAllocateNew code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1531.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdAllocateNew as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdAllocateNew:\n```c\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdAllocateNew code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n/* Minimal type aliases to allow compilation */\ntypedef int32_t int32;\ntypedef uint32_t osal_objtype_t;\n\n/* Token structure used by the API */\ntypedef struct\n{\n    int32 obj_id;\n} OS_object_token_t;\n\n/* Global state placeholder */\nstruct\n{\n    uint32_t GlobalState;\n} OS_SharedGlobalVars = { 0 };\n\n/* Constants (minimal set used by the function) */\nenum\n{\n    OS_SHUTDOWN_MAGIC_NUMBER = 0xDEADBEEF,\n    OS_ERR_INCORRECT_OBJ_STATE = -1,\n    OS_SUCCESS = 0,\n    OS_ERR_NAME_NOT_FOUND = -2,\n    OS_ERR_NAME_TAKEN = -3,\n};\n\n/* Forward declarations of OS functions used by the implementation. These are\n * minimal stubs so that the test code compiles and runs in isolation. */\nint32 OS_ObjectIdTransactionInit(int lock_mode, osal_objtype_t idtype, OS_object_token_t *token);\nint32 OS_ObjectIdFindNextMatch(int (*MatchFunc)(const void *, OS_object_token_t *), void *arg, OS_object_token_t *token);\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token);\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token);\nint32 OS_NotifyEvent(int event, int obj_id, void *data);\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token);\nint32 OS_ObjectIdFinalizeNew(int32 return_code, OS_object_token_t *token, void *arg);\n\n/* A match function that checks the passed reference against a known name.\n * This stub accepts a const void *ref so it models the safer API that the\n * violation-reporting agent recommended. */\nint32 OS_ObjectNameMatch(const void *ref, OS_object_token_t *token)\n{\n    if (ref == NULL)\n    {\n        return OS_ERR_NAME_NOT_FOUND;\n    }\n\n    const char *s = (const char *)ref;\n    /* If the name equals \"taken\" we simulate that an object already exists. */\n    if (strcmp(s, \"taken\") == 0)\n    {\n        return OS_SUCCESS;\n    }\n\n    return OS_ERR_NAME_NOT_FOUND;\n}\n\n/* Simple logging helper: append formatted messages to /tmp/logs/1531.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, silently ignore to avoid affecting logic. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Minimal stub implementations to allow running the allocation function. */\nint32 OS_ObjectIdTransactionInit(int lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    (void)lock_mode;\n    (void)idtype;\n    /* For testing, allocate a fake ID in the token */\n    if (token != NULL)\n    {\n        token->obj_id = 42;\n    }\n    return OS_SUCCESS;\n}\n\nint32 OS_ObjectIdFindNextMatch(int (*MatchFunc)(const void *, OS_object_token_t *), void *arg, OS_object_token_t *token)\n{\n    /* This stub demonstrates how the (void *)arg is consumed by the matcher.\n     * It calls the provided MatchFunc if available. */\n    if (MatchFunc == NULL)\n    {\n        return OS_ERR_NAME_NOT_FOUND;\n    }\n\n    /* The MatchFunc expects a const void *, but the API signature takes a\n     * non-const void *. This is the function that illustrates the cast-away-const\n     * scenario: callers cast their const char * names to (void *) when calling\n     * this API. */\n    return MatchFunc((const void *)arg, token);\n}\n\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    (void)token;\n    /* Simulate success in finding a free slot (ID already in token from init) */\n    return OS_SUCCESS;\n}\n\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    (void)token;\n    probe_log(\"OS_ObjectIdTransactionCancel called\");\n}\n\nint32 OS_NotifyEvent(int event, int obj_id, void *data)\n{\n    (void)data;\n    probe_log(\"OS_NotifyEvent: event=%d obj_id=%d\", event, obj_id);\n    return OS_SUCCESS;\n}\n\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    (void)token;\n    probe_log(\"OS_ObjectIdConvertToken called for obj_id=%d\", token ? token->obj_id : -1);\n    return OS_SUCCESS;\n}\n\nint32 OS_ObjectIdFinalizeNew(int32 return_code, OS_object_token_t *token, void *arg)\n{\n    (void)arg;\n    probe_log(\"OS_ObjectIdFinalizeNew called: return_code=%d obj_id=%d\", return_code, token ? token->obj_id : -1);\n    return return_code;\n}\n\n/* The target function with inserted logging probes. The original logic is\n * preserved; logging calls are interleaved to capture the control flow and\n * state, especially around the call that casts away const. */\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    probe_log(\"ENTER: OS_ObjectIdAllocateNew idtype=%u name_ptr=%p name=\\\"%s\\\" token_ptr=%p\",\n              (unsigned)idtype,\n              (const void *)name,\n              (name != NULL) ? name : \"(null)\",\n              (void *)token);\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        probe_log(\"ABORT: shutdown state detected (GlobalState=0x%08X)\", OS_SharedGlobalVars.GlobalState);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    probe_log(\"After TransactionInit: return_code=%d\", return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"TransactionInit failed, returning %d\", return_code);\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        /* Log details about the cast that causes the const qualifier to be discarded.\n         * This documents the violation scenario: name is const char *, but is passed\n         * as (void *)name to an API that takes a non-const void *arg. */\n        probe_log(\"About to call OS_ObjectIdFindNextMatch. name (const char *) = %p, contents=\\\"%s\\\"\",\n                  (const void *)name, name);\n        probe_log(\"Casting away const: calling OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token)\");\n\n        /* The original code casts away const here; preserved to reproduce the scenario. */\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n\n        probe_log(\"OS_ObjectIdFindNextMatch returned %d\", return_code);\n    }\n    else\n    {\n        probe_log(\"No name provided (name == NULL), setting return_code = OS_ERR_NAME_NOT_FOUND\");\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"Name match found: setting return_code = OS_ERR_NAME_TAKEN\");\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        probe_log(\"Name not found; attempting to find next free ID (current return_code=%d)\", return_code);\n        return_code = OS_ObjectIdFindNextFree(token);\n        probe_log(\"OS_ObjectIdFindNextFree returned %d\", return_code);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Allocation failed (return_code=%d). Cancelling transaction.\", return_code);\n        OS_ObjectIdTransactionCancel(token);\n        probe_log(\"EXIT: OS_ObjectIdAllocateNew returning %d\", return_code);\n        return return_code;\n    }\n    else\n    {\n        probe_log(\"Allocation succeeded so far; notifying event for obj_id=%d\", token ? token->obj_id : -1);\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n        probe_log(\"OS_NotifyEvent returned %d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n        probe_log(\"OS_ObjectIdConvertToken returned %d\", return_code);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Finalization needed, calling OS_ObjectIdFinalizeNew with return_code=%d\", return_code);\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    probe_log(\"EXIT: OS_ObjectIdAllocateNew returning %d\", return_code);\n    return return_code;\n}\n\n/* Definitions for symbols referenced in the stubs that would normally be\n * provided by the OS headers. These are simple placeholders to make this\n * translation unit self-contained. */\nenum\n{\n    OS_LOCK_MODE_EXCLUSIVE = 1,\n    OS_EVENT_RESOURCE_ALLOCATED = 100,\n};\n"
}