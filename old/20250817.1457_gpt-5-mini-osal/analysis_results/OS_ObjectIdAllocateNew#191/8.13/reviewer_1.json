{
  "user_message": "An agent A claimed that the following OS_ObjectIdAllocateNew code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdAllocateNew.\n```c\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        return_code = OS_ObjectIdFindNextFree(token);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n        return return_code;\n    }\n    else\n    {\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call casts away const: name is const char * but is passed as (void *)name to OS_ObjectIdFindNextMatch, which takes a non-const void *arg. This discards the const qualifier and therefore violates the intent of Rule 8.13. Fix by changing the match API to take a const-qualified pointer (e.g. OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, const void *arg, ... ) and OS_ObjectNameMatch to accept const void *ref), then call without a cast.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef uint32_t osal_objtype_t;\ntypedef struct\n{\n    int32 obj_id;\n} OS_object_token_t;\nstruct\n{\n    uint32_t GlobalState;\n} OS_SharedGlobalVars = { 0 };\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1531.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, silently ignore to avoid affecting logic. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nint32 OS_NotifyEvent(int event, int obj_id, void *data)\n{\n    (void)data;\n    probe_log(\"OS_NotifyEvent: event=%d obj_id=%d\", event, obj_id);\n    return OS_SUCCESS;\n}\n\nint32 OS_ObjectNameMatch(const void *ref, OS_object_token_t *token)\n{\n    if (ref == NULL)\n    {\n        return OS_ERR_NAME_NOT_FOUND;\n    }\n\n    const char *s = (const char *)ref;\n    /* If the name equals \"taken\" we simulate that an object already exists. */\n    if (strcmp(s, \"taken\") == 0)\n    {\n        return OS_SUCCESS;\n    }\n\n    return OS_ERR_NAME_NOT_FOUND;\n}\nint32 OS_ObjectIdTransactionInit(int lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    (void)lock_mode;\n    (void)idtype;\n    /* For testing, allocate a fake ID in the token */\n    if (token != NULL)\n    {\n        token->obj_id = 42;\n    }\n    return OS_SUCCESS;\n}\nint32 OS_ObjectIdFindNextMatch(int (*MatchFunc)(const void *, OS_object_token_t *), void *arg, OS_object_token_t *token)\n{\n    if (MatchFunc == NULL)\n    {\n        return OS_ERR_NAME_NOT_FOUND;\n    }\n\n    /* Call the match with a const-cast as in original scenario */\n    return MatchFunc((const void *)arg, token);\n}\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    (void)token;\n    return OS_SUCCESS;\n}\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    (void)token;\n    probe_log(\"OS_ObjectIdTransactionCancel called\");\n}\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    (void)token;\n    probe_log(\"OS_ObjectIdConvertToken called for obj_id=%d\", token ? token->obj_id : -1);\n    return OS_SUCCESS;\n}\nint32 OS_ObjectIdFinalizeNew(int32 return_code, OS_object_token_t *token, void *arg)\n{\n    (void)arg;\n    probe_log(\"OS_ObjectIdFinalizeNew called: return_code=%d obj_id=%d\", return_code, token ? token->obj_id : -1);\n    return return_code;\n}\nint32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    probe_log(\"ENTER: OS_ObjectIdAllocateNew idtype=%u name_ptr=%p name=\\\"%s\\\" token_ptr=%p\",\n              (unsigned)idtype,\n              (const void *)name,\n              (name != NULL) ? name : \"(null)\",\n              (void *)token);\n\n    /*\n     * No new objects can be created after Shutdown request\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        probe_log(\"ABORT: shutdown state detected (GlobalState=0x%08X)\", OS_SharedGlobalVars.GlobalState);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);\n    probe_log(\"After TransactionInit: return_code=%d\", return_code);\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"TransactionInit failed, returning %d\", return_code);\n        return return_code;\n    }\n\n    /*\n     * Check if an object of the same name already exists.\n     * If so, a new object cannot be allocated.\n     */\n    if (name != NULL)\n    {\n        /* Log details about the cast that causes the const qualifier to be discarded. */\n        probe_log(\"About to call OS_ObjectIdFindNextMatch. name (const char *) = %p, contents=\\\"%s\\\"\",\n                  (const void *)name, name);\n        probe_log(\"Casting away const: calling OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token)\");\n\n        /* The original code casts away const here; preserved to reproduce the scenario. */\n        return_code = OS_ObjectIdFindNextMatch(OS_ObjectNameMatch, (void *)name, token);\n\n        probe_log(\"OS_ObjectIdFindNextMatch returned %d\", return_code);\n    }\n    else\n    {\n        probe_log(\"No name provided (name == NULL), setting return_code = OS_ERR_NAME_NOT_FOUND\");\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"Name match found: setting return_code = OS_ERR_NAME_TAKEN\");\n        return_code = OS_ERR_NAME_TAKEN;\n    }\n    else\n    {\n        probe_log(\"Name not found; attempting to find next free ID (current return_code=%d)\", return_code);\n        return_code = OS_ObjectIdFindNextFree(token);\n        probe_log(\"OS_ObjectIdFindNextFree returned %d\", return_code);\n    }\n\n    /* If allocation failed, abort the operation now - no ID was allocated.\n     * After this point, if a future step fails, the allocated ID must be\n     * released. */\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Allocation failed (return_code=%d). Cancelling transaction.\", return_code);\n        OS_ObjectIdTransactionCancel(token);\n        probe_log(\"EXIT: OS_ObjectIdAllocateNew returning %d\", return_code);\n        return return_code;\n    }\n    else\n    {\n        probe_log(\"Allocation succeeded so far; notifying event for obj_id=%d\", token ? token->obj_id : -1);\n        return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n        probe_log(\"OS_NotifyEvent returned %d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_ObjectIdConvertToken(token);\n        probe_log(\"OS_ObjectIdConvertToken returned %d\", return_code);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Finalization needed, calling OS_ObjectIdFinalizeNew with return_code=%d\", return_code);\n        return_code = OS_ObjectIdFinalizeNew(return_code, token, NULL);\n    }\n\n    probe_log(\"EXIT: OS_ObjectIdAllocateNew returning %d\", return_code);\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code casts away the const qualifier when calling OS_ObjectIdFindNextMatch: name is const char * but is passed as (void *)name to a function whose parameter is a non-const void *. This discards the const qualifier and violates the intent of MISRA C 2023 Rule 8.13 (pointers should be to const-qualified types whenever possible). The proper fix is to make the API accept a const-qualified pointer (e.g. change OS_ObjectIdFindNextMatch to take const void *arg and ensure the match callback also accepts const void *), and then call it without the cast."
}