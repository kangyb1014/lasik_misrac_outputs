{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_TaskSetPriority:\n```c\nint32 OS_TaskSetPriority(osal_id_t task_id, osal_priority_t new_priority)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        return_code = OS_TaskSetPriority_Impl(&token, new_priority);\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* Use the abstracted priority, not the OS one */\n            /* Change the priority in the table as well */\n            task->priority = new_priority;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_TaskSetPriority:\nint32 OS_TaskSetPriority_Impl(const OS_object_token_t *token, osal_priority_t new_priority)\n{\n    int os_priority;\n    int ret;\n\n    OS_impl_task_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /* Change OSAL priority into a priority that will work for this OS */\n        os_priority = OS_PriorityRemap(new_priority);\n\n        /*\n        ** Set priority\n        */\n        ret = pthread_setschedprio(impl->id, os_priority);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_setschedprio: Task ID = %lu, prio = %d, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), os_priority, strerror(ret));\n            return OS_ERROR;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_task_internal_record_t OS_task_table[LOCAL_NUM_OBJECTS]\n...\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\n#define OS_SUCCESS (0)\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    char            task_name[OS_MAX_API_NAME];\n    size_t          stack_size;\n    osal_priority_t priority;\n    osal_task_entry entry_function_pointer;\n    osal_task_entry delete_hook_pointer;\n    void *          entry_arg;\n    osal_stackptr_t stack_pointer;\n} OS_task_internal_record_t\n...\ntypedef uint8_t osal_priority_t\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic int OS_PriorityRemap(osal_priority_t InputPri)\n{\n    int OutputPri;\n\n    if (InputPri == 0)\n    {\n        /* use the \"MAX\" local priority only for OSAL tasks with priority=0 */\n        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMax;\n    }\n    else if (InputPri >= OS_MAX_TASK_PRIORITY)\n    {\n        /* use the \"MIN\" local priority only for OSAL tasks with priority=255 */\n        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMin;\n    }\n    else\n    {\n        /*\n         * Spread the remainder of OSAL priorities over the remainder of local priorities\n         *\n         * Note OSAL priorities use the VxWorks style with zero being the\n         * highest and OS_MAX_TASK_PRIORITY being the lowest, this inverts it\n         */\n        OutputPri = (OS_MAX_TASK_PRIORITY - 1) - (int)InputPri;\n\n        OutputPri *= (POSIX_GlobalVars.PriLimits.PriorityMax - POSIX_GlobalVars.PriLimits.PriorityMin) - 2;\n        OutputPri += OS_MAX_TASK_PRIORITY / 2;\n        OutputPri /= (OS_MAX_TASK_PRIORITY - 2);\n        OutputPri += POSIX_GlobalVars.PriLimits.PriorityMin + 1;\n    }\n\n    return OutputPri;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);",
    "if (InputPri == 0)\n    {\n        /* use the \"MAX\" local priority only for OSAL tasks with priority=0 */\n        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMax;\n    }\n    else if (InputPri >= OS_MAX_TASK_PRIORITY)\n    {\n        /* use the \"MIN\" local priority only for OSAL tasks with priority=255 */\n        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMin;\n    }",
    "        if (return_code == OS_SUCCESS)\n        {\n            /* Use the abstracted priority, not the OS one */\n            /* Change the priority in the table as well */\n            task->priority = new_priority;\n        }",
    "token->obj_id = id;",
    "#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])",
    "    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /* Change OSAL priority into a priority that will work for this OS */\n        os_priority = OS_PriorityRemap(new_priority);\n\n        /*\n        ** Set priority\n        */\n        ret = pthread_setschedprio(impl->id, os_priority);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_setschedprio: Task ID = %lu, prio = %d, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), os_priority, strerror(ret));\n            return OS_ERROR;\n        }\n    }"
  ],
  "explanation": "I listed any assignments, macro uses, or conditional branches that could potentially be \"dead\" (i.e. executed but removable without changing observable behaviour) based on the provided snippets and typical OSAL usage patterns. I did not include the remaining fragments because:\n- Control-flow and transaction-management calls (OS_ObjectIdTransactionInit/Finish/Cancel, OS_ObjectIdConvertToken, return_code checks, OS_ObjectIdRelease) have clear side-effects (locking/unlocking, token state changes) and cannot be assumed dead without broader context.\n- The macro and inline functions used to index tables (OS_ObjectIndexFromToken, OS_OBJECT_TABLE_GET) are necessary to access the object tables; while their exact form may be questionable, their use is not by itself dead code because they produce side-effects (addressing) used by subsequent operations.\n- Declarations, typedefs, array definitions and return statements are structural and necessary; they are not dead code under Rule 2.2 (they either allocate storage or affect compilation/linkage).\n- The remaining arithmetic in OS_PriorityRemap (the else branch) is needed to compute mapped priorities when neither special-case branch applies.\nThese non-reported fragments therefore have evident runtime effects or are required for correct program operation and so are not flagged as suspicious for dead-code under Rule 2.2 based solely on the provided excerpts."
}