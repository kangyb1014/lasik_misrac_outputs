{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call memchr(name_ptr, 0, OS_MAX_FILE_NAME) can read up to OS_MAX_FILE_NAME bytes starting at name_ptr. name_ptr points into VirtualPath just after the last '/'. Although OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) ensured a terminating '\\0' exists within the first OS_MAX_PATH_LEN bytes, it does not guarantee that there are OS_MAX_FILE_NAME bytes available from name_ptr. If the filename (characters from name_ptr up to and including the terminator) is shorter than OS_MAX_FILE_NAME, memchr will attempt to access bytes beyond the end of the VirtualPath object, causing an out\u2011of\u2011bounds access. Example: with OS_MAX_FILE_NAME = 10 and VirtualPath = \"/dir/x\" (only 2 bytes including '\\0' from name_ptr), memchr will read 10 bytes starting at name_ptr and overruns the object. This violates MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_mkdir code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1231.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_mkdir as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_mkdir:\n```c\nint32 OS_mkdir(const char *path, uint32 access)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirCreate_Impl(local_path, access);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_mkdir code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/*\n * Probing helpers for OS_mkdir to log control flow and relevant state\n * to /tmp/logs/1231.txt. These helpers are lightweight and do not\n * change the original logic or return values of OS_mkdir.\n */\nstatic size_t safe_strnlen(const char *s, size_t max)\n{\n    size_t i = 0;\n    if (s == (const char *)0)\n    {\n        return 0u;\n    }\n\n    while (i < max && s[i] != '\\0')\n    {\n        ++i;\n    }\n\n    return i;\n}\n\nstatic void append_log_entry(const char *event,\n                             const char *path, size_t path_len,\n                             const char *local_path, size_t local_len,\n                             long return_code, unsigned long access)\n{\n    FILE *f = fopen(\"/tmp/logs/1231.txt\", \"a\");\n    if (f == (FILE *)0)\n    {\n        return;\n    }\n\n    /* Print the event, the path (bounded by path_len), the local_path (bounded by local_len),\n     * and key numeric state. Using %.*s ensures we never read beyond the provided length.\n     */\n    fprintf(f, \"EVENT=%s\\n\", event);\n    fprintf(f, \"  return_code=%ld access=%lu\\n\", return_code, access);\n    fprintf(f, \"  path_len=%zu local_path_len=%zu\\n\", path_len, local_len);\n    fprintf(f, \"  path=\\\"\");\n    if (path != (const char *)0 && path_len > 0u)\n    {\n        fprintf(f, \"%.*s\", (int)path_len, path);\n    }\n    fprintf(f, \"\\\"\\n\");\n\n    fprintf(f, \"  local_path=\\\"\");\n    if (local_path != (const char *)0 && local_len > 0u)\n    {\n        fprintf(f, \"%.*s\", (int)local_len, local_path);\n    }\n    fprintf(f, \"\\\"\\n\");\n\n    fprintf(f, \"----\\n\");\n    fclose(f);\n}\n\nint32 OS_mkdir(const char *path, uint32 access)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log function entry and the provided path (bounded) */\n    append_log_entry(\"entry\", path, safe_strnlen(path, 4096u), (const char *)0, 0u, -1L, (unsigned long)access);\n\n    return_code = OS_TranslatePath(path, local_path);\n\n    /* Log after translation attempt; include the translated local_path up to the buffer limit */\n    append_log_entry(\"after_translate\", path, safe_strnlen(path, 4096u), local_path, safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN), (long)return_code, (unsigned long)access);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log just before calling the implementation to create the directory */\n        append_log_entry(\"before_create\", path, safe_strnlen(path, 4096u), local_path, safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN), (long)return_code, (unsigned long)access);\n\n        return_code = OS_DirCreate_Impl(local_path, access);\n\n        /* Log after the implementation call */\n        append_log_entry(\"after_create\", path, safe_strnlen(path, 4096u), local_path, safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN), (long)return_code, (unsigned long)access);\n    }\n    else\n    {\n        /* Log the failure to translate the path */\n        append_log_entry(\"translate_failed\", path, safe_strnlen(path, 4096u), local_path, safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN), (long)return_code, (unsigned long)access);\n    }\n\n    /* Final return log (also useful to mark exit) */\n    append_log_entry(\"return\", path, safe_strnlen(path, 4096u), local_path, safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN), (long)return_code, (unsigned long)access);\n\n    return return_code;\n}\n"
}