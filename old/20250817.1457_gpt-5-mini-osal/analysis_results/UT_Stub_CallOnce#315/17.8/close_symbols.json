{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CallOnce': {'callees': ['UtAssert_Abort'], 'callers': ['UT_AllocStubObjId', 'UT_DeleteStubObjId']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_AllocStubObjId': {'callees': ['UT_Stub_CallOnce', 'UtAssert_Abort', 'UtAssert_GetContext', 'UT_ObjIdCompose'], 'callers': ['UT_DefaultHandler_OS_BinSemCreate', 'UT_DefaultHandler_OS_CountSemCreate', 'UT_DefaultHandler_OS_DirectoryOpen', 'UT_DefaultHandler_OS_OpenCreate', 'UT_DefaultHandler_OS_FileSysAddFixedMap', 'UT_DefaultHandler_OS_ModuleLoad', 'UT_DefaultHandler_OS_MutSemCreate', 'UT_DefaultHandler_OS_QueueCreate', 'UT_DefaultHandler_OS_SocketOpen', 'UT_DefaultHandler_OS_TaskCreate', 'UT_DefaultHandler_OS_TimerAdd', 'UT_DefaultHandler_OS_TimerCreate', 'UT_DefaultHandler_OS_TimeBaseCreate']}, 'UT_DeleteStubObjId': {'callees': ['UT_Stub_CallOnce', 'UT_ObjIdDecompose', 'UtAssert_GetContext'], 'callers': ['UT_DefaultHandler_OS_BinSemDelete', 'UT_DefaultHandler_OS_CountSemDelete', 'UT_DefaultHandler_OS_DirectoryClose', 'UT_DefaultHandler_OS_close', 'UT_DefaultHandler_OS_ModuleUnload', 'UT_DefaultHandler_OS_MutSemDelete', 'UT_DefaultHandler_OS_QueueDelete', 'UT_DefaultHandler_OS_TaskDelete', 'UT_DefaultHandler_OS_TimerDelete', 'UT_DefaultHandler_OS_TimeBaseDelete']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t",
    "UT_StubTableEntry_t",
    "UT_StubTable",
    "UT_MAX_FUNC_STUBS",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_CALL_ONCE"
  ],
  "explanation": "UT_EntryKey_t: needed to know the underlying type of FuncKey so you can confirm the cast FuncKey = (UT_EntryKey_t)Func is a simple value conversion and does not create an alias that would modify the parameter itself.\n\nUT_StubTableEntry_t: required to see the types of the fields (EntryType, FuncKey). This verifies that assigning OnceEnt->FuncKey stores a copy into the table entry and does not write back into the parameter variable Func.\n\nUT_StubTable: definition/type of the global table (pointer/array) is needed to ensure the code that walks and modifies entries (OnceEnt, StubPtr) cannot indirectly modify the parameter Func (for example via weird macros or aliasing of storage).\n\nUT_MAX_FUNC_STUBS: loop bound is required to understand the loop semantics and ensure no operations in the loop could modify the parameter (e.g., via pointer arithmetic or indexing beyond table bounds that might alias parameter storage in an unexpected implementation-defined way).\n\nUT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_CALL_ONCE: the enum/macro values for EntryType are required to confirm the code paths that set OnceEnt->EntryType and OnceEnt->FuncKey are normal field assignments (not macros that expand to assignments involving the parameter)."
}