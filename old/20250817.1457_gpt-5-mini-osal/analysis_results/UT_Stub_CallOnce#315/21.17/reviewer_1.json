{
  "user_message": "An agent A claimed that the following UT_Stub_CallOnce code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CallOnce.\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strlen(OutputMessage) is not protected against OutputMessage being NULL or not NUL\u2011terminated. If UT_BSP_DoText is ever invoked with OutputMessage == NULL (or with a char buffer that is not NUL\u2011terminated), strlen will read beyond the object (or dereference NULL), causing undefined behavior. For example, a caller invoking UT_BSP_DoText(UTASSERT_CASETYPE_X, NULL) or passing a non\u2011terminated buffer would trigger an out\u2011of\u2011bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    FILE *logf = fopen(\"/tmp/logs/2527.txt\", \"a\");\n\n    if (logf)\n    {\n        fprintf(logf, \"UT_Stub_CallOnce: Enter - Func=%p\\n\", (void *)Func);\n        fflush(logf);\n    }\n\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        if (logf)\n        {\n            fprintf(logf, \"UT_Stub_CallOnce: Func is NULL, returning early\\n\");\n            fclose(logf);\n        }\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    if (logf)\n    {\n        /* Print FuncKey as an opaque pointer-sized value to aid debugging */\n        fprintf(logf, \"UT_Stub_CallOnce: Computed FuncKey=%p\\n\", (void *)(uintptr_t)FuncKey);\n        fflush(logf);\n    }\n\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (logf)\n        {\n            if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED)\n            {\n                /* Avoid reading uninitialized FuncKey when entry is UNUSED */\n                fprintf(logf, \"UT_Stub_CallOnce: idx=%d EntryType=UNUSED\\n\", i);\n            }\n            else\n            {\n                fprintf(logf, \"UT_Stub_CallOnce: idx=%d EntryType=%d FuncKey=%p\\n\", i, StubPtr->EntryType,\n                        (void *)(uintptr_t)StubPtr->FuncKey);\n            }\n            fflush(logf);\n        }\n\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n            if (logf)\n            {\n                fprintf(logf, \"UT_Stub_CallOnce: Recorded first UNUSED slot at idx=%d (OnceEnt set)\\n\", i);\n                fflush(logf);\n            }\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            if (logf)\n            {\n                fprintf(logf, \"UT_Stub_CallOnce: Found existing CALL_ONCE entry at idx=%d\\n\", i);\n                fflush(logf);\n            }\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        if (logf)\n        {\n            fprintf(logf, \"UT_Stub_CallOnce: OnceEnt is NULL - cannot proceed, aborting\\n\");\n            fclose(logf);\n        }\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        if (logf)\n        {\n            fprintf(logf, \"UT_Stub_CallOnce: Initializing OnceEnt: setting EntryType->CALL_ONCE, FuncKey=%p\\n\",\n                    (void *)(uintptr_t)FuncKey);\n            fflush(logf);\n            /* Close log before calling Func to ensure file is flushed and unlocked for other processes */\n            fclose(logf);\n            logf = NULL;\n        }\n\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        /* Log the invocation point (file was closed above to avoid holding it during callback) */\n        Func();\n    }\n    else\n    {\n        if (logf)\n        {\n            fprintf(logf, \"UT_Stub_CallOnce: OnceEnt already CALL_ONCE - nothing to do\\n\");\n            fclose(logf);\n        }\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Stub_CallOnce: Enter - Func=0x5599ec90d7c1\nUT_Stub_CallOnce: Computed FuncKey=0x5599ec90d7c1\nUT_Stub_CallOnce: idx=0 EntryType=UNUSED\nUT_Stub_CallOnce: Recorded first UNUSED slot at idx=0 (OnceEnt set)\nUT_Stub_CallOnce: idx=1 EntryType=UNUSED\nUT_Stub_CallOnce: idx=2 EntryType=UNUSED\nUT_Stub_CallOnce: idx=3 EntryType=UNUSED\nUT_Stub_CallOnce: idx=4 EntryType=UNUSED\nUT_Stub_CallOnce: idx=5 EntryType=UNUSED\nUT_Stub_CallOnce: idx=6 EntryType=UNUSED\nUT_Stub_CallOnce: idx=7 EntryType=UNUSED\nUT_Stub_CallOnce: idx=8 EntryType=UNUSED\nUT_Stub_CallOnce: idx=9 EntryType=7 FuncKey=0x5599ec90cb87\nUT_Stub_CallOnce: idx=10 EntryType=6 FuncKey=0x5599ec90cb87\nUT_Stub_CallOnce: idx=11 EntryType=1 FuncKey=0x5599ec90cb87\nUT_Stub_CallOnce: idx=12 EntryType=7 FuncKey=0x5599ec90aae3\nUT_Stub_CallOnce: idx=13 EntryType=1 FuncKey=0x5599ec90aae3\nUT_Stub_CallOnce: idx=14 EntryType=6 FuncKey=0x5599ec90aae3\nUT_Stub_CallOnce: idx=15 EntryType=UNUSED\nUT_Stub_CallOnce: idx=16 EntryType=UNUSED\nUT_Stub_CallOnce: idx=17 EntryType=UNUSED\nUT_Stub_CallOnce: idx=18 EntryType=UNUSED\nUT_Stub_CallOnce: idx=19 EntryType=UNUSED\nUT_Stub_CallOnce: idx=20 EntryType=UNUSED\nUT_Stub_CallOnce: idx=21 EntryType=UNUSED\nUT_Stub_CallOnce: idx=22 EntryType=UNUSED\nUT_Stub_CallOnce: idx=23 EntryType=UNUSED\nUT_Stub_CallOnce: idx=24 EntryType=UNUSED\nUT_Stub_CallOnce: idx=25 EntryType=UNUSED\nUT_Stub_CallOnce: idx=26 EntryType=UNUSED\nUT_Stub_CallOnce: idx=27 EntryType=UNUSED\nUT_Stub_CallOnce: idx=28 EntryType=UNUSED\nUT_Stub_CallOnce: idx=29 EntryType=UNUSED\nUT_Stub_CallOnce: idx=30 EntryType=UNUSED\nUT_Stub_CallOnce: idx=31 EntryType=UNUSED\nUT_Stub_CallOnce: idx=32 EntryType=UNUSED\nUT_Stub_CallOnce: idx=33 EntryType=UNUSED\nUT_Stub_CallOnce: idx=34 EntryType=UNUSED\nUT_Stub_CallOnce: idx=35 EntryType=UNUSED\nUT_Stub_CallOnce: idx=36 EntryType=UNUSED\nUT_Stub_CallOnce: idx=37 EntryType=UNUSED\nUT_Stub_CallOnce: idx=38 EntryType=UNUSED\nUT_Stub_CallOnce: idx=39 EntryType=UNUSED\nUT_Stub_CallOnce: idx=40 EntryType=UNUSED\nUT_Stub_CallOnce: idx=41 EntryType=UNUSED\nUT_Stub_CallOnce: idx=42 EntryType=UNUSED\nUT_Stub_CallOnce: idx=43 EntryType=UNUSED\nUT_Stub_CallOnce: idx=44 EntryType=UNUSED\nUT_Stub_CallOnce: idx=45 EntryType=UNUSED\nUT_Stub_CallOnce: idx=46 EntryType=UNUSED\nUT_Stub_CallOnce: idx=47 EntryType=UNUSED\nUT_Stub_CallOnce: idx=48 EntryType=UNUSED\nUT_Stub_CallOnce: idx=49 EntryType=UNUSED\nUT_Stub_CallOnce: idx=50 EntryType=UNUSED\nUT_Stub_CallOnce: idx=51 EntryType=UNUSED\nUT_Stub_CallOnce: idx=52 EntryType=UNUSED\nUT_Stub_CallOnce: idx=53 EntryType=UNUSED\nUT_Stub_CallOnce: idx=54 EntryType=UNUSED\nUT_Stub_CallOnce: idx=55 EntryType=UNUSED\nUT_Stub_CallOnce: idx=56 EntryType=UNUSED\nUT_Stub_CallOnce: idx=57 EntryType=UNUSED\nUT_Stub_CallOnce: idx=58 EntryType=UNUSED\nUT_Stub_CallOnce: idx=59 EntryType=UNUSED\nUT_Stub_CallOnce: idx=60 EntryType=UNUSED\nUT_Stub_CallOnce: idx=61 EntryType=UNUSED\nUT_Stub_CallOnce: idx=62 EntryType=UNUSED\nUT_Stub_CallOnce: idx=63 EntryType=UNUSED\nUT_Stub_CallOnce: idx=64 EntryType=UNUSED\nUT_Stub_CallOnce: idx=65 EntryType=UNUSED\nUT_Stub_CallOnce: idx=66 EntryType=UNUSED\nUT_Stub_CallOnce: idx=67 EntryType=UNUSED\nUT_Stub_CallOnce: idx=68 EntryType=UNUSED\nUT_Stub_CallOnce: idx=69 EntryType=UNUSED\nUT_Stub_CallOnce: idx=70 EntryType=UNUSED\nUT_Stub_CallOnce: idx=71 EntryType=UNUSED\nUT_Stub_CallOnce: idx=72 EntryType=UNUSED\nUT_Stub_CallOnce: idx=73 EntryType=UNUSED\nUT_Stub_CallOnce: idx=74 EntryType=UNUSED\nUT_Stub_CallOnce: idx=75 EntryType=UNUSED\nUT_Stub_CallOnce: idx=76 EntryType=UNUSED\nUT_Stub_CallOnce: idx=77 EntryType=UNUSED\nUT_Stub_CallOnce: idx=78 EntryType=UNUSED\nUT_Stub_CallOnce: idx=79 EntryType=8 FuncKey=0x5599ec90ef8f\nUT_Stub_CallOnce: idx=80 EntryType=UNUSED\nUT_Stub_CallOnce: idx=81 EntryType=UNUSED\nUT_Stub_CallOnce: idx=82 EntryType=UNUSED\nUT_Stub_CallOnce: idx=83 EntryType=UNUSED\nUT_Stub_CallOnce: idx=84 EntryType=UNUSED\nUT_Stub_CallOnce: idx=85 EntryType=UNUSED\nUT_Stub_CallOnce: idx=86 EntryType=UNUSED\nUT_Stub_CallOnce: idx=87 EntryType=UNUSED\nUT_Stub_CallOnce: idx=88 EntryType=UNUSED\nUT_Stub_CallOnce: idx=89 EntryType=UNUSED\nUT_Stub_CallOnce: idx=90 EntryType=U\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The UT_Stub_CallOnce implementation shown does not use any functions from <string.h> (no strlen, strcpy, memcpy, etc.) and therefore cannot violate MISRA C 2023 Rule 21.17. The scenario cited by agent A refers to a separate function (UT_BSP_DoText) and a strlen(OutputMessage) call; that call is not present in UT_Stub_CallOnce and the provided logs show only pointer checks, table iteration and assignments (including an explicit check for Func == NULL). Thus there is no evidence in the shown code that string.h functions are used or that an out\u2011of\u2011bounds string access occurs here."
}