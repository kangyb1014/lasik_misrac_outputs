{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CallOnce': {'callees': ['UtAssert_Abort'], 'callers': ['UT_AllocStubObjId', 'UT_DeleteStubObjId']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_AllocStubObjId': {'callees': ['UT_Stub_CallOnce', 'UtAssert_Abort', 'UtAssert_GetContext', 'UT_ObjIdCompose'], 'callers': ['UT_DefaultHandler_OS_BinSemCreate', 'UT_DefaultHandler_OS_CountSemCreate', 'UT_DefaultHandler_OS_DirectoryOpen', 'UT_DefaultHandler_OS_OpenCreate', 'UT_DefaultHandler_OS_FileSysAddFixedMap', 'UT_DefaultHandler_OS_ModuleLoad', 'UT_DefaultHandler_OS_MutSemCreate', 'UT_DefaultHandler_OS_QueueCreate', 'UT_DefaultHandler_OS_SocketOpen', 'UT_DefaultHandler_OS_TaskCreate', 'UT_DefaultHandler_OS_TimerAdd', 'UT_DefaultHandler_OS_TimerCreate', 'UT_DefaultHandler_OS_TimeBaseCreate']}, 'UT_DeleteStubObjId': {'callees': ['UT_Stub_CallOnce', 'UT_ObjIdDecompose', 'UtAssert_GetContext'], 'callers': ['UT_DefaultHandler_OS_BinSemDelete', 'UT_DefaultHandler_OS_CountSemDelete', 'UT_DefaultHandler_OS_DirectoryClose', 'UT_DefaultHandler_OS_close', 'UT_DefaultHandler_OS_ModuleUnload', 'UT_DefaultHandler_OS_MutSemDelete', 'UT_DefaultHandler_OS_QueueDelete', 'UT_DefaultHandler_OS_TaskDelete', 'UT_DefaultHandler_OS_TimerDelete', 'UT_DefaultHandler_OS_TimeBaseDelete']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_MAX_FUNC_STUBS",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_CALL_ONCE",
    "UT_StubTable",
    "UtAssert_Abort",
    "UT_BSP_DoText"
  ],
  "explanation": "- UT_StubTableEntry_t: The structure type of elements stepped through by StubPtr. Need its field types and layout (EntryType, FuncKey) to confirm that pointer arithmetic ++StubPtr and accesses StubPtr->EntryType/FuncKey are within bounds and do not alias or hide any embedded string buffers that could be manipulated with <string.h> functions.\n- UT_EntryKey_t: The type used to store function-pointer keys (FuncKey). Its underlying type (pointer, integer width) matters to verify the cast (UT_EntryKey_t)Func and subsequent comparisons do not cause undefined behavior or hidden pointer reinterpretations that might relate to buffer bounds.\n- UT_MAX_FUNC_STUBS: The loop bound. Required to determine the intended number of entries and to verify the loop and StubPtr increments cannot advance beyond the allocated UT_StubTable storage.\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_CALL_ONCE: The enum/constant values compared against and assigned to EntryType. Need their definitions to ensure no side effects/macros and to understand valid state transitions (and whether any of these constants imply use of string buffers elsewhere).\n- UT_StubTable: The actual table object (pointer/array) iterated by StubPtr. Its declaration and allocation size are required to confirm that advancing StubPtr up to UT_MAX_FUNC_STUBS elements is safe and does not access memory beyond the object.\n- UtAssert_Abort: This function is called when OnceEnt == NULL. To prove the target function does not introduce any violations of the <string.h> rule, UtAssert_Abort\u2019s implementation (or prototype) must be examined because it may call string.h functions (directly or indirectly) and thus could cause out-of-bounds accesses.\n- UT_BSP_DoText: Static call graph shows UtAssert_Abort calls UT_BSP_DoText. Include its implementation because it is an immediate callee that may use standard string functions (e.g., copying/formatting text) and therefore could be the site of any rule violation triggered by the assert path.\n\nNote: The caller-supplied Func() could itself use string.h functions, but analyzing arbitrary callbacks is out of scope for verifying whether UT_Stub_CallOnce itself (and the functions it directly/indirectly invokes) violate the rule; if you need to cover possible callback behavior, include the concrete callback implementations that are passed to UT_Stub_CallOnce in your test/usage scenarios."
}