{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CallOnce': {'callees': ['UtAssert_Abort'], 'callers': ['UT_AllocStubObjId', 'UT_DeleteStubObjId']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_AllocStubObjId': {'callees': ['UT_Stub_CallOnce', 'UtAssert_Abort', 'UtAssert_GetContext', 'UT_ObjIdCompose'], 'callers': ['UT_DefaultHandler_OS_BinSemCreate', 'UT_DefaultHandler_OS_CountSemCreate', 'UT_DefaultHandler_OS_DirectoryOpen', 'UT_DefaultHandler_OS_OpenCreate', 'UT_DefaultHandler_OS_FileSysAddFixedMap', 'UT_DefaultHandler_OS_ModuleLoad', 'UT_DefaultHandler_OS_MutSemCreate', 'UT_DefaultHandler_OS_QueueCreate', 'UT_DefaultHandler_OS_SocketOpen', 'UT_DefaultHandler_OS_TaskCreate', 'UT_DefaultHandler_OS_TimerAdd', 'UT_DefaultHandler_OS_TimerCreate', 'UT_DefaultHandler_OS_TimeBaseCreate']}, 'UT_DeleteStubObjId': {'callees': ['UT_Stub_CallOnce', 'UT_ObjIdDecompose', 'UtAssert_GetContext'], 'callers': ['UT_DefaultHandler_OS_BinSemDelete', 'UT_DefaultHandler_OS_CountSemDelete', 'UT_DefaultHandler_OS_DirectoryClose', 'UT_DefaultHandler_OS_close', 'UT_DefaultHandler_OS_ModuleUnload', 'UT_DefaultHandler_OS_MutSemDelete', 'UT_DefaultHandler_OS_QueueDelete', 'UT_DefaultHandler_OS_TaskDelete', 'UT_DefaultHandler_OS_TimerDelete', 'UT_DefaultHandler_OS_TimeBaseDelete']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_StubTable",
    "UT_MAX_FUNC_STUBS",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_CALL_ONCE",
    "UtAssert_Abort"
  ],
  "explanation": "UT_StubTableEntry_t: the full struct definition (field names and types for EntryType, FuncKey, and any other fields) is required to know which members are modified or only read. If the code never modifies certain members, those members (and pointers to the struct) might be candidates for const qualification; conversely if members are modified, they cannot be const.\n\nUT_EntryKey_t: the typedef for FuncKey (its underlying type) is needed to determine whether casting the function pointer into this key type affects const-correctness or implies mutation of pointed-to data (e.g., if it is a pointer type versus an integral type).\n\nUT_StubTable: the declaration (extern/definition) and its qualifier (is it an array, pointer, declared const?) are required to decide whether StubPtr and OnceEnt should be pointers-to-const or not. If the table is declared const, using non-const pointers would be a const-violation; if it is non-const but never modified, pointers could be const-qualified.\n\nUT_MAX_FUNC_STUBS: the size/limit constant is needed only to confirm loop bounds and whether the loop reads or writes within the table range; it helps determine if the table is actually treated as mutable or purely read-mostly (affects whether pointer-to-const is appropriate).\n\nUT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_CALL_ONCE: the definitions/values (enum or macros) are needed to understand which branches read-only inspect EntryType and which branches cause writes (the code writes OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE). Knowing these symbols shows which table entries are mutated and therefore whether pointers to entries can/should be const.\n\nUtAssert_Abort: the function prototype is needed because it is called with a string literal. If UtAssert_Abort's parameter is non-const char* this call would discard const qualification of the string literal and be a MISRA violation; if it accepts const char* then no violation. Thus the prototype (parameter types and const qualifiers) must be known."
}