{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CallOnce:\n```c\nvoid UT_Stub_CallOnce(void (*Func)(void))\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *OnceEnt;\n    UT_EntryKey_t        FuncKey;\n    int32                i;\n\n    if (Func == NULL)\n    {\n        return;\n    }\n\n    FuncKey = (UT_EntryKey_t)Func;\n    OnceEnt = NULL;\n    StubPtr = UT_StubTable;\n    for (i = 0; i < UT_MAX_FUNC_STUBS; ++i)\n    {\n        if (StubPtr->EntryType == UT_ENTRYTYPE_UNUSED && OnceEnt == NULL)\n        {\n            OnceEnt = StubPtr;\n        }\n        else if (StubPtr->EntryType == UT_ENTRYTYPE_CALL_ONCE && StubPtr->FuncKey == FuncKey)\n        {\n            OnceEnt = StubPtr;\n            break;\n        }\n        ++StubPtr;\n    }\n\n    if (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else if (OnceEnt->EntryType == UT_ENTRYTYPE_UNUSED)\n    {\n        OnceEnt->EntryType = UT_ENTRYTYPE_CALL_ONCE;\n        OnceEnt->FuncKey   = FuncKey;\n\n        Func();\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Stub_CallOnce:\nstatic UT_StubTableEntry_t UT_StubTable[UT_MAX_FUNC_STUBS] = {{0}}\n...\n#define UT_MAX_FUNC_STUBS 200\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nosal_id_t UT_AllocStubObjId(osal_objtype_t ObjType)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    uint32             indx;\n    osal_id_t          Result;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    if (ObjType == OS_OBJECT_TYPE_UNDEFINED || ObjType >= OS_OBJECT_TYPE_USER)\n    {\n        /* Code is broken, abort the test\n         * (This signifies an error in the stub code itself hence the abort)\n         */\n        UtAssert_Abort(\"ObjType out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    if (StatePtr->LastIssueNumber < ((8 * sizeof(StatePtr->ValidBits)) - 1))\n    {\n        ++StatePtr->LastIssueNumber;\n    }\n\n    indx = StatePtr->LastIssueNumber;\n\n    ObjMask = 1 << (indx & 0x07);\n    /*\n     * Check for overlap/re-issue - this COULD happen when using\n     * the original (non-opaque) object IDs if a UT creates too many\n     * objects of a certain type.  There is really no way around this\n     * and it means the test needs to be revised to not create so many\n     * objects OR it needs to support opaque object IDs\n     */\n    if ((StatePtr->ValidBits[indx >> 3] & ObjMask) != 0)\n    {\n        UtAssert_Failed(\"OSAPI UT stub object overlap\");\n    }\n    StatePtr->ValidBits[indx >> 3] |= ObjMask;\n\n    /*\n     * Finalize Object ID - put into proper range for type\n     */\n    UT_ObjIdCompose(indx, ObjType, &Result);\n\n    return Result;\n}\n...\nvoid UT_DeleteStubObjId(osal_objtype_t ObjType, osal_id_t ObjId)\n{\n    UT_ObjTypeState_t *StatePtr;\n    uint8              ObjMask;\n    osal_objtype_t     checktype;\n    uint32             checkidx;\n    bool               ObjWasValid;\n\n    UT_Stub_CallOnce(UT_ClearAllStubObjects);\n\n    UT_ObjIdDecompose(ObjId, &checkidx, &checktype);\n\n    /*\n     * Verify the object type\n     */\n    if (ObjType != checktype)\n    {\n        /* Calling code is broken, abort the test */\n        UtAssert_Failed(\"Object type is not correct\");\n    }\n\n    if (checkidx >= (8 * sizeof(StatePtr->ValidBits)))\n    {\n        /* Calling code is broken */\n        UtAssert_Failed(\"ObjId out of range\");\n    }\n\n    StatePtr = &UT_ObjState[ObjType];\n\n    /* Clear out any bit it could have been */\n    ObjWasValid = false;\n    ObjMask     = 1 << (checkidx & 0x07);\n    if ((StatePtr->ValidBits[checkidx >> 3] & ObjMask) != 0)\n    {\n        ObjWasValid = true;\n        StatePtr->ValidBits[checkidx >> 3] &= ~ObjMask;\n    }\n\n    /* Unfortunately, some code has a habit of just blindly calling \"Delete\"\n     * regardless of whether those entities were created or not.  This is\n     * an issue on the non-opaque OSAL implementations and will produce\n     * thousands of failed test cases, so this can only be verified\n     * on the opaque objid versions.\n     */\n    if (!ObjWasValid)\n    {\n        /*\n         * These stubs can be more strict about the usage patterns.\n         *\n         * In general any app calling delete on an ID they did not create likely\n         * signifies an error in that application.\n         */\n        UtAssert_Failed(\"Deleted object that was never created\");\n    }\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (OnceEnt == NULL)\n    {\n        /* should never happen -- UT_MAX_FUNC_STUBS needs increase if it does */\n        UtAssert_Abort(\"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\");\n    }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The UtAssert_Abort() branch is reachable if the stub table contains no UT_ENTRYTYPE_UNUSED entries and no matching UT_ENTRYTYPE_CALL_ONCE entry (e.g. all UT_MAX_FUNC_STUBS entries are in use). This is defensive/error handling: removing it would change program behaviour in that error case, so it is not dead code."
}