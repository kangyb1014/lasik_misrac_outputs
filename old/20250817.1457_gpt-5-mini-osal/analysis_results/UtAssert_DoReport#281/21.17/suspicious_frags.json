{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of UtAssert_DoReport:\n```c\nvoid UtAssert_DoReport(const char *File, uint32 LineNum, uint32 SegmentNum, uint32 TestSeq, uint8 MessageType,\n                       const char *SubsysName, const char *ShortDesc)\n{\n    uint32      FileLen;\n    const char *BasePtr;\n    char        ReportBuffer[320];\n\n    FileLen = strlen(File);\n    BasePtr = File + FileLen;\n    while (FileLen > 0)\n    {\n        --BasePtr;\n        --FileLen;\n        if (*BasePtr == '/' || *BasePtr == '\\\\')\n        {\n            ++BasePtr;\n            break;\n        }\n    }\n\n    snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u.%03u %s:%u - %s\", (unsigned int)SegmentNum,\n             (unsigned int)TestSeq, BasePtr, (unsigned int)LineNum, ShortDesc);\n\n    UT_BSP_DoText(MessageType, ReportBuffer);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function UtAssert_DoReport:\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n...\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "while (FileLen > 0)\n    {\n        --BasePtr;\n        --FileLen;\n        if (*BasePtr == '/' || *BasePtr == '\\\\')\n        {\n            ++BasePtr;\n            break;\n        }\n    }",
    "OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);",
    "snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));",
    "OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));",
    "snprintf(ReportBuffer, sizeof(ReportBuffer), \"%02u.%03u %s:%u - %s\", (unsigned int)SegmentNum,\n             (unsigned int)TestSeq, BasePtr, (unsigned int)LineNum, ShortDesc);",
    "MsgLen = strlen(OutputMessage);",
    "if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }",
    "va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);",
    "FileLen = strlen(File);"
  ],
  "explanation": "I listed all code fragments that perform string handling or compute string lengths and that therefore could lead to accesses beyond the bounds of the referenced objects (strlen calls, uses of %s in formatted output, vsnprintf with external format/args, and indexing based on strlen). These are the locations that require investigation for compliance with MISRA C 2023 Rule 21.17.\n\nOther fragments in the provided code were not listed because they do not invoke string.h functions or do not perform reads of string objects that depend on external lengths. Examples:\n- Buffer is written via snprintf with an explicit size; snprintf guarantees not to write beyond the provided buffer size, so the write target is bounded. The subsequent strlen(Buffer) reads the buffer produced by that bounded snprintf.\n- The local ReportBuffer and FinalMessage are constructed with snprintf/vsnprintf using explicit size arguments, which bound writes to those destination arrays. Those lines still were included for inspection where the source strings (BasePtr, ShortDesc, format/varargs) could cause unbounded reads; otherwise the mere presence of a bounded snprintf/vsnprintf write was not listed as suspect by itself.\n- Calls that output fixed short literals (e.g., OS_BSP_ConsoleOutput_Impl(\"\\n\", 1) or OS_BSP_ConsoleOutput_Impl(\" \", 1)) do not read beyond bounds and were not included.\n\nIf further narrowing is desired, investigators should focus on: whether File, ShortDesc, MessageFormat and the variadic arguments (and OutputMessage) are guaranteed to be valid, null-terminated, and point to objects large enough to satisfy the string reads performed by strlen or the %s conversions."
}