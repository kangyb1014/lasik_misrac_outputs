{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nWhen the error number is not found in OS_GLOBAL_ERROR_NAME_TABLE, the code assigns Error = OS_IMPL_ERROR_NAME_TABLE and then evaluates the while condition. However OS_IMPL_ERROR_NAME_TABLE is defined as a single sentinel entry {{0, NULL}}, so the inner loop never advances and Error ends up pointing to a sentinel equivalent to the global table's end marker. The assignment (and the inner loop evaluation) therefore has no effect on subsequent behavior and could be removed without changing program behavior. This constitutes dead code under MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_GetErrorName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1242.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_GetErrorName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_GetErrorName:\n```c\nint32 OS_GetErrorName(int32 error_num, os_err_name_t *err_name)\n{\n    int32                        return_code;\n    const OS_ErrorTable_Entry_t *Error;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(err_name);\n\n    Error = OS_GLOBAL_ERROR_NAME_TABLE;\n    while (Error->Name != NULL && Error->Number != error_num)\n    {\n        ++Error;\n    }\n\n    if (Error->Number != error_num)\n    {\n        Error = OS_IMPL_ERROR_NAME_TABLE;\n        while (Error->Name != NULL && Error->Number != error_num)\n        {\n            ++Error;\n        }\n    }\n\n    if (Error->Number == error_num && Error->Name != NULL)\n    {\n        strncpy(*err_name, Error->Name, sizeof(*err_name) - 1);\n        *err_name[sizeof(*err_name) - 1] = 0;\n        return_code                      = OS_SUCCESS;\n    }\n    else\n    {\n        snprintf(*err_name, OS_ERROR_NAME_LENGTH, \"OS_UNKNOWN(%d)\", (int)error_num);\n        return_code = OS_ERROR;\n    }\n\n    (*err_name)[OS_ERROR_NAME_LENGTH - 1] = '\\0';\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_GetErrorName code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nstatic void os_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1242.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_GetErrorName(int32 error_num, os_err_name_t *err_name)\n{\n    int32                        return_code;\n    const OS_ErrorTable_Entry_t *Error;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(err_name);\n\n    os_log(\"OS_GetErrorName ENTRY: error_num=%d, err_name_ptr=%p\", (int)error_num, (void *)err_name);\n\n    Error = OS_GLOBAL_ERROR_NAME_TABLE;\n    os_log(\"Start searching GLOBAL table at %p (first.Name=%p, first.Number=%d)\", (const void *)Error,\n           (const void *)Error->Name, (int)Error->Number);\n\n    {\n        int global_iter = 0;\n        while (Error->Name != NULL && Error->Number != error_num)\n        {\n            os_log(\"GLOBAL loop iter=%d: ptr=%p, Name=%p, Number=%d\", global_iter,\n                   (const void *)Error, (const void *)Error->Name, (int)Error->Number);\n            ++Error;\n            ++global_iter;\n        }\n        os_log(\"GLOBAL loop exit after %d iters: ptr=%p, Name=%p, Number=%d\", global_iter,\n               (const void *)Error, (const void *)Error->Name, (int)Error->Number);\n    }\n\n    if (Error->Number != error_num)\n    {\n        os_log(\"Not found in GLOBAL (found Number=%d, Name=%p). Assigning Error = OS_IMPL_ERROR_NAME_TABLE\", (int)Error->Number,\n               (const void *)Error->Name);\n\n        Error = OS_IMPL_ERROR_NAME_TABLE;\n        os_log(\"Assigned impl table at %p (first.Name=%p, first.Number=%d)\", (const void *)Error,\n               (const void *)Error->Name, (int)Error->Number);\n\n        {\n            int impl_iter = 0;\n            while (Error->Name != NULL && Error->Number != error_num)\n            {\n                os_log(\"IMPL loop iter=%d: ptr=%p, Name=%p, Number=%d\", impl_iter,\n                       (const void *)Error, (const void *)Error->Name, (int)Error->Number);\n                ++Error;\n                ++impl_iter;\n\n                /* If impl table is the single-sentinel table, this will quickly show it by repeated logs\n                   where Name==NULL or Number==0; the logs allow reproducing the scenario described. */\n            }\n            os_log(\"IMPL loop exit after %d iters: ptr=%p, Name=%p, Number=%d\", impl_iter,\n                   (const void *)Error, (const void *)Error->Name, (int)Error->Number);\n        }\n    }\n\n    if (Error->Number == error_num && Error->Name != NULL)\n    {\n        os_log(\"MATCH found: ptr=%p, Name=%p, Number=%d -> copying name\", (const void *)Error,\n               (const void *)Error->Name, (int)Error->Number);\n\n        strncpy(*err_name, Error->Name, sizeof(*err_name) - 1);\n        *err_name[sizeof(*err_name) - 1] = 0;\n        return_code                      = OS_SUCCESS;\n    }\n    else\n    {\n        os_log(\"NO MATCH: final ptr=%p, Name=%p, Number=%d -> using unknown format\", (const void *)Error,\n               (const void *)Error->Name, (int)Error->Number);\n\n        snprintf(*err_name, OS_ERROR_NAME_LENGTH, \"OS_UNKNOWN(%d)\", (int)error_num);\n        return_code = OS_ERROR;\n    }\n\n    (*err_name)[OS_ERROR_NAME_LENGTH - 1] = '\\0';\n\n    os_log(\"OS_GetErrorName EXIT: return_code=%d, final_err_name_ptr=%p\", (int)return_code, (void *)err_name);\n\n    return return_code;\n}\n"
}