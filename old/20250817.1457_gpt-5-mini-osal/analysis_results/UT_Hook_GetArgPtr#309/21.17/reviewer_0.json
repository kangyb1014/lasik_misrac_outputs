{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strcmp(MetaPtr->Name, Name) only checks MetaPtr->Name != NULL but does not validate the parameter Name or that both strings are NUL-terminated. If the caller passes Name == NULL (or passes a non\u2013NUL-terminated buffer), strcmp will dereference/read beyond the bounds of the object referenced by Name, causing undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_2479_Log(const void *ContextPtr, const void *MetaPtr, const char *Name, size_t ExpectedTypeSize,\n                        unsigned int i, const char *where, unsigned long meta_size, unsigned int meta_type)\n{\n    FILE *f = fopen(\"/tmp/logs/2479.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    fprintf(f, \"UT_Hook_GetArgPtr LOG (%s)\\n\", where);\n    fprintf(f, \"  loop index i=%u\\n\", i);\n    fprintf(f, \"  ContextPtr=%p MetaPtr=%p\\n\", ContextPtr, MetaPtr);\n    fprintf(f, \"  MetaPtr->Name=%p Name=%p\\n\", (void *)MetaPtr, (void *)Name);\n    fprintf(f, \"  ExpectedTypeSize=%lu MetaPtr->Size=%lu MetaPtr->Type=%u\\n\",\n            (unsigned long)ExpectedTypeSize, (unsigned long)meta_size, meta_type);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n\n        /* Log entry for each candidate argument metadata. Do not dereference Name or MetaPtr->Name here. */\n        UT_2479_Log(ContextPtr, MetaPtr, Name, ExpectedTypeSize, (unsigned int)i, \"loop_entry\",\n                    MetaPtr->Size, (unsigned int)MetaPtr->Type);\n\n        if (MetaPtr->Name != NULL)\n        {\n            /* Log state immediately before calling strcmp. This will capture cases where Name is NULL. */\n            UT_2479_Log(ContextPtr, MetaPtr, Name, ExpectedTypeSize, (unsigned int)i, \"before_strcmp\",\n                        MetaPtr->Size, (unsigned int)MetaPtr->Type);\n\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                /* Log the match that was found */\n                UT_2479_Log(ContextPtr, MetaPtr, Name, ExpectedTypeSize, (unsigned int)i, \"match_found\",\n                            MetaPtr->Size, (unsigned int)MetaPtr->Type);\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n\n                    /* Log the resolved result pointer */\n                    UT_2479_Log(ContextPtr, MetaPtr, Name, ExpectedTypeSize, (unsigned int)i, \"result_direct\",\n                                MetaPtr->Size, (unsigned int)MetaPtr->Type);\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n\n                    /* Log the resolved indirect result pointer */\n                    UT_2479_Log(ContextPtr, MetaPtr, Name, ExpectedTypeSize, (unsigned int)i, \"result_indirect\",\n                                MetaPtr->Size, (unsigned int)MetaPtr->Type);\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        /* Log the fact that no match was found prior to asserting. */\n        UT_2479_Log(ContextPtr, NULL, Name, ExpectedTypeSize, (unsigned int)i, \"no_result_before_assert\",\n                    0UL, 0U);\n\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317cc\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317cc\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (match_found)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317cc\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (result_indirect)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317cc\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (match_found)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (result_indirect)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317a8\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=1\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50548\n  MetaPtr->Name=0x7fff12b50548 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=2\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50560\n  MetaPtr->Name=0x7fff12b50560 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=2\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50560\n  MetaPtr->Name=0x7fff12b50560 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (match_found)\n  loop index i=2\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50560\n  MetaPtr->Name=0x7fff12b50560 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (result_indirect)\n  loop index i=2\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50560\n  MetaPtr->Name=0x7fff12b50560 Name=0x562e87f317e0\n  ExpectedTypeSize=4 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (loop_entry)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  MetaPtr->Name=0x7fff12b50530 Name=0x562e87f317c0\n  ExpectedTypeSize=8 MetaPtr->Size=4 MetaPtr->Type=2\n\nUT_Hook_GetArgPtr LOG (before_strcmp)\n  loop index i=0\n  ContextPtr=0x7fff12b504e0 MetaPtr=0x7fff12b50530\n  \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The call strcmp(MetaPtr->Name, Name) only guards MetaPtr->Name against NULL but does not validate the parameter Name (nor ensure either string is NUL-terminated). MISRA C 2023 Rule 21.17 requires that uses of <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. As written, UT_Hook_GetArgPtr can call strcmp with a NULL or non\u2013NUL-terminated Name, which can cause out-of-bounds reads/undefined behavior, so the code violates Rule 21.17."
}