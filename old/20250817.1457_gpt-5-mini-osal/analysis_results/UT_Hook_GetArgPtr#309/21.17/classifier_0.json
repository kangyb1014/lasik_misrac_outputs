{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_Hook_GetArgPtr:\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_Hook_GetArgPtr:\ntypedef struct\n{\n    int32                Int32StatusCode;\n    bool                 Int32StatusIsSet;\n    uint32               ArgCount;\n    const void *         ArgPtr[UT_STUBCONTEXT_MAXSIZE];\n    UT_StubArgMetaData_t Meta[UT_STUBCONTEXT_MAXSIZE];\n} UT_StubContext_t\n...\ntypedef struct\n{\n    UT_StubContext_Arg_Type_t Type;\n    const char *              Name;\n    size_t                    Size;\n} UT_StubArgMetaData_t\n...\n#define UtAssert_Failed(__VA_ARGS__) UtAssertEx(false,UtAssert_GetContext(),__FILE__,__LINE__,__VA_ARGS__)\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The call strcmp(MetaPtr->Name, Name) only checks MetaPtr->Name != NULL but does not validate the parameter Name or that both strings are NUL-terminated. If the caller passes Name == NULL (or passes a non\u2013NUL-terminated buffer), strcmp will dereference/read beyond the bounds of the object referenced by Name, causing undefined behavior."
}