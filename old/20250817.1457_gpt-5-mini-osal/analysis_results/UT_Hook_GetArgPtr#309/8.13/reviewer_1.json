{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The union member 'AsPtr' is declared as 'void *' (a pointer to non-const). Although the union object is declared const, that makes the pointer itself effectively 'void * const' (the pointer cannot be changed) but does not make the pointed-to type const. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types when possible; here 'AsPtr' should be declared as 'const void *' (or otherwise point to a const-qualified type) when feasible. Therefore this fragment violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_Hook_LogMsg(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fp = fopen(\"/tmp/logs/2475.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    /* Log entry with key parameters */\n    UT_Hook_LogMsg(\"UT_Hook_GetArgPtr ENTER: Name='%s', ExpectedTypeSize=%lu, ContextPtr=%p\", Name ? Name : \"(null)\", (unsigned long)ExpectedTypeSize, (const void *)ContextPtr);\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n\n        UT_Hook_LogMsg(\"Loop idx=%lu: MetaPtr=%p, Meta.Name=%p\", (unsigned long)i, (const void *)MetaPtr, (const void *)MetaPtr->Name);\n\n        if (MetaPtr->Name != NULL)\n        {\n            UT_Hook_LogMsg(\"  Meta.Name='%s', Meta.Size=%lu, ExpectedTypeSize=%lu, Meta.Type=%u\", MetaPtr->Name, (unsigned long)MetaPtr->Size, (unsigned long)ExpectedTypeSize, (unsigned)MetaPtr->Type);\n\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                UT_Hook_LogMsg(\"  MATCH: name and size checks passed for index=%lu\", (unsigned long)i);\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                    UT_Hook_LogMsg(\"  Path: DIRECT. Result set to &ContextPtr->ArgPtr[%lu] -> %p\", (unsigned long)i, (const void *)&ContextPtr->ArgPtr[i]);\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                    UT_Hook_LogMsg(\"  Path: INDIRECT. Result set to ContextPtr->ArgPtr[%lu] -> %p\", (unsigned long)i, (const void *)ContextPtr->ArgPtr[i]);\n                }\n                else\n                {\n                    UT_Hook_LogMsg(\"  Path: UNKNOWN Meta.Type=%u at index=%lu\", (unsigned)MetaPtr->Type, (unsigned long)i);\n                }\n\n                UT_Hook_LogMsg(\"  Breaking out of loop with Result=%p\", (const void *)Result);\n                break;\n            }\n            else\n            {\n                UT_Hook_LogMsg(\"  NO MATCH at index=%lu: strcmp=%d, size_check=%d\", (unsigned long)i, strcmp(MetaPtr->Name, Name), (int)(MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize));\n            }\n        }\n        else\n        {\n            UT_Hook_LogMsg(\"  Meta.Name is NULL at index=%lu\", (unsigned long)i);\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UT_Hook_LogMsg(\"Result is NULL after scanning args. About to call UtAssert_Failed for Name='%s' ExpectedTypeSize=%lu\", Name ? Name : \"(null)\", (unsigned long)ExpectedTypeSize);\n\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n            /* Log the default union contents to capture the violation scenario (AsPtr is void *) */\n            UT_Hook_LogMsg(\"Using ARG_DEFAULT_ZERO_VALUE as fallback. ARG_DEFAULT_ZERO_VALUE.AsInt=%lu, AsPtr=%p, AsFloat=%g\",\n                           ARG_DEFAULT_ZERO_VALUE.AsInt,\n                           ARG_DEFAULT_ZERO_VALUE.AsPtr,\n                           ARG_DEFAULT_ZERO_VALUE.AsFloat);\n\n            UT_Hook_LogMsg(\"Returning fallback Result=%p\", (const void *)Result);\n        }\n        else\n        {\n            UT_Hook_LogMsg(\"Fallback not possible (ExpectedTypeSize=%lu > sizeof(ARG_DEFAULT_ZERO_VALUE)=%zu). About to call UtAssert_Abort.\",\n                           (unsigned long)ExpectedTypeSize, sizeof(ARG_DEFAULT_ZERO_VALUE));\n\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n    else\n    {\n        UT_Hook_LogMsg(\"Returning Result=%p\", (const void *)Result);\n    }\n\n    UT_Hook_LogMsg(\"UT_Hook_GetArgPtr EXIT\");\n    return Result;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Hook_GetArgPtr ENTER: Name='lock_mode', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  MATCH: name and size checks passed for index=0\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[0] -> 0x7ffe5bd517dc\n  Breaking out of loop with Result=0x7ffe5bd517dc\nReturning Result=0x7ffe5bd517dc\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='idtype', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  NO MATCH at index=0: strcmp=3, size_check=1\nLoop idx=1: MetaPtr=0x7ffe5bd51598, Meta.Name=0x560d5577a3b7\n  Meta.Name='idtype', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  MATCH: name and size checks passed for index=1\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[1] -> 0x7ffe5bd517d8\n  Breaking out of loop with Result=0x7ffe5bd517d8\nReturning Result=0x7ffe5bd517d8\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='id', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  NO MATCH at index=0: strcmp=3, size_check=1\nLoop idx=1: MetaPtr=0x7ffe5bd51598, Meta.Name=0x560d5577a3b7\n  Meta.Name='idtype', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  NO MATCH at index=1: strcmp=116, size_check=1\nLoop idx=2: MetaPtr=0x7ffe5bd515b0, Meta.Name=0x560d5577a510\n  Meta.Name='id', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  MATCH: name and size checks passed for index=2\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[2] -> 0x7ffe5bd517d4\n  Breaking out of loop with Result=0x7ffe5bd517d4\nReturning Result=0x7ffe5bd517d4\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='token', ExpectedTypeSize=8, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=8, Meta.Type=2\n  NO MATCH at index=0: strcmp=-8, size_check=0\nLoop idx=1: MetaPtr=0x7ffe5bd51598, Meta.Name=0x560d5577a3b7\n  Meta.Name='idtype', Meta.Size=4, ExpectedTypeSize=8, Meta.Type=2\n  NO MATCH at index=1: strcmp=-11, size_check=0\nLoop idx=2: MetaPtr=0x7ffe5bd515b0, Meta.Name=0x560d5577a510\n  Meta.Name='id', Meta.Size=4, ExpectedTypeSize=8, Meta.Type=2\n  NO MATCH at index=2: strcmp=-11, size_check=0\nLoop idx=3: MetaPtr=0x7ffe5bd515c8, Meta.Name=0x560d5577a3ed\n  Meta.Name='token', Meta.Size=8, ExpectedTypeSize=8, Meta.Type=2\n  MATCH: name and size checks passed for index=3\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[3] -> 0x7ffe5bd517c8\n  Breaking out of loop with Result=0x7ffe5bd517c8\nReturning Result=0x7ffe5bd517c8\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='lock_mode', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  MATCH: name and size checks passed for index=0\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[0] -> 0x7ffe5bd517dc\n  Breaking out of loop with Result=0x7ffe5bd517dc\nReturning Result=0x7ffe5bd517dc\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='idtype', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  NO MATCH at index=0: strcmp=3, size_check=1\nLoop idx=1: MetaPtr=0x7ffe5bd51598, Meta.Name=0x560d5577a3b7\n  Meta.Name='idtype', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  MATCH: name and size checks passed for index=1\n  Path: INDIRECT. Result set to ContextPtr->ArgPtr[1] -> 0x7ffe5bd517d8\n  Breaking out of loop with Result=0x7ffe5bd517d8\nReturning Result=0x7ffe5bd517d8\nUT_Hook_GetArgPtr EXIT\nUT_Hook_GetArgPtr ENTER: Name='id', ExpectedTypeSize=4, ContextPtr=0x7ffe5bd51530\nLoop idx=0: MetaPtr=0x7ffe5bd51580, Meta.Name=0x560d5577a506\n  Meta.Name='lock_mode', Meta.Size=4, ExpectedTypeSize=4, Meta.Type=2\n  NO MAT\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. MISRA C 2023 R8.13 requires that pointer types should be to const-qualified targets whenever possible. In the snippet the union member is declared as 'void * AsPtr;', i.e. a pointer to non-const. Declaring the union object as const (static const union { ... } ARG_DEFAULT_ZERO_VALUE) makes the union instance itself const, but it does not change the declared type of the member AsPtr \u2014 the pointed-to type remains unqualified (void). Thus the code contains a pointer type that could and should be const-qualified (e.g. 'const void * AsPtr') because the member is used only as a fallback/zero pointer and not used to modify the pointed-to object. Therefore the agent A report that this fragment violates MISRA R8.13 is correct."
}