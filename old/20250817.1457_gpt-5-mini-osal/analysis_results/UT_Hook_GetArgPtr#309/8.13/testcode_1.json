{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe union member 'AsPtr' is declared as 'void *' (a pointer to non-const). Although the union object is declared const, that makes the pointer itself effectively 'void * const' (the pointer cannot be changed) but does not make the pointed-to type const. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types when possible; here 'AsPtr' should be declared as 'const void *' (or otherwise point to a const-qualified type) when feasible. Therefore this fragment violates Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_Hook_GetArgPtr code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2475.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_Hook_GetArgPtr as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_Hook_GetArgPtr:\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\nPlease provide the modified UT_Hook_GetArgPtr code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/*\n * Probe logging helper: append a message to the log file. Keep simple to avoid\n * changing program behavior. If the log cannot be opened, continue silently.\n */\nstatic void UT_Hook_LogMsg(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fp = fopen(\"/tmp/logs/2475.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    /* Log entry with key parameters */\n    UT_Hook_LogMsg(\"UT_Hook_GetArgPtr ENTER: Name='%s', ExpectedTypeSize=%lu, ContextPtr=%p\", Name ? Name : \"(null)\", (unsigned long)ExpectedTypeSize, (const void *)ContextPtr);\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n\n        UT_Hook_LogMsg(\"Loop idx=%lu: MetaPtr=%p, Meta.Name=%p\", (unsigned long)i, (const void *)MetaPtr, (const void *)MetaPtr->Name);\n\n        if (MetaPtr->Name != NULL)\n        {\n            UT_Hook_LogMsg(\"  Meta.Name='%s', Meta.Size=%lu, ExpectedTypeSize=%lu, Meta.Type=%u\", MetaPtr->Name, (unsigned long)MetaPtr->Size, (unsigned long)ExpectedTypeSize, (unsigned)MetaPtr->Type);\n\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                UT_Hook_LogMsg(\"  MATCH: name and size checks passed for index=%lu\", (unsigned long)i);\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                    UT_Hook_LogMsg(\"  Path: DIRECT. Result set to &ContextPtr->ArgPtr[%lu] -> %p\", (unsigned long)i, (const void *)&ContextPtr->ArgPtr[i]);\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                    UT_Hook_LogMsg(\"  Path: INDIRECT. Result set to ContextPtr->ArgPtr[%lu] -> %p\", (unsigned long)i, (const void *)ContextPtr->ArgPtr[i]);\n                }\n                else\n                {\n                    UT_Hook_LogMsg(\"  Path: UNKNOWN Meta.Type=%u at index=%lu\", (unsigned)MetaPtr->Type, (unsigned long)i);\n                }\n\n                UT_Hook_LogMsg(\"  Breaking out of loop with Result=%p\", (const void *)Result);\n                break;\n            }\n            else\n            {\n                UT_Hook_LogMsg(\"  NO MATCH at index=%lu: strcmp=%d, size_check=%d\", (unsigned long)i, strcmp(MetaPtr->Name, Name), (int)(MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize));\n            }\n        }\n        else\n        {\n            UT_Hook_LogMsg(\"  Meta.Name is NULL at index=%lu\", (unsigned long)i);\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UT_Hook_LogMsg(\"Result is NULL after scanning args. About to call UtAssert_Failed for Name='%s' ExpectedTypeSize=%lu\", Name ? Name : \"(null)\", (unsigned long)ExpectedTypeSize);\n\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n            /* Log the default union contents to capture the violation scenario (AsPtr is void *) */\n            UT_Hook_LogMsg(\"Using ARG_DEFAULT_ZERO_VALUE as fallback. ARG_DEFAULT_ZERO_VALUE.AsInt=%lu, AsPtr=%p, AsFloat=%g\",\n                           ARG_DEFAULT_ZERO_VALUE.AsInt,\n                           ARG_DEFAULT_ZERO_VALUE.AsPtr,\n                           ARG_DEFAULT_ZERO_VALUE.AsFloat);\n\n            UT_Hook_LogMsg(\"Returning fallback Result=%p\", (const void *)Result);\n        }\n        else\n        {\n            UT_Hook_LogMsg(\"Fallback not possible (ExpectedTypeSize=%lu > sizeof(ARG_DEFAULT_ZERO_VALUE)=%zu). About to call UtAssert_Abort.\",\n                           (unsigned long)ExpectedTypeSize, sizeof(ARG_DEFAULT_ZERO_VALUE));\n\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n    else\n    {\n        UT_Hook_LogMsg(\"Returning Result=%p\", (const void *)Result);\n    }\n\n    UT_Hook_LogMsg(\"UT_Hook_GetArgPtr EXIT\");\n    return Result;\n}\n"
}