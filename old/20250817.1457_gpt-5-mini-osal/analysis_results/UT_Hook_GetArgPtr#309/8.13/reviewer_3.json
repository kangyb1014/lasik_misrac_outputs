{
  "user_message": "An agent A claimed that the following UT_Hook_GetArgPtr code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Hook_GetArgPtr.\n```c\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n        if (MetaPtr->Name != NULL)\n        {\n            if (strcmp(MetaPtr->Name, Name) == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                }\n                break;\n            }\n        }\n    }\n\n    /*\n     * If no suitable result pointer was found, this means a mismatch\n     * between the stub and test case, such as a change in argument/parameter names.\n     * This is an error that should be corrected, so report it as a failure.\n     */\n    if (Result == NULL)\n    {\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n        }\n        else\n        {\n            /*\n             * As the caller will likely dereference the returned pointer, should\n             * never return NULL.  Just abort here.\n             */\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n\n    return Result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the member UT_StubArgMetaData_t.Name is declared as a non-const pointer (e.g. char *Name;), this fragment uses it only for reading (NULL check and strcmp) and therefore it should be declared const char *Name;. In that case Rule 8.13 is violated because the pointer does not point to a const-qualified type even though it can be const-qualified. (If Name is already declared as const char * then there is no violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2475.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* best-effort logging; do not change program flow */\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    fprintf(fp, \"\\n\");\n    va_end(ap);\n\n    fclose(fp);\n}\n\nconst void *UT_Hook_GetArgPtr(const UT_StubContext_t *ContextPtr, const char *Name, size_t ExpectedTypeSize)\n{\n    uint32                      i;\n    const void *                Result;\n    const UT_StubArgMetaData_t *MetaPtr;\n\n    static const union\n    {\n        unsigned long AsInt;\n        void *        AsPtr;\n        double        AsFloat;\n    } ARG_DEFAULT_ZERO_VALUE = {0};\n\n    UT_Log(\"UT_Hook_GetArgPtr ENTRY: Name='%s' ExpectedTypeSize=%lu ArgCount=%u\", Name,\n           (unsigned long)ExpectedTypeSize, (unsigned)ContextPtr->ArgCount);\n\n    Result = NULL;\n    for (i = 0; i < ContextPtr->ArgCount; ++i)\n    {\n        MetaPtr = &ContextPtr->Meta[i];\n\n        /* Log basic metadata for this iteration */\n        UT_Log(\"iter=%u MetaPtr=%p Name_ptr=%p Name_str='%s' Size=%lu Type=%d\",\n               (unsigned)i, (void *)MetaPtr, (void *)MetaPtr->Name,\n               (MetaPtr->Name != NULL ? MetaPtr->Name : \"(null)\"), (unsigned long)MetaPtr->Size,\n               (int)MetaPtr->Type);\n\n        if (MetaPtr->Name != NULL)\n        {\n            int cmp = strcmp(MetaPtr->Name, Name);\n            UT_Log(\"iter=%u strcmp('%s','%s')=%d Size_match=%d\",\n                   (unsigned)i, MetaPtr->Name, Name, cmp,\n                   (int)(MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize));\n\n            if (cmp == 0 && (MetaPtr->Size == 0 || MetaPtr->Size == ExpectedTypeSize))\n            {\n                UT_Log(\"iter=%u MATCH found (Name='%s') at index %u; Type=%d\",\n                       (unsigned)i, MetaPtr->Name, (unsigned)i, (int)MetaPtr->Type);\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_DIRECT)\n                {\n                    Result = &ContextPtr->ArgPtr[i];\n                    UT_Log(\"iter=%u set Result -> &ContextPtr->ArgPtr[%u] = %p (DIRECT)\", (unsigned)i, (unsigned)i, Result);\n                }\n                else if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_INDIRECT)\n                {\n                    Result = ContextPtr->ArgPtr[i];\n                    UT_Log(\"iter=%u set Result = ContextPtr->ArgPtr[%u] = %p (INDIRECT)\", (unsigned)i, (unsigned)i, Result);\n                }\n                else\n                {\n                    UT_Log(\"iter=%u MATCH but unknown Type=%d; leaving Result as %p\", (unsigned)i, (int)MetaPtr->Type, Result);\n                }\n\n                break;\n            }\n        }\n        else\n        {\n            UT_Log(\"iter=%u Skipping: MetaPtr->Name is NULL\", (unsigned)i);\n        }\n    }\n\n    if (Result == NULL)\n    {\n        UT_Log(\"No suitable Result found for Name='%s' ExpectedTypeSize=%lu; calling UtAssert_Failed\", Name,\n               (unsigned long)ExpectedTypeSize);\n\n        UtAssert_Failed(\"Requested parameter %s of size %lu which was not provided by the stub\", Name,\n                        (unsigned long)ExpectedTypeSize);\n\n        if (ExpectedTypeSize <= sizeof(ARG_DEFAULT_ZERO_VALUE))\n        {\n            Result = &ARG_DEFAULT_ZERO_VALUE;\n            UT_Log(\"Using ARG_DEFAULT_ZERO_VALUE (%p) as fallback Result (size ok)\", Result);\n        }\n        else\n        {\n            UT_Log(\"ExpectedTypeSize %lu > ARG_DEFAULT_ZERO_VALUE size %lu; calling UtAssert_Abort\",\n                   (unsigned long)ExpectedTypeSize, (unsigned long)sizeof(ARG_DEFAULT_ZERO_VALUE));\n\n            UtAssert_Abort(\"No value for parameter\");\n        }\n    }\n    else\n    {\n        UT_Log(\"Returning Result=%p for Name='%s'\", Result, Name);\n    }\n\n    return Result;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Hook_GetArgPtr ENTRY: Name='lock_mode' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','lock_mode')=0 Size_match=1\niter=0 MATCH found (Name='lock_mode') at index 0; Type=2\niter=0 set Result = ContextPtr->ArgPtr[0] = 0x7ffe0d7be4ec (INDIRECT)\nReturning Result=0x7ffe0d7be4ec for Name='lock_mode'\nUT_Hook_GetArgPtr ENTRY: Name='idtype' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','idtype')=3 Size_match=1\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a53b7 Name_str='idtype' Size=4 Type=2\niter=1 strcmp('idtype','idtype')=0 Size_match=1\niter=1 MATCH found (Name='idtype') at index 1; Type=2\niter=1 set Result = ContextPtr->ArgPtr[1] = 0x7ffe0d7be4e8 (INDIRECT)\nReturning Result=0x7ffe0d7be4e8 for Name='idtype'\nUT_Hook_GetArgPtr ENTRY: Name='id' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','id')=3 Size_match=1\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a53b7 Name_str='idtype' Size=4 Type=2\niter=1 strcmp('idtype','id')=116 Size_match=1\niter=2 MetaPtr=0x7ffe0d7be2c0 Name_ptr=0x55baaf8a5510 Name_str='id' Size=4 Type=2\niter=2 strcmp('id','id')=0 Size_match=1\niter=2 MATCH found (Name='id') at index 2; Type=2\niter=2 set Result = ContextPtr->ArgPtr[2] = 0x7ffe0d7be4e4 (INDIRECT)\nReturning Result=0x7ffe0d7be4e4 for Name='id'\nUT_Hook_GetArgPtr ENTRY: Name='token' ExpectedTypeSize=8 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','token')=-8 Size_match=0\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a53b7 Name_str='idtype' Size=4 Type=2\niter=1 strcmp('idtype','token')=-11 Size_match=0\niter=2 MetaPtr=0x7ffe0d7be2c0 Name_ptr=0x55baaf8a5510 Name_str='id' Size=4 Type=2\niter=2 strcmp('id','token')=-11 Size_match=0\niter=3 MetaPtr=0x7ffe0d7be2d8 Name_ptr=0x55baaf8a53ed Name_str='token' Size=8 Type=2\niter=3 strcmp('token','token')=0 Size_match=1\niter=3 MATCH found (Name='token') at index 3; Type=2\niter=3 set Result = ContextPtr->ArgPtr[3] = 0x7ffe0d7be4d8 (INDIRECT)\nReturning Result=0x7ffe0d7be4d8 for Name='token'\nUT_Hook_GetArgPtr ENTRY: Name='lock_mode' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','lock_mode')=0 Size_match=1\niter=0 MATCH found (Name='lock_mode') at index 0; Type=2\niter=0 set Result = ContextPtr->ArgPtr[0] = 0x7ffe0d7be4ec (INDIRECT)\nReturning Result=0x7ffe0d7be4ec for Name='lock_mode'\nUT_Hook_GetArgPtr ENTRY: Name='idtype' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','idtype')=3 Size_match=1\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a53b7 Name_str='idtype' Size=4 Type=2\niter=1 strcmp('idtype','idtype')=0 Size_match=1\niter=1 MATCH found (Name='idtype') at index 1; Type=2\niter=1 set Result = ContextPtr->ArgPtr[1] = 0x7ffe0d7be4e8 (INDIRECT)\nReturning Result=0x7ffe0d7be4e8 for Name='idtype'\nUT_Hook_GetArgPtr ENTRY: Name='id' ExpectedTypeSize=4 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','id')=3 Size_match=1\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a53b7 Name_str='idtype' Size=4 Type=2\niter=1 strcmp('idtype','id')=116 Size_match=1\niter=2 MetaPtr=0x7ffe0d7be2c0 Name_ptr=0x55baaf8a5510 Name_str='id' Size=4 Type=2\niter=2 strcmp('id','id')=0 Size_match=1\niter=2 MATCH found (Name='id') at index 2; Type=2\niter=2 set Result = ContextPtr->ArgPtr[2] = 0x7ffe0d7be4e4 (INDIRECT)\nReturning Result=0x7ffe0d7be4e4 for Name='id'\nUT_Hook_GetArgPtr ENTRY: Name='token' ExpectedTypeSize=8 ArgCount=4\niter=0 MetaPtr=0x7ffe0d7be290 Name_ptr=0x55baaf8a5506 Name_str='lock_mode' Size=4 Type=2\niter=0 strcmp('lock_mode','token')=-8 Size_match=0\niter=1 MetaPtr=0x7ffe0d7be2a8 Name_ptr=0x55baaf8a\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In this function MetaPtr is a pointer to a const UT_StubArgMetaData_t and the code only reads MetaPtr->Name (NULL check and strcmp). If the member in the struct is declared as char *Name; then the pointer points to mutable characters even though those characters are never modified here \u2014 MISRA C:2023 Rule 8.13 requires a pointer to point to a const-qualified type whenever possible, so the member should be declared const char *Name. If the struct already declares Name as const char * then there is no violation. The provided execution log shows only read accesses, which supports the claim that the member can be const-qualified, so the report is correct."
}