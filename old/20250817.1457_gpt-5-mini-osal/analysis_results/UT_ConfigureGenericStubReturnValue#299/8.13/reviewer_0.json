{
  "user_message": "An agent A claimed that the following UT_ConfigureGenericStubReturnValue code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_ConfigureGenericStubReturnValue.\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The assignment copies a const-qualified pointer (ValuePtr has type 'const void *') into the buffer field IndirectPtr. If IndirectPtr is declared as a non-const pointer (e.g. 'void *IndirectPtr;'), this discards the const qualifier and therefore violates MISRA C 2023 Rule 8.13. (If IndirectPtr were declared 'const void *', there would be no violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned int UT_EntryKey_t;\ntypedef int UT_ValueGenre_t;\ntypedef int32_t int32;\nstruct UT_StubTableEntry\n{\n    UT_EntryKey_t FuncKey;\n    UT_EntryType_t EntryType;\n    union\n    {\n        struct\n        {\n            UT_ValueGenre_t Genre;\n            int32 Counter;\n            size_t ActualSz;\n            const char *TypeName;\n            struct\n            {\n                const void *IndirectPtr;\n            } Buf;\n        } Rvc;\n    } Data;\n};\nextern void UtAssert_Abort(const char *msg);\nstatic void UT_Probe_Log(const char *stage, UT_EntryKey_t key, UT_StubTableEntry_t *sp,\n                         UT_EntryType_t reqType, const void *vptr, size_t vsize,\n                         UT_ValueGenre_t vgenre, int32 cnt, const char *tname)\n{\n    FILE *fp = fopen(\"/tmp/logs/2395.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"[UT_ConfigureGenericStubReturnValue] stage=%s\\n\", stage);\n        fprintf(fp, \"  FuncKey=%u\\n\", (unsigned int)key);\n        fprintf(fp, \"  StubPtr=%p\\n\", (void *)sp);\n        fprintf(fp, \"  ReqEntryType=%d\\n\", (int)reqType);\n        fprintf(fp, \"  ValuePtr=%p\\n\", (const void *)vptr);\n        fprintf(fp, \"  ValueSize=%zu\\n\", vsize);\n        fprintf(fp, \"  ValueGenre=%d\\n\", (int)vgenre);\n        fprintf(fp, \"  Counter=%d\\n\", (int)cnt);\n        fprintf(fp, \"  TypeName=%s\\n\", (tname != NULL) ? tname : \"(null)\");\n        fprintf(fp, \"\\n\");\n        (void)fclose(fp);\n    }\n}\n\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    /* Initial probe at function entry */\n    UT_Probe_Log(\"entry\", FuncKey, NULL, (UT_EntryType_t)-1, ValuePtr, ValueSize, ValueGenre, Counter, TypeName);\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    /* Probe after selecting the requested entry type */\n    UT_Probe_Log(\"after_reqtype_selection\", FuncKey, StubPtr, ReqEntryType, ValuePtr, ValueSize, ValueGenre, Counter, TypeName);\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        /* Probe right before deciding storage strategy */\n        UT_Probe_Log(\"before_store_choice\", FuncKey, StubPtr, ReqEntryType, ValuePtr, ValueSize, ValueGenre, Counter, TypeName);\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n\n            /* Log that we are about to perform the potentially-qualifier-discarding assignment */\n            UT_Probe_Log(\"opaque_branch_before_assignment\", FuncKey, StubPtr, ReqEntryType, ValuePtr, ValueSize, ValueGenre, Counter, TypeName);\n\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n\n            /* Log after the assignment to capture the stored pointer value */\n            UT_Probe_Log(\"opaque_branch_after_assignment\", FuncKey, StubPtr, ReqEntryType, StubPtr->Data.Rvc.Buf.IndirectPtr, ValueSize, ValueGenre, Counter, TypeName);\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_Probe_Log(\"nonopaque_before_storeretval\", FuncKey, StubPtr, ReqEntryType, ValuePtr, ValueSize, ValueGenre, Counter, TypeName);\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n            UT_Probe_Log(\"nonopaque_after_storeretval\", FuncKey, StubPtr, ReqEntryType, StubPtr->Data.Rvc.Buf.IndirectPtr, ValueSize, ValueGenre, Counter, TypeName);\n        }\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Summary: Agent A\u2019s concern is theoretically valid but not provable from the snippets shown. Explanation:\n\n- MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types where possible. The code assigns ValuePtr (type const void *) into StubPtr->Data.Rvc.Buf.IndirectPtr.\n\n- If IndirectPtr were declared as a non-const pointer (e.g. void *IndirectPtr), that assignment would discard the const qualifier and would indeed be contrary to the intent of Rule 8.13 (and would also require an explicit cast to suppress a qualification-loss warning). So under that declaration the agent\u2019s report would be correct.\n\n- However, the original code excerpt does not show the declaration of IndirectPtr. In the provided test code the field is declared as const void *IndirectPtr, in which case the assignment does not discard qualifiers and does not violate Rule 8.13. Because the report depends on the (absent) declaration of IndirectPtr, the claim cannot be confirmed from the original snippet alone.\n\nConclusion: the agent\u2019s scenario is plausible (correct if IndirectPtr is non-const) but not demonstrably correct given the supplied code; therefore the report as stated is not conclusively correct."
}