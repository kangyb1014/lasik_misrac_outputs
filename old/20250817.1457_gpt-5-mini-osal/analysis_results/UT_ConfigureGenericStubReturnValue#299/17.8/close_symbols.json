{
  "user_message": "Target function code is:\n```c\nvoid UT_ConfigureGenericStubReturnValue(UT_EntryKey_t FuncKey, const void *ValuePtr, size_t ValueSize,\n                                        UT_ValueGenre_t ValueGenre, int32 Counter, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    UT_EntryType_t       ReqEntryType;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n    /*\n     * For deferred retval configs, this always adds a new entry.  But\n     * for constant retval configs, it should replace the existing entry if\n     * there is one.\n     */\n    if (Counter > 0)\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;\n        StubPtr      = NULL;\n    }\n    else\n    {\n        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;\n        StubPtr      = UT_GetStubEntry(FuncKey, ReqEntryType);\n    }\n\n    if (StubPtr == NULL)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey = FuncKey;\n\n        StubPtr->EntryType         = ReqEntryType;\n        StubPtr->Data.Rvc.Genre    = ValueGenre;\n        StubPtr->Data.Rvc.Counter  = Counter;\n        StubPtr->Data.Rvc.ActualSz = ValueSize;\n        StubPtr->Data.Rvc.TypeName = TypeName;\n\n        if (ValueGenre == UT_ValueGenre_OPAQUE)\n        {\n            /* For \"unknown\" types the pointer is stored directly - this allows for ANY return type of ANY size,\n             * but requires that the caller maintain the buffer in scope until the test completes */\n            StubPtr->Data.Rvc.Buf.IndirectPtr = ValuePtr;\n        }\n        else\n        {\n            /* For any of the recognized typical return types, a copy is made and stored in the state buffer */\n            UT_StoreRetval(&StubPtr->Data.Rvc.Buf, ValuePtr, ValueSize, ValueGenre);\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_ConfigureGenericStubReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_SetDeferredRetcode', 'UT_SetDefaultReturnValue']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_SetDeferredRetcode': {'callees': ['UtAssert_GetContext', 'UT_ConfigureGenericStubReturnValue'], 'callers': []}, 'UT_SetDefaultReturnValue': {'callees': ['UT_ConfigureGenericStubReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_StubTableEntry_t::Data.Rvc.Buf (buffer type)",
    "UT_EntryKey_t",
    "UT_EntryType_t",
    "UT_ValueGenre_t",
    "UT_ValueGenre_OPAQUE",
    "UT_StoreRetval",
    "UT_GetStubEntry",
    "UtAssert_Abort",
    "int32",
    "size_t"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d you must be able to show that none of the function\u2019s parameter objects (the parameter variables themselves) are written to. The following symbols are needed and why:\n\n- UT_StubTableEntry_t\n  - The function writes into fields of the returned stub object (e.g. StubPtr->FuncKey, EntryType, Data.*). You need the struct definition to confirm these writes are to the stub object, not to aliases of any parameter variable, and to inspect member types for aliasing/side-effect concerns.\n\n- UT_StubTableEntry_t::Data.Rvc.Buf (the buffer type inside the Rvc sub-structure)\n  - UT_StoreRetval is called to copy into this buffer. You must know the buffer\u2019s type/layout to ensure UT_StoreRetval operates on the stub state and cannot legally modify the target function\u2019s parameter variables via aliasing.\n\n- UT_EntryKey_t\n  - FuncKey is a parameter of this type. Its definition is needed to ensure it is a value type (or pointer) and that assigning FuncKey into StubPtr->FuncKey cannot be an assignment that modifies the parameter object itself (e.g., via an unexpected reference wrapper or macro).\n\n- UT_EntryType_t\n  - ReqEntryType is assigned and passed to UT_GetStubEntry; its definition confirms there are no hidden semantics (e.g. macros, special setters) that could modify a parameter variable.\n\n- UT_ValueGenre_t and UT_ValueGenre_OPAQUE (enum/constant)\n  - ValueGenre is compared to UT_ValueGenre_OPAQUE. The enum/constant definitions are required to ensure the comparison has no side effects and that ValueGenre is a plain value type (so the compare cannot modify the parameter variable).\n\n- UT_StoreRetval (prototype/implementation)\n  - This function is passed ValuePtr and the stub buffer. You must confirm its prototype does not take a pointer-to-pointer or reference to the ValuePtr parameter (i.e. it must not be able to modify the ValuePtr parameter variable itself). Also check it does not cast and write through the ValuePtr parameter variable itself.\n\n- UT_GetStubEntry (prototype/implementation)\n  - UT_GetStubEntry is called with FuncKey and ReqEntryType and may return NULL or a pointer. You need its prototype to ensure it takes FuncKey by value (not by pointer/reference) so it cannot modify the FuncKey parameter variable. Also confirm it has no hidden side effects that could alias into parameter storage.\n\n- UtAssert_Abort (prototype)\n  - The function is called on an error path. Its prototype/behavior is needed only to confirm it does not attempt to modify any of the target function\u2019s parameter variables (unlikely but required for completeness of the MISRA check).\n\n- int32 and size_t (typedefs)\n  - Confirm these are ordinary integer typedefs so that Counter and ValueSize are plain value parameters and cannot be modified indirectly by writes into other objects with unexpected aliasing.\n\nIn short, the above type definitions and called-function signatures are required to prove that all assignments and calls in UT_ConfigureGenericStubReturnValue operate on local variables or on fields of the stub object returned by UT_GetStubEntry, and do not modify the parameter variables themselves (which would violate the MISRA rule)."
}