{
  "user_message": "An agent A claimed that the following OS_MutSemGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemGetInfo.\n```c\nint32 OS_MutSemGetInfo(osal_id_t sem_id, OS_mut_sem_prop_t *mut_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(mut_prop);\n\n    memset(mut_prop, 0, sizeof(OS_mut_sem_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_mutex_table, token);\n\n        strncpy(mut_prop->name, record->name_entry, sizeof(mut_prop->name) - 1);\n        mut_prop->creator = record->creator;\n\n        return_code = OS_MutSemGetInfo_Impl(&token, mut_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'record' is declared as OS_common_record_t * and is assigned from OS_OBJECT_TABLE_GET which yields an OS_common_record_t * (the global table is OS_common_record_t *const). In OS_MutSemGetInfo the code only reads fields from the record (record->name_entry, record->creator) and does not modify the object, so 'record' could and should be declared to point to a const-qualified type (e.g. const OS_common_record_t *record). Because the pointer is not const-qualified despite being used only for read access, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_MutSemGetInfo_Log(const char *stage,\n                                 unsigned long sem_id_val,\n                                 const void *record_ptr,\n                                 const void *token_addr,\n                                 long return_code_val,\n                                 const char *name_entry,\n                                 unsigned long creator_val)\n{\n    FILE *f = fopen(\"/tmp/logs/1763.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"[OS_MutSemGetInfo] %s\\n\", stage);\n        fprintf(f, \"  sem_id=%lu, return_code=%ld, record_ptr=%p, token_addr=%p\\n\",\n                sem_id_val, return_code_val, record_ptr, token_addr);\n        if (name_entry != NULL)\n        {\n            fprintf(f, \"  record->name_entry=\\\"%s\\\"\\n\", name_entry);\n        }\n        fprintf(f, \"  record->creator=%lu\\n\", creator_val);\n        fclose(f);\n    }\n}\n\nint32 OS_MutSemGetInfo(osal_id_t sem_id, OS_mut_sem_prop_t *mut_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Log entry */\n    OS_MutSemGetInfo_Log(\"entry\", (unsigned long)sem_id, NULL, NULL, 0L, NULL, 0UL);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(mut_prop);\n\n    memset(mut_prop, 0, sizeof(OS_mut_sem_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log after object id lookup */\n    OS_MutSemGetInfo_Log(\"after OS_ObjectIdGetById\", (unsigned long)sem_id, NULL, &token, (long)return_code, NULL, 0UL);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_mutex_table, token);\n\n        /* Log the record pointer and its readable fields before use. */\n        OS_MutSemGetInfo_Log(\"object found\",\n                              (unsigned long)sem_id,\n                              (const void *)record,\n                              (const void *)&token,\n                              (long)return_code,\n                              (record != NULL) ? record->name_entry : \"(null)\",\n                              (record != NULL) ? (unsigned long)record->creator : 0UL);\n\n        strncpy(mut_prop->name, record->name_entry, sizeof(mut_prop->name) - 1);\n        mut_prop->creator = record->creator;\n\n        return_code = OS_MutSemGetInfo_Impl(&token, mut_prop);\n\n        /* Log after implementation call */\n        OS_MutSemGetInfo_Log(\"after OS_MutSemGetInfo_Impl\",\n                              (unsigned long)sem_id,\n                              (const void *)record,\n                              (const void *)&token,\n                              (long)return_code,\n                              (record != NULL) ? record->name_entry : \"(null)\",\n                              (record != NULL) ? (unsigned long)record->creator : 0UL);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    /* Log exit */\n    OS_MutSemGetInfo_Log(\"exit\", (unsigned long)sem_id, (const void *)record, (const void *)&token, (long)return_code,\n                         (record != NULL) ? record->name_entry : \"(null)\",\n                         (record != NULL) ? (unsigned long)record->creator : 0UL);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[OS_MutSemGetInfo] entry\n  sem_id=3735928559, return_code=0, record_ptr=(nil), token_addr=(nil)\n  record->creator=0\n[OS_MutSemGetInfo] after OS_ObjectIdGetById\n  sem_id=3735928559, return_code=-35, record_ptr=(nil), token_addr=0x7fffdfb6e1f0\n  record->creator=0\n[OS_MutSemGetInfo] exit\n  sem_id=3735928559, return_code=-35, record_ptr=0x7fffdfb6e3d8, token_addr=0x7fffdfb6e1f0\n  record->name_entry=\"/tmp/tmpg6xvxnab/build/unit-tests/oscore-test/osal_core_UT\"\n  record->creator=0\n[OS_MutSemGetInfo] entry\n  sem_id=0, return_code=0, record_ptr=(nil), token_addr=(nil)\n  record->creator=0\n[OS_MutSemGetInfo] after OS_ObjectIdGetById\n  sem_id=0, return_code=-35, record_ptr=(nil), token_addr=0x7fffdfb6e1f0\n  record->creator=0\n[OS_MutSemGetInfo] exit\n  sem_id=0, return_code=-35, record_ptr=0x7fffdfb6e3d8, token_addr=0x7fffdfb6e1f0\n  record->name_entry=\"/tmp/tmpg6xvxnab/build/unit-tests/oscore-test/osal_core_UT\"\n  record->creator=0\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 8.13 asks that pointers point to const-qualified types when feasible, but the provided test trace shows that the local variable record is used (logged) outside the guarded path where it is assigned. The logs show record contains and is dereferenced at exit even for paths where OS_ObjectIdGetById did not return OS_SUCCESS, which demonstrates the variable is effectively uninitialized/used outside its initialization in some control-flow. Because record is not reliably initialized on all paths in this function as exercised by the tests, it is not a straightforward case of a read-only local reference that can be safely changed to const in all circumstances. In short, the evidence from the test run does not support the claim that this is a simple 8.13 violation (i.e. a pointer that is only read and therefore should be declared pointing-to-const). Therefore the agent A report is incorrect."
}