{
  "user_message": "An agent A claimed that the following OS_OpenCreate code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_OpenCreate.\n```c\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The inline OS_strnlen implementation calls memchr(s, 0, maxlen) with maxlen = OS_MAX_PATH_LEN. If the object referenced by VirtualPath is smaller than OS_MAX_PATH_LEN (for example a caller passes a pointer to a 16\u2011byte buffer while OS_MAX_PATH_LEN is larger), memchr will scan past the end of that object and access out-of-bounds memory. This use of the <string.h> function memchr can therefore violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_LogProbe(const char *stage, const char *path, const char *local_path, int flags, int access_mode, const void *token_ptr, const void *stream_ptr, int return_code, const void *filedes_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/1295.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"STAGE: %s\\n\", stage);\n    fprintf(f, \"  path_ptr=%p\\n\", (const void *)path);\n    if (local_path != NULL)\n    {\n        /* local_path is an internal buffer allocated on the stack of this function\n         * so it is safe to print when provided. Avoid printing the caller's `path`\n         * contents, which could trigger the reported violation. */\n        fprintf(f, \"  local_path=\\\"%s\\\"\\n\", local_path);\n    }\n    fprintf(f, \"  flags=%d access_mode=%d\\n\", flags, access_mode);\n    fprintf(f, \"  token_ptr=%p stream_ptr=%p filedes_ptr=%p return_code=%d\\n\\n\", token_ptr, stream_ptr, filedes_ptr, return_code);\n\n    fclose(f);\n}\n\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Log entry state (do not dereference `path`) */\n    OS_LogProbe(\"entry\", path, NULL, (int)flags, (int)access_mode, NULL, NULL, -1, (const void *)filedes);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /* Log after init */\n    OS_LogProbe(\"after_init_filedes\", path, NULL, (int)flags, (int)access_mode, NULL, NULL, -1, (const void *)filedes);\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        OS_LogProbe(\"invalid_access_mode\", path, NULL, (int)flags, (int)access_mode, NULL, NULL, OS_ERROR, (const void *)filedes);\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    OS_LogProbe(\"pre_translate\", path, NULL, (int)flags, (int)access_mode, NULL, NULL, -1, (const void *)filedes);\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    /* Log result of translation. Only print local_path if translation succeeded. */\n    OS_LogProbe(\"post_translate\", path, (return_code == OS_SUCCESS) ? local_path : NULL, (int)flags, (int)access_mode, NULL, NULL, return_code, (const void *)filedes);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        OS_LogProbe(\"after_allocate\", path, local_path, (int)flags, (int)access_mode, (const void *)&token, NULL, return_code, (const void *)filedes);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Log after init of object */\n            OS_LogProbe(\"after_object_init\", path, local_path, (int)flags, (int)access_mode, (const void *)&token, (const void *)stream, return_code, (const void *)filedes);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n            OS_LogProbe(\"after_impl\", path, local_path, (int)flags, (int)access_mode, (const void *)&token, (const void *)stream, return_code, (const void *)filedes);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n            OS_LogProbe(\"after_finalize\", path, local_path, (int)flags, (int)access_mode, (const void *)&token, (const void *)stream, return_code, (const void *)filedes);\n        }\n    }\n\n    OS_LogProbe(\"exit\", path, (return_code == OS_SUCCESS) ? local_path : NULL, (int)flags, (int)access_mode, NULL, NULL, return_code, (const void *)filedes);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nSTAGE: entry\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: after_init_filedes\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: pre_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: post_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\nSTAGE: exit\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\nSTAGE: entry\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: after_init_filedes\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: pre_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: post_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\nSTAGE: exit\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\nSTAGE: entry\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: after_init_filedes\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: pre_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-1\n\nSTAGE: post_translate\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\nSTAGE: exit\n  path_ptr=0x55f98f2632b8\n  flags=3 access_mode=2\n  token_ptr=(nil) stream_ptr=(nil) filedes_ptr=0x55f98f280608 return_code=-108\n\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. While OS_OpenCreate itself does not directly call <string.h> functions, it passes the caller-supplied pointer path to OS_TranslatePath. The reported inline strnlen implementation that uses memchr(s, 0, OS_MAX_PATH_LEN) can read up to OS_MAX_PATH_LEN bytes from the pointer regardless of the actual size of the object referenced by path. If a caller provides a pointer to a smaller object (e.g. a 16-byte buffer) this memchr invocation may access beyond the object bounds, which is exactly the situation MISRA C 2023 Rule 21.17 forbids. The provided test output (consistent post_translate error codes) is compatible with OS_TranslatePath exercising the length-check logic; it does not negate the out-of-bounds access possibility. Therefore Agent A\u2019s report that this code can violate Rule 21.17 is correct."
}