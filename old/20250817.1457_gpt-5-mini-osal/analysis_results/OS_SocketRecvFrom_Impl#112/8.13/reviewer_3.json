{
  "user_message": "An agent A claimed that the following OS_SocketRecvFrom_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketRecvFrom_Impl.\n```c\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n        }\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    return_code = OS_QUEUE_EMPTY;\n                }\n                else\n                {\n                    OS_DEBUG(\"recvfrom: %s\\n\", strerror(errno));\n                    return_code = OS_ERROR;\n                }\n            }\n            else\n            {\n                return_code = os_result;\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                }\n            }\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call uses the return value of strerror(errno) (type char *) directly where the string is not modified. The returned pointer should be treated as pointing to const data (e.g. const char *err = strerror(errno);) but here a non-const-qualified pointer type is used implicitly by the call. This violates the intent of Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/899.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketRecvFrom_Impl(const OS_object_token_t *token, void *buffer, size_t buflen, OS_SockAddr_t *RemoteAddr,\n                             int32 timeout)\n{\n    int32                           return_code;\n    int                             os_result;\n    int                             waitflags;\n    uint32                          operation;\n    struct sockaddr *               sa;\n    socklen_t                       addrlen;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /* Log entry and key parameters */\n    probe_log(\"ENTER OS_SocketRecvFrom_Impl: token=%p buffer=%p buflen=%zu RemoteAddr=%p timeout=%d impl=%p\",\n              (const void *)token, buffer, buflen, (const void *)RemoteAddr, (int)timeout, (const void *)impl);\n\n    if (RemoteAddr == NULL)\n    {\n        sa      = NULL;\n        addrlen = 0;\n        probe_log(\"RemoteAddr is NULL; sa=NULL addrlen=0\");\n    }\n    else\n    {\n        addrlen = OS_SOCKADDR_MAX_LEN;\n        sa      = (struct sockaddr *)&RemoteAddr->AddrData;\n        probe_log(\"RemoteAddr provided; initial addrlen=%u sa=%p\", (unsigned)addrlen, (const void *)sa);\n    }\n\n    operation = OS_STREAM_STATE_READABLE;\n    /*\n     * If \"O_NONBLOCK\" flag is set then use select()\n     * Note this is the only way to get a correct timeout\n     */\n    if (impl->selectable)\n    {\n        waitflags   = MSG_DONTWAIT;\n        probe_log(\"impl->selectable true; calling OS_SelectSingle_Impl with timeout=%d\", (int)timeout);\n        return_code = OS_SelectSingle_Impl(token, &operation, timeout);\n        probe_log(\"OS_SelectSingle_Impl returned %d operation=0x%08x\", (int)return_code, (unsigned)operation);\n    }\n    else\n    {\n        if (timeout == 0)\n        {\n            waitflags = MSG_DONTWAIT;\n            probe_log(\"impl->selectable false; timeout==0 -> waitflags=MSG_DONTWAIT\");\n        }\n        else\n        {\n            /* note timeout will not be honored if >0 */\n            waitflags = 0;\n            probe_log(\"impl->selectable false; timeout>0 -> waitflags=0 (timeout not honored)\");\n        }\n        return_code = OS_SUCCESS;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if ((operation & OS_STREAM_STATE_READABLE) == 0)\n        {\n            probe_log(\"operation not readable (operation=0x%08x); returning OS_ERROR_TIMEOUT\", (unsigned)operation);\n            return_code = OS_ERROR_TIMEOUT;\n        }\n        else\n        {\n            probe_log(\"Calling recvfrom: fd=%d buflen=%zu waitflags=0x%08x sa=%p addrlen=%u\",\n                      impl->fd, buflen, (unsigned)waitflags, (const void *)sa, (unsigned)addrlen);\n\n            os_result = recvfrom(impl->fd, buffer, buflen, waitflags, sa, &addrlen);\n            probe_log(\"recvfrom returned %d (errno=%d)\", os_result, errno);\n\n            if (os_result < 0)\n            {\n                if (errno == EAGAIN || errno == EWOULDBLOCK)\n                {\n                    probe_log(\"recvfrom indicates would block: EAGAIN/EWOULDBLOCK -> OS_QUEUE_EMPTY\");\n                    return_code = OS_QUEUE_EMPTY;\n                }\n                else\n                {\n                    /* Capture strerror in a const-qualified pointer as evidence without modifying the string */\n                    const char *err = strerror(errno);\n\n                    /* Original debug call preserved, plus an on-disk probe that records the string */\n                    OS_DEBUG(\"recvfrom: %s\\n\", err);\n                    probe_log(\"recvfrom error; errno=%d strerror=\\\"%s\\\"\", errno, err);\n\n                    return_code = OS_ERROR;\n                }\n            }\n            else\n            {\n                return_code = os_result;\n\n                if (RemoteAddr != NULL)\n                {\n                    RemoteAddr->ActualLength = addrlen;\n                    probe_log(\"Received %d bytes; updated RemoteAddr->ActualLength=%u\", os_result, (unsigned)addrlen);\n                }\n                else\n                {\n                    probe_log(\"Received %d bytes; no RemoteAddr to update\", os_result);\n                }\n            }\n        }\n    }\n\n    probe_log(\"EXIT OS_SocketRecvFrom_Impl: return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketRecvFrom_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 8.13 concerns pointer declarations: a pointer object should point to a const-qualified type whenever possible. In the original code there is no pointer variable declared to hold the result of strerror(errno) \u2014 the return value is used directly as an rvalue argument to OS_DEBUG. There is therefore no pointer declaration that could/should be made const. Even if one captured the return in a variable, assigning it to a const char * (const char *err = strerror(errno);) is allowed and would satisfy the intent; the original use does not constitute a Rule 8.13 violation. In short, the report is incorrect."
}