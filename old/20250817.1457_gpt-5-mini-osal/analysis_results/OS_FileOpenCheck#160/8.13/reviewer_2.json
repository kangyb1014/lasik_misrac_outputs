{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In OS_FileOpenCheck the local variable 'stream' is declared as \"OS_stream_internal_record_t *stream;\" even though it is only used for read-only access (checking stream->socket_domain and calling strcmp on stream->stream_name). It could and should be declared as \"const OS_stream_internal_record_t *stream\" to express immutability and satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int int32;\nstruct OS_object_token\n{\n    int token_id;\n};\ntypedef struct OS_object_token\n{\n    int token_id;\n} OS_object_token_t;\nstruct OS_object_iter\n{\n    OS_object_token_t token;\n};\ntypedef struct OS_object_iter\n{\n    OS_object_token_t token;\n} OS_object_iter_t;\nstruct OS_stream_internal_record\n{\n    int socket_domain;\n    const char *stream_name;\n};\ntypedef struct OS_stream_internal_record\n{\n    int socket_domain;\n    const char *stream_name;\n} OS_stream_internal_record_t;\nextern void OS_ObjectIdIterateActive(int local_objid_type, OS_object_iter_t *iter);\nextern int OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter);\nextern void OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter);\nextern OS_stream_internal_record_t *OS_OBJECT_TABLE_GET(void *table, OS_object_token_t token);\nstatic void OSAL_Probe_LogStreamState(const void *stream_ptr,\n                                      int socket_domain,\n                                      const char *stream_name,\n                                      const char *filename,\n                                      int strcmp_result,\n                                      int match_found,\n                                      OS_object_token_t token)\n{\n    FILE *f = fopen(\"/tmp/logs/1283.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t t = time(NULL);\n        struct tm tm_buf;\n        (void)localtime_r(&t, &tm_buf);\n\n        /* Log: timestamp, token, pointer value, socket_domain, stream_name, strcmp result, match flag, filename */\n        fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d | token=%d | stream=%p | socket_domain=%d | stream_name=\\\"%s\\\" | strcmp=%d | match=%d | Filename=\\\"%s\\\"\\n\",\n                tm_buf.tm_year + 1900,\n                tm_buf.tm_mon + 1,\n                tm_buf.tm_mday,\n                tm_buf.tm_hour,\n                tm_buf.tm_min,\n                tm_buf.tm_sec,\n                token.token_id,\n                stream_ptr,\n                socket_domain,\n                (stream_name != NULL) ? stream_name : \"(null)\",\n                strcmp_result,\n                match_found,\n                (filename != NULL) ? filename : \"(null)\");\n        fclose(f);\n    }\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters (replaced project-specific macro with a simple NULL check\n       to avoid depending on a macro definition in this snippet). */\n    if (Filename == NULL)\n    {\n        return OS_ERROR;\n    }\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Probe: log the state before the comparison so callers can reproduce and inspect the flow */\n        /* Compute strcmp result for logging without changing behavior (strcmp will be called again in the condition) */\n        int strcmp_result = -1;\n        if (stream != NULL && stream->stream_name != NULL && Filename != NULL)\n        {\n            strcmp_result = strcmp(stream->stream_name, Filename);\n        }\n\n        OSAL_Probe_LogStreamState((const void *)stream,\n                                  (stream != NULL) ? (int)stream->socket_domain : -1,\n                                  (stream != NULL) ? stream->stream_name : NULL,\n                                  Filename,\n                                  strcmp_result,\n                                  0,\n                                  iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* Log the matching event with match flag set */\n            OSAL_Probe_LogStreamState((const void *)stream,\n                                      (int)stream->socket_domain,\n                                      stream->stream_name,\n                                      Filename,\n                                      0,\n                                      1,\n                                      iter.token);\n\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_FileOpenCheck the local variable 'stream' is only used for read-only access (reading socket_domain and stream_name, and passing a pointer to functions that take const void* or read-only args). Therefore it could and should be declared as pointing to a const-qualified type (e.g. const OS_stream_internal_record_t *stream) to express immutability and satisfy MISRA C 2023 Rule 8.13. Assigning a non-const pointer result from OS_OBJECT_TABLE_GET to a const pointer is allowed; there is no evidence in the shown function that the object is modified via 'stream'. The fact that the provided test snippet failed to compile does not invalidate the semantic observation about const qualification \u2014 the compilation failure likely comes from missing project-specific definitions/macros, not from the const-correctness issue. Note: if elsewhere in this function or callers the code needed to modify the record via this pointer, then making it const would be inappropriate; however, based on the presented code, that is not the case."
}