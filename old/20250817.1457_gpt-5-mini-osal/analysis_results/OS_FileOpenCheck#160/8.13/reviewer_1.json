{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'stream' is declared as a non-const OS_stream_internal_record_t * but is only used for read-only operations (accessing stream->socket_domain and stream->stream_name for strcmp). It could and should be declared as const OS_stream_internal_record_t *stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token); converting the non-const result of the macro to a pointer to const is allowed. Therefore Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    FILE *log = fopen(\"/tmp/logs/1283.txt\", \"a\");\n\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck START: Filename=\\\"%s\\\"\\n\",\n                (Filename != NULL) ? Filename : \"(null)\");\n        fflush(log);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Probe: log iterator token and stream pointer + key fields observed\n         * Note: print safe fallbacks if stream or its name is NULL to avoid\n         * introducing new side effects. The original logic below still\n         * dereferences stream as before to preserve behavior. */\n        if (log)\n        {\n            fprintf(log,\n                    \"ITER token=%p stream_ptr=%p socket_domain=%d stream_name=\\\"%s\\\"\\n\",\n                    (void *)&iter.token,\n                    (void *)stream,\n                    (int)((stream != NULL) ? stream->socket_domain : -999),\n                    (stream != NULL && stream->stream_name != NULL) ? stream->stream_name : \"(null)\");\n            fflush(log);\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            if (log)\n            {\n                fprintf(log, \"MATCH FOUND: token=%p stream_name=\\\"%s\\\" Filename=\\\"%s\\\"\\n\",\n                        (void *)&iter.token,\n                        stream->stream_name,\n                        Filename);\n                fflush(log);\n            }\n\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    if (log)\n    {\n        fprintf(log, \"Iterator complete, return_code=%d\\n\", (int)return_code);\n        fflush(log);\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log)\n    {\n        fprintf(log, \"OS_FileOpenCheck END\\n\\n\");\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_FileOpenCheck the local variable stream is only used to read fields (socket_domain and stream_name) and is never used to modify the object. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types whenever possible. Declaring the variable as const OS_stream_internal_record_t *stream would satisfy the rule. Assigning the result of the OS_OBJECT_TABLE_GET macro (which returns a non-const pointer) to a pointer-to-const is allowed implicitly, so there is no technical obstacle to making this change. The provided test/logging code and empty log do not affect the static rule assessment \u2014 they only show the function may not have been exercised in the tests. The only caveat would be if some other part of the function (or APIs called subsequently) required a modifiable pointer; no such usage is present here, so the original code violates Rule 8.13."
}