{
  "user_message": "An agent A claimed that the following OS_FileOpenCheck code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileOpenCheck.\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The iterator field 'base' points to an object table that is only read by the iterator (e.g. OS_ObjectIdIteratorGetNext uses OS_OBJECT_TABLE_GET(iter->base, iter->token) to obtain a record for inspection). Since the iterator does not modify the table through this pointer, it should be declared const (const OS_common_record_t *base). Leaving it as a non-const pointer allows accidental modification and therefore violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FileOpenCheck_Log(const char *format, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1283.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* If logging fails do not affect original logic. */\n    }\n\n    va_list ap;\n    va_start(ap, format);\n    vfprintf(fp, format, ap);\n    fprintf(fp, \"\\n\");\n    va_end(ap);\n\n    fclose(fp);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    /* Log entry and parameter state */\n    OS_FileOpenCheck_Log(\"OS_FileOpenCheck: entered. Filename='%s' ptr=%p\", Filename, (void *)Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    /* Print the address of the iterator and the address of the token member.\n       The token member may be an aggregate type and not directly printable as an integer. */\n    OS_FileOpenCheck_Log(\"OS_FileOpenCheck: iterator initialized. iter.ptr=%p, iter.token_ptr=%p\", (void *)&iter, (void *)&iter.token);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        /* Capture token prior to table access */\n        OS_FileOpenCheck_Log(\"OS_FileOpenCheck: iterator advanced. iter.token_ptr=%p\", (void *)&iter.token);\n\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log addresses and key fields read from the record. This shows read-only usage of the table. */\n        OS_FileOpenCheck_Log(\"OS_FileOpenCheck: stream ptr=%p, socket_domain=%d, stream_name='%s'\", (void *)stream, (int)stream->socket_domain, (stream->stream_name != NULL) ? stream->stream_name : \"(null)\");\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            OS_FileOpenCheck_Log(\"OS_FileOpenCheck: match found. token_ptr=%p, stream=%p\", (void *)&iter.token, (void *)stream);\n            return_code = OS_SUCCESS;\n            break;\n        }\n        else\n        {\n            OS_FileOpenCheck_Log(\"OS_FileOpenCheck: no match for token_ptr=%p\", (void *)&iter.token);\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    OS_FileOpenCheck_Log(\"OS_FileOpenCheck: iterator destroyed. final return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileOpenCheck. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the evidence shown. MISRA C:2023 R.8.13 states that a pointer should point to a const\u2011qualified type whenever it is only used for reading. However, the provided OS_FileOpenCheck source does not show the definition of OS_object_iter_t (and its alleged base member) nor the definition of OS_OBJECT_TABLE_GET/OS_stream_table. The agent's scenario about an iterator field named base being non\u2011const is speculative \u2014 it may be true in the wider code base, but it cannot be established from the snippet.\n\nWhat can be said from the snippet: the local variable stream is declared as OS_stream_internal_record_t * and is only read (socket_domain, stream_name). That local pointer could legitimately be declared as const OS_stream_internal_record_t * to be conformant with R.8.13 if the API/ macro allows it. Whether the iterator's internal pointer (iter.base) violates R.8.13 depends on the iterator type and how it is used/initialized (which are not shown). The added logging / test did not exercise the function (empty log) and therefore does not demonstrate a rule violation either.\n\nConclusion: the report as presented is not correct \u2014 there is insufficient evidence to claim a definitive violation of MISRA R.8.13. To confirm or refute the issue you must inspect the definitions of OS_object_iter_t (particularly the base member) and OS_OBJECT_TABLE_GET/OS_stream_table; if those pointers are only used for read access they should be const-qualified (and likewise the local stream variable could be changed to const if the API permits)."
}