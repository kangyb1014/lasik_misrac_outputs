{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential buffer overrun / unterminated string leading to out-of-bounds access in later strcmp: OS_OBJECT_INIT(token, stream, stream_name, path) must copy the path into stream->stream_name (char[OS_MAX_PATH_LEN]). The macro definition is not provided; if it uses an unbounded copy (e.g. strcpy or memcpy without size check) the copy can overflow stream_name. Even if it uses strncpy(stream->stream_name, path, sizeof(stream->stream_name)) but does not explicitly NUL-terminate when path length >= sizeof(stream->stream_name), stream->stream_name may be non-terminated. Later, OS_FileOpenCheck calls strcmp(stream->stream_name, Filename) \u2014 strcmp will read until a NUL byte and can therefore access beyond the bounds of stream_name, violating MISRA C 2023 Rule 21.17. Because the macro behavior and any bounds checks on the source path are not shown, this fragment is considered to potentially violate the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileOpenCheck code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1287.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileOpenCheck as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileOpenCheck:\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileOpenCheck code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Probe logging helper - appends logs to /tmp/logs/1287.txt */\nstatic void OS_FileOpenCheck_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1287.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    /* Log entry and Filename pointer (do not print contents to avoid extra reads) */\n    OS_FileOpenCheck_Log(\"OS_FileOpenCheck ENTER: Filename=%p\", (const void *)Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log iterator token and stream pointer and domain value */\n        OS_FileOpenCheck_Log(\n            \"ITER token=%u stream=%p socket_domain=%d stream_name_ptr=%p\",\n            (unsigned)iter.token,\n            (const void *)stream,\n            (int)stream->socket_domain,\n            (const void *)stream->stream_name);\n\n        /* Preserve original short-circuit logic: check domain first */\n        if (stream->socket_domain == OS_SocketDomain_INVALID)\n        {\n            /* Log that we are about to call strcmp (this replicates the original behavior)\n             * Do not attempt to print stream->stream_name contents here to avoid additional\n             * out-of-bounds reads beyond what the original code would do. */\n            OS_FileOpenCheck_Log(\"About to strcmp(stream->stream_name, Filename) for token=%u\", (unsigned)iter.token);\n\n            int cmp = strcmp(stream->stream_name, Filename);\n\n            OS_FileOpenCheck_Log(\"strcmp result for token=%u: %d\", (unsigned)iter.token, cmp);\n\n            if (cmp == 0)\n            {\n                OS_FileOpenCheck_Log(\"Match found for token=%u -> returning OS_SUCCESS\", (unsigned)iter.token);\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    OS_FileOpenCheck_Log(\"OS_FileOpenCheck EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n"
}