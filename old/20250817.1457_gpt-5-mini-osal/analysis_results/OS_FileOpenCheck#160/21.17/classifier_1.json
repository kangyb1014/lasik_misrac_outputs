{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FileOpenCheck:\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FileOpenCheck:\ntypedef struct\n{\n    char   stream_name[OS_MAX_PATH_LEN];\n    uint8  socket_domain;\n    uint8  socket_type;\n    uint16 stream_state;\n} OS_stream_internal_record_t\n...\nOS_stream_internal_record_t OS_stream_table[OS_MAX_NUM_OPEN_FILES]\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_MAX_API_NAME 20\n...\nint32 OS_OpenCreate(osal_id_t *filedes, const char *path, int32 flags, int32 access_mode)\n{\n    int32                        return_code;\n    char                         local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(filedes);\n\n    /* Initialize file descriptor */\n    *filedes = OS_OBJECT_ID_UNDEFINED;\n\n    /*\n    ** Check for a valid access mode\n    */\n    if (access_mode != OS_WRITE_ONLY && access_mode != OS_READ_ONLY && access_mode != OS_READ_WRITE)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Translate the path\n     */\n    return_code = OS_TranslatePath(path, (char *)local_path);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, stream, stream_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_FileOpen_Impl(&token, local_path, flags, access_mode);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, filedes);\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_FileOpen_Impl(const OS_object_token_t *token, const char *local_path, int32 flags, int32 access_mode)\n{\n    int                             os_perm;\n    int                             os_mode;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n    ** Check for a valid access mode\n    ** For creating a file, OS_READ_ONLY does not make sense\n    */\n    switch (access_mode)\n    {\n        case OS_WRITE_ONLY:\n            os_perm = O_WRONLY;\n            break;\n        case OS_READ_ONLY:\n            os_perm = O_RDONLY;\n            break;\n        case OS_READ_WRITE:\n            os_perm = O_RDWR;\n            break;\n        default:\n            return OS_ERROR;\n    }\n\n    if (flags & OS_FILE_FLAG_CREATE)\n    {\n        os_perm |= O_CREAT;\n    }\n    if (flags & OS_FILE_FLAG_TRUNCATE)\n    {\n        os_perm |= O_TRUNC;\n    }\n\n    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;\n\n    os_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n    impl->fd = open(local_path, os_perm, os_mode);\n\n    if (impl->fd < 0)\n    {\n        OS_DEBUG(\"open(%s): %s\\n\", local_path, strerror(errno));\n        return OS_ERROR;\n    }\n\n    /*\n     * If the flags included O_NONBLOCK, then\n     * enable the \"select\" call on this handle.\n     */\n    impl->selectable = ((os_perm & O_NONBLOCK) != 0);\n\n    return OS_SUCCESS;\n}\n...\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n...\nint32 OS_SocketOpen(osal_id_t *sock_id, OS_SocketDomain_t Domain, OS_SocketType_t Type)\n{\n    OS_object_token_t            token;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n\n    /* Check for NULL pointers */\n    OS_CHECK_POINTER(sock_id);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Save all the data to our own internal table */\n        memset(stream, 0, sizeof(OS_stream_internal_record_t));\n        stream->socket_domain = Domain;\n        stream->socket_type   = Type;\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_SocketOpen_Impl(&token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sock_id);\n    }\n\n    return return_code;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call itself does not violate Rule 21.17 because the destination buffer and its size are passed (sock->stream_name and sizeof(sock->stream_name)), so provided the implementation of OS_SocketAddrToString_Impl respects the size parameter and uses bounds-checked operations (e.g. snprintf, strncpy with explicit limit, or writes guarded by the size), no out-of-bounds access occurs. A violation scenario would be if OS_SocketAddrToString_Impl ignores the size argument or uses unbounded functions such as strcpy, strcat, or writes more bytes than the supplied sizeof(sock->stream_name) (or otherwise miscomputes the buffer length) \u2014 in that case Rule 21.17 would be violated."
}