{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf OS_BinSemGive_Impl is declared as taking a non-const pointer (e.g. int32 OS_BinSemGive_Impl(OS_object_token_t *token)) but does not modify the pointed-to object, then this call violates MISRA C 2023 Rule 8.13 because the pointer parameter should be const-qualified (const OS_object_token_t *). If the implementation does modify the token or the prototype already uses a pointer-to-const, then there is no violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_BinSemGive code that contains useful probe functions that print useful logs to a file \"/tmp/logs/971.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_BinSemGive as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_BinSemGive:\n```c\nint32 OS_BinSemGive(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_BinSemGive_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_BinSemGive code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Minimal type and constant definitions to allow this test file to compile and run.\n   In the real project these come from the OSAL headers. */\n\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\n\ntypedef struct\n{\n    /* opaque token contents for test purposes */\n    uint8_t opaque[16];\n} OS_object_token_t;\n\nstatic const int OS_LOCK_MODE_NONE = 0;\nstatic const int LOCAL_OBJID_TYPE   = 1;\nstatic const int OS_SUCCESS         = 0;\n\n/* Prototypes for the OSAL functions used by OS_BinSemGive.\n   In the real build these are provided by the OSAL. */\nextern int32 OS_ObjectIdGetById(int lock_mode, int local_type, osal_id_t id, OS_object_token_t *token);\nextern int32 OS_BinSemGive_Impl(OS_object_token_t *token);\n\n/* Probe helpers: write control flow and state information to /tmp/logs/971.txt\n   The logs include the sem_id, return_code from the lookup, the address of the\n   token and a byte-wise dump of the token before and after calling the impl.\n   These functions intentionally use only standard C library calls. */\nstatic void probe_log_token_bytes(FILE *f, const OS_object_token_t *token)\n{\n    const unsigned char *p = (const unsigned char *)token;\n    size_t i;\n    /* Print a fixed-size dump based on sizeof(token) so an external agent can\n       detect whether contents changed. */\n    for (i = 0; i < sizeof(*token); ++i)\n    {\n        fprintf(f, \"%02X\", (unsigned)p[i]);\n        if (i + 1 < sizeof(*token))\n        {\n            fprintf(f, \":\");\n        }\n    }\n}\n\nstatic void probe_log_before(osal_id_t sem_id, const OS_object_token_t *token, int32 lookup_rc)\n{\n    FILE *f = fopen(\"/tmp/logs/971.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_BinSemGive] ENTRY\\n\");\n    fprintf(f, \"sem_id=%u lookup_rc=%d token_addr=%p token_size=%zu\\n\",\n            (unsigned)sem_id, (int)lookup_rc, (const void *)token, sizeof(*token));\n    fprintf(f, \"token_before=\");\n    probe_log_token_bytes(f, token);\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\nstatic void probe_log_after(osal_id_t sem_id, const OS_object_token_t *token, int32 impl_rc)\n{\n    FILE *f = fopen(\"/tmp/logs/971.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_BinSemGive] AFTER_IMPL\\n\");\n    fprintf(f, \"sem_id=%u impl_rc=%d token_addr=%p token_size=%zu\\n\",\n            (unsigned)sem_id, (int)impl_rc, (const void *)token, sizeof(*token));\n    fprintf(f, \"token_after=\");\n    probe_log_token_bytes(f, token);\n    fprintf(f, \"\\n\\n\");\n\n    fclose(f);\n}\n\n/* The OS_BinSemGive function with inserted probes. The original logic is\n   preserved: obtain the token with OS_ObjectIdGetById, and if successful,\n   call OS_BinSemGive_Impl with the address of the token. Probes capture the\n   token contents before and after the impl call so other agents can detect\n   whether the implementation modified the pointed-to object (which is the\n   basis for the MISRA Rule 8.13 discussion). */\nint32 OS_BinSemGive(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log state after lookup and before calling impl */\n    probe_log_before(sem_id, &token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Call the implementation. The implementation signature in some builds\n           may take a non-const pointer even if it does not modify the token.\n           The probe logs will allow detection of whether the token was\n           modified by the implementation, which provides evidence for the\n           Rule 8.13 scenario. */\n        return_code = OS_BinSemGive_Impl(&token);\n    }\n\n    /* Log state after impl call (or after lookup failure) */\n    probe_log_after(sem_id, &token, return_code);\n\n    return return_code;\n}\n\n/* -------------------------------------------------------------------------\n   Minimal stub implementations to make this file self-contained for testing.\n   In an actual OSAL build these would be provided by the OSAL library, so\n   these stubs are only present to make compilation and local testing possible.\n   They are written to avoid modifying token contents so that probes can\n   demonstrate the \"pointer should be const\" scenario (i.e., the impl does not\n   modify the pointed-to data even though it accepts a non-const pointer).\n   ------------------------------------------------------------------------- */\n\nint32 OS_ObjectIdGetById(int lock_mode, int local_type, osal_id_t id, OS_object_token_t *token)\n{\n    (void)lock_mode;\n    (void)local_type;\n    (void)id;\n\n    /* Populate the token with deterministic data for easier testing */\n    for (size_t i = 0; i < sizeof(*token); ++i)\n    {\n        token->opaque[i] = (unsigned char)(i + 1u);\n    }\n\n    return OS_SUCCESS;\n}\n\nint32 OS_BinSemGive_Impl(OS_object_token_t *token)\n{\n    /* For the test scenario we intentionally do not modify *token. This\n       allows probes to capture that the impl did not change the pointed-to\n       object, supporting the argument that the parameter should be const. */\n    (void)token;\n    return OS_SUCCESS;\n}\n"
}