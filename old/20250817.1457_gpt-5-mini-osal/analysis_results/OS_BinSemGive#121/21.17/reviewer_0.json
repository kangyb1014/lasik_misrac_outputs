{
  "user_message": "An agent A claimed that the following OS_BinSemGive code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemGive.\n```c\nint32 OS_BinSemGive(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_BinSemGive_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memset(token, 0, sizeof(*token)) writes sizeof(OS_object_token_t) bytes to the memory pointed to by token. If token is NULL or points to an object smaller than OS_object_token_t (for example a caller mistakenly passes NULL or a pointer to a different/smaller object), this will write beyond the bounds and cause undefined behavior. Although the shown call chain (caller passing &token for a local OS_object_token_t) is safe, OS_ObjectIdTransactionInit does not validate the token pointer before the memset; therefore the code can violate Rule 21.17 in a scenario where a caller passes an invalid/NULL pointer.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef uint32_t osal_id_t;\ntypedef unsigned int osal_objtype_t;\ntypedef int OS_lock_mode_t;\nstruct OS_object_token\n{\n    unsigned char data[sizeof(void *) * 8];\n};\ntypedef struct OS_object_token\n{\n    unsigned char data[sizeof(void *) * 8];\n} OS_object_token_t;\nint32_t OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token);\nint32_t OS_BinSemGive_Impl(const OS_object_token_t *token);\nstatic void probe_log(const char *fmt, ...)\n{\n    char buf[1024];\n    va_list ap;\n    int fd;\n    ssize_t wrote;\n\n    va_start(ap, fmt);\n    /* vsnprintf is safe here since buf is bounded */\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n\n    fd = open(\"/tmp/logs/975.txt\", O_WRONLY | O_CREAT | O_APPEND,\n              S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n    if (fd < 0)\n    {\n        /* If logging fails, do not alter program behavior. */\n        return;\n    }\n\n    /* Write the formatted message; ignore partial write handling for brevity */\n    wrote = write(fd, buf, strnlen(buf, sizeof(buf)));\n    (void)wrote;\n    close(fd);\n}\n\nint32_t OS_BinSemGive(uint32_t sem_id)\n{\n    /* Use the proper token type so the function signatures match. */\n    OS_object_token_t token;\n    int32_t         return_code;\n\n    /* Log entry and parameter state */\n    probe_log(\"OS_BinSemGive: entry sem_id=%u, &token=%p, sizeof(token)=%zu\\n\",\n              (unsigned)sem_id, (void *)&token, sizeof(token));\n\n    /* Check Parameters (original call preserved) */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    probe_log(\"OS_BinSemGive: OS_ObjectIdGetById returned %d\\n\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token contents (hex) to help detect invalid/NULL writes downstream */\n        /* Only dump a bounded number of bytes to avoid huge logs. */\n        size_t dump_len = sizeof(token) < 64 ? sizeof(token) : 64;\n        char hexbuf[3 * 64 + 1];\n        size_t i;\n        char *hp = hexbuf;\n        unsigned char *tbytes = (unsigned char *)&token;\n\n        for (i = 0; i < dump_len; ++i)\n        {\n            /* Format each byte as two hex characters + space */\n            int n = snprintf(hp, 4, \"%02x \", tbytes[i]);\n            hp += n;\n        }\n        *hp = '\\0';\n\n        probe_log(\"OS_BinSemGive: token dump (first %zu bytes): %s\\n\", dump_len, hexbuf);\n\n        /* Call the implementation as in the original code */\n        return_code = OS_BinSemGive_Impl(&token);\n\n        probe_log(\"OS_BinSemGive: OS_BinSemGive_Impl returned %d\\n\", return_code);\n    }\n    else\n    {\n        probe_log(\"OS_BinSemGive: parameter check failed, returning %d\\n\", return_code);\n    }\n\n    probe_log(\"OS_BinSemGive: exit returning %d\\n\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the code shown. Rule 21.17 concerns uses of <string.h> functions (e.g. memset) that might write beyond the bounds of the object pointed to. The OS_BinSemGive code shown does not call any string.h function itself; it declares a local OS_object_token_t token and passes its address (&token) to OS_ObjectIdGetById. Passing &token guarantees a valid, suitably sized object for any subsequent memset(mem, 0, sizeof(*token)) performed by the callee. If a memset without a null/size check exists, that would be an issue in the implementation that performs the memset (e.g. OS_ObjectIdTransactionInit or OS_ObjectIdGetById), not in this OS_BinSemGive caller. In addition, it is common and acceptable for a function to require a non-NULL, properly sized buffer as part of its contract; in that case the callee may assume the pointer is valid and use memset without an extra runtime null check. To determine an actual MISRA 21.17 violation you must inspect the function that calls memset and its documented preconditions. As given, OS_BinSemGive itself does not violate Rule 21.17."
}