{
  "user_message": "An agent A claimed that the following OS_FileSysStatVolume_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStatVolume_Impl.\n```c\nint32 OS_FileSysStatVolume_Impl(const OS_object_token_t *token, OS_statvfs_t *result)\n{\n    OS_filesys_internal_record_t *local;\n    struct statvfs                stat_buf;\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if (statvfs(local->system_mountpt, &stat_buf) != 0)\n    {\n        return OS_ERROR;\n    }\n\n    result->block_size   = OSAL_SIZE_C(stat_buf.f_bsize);\n    result->blocks_free  = OSAL_BLOCKCOUNT_C(stat_buf.f_bfree);\n    result->total_blocks = OSAL_BLOCKCOUNT_C(stat_buf.f_blocks);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'local' is used only for reading fields (local->system_mountpt) and is not modified in OS_FileSysStatVolume_Impl, so it should be declared as pointing to a const-qualified type (e.g. const OS_filesys_internal_record_t *local). Assigning the non-const table element to a const pointer is allowed, so the current non-const declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FileSysStatVolume_Log(const char *msg)\n{\n    FILE *fp = fopen(\"/tmp/logs/323.txt\", \"a\");\n    if (fp != NULL)\n    {\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\nint32 OS_FileSysStatVolume_Impl(const OS_object_token_t *token, OS_statvfs_t *result)\n{\n    OS_filesys_internal_record_t *local;\n    struct statvfs                stat_buf;\n\n    /* Probe: log entry and token/local resolution */\n    {\n        char buf[512];\n        /* Log token pointer and that we are attempting to fetch table element */\n        snprintf(buf, sizeof(buf), \"OS_FileSysStatVolume_Impl: entry token=%p\", (const void *)token);\n        OS_FileSysStatVolume_Log(buf);\n    }\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /* Probe: log local pointer and mountpoint (as available) */\n    {\n        char buf[1024];\n        const char *mp = \"(null)\";\n        if (local != NULL)\n        {\n            /* local->system_mountpt is read-only here for logging purposes */\n            mp = local->system_mountpt;\n        }\n        snprintf(buf, sizeof(buf), \"OS_FileSysStatVolume_Impl: local=%p, mountpt='%s'\", (void *)local, mp);\n        OS_FileSysStatVolume_Log(buf);\n    }\n\n    if (statvfs(local->system_mountpt, &stat_buf) != 0)\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"OS_FileSysStatVolume_Impl: statvfs failed for '%s' errno=%d\", local->system_mountpt, errno);\n        OS_FileSysStatVolume_Log(buf);\n        return OS_ERROR;\n    }\n\n    /* Probe: log raw statvfs fields read */\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"OS_FileSysStatVolume_Impl: statvfs f_bsize=%lu f_bfree=%lu f_blocks=%lu\",\n                 (unsigned long)stat_buf.f_bsize,\n                 (unsigned long)stat_buf.f_bfree,\n                 (unsigned long)stat_buf.f_blocks);\n        OS_FileSysStatVolume_Log(buf);\n    }\n\n    result->block_size   = OSAL_SIZE_C(stat_buf.f_bsize);\n    result->blocks_free  = OSAL_BLOCKCOUNT_C(stat_buf.f_bfree);\n    result->total_blocks = OSAL_BLOCKCOUNT_C(stat_buf.f_blocks);\n\n    /* Probe: log resulting OS_statvfs_t values */\n    {\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"OS_FileSysStatVolume_Impl: result block_size=%llu blocks_free=%llu total_blocks=%llu\",\n                 (unsigned long long)result->block_size,\n                 (unsigned long long)result->blocks_free,\n                 (unsigned long long)result->total_blocks);\n        OS_FileSysStatVolume_Log(buf);\n    }\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysStatVolume_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The local pointer is only used for read-only access (local->system_mountpt is only read, no member of *local is modified), so per MISRA C:2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. const OS_filesys_internal_record_t *local). Converting a non-const pointer from the object table to a pointer-to-const is allowed in C, and making this change does not affect the subsequent uses (passing the mount point to statvfs, reading members, etc.). The only caveat is if some API called later requires a modifiable pointer-to-struct (or the code intentionally needs to modify *local), in which case const would be inappropriate \u2014 but that is not the case in the shown function. Therefore agent A\u2019s report is correct."
}