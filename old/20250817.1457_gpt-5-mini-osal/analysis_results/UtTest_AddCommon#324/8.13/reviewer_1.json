{
  "user_message": "An agent A claimed that the following UtTest_AddCommon code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_AddCommon.\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:UtList_Add takes a data pointer as void *Data and forwards it to UtList_NewNode(Data, ...). If the pointed data (e.g. &UtTestDataBaseEntry) is only read/copied and not modified by UtList_Add/UtList_NewNode, the parameter types should be declared as const void * (and propagated to UtList_NewNode). Using plain void * where a const-qualified pointer is possible violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nvoid UtTest_AddCommon_Log(const char *Stage, const void *DataPtr, uint32 Size, uint32 EntryType, const char *TestName)\n{\n    /* Probe: log control path and selected state to a file so other agents can reproduce the scenario */\n    FILE *Log = fopen(\"/tmp/logs/2595.txt\", \"a\");\n    if (Log == NULL)\n    {\n        return;\n    }\n\n    /* Log header information */\n    fprintf(Log, \"Stage: %s\\n\", Stage);\n    fprintf(Log, \"  DataPtr: %p\\n\", DataPtr);\n    fprintf(Log, \"  Size: %u\\n\", (unsigned int)Size);\n    fprintf(Log, \"  EntryType: %u\\n\", (unsigned int)EntryType);\n    fprintf(Log, \"  TestName: %s\\n\", (TestName != NULL) ? TestName : \"(null)\");\n\n    /* Log up to the first 64 bytes of the data payload in hex to show contents (read-only) */\n    {\n        const unsigned char *Bytes = (const unsigned char *)DataPtr;\n        uint32 Limit = (Size < 64U) ? Size : 64U;\n        unsigned int i;\n\n        fprintf(Log, \"  DataHex: \");\n        for (i = 0U; i < Limit; ++i)\n        {\n            fprintf(Log, \"%02X\", Bytes[i]);\n            if ((i + 1U) % 16U == 0U)\n            {\n                fprintf(Log, \"\\n           \");\n            }\n            else\n            {\n                fprintf(Log, \" \");\n            }\n        }\n        if (Limit == 0U)\n        {\n            fprintf(Log, \"(empty)\");\n        }\n        fprintf(Log, \"\\n\");\n    }\n\n    fflush(Log);\n    fclose(Log);\n}\n\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    /* Log the local stack entry prior to adding it to the list. Use a const pointer to emphasize\n       that the data is only read/copied by UtList_Add/UtList_NewNode in the violation scenario. */\n    UtTest_AddCommon_Log(\"before_add\", (const void *)&UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType, TestName);\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n\n    /* Log after the add call to capture post-call state and confirm what was passed. */\n    UtTest_AddCommon_Log(\"after_add\", (const void *)&UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType, TestName);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_VxWorks_BinSemAPI_Impl_Init\n  DataHex: 99 98 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 56 78 57 6F 72\n           6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70\n           6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_VxWorks_BinSemAPI_Impl_Init\n  DataHex: 99 98 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 56 78 57 6F 72\n           6B 73 5F 42 69 6E 53 65 6D 41 50 49 5F 49 6D 70\n           6C 5F 49 6E 69 74 00 00 00 00 00 00 00 00 00 00\n           \nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemCreate_Impl\n  DataHex: 61 99 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemCreate_Impl\n  DataHex: 61 99 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 43 72 65 61 74 65 5F 49 6D 70 6C 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemDelete_Impl\n  DataHex: 51 9B C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemDelete_Impl\n  DataHex: 51 9B C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 44 65 6C 65 74 65 5F 49 6D 70 6C 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemGive_Impl\n  DataHex: 61 9C C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemGive_Impl\n  DataHex: 61 9C C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 47 69 76 65 5F 49 6D 70 6C 00 00 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemFlush_Impl\n  DataHex: 3D 9E C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 46 6C 75 73 68 5F 49 6D 70 6C 00 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemFlush_Impl\n  DataHex: 3D 9E C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 46 6C 75 73 68 5F 49 6D 70 6C 00 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: before_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemTake_Impl\n  DataHex: 19 A0 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n           6D 54 61 6B 65 5F 49 6D 70 6C 00 00 00 00 00 00\n           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n           \nStage: after_add\n  DataPtr: 0x7ffddf261990\n  Size: 64\n  EntryType: 2\n  TestName: OS_BinSemTake_Impl\n  DataHex: 19 A0 C1 14 4E 56 00 00 0D A5 C1 14 4E 56 00 00\n           93 A5 C1 14 4E 56 00 00 4F 53 5F 42 69 6E 53 65\n          \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The provided logs (before_add and after_add) show the buffer passed to UtList_Add remains unchanged, and the described forwarding to UtList_NewNode indicates the code only reads/copies the supplied data. Under MISRA C:2023 Rule 8.13, pointer parameters that do not require modification of the pointed-to object should be declared to point to a const-qualified type. Therefore UtList_Add (and the forwarded UtList_NewNode) should take a const void * (and related signatures should be updated/propagated). The current use of plain void * where a const-qualified pointer is possible violates Rule 8.13."
}