{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call uses strncpy(dst, TestName, sizeof(dst)-1) without any guarantee that the source object TestName is null\u2011terminated within that many bytes or that its buffer is at least that long. If TestName points to a smaller char array (or a non\u2011terminated string) shorter than sizeof(UtTestDataBaseEntry.TestName)-1, strncpy will attempt to read up to that many bytes from TestName and can read beyond the source object\u2019s bounds \u2014 violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtTest_AddCommon code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2599.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtTest_AddCommon as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtTest_AddCommon:\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n</target_code>\nPlease provide the modified UtTest_AddCommon code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <ctype.h>\n\n/* Probe helper: append formatted log to /tmp/logs/2599.txt */\nstatic void UtProbe_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2599.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Probe helper: dump a byte range as hex and printable chars */\nstatic void UtProbe_DumpBytes(const char *label, const unsigned char *buf, size_t len)\n{\n    FILE *f = fopen(\"/tmp/logs/2599.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"%s: len=%zu\\n\", label, len);\n    fprintf(f, \"hex: \");\n    for (size_t i = 0; i < len; ++i)\n    {\n        fprintf(f, \"%02X \", buf[i]);\n    }\n    fprintf(f, \"\\n\");\n    fprintf(f, \"str: \\\"\");\n    for (size_t i = 0; i < len; ++i)\n    {\n        unsigned char c = buf[i];\n        if (isprint(c))\n            fputc(c, f);\n        else\n            fputc('.', f);\n    }\n    fprintf(f, \"\\\"\\n\");\n    fclose(f);\n}\n\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n\n    UtProbe_Log(\"UtTest_AddCommon: entry. Test=%p Setup=%p Teardown=%p TestName=%p EntryType=%u\",\n                (const void *)Test, (const void *)Setup, (const void *)Teardown, (const void *)TestName, (unsigned)EntryType);\n\n    if (TestName != NULL)\n    {\n        /* Compute the requested copy length (same as original strncpy call) */\n        size_t req_len = sizeof(UtTestDataBaseEntry.TestName) - 1U;\n\n        /* Determine if a NUL exists within req_len bytes. This mirrors the same bounded scan that\n           strncpy will effectively perform when copying up to req_len bytes. The scan is limited\n           to req_len to avoid probing beyond the amount strncpy will attempt to read. */\n        size_t found_len = 0;\n        for (found_len = 0; found_len < req_len; ++found_len)\n        {\n            /* Accessing TestName[found_len] here is the same kind of access that strncpy will do\n               during the copy and is necessary to log whether a terminating NUL exists within the\n               range. This intentionally mirrors the risky access to allow reproduction of the\n               scenario without introducing larger reads than the original code. */\n            if (TestName[found_len] == '\\0')\n            {\n                break;\n            }\n        }\n\n        if (found_len < req_len && TestName[found_len] == '\\0')\n        {\n            UtProbe_Log(\"UtTest_AddCommon: TestName contains NUL at offset %zu (within req_len=%zu)\", found_len, req_len);\n        }\n        else\n        {\n            UtProbe_Log(\"UtTest_AddCommon: No NUL found within req_len=%zu (found_len=%zu) -- strncpy will read up to req_len bytes from TestName and may read beyond its actual object bounds\", req_len, found_len);\n        }\n\n        /* Dump the bytes that will be read/copied (up to req_len bytes). This helps reproduce\n           what strncpy will see. It intentionally limits the dump to req_len bytes. */\n        UtProbe_DumpBytes(\"TestName_precopy\", (const unsigned char *)TestName, (found_len < req_len) ? (found_len + 1) : req_len);\n\n        /* Original copy operation preserved as-is */\n        strncpy(UtTestDataBaseEntry.TestName, TestName, req_len);\n\n        /* Log destination contents after strncpy (print up to full buffer length) */\n        UtProbe_DumpBytes(\"TestName_postcopy\", (const unsigned char *)UtTestDataBaseEntry.TestName, sizeof(UtTestDataBaseEntry.TestName));\n    }\n    else\n    {\n        UtProbe_Log(\"UtTest_AddCommon: TestName is NULL\");\n    }\n\n    UtProbe_Log(\"UtTest_AddCommon: about to lock and add entry\");\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n    UtProbe_Log(\"UtTest_AddCommon: exit\");\n}\n"
}