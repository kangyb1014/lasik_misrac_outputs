{
  "user_message": "Target function code is:\n```c\nvoid UtTest_AddCommon(void (*Test)(void), void (*Setup)(void), void (*Teardown)(void), const char *TestName,\n                      uint32 EntryType)\n{\n    UtTestDataBaseEntry_t UtTestDataBaseEntry;\n\n    memset(&UtTestDataBaseEntry, 0, sizeof(UtTestDataBaseEntry));\n    UtTestDataBaseEntry.Test     = Test;\n    UtTestDataBaseEntry.Setup    = Setup;\n    UtTestDataBaseEntry.Teardown = Teardown;\n    if (TestName != NULL)\n    {\n        strncpy(UtTestDataBaseEntry.TestName, TestName, sizeof(UtTestDataBaseEntry.TestName) - 1);\n    }\n\n    UT_BSP_Lock();\n    UtList_Add(UtAssert_Global.DataBasePtr, &UtTestDataBaseEntry, sizeof(UtTestDataBaseEntry_t), EntryType);\n    UT_BSP_Unlock();\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UtTest_AddCommon': {'callees': ['UT_BSP_Lock', 'UtList_Add', 'UT_BSP_Unlock'], 'callers': ['UtTest_Add', 'UtTest_AddSetup', 'UtTest_AddTeardown', 'UtTest_AddSubTest']}, 'UT_BSP_Lock': {'callees': ['OS_BSP_Lock_Impl'], 'callers': ['UtAssert_BeginTest', 'UtAssert_EndTest', 'UtAssertEx', 'UtTest_AddCommon', 'UtTest_Run', 'UT_BSP_DoText', 'UT_BSP_EndTest']}, 'UtList_Add': {'callees': ['UtList_GetHead', 'UtList_NewNode', 'UtList_Insert_Before'], 'callers': ['UtTest_AddCommon']}, 'UT_BSP_Unlock': {'callees': ['OS_BSP_Unlock_Impl'], 'callers': ['UtAssert_BeginTest', 'UtAssert_EndTest', 'UtAssertEx', 'UtTest_AddCommon', 'UtTest_Run', 'UT_BSP_DoText', 'UT_BSP_EndTest']}, 'UtTest_Add': {'callees': ['UtTest_AddCommon'], 'callers': []}, 'UtTest_AddSetup': {'callees': ['UtTest_AddCommon'], 'callers': []}, 'UtTest_AddTeardown': {'callees': ['UtTest_AddCommon'], 'callers': []}, 'UtTest_AddSubTest': {'callees': ['UtTest_AddCommon'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UtTestDataBaseEntry_t",
    "UtTestDataBaseEntry_t.TestName (member)",
    "UtTestDataBaseEntry_t.Test/Setup/Teardown (members)",
    "uint32 (typedef)",
    "UtAssert_Global (DataBasePtr member)",
    "UtList_Add (prototype/definition)",
    "UT_BSP_Lock (prototype/macro/definition)",
    "UT_BSP_Unlock (prototype/macro/definition)",
    "strncpy (prototype)",
    "memset (prototype)"
  ],
  "explanation": "Reason each symbol is needed for checking the MISRA rule (parameter shall not be modified):\n\n- UtTestDataBaseEntry_t: You must see the struct definition to know the types of its members (especially Test, Setup, Teardown and TestName) and to confirm that the function only writes into a local object, not into a function parameter. The struct definition also gives the size used in sizeof, and the actual type of Test/Setup/Teardown fields (to confirm no aliasing to the parameter variables).\n\n- UtTestDataBaseEntry_t.TestName (member): The code calls strncpy with TestName as source and UtTestDataBaseEntry.TestName as destination. Knowing the member declaration (array vs pointer, qualifiers) verifies that the destination is a local object and that the source parameter (TestName) is not being written to.\n\n- UtTestDataBaseEntry_t.Test/Setup/Teardown (members): Explicitly note these members so the analyser can confirm the assignment UtTestDataBaseEntry.Test = Test; etc. assigns parameter values into a local struct member (allowed) and does not modify the parameter variables themselves.\n\n- uint32 (typedef): Confirm that EntryType is an ordinary scalar type (not a typedef to a pointer or complex type that could alias or be modified indirectly). This ensures passing EntryType by value cannot cause modification of the parameter variable by callees.\n\n- UtAssert_Global (DataBasePtr member): The global whose DataBasePtr is passed to UtList_Add must be known (type/definition) so the analyser can check how UtList_Add is invoked and to rule out any macros or strange aliasing that might involve function parameters.\n\n- UtList_Add (prototype/definition): You must inspect UtList_Add's signature/implementation (or macro expansion) to ensure it does not take addresses of this function's parameters or otherwise modify the parameter variables (e.g., via macro side effects). Confirm it only uses the provided pointer to the local UtTestDataBaseEntry buffer and does not write into the caller's parameter variables.\n\n- UT_BSP_Lock / UT_BSP_Unlock (prototype/macro/definition): These could be functions or macros; include their definitions to confirm they do not expand into code that assigns to or takes the address of any of this function's parameters. Macros in particular could reference identifiers and cause unexpected modifications.\n\n- strncpy (prototype): Include the standard prototype to confirm the argument types (source is const char *), so passing TestName (const char *) is a read-only use of the parameter and strncpy will not modify the pointer parameter variable itself.\n\n- memset (prototype): Include memset to confirm its usage here targets the local struct buffer and does not touch any parameter variables.\n\nIn short: obtain the struct and typedefs to verify local vs parameter objects, and obtain prototypes/definitions (or macro expansions) of the called functions/macros (UtList_Add, UT_BSP_Lock, UT_BSP_Unlock, strncpy, memset) to ensure none of them modify the target function's parameter variables (directly or via macro expansion)."
}