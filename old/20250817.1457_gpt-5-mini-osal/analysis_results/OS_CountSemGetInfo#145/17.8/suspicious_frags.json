{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_CountSemGetInfo:\n```c\nint32 OS_CountSemGetInfo(osal_id_t sem_id, OS_count_sem_prop_t *count_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(count_prop);\n\n    memset(count_prop, 0, sizeof(OS_count_sem_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_count_sem_table, token);\n\n        strncpy(count_prop->name, record->name_entry, sizeof(count_prop->name) - 1);\n        count_prop->creator = record->creator;\n\n        return_code = OS_CountSemGetInfo_Impl(&token, count_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_CountSemGetInfo:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nint32 OS_CountSemGetInfo_Impl(const OS_object_token_t *token, OS_count_sem_prop_t *count_prop)\n{\n    int                                 sval;\n    OS_impl_countsem_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_count_sem_table, *token);\n\n    if (sem_getvalue(&impl->id, &sval) < 0)\n    {\n        return OS_SEM_FAILURE;\n    }\n\n    /* put the info into the structure */\n    count_prop->value = sval;\n    return OS_SUCCESS;\n}\n...\ntypedef struct\n{\n    char      name[OS_MAX_API_NAME];\n    osal_id_t creator;\n    int32     value;\n} OS_count_sem_prop_t\n...\ntypedef struct OS_common_record OS_common_record_t\n...\nextern OS_common_record_t *const OS_global_count_sem_table\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No code fragments in the provided functions appear to modify a function parameter itself (which would violate MISRA C 2023 Rule 17.8). Specific notes ruling out suspiciousness:\n\n- OS_CountSemGetInfo parameters: sem_id is not assigned to anywhere in the function; count_prop (a pointer parameter) is not reassigned. The code only modifies the object pointed to by count_prop (memset, strncpy, assignments) which is permitted by the rule.\n\n- The OS_CHECK_POINTER(count_prop) macro only checks/evaluates the pointer for NULL; it does not assign to the pointer parameter.\n\n- The call return_code = OS_CountSemGetInfo_Impl(&token, count_prop) passes count_prop through; passing a pointer as an argument does not modify the pointer parameter in the caller. The local token is not a function parameter of OS_CountSemGetInfo and thus not relevant to Rule 17.8 for that function.\n\n- In OS_CountSemGetInfo_Impl the first parameter is const OS_object_token_t *token and the function dereferences it but does not reassign the token pointer; dereferencing to access pointed-to data is allowed. The second parameter OS_count_sem_prop_t *count_prop is used to store the semaphore value (count_prop->value = sval) \u2014 this modifies the pointed-to object, which the rule permits.\n\n- The OS_OBJECT_TABLE_GET macro uses the address-of operator on its macro argument (&(tok)) but in the uses shown the argument is an lvalue (token or *token). The macro expansion does not reassign function parameters.\n\nGiven the provided code and related definitions, there are no instances where a function parameter (the pointer variable itself or any other parameter) is assigned to or otherwise modified; only the objects pointed-to are modified, which is allowed by Rule 17.8. Therefore no suspicious fragments are reported."
}