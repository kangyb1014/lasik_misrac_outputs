{
  "user_message": "An agent A claimed that the following OS_Posix_InternalTaskCreate_Impl code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of OS_Posix_InternalTaskCreate_Impl.\n```c\nint32 OS_Posix_InternalTaskCreate_Impl(pthread_t *pthr, osal_priority_t priority, size_t stacksz,\n                                       PthreadFuncPtr_t entry, void *entry_arg)\n{\n    int                return_code = 0;\n    pthread_attr_t     custom_attr;\n    struct sched_param priority_holder;\n\n    /*\n     ** Initialize the pthread_attr structure.\n     ** The structure is used to set the stack and priority\n     */\n    memset(&custom_attr, 0, sizeof(custom_attr));\n    return_code = pthread_attr_init(&custom_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_init error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n     * Adjust the stack size parameter.\n     *\n     * POSIX has additional restrictions/limitations on the stack size of tasks that\n     * other RTOS environments may not have.  Specifically POSIX says that the stack\n     * size must be at least PTHREAD_STACK_MIN and may also need to be a multiple of the\n     * system page size.\n     *\n     * Rounding up means the user might get a bigger stack than they requested, but\n     * that should not break anything aside from consuming extra memory.\n     */\n    if (stacksz < PTHREAD_STACK_MIN)\n    {\n        stacksz = PTHREAD_STACK_MIN;\n    }\n\n    stacksz += POSIX_GlobalVars.PageSize - 1;\n    stacksz -= stacksz % POSIX_GlobalVars.PageSize;\n\n    /*\n    ** Set the Stack Size\n    */\n    return_code = pthread_attr_setstacksize(&custom_attr, stacksz);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_setstacksize error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n    ** Set the thread to be joinable by default\n    */\n    return_code = pthread_attr_setdetachstate(&custom_attr, PTHREAD_CREATE_JOINABLE);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_setdetachstate error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n    ** Test to see if the original main task scheduling priority worked.\n    ** If so, then also set the attributes for this task.  Otherwise attributes\n    ** are left at default.\n    */\n    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /*\n        ** Set the scheduling inherit attribute to EXPLICIT\n        */\n        return_code = pthread_attr_setinheritsched(&custom_attr, PTHREAD_EXPLICIT_SCHED);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setinheritsched error in OS_TaskCreate, errno = %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set the scheduling policy\n        ** The best policy is determined during initialization\n        */\n        return_code = pthread_attr_setschedpolicy(&custom_attr, POSIX_GlobalVars.SelectedRtScheduler);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setschedpolity error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set priority\n        */\n        return_code = pthread_attr_getschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_getschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        priority_holder.sched_priority = OS_PriorityRemap(priority);\n        return_code                    = pthread_attr_setschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n    } /* End if user is root */\n\n    /*\n     ** Create thread\n     */\n    return_code = pthread_create(pthr, &custom_attr, entry, entry_arg);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_create error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n     ** Free the resources that are no longer needed\n     ** Since the task is now running - pthread_create() was successful -\n     ** Do not treat anything bad that happens after this point as fatal.\n     ** The task is running, after all - better to leave well enough alone.\n     */\n    return_code = pthread_attr_destroy(&custom_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_destroy error in OS_TaskCreate: %s\\n\", strerror(return_code));\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'stacksz' (a non-pointer function parameter) is modified by the statement 'stacksz += POSIX_GlobalVars.PageSize - 1;'. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (except the object pointed to by pointer parameters). This line therefore violates Rule 17.8. (Remedy: copy 'stacksz' to a local variable and modify the local.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_Posix_InternalTaskCreate_Impl(pthread_t *pthr, osal_priority_t priority, size_t stacksz,\n                                       PthreadFuncPtr_t entry, void *entry_arg)\n{\n    int                return_code = 0;\n    pthread_attr_t     custom_attr;\n    struct sched_param priority_holder;\n    FILE *log = fopen(\"/tmp/logs/461.txt\", \"a\");\n\n    if (log)\n    {\n        fprintf(log, \"ENTER: OS_Posix_InternalTaskCreate_Impl priority=%d stacksz=%zu pthr=%p entry=%p entry_arg=%p\\n\",\n                (int)priority, stacksz, (void *)pthr, (void *)entry, entry_arg);\n        fflush(log);\n    }\n\n    /*\n     ** Initialize the pthread_attr structure.\n     ** The structure is used to set the stack and priority\n     */\n    memset(&custom_attr, 0, sizeof(custom_attr));\n    return_code = pthread_attr_init(&custom_attr);\n    if (return_code != 0)\n    {\n        if (log)\n        {\n            fprintf(log, \"ERROR: pthread_attr_init returned %d (%s)\\n\", return_code, strerror(return_code));\n            fclose(log);\n        }\n        OS_DEBUG(\"pthread_attr_init error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n     * Adjust the stack size parameter.\n     *\n     * POSIX has additional restrictions/limitations on the stack size of tasks that\n     * other RTOS environments may not have.  Specifically POSIX says that the stack\n     * size must be at least PTHREAD_STACK_MIN and may also need to be a multiple of the\n     * system page size.\n     *\n     * Rounding up means the user might get a bigger stack than they requested, but\n     * that should not break anything aside from consuming extra memory.\n     */\n    if (log)\n    {\n        fprintf(log, \"BEFORE_ADJUST: stacksz=%zu PTHREAD_STACK_MIN=%d PageSize=%zu\\n\",\n                stacksz, (int)PTHREAD_STACK_MIN, POSIX_GlobalVars.PageSize);\n        fflush(log);\n    }\n\n    if (stacksz < PTHREAD_STACK_MIN)\n    {\n        if (log)\n        {\n            fprintf(log, \"ADJUST_MIN: stacksz (%zu) < PTHREAD_STACK_MIN (%d) -> setting to PTHREAD_STACK_MIN\\n\",\n                    stacksz, (int)PTHREAD_STACK_MIN);\n            fflush(log);\n        }\n        stacksz = PTHREAD_STACK_MIN;\n    }\n\n    if (log)\n    {\n        fprintf(log, \"AFTER_MIN_CHECK: stacksz=%zu\\n\", stacksz);\n        fflush(log);\n    }\n\n    stacksz += POSIX_GlobalVars.PageSize - 1;\n    if (log)\n    {\n        fprintf(log, \"ROUND_PRE: added PageSize-1 -> stacksz=%zu (PageSize=%zu)\\n\",\n                stacksz, POSIX_GlobalVars.PageSize);\n        fflush(log);\n    }\n\n    stacksz -= stacksz % POSIX_GlobalVars.PageSize;\n    if (log)\n    {\n        fprintf(log, \"ROUND_POST: rounded down to page multiple -> stacksz=%zu\\n\", stacksz);\n        fflush(log);\n    }\n\n    /*\n    ** Set the Stack Size\n    */\n    if (log)\n    {\n        fprintf(log, \"SET_STACKSIZE: calling pthread_attr_setstacksize with stacksz=%zu\\n\", stacksz);\n        fflush(log);\n    }\n    return_code = pthread_attr_setstacksize(&custom_attr, stacksz);\n    if (return_code != 0)\n    {\n        if (log)\n        {\n            fprintf(log, \"ERROR: pthread_attr_setstacksize returned %d (%s) with stacksz=%zu\\n\",\n                    return_code, strerror(return_code), stacksz);\n            fclose(log);\n        }\n        OS_DEBUG(\"pthread_attr_setstacksize error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    if (log)\n    {\n        fprintf(log, \"SET_STACKSIZE_OK: pthread_attr_setstacksize succeeded for stacksz=%zu\\n\", stacksz);\n        fflush(log);\n    }\n\n    /*\n    ** Set the thread to be joinable by default\n    */\n    return_code = pthread_attr_setdetachstate(&custom_attr, PTHREAD_CREATE_JOINABLE);\n    if (return_code != 0)\n    {\n        if (log)\n        {\n            fprintf(log, \"ERROR: pthread_attr_setdetachstate returned %d (%s)\\n\", return_code, strerror(return_code));\n            fclose(log);\n        }\n        OS_DEBUG(\"pthread_attr_setdetachstate error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n    ** Test to see if the original main task scheduling priority worked.\n    ** If so, then also set the attributes for this task.  Otherwise attributes\n    ** are left at default.\n    */\n    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /*\n        ** Set the scheduling inherit attribute to EXPLICIT\n        */\n        return_code = pthread_attr_setinheritsched(&custom_attr, PTHREAD_EXPLICIT_SCHED);\n        if (return_code != 0)\n        {\n            if (log)\n            {\n                fprintf(log, \"ERROR: pthread_attr_setinheritsched returned %d (%s)\\n\", return_code, strerror(return_code));\n                fclose(log);\n            }\n            OS_DEBUG(\"pthread_attr_setinheritsched error in OS_TaskCreate, errno = %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set the scheduling policy\n        ** The best policy is determined during initialization\n        */\n        return_code = pthread_attr_setschedpolicy(&custom_attr, POSIX_GlobalVars.SelectedRtScheduler);\n        if (return_code != 0)\n        {\n            if (log)\n            {\n                fprintf(log, \"ERROR: pthread_attr_setschedpolicy returned %d (%s)\\n\", return_code, strerror(return_code));\n                fclose(log);\n            }\n            OS_DEBUG(\"pthread_attr_setschedpolity error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set priority\n        */\n        return_code = pthread_attr_getschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            if (log)\n            {\n                fprintf(log, \"ERROR: pthread_attr_getschedparam returned %d (%s)\\n\", return_code, strerror(return_code));\n                fclose(log);\n            }\n            OS_DEBUG(\"pthread_attr_getschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        priority_holder.sched_priority = OS_PriorityRemap(priority);\n        if (log)\n        {\n            fprintf(log, \"PRIORITY: remapped priority -> sched_priority=%d\\n\", (int)priority_holder.sched_priority);\n            fflush(log);\n        }\n        return_code                    = pthread_attr_setschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            if (log)\n            {\n                fprintf(log, \"ERROR: pthread_attr_setschedparam returned %d (%s)\\n\", return_code, strerror(return_code));\n                fclose(log);\n            }\n            OS_DEBUG(\"pthread_attr_setschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n    } /* End if user is root */\n\n    /*\n     ** Create thread\n     */\n    if (log)\n    {\n        fprintf(log, \"CREATE_THREAD: calling pthread_create\\n\");\n        fflush(log);\n    }\n    return_code = pthread_create(pthr, &custom_attr, entry, entry_arg);\n    if (return_code != 0)\n    {\n        if (log)\n        {\n            fprintf(log, \"ERROR: pthread_create returned %d (%s)\\n\", return_code, strerror(return_code));\n            fclose(log);\n        }\n        OS_DEBUG(\"pthread_create error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    if (log)\n    {\n        fprintf(log, \"CREATE_THREAD_OK: thread created, pthr=%p\\n\", (void *)pthr);\n        fflush(log);\n    }\n\n    /*\n     ** Free the resources that are no longer needed\n     ** Since the task is now running - pthread_create() was successful -\n     ** Do not treat anything bad that happens after this point as fatal.\n     ** The task is running, after all - better to leave well enough alone.\n     */\n    return_code = pthread_attr_destroy(&custom_attr);\n    if (return_code != 0)\n    {\n        if (log)\n        {\n            fprintf(log, \"WARN: pthread_attr_destroy returned %d (%s)\\n\", return_code, strerror(return_code));\n            fflush(log);\n            /* Do not treat this as fatal - close log and continue returning success */\n            fclose(log);\n        }\n        OS_DEBUG(\"pthread_attr_destroy error in OS_TaskCreate: %s\\n\", strerror(return_code));\n    }\n    else\n    {\n        if (log)\n        {\n            fprintf(log, \"EXIT: OS_Posix_InternalTaskCreate_Impl returning OS_SUCCESS stacksz=%zu\\n\", stacksz);\n            fflush(log);\n            fclose(log);\n        }\n    }\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_Posix_InternalTaskCreate_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 17.8 states that a function parameter shall not be modified (the object pointed to by a pointer parameter may be modified, but the pointer itself shall not). In the shown function the non\u2011pointer parameter 'stacksz' is assigned to and modified (examples: 'stacksz = PTHREAD_STACK_MIN;', 'stacksz += POSIX_GlobalVars.PageSize - 1;', and 'stacksz -= stacksz % POSIX_GlobalVars.PageSize;'). Those statements modify a value parameter and therefore violate Rule 17.8. The remedy is to copy the parameter into a local variable (e.g. size_t adjusted_stacksz = stacksz;) and perform the adjustments on that local variable, then use the local when calling pthread_attr_setstacksize. The empty test log does not affect the correctness of this rule assessment."
}