{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The iterator member OS_object_iter_t::base is declared as OS_common_record_t * but in OS_ObjectIdIteratorGetNext it is only used for read-only access (OS_OBJECT_TABLE_GET returns a record pointer that is only read, e.g. record->active_id). Therefore base should be const OS_common_record_t * to reflect that it is not modified; the current non-const declaration violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ObjectIdIterator_LogState(const char *stage,\n                                         const OS_object_iter_t *iter,\n                                         const OS_common_record_t *record,\n                                         int match_called,\n                                         int match_result)\n{\n    FILE *f = fopen(\"/tmp/logs/1603.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Print a compact snapshot useful to reproduce the violation scenario. */\n    fprintf(f, \"[%s] iter=%p base=%p token.idx=%llu limit=%llu token.id=%llu match=%p arg=%p record=%p\",\n            stage,\n            (void *)iter,\n            (void *)iter->base,\n            (unsigned long long)iter->token.obj_idx,\n            (unsigned long long)iter->limit,\n            (unsigned long long)iter->token.obj_id,\n            (void *)iter->match,\n            (void *)iter->arg,\n            (void *)record);\n\n    if (record != NULL)\n    {\n        fprintf(f, \" active_id=%llu\", (unsigned long long)record->active_id);\n    }\n\n    fprintf(f, \" match_called=%d match_result=%d\\n\", match_called, match_result);\n    fclose(f);\n}\n\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    /* Log initial state */\n    OS_ObjectIdIterator_LogState(\"enter\", iter, NULL, 0, 0);\n\n    do\n    {\n        ++iter->token.obj_idx;\n\n        /* Log after advancing the index */\n        OS_ObjectIdIterator_LogState(\"after_inc\", iter, NULL, 0, 0);\n\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            OS_ObjectIdIterator_LogState(\"limit_reached\", iter, NULL, 0, 0);\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n\n        /* Log the record pointer obtained from the table */\n        OS_ObjectIdIterator_LogState(\"got_record\", iter, record, 0, 0);\n\n        if (iter->match == NULL)\n        {\n            /* No match function: treat as match */\n            OS_ObjectIdIterator_LogState(\"match_null\", iter, record, 0, 1);\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n        else\n        {\n            /* Call the match function once and log its result */\n            int match_result = iter->match(iter->arg, &iter->token, record) ? 1 : 0;\n            OS_ObjectIdIterator_LogState(\"match_called\", iter, record, 1, match_result);\n\n            if (match_result)\n            {\n                iter->token.obj_id = record->active_id;\n                got_next           = true;\n            }\n        }\n    } while (!got_next);\n\n    OS_ObjectIdIterator_LogState(\"exit\", iter, (got_next ? record : NULL), 0, got_next ? 1 : 0);\n\n    return got_next;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdIteratorGetNext. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not proven correct. MISRA C 2023 Rule 8.13 requires that a pointer type be const-qualified when it can be (i.e. the object is never modified through that pointer anywhere it is used). Merely observing that OS_ObjectIdIteratorGetNext only reads from the record pointer does not by itself prove a violation: the offending declaration is at the type/structure definition of OS_object_iter_t::base, and you must examine that definition and all uses of iter->base (and the callback signature iter->match and any macros like OS_OBJECT_TABLE_GET) to determine whether making it const is possible. In particular, if other code (or the match callback) writes via the pointer, or OS_OBJECT_TABLE_GET yields a non-const record type, then keeping base non-const is required and no MISRA violation exists. The provided evidence shows only a single read-only use in this function, so it is insufficient to conclude a rule 8.13 violation."
}