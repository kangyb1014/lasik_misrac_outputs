{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'record' is declared as OS_common_record_t * but is only used for read access (record->active_id). It is assigned from OS_OBJECT_TABLE_GET(iter->base, iter->token) which yields a non-const OS_common_record_t *. Since the pointee is not modified in this function, the pointer should be const-qualified (e.g. const OS_common_record_t *record, and ideally iter->base should be const OS_common_record_t *). Therefore Rule 8.13 is violated in this code fragment.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1603.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    /* Entry log */\n    os_probe_log(\"ENTRY: OS_ObjectIdIteratorGetNext iter=%p start_idx=%lu limit=%lu start_obj_id=%lu\",\n                 (void *)iter,\n                 (unsigned long)iter->token.obj_idx,\n                 (unsigned long)iter->limit,\n                 (unsigned long)iter->token.obj_id);\n\n    do\n    {\n        ++iter->token.obj_idx;\n        os_probe_log(\"LOOP: incremented obj_idx=%lu (limit=%lu)\",\n                     (unsigned long)iter->token.obj_idx,\n                     (unsigned long)iter->limit);\n\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            os_probe_log(\"BREAK: obj_idx (%lu) >= limit (%lu)\",\n                         (unsigned long)iter->token.obj_idx,\n                         (unsigned long)iter->limit);\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        os_probe_log(\"FETCH: record=%p base=%p obj_idx=%lu\",\n                     (void *)record,\n                     (void *)iter->base,\n                     (unsigned long)iter->token.obj_idx);\n\n        /* Evaluate match once and log the result (preserve original semantics) */\n        bool matched;\n        if (iter->match == NULL)\n        {\n            matched = true;\n        }\n        else\n        {\n            matched = iter->match(iter->arg, &iter->token, record);\n        }\n\n        os_probe_log(\"MATCH_EVAL: matched=%d for record=%p obj_idx=%lu\",\n                     (int)matched,\n                     (void *)record,\n                     (unsigned long)iter->token.obj_idx);\n\n        if (matched)\n        {\n            /* Log the active_id read for evidence that the record is only read */\n            os_probe_log(\"ASSIGN: assigning token.obj_id = record->active_id (record=%p active_id=%lu)\",\n                         (void *)record,\n                         (unsigned long)record->active_id);\n\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    os_probe_log(\"EXIT: got_next=%d final_obj_id=%lu final_obj_idx=%lu\",\n                 (int)got_next,\n                 (unsigned long)iter->token.obj_id,\n                 (unsigned long)iter->token.obj_idx);\n\n    return got_next;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdIteratorGetNext. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation (the local pointer variable is only read and could be const-qualified) is technically valid as a coding-style point, but the report does not establish a definite MISRA 8.13 violation. Whether Rule 8.13 is violated depends on the surrounding API: the function passes record to iter->match(...) and the code uses OS_OBJECT_TABLE_GET(iter->base,...). If the match callback\u2019s parameter type (and any other callees) expects a non-const OS_common_record_t * (i.e. the record may be modified through that pointer), then the local declaration cannot be changed to const without changing other interfaces. Conversely, if the match callback and OS_OBJECT_TABLE_GET can accept/return const-qualified pointers (or match takes a pointer-to-const), then the local pointer should be declared const to satisfy Rule 8.13. The supplied test/logging run does not prove that the pointee is never modified elsewhere. Therefore the report as stated is not conclusively correct. Recommendation: inspect the prototype of iter->match and OS_OBJECT_TABLE_GET (and other uses) \u2014 if they do not require a modifiable pointer, change the local variable to const OS_common_record_t * (and consider const-qualifying upstream APIs) to conform to Rule 8.13."
}