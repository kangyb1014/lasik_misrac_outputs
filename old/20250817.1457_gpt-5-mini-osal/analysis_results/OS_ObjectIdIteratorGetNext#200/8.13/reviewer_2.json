{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The invocation iter->match(iter->arg, &iter->token, record) passes a pointer to iter->token and the record pointer as non-const. If the match callback does not need to modify those objects (typical for a predicate), the function prototype should use const-qualified pointer parameters (e.g. const OS_object_token_t * and const OS_common_record_t * or const void * for arg). Given that record is declared as OS_common_record_t * and &iter->token yields a non-const pointer, this is a violation of MISRA C 2023 Rule 8.13 unless the match callback actually needs to modify those objects.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_probe(const char *event, OS_object_iter_t *iter, OS_common_record_t *record, int match_result)\n{\n    FILE *f = fopen(\"/tmp/logs/1603.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Safely print the most relevant fields observed in the iterator/record. */\n    (void)fprintf(f,\n                  \"%s: iter=%p arg=%p token_addr=%p token.obj_idx=%lld token.obj_id=%lld limit=%lld base=%p record=%p active_id=%lld match_result=%d\\n\",\n                  event,\n                  (void *)iter,\n                  (void *)(iter ? iter->arg : NULL),\n                  (void *)(iter ? &iter->token : NULL),\n                  (long long)(iter ? (long long)iter->token.obj_idx : (long long)-1),\n                  (long long)(iter ? (long long)iter->token.obj_id : (long long)-1),\n                  (long long)(iter ? (long long)iter->limit : (long long)-1),\n                  (void *)(iter ? iter->base : NULL),\n                  (void *)record,\n                  (long long)(record ? (long long)record->active_id : (long long)-1),\n                  match_result);\n\n    (void)fclose(f);\n}\n\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            os_log_probe(\"break_out_of_range\", iter, NULL, -1);\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        os_log_probe(\"after_get_record\", iter, record, -1);\n\n        if (iter->match == NULL)\n        {\n            os_log_probe(\"match_is_null\", iter, record, -1);\n            /* Preserve original behavior when match is NULL */\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n        else\n        {\n            os_log_probe(\"before_match_call\", iter, record, -1);\n            /* Call match and capture result for logging while preserving original logic */\n            int match_res = iter->match(iter->arg, &iter->token, record) ? 1 : 0;\n            os_log_probe(\"after_match_call\", iter, record, match_res);\n\n            if (match_res)\n            {\n                iter->token.obj_id = record->active_id;\n                got_next           = true;\n            }\n        }\n    } while (!got_next);\n\n    os_log_probe(\"function_exit\", iter, NULL, got_next ? 1 : 0);\n\n    return got_next;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdIteratorGetNext. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a MISRA 8.13 violation. MISRA C 2023 Rule 8.13 concerns pointer declarations (pointer types should be const-qualified when the pointed-to object does not need to be modified), not the mere act of passing an address at a call site. The code shown only shows a call: iter->match(iter->arg, &iter->token, record). Whether this violates 8.13 depends on the declaration of the match callback in OS_object_iter_t and on whether the callback actually needs to modify the pointed-to objects. If the match callback is declared to take non-const pointers because it may modify the token or record, then there is no violation. If the callback is declared to take non-const pointers but in all uses it never modifies them, then the correct remedy would be to change the callback prototype to use const-qualified pointer parameters (or document/justify the non-const API) \u2014 but you must inspect the callback declaration and its implementations to determine that. In short: agent A misapplied the rule to a call site and provided no evidence about the callback\u2019s declaration or behavior, so the report is not correct as presented. To confirm a real violation, examine the match function pointer type in OS_object_iter_t and all match implementations to see if const qualification is possible without breaking API semantics."
}