{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorGetNext code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorGetNext.\n```c\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If OS_ObjectIndexFromToken is declared to take a non-const pointer (e.g. OS_ObjectIndexFromToken(OS_object_token_t *tok)) but does not actually modify the token, then the pointer parameter should be declared const (const OS_object_token_t *). The macro passes &(tok) which yields a non-const OS_object_token_t *; therefore in that situation Rule 8.13 is violated because the pointer should point to a const-qualified type when possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ObjectIterator_LogState(const OS_object_iter_t *iter, const OS_common_record_t *record, const char *event)\n{\n    FILE *f = fopen(\"/tmp/logs/1603.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Try to create the directory once if it does not exist, then retry */\n        (void)mkdir(\"/tmp/logs\", 0777);\n        f = fopen(\"/tmp/logs/1603.txt\", \"a\");\n    }\n\n    if (f != NULL)\n    {\n        /* Print important fields that help reproduce the control flow and state\n         * relevant to the token/object index scenario. We keep casts to avoid\n         * warnings on pointer-to-integer prints. */\n        fprintf(f,\n                \"%s: iter=%p token.obj_idx=%ld token.obj_id=%ld limit=%ld base=%p match=%p arg=%p record=%p active_id=%ld\\n\",\n                event,\n                (const void *)iter,\n                (long)iter->token.obj_idx,\n                (long)iter->token.obj_id,\n                (long)iter->limit,\n                (const void *)iter->base,\n                (const void *)iter->match,\n                (const void *)iter->arg,\n                (const void *)record,\n                (long)((record != NULL) ? record->active_id : -1));\n        fclose(f);\n    }\n}\n\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    /* Log entry state */\n    OS_ObjectIterator_LogState(iter, NULL, \"ENTRY\");\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    OS_ObjectIterator_LogState(iter, NULL, \"AFTER_INIT_TOKEN_ID\");\n\n    do\n    {\n        OS_ObjectIterator_LogState(iter, NULL, \"LOOP_TOP_BEFORE_INCREMENT\");\n\n        ++iter->token.obj_idx;\n\n        OS_ObjectIterator_LogState(iter, NULL, \"AFTER_INCREMENT\");\n\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            OS_ObjectIterator_LogState(iter, NULL, \"BREAK_LIMIT_REACHED\");\n            break;\n        }\n\n        /* Retrieve the record for the current token */\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n\n        OS_ObjectIterator_LogState(iter, record, \"AFTER_RECORD_FETCH\");\n\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            OS_ObjectIterator_LogState(iter, record, \"MATCH_SUCCESS\");\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n            OS_ObjectIterator_LogState(iter, record, \"ASSIGNED_OBJ_ID_AND_SET_GOT_NEXT\");\n        }\n        else\n        {\n            OS_ObjectIterator_LogState(iter, record, \"MATCH_FAILED\");\n        }\n    } while (!got_next);\n\n    OS_ObjectIterator_LogState(iter, got_next ? record : NULL, \"EXIT\");\n\n    return got_next;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdIteratorGetNext. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA 8.13 is about pointer declarations pointing to const-qualified types where possible. The code shown does not contain such a bad declaration: OS_ObjectIdIteratorGetNext modifies iter->token (increments obj_idx and assigns obj_id), so token cannot be declared const in this function. Passing &iter->token yields a non-const pointer value, but that is permissible when the pointee is mutable here; moreover converting a non-const pointer to a const-parameter of a callee is allowed. The only way a Rule 8.13 violation could exist is if some function/type (for example the prototype of OS_ObjectIndexFromToken or the match callback) is declared to take a non-const pointer even though it never modifies the pointee \u2014 that would be a problem in that function's declaration, not in OS_ObjectIdIteratorGetNext. Agent A's scenario is speculative and does not demonstrate a violation in the provided code, so the report is not correct."
}