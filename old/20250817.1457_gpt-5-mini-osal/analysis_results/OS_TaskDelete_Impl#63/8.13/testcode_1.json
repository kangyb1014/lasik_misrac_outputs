{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function declares a non-const pointer: \"OS_impl_task_internal_record_t *impl;\" and uses it only for read access (impl->id passed to pthread_cancel/join). Since the function does not modify the pointee, the pointer should be declared as a pointer to const (const OS_impl_task_internal_record_t *impl) to satisfy MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/507.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete_Impl:\n```c\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <pthread.h>\n#include <errno.h>\n\n/* Probe logging helper: append formatted messages to /tmp/logs/507.txt */\nstatic void OS_TaskDelete_Impl_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/507.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: entry token=%p\", (const void *)token);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /* Log the pointer value and the object id for easier correlation in the logs */\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: impl pointer=%p\", (const void *)impl);\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: object id=%lu\",\n                           OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)));\n\n    /* Compute a simple checksum of the impl object memory to demonstrate that it is not modified\n     * by this function (evidence the pointer is used for read-only access at runtime).\n     * Guard against impl being NULL. */\n    if (impl != NULL)\n    {\n        unsigned long checksum_before = 0u;\n        size_t i;\n        const unsigned char *bytes = (const unsigned char *)impl;\n        for (i = 0u; i < sizeof *impl; ++i)\n        {\n            checksum_before += (unsigned long)bytes[i];\n        }\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: checksum_before=%lu\", checksum_before);\n    }\n    else\n    {\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: impl is NULL\");\n    }\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: calling pthread_cancel for object id=%lu\",\n                           OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)));\n    ret = pthread_cancel(impl->id);\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: pthread_cancel returned %d\", ret);\n\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: pthread_cancel failed for object id=%lu, err=%s\",\n                               OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: calling pthread_join for object id=%lu\",\n                               OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)));\n        ret = pthread_join(impl->id, &retval);\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: pthread_join returned %d, retval=%p\", ret, retval);\n\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n            OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: pthread_join failed for object id=%lu, err=%s\",\n                                   OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n\n    /* Recompute checksum to show that impl memory was not modified by this function */\n    if (impl != NULL)\n    {\n        unsigned long checksum_after = 0u;\n        size_t i;\n        const unsigned char *bytes = (const unsigned char *)impl;\n        for (i = 0u; i < sizeof *impl; ++i)\n        {\n            checksum_after += (unsigned long)bytes[i];\n        }\n        OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: checksum_after=%lu\", checksum_after);\n    }\n\n    OS_TaskDelete_Impl_log(\"OS_TaskDelete_Impl: exit returning OS_SUCCESS\");\n    return OS_SUCCESS;\n}\n"
}