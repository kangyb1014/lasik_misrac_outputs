{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable 'impl' is declared as a non-const pointer (OS_impl_task_internal_record_t *impl) but in the shown function it is only read (impl->id is used) and the pointed-to table entry is not modified. The assignment impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token); therefore yields a non-const pointer when a pointer-to-const (const OS_impl_task_internal_record_t *impl) would be possible and preferable. This violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/507.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete_Impl:\n```c\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete_Impl code.\n",
  "test_code": "int32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /* Probe: log entry, token and resolved impl pointer */\n    {\n        FILE *fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"OS_TaskDelete_Impl: ENTRY\\n\");\n            fprintf(fp, \"  token_ptr=%p\\n\", (void *)token);\n            fprintf(fp, \"  token_id=%lu\\n\", OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)));\n            fprintf(fp, \"  impl_ptr=%p\\n\", (void *)impl);\n            fclose(fp);\n        }\n    }\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n\n    /* Probe: log result of pthread_cancel */\n    {\n        FILE *fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"  pthread_cancel called on impl->id (impl=%p)\\n\", (void *)impl);\n            fprintf(fp, \"  pthread_cancel returned: %d\\n\", ret);\n            if (ret != 0)\n            {\n                fprintf(fp, \"  pthread_cancel error: %s\\n\", strerror(ret));\n            }\n            fclose(fp);\n        }\n    }\n\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n\n        /* Probe: log result of pthread_join */\n        {\n            FILE *fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n            if (fp != NULL)\n            {\n                fprintf(fp, \"  pthread_join called on impl->id (impl=%p)\\n\", (void *)impl);\n                fprintf(fp, \"  pthread_join returned: %d\\n\", ret);\n                if (ret != 0)\n                {\n                    fprintf(fp, \"  pthread_join error: %s\\n\", strerror(ret));\n                }\n                else\n                {\n                    fprintf(fp, \"  pthread_join success, retval=%p\\n\", retval);\n                }\n                fclose(fp);\n            }\n        }\n\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n\n    /* Probe: log exit */\n    {\n        FILE *fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n        if (fp != NULL)\n        {\n            fprintf(fp, \"OS_TaskDelete_Impl: EXIT (return %d)\\n\", (int)OS_SUCCESS);\n            fprintf(fp, \"--------------------------------------------------\\n\");\n            fclose(fp);\n        }\n    }\n\n    return OS_SUCCESS;\n}\n"
}