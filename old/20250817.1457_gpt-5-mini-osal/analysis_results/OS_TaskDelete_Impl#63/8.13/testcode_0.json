{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe macro OS_OBJECT_TABLE_GET returns a pointer to a mutable table element (&tbl[index]) even when it is used in contexts where a const-qualified pointer would be appropriate. For example, in OS_TaskDelete_Impl the call impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token) yields an OS_impl_task_internal_record_t * but the function only reads impl->id and does not modify the record; impl could therefore be declared const OS_impl_task_internal_record_t * (or the macro could return a pointer to const). The macro thus produces a non-const pointer where a const-qualified pointer is possible, violating MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/507.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete_Impl:\n```c\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    ret = pthread_cancel(impl->id);\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n        ret = pthread_join(impl->id, &retval);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n\n/* Probe helper to log control flow and state for OS_TaskDelete_Impl */\nstatic void OS_TaskDelete_Impl_log_probe(const OS_object_token_t *token,\n                                        OS_impl_task_internal_record_t *impl,\n                                        const char *location,\n                                        int ret_code,\n                                        void *retval)\n{\n    FILE *f = fopen(\"/tmp/logs/507.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log token pointer, object id (as integer), impl pointer, return code and retval pointer. */\n    fprintf(f, \"%s: token=%p object_id=%lu impl_ptr=%p ret=%d retval=%p\\n\",\n            location,\n            (const void *)token,\n            (unsigned long)OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),\n            (void *)impl,\n            ret_code,\n            retval);\n    /* Note that the actual field 'impl->id' is accessed by the implementation; log that fact. */\n    if (impl != NULL)\n    {\n        fprintf(f, \"%s: NOTE: implementation record is non-NULL; impl->id will be accessed (value not printed for portability)\\n\",\n                location);\n    }\n\n    fclose(f);\n}\n\nint32 OS_TaskDelete_Impl(const OS_object_token_t *token)\n{\n    OS_impl_task_internal_record_t *impl;\n    void *                          retval;\n    int                             ret;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_task_table, *token);\n\n    /* Probe after obtaining the implementation record */\n    OS_TaskDelete_Impl_log_probe(token, impl, \"after_get_impl\", -1, NULL);\n\n    /*\n    ** Try to delete the task\n    ** If this fails, not much recourse - the only potential cause of failure\n    ** to cancel here is that the thread ID is invalid because it already exited itself,\n    ** and if that is true there is nothing wrong - everything is OK to continue normally.\n    */\n    /* Probe immediately before calling pthread_cancel (impl->id will be accessed) */\n    OS_TaskDelete_Impl_log_probe(token, impl, \"before_pthread_cancel (about to access impl->id)\", -1, NULL);\n\n    ret = pthread_cancel(impl->id);\n\n    /* Probe after pthread_cancel returns */\n    OS_TaskDelete_Impl_log_probe(token, impl, \"after_pthread_cancel\", ret, NULL);\n\n    if (ret != 0)\n    {\n        OS_DEBUG(\"pthread_cancel: Failed on Task ID = %lu, err = %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n\n        /* fall through (will still return OS_SUCCESS) */\n    }\n    else\n    {\n        /*\n         * Note that \"pthread_cancel\" is a request - and successful return above\n         * only means that the cancellation request is pending.\n         *\n         * pthread_join() will wait until the thread has actually exited.\n         *\n         * This is important for CFE, as task deletion often occurs in\n         * conjunction with an application reload - which means the next\n         * call is likely to be OS_ModuleUnload().  So is critical that all\n         * tasks potentially executing code within that module have actually\n         * been stopped - not just pending cancellation.\n         */\n\n        /* Probe immediately before pthread_join */\n        OS_TaskDelete_Impl_log_probe(token, impl, \"before_pthread_join (about to access impl->id)\", -1, NULL);\n\n        ret = pthread_join(impl->id, &retval);\n\n        /* Probe after pthread_join returns, include retval pointer for inspection */\n        OS_TaskDelete_Impl_log_probe(token, impl, \"after_pthread_join\", ret, retval);\n\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_join: Failed on Task ID = %lu, err = %s\\n\",\n                     OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(ret));\n        }\n    }\n    return OS_SUCCESS;\n}\n"
}