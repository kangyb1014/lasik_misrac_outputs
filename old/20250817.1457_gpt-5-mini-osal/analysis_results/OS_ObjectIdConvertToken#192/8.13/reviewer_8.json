{
  "user_message": "An agent A claimed that the following OS_ObjectIdConvertToken code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdConvertToken.\n```c\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local parameter 'token' (type OS_object_token_t * ) is not const-qualified yet it is only read in OS_ObjectIdConvertToken and is passed to OS_WaitForStateChange. If OS_WaitForStateChange does not modify the object pointed to, then both the parameter of OS_ObjectIdConvertToken and the parameter type of OS_WaitForStateChange should be 'const OS_object_token_t *'. As written (passing a non-const pointer), this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_LogTokenState(const char *stage,\n                             void *token_ptr,\n                             void *obj_ptr,\n                             unsigned long long attempts,\n                             unsigned long long lock_mode_val,\n                             unsigned long long obj_active_id_val,\n                             unsigned long long obj_refcount_val,\n                             unsigned long long expected_id_val,\n                             int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1539.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"STAGE: %s\\n\", stage);\n    fprintf(f, \"  token: %p\\n\", token_ptr);\n    fprintf(f, \"  obj: %p\\n\", obj_ptr);\n    fprintf(f, \"  attempts: %llu\\n\", attempts);\n    fprintf(f, \"  token->lock_mode (as int): %llu\\n\", lock_mode_val);\n    fprintf(f, \"  obj->active_id (as int): %llu\\n\", obj_active_id_val);\n    fprintf(f, \"  obj->refcount: %llu\\n\", obj_refcount_val);\n    fprintf(f, \"  expected_id (as int): %llu\\n\", expected_id_val);\n    fprintf(f, \"  return_code (snapshot): %d\\n\", return_code);\n    fprintf(f, \"----------------------------------------\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /* Log initial state after obtaining obj and expected_id */\n    OS_LogTokenState(\"entry_after_token_resolve\",\n                     (void *)token,\n                     (void *)obj,\n                     (unsigned long long)attempts,\n                     (unsigned long long)token->lock_mode,\n                     (unsigned long long)(obj ? obj->active_id : 0ULL),\n                     (unsigned long long)(obj ? obj->refcount : 0ULL),\n                     (unsigned long long)expected_id,\n                     (int)return_code);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        OS_LogTokenState(\"invalid_expected_id\",\n                         (void *)token,\n                         (void *)obj,\n                         (unsigned long long)attempts,\n                         (unsigned long long)token->lock_mode,\n                         (unsigned long long)(obj ? obj->active_id : 0ULL),\n                         (unsigned long long)(obj ? obj->refcount : 0ULL),\n                         (unsigned long long)expected_id,\n                         (int)OS_ERR_INCORRECT_OBJ_STATE);\n\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n\n        OS_LogTokenState(\"lock_mode_reserved_set_expected\",\n                         (void *)token,\n                         (void *)obj,\n                         (unsigned long long)attempts,\n                         (unsigned long long)token->lock_mode,\n                         (unsigned long long)(obj ? obj->active_id : 0ULL),\n                         (unsigned long long)(obj ? obj->refcount : 0ULL),\n                         (unsigned long long)expected_id,\n                         (int)return_code);\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            OS_LogTokenState(\"id_match_enter\",\n                             (void *)token,\n                             (void *)obj,\n                             (unsigned long long)attempts,\n                             (unsigned long long)token->lock_mode,\n                             (unsigned long long)obj->active_id,\n                             (unsigned long long)obj->refcount,\n                             (unsigned long long)expected_id,\n                             (int)return_code);\n\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n\n                    OS_LogTokenState(\"exclusive_overwrite_to_reserved\",\n                                     (void *)token,\n                                     (void *)obj,\n                                     (unsigned long long)attempts,\n                                     (unsigned long long)token->lock_mode,\n                                     (unsigned long long)obj->active_id,\n                                     (unsigned long long)obj->refcount,\n                                     (unsigned long long)expected_id,\n                                     (int)return_code);\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n\n                    OS_LogTokenState(\"exclusive_refcount_zero_success\",\n                                     (void *)token,\n                                     (void *)obj,\n                                     (unsigned long long)attempts,\n                                     (unsigned long long)token->lock_mode,\n                                     (unsigned long long)obj->active_id,\n                                     (unsigned long long)obj->refcount,\n                                     (unsigned long long)expected_id,\n                                     (int)return_code);\n\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n\n                OS_LogTokenState(\"nonexclusive_success\",\n                                 (void *)token,\n                                 (void *)obj,\n                                 (unsigned long long)attempts,\n                                 (unsigned long long)token->lock_mode,\n                                 (unsigned long long)obj->active_id,\n                                 (unsigned long long)obj->refcount,\n                                 (unsigned long long)expected_id,\n                                 (int)return_code);\n\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n\n            OS_LogTokenState(\"invalid_id_fail\",\n                             (void *)token,\n                             (void *)obj,\n                             (unsigned long long)attempts,\n                             (unsigned long long)token->lock_mode,\n                             (unsigned long long)obj->active_id,\n                             (unsigned long long)obj->refcount,\n                             (unsigned long long)expected_id,\n                             (int)return_code);\n\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n\n            OS_LogTokenState(\"attempts_exhausted\",\n                             (void *)token,\n                             (void *)obj,\n                             (unsigned long long)attempts,\n                             (unsigned long long)token->lock_mode,\n                             (unsigned long long)obj->active_id,\n                             (unsigned long long)obj->refcount,\n                             (unsigned long long)expected_id,\n                             (int)return_code);\n\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_LogTokenState(\"before_wait_for_state_change\",\n                         (void *)token,\n                         (void *)obj,\n                         (unsigned long long)attempts,\n                         (unsigned long long)token->lock_mode,\n                         (unsigned long long)obj->active_id,\n                         (unsigned long long)obj->refcount,\n                         (unsigned long long)expected_id,\n                         (int)return_code);\n\n        OS_WaitForStateChange(token, attempts);\n\n        OS_LogTokenState(\"after_wait_for_state_change\",\n                         (void *)token,\n                         (void *)obj,\n                         (unsigned long long)attempts,\n                         (unsigned long long)token->lock_mode,\n                         (unsigned long long)obj->active_id,\n                         (unsigned long long)obj->refcount,\n                         (unsigned long long)expected_id,\n                         (int)return_code);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            OS_LogTokenState(\"success_increment_refcount\",\n                             (void *)token,\n                             (void *)obj,\n                             (unsigned long long)attempts,\n                             (unsigned long long)token->lock_mode,\n                             (unsigned long long)obj->active_id,\n                             (unsigned long long)obj->refcount,\n                             (unsigned long long)expected_id,\n                             (int)return_code);\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_LogTokenState(\"before_unlock_global\",\n                                 (void *)token,\n                                 (void *)obj,\n                                 (unsigned long long)attempts,\n                                 (unsigned long long)token->lock_mode,\n                                 (unsigned long long)obj->active_id,\n                                 (unsigned long long)obj->refcount,\n                                 (unsigned long long)expected_id,\n                                 (int)return_code);\n\n                OS_Unlock_Global(token);\n\n                OS_LogTokenState(\"after_unlock_global\",\n                                 (void *)token,\n                                 (void *)obj,\n                                 (unsigned long long)attempts,\n                                 (unsigned long long)token->lock_mode,\n                                 (unsigned long long)obj->active_id,\n                                 (unsigned long long)obj->refcount,\n                                 (unsigned long long)expected_id,\n                                 (int)return_code);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n\n            OS_LogTokenState(\"restore_active_id_on_failure\",\n                             (void *)token,\n                             (void *)obj,\n                             (unsigned long long)attempts,\n                             (unsigned long long)token->lock_mode,\n                             (unsigned long long)obj->active_id,\n                             (unsigned long long)obj->refcount,\n                             (unsigned long long)expected_id,\n                             (int)return_code);\n        }\n    }\n\n    OS_LogTokenState(\"exit\",\n                     (void *)token,\n                     (void *)obj,\n                     (unsigned long long)attempts,\n                     (unsigned long long)token->lock_mode,\n                     (unsigned long long)(obj ? obj->active_id : 0ULL),\n                     (unsigned long long)(obj ? obj->refcount : 0ULL),\n                     (unsigned long long)expected_id,\n                     (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdConvertToken. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The function OS_ObjectIdConvertToken itself never writes through the token pointer \u2014 it only reads token fields (token->lock_mode) and calls helper functions with token. Under MISRA C 2023 Rule 8.13 a pointer parameter should be const-qualified when it is only used for reading. So if all of the callees (OS_WaitForStateChange, OS_Unlock_Global, OS_ObjectIdGlobalFromToken, OS_ObjectIdFromToken, etc.) accept a pointer-to-const (and do not modify the pointed object), then the parameter should indeed be declared const OS_object_token_t * and the current non-const declaration would be a violation of 8.13.\n\nHowever, this cannot be determined from the single function body alone \u2014 if any of those called functions are declared to take a non-const OS_object_token_t * (or if any of them actually modify the object), then making the parameter const here would be impossible without changing those other APIs. In that case the non-const parameter is justified and there is no violation.\n\nConclusion: the agent\u2019s report is incomplete. The claim may be correct (the function appears to only read the token), but you need the prototypes/semantics of the callees to confirm whether making the pointer const is possible. Without that information the report cannot be conclusively proven, so treat the reported violation as unconfirmed."
}