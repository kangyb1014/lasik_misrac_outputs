{
  "user_message": "An agent A claimed that the following OS_ObjectIdConvertToken code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdConvertToken.\n```c\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'OS_object_token_t *token' is only read in OS_ObjectIdConvertToken (e.g. token->lock_mode is tested, token passed to OS_ObjectIdGlobalFromToken/OS_ObjectIdFromToken/OS_WaitForStateChange/OS_Unlock_Global) and is not modified locally. According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible \u2014 the signature should be 'const OS_object_token_t *token' and the read-only usage (including the 'if (token->lock_mode != OS_LOCK_MODE_NONE)') should use that const-qualified pointer. Because the parameter is non-const but used only for read access, this violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1539.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    probe_log(\"ENTER: OS_ObjectIdConvertToken token=%p\", (void *)token);\n    if (token != NULL)\n    {\n        probe_log(\"token->lock_mode=%d\", (int)token->lock_mode);\n    }\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    probe_log(\"OS_ObjectIdGlobalFromToken returned obj=%p\", (void *)obj);\n\n    expected_id = OS_ObjectIdFromToken(token);\n    probe_log(\"OS_ObjectIdFromToken returned expected_id=%lu\", (unsigned long)expected_id);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        probe_log(\"EXIT: invalid expected_id=%lu -> OS_ERR_INCORRECT_OBJ_STATE\", (unsigned long)expected_id);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        probe_log(\"token->lock_mode is RESERVED; overriding expected_id (was %lu) to OS_OBJECT_ID_RESERVED\", (unsigned long)expected_id);\n        expected_id = OS_OBJECT_ID_RESERVED;\n        probe_log(\"expected_id now %lu\", (unsigned long)expected_id);\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        probe_log(\"LOOP: attempts=%u obj=%p active_id=%lu expected_id=%lu refcount=%u\",\n                  (unsigned)attempts,\n                  (void *)obj,\n                  (unsigned long)obj->active_id,\n                  (unsigned long)expected_id,\n                  (unsigned)obj->refcount);\n\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            probe_log(\"ID match: obj->active_id == expected_id (%lu)\", (unsigned long)expected_id);\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                probe_log(\"lock_mode is EXCLUSIVE\");\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    probe_log(\"Overwriting expected_id %lu -> OS_OBJECT_ID_RESERVED and setting obj->active_id\", (unsigned long)expected_id);\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                    probe_log(\"obj->active_id now %lu\", (unsigned long)obj->active_id);\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                probe_log(\"Checking refcount=%u\", (unsigned)obj->refcount);\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    probe_log(\"refcount==0 -> success, breaking out (return_code=%d)\", (int)return_code);\n                    break;\n                }\n                else\n                {\n                    probe_log(\"refcount!=0 -> need to wait (refcount=%u)\", (unsigned)obj->refcount);\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                probe_log(\"Non-exclusive lock and ID match -> success (return_code=%d)\", (int)return_code);\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            probe_log(\"ID mismatch and not RESERVED -> fail out (obj->active_id=%lu expected_id=%lu)\",\n                      (unsigned long)obj->active_id,\n                      (unsigned long)expected_id);\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        probe_log(\"Contention detected; incremented attempts -> %u\", (unsigned)attempts);\n        if (attempts >= 5)\n        {\n            probe_log(\"Attempts exceeded threshold -> OS_ERR_OBJECT_IN_USE\");\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        probe_log(\"Calling OS_WaitForStateChange(token=%p, attempts=%u)\", (void *)token, (unsigned)attempts);\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    probe_log(\"POST-LOOP: return_code=%d expected_id=%lu token->lock_mode=%d obj=%p obj->active_id=%lu refcount=%u\",\n              (int)return_code,\n              (unsigned long)expected_id,\n              (int)token->lock_mode,\n              (void *)obj,\n              (unsigned long)obj->active_id,\n              (unsigned)obj->refcount);\n\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n            probe_log(\"Incremented obj->refcount -> %u\", (unsigned)obj->refcount);\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                probe_log(\"Calling OS_Unlock_Global(token=%p) for lock_mode=%d\", (void *)token, (int)token->lock_mode);\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            probe_log(\"Failure path: restoring obj->active_id from token (was %lu)\", (unsigned long)obj->active_id);\n            obj->active_id = OS_ObjectIdFromToken(token);\n            probe_log(\"obj->active_id restored to %lu\", (unsigned long)obj->active_id);\n        }\n    }\n\n    probe_log(\"EXIT: OS_ObjectIdConvertToken return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdConvertToken. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is plausible but not confirmed from the code shown. Inside OS_ObjectIdConvertToken the token object is only read (token->lock_mode and token passed to other functions) and not modified directly, so at this function-local view it could be declared const. However MISRA 8.13 applies to the whole usage: you may only make the parameter pointer-to-const if that is compatible with all uses and callees. In this function token is passed to OS_ObjectIdGlobalFromToken, OS_ObjectIdFromToken, OS_WaitForStateChange and OS_Unlock_Global \u2014 if any of those functions are declared to take a non-const OS_object_token_t * (or if they may modify the token), then the parameter cannot be changed to const without changing those APIs (or using casts, which would defeat the rule). Agent A did not show the prototypes of those callees or the wider API contract, so you cannot conclude a definite MISRA 8.13 violation from the snippet alone. Recommendation: inspect the declarations of the called functions (and any places that take this pointer) \u2014 if they all accept const OS_object_token_t * (or do not modify the object), then change the signature to const OS_object_token_t *token to comply with 8.13; otherwise the current non-const parameter is justified."
}