{
  "user_message": "An agent A claimed that the following OS_ObjectIdConvertToken code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdConvertToken.\n```c\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    break;\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_WaitForStateChange(token, attempts);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter is declared as OS_object_token_t *token (non-const) yet the code only reads from it (e.g. token->lock_mode). The pointer should be to a const-qualified type (const OS_object_token_t *token) when it is not modified. Thus the use of token->lock_mode here represents a violation of MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_LogTokenState(const char *stage,\n                             const void *token_ptr,\n                             const void *obj_ptr,\n                             long return_code,\n                             unsigned long attempts,\n                             unsigned long expected_id_val)\n{\n    FILE *fp = fopen(\"/tmp/logs/1539.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* Try to create the directory and reopen. Ignore errors silently if it fails. */\n        (void)mkdir(\"/tmp/logs\", 0777);\n        fp = fopen(\"/tmp/logs/1539.txt\", \"a\");\n        if (fp == NULL)\n        {\n            return;\n        }\n    }\n\n    /* Write a compact single-line log entry with key pieces of state. */\n    (void)fprintf(fp,\n                  \"stage=%s token=%p obj=%p return=%ld attempts=%lu expected_id=%llu\\n\",\n                  stage,\n                  token_ptr,\n                  obj_ptr,\n                  return_code,\n                  attempts,\n                  (unsigned long long) expected_id_val);\n\n    (void)fflush(fp);\n    (void)fclose(fp);\n}\n\nint32 OS_ObjectIdConvertToken(OS_object_token_t *token)\n{\n    int32               return_code = OS_ERROR;\n    uint32              attempts    = 0;\n    OS_common_record_t *obj;\n    osal_id_t           expected_id;\n\n    /* Log entry state */\n    OS_LogTokenState(\"entry\", token, NULL, (long)return_code, (unsigned long)attempts, 0UL);\n\n    obj         = OS_ObjectIdGlobalFromToken(token);\n    expected_id = OS_ObjectIdFromToken(token);\n\n    /* Log resolved obj and expected_id */\n    OS_LogTokenState(\"after_resolve\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n\n    /*\n     * Upon entry the ID from the token must be valid\n     */\n    if (!OS_ObjectIdIsValid(expected_id))\n    {\n        OS_LogTokenState(\"invalid_id\", token, obj, (long)OS_ERR_INCORRECT_OBJ_STATE, (unsigned long)attempts, (unsigned long)expected_id);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * If lock mode is RESERVED, then the ID in the record should\n     * already be set to OS_OBJECT_ID_RESERVED.  This is for very\n     * specific use cases where a secondary task needs to access an\n     * object during its creation/deletion.\n     *\n     * For all typical modes the ID in the record should be equal\n     * to the token ID.\n     */\n    if (token->lock_mode == OS_LOCK_MODE_RESERVED)\n    {\n        expected_id = OS_OBJECT_ID_RESERVED;\n        OS_LogTokenState(\"reserved_adjust\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n    }\n\n    while (true)\n    {\n        /* Validate the integrity of the ID.  As the \"active_id\" is a single\n         * integer, we can do this check regardless of whether global is locked or not. */\n        if (OS_ObjectIdEqual(obj->active_id, expected_id))\n        {\n            /*\n             * Got an ID match...\n             */\n            OS_LogTokenState(\"id_match\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n\n            if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                /*\n                 * For EXCLUSIVE mode, overwrite the ID to be RESERVED now -- this\n                 * makes any future ID checks or lock attempts in other tasks fail to match.\n                 */\n                if (!OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n                {\n                    expected_id    = OS_OBJECT_ID_RESERVED;\n                    obj->active_id = expected_id;\n                    OS_LogTokenState(\"exclusive_overwrite\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n                }\n\n                /*\n                 * Also confirm that reference count is zero\n                 * If not zero, will need to wait for other tasks to release.\n                 */\n                if (obj->refcount == 0)\n                {\n                    return_code = OS_SUCCESS;\n                    OS_LogTokenState(\"exclusive_refcount_zero_success\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n                    break;\n                }\n                else\n                {\n                    OS_LogTokenState(\"exclusive_refcount_nonzero\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n                }\n            }\n            else\n            {\n                /*\n                 * Nothing else to test for this lock type\n                 */\n                return_code = OS_SUCCESS;\n                OS_LogTokenState(\"nonexclusive_success\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n                break;\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_NONE || !OS_ObjectIdEqual(obj->active_id, OS_OBJECT_ID_RESERVED))\n        {\n            /* Not an ID match and not RESERVED - fail out */\n            return_code = OS_ERR_INVALID_ID;\n            OS_LogTokenState(\"id_mismatch_fail\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n            break;\n        }\n\n        /*\n         * If we get this far, it means there is contention for access to the object.\n         *  a) we want to some type of lock but the ID is currently RESERVED\n         *  b) the refcount is too high - need to wait for release\n         *\n         * In this case we will UNLOCK the global object again so that the holder\n         * can relinquish it.  We'll try again a few times before giving up hope.\n         */\n        ++attempts;\n        OS_LogTokenState(\"contention_attempt\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n\n        if (attempts >= 5)\n        {\n            return_code = OS_ERR_OBJECT_IN_USE;\n            OS_LogTokenState(\"attempts_exhausted\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n            break;\n        }\n\n        /*\n         * Call the impl layer to wait for some sort of change to occur.\n         */\n        OS_LogTokenState(\"wait_before\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n        OS_WaitForStateChange(token, attempts);\n        OS_LogTokenState(\"wait_after\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n    }\n\n    /*\n     * Determine if the global table needs to be unlocked now.\n     *\n     * If lock_mode is OS_LOCK_MODE_NONE, then the table was never locked\n     * to begin with, and therefore never needs to be unlocked.\n     */\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        if (return_code == OS_SUCCESS)\n        {\n            /* always increment the refcount, which means a task is actively\n             * using or modifying this record. */\n            ++obj->refcount;\n            OS_LogTokenState(\"success_increment_refcount\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n\n            /*\n             * On a successful operation, the global is unlocked if it is\n             * a REFCOUNT or EXCLUSIVE lock.  Note for EXCLUSIVE, because the ID\n             * was overwritten to OS_OBJECT_ID_RESERVED, other tasks will not be\n             * able to access the object because the ID will not match, so the\n             * table can be unlocked while the remainder of the create/delete process\n             * continues.\n             *\n             * For OS_LOCK_MODE_GLOBAL the global lock should be maintained and\n             * returned to the caller.\n             */\n            if (token->lock_mode == OS_LOCK_MODE_REFCOUNT || token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n            {\n                OS_LogTokenState(\"unlock_global\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n                OS_Unlock_Global(token);\n            }\n        }\n        else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE && OS_ObjectIdEqual(expected_id, OS_OBJECT_ID_RESERVED))\n        {\n            /*\n             * On failure, if the active_id was overwritten, then set\n             * it back to the original value which is in the token.\n             * (note it had to match initially before overwrite)\n             */\n            obj->active_id = OS_ObjectIdFromToken(token);\n            OS_LogTokenState(\"restore_active_id_on_failure\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n        }\n    }\n\n    OS_LogTokenState(\"exit\", token, obj, (long)return_code, (unsigned long)attempts, (unsigned long)expected_id);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdConvertToken. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim is not definitively correct. MISRA 8.13 encourages declaring a pointer parameter as pointing to const if the function does not modify the pointed-to object, but that only applies \u201cwhen possible\u201d. In this function OS_ObjectIdConvertToken the local code does only read members of *token (no writes). However token is passed to other routines (OS_ObjectIdGlobalFromToken, OS_ObjectIdFromToken, OS_WaitForStateChange, OS_Unlock_Global). If any of those callees have prototypes that accept a non-const OS_object_token_t * (or if they modify the token), making the parameter const would be incompatible and therefore not \u201cpossible\u201d. Without inspecting the prototypes/implementations of those functions you cannot conclude a MISRA violation. If those callees all accept const pointers and do not modify the token, then the parameter could (and per MISRA 8.13 should) be changed to const OS_object_token_t *token \u2014 otherwise leaving it non-const is justified. Therefore the report as given is not proven correct."
}