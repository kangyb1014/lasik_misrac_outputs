{
  "user_message": "An agent A claimed that the following OS_TimerGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimerGetInfo.\n```c\nint32 OS_TimerGetInfo(osal_id_t timer_id, OS_timer_prop_t *timer_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timer_prop, 0, sizeof(OS_timer_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TIMECB, timer_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timecb_table, token);\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timecb->timebase_token);\n\n        strncpy(timer_prop->name, record->name_entry, sizeof(timer_prop->name) - 1);\n        timer_prop->creator       = record->creator;\n        timer_prop->interval_time = (uint32)timecb->interval_time;\n        timer_prop->accuracy      = timebase->accuracy_usec;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'timebase' is declared as a non-const OS_timebase_internal_record_t * but is only used for read-only access (timebase->accuracy_usec). The assignment timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timecb->timebase_token); therefore could use a const-qualified pointer (const OS_timebase_internal_record_t *timebase). Declaring it non-const when it could be const violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TimerGetInfo_Log(const char *label, const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2203.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_TimerGetInfo] %s: \", label);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_TimerGetInfo(osal_id_t timer_id, OS_timer_prop_t *timer_prop)\n{\n    OS_common_record_t *           record;\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Log entry and parameters */\n    OS_TimerGetInfo_Log(\"ENTRY\", \"timer_id=%llu timer_prop=%p\",\n                        (unsigned long long)(uintptr_t)timer_id, (void *)timer_prop);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_prop);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    OS_TimerGetInfo_Log(\"CONTEXT\", \"objtype=%d\", (int)objtype);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        OS_TimerGetInfo_Log(\"RETURN\", \"OS_ERR_INCORRECT_OBJ_STATE due to objtype == OS_TIMEBASE\");\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    memset(timer_prop, 0, sizeof(OS_timer_prop_t));\n    OS_TimerGetInfo_Log(\"STATE\", \"cleared timer_prop at %p\", (void *)timer_prop);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TIMECB, timer_id, &token);\n    /*\n     * token is an aggregate type in some builds. Print its address instead\n     * of attempting to cast the aggregate to an integer/pointer type.\n     */\n    OS_TimerGetInfo_Log(\"LOOKUP\", \"OS_ObjectIdGetById returned %d, token=%p\",\n                        (int)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record   = OS_OBJECT_TABLE_GET(OS_global_timecb_table, token);\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timecb->timebase_token);\n\n        /* Log the retrieved pointers and key fields used below. */\n        OS_TimerGetInfo_Log(\"RECORD\", \"record=%p name_entry=%.32s creator=%u\",\n                            (void *)record,\n                            (record && record->name_entry) ? record->name_entry : \"(null)\",\n                            (unsigned) (record ? record->creator : 0U));\n\n        /*\n         * timecb->timebase_token may be an aggregate type. Print its address\n         * (or NULL) rather than trying to coerce it into an integer/pointer.\n         */\n        OS_TimerGetInfo_Log(\"TIMECB\", \"timecb=%p timebase_token=%p interval_time=%llu\",\n                            (void *)timecb,\n                            (void *)(timecb ? &timecb->timebase_token : NULL),\n                            (unsigned long long)(timecb ? (unsigned long long)timecb->interval_time : 0ULL));\n\n        OS_TimerGetInfo_Log(\"TIMEBASE\", \"timebase=%p accuracy_usec=%llu\",\n                            (void *)timebase,\n                            (unsigned long long)(timebase ? (unsigned long long)timebase->accuracy_usec : 0ULL));\n\n        strncpy(timer_prop->name, record->name_entry, sizeof(timer_prop->name) - 1);\n        timer_prop->creator       = record->creator;\n        timer_prop->interval_time = (uint32)timecb->interval_time;\n        timer_prop->accuracy      = timebase->accuracy_usec;\n\n        OS_ObjectIdRelease(&token);\n        OS_TimerGetInfo_Log(\"EXIT\", \"success, timer_prop populated for timer_id=%llu\",\n                            (unsigned long long)(uintptr_t)timer_id);\n    }\n    else\n    {\n        OS_TimerGetInfo_Log(\"EXIT\", \"failed to find timer, return_code=%d\", (int)return_code);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimerGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In OS_TimerGetInfo the variable timebase is only used for read-only access (timebase->accuracy_usec and logged reads); therefore it could and should be declared as a pointer to const (const OS_timebase_internal_record_t *timebase) per MISRA C 2023 Rule 8.13. Assigning the result of OS_OBJECT_TABLE_GET (which likely yields a non-const pointer) to a pointer-to-const is allowed in C, so making timebase const is feasible here. Note also that record and timecb are similarly only read and could be const as well. The only reason not to qualify these pointers as const would be if other code (or macros/types used) require modification through them; that is not the case inside this function. Hence the reported violation is valid."
}