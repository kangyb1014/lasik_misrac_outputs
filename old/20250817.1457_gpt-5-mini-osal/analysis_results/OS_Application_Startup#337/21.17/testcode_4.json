{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) call can read beyond object bounds if either pointer is NULL or not NUL-terminated. For example, if a caller passed TypeName == NULL to the registration API (or the stub entry was allocated/reused without ContentTypeStr being set) then strcmp will dereference a NULL pointer. Or if one of the pointers points to a non-NUL-terminated buffer, strcmp will overrun the buffer. In these cases the use of strcmp can access memory beyond the referenced object, violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_Application_Startup code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2703.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_Application_Startup as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_Application_Startup:\n```c\nvoid OS_Application_Startup(void)\n{\n    UtTest_EarlyInit();\n    UT_BSP_Setup();\n\n    /*\n     * Wrap the UtTest_Setup() function in a UT segment called \"SETUP\"\n     * This allows any assert calls to be used and recorded during setup\n     */\n    UtAssert_BeginTest(\"SETUP\");\n    UtTest_Setup();\n    UtAssert_EndTest();\n}\n```\n</target_code>\nPlease provide the modified OS_Application_Startup code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n/*\n * Probe and logging helpers to assist in reproducing the strcmp-related\n * violation scenario. These helpers do not change the original logic of\n * OS_Application_Startup; they only record control flow and state to\n * /tmp/logs/2703.txt. Callers elsewhere in the test harness can call\n * LogProbe_StrcmpParams() with known buffer sizes to safely record the\n * presence/absence of NUL terminators and pointer values.\n */\n\n/* Append formatted text to the log file. Safe no-op if file cannot be opened. */\nstatic void WriteLog(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/2703.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\n\n/* Record basic information about a string pointer and whether it contains a NUL\n * byte within the provided max_len. The function will not read beyond max_len\n * bytes. The caller must provide the actual object size (or a safe upper bound)\n * to avoid reading beyond object bounds. This design avoids introducing new\n * out-of-bounds accesses in the probe itself.\n */\nvoid LogProbe_StringInfo(const char *label, const char *s, size_t max_len)\n{\n    char buf[256];\n    if (s == NULL)\n    {\n        snprintf(buf, sizeof(buf), \"%s: pointer=NULL\", label);\n        WriteLog(buf);\n        return;\n    }\n\n    /* Limit how many bytes to inspect to avoid huge logs */\n    size_t inspect = (max_len < 200U) ? max_len : 200U;\n    size_t i;\n    int nul_found = 0;\n\n    for (i = 0U; i < inspect; ++i)\n    {\n        if (s[i] == '\\0')\n        {\n            nul_found = 1;\n            break;\n        }\n    }\n\n    if (nul_found)\n    {\n        snprintf(buf, sizeof(buf), \"%s: ptr=%p, NUL at offset=%zu, inspected=%zu\",\n                 label, (const void *)s, i, inspect);\n    }\n    else\n    {\n        snprintf(buf, sizeof(buf), \"%s: ptr=%p, no NUL within first %zu bytes\",\n                 label, (const void *)s, inspect);\n    }\n    WriteLog(buf);\n}\n\n/* Convenience probe for the strcmp scenario. The caller MUST provide the\n * maximum valid lengths of both strings (object sizes). This function will\n * log pointer values and whether each string is NUL-terminated within the\n * provided bounds. It intentionally does NOT call strcmp to avoid causing the\n * very out-of-bounds read that is under investigation.\n */\nvoid LogProbe_StrcmpParams(const char *typeName, size_t typeNameSize,\n                           const char *contentTypeStr, size_t contentTypeStrSize)\n{\n    char buf[256];\n    snprintf(buf, sizeof(buf), \"[Probe] LogProbe_StrcmpParams called: typeName=%p, typeNameSize=%zu, contentTypeStr=%p, contentTypeStrSize=%zu\",\n             (const void *)typeName, typeNameSize, (const void *)contentTypeStr, contentTypeStrSize);\n    WriteLog(buf);\n\n    LogProbe_StringInfo(\"TypeName\", typeName, typeNameSize);\n    LogProbe_StringInfo(\"ContentTypeStr\", contentTypeStr, contentTypeStrSize);\n}\n\n/* The original OS_Application_Startup function with minimal, safe probes\n * inserted to capture control flow and the availability of the probe APIs.\n * The original call sequence and behavior is preserved.\n */\nvoid OS_Application_Startup(void)\n{\n    WriteLog(\"OS_Application_Startup: entry\");\n\n    /* Record before early init */\n    WriteLog(\"OS_Application_Startup: calling UtTest_EarlyInit()\");\n    UtTest_EarlyInit();\n    WriteLog(\"OS_Application_Startup: returned from UtTest_EarlyInit()\");\n\n    /* Record before BSP setup */\n    WriteLog(\"OS_Application_Startup: calling UT_BSP_Setup()\");\n    UT_BSP_Setup();\n    WriteLog(\"OS_Application_Startup: returned from UT_BSP_Setup()\");\n\n    /* Announce that probe helpers are available to the test harness */\n    WriteLog(\"OS_Application_Startup: probe helpers available: LogProbe_StrcmpParams, LogProbe_StringInfo\");\n\n    /*\n     * Wrap the UtTest_Setup() function in a UT segment called \"SETUP\"\n     * This allows any assert calls to be used and recorded during setup\n     */\n    UtAssert_BeginTest(\"SETUP\");\n    WriteLog(\"OS_Application_Startup: inside SETUP, calling UtTest_Setup()\");\n\n    UtTest_Setup();\n\n    WriteLog(\"OS_Application_Startup: returned from UtTest_Setup()\");\n    UtAssert_EndTest();\n\n    WriteLog(\"OS_Application_Startup: exit\");\n}\n"
}