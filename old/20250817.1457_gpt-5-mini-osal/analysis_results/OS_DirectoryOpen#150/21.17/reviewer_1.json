{
  "user_message": "An agent A claimed that the following OS_DirectoryOpen code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_DirectoryOpen.\n```c\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential violation: OS_DirectoryOpen passes local_path to OS_DirOpen_Impl without a visible, verifiable contract here that local_path is a NUL-terminated string and that there is spare space if the callee will append to it. If OS_TranslatePath did not guarantee a terminating '\\0' within local_path (or if OS_DirOpen_Impl calls string.h functions that append data but assumes extra space), calls inside OS_DirOpen_Impl to strlen/strcpy/strcat/strncat/etc could read or write beyond the bounds of local_path, violating MISRA C 2023 Rule 21.17. If, however, OS_TranslatePath and the implementation contract for OS_DirOpen_Impl guarantee that local_path is NUL-terminated and sized appropriately for any further string operations, then no violation occurs. Given only the shown code, this potential out\u2011of\u2011bounds access cannot be ruled out.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic FILE *log_file_open(void)\n{\n    /* Try to create the directory if it does not exist. Ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    return fopen(\"/tmp/logs/1207.txt\", \"a\");\n}\nstatic void log_msg(const char *fmt, ...)\n{\n    FILE *f = log_file_open();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic size_t safe_strnlen(const char *s, size_t bufsize)\n{\n    size_t i;\n    for (i = 0; i < bufsize; ++i)\n    {\n        if (s[i] == '\\0')\n            break;\n    }\n    return i;\n}\nstatic void log_buf_state(const char *name, const char *buf, size_t bufsize)\n{\n    FILE *f = log_file_open();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    size_t len = safe_strnlen(buf, bufsize);\n    if (len < bufsize)\n    {\n        /* NUL found within buffer bounds. Print as string (safe). */\n        fprintf(f, \"%s: NUL-terminated, length=%zu, content=\\\"%s\\\"\\n\", name, len, buf);\n    }\n    else\n    {\n        /* No NUL found within bounds. Print an informational message and hex of first bytes. */\n        fprintf(f, \"%s: NO NUL within first %zu bytes. First %zu bytes (hex):\", name, bufsize, bufsize);\n        for (size_t i = 0; i < bufsize; ++i)\n        {\n            fprintf(f, \" %02X\", (unsigned char)buf[i]);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fclose(f);\n}\n\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Log entry and parameters (pointers only to avoid dereferencing invalid addresses). */\n    log_msg(\"OS_DirectoryOpen: entry dir_id=%p, path=%p\", (void *)dir_id, (const void *)path);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n\n    /* Log the result of OS_TranslatePath and the safe state of local_path. */\n    log_msg(\"OS_DirectoryOpen: OS_TranslatePath returned %d\", return_code);\n    log_buf_state(\"local_path\", local_path, (size_t)OS_MAX_LOCAL_PATH_LEN);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        log_msg(\"OS_DirectoryOpen: OS_ObjectIdAllocateNew returned %d\", return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Log state before calling OS-specific implementation. */\n            log_msg(\"OS_DirectoryOpen: token address=%p, dir pointer=%p\", (void *)&token, (void *)dir);\n            /* Re-evaluate local_path length safely for logging before the impl call. */\n            {\n                size_t len = safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN);\n                if (len < (size_t)OS_MAX_LOCAL_PATH_LEN)\n                {\n                    log_msg(\"OS_DirectoryOpen: calling OS_DirOpen_Impl with local_path (len=%zu): %s\", len, local_path);\n                }\n                else\n                {\n                    log_msg(\"OS_DirectoryOpen: calling OS_DirOpen_Impl but local_path has no NUL within %d bytes\", OS_MAX_LOCAL_PATH_LEN);\n                }\n            }\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Log the result of the OS-specific implementation. */\n            log_msg(\"OS_DirectoryOpen: OS_DirOpen_Impl returned %d\", return_code);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n            log_msg(\"OS_DirectoryOpen: OS_ObjectIdFinalizeNew returned %d\", return_code);\n        }\n    }\n\n    log_msg(\"OS_DirectoryOpen: exit with return_code=%d\", return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_DirectoryOpen. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct as a definite MISRA 21.17 violation. Rule 21.17 concerns actual uses of the <string.h> functions that can read/write beyond the bounds of the objects referenced by their pointer parameters. In the snippet shown OS_DirectoryOpen itself does not call any <string.h> functions; it merely calls OS_TranslatePath(local_path) and then passes local_path to OS_DirOpen_Impl. Whether a 21.17 violation exists depends on the contracts/implementations of those two functions: if OS_TranslatePath guarantees that local_path is NUL-terminated and sized appropriately for any operations performed by OS_DirOpen_Impl, then no violation occurs. Conversely, if OS_DirOpen_Impl or a deeper callee uses string.h functions assuming extra space or a NUL terminator that OS_TranslatePath does not provide, that deeper code could violate 21.17 \u2014 but that is a potential violation in the implementation of those functions, not a proven violation of the OS_DirectoryOpen body shown. Given only the code provided, the claim cannot be established as a true violation. Recommended action: document/verify the postcondition of OS_TranslatePath (NUL-termination and maximum written length) and the precondition expected by OS_DirOpen_Impl (max buffer size / whether it may append). If such contracts are not present, either add them or make copies and/or bounds-checked operations in OS_DirectoryOpen (or change the API) so callers cannot rely on implicit assumptions."
}