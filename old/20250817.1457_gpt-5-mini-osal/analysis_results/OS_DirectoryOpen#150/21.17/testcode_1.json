{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: OS_DirectoryOpen passes local_path to OS_DirOpen_Impl without a visible, verifiable contract here that local_path is a NUL-terminated string and that there is spare space if the callee will append to it. If OS_TranslatePath did not guarantee a terminating '\\0' within local_path (or if OS_DirOpen_Impl calls string.h functions that append data but assumes extra space), calls inside OS_DirOpen_Impl to strlen/strcpy/strcat/strncat/etc could read or write beyond the bounds of local_path, violating MISRA C 2023 Rule 21.17. If, however, OS_TranslatePath and the implementation contract for OS_DirOpen_Impl guarantee that local_path is NUL-terminated and sized appropriately for any further string operations, then no violation occurs. Given only the shown code, this potential out\u2011of\u2011bounds access cannot be ruled out.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryOpen code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1207.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryOpen as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryOpen:\n```c\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryOpen code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <stddef.h>\n\n/* Probe helpers for logging --- do not change program logic. */\nstatic FILE *log_file_open(void)\n{\n    /* Try to create the directory if it does not exist. Ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    return fopen(\"/tmp/logs/1207.txt\", \"a\");\n}\n\nstatic void log_msg(const char *fmt, ...)\n{\n    FILE *f = log_file_open();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Safe strnlen that will not read past bufsize. */\nstatic size_t safe_strnlen(const char *s, size_t bufsize)\n{\n    size_t i;\n    for (i = 0; i < bufsize; ++i)\n    {\n        if (s[i] == '\\0')\n            break;\n    }\n    return i;\n}\n\n/* Log the state of a character buffer safely without reading beyond its bounds. */\nstatic void log_buf_state(const char *name, const char *buf, size_t bufsize)\n{\n    FILE *f = log_file_open();\n    if (f == NULL)\n    {\n        return;\n    }\n\n    size_t len = safe_strnlen(buf, bufsize);\n    if (len < bufsize)\n    {\n        /* NUL found within buffer bounds. Print as string (safe). */\n        fprintf(f, \"%s: NUL-terminated, length=%zu, content=\\\"%s\\\"\\n\", name, len, buf);\n    }\n    else\n    {\n        /* No NUL found within bounds. Print an informational message and hex of first bytes. */\n        fprintf(f, \"%s: NO NUL within first %zu bytes. First %zu bytes (hex):\", name, bufsize, bufsize);\n        for (size_t i = 0; i < bufsize; ++i)\n        {\n            fprintf(f, \" %02X\", (unsigned char)buf[i]);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fclose(f);\n}\n\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Log entry and parameters (pointers only to avoid dereferencing invalid addresses). */\n    log_msg(\"OS_DirectoryOpen: entry dir_id=%p, path=%p\", (void *)dir_id, (const void *)path);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n\n    /* Log the result of OS_TranslatePath and the safe state of local_path. */\n    log_msg(\"OS_DirectoryOpen: OS_TranslatePath returned %d\", return_code);\n    log_buf_state(\"local_path\", local_path, (size_t)OS_MAX_LOCAL_PATH_LEN);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        log_msg(\"OS_DirectoryOpen: OS_ObjectIdAllocateNew returned %d\", return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Log state before calling OS-specific implementation. */\n            log_msg(\"OS_DirectoryOpen: token address=%p, dir pointer=%p\", (void *)&token, (void *)dir);\n            /* Re-evaluate local_path length safely for logging before the impl call. */\n            {\n                size_t len = safe_strnlen(local_path, (size_t)OS_MAX_LOCAL_PATH_LEN);\n                if (len < (size_t)OS_MAX_LOCAL_PATH_LEN)\n                {\n                    log_msg(\"OS_DirectoryOpen: calling OS_DirOpen_Impl with local_path (len=%zu): %s\", len, local_path);\n                }\n                else\n                {\n                    log_msg(\"OS_DirectoryOpen: calling OS_DirOpen_Impl but local_path has no NUL within %d bytes\", OS_MAX_LOCAL_PATH_LEN);\n                }\n            }\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Log the result of the OS-specific implementation. */\n            log_msg(\"OS_DirectoryOpen: OS_DirOpen_Impl returned %d\", return_code);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n            log_msg(\"OS_DirectoryOpen: OS_ObjectIdFinalizeNew returned %d\", return_code);\n        }\n    }\n\n    log_msg(\"OS_DirectoryOpen: exit with return_code=%d\", return_code);\n    return return_code;\n}\n"
}