{
  "user_message": "An agent A claimed that the following OS_DirectoryOpen code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_DirectoryOpen.\n```c\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        if (return_code == OS_SUCCESS)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n\n            /* Reset the table entry and save the name */\n            OS_OBJECT_INIT(token, dir, dir_name, path);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts away the const qualifier when passing 'name' (declared as const char *) to OS_ObjectIdFindNextMatch: (void *)name. This discards const and supplies a non-const void * where a const-qualified pointer should be used (the callee should take a const void * if it does not modify the data). Casting away const in this way violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef unsigned long osal_id_t;\ntypedef struct\n{\n    void *opaque;\n} OS_object_token_t;\nstruct OS_dir_internal_record\n{\n    /* opaque */\n    int dummy;\n};\ntypedef struct OS_dir_internal_record\n{\n    /* opaque */\n    int dummy;\n} OS_dir_internal_record_t;\nint32 OS_TranslatePath(const char *path, char *local_path);\nint32 OS_ObjectIdAllocateNew(int type, void *a, OS_object_token_t *token);\nOS_dir_internal_record_t *OS_OBJECT_TABLE_GET(void *table, OS_object_token_t token);\nvoid OS_OBJECT_INIT(OS_object_token_t token, OS_dir_internal_record_t *dir, const char *dir_name, const char *path);\nint32 OS_DirOpen_Impl(OS_object_token_t *tokenptr, const char *local_path);\nint32 OS_ObjectIdFinalizeNew(int32 prev_return, OS_object_token_t *tokenptr, osal_id_t *dir_id);\nvoid OS_CHECK_POINTER(void *ptr);\nstatic void OS_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1203.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_DirectoryOpen(osal_id_t *dir_id, const char *path)\n{\n    char                      local_path[OS_MAX_LOCAL_PATH_LEN];\n    OS_object_token_t         token;\n    OS_dir_internal_record_t *dir;\n    int32                     return_code;\n\n    /* Log entry and parameter state */\n    OS_LogProbe(\"OS_DirectoryOpen ENTRY: dir_id=%p, path=%p, path_str='%s'\",\n                (const void *)dir_id,\n                (const void *)path,\n                (path != NULL) ? path : \"(null)\");\n\n    /* Check parameters */\n    OS_CHECK_POINTER(dir_id);\n\n    return_code = OS_TranslatePath(path, local_path);\n    OS_LogProbe(\"OS_TranslatePath returned %ld, local_path='%s'\",\n                (long)return_code,\n                local_path);\n\n    if (return_code == 0)\n    {\n        /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n        return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &token);\n        OS_LogProbe(\"OS_ObjectIdAllocateNew returned %ld, token=%p\",\n                    (long)return_code,\n                    (const void *)&token);\n\n        if (return_code == 0)\n        {\n            dir = OS_OBJECT_TABLE_GET(OS_dir_table, token);\n            OS_LogProbe(\"OS_OBJECT_TABLE_GET returned dir=%p for token=%p\",\n                        (const void *)dir,\n                        (const void *)&token);\n\n            /* Reset the table entry and save the name */\n            OS_LogProbe(\"Before OS_OBJECT_INIT: token=%p, dir=%p, name_from_path='%s'\",\n                        (const void *)&token,\n                        (const void *)dir,\n                        (path != NULL) ? path : \"(null)\");\n\n            OS_OBJECT_INIT(token, dir, \"dir_name\", path);\n\n            OS_LogProbe(\"After OS_OBJECT_INIT: token=%p, dir=%p\",\n                        (const void *)&token,\n                        (const void *)dir);\n\n            /* Now call the OS-specific implementation.  */\n            return_code = OS_DirOpen_Impl(&token, local_path);\n            OS_LogProbe(\"OS_DirOpen_Impl returned %ld for token=%p\",\n                        (long)return_code,\n                        (const void *)&token);\n\n            /* Check result, finalize record, and unlock global table. */\n            return_code = OS_ObjectIdFinalizeNew(return_code, &token, dir_id);\n\n            if (dir_id != NULL)\n            {\n                OS_LogProbe(\"OS_ObjectIdFinalizeNew returned %ld, dir_id=%p, *dir_id=%lu\",\n                            (long)return_code,\n                            (const void *)dir_id,\n                            (unsigned long)(*dir_id));\n            }\n            else\n            {\n                OS_LogProbe(\"OS_ObjectIdFinalizeNew returned %ld, dir_id=NULL\",\n                            (long)return_code);\n            }\n        }\n    }\n\n    OS_LogProbe(\"OS_DirectoryOpen EXIT: return_code=%ld\",\n                (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The supplied OS_DirectoryOpen code does not perform any cast that discards the const qualifier and there is no call to OS_ObjectIdFindNextMatch in the target code. In the additional test code the OS_OBJECT_INIT prototype is declared to take const char * parameters and the only casts shown (for logging) are to const void *, not to plain void *. Therefore there is no evidence in the provided code that a const char * is being converted to a non-const pointer (e.g. to void *), which is the concrete situation that would violate MISRA C 2023 Rule 8.13. The agent's scenario names a different function and a (void *) cast that does not appear in the target code, so the claim is not supported by the supplied code. If a cast-away-of-const did exist, the correct remedy would be to change the callee to accept a const-qualified pointer (or avoid the cast), but that situation is not present here."
}