{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorInit code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorInit.\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'void *matcharg' is not const-qualified. In the shown function it is only stored in iter->arg and not dereferenced/modified, so it should be declared as 'const void *matcharg' (and the iterator field iter->arg made 'const void *') to indicate read-only use. As written the non-const pointer violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef uint32_t osal_id_t;\ntypedef uint32_t osal_index_t;\ntypedef uint32_t osal_objtype_t;\ntypedef struct\n{\n    osal_id_t obj_id;\n    osal_index_t obj_idx;\n} OS_object_token_t;\nstruct OS_common_record\n{\n    osal_id_t active_id;\n    /* other fields not needed for the test */\n};\ntypedef struct OS_common_record\n{\n    osal_id_t active_id;\n    /* other fields not needed for the test */\n} OS_common_record_t;\ntypedef bool (*OS_ObjectMatchFunc_t)(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj);\ntypedef struct\n{\n    OS_ObjectMatchFunc_t match;\n    void *arg;            /* NOTE: intentionally non-const to reflect the reported code */\n    uint32 limit;\n    OS_common_record_t *base;\n    OS_object_token_t token;\n} OS_object_iter_t;\ntypedef enum\n{\n    OS_LOCK_MODE_GLOBAL = 0\n} OS_lock_mode_t;\nstatic void os_probe_log_iterator_state(const char *stage, OS_ObjectMatchFunc_t matchfunc,\n                                        void *matcharg, osal_objtype_t objtype,\n                                        const OS_object_iter_t *iter, int32 rv)\n{\n    FILE *f = fopen(\"/tmp/logs/1611.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging cannot be opened, avoid altering program behavior; silently return */\n        return;\n    }\n\n    fprintf(f, \"--- OS_ObjectIdIteratorInit probe: %s\\n\", stage);\n    fprintf(f, \" matchfunc pointer: %p\\n\", (void *)matchfunc);\n    fprintf(f, \" matchfunc is %s\\n\", (matchfunc == NULL) ? \"NULL\" : \"non-NULL\");\n    fprintf(f, \" matcharg pointer: %p\\n\", matcharg);\n    fprintf(f, \" objtype value: %u\\n\", (unsigned)objtype);\n\n    if (iter != NULL)\n    {\n        fprintf(f, \" iter->match pointer: %p\\n\", (void *)iter->match);\n        fprintf(f, \" iter->arg pointer: %p\\n\", iter->arg);\n        fprintf(f, \" iter->limit value: %u\\n\", (unsigned)iter->limit);\n        fprintf(f, \" iter->base pointer: %p\\n\", (void *)iter->base);\n        fprintf(f, \" iter->token.obj_id: %u\\n\", (unsigned)iter->token.obj_id);\n        fprintf(f, \" iter->token.obj_idx: %u\\n\", (unsigned)iter->token.obj_idx);\n    }\n    else\n    {\n        fprintf(f, \" iter pointer: NULL\\n\");\n    }\n\n    fprintf(f, \" return value from transaction init: %d\\n\", (int)rv);\n    fprintf(f, \"--- end probe\\n\\n\");\n    fclose(f);\n}\n\nuint32 OS_GetMaxForObjectType(osal_objtype_t objtype)\n{\n    /* return a predictable value based on objtype */\n    return (uint32)(objtype + 10u);\n}\nuint32 OS_GetBaseForObjectType(osal_objtype_t objtype)\n{\n    /* return an index into OS_common_table; keep it bounded */\n    return (uint32)(objtype % (sizeof(OS_common_table) / sizeof(OS_common_table[0])));\n}\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t objtype, OS_object_token_t *token)\n{\n    /* simple stub: set a token and return success (0) */\n    (void)lock_mode;\n    (void)objtype;\n    if (token != NULL)\n    {\n        token->obj_id = 0xDEADBEEF & 0x7FFFFFFF; /* some non-zero token value */\n        token->obj_idx = 0u;\n    }\n    return 0;\n}\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    /* Log entry state before assignments */\n    os_probe_log_iterator_state(\"entry (before assignments)\", matchfunc, matcharg, objtype, iter, -1);\n\n    /* Preserve the original assignments exactly as in the target code */\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    /* Log state after assignments, before transaction init */\n    os_probe_log_iterator_state(\"after assignments (before transaction)\", matchfunc, matcharg, objtype, iter, -1);\n\n    /* Call the transaction init and capture its return value so it can be logged */\n    int32 rv = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n\n    /* Log final state including the return value and token set by transaction init */\n    os_probe_log_iterator_state(\"after transaction init (final)\", matchfunc, matcharg, objtype, iter, rv);\n\n    return rv;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s claim is not supported. MISRA C:2023 Rule 8.13 recommends that pointers point to const-qualified types when that is feasible across the API usage, but you cannot decide that from this single function in isolation. In the shown code the iterator field iter->arg itself is declared as void * (non-const) and the match function type in the supplied test code uses void * for its first parameter. That means a const qualification here would be incompatible with the rest of the API (you would have to cast away const or change the matchfunc prototype). Therefore it is not safe to conclude the pointer \u201cshould\u201d be const here without analysing the rest of the API and call sites. Also note that MISRA\u2019s wording is \u201cshould\u201d (a guideline) \u2014 projects may accept a non-const pointer for valid reasons. In short: the agent\u2019s report is not correct as presented; you need broader API/context evidence to claim a true Rule 8.13 violation."
}