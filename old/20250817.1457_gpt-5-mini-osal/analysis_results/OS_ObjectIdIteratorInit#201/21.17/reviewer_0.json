{
  "user_message": "An agent A claimed that the following OS_ObjectIdIteratorInit code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdIteratorInit.\n```c\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to memset(token, 0, sizeof(*token)) assumes 'token' points to a valid OS_object_token_t object but the function does not validate the pointer. If a caller invokes OS_ObjectIdTransactionInit(..., token) with token == NULL (or with a pointer to a smaller/invalid buffer), memset will write sizeof(OS_object_token_t) bytes via a NULL/invalid pointer, resulting in an access beyond the bounds of the referenced object (UB). Example violating call: OS_ObjectIdTransactionInit(OS_LOCK_MODE_NONE, some_type, NULL);\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    /* Probe: log entry and input pointers/state */\n    FILE *f = fopen(\"/tmp/logs/1615.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Note: cast function pointer to uintptr_t for printing; this is debug-only logging */\n        fprintf(f, \"ENTRY: OS_ObjectIdIteratorInit(matchfunc=%\" PRIxPTR \", matcharg=%p, objtype=%d, iter=%p)\\n\",\n                (uintptr_t)matchfunc, matcharg, (int)objtype, (void *)iter);\n        fclose(f);\n    }\n\n    /* Preserve original logic (perform the same assignments in the same order) */\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    /* Probe: log the iterator state and the address of the token field we will pass on */\n    f = fopen(\"/tmp/logs/1615.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"STATE: iter=%p match=%\" PRIxPTR \" arg=%p limit=%u base=%p token_addr=%p\\n\",\n                (void *)iter,\n                (uintptr_t)iter->match,\n                iter->arg,\n                (unsigned)iter->limit,\n                (void *)iter->base,\n                (void *)&iter->token);\n        fclose(f);\n    }\n\n    /* Call the original transaction init and capture its return for logging */\n    int32 ret = OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n\n    f = fopen(\"/tmp/logs/1615.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"EXIT: OS_ObjectIdTransactionInit returned %ld for iter=%p token_addr=%p\\n\",\n                (long)ret,\n                (void *)iter,\n                (void *)&iter->token);\n        fclose(f);\n    }\n\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 21.17 targets uses of <string.h> functions (memset/memcpy/strcpy/etc.) that can write beyond the bounds of the referenced objects. The submitted OS_ObjectIdIteratorInit implementation contains no calls to any <string.h> functions. It passes &iter->token to OS_ObjectIdTransactionInit, and it also dereferences iter earlier to assign iter->match/arg/limit/base. If iter were NULL or invalid the UB would occur in OS_ObjectIdIteratorInit itself when those fields are written, long before any called function could do a memset. The scenario given by agent A (calling OS_ObjectIdTransactionInit(..., NULL)) describes a misuse of OS_ObjectIdTransactionInit or a potential defect inside OS_ObjectIdTransactionInit (if it calls memset on a NULL/invalid pointer without validation) \u2014 but that would be a violation attributable to OS_ObjectIdTransactionInit, not to OS_ObjectIdIteratorInit. Therefore the claim that OS_ObjectIdIteratorInit violates MISRA C 2023 Rule 21.17 is incorrect."
}