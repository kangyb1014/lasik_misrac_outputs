{
  "user_message": "An agent A claimed that the following OS_CountSemDelete code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_CountSemDelete.\n```c\nint32 OS_CountSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_CountSemDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The strcmp call uses two pointers without validating they point to valid, NUL-terminated strings. In particular, UT_Stub_RegisterReturnType stores ContentTypeStr = TypeName without checking for NULL; if TypeName (or the stored ContentTypeStr) is NULL, or if either string is not NUL-terminated, the call strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) will dereference an invalid pointer or read past the object bounds. For example, if RegisterReturnType was called with a NULL TypeName, later UT_Stub_GetReturnValuePtr will call strcmp(NULL, ...) leading to out-of-bounds/undefined access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_1151_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1151.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    struct tm *tm = localtime_r(&t, &tm_buf);\n    if (tm != NULL)\n    {\n        fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \", tm->tm_year + 1900, tm->tm_mon + 1,\n                tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n    }\n    else\n    {\n        fprintf(f, \"(no-time) \");\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast to the standard va_list to match the vfprintf signature in this build environment */\n    vfprintf(f, fmt, (va_list)ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_CountSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and input state */\n    OS_1151_Log(\"OS_CountSemDelete ENTRY: sem_id=%lld (0x%llx)\", (long long)sem_id, (unsigned long long)sem_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log result of object id lookup and address of the token used */\n    OS_1151_Log(\"After OS_ObjectIdGetById: return_code=%d, token_addr=%p\", (int)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log before calling implementation routine */\n        OS_1151_Log(\"Calling OS_CountSemDelete_Impl with token_addr=%p\", (void *)&token);\n\n        return_code = OS_CountSemDelete_Impl(&token);\n\n        /* Log after implementation routine returns */\n        OS_1151_Log(\"After OS_CountSemDelete_Impl: return_code=%d\", (int)return_code);\n\n        /* Complete the operation via the common routine */\n        OS_1151_Log(\"Calling OS_ObjectIdFinalizeDelete with token_addr=%p, current_return=%d\", (void *)&token, (int)return_code);\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Final return value logged */\n        OS_1151_Log(\"After OS_ObjectIdFinalizeDelete: final_return_code=%d\", (int)return_code);\n    }\n    else\n    {\n        /* Log the failure path so callers can reproduce/inspect the scenario */\n        OS_1151_Log(\"OS_ObjectIdGetById failed (return_code=%d). Skipping delete and finalize.\", (int)return_code);\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is incorrect for the provided OS_CountSemDelete function. MISRA C 2023 Rule 21.17 concerns use of string.h functions (memcpy, strcpy, strcmp, strlen, etc.). The OS_CountSemDelete implementation shown does not call any string.h functions itself \u2014 it only calls OS_ObjectIdGetById, OS_CountSemDelete_Impl and OS_ObjectIdFinalizeDelete and uses logging via fprintf. The scenario described by agent A refers to a strcmp in a UT_Stub_* routine and a NULL TypeName; that is a different piece of code and is not present in the supplied OS_CountSemDelete. If those other routines contain unsafe strcmp usage then they should be inspected separately, but that does not make the shown OS_CountSemDelete violate Rule 21.17. The test/logging code also does not introduce any string.h usage relevant to 21.17. Therefore the report is not correct."
}