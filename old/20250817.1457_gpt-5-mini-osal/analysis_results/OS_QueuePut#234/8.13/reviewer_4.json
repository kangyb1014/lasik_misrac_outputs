{
  "user_message": "An agent A claimed that the following OS_QueuePut code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueuePut.\n```c\nint32 OS_QueuePut(osal_id_t queue_id, const void *data, size_t size, uint32 flags)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        if (size > queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is too large\n            */\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else\n        {\n            return_code = OS_QueuePut_Impl(&token, data, size, flags);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'impl' is declared as a non-const pointer (OS_impl_queue_internal_record_t *impl) but, in this function, it is only used to read members (e.g. impl->id) and is never used to modify the pointed-to object. According to MISRA C 2023 Rule 8.13 the pointer should be qualified const when possible. A suitable fix is to declare it as: const OS_impl_queue_internal_record_t *impl; (initialization from the non-const table pointer is allowed).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueuePut_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1875.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast ap to the system va_list expected by vfprintf to avoid type-mismatch\n     * when the build environment uses a different typedef (e.g., OCS_va_list).\n     */\n    vfprintf(f, fmt, (va_list)ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_QueuePut(osal_id_t queue_id, const void *data, size_t size, uint32 flags)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Log entry and parameters (pointer values and sizes only) */\n    OS_QueuePut_Log(\"ENTRY: OS_QueuePut queue_id=%\" PRIuPTR \" data=%p size=%zu flags=0x%08\" PRIx32,\n                    (uintptr_t)queue_id, data, size, (uint32_t)flags);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    OS_QueuePut_Log(\"OS_ObjectIdGetById returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Log the looked-up queue pointer and its max size */\n        OS_QueuePut_Log(\"Queue lookup: queue=%p max_size=%zu\", (void *)queue, queue->max_size);\n\n        if (size > queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is too large\n            */\n            OS_QueuePut_Log(\"Size check failed: size=%zu > max_size=%zu -> OS_QUEUE_INVALID_SIZE\", size, queue->max_size);\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else\n        {\n            OS_QueuePut_Log(\"Calling OS_QueuePut_Impl with token=%p data=%p size=%zu flags=0x%08\" PRIx32,\n                            (void *)&token, data, size, (uint32_t)flags);\n            return_code = OS_QueuePut_Impl(&token, data, size, flags);\n            OS_QueuePut_Log(\"OS_QueuePut_Impl returned %d\", return_code);\n        }\n    }\n\n    OS_QueuePut_Log(\"EXIT: OS_QueuePut return_code=%d\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In the shown OS_QueuePut function the local pointer 'queue' is only used to read members (queue->max_size) and is never used to modify the pointed-to object, so per MISRA C 2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. const OS_queue_internal_record_t *queue). Assigning a non-const pointer from the object table to a const-qualified pointer is allowed (adding const), so this change is feasible. One caveat: any code that later removes the const qualifier (for example by casting the const pointer to void * to pass to APIs that take void *) must be adjusted to avoid discarding qualifiers or must use an explicit and justified cast \u2014 otherwise that would itself violate other MISRA rules. The agent's use of the name 'impl' in the scenario is just a naming difference; the issue applies equally to the 'queue' pointer in the provided code."
}