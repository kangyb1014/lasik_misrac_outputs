{
  "user_message": "An agent A claimed that the following OS_QueuePut code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueuePut.\n```c\nint32 OS_QueuePut(osal_id_t queue_id, const void *data, size_t size, uint32 flags)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        if (size > queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is too large\n            */\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else\n        {\n            return_code = OS_QueuePut_Impl(&token, data, size, flags);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'queue' is declared as a non-const pointer (OS_queue_internal_record_t *queue) but is only used for reading (checking queue->max_size). Per MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible. The OS_OBJECT_TABLE_GET macro yields &tbl[...] (a pointer to non-const), but assigning that to a pointer-to-const is allowed; therefore the local declaration should be changed to const OS_queue_internal_record_t *queue to comply.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_QueuePut(osal_id_t queue_id, const void *data, size_t size, uint32 flags)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Small helper to record probing information to a log file. */\n    /* This preserves original behavior and only appends diagnostic info. */\n    void OS_QueuePut_LogState(const OS_object_token_t *token_ptr,\n                              const OS_queue_internal_record_t *queue_ptr,\n                              size_t size_val,\n                              uint32 flags_val,\n                              const char *msg,\n                              int32 code)\n    {\n        FILE *f = fopen(\"/tmp/logs/1875.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"OS_QueuePut: %s\\n\", msg);\n            fprintf(f, \"  token_addr=%p queue_ptr=%p size=%zu flags=%u return_code=%ld\\n\",\n                    (void *)token_ptr, (void *)queue_ptr, size_val, (unsigned)flags_val, (long)code);\n            if (queue_ptr != NULL)\n            {\n                /* max_size is assumed to be size_t-like; print with %%zu */\n                fprintf(f, \"  queue->max_size=%zu\\n\", queue_ptr->max_size);\n            }\n            fclose(f);\n        }\n    }\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Log after resolving the object and obtaining the queue pointer */\n        OS_QueuePut_LogState(&token, queue, size, flags, \"after object lookup and table get\", return_code);\n\n        if (size > queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is too large\n            */\n            return_code = OS_QUEUE_INVALID_SIZE;\n\n            /* Log the invalid size decision so the path is observable */\n            OS_QueuePut_LogState(&token, queue, size, flags, \"size exceeds queue->max_size - returning INVALID_SIZE\", return_code);\n        }\n        else\n        {\n            /* Log that we are about to call the platform-specific implementation */\n            OS_QueuePut_LogState(&token, queue, size, flags, \"calling OS_QueuePut_Impl\", return_code);\n\n            return_code = OS_QueuePut_Impl(&token, data, size, flags);\n\n            /* Log result from implementation call */\n            OS_QueuePut_LogState(&token, queue, size, flags, \"returned from OS_QueuePut_Impl\", return_code);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueuePut. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown OS_QueuePut implementation the local variable queue is only used for read-only access (queue->max_size) and is never used to modify the pointed-to object or passed to routines that require a pointer-to-non-const. Per MISRA C 2023 R.8.13, the pointer should be declared to point to a const-qualified type when possible. Changing the declaration to\n\n    const OS_queue_internal_record_t *queue;\n\nis allowed: converting a pointer-to-non-const (the value produced by OS_OBJECT_TABLE_GET) to a pointer-to-const is valid in C and makes the intent explicit. The additional logging in the test code does not affect the rule; it only reads queue->max_size and would also be compatible with a const-qualified pointer. The only caveat is if elsewhere in the real code the pointer must be used to modify the object or passed to APIs expecting a non-const pointer \u2014 in that case const cannot be applied. Based on the provided snippet, however, the agent A\u2019s report is correct."
}