{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The code calls strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) without guaranteeing that RefText points to a valid null\u2011terminated buffer of at least that many bytes (or is non-NULL). If RefText is NULL or points to a shorter/non\u2011terminated object, strncmp may read beyond the bounds and cause undefined behaviour (violation of MISRA C 2023 Rule 21.17).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_DoCompare code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2247.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_DoCompare as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_DoCompare:\n```c\nstatic bool UtAssert_DoCompare(long ActualValueIn, UtAssert_Compare_t CompareType, UT_IntCheck_t ReferenceValueIn,\n                               bool IsUnsigned)\n{\n    bool              Result;\n    UtAssert_IntBuf_t ActualValue;\n    UtAssert_IntBuf_t ReferenceValue;\n\n    if (IsUnsigned)\n    {\n        ActualValue.u    = ActualValueIn;\n        ReferenceValue.u = ReferenceValueIn;\n    }\n    else\n    {\n        ActualValue.s    = ActualValueIn;\n        ReferenceValue.s = ReferenceValueIn;\n    }\n\n    switch (UT_COMPARE_TYPE(CompareType, IsUnsigned))\n    {\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, true): /* actual equals reference value */\n            Result = (ActualValue.u == ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, false): /* actual equals reference value */\n            Result = (ActualValue.s == ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, true): /* actual does not non equal reference value */\n            Result = (ActualValue.u != ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, false): /* actual does not non equal reference value */\n            Result = (ActualValue.s != ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, true): /* actual less than reference (exclusive) */\n            Result = (ActualValue.u < ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, false): /* actual less than reference (exclusive) */\n            Result = (ActualValue.s < ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, true): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.u > ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, false): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.s > ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, true): /* actual less than reference (inclusive) */\n            Result = (ActualValue.u <= ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, false): /* actual less than reference (inclusive) */\n            Result = (ActualValue.s <= ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, true): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.u >= ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, false): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.s >= ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, true): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == ReferenceValue.u;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, false): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == ReferenceValue.s;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, true): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == 0;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, false): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == 0;\n            break;\n        default: /* should never happen */\n            Result = false;\n            break;\n    }\n\n    return Result;\n}\n```\n</target_code>\nPlease provide the modified UtAssert_DoCompare code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n\n/* Probe logging helper.\n * Writes a concise trace of control flow and operand state to /tmp/logs/2247.txt.\n * This function is intentionally lightweight and does not alter program logic.\n */\nstatic void UtAssert_DoCompare_Log(const char *tag, long ActualValueIn, UtAssert_Compare_t CompareType,\n                                   UT_IntCheck_t ReferenceValueIn, bool IsUnsigned,\n                                   long Act_s, unsigned long Act_u, long Ref_s, unsigned long Ref_u,\n                                   int SelectedCase, const char *caseName, bool Result)\n{\n    FILE *f = fopen(\"/tmp/logs/2247.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    fprintf(f, \"%s: CompareType=%d IsUnsigned=%d ActualValueIn=%ld ReferenceValueIn=%ld\\n\",\n            tag, (int)CompareType, (int)IsUnsigned, ActualValueIn, (long)ReferenceValueIn);\n\n    /* Log the interpreted union views so callers can observe how the values were\n     * mapped into signed/unsigned views prior to the comparison. */\n    fprintf(f, \"%s: Interpreted: Act_s=%ld Act_u=%lu Ref_s=%ld Ref_u=%lu\\n\",\n            tag, Act_s, (unsigned long)Act_u, Ref_s, (unsigned long)Ref_u);\n\n    fprintf(f, \"%s: SelectedCase=%d CaseName=%s Result=%d\\n\",\n            tag, SelectedCase, (caseName != NULL) ? caseName : \"(unknown)\", (int)Result);\n\n    fprintf(f, \"------------------------------------------------------------\\n\");\n    fclose(f);\n}\n\nstatic bool UtAssert_DoCompare(long ActualValueIn, UtAssert_Compare_t CompareType, UT_IntCheck_t ReferenceValueIn,\n                               bool IsUnsigned)\n{\n    bool              Result;\n    UtAssert_IntBuf_t ActualValue;\n    UtAssert_IntBuf_t ReferenceValue;\n\n    if (IsUnsigned)\n    {\n        ActualValue.u    = ActualValueIn;\n        ReferenceValue.u = ReferenceValueIn;\n    }\n    else\n    {\n        ActualValue.s    = ActualValueIn;\n        ReferenceValue.s = ReferenceValueIn;\n    }\n\n    /* Log initial mapping of inputs into the internal union representation. */\n    UtAssert_DoCompare_Log(\"ENTRY\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                           /* Act_s */ ActualValue.s, /* Act_u */ ActualValue.u,\n                           /* Ref_s */ ReferenceValue.s, /* Ref_u */ ReferenceValue.u,\n                           /* SelectedCase (best-effort) */ UT_COMPARE_TYPE(CompareType, IsUnsigned),\n                           /* caseName */ NULL, /* Result unknown yet */ -1);\n\n    switch (UT_COMPARE_TYPE(CompareType, IsUnsigned))\n    {\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, true): /* actual equals reference value */\n            Result = (ActualValue.u == ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"EQ (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, false): /* actual equals reference value */\n            Result = (ActualValue.s == ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"EQ (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, true): /* actual does not non equal reference value */\n            Result = (ActualValue.u != ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"NEQ (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, false): /* actual does not non equal reference value */\n            Result = (ActualValue.s != ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"NEQ (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, true): /* actual less than reference (exclusive) */\n            Result = (ActualValue.u < ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"LT (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, false): /* actual less than reference (exclusive) */\n            Result = (ActualValue.s < ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"LT (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, true): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.u > ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"GT (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, false): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.s > ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"GT (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, true): /* actual less than reference (inclusive) */\n            Result = (ActualValue.u <= ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"LTEQ (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, false): /* actual less than reference (inclusive) */\n            Result = (ActualValue.s <= ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"LTEQ (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, true): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.u >= ReferenceValue.u);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"GTEQ (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, false): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.s >= ReferenceValue.s);\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"GTEQ (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, true): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == ReferenceValue.u;\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"BITMASK_SET (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, false): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == ReferenceValue.s;\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"BITMASK_SET (signed)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, true): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == 0;\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"BITMASK_UNSET (unsigned)\", Result);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, false): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == 0;\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"BITMASK_UNSET (signed)\", Result);\n            break;\n        default: /* should never happen */\n            Result = false;\n            UtAssert_DoCompare_Log(\"BRANCH\", ActualValueIn, CompareType, ReferenceValueIn, IsUnsigned,\n                                   ActualValue.s, ActualValue.u, ReferenceValue.s, ReferenceValue.u,\n                                   UT_COMPARE_TYPE(CompareType, IsUnsigned), \"DEFAULT\", Result);\n            break;\n    }\n\n    /* Final result already logged in the branch-specific logs. Keep return behavior identical. */\n    return Result;\n}\n"
}