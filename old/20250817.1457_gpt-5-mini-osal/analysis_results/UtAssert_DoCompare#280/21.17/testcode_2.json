{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call uses strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) without checking ActualText for NULL or guaranteeing it points to a NUL-terminated buffer of at least 9 bytes. If a caller passes ActualText == NULL (or a non-NUL-terminated buffer shorter than 9 characters), strncmp will dereference/read beyond the object bounds and thus violate Rule 21.17 (e.g. ActualText is a 5-byte array without a terminating '\\0' or is NULL).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_DoCompare code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2247.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_DoCompare as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_DoCompare:\n```c\nstatic bool UtAssert_DoCompare(long ActualValueIn, UtAssert_Compare_t CompareType, UT_IntCheck_t ReferenceValueIn,\n                               bool IsUnsigned)\n{\n    bool              Result;\n    UtAssert_IntBuf_t ActualValue;\n    UtAssert_IntBuf_t ReferenceValue;\n\n    if (IsUnsigned)\n    {\n        ActualValue.u    = ActualValueIn;\n        ReferenceValue.u = ReferenceValueIn;\n    }\n    else\n    {\n        ActualValue.s    = ActualValueIn;\n        ReferenceValue.s = ReferenceValueIn;\n    }\n\n    switch (UT_COMPARE_TYPE(CompareType, IsUnsigned))\n    {\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, true): /* actual equals reference value */\n            Result = (ActualValue.u == ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, false): /* actual equals reference value */\n            Result = (ActualValue.s == ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, true): /* actual does not non equal reference value */\n            Result = (ActualValue.u != ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, false): /* actual does not non equal reference value */\n            Result = (ActualValue.s != ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, true): /* actual less than reference (exclusive) */\n            Result = (ActualValue.u < ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, false): /* actual less than reference (exclusive) */\n            Result = (ActualValue.s < ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, true): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.u > ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, false): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.s > ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, true): /* actual less than reference (inclusive) */\n            Result = (ActualValue.u <= ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, false): /* actual less than reference (inclusive) */\n            Result = (ActualValue.s <= ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, true): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.u >= ReferenceValue.u);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, false): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.s >= ReferenceValue.s);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, true): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == ReferenceValue.u;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, false): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == ReferenceValue.s;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, true): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == 0;\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, false): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == 0;\n            break;\n        default: /* should never happen */\n            Result = false;\n            break;\n    }\n\n    return Result;\n}\n```\n</target_code>\nPlease provide the modified UtAssert_DoCompare code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdarg.h>\n\n/* Probe logging helper -- append logs to /tmp/logs/2247.txt */\nstatic void UtAssert_ProbeLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2247.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * Modified UtAssert_DoCompare with inserted probes. Original logic preserved.\n */\nstatic bool UtAssert_DoCompare(long ActualValueIn, UtAssert_Compare_t CompareType, UT_IntCheck_t ReferenceValueIn,\n                               bool IsUnsigned)\n{\n    bool              Result;\n    UtAssert_IntBuf_t ActualValue;\n    UtAssert_IntBuf_t ReferenceValue;\n\n    /* Log entry state */\n    UtAssert_ProbeLog(\"ENTER UtAssert_DoCompare: ActualValueIn=%ld, ReferenceValueIn=%ld, CompareType=%d, IsUnsigned=%d\",\n                      (long)ActualValueIn, (long)ReferenceValueIn, (int)CompareType, (int)IsUnsigned);\n\n    if (IsUnsigned)\n    {\n        ActualValue.u    = ActualValueIn;\n        ReferenceValue.u = ReferenceValueIn;\n    }\n    else\n    {\n        ActualValue.s    = ActualValueIn;\n        ReferenceValue.s = ReferenceValueIn;\n    }\n\n    /* Log computed representations */\n    UtAssert_ProbeLog(\"Computed values: Actual.s=%ld, Actual.u=%lu, Reference.s=%ld, Reference.u=%lu\",\n                      (long)ActualValue.s,\n                      (unsigned long)ActualValue.u,\n                      (long)ReferenceValue.s,\n                      (unsigned long)ReferenceValue.u);\n\n    switch (UT_COMPARE_TYPE(CompareType, IsUnsigned))\n    {\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, true): /* actual equals reference value */\n            Result = (ActualValue.u == ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: EQ (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_EQ, false): /* actual equals reference value */\n            Result = (ActualValue.s == ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: EQ (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, true): /* actual does not non equal reference value */\n            Result = (ActualValue.u != ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: NEQ (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_NEQ, false): /* actual does not non equal reference value */\n            Result = (ActualValue.s != ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: NEQ (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, true): /* actual less than reference (exclusive) */\n            Result = (ActualValue.u < ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: LT (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LT, false): /* actual less than reference (exclusive) */\n            Result = (ActualValue.s < ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: LT (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, true): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.u > ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: GT (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GT, false): /* actual greater than reference (exclusive)  */\n            Result = (ActualValue.s > ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: GT (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, true): /* actual less than reference (inclusive) */\n            Result = (ActualValue.u <= ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: LTEQ (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_LTEQ, false): /* actual less than reference (inclusive) */\n            Result = (ActualValue.s <= ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: LTEQ (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, true): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.u >= ReferenceValue.u);\n            UtAssert_ProbeLog(\"CASE: GTEQ (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_GTEQ, false): /* actual greater than reference (inclusive) */\n            Result = (ActualValue.s >= ReferenceValue.s);\n            UtAssert_ProbeLog(\"CASE: GTEQ (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, true): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == ReferenceValue.u;\n            UtAssert_ProbeLog(\"CASE: BITMASK_SET (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_SET, false): /* bit(s) in reference are set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == ReferenceValue.s;\n            UtAssert_ProbeLog(\"CASE: BITMASK_SET (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, true): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.u & ReferenceValue.u) == 0;\n            UtAssert_ProbeLog(\"CASE: BITMASK_UNSET (unsigned) -- Actual.u=%lu, Reference.u=%lu, Result=%d\",\n                              (unsigned long)ActualValue.u, (unsigned long)ReferenceValue.u, Result ? 1 : 0);\n            break;\n        case UT_COMPARE_TYPE(UtAssert_Compare_BITMASK_UNSET, false): /* bit(s) in reference are not set in actual */\n            Result = (ActualValue.s & ReferenceValue.s) == 0;\n            UtAssert_ProbeLog(\"CASE: BITMASK_UNSET (signed) -- Actual.s=%ld, Reference.s=%ld, Result=%d\",\n                              (long)ActualValue.s, (long)ReferenceValue.s, Result ? 1 : 0);\n            break;\n        default: /* should never happen */\n            Result = false;\n            UtAssert_ProbeLog(\"CASE: DEFAULT -- Unexpected compare type (%d). Setting Result=false.\", (int)CompareType);\n            break;\n    }\n\n    /* Log exit state */\n    UtAssert_ProbeLog(\"EXIT UtAssert_DoCompare: Result=%d\", Result ? 1 : 0);\n\n    return Result;\n}\n"
}