{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. OutPtr points into OutputLine (80 bytes). Each sprintf(OutPtr, \"%02X  \", Byte_ptr[i]) will write the formatted bytes plus a terminating NUL (for values < 256 the format produces 4 printable chars + NUL = 5 bytes). The code advances OutPtr by only 3 each iteration, and there is no check that the remaining space in OutputLine is sufficient. For example, if snprintf produced a 20\u2011byte prefix and the loop runs 16 times, sprintf would attempt to write 16*5 = 80 bytes starting at index 20 (indices 20..99), which overruns OutputLine (max index 79). Therefore the use of the string/formatting function here can result in accesses beyond the bounds of the object referenced by OutPtr/OutputLine and violates the rule.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtPrintx code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2687.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtPrintx as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtPrintx:\n```c\nvoid UtPrintx(const void *Memory, uint32 Length)\n{\n    uint32       i;\n    uint32       j;\n    const uint8 *Byte_ptr = Memory;\n    char         OutputLine[80];\n    char *       OutPtr;\n\n    i = 0;\n    while (i < Length)\n    {\n        snprintf(OutputLine, sizeof(OutputLine), \"%16lx: \", (unsigned long)&Byte_ptr[i]);\n        OutPtr = OutputLine;\n        OutPtr += strlen(OutputLine);\n        for (j = 0; j < 16 && i < Length; j++, i++)\n        {\n            sprintf(OutPtr, \"%02X  \", Byte_ptr[i]);\n            OutPtr += 3;\n        }\n\n        UT_BSP_DoText(UTASSERT_CASETYPE_INFO, OutputLine);\n    }\n}\n```\n</target_code>\nPlease provide the modified UtPrintx code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/*\n * Modified UtPrintx: original logic preserved; added logging probes to\n * /tmp/logs/2687.txt to capture control flow and buffer state for\n * reproducing the potential Rule 21.17 violation scenario.\n *\n * Notes:\n * - This file must be compiled in the same environment where uint32 and\n *   uint8 are defined (they are not redefined here to avoid conflicts).\n * - The function does not define main and does not introduce new behaviour\n *   beyond logging. The original formatting calls are preserved.\n */\n\nvoid UtPrintx(const void *Memory, uint32 Length)\n{\n    uint32       i;\n    uint32       j;\n    const uint8 *Byte_ptr = Memory;\n    char         OutputLine[80];\n    char *       OutPtr;\n\n    /* Open log file for append; if unavailable, logging is skipped. */\n    FILE *log = fopen(\"/tmp/logs/2687.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"---- UtPrintx ENTRY ----\\n\");\n        fprintf(log, \"Memory=%p Length=%u\\n\", Memory, (unsigned)Length);\n        fflush(log);\n    }\n\n    i = 0;\n    while (i < Length)\n    {\n        size_t out_size = sizeof(OutputLine);\n\n        if (log)\n        {\n            fprintf(log, \"LOOP start: i=%u remaining_length=%u\\n\", (unsigned)i, (unsigned)(Length - i));\n            fflush(log);\n        }\n\n        /* original prefix formatting retained */\n        snprintf(OutputLine, sizeof(OutputLine), \"%16lx: \", (unsigned long)&Byte_ptr[i]);\n\n        if (log)\n        {\n            int prefix_len = (int)strlen(OutputLine);\n            fprintf(log, \"snprintf produced prefix_len=%d prefix=\\\"%s\\\"\\n\", prefix_len, OutputLine);\n            fprintf(log, \"OutputLine buffer size=%zu\\n\", out_size);\n            fflush(log);\n        }\n\n        OutPtr = OutputLine;\n        OutPtr += strlen(OutputLine);\n\n        if (log)\n        {\n            ptrdiff_t offset = OutPtr - OutputLine;\n            size_t remaining = (out_size > (size_t)offset) ? (out_size - (size_t)offset) : 0u;\n            fprintf(log, \"After prefix: OutPtr offset=%ld remaining=%zu\\n\", (long)offset, remaining);\n            fflush(log);\n        }\n\n        for (j = 0; j < 16 && i < Length; j++, i++)\n        {\n            /* preserve original sprintf usage (this is where the reported overrun can occur) */\n            int ret = sprintf(OutPtr, \"%02X  \", Byte_ptr[i]);\n\n            if (log)\n            {\n                ptrdiff_t offset_before = OutPtr - OutputLine;\n                /* ret may be -1 on failure; otherwise number of characters written (excluding NUL) */\n                fprintf(log, \"sprintf at i=%u j=%u byte=0x%02X ret=%d offset_before=%ld\\n\",\n                        (unsigned)i, (unsigned)j, (unsigned)Byte_ptr[i], ret, (long)offset_before);\n\n                /* Show the immediate string that was written at OutPtr (this is the substring starting at OutPtr) */\n                /* Ensure the printed substring is safe by bounding its length when printing to log. */\n                {\n                    size_t remaining_buf = (sizeof(OutputLine) > (size_t)offset_before) ? (sizeof(OutputLine) - (size_t)offset_before) : 0u;\n                    /* Print up to remaining_buf characters from OutPtr to avoid reading beyond buffer in the log. */\n                    if (remaining_buf > 0)\n                    {\n                        /* Temporary buffer to safely capture what was written */\n                        char temp[128]; /* sufficiently large for logging; not used for program logic */\n                        size_t to_copy = (remaining_buf < (sizeof(temp) - 1)) ? remaining_buf : (sizeof(temp) - 1);\n                        /* Use strncpy to avoid overruns when copying to temp. */\n                        strncpy(temp, OutPtr, to_copy);\n                        temp[to_copy] = '\\0';\n                        fprintf(log, \"written_substring=\\\"%s\\\" remaining_buf=%zu\\n\", temp, remaining_buf);\n                    }\n                    else\n                    {\n                        fprintf(log, \"written_substring=<no room in buffer> remaining_buf=0\\n\");\n                    }\n                }\n\n                fflush(log);\n            }\n\n            /* advance pointer exactly as original code */\n            OutPtr += 3;\n\n            if (log)\n            {\n                ptrdiff_t offset_after = OutPtr - OutputLine;\n                size_t remaining_after = (sizeof(OutputLine) > (size_t)offset_after) ? (sizeof(OutputLine) - (size_t)offset_after) : 0u;\n                fprintf(log, \"After advance: OutPtr offset=%ld remaining=%zu\\n\", (long)offset_after, remaining_after);\n                fflush(log);\n            }\n        }\n\n        if (log)\n        {\n            fprintf(log, \"Calling UT_BSP_DoText with OutputLine (len %zu): '%s'\\n\", strlen(OutputLine), OutputLine);\n            fflush(log);\n        }\n\n        UT_BSP_DoText(UTASSERT_CASETYPE_INFO, OutputLine);\n    }\n\n    if (log)\n    {\n        fprintf(log, \"---- UtPrintx EXIT ----\\n\\n\");\n        fclose(log);\n    }\n}\n"
}