{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UtPrintx:\n```c\nvoid UtPrintx(const void *Memory, uint32 Length)\n{\n    uint32       i;\n    uint32       j;\n    const uint8 *Byte_ptr = Memory;\n    char         OutputLine[80];\n    char *       OutPtr;\n\n    i = 0;\n    while (i < Length)\n    {\n        snprintf(OutputLine, sizeof(OutputLine), \"%16lx: \", (unsigned long)&Byte_ptr[i]);\n        OutPtr = OutputLine;\n        OutPtr += strlen(OutputLine);\n        for (j = 0; j < 16 && i < Length; j++, i++)\n        {\n            sprintf(OutPtr, \"%02X  \", Byte_ptr[i]);\n            OutPtr += 3;\n        }\n\n        UT_BSP_DoText(UTASSERT_CASETYPE_INFO, OutputLine);\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UtPrintx:\nsize_t size\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOutPtr = OutputLine;\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The assignment OutPtr = OutputLine; itself does not violate MISRA C 2023 Rule 21.17. However, in this function a realistic violation can occur after this assignment: snprintf writes a null-terminated prefix into OutputLine, OutPtr is advanced to the terminating NUL via strlen(OutputLine), and then sprintf(OutPtr, \"%02X  \", ...) is used repeatedly. sprintf writes the formatted bytes plus a terminating NUL, but the code advances OutPtr by only 3 each iteration (while the formatted string is longer), which will cause successive writes to overlap and eventually write past the end of OutputLine. That out\u2011of\u2011bounds write (and any subsequent strlen or other string-handling operations) would violate Rule 21.17."
}