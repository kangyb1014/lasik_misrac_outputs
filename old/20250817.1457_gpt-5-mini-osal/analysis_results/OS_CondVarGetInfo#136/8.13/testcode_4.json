{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable 'record' is declared as a non-const pointer: 'OS_common_record_t *record;'. In OS_CondVarGetInfo it is only used for read accesses (record->name_entry, record->creator) and never to modify the pointed-to object, so the pointer could and should be const-qualified: 'const OS_common_record_t *record;'. Assigning the result of OS_OBJECT_TABLE_GET (which yields OS_common_record_t *) to a pointer-to-const is allowed; therefore the current declaration violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CondVarGetInfo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1091.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CondVarGetInfo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CondVarGetInfo:\n```c\nint32 OS_CondVarGetInfo(osal_id_t var_id, OS_condvar_prop_t *condvar_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(condvar_prop);\n\n    memset(condvar_prop, 0, sizeof(OS_condvar_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_condvar_table, token);\n\n        strncpy(condvar_prop->name, record->name_entry, sizeof(condvar_prop->name) - 1);\n        condvar_prop->creator = record->creator;\n\n        return_code = OS_CondVarGetInfo_Impl(&token, condvar_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CondVarGetInfo code.\n",
  "test_code": "int32 OS_CondVarGetInfo(osal_id_t var_id, OS_condvar_prop_t *condvar_prop)\n{\n    OS_common_record_t *record;\n    int32               return_code;\n    OS_object_token_t   token;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(condvar_prop);\n\n    /* Probe log: entry and parameter values */\n    {\n        FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_CondVarGetInfo: entry, var_id=%ld, condvar_prop=%p\\n\", (long)var_id, (void *)condvar_prop);\n            fclose(log);\n        }\n    }\n\n    memset(condvar_prop, 0, sizeof(OS_condvar_prop_t));\n\n    /* Probe log: after memset */\n    {\n        FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_CondVarGetInfo: cleared condvar_prop (zeroed).\\n\");\n            fclose(log);\n        }\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_CONDVAR, var_id, &token);\n\n    /* Probe log: result of ID lookup */\n    {\n        FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_CondVarGetInfo: OS_ObjectIdGetById returned %ld, token=%p\\n\", (long)return_code, (void *)&token);\n            fclose(log);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_condvar_table, token);\n\n        /* Probe log: record pointer and fields read from it (evidence for read-only usage) */\n        {\n            FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n            if (log != NULL)\n            {\n                if (record != NULL)\n                {\n                    /* Log the pointer value and the read-only fields accessed below */\n                    fprintf(log, \"OS_CondVarGetInfo: record=%p, name_entry=\\\"%s\\\", creator=%ld\\n\",\n                            (void *)record,\n                            (record->name_entry != NULL) ? record->name_entry : \"(null)\",\n                            (long)record->creator);\n                }\n                else\n                {\n                    fprintf(log, \"OS_CondVarGetInfo: record is NULL after OS_OBJECT_TABLE_GET\\n\");\n                }\n                fclose(log);\n            }\n        }\n\n        strncpy(condvar_prop->name, record->name_entry, sizeof(condvar_prop->name) - 1);\n        condvar_prop->creator = record->creator;\n\n        /* Probe log: state before calling implementation-specific getter */\n        {\n            FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"OS_CondVarGetInfo: about to call OS_CondVarGetInfo_Impl, token=%p, condvar_prop.name=\\\"%s\\\", creator=%ld\\n\",\n                        (void *)&token, condvar_prop->name, (long)condvar_prop->creator);\n                fclose(log);\n            }\n        }\n\n        return_code = OS_CondVarGetInfo_Impl(&token, condvar_prop);\n\n        /* Probe log: result from implementation-specific getter */\n        {\n            FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"OS_CondVarGetInfo: OS_CondVarGetInfo_Impl returned %ld\\n\", (long)return_code);\n                fclose(log);\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Probe log: after release */\n        {\n            FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"OS_CondVarGetInfo: token released (%p)\\n\", (void *)&token);\n                fclose(log);\n            }\n        }\n    }\n\n    /* Probe log: exit and return code */\n    {\n        FILE *log = fopen(\"/tmp/logs/1091.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_CondVarGetInfo: exit, return_code=%ld\\n\", (long)return_code);\n            fclose(log);\n        }\n    }\n\n    return return_code;\n}\n"
}