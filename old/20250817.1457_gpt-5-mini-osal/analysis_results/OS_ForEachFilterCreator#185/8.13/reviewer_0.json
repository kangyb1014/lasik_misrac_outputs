{
  "user_message": "An agent A claimed that the following OS_ForEachFilterCreator code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachFilterCreator.\n```c\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'filter' is declared as a non-const OS_creator_filter_t * but is only used for read-only access (reading filter->creator_id). According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type where possible. For example, it should be declared as: const OS_creator_filter_t *filter = ref; (or the function parameter changed to const void *ref).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_LogForEachFilterCreator(const char *format, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1483.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, format);\n    /* cast to va_list to ensure the expected type for vfprintf in environments\n       where there is an alternate typedef (e.g. OCS_va_list) */\n    vfprintf(f, format, (va_list)ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    /* Keep the original (non-const) pointer to reproduce the reported violation scenario */\n    OS_creator_filter_t *filter = ref;\n\n    /* Log entry and key state values to help reproduce and evidence the violation */\n    OS_LogForEachFilterCreator(\"ENTER: OS_ForEachFilterCreator ref=%p token=%p obj=%p\", (void *)ref, (const void *)token, (const void *)obj);\n\n    /* Log fields that are used/read below. Cast to uintptr_t for portable integer printing. */\n    OS_LogForEachFilterCreator(\"obj->active_id=%\" PRIuPTR \", obj->creator=%\" PRIuPTR, (uintptr_t)obj->active_id, (uintptr_t)obj->creator);\n    OS_LogForEachFilterCreator(\"filter=%p filter->creator_id=%\" PRIuPTR, (void *)filter, (uintptr_t)filter->creator_id);\n\n    /* Preserve original logic while capturing intermediate boolean results for traceability. */\n    bool valid = OS_ObjectIdIsValid(obj->active_id);\n    bool any_eq = OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY);\n    bool creator_eq = OS_ObjectIdEqual(obj->creator, filter->creator_id);\n\n    OS_LogForEachFilterCreator(\"OS_ObjectIdIsValid(active_id)=%d\", (int)valid);\n    OS_LogForEachFilterCreator(\"OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY)=%d\", (int)any_eq);\n    OS_LogForEachFilterCreator(\"OS_ObjectIdEqual(obj->creator, filter->creator_id)=%d\", (int)creator_eq);\n\n    bool result = (valid && (any_eq || creator_eq));\n\n    OS_LogForEachFilterCreator(\"EXIT: result=%d\", (int)result);\n\n    return result;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 8.13 advises that pointers shall point to const-qualified types whenever possible. In the shown function the local pointer is declared as a non-const:\n\n    OS_creator_filter_t *filter = ref;\n\nbut it is only used for read-only access (filter->creator_id). Therefore the pointer should be const-qualified, e.g.:\n\n    const OS_creator_filter_t *filter = ref;\n\n(or change the parameter to const void *ref so the local pointer naturally becomes const). If the function actually needs to modify the pointed object elsewhere, then making it const would be inappropriate; however, given the provided code the pointer can and should be const to comply with Rule 8.13. The failing test compilation is unrelated to the correctness of the rule application here."
}