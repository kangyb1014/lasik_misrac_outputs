{
  "user_message": "An agent A claimed that the following OS_ForEachFilterCreator code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachFilterCreator.\n```c\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_creator_filter_t *filter = ref;\n\n    /*\n     * Check if the obj_id is both valid and matches\n     * the specified creator_id\n     */\n    return (OS_ObjectIdIsValid(obj->active_id) && (OS_ObjectIdEqual(filter->creator_id, OS_OBJECT_CREATOR_ANY) ||\n                                                   OS_ObjectIdEqual(obj->creator, filter->creator_id)));\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'ref' is declared as void * but is only read (assigned to OS_creator_filter_t *filter and only inspected); the function does not modify the object pointed to. According to MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible. Example fix: change the prototype to 'bool OS_ForEachFilterCreator(const void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)' and use 'const OS_creator_filter_t *filter = ref;'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_probe(const char *fmt, ...)\n{\n    char buf[1024];\n    va_list ap;\n    va_start(ap, fmt);\n    int n = vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n\n    int fd = open(\"/tmp/logs/1483.txt\", O_WRONLY | O_CREAT | O_APPEND, 0644);\n    if (fd >= 0)\n    {\n        /* write up to the number of bytes reported by vsnprintf (or the buffer size) */\n        size_t to_write = (n > 0 && n < (int)sizeof(buf)) ? (size_t)n : sizeof(buf);\n        /* ignore return value; logging must not affect control flow */\n        (void)write(fd, buf, to_write);\n        (void)close(fd);\n    }\n}\n\nbool OS_ForEachFilterCreator(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    /* keep original assignment to preserve original logic and signature */\n    OS_creator_filter_t *filter = ref;\n\n    /* Log entry and pointers to reproduce the scenario where 'ref' is only read */\n    os_log_probe(\"ENTRY: OS_ForEachFilterCreator called: ref=%p, token=%p, obj=%p\\n\", ref, (const void *)token, (const void *)obj);\n\n    /* Use a const-qualified view for inspection only (does not modify object) */\n    const OS_creator_filter_t *cfilter = (const OS_creator_filter_t *)ref;\n    os_log_probe(\"INSPECT: filter (as const)=%p, filter->creator_id addr=%p\\n\", (const void *)cfilter, (const void *)&(cfilter->creator_id));\n\n    /* Preserve original checks and logic but log intermediate boolean results */\n    bool is_valid = OS_ObjectIdIsValid(obj->active_id);\n    bool equal_any = OS_ObjectIdEqual(cfilter->creator_id, OS_OBJECT_CREATOR_ANY);\n    bool equal_creator = OS_ObjectIdEqual(obj->creator, cfilter->creator_id);\n\n    os_log_probe(\"CHECKS: is_valid=%d, equal_any=%d, equal_creator=%d\\n\", (int)is_valid, (int)equal_any, (int)equal_creator);\n\n    bool result = (is_valid && (equal_any || equal_creator));\n\n    os_log_probe(\"EXIT: OS_ForEachFilterCreator result=%d\\n\", (int)result);\n\n    return result;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is essentially correct: in the shown implementation the object passed via ref is only read, so the pointer could and should be const-qualified to satisfy MISRA C 2023 Rule 8.13. A compliant change would be to either (a) change the parameter to const void *ref (and adjust any callers/signature) and use const OS_creator_filter_t *filter = ref; or (b) if the function prototype must remain void * (e.g. because it implements a fixed callback type), at minimum use a const-qualified local view (const OS_creator_filter_t *cfilter = (const OS_creator_filter_t *)ref;) so the code documents and enforces non-modification. If the prototype cannot be changed due to external API/signature constraints, then keeping void *ref is an acceptable exception, but that should be documented (deviation). Therefore the report that the code \u201cviolates\u201d 8.13 is correct in the absence of an overriding signature constraint; if such a constraint exists then the report is a false positive but the recommended local const cast should still be applied."
}