{
  "user_message": "An agent A claimed that the following OS_ObjectIdFinalizeDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFinalizeDelete.\n```c\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    osal_id_t final_id;\n\n    /* Clear the OSAL ID if successful - this returns the record to the pool */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n    }\n    else\n    {\n        /* this restores the original ID */\n        final_id = token->obj_id;\n    }\n\n    /* Either way we must unlock the object type */\n    OS_ObjectIdTransactionFinish(token, &final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n    }\n\n    return operation_status;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function takes a pointer parameter 'OS_object_token_t *token' but never modifies the referent in this function (only reads token->obj_id). Per MISRA C 2023 Rule 8.13 the pointer should be to a const-qualified type when possible (e.g. const OS_object_token_t *token). Therefore this signature violates the rule unless the callee OS_ObjectIdTransactionFinish or other code requires a non-const pointer (in which case the non-const is justified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1547.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    osal_id_t final_id;\n\n    os_probe_log(\"ENTER: OS_ObjectIdFinalizeDelete operation_status=%d token=%p\",\n                 (int)operation_status, (void *)token);\n\n    /* Clear the OSAL ID if successful - this returns the record to the pool */\n    if (operation_status == OS_SUCCESS)\n    {\n        final_id = OS_OBJECT_ID_UNDEFINED;\n        os_probe_log(\"Branch: operation_status==OS_SUCCESS -> final_id set to OS_OBJECT_ID_UNDEFINED(%lld)\",\n                     (long long)final_id);\n    }\n    else\n    {\n        /* this restores the original ID */\n        final_id = token->obj_id;\n        os_probe_log(\"Branch: operation_status!=OS_SUCCESS -> final_id restored from token->obj_id=%lld token=%p\",\n                     (long long)token->obj_id, (void *)token);\n    }\n\n    /* Either way we must unlock the object type */\n    os_probe_log(\"Before OS_ObjectIdTransactionFinish: token=%p final_id=%lld\",\n                 (void *)token, (long long)final_id);\n    OS_ObjectIdTransactionFinish(token, &final_id);\n    os_probe_log(\"After OS_ObjectIdTransactionFinish: token=%p final_id=%lld\",\n                 (void *)token, (long long)final_id);\n\n    /* Give event callback to the application */\n    if (operation_status == OS_SUCCESS)\n    {\n        /* Note: original code passes token->obj_id here; logging does the same read to evidence the usage */\n        os_probe_log(\"About to call OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id=%lld, NULL) token=%p\",\n                     (long long)token->obj_id, (void *)token);\n        OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n    }\n\n    os_probe_log(\"EXIT: OS_ObjectIdFinalizeDelete returning %d\", (int)operation_status);\n\n    return operation_status;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdFinalizeDelete. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report as stated is incomplete and therefore not conclusively correct. MISRA C:2023 Rule 8.13 does recommend that pointers should point to const-qualified types when they are not used to modify the referenced object. In the body of OS_ObjectIdFinalizeDelete this function itself does not modify *token \u2014 it only reads token->obj_id and passes token on to OS_ObjectIdTransactionFinish. Whether the signature violates 8.13 depends on the declarations/behavior of the callees:\n\n- If OS_ObjectIdTransactionFinish (or any other function called with token) requires a non-const OS_object_token_t * because it may modify the object, then the non-const parameter here is justified and there is no MISRA violation.\n- If all callees take a pointer-to-const (or otherwise never modify the object) and this function never modifies *token, then this function should be changed to take const OS_object_token_t *token to satisfy Rule 8.13.\n\nAgent A\u2019s observation (that the pointer is never modified in this function and could be const) is accurate as far as local usage, but the report claiming a MISRA violation is not substantiated without checking the prototype/semantics of OS_ObjectIdTransactionFinish and any other callees. Therefore the report as given is not correct (insufficient evidence). To resolve: inspect the prototype/implementation of OS_ObjectIdTransactionFinish and any other consumers of token; if they do not require a mutable pointer, change the parameter to const; otherwise keep as-is."
}