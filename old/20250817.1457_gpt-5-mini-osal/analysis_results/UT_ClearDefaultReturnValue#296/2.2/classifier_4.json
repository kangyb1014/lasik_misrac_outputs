{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_ClearDefaultReturnValue:\n```c\nvoid UT_ClearDefaultReturnValue(UT_EntryKey_t FuncKey)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT);\n    if (StubPtr != NULL)\n    {\n        UT_ClearStubEntry(StubPtr);\n    }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (StubPtr != NULL)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Based on the fragment alone, there is no evidence that the conditional is dead: it protects the call UT_ClearStubEntry(StubPtr) against a NULL pointer returned by UT_GetStubEntry, and so removing it could change behaviour if NULL is possible. Therefore, rule 2.2 is not violated as shown. Specific violation scenario: if elsewhere in the project it is proven (by specification or static analysis) that UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT) can never return NULL for any valid FuncKey, then the if (StubPtr != NULL) test is executed but unnecessary\u2014removing it would not change program behaviour\u2014and that would violate MISRA C 2023 Rule 2.2."
}