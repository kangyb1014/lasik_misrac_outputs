{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation: OS_strnlen calls memchr(VirtualPath, 0, OS_MAX_PATH_LEN). If the caller passes a pointer to a char object that is smaller than OS_MAX_PATH_LEN (or not NUL-terminated within that size), memchr may read up to OS_MAX_PATH_LEN bytes past the start of VirtualPath and thereby access memory beyond the bounds of the object. For example, calling OS_rmdir on a small buffer or a non-terminated string (e.g. const char s[10] without a NUL within the first OS_MAX_PATH_LEN bytes) can cause memchr to read out-of-bounds. This violates MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rmdir code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1239.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rmdir as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rmdir:\n```c\nint32 OS_rmdir(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirRemove_Impl(local_path);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rmdir code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <string.h>\n\n/* Probe helper: append logs to /tmp/logs/1239.txt.  */\nstatic void probe_log(const char *fmt, ...)\n{\n    /* Best-effort create directory; ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    FILE *f = fopen(\"/tmp/logs/1239.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * Modified OS_rmdir with logging probes. The original control flow\n * and return behavior are preserved. The probes log the pointer value\n * of the input, the address and size of the local_path buffer, the\n * result codes from OS_TranslatePath and OS_DirRemove_Impl, and the\n * translated local path (bounded by the local buffer length).\n */\nint32 OS_rmdir(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Log entry and key state (do not dereference 'path' to avoid\n       reading beyond the caller's object). */\n    probe_log(\"ENTER OS_rmdir: path=%p, local_path_addr=%p, local_path_size=%zu\",\n              (const void *)path,\n              (void *)local_path,\n              (size_t)sizeof(local_path));\n\n    return_code = OS_TranslatePath(path, local_path);\n    probe_log(\"After OS_TranslatePath: return_code=%d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Safely measure and log the translated local_path contents.\n           strnlen is used with the local buffer size to avoid any\n           read beyond the local buffer. This does not read from the\n           caller's 'path' pointer and therefore avoids introducing\n           new out-of-bounds reads. */\n        size_t len = strnlen(local_path, sizeof(local_path));\n        probe_log(\"Translated local_path (len=%zu): '%.*s'\",\n                  len,\n                  (int)len,\n                  local_path);\n\n        return_code = OS_DirRemove_Impl(local_path);\n        probe_log(\"After OS_DirRemove_Impl: return_code=%d\", (int)return_code);\n    }\n    else\n    {\n        probe_log(\"OS_TranslatePath failed; skipping OS_DirRemove_Impl\");\n    }\n\n    probe_log(\"EXIT OS_rmdir: return_code=%d\", (int)return_code);\n    return return_code;\n}\n"
}