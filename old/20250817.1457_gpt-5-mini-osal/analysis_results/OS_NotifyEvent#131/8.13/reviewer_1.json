{
  "user_message": "An agent A claimed that the following OS_NotifyEvent code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_NotifyEvent.\n```c\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    if (OS_SharedGlobalVars.EventHandler != NULL)\n    {\n        status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    return status;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_NotifyEvent takes a non-const pointer parameter (void *data) and forwards it to the EventHandler. If the handler does not need to modify the pointed-to object, the pointer should be const-qualified (const void *) \u2014 therefore the current code (passing a non-const void *) violates MISRA C 2023 Rule 8.13. Recommended fix: change the parameter and the EventHandler prototype to use const void * (unless modification is intended).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_LogNotifyEvent(const char *phase, OS_Event_t event, osal_id_t object_id, void *data, int32 status)\n{\n    FILE *f = fopen(\"/tmp/logs/1051.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Log the phase, event, object id, data pointer, and status. */\n        fprintf(f, \"%s: event=0x%lx object_id=%lu data=%p status=%ld handler=%s\\n\",\n                phase,\n                (unsigned long)event,\n                (unsigned long)object_id,\n                data,\n                (long)status,\n                (OS_SharedGlobalVars.EventHandler != NULL) ? \"present\" : \"NULL\");\n        fclose(f);\n    }\n}\n\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    /* Log entry with initial parameters. */\n    OS_LogNotifyEvent(\"ENTRY\", event, object_id, data, 0);\n\n    if (OS_SharedGlobalVars.EventHandler != NULL)\n    {\n        /* Log that we are about to call the handler, include the pointer being forwarded. */\n        OS_LogNotifyEvent(\"CALL_HANDLER\", event, object_id, data, 0);\n\n        status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n\n        /* Log the status returned by the handler. */\n        OS_LogNotifyEvent(\"AFTER_HANDLER\", event, object_id, data, status);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n\n        /* Log that no handler was present and default success is used. */\n        OS_LogNotifyEvent(\"NO_HANDLER\", event, object_id, data, status);\n    }\n\n    return status;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_NotifyEvent. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 encourages the use of const for pointer targets that are not modified. The OS_NotifyEvent implementation itself does not modify *data \u2014 it simply forwards the pointer to OS_SharedGlobalVars.EventHandler. Whether this is a violation depends on the semantics of the EventHandler API and the rest of the codebase: if the handler and all downstream users only read the pointed-to object, then the pointer type should be const (and both OS_NotifyEvent and the EventHandler prototype should be changed), otherwise a non-const pointer is appropriate.\n\nAgent A\u2019s report assumes the handler does not need to modify the pointee, but provides no evidence from the rest of the codebase to justify that assumption. Therefore the claim that the shown code definitively violates Rule 8.13 is not provable from the snippet alone. The recommended fix (change to const void * and update the EventHandler prototype) is correct only if the handler truly does not modify the data. Also note Rule 8.13 is a \u201cshould\u201d (advisory) style requirement \u2014 a static analyser may flag non-const pointers, but remediation must be guided by API semantics and compatibility.\n\nRecommended action: examine the EventHandler declaration and all implementations/callers. If they only read the data, change the prototypes to const void * (propagating that change through callers). If any handler modifies the data, keep the non-const signature and document why modification is required."
}