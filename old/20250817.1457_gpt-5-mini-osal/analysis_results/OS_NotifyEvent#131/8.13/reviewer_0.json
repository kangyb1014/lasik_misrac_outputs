{
  "user_message": "An agent A claimed that the following OS_NotifyEvent code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_NotifyEvent.\n```c\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n\n    if (OS_SharedGlobalVars.EventHandler != NULL)\n    {\n        status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n    }\n    else\n    {\n        status = OS_SUCCESS;\n    }\n\n    return status;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'void *data' is not const-qualified. If OS_NotifyEvent and the referenced EventHandler only read from the pointed-to data (i.e. they do not modify it), then the parameter should be declared as 'const void *data'. In that common case the current declaration violates MISRA C 2023 Rule 8.13. (If, however, the data is intended to be modified by the handler, the non-const declaration is appropriate and no violation occurs.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_notify_print_hex(FILE *fp, const unsigned char *buf, size_t len)\n{\n    size_t i;\n    for (i = 0; i < len; ++i)\n    {\n        /* Print two-digit hex for each byte */\n        fprintf(fp, \"%02X\", buf[i]);\n        if (i + 1 < len)\n        {\n            fputc(' ', fp);\n        }\n    }\n}\nstatic void os_notify_log_pre(const void *data, size_t nbytes, FILE *fp)\n{\n    fprintf(fp, \"  data_ptr=%p\\n\", data);\n    if (data != NULL && nbytes > 0U)\n    {\n        unsigned char buf[16];\n        size_t to_copy = (nbytes < sizeof(buf)) ? nbytes : sizeof(buf);\n\n        /* Copy bytes for logging; do not modify original data */\n        (void)memcpy(buf, data, to_copy);\n        fprintf(fp, \"  data_before[%u]=\", (unsigned)to_copy);\n        os_notify_print_hex(fp, buf, to_copy);\n        fputc('\\n', fp);\n    }\n}\nstatic void os_notify_log_post_and_compare(const void *data, size_t nbytes, const unsigned char *before, size_t before_len, FILE *fp)\n{\n    if (data == NULL || nbytes == 0U)\n    {\n        return;\n    }\n\n    unsigned char after[16];\n    size_t to_copy = (nbytes < sizeof(after)) ? nbytes : sizeof(after);\n\n    (void)memcpy(after, data, to_copy);\n    fprintf(fp, \"  data_after[%u]=\", (unsigned)to_copy);\n    os_notify_print_hex(fp, after, to_copy);\n    fputc('\\n', fp);\n\n    if (before != NULL && before_len == to_copy)\n    {\n        if (memcmp(before, after, to_copy) != 0)\n        {\n            /* Log byte-wise differences */\n            size_t i;\n            fprintf(fp, \"  data_modified: diffs at byte indexes:\\n\");\n            for (i = 0; i < to_copy; ++i)\n            {\n                if (before[i] != after[i])\n                {\n                    fprintf(fp, \"    idx %u: before=%02X after=%02X\\n\", (unsigned)i, before[i], after[i]);\n                }\n            }\n        }\n        else\n        {\n            fprintf(fp, \"  data_not_modified\\n\");\n        }\n    }\n}\n\nint32 OS_NotifyEvent(OS_Event_t event, osal_id_t object_id, void *data)\n{\n    int32 status;\n    FILE *fp = fopen(\"/tmp/logs/1051.txt\", \"a\");\n\n    if (fp != NULL)\n    {\n        fprintf(fp, \"OS_NotifyEvent: enter\\n\");\n\n        /* Log the handler pointer and object id in pointer form for diagnostics. */\n        fprintf(fp, \"  EventHandler_ptr=%p\\n\", (void *)OS_SharedGlobalVars.EventHandler);\n\n        /* Record a small pre-call snapshot of the data (up to 16 bytes). */\n        unsigned char before_buf[16];\n        size_t before_len = 0U;\n        if (data != NULL)\n        {\n            before_len = sizeof(before_buf);\n            /* If the caller passed less than 16 bytes, the code here still reads up to 16 bytes.\n             * It is expected in normal use that the data pointer is valid for the bytes read.\n             */\n            (void)memcpy(before_buf, data, before_len);\n            fprintf(fp, \"  snapshot_taken (16 bytes)\\n\");\n        }\n\n        os_notify_log_pre(data, (data != NULL) ? (size_t)16U : 0U, fp);\n\n        if (OS_SharedGlobalVars.EventHandler != NULL)\n        {\n            fprintf(fp, \"  calling EventHandler...\\n\");\n            status = OS_SharedGlobalVars.EventHandler(event, object_id, data);\n            fprintf(fp, \"  EventHandler returned status=%ld\\n\", (long)status);\n        }\n        else\n        {\n            fprintf(fp, \"  EventHandler is NULL; default success\\n\");\n            status = OS_SUCCESS;\n        }\n\n        /* Post-call snapshot and comparison to detect whether the handler modified the pointed data. */\n        if (data != NULL)\n        {\n            os_notify_log_post_and_compare(data, (size_t)16U, before_buf, before_len, fp);\n        }\n\n        fprintf(fp, \"OS_NotifyEvent: exit status=%ld\\n\\n\", (long)status);\n        (void)fclose(fp);\n    }\n\n    return status;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_NotifyEvent. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s observation is not provably correct from the snippet alone. MISRA C 2023 Rule 8.13 does encourage using const-qualified pointee types where possible, but whether OS_NotifyEvent violates the rule depends on the intended/actual use of the data pointer and the signature of the EventHandler it calls. If the handler and all callers treat the pointed data as read\u2011only, then the parameter should be const void * (and the handler prototype should also use const), and leaving it as void * would be a violation. However, if the handler (or other callers) may modify the data, the non\u2011const declaration is appropriate and there is no violation. Therefore the report cannot be confirmed without inspecting the EventHandler prototype, its implementations and the API contract/call sites. Recommendation: examine/change the EventHandler declaration and all call sites \u2014 make both OS_NotifyEvent and EventHandler take const void * if the data is truly read\u2011only, otherwise keep void * and document the mutability requirement."
}