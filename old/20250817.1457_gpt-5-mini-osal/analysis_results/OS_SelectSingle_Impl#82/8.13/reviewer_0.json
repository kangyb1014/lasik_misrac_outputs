{
  "user_message": "An agent A claimed that the following OS_SelectSingle_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SelectSingle_Impl.\n```c\nint32 OS_SelectSingle_Impl(const OS_object_token_t *token, uint32 *SelectFlags, int32 msecs)\n{\n    int32                           return_code;\n    fd_set                          wr_set;\n    fd_set                          rd_set;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n     * If called on a stream_id which does not support this\n     * operation, return immediately and do not invoke the system call\n     */\n    if (!impl->selectable)\n    {\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (impl->fd >= FD_SETSIZE)\n    {\n        /* out of range of select() implementation */\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (*SelectFlags != 0)\n    {\n        FD_ZERO(&wr_set);\n        FD_ZERO(&rd_set);\n        if (*SelectFlags & OS_STREAM_STATE_READABLE)\n        {\n            FD_SET(impl->fd, &rd_set);\n        }\n        if (*SelectFlags & OS_STREAM_STATE_WRITABLE)\n        {\n            FD_SET(impl->fd, &wr_set);\n        }\n\n        return_code = OS_DoSelect(impl->fd, &rd_set, &wr_set, msecs);\n\n        if (return_code == OS_SUCCESS)\n        {\n            if (!FD_ISSET(impl->fd, &rd_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_READABLE;\n            }\n            if (!FD_ISSET(impl->fd, &wr_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_WRITABLE;\n            }\n        }\n        else\n        {\n            *SelectFlags = 0;\n        }\n    }\n    else\n    {\n        /* Nothing to check for, return immediately. */\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In OS_SelectSingle_Impl the local pointer variable is declared as a non-const pointer: \"OS_impl_file_internal_record_t *impl;\". The function only reads members of the referenced object (impl->selectable, impl->fd) and does not modify the object, so the pointer could and should be declared as a pointer to const (const OS_impl_file_internal_record_t *impl) to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SelectSingle_Log(const char *event, const void *token_ptr, const void *impl_ptr,\n                                unsigned long select_flags_val, int32_t msecs, int32_t fd, int selectable, int32_t return_code)\n{\n    FILE *fp = fopen(\"/tmp/logs/659.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Simple CSV-style line to capture key state. */\n    fprintf(fp, \"%s, token=%p, impl=%p, select_flags=0x%08lx, msecs=%d, fd=%d, selectable=%d, return=%d\\n\",\n            event, token_ptr, impl_ptr, select_flags_val, (int)msecs, fd, selectable, return_code);\n    fclose(fp);\n}\n\nint32 OS_SelectSingle_Impl(const OS_object_token_t *token, uint32 *SelectFlags, int32 msecs)\n{\n    int32                           return_code;\n    fd_set                          wr_set;\n    fd_set                          rd_set;\n    OS_impl_file_internal_record_t *impl;\n\n    /* Log entry to indicate function start and token value */\n    OS_SelectSingle_Log(\"ENTRY\", token, NULL, (unsigned long)(*SelectFlags), msecs, -1, -1, -999);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /* Log after fetching impl pointer */\n    if (impl != NULL)\n    {\n        OS_SelectSingle_Log(\"AFTER_LOOKUP\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), -998);\n    }\n    else\n    {\n        /* impl NULL - log and proceed as original logic would (may dereference later) */\n        OS_SelectSingle_Log(\"AFTER_LOOKUP_NULL\", token, NULL, (unsigned long)(*SelectFlags), msecs, -1, 0, -997);\n    }\n\n    /*\n     * If called on a stream_id which does not support this\n     * operation, return immediately and do not invoke the system call\n     */\n    if (!impl->selectable)\n    {\n        OS_SelectSingle_Log(\"NOT_SELECTABLE\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, 0, OS_ERR_OPERATION_NOT_SUPPORTED);\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (impl->fd >= FD_SETSIZE)\n    {\n        /* out of range of select() implementation */\n        OS_SelectSingle_Log(\"FD_OUT_OF_RANGE\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), OS_ERR_OPERATION_NOT_SUPPORTED);\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (*SelectFlags != 0)\n    {\n        FD_ZERO(&wr_set);\n        FD_ZERO(&rd_set);\n        if (*SelectFlags & OS_STREAM_STATE_READABLE)\n        {\n            FD_SET(impl->fd, &rd_set);\n        }\n        if (*SelectFlags & OS_STREAM_STATE_WRITABLE)\n        {\n            FD_SET(impl->fd, &wr_set);\n        }\n\n        /* Log before calling OS_DoSelect */\n        OS_SelectSingle_Log(\"BEFORE_DOSELECT\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), -996);\n\n        return_code = OS_DoSelect(impl->fd, &rd_set, &wr_set, msecs);\n\n        /* Log result of select */\n        OS_SelectSingle_Log(\"AFTER_DOSELECT\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), return_code);\n\n        if (return_code == OS_SUCCESS)\n        {\n            if (!FD_ISSET(impl->fd, &rd_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_READABLE;\n            }\n            if (!FD_ISSET(impl->fd, &wr_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_WRITABLE;\n            }\n\n            /* Log final SelectFlags when success */\n            OS_SelectSingle_Log(\"DOSELECT_SUCCESS_FLAGS\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                                (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), return_code);\n        }\n        else\n        {\n            *SelectFlags = 0;\n\n            /* Log final SelectFlags when failure */\n            OS_SelectSingle_Log(\"DOSELECT_FAILURE_FLAGS\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                                (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), return_code);\n        }\n    }\n    else\n    {\n        /* Nothing to check for, return immediately. */\n        return_code = OS_SUCCESS;\n\n        /* Log early-exit with no flags */\n        OS_SelectSingle_Log(\"NO_FLAGS_RETURN\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                            (int32_t)impl->fd, (int)(impl->selectable ? 1 : 0), return_code);\n    }\n\n    /* Final return log */\n    OS_SelectSingle_Log(\"EXIT\", token, (const void *)impl, (unsigned long)(*SelectFlags), msecs,\n                        (impl != NULL) ? (int32_t)impl->fd : -1, (impl != NULL) ? (int)(impl->selectable ? 1 : 0) : 0, return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SelectSingle_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C:2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever the pointed-to object is not modified through that pointer. In OS_SelectSingle_Impl the local pointer impl is only dereferenced for reads (impl->selectable and impl->fd); there are no writes through impl and it is not passed to any callee that requires a non-const pointer. Therefore declaring it as const OS_impl_file_internal_record_t *impl would conform to the rule. Assigning the result of OS_OBJECT_TABLE_GET (which may have a non-const result type) to a const-qualified local pointer is permitted, so there is no practical impediment to making this change. The additional test logging does not affect the assessment \u2014 the code as shown violates the guidance in Rule 8.13 and should be changed or documented with a justified deviation if the const qualification cannot be used for a specific reason."
}