{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectSingle_Impl(const OS_object_token_t *token, uint32 *SelectFlags, int32 msecs)\n{\n    int32                           return_code;\n    fd_set                          wr_set;\n    fd_set                          rd_set;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    /*\n     * If called on a stream_id which does not support this\n     * operation, return immediately and do not invoke the system call\n     */\n    if (!impl->selectable)\n    {\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (impl->fd >= FD_SETSIZE)\n    {\n        /* out of range of select() implementation */\n        return OS_ERR_OPERATION_NOT_SUPPORTED;\n    }\n\n    if (*SelectFlags != 0)\n    {\n        FD_ZERO(&wr_set);\n        FD_ZERO(&rd_set);\n        if (*SelectFlags & OS_STREAM_STATE_READABLE)\n        {\n            FD_SET(impl->fd, &rd_set);\n        }\n        if (*SelectFlags & OS_STREAM_STATE_WRITABLE)\n        {\n            FD_SET(impl->fd, &wr_set);\n        }\n\n        return_code = OS_DoSelect(impl->fd, &rd_set, &wr_set, msecs);\n\n        if (return_code == OS_SUCCESS)\n        {\n            if (!FD_ISSET(impl->fd, &rd_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_READABLE;\n            }\n            if (!FD_ISSET(impl->fd, &wr_set))\n            {\n                *SelectFlags &= ~OS_STREAM_STATE_WRITABLE;\n            }\n        }\n        else\n        {\n            *SelectFlags = 0;\n        }\n    }\n    else\n    {\n        /* Nothing to check for, return immediately. */\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_GenericRead_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedRead']}, 'OS_GenericWrite_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_TimedWrite']}, 'OS_SocketConnect_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketConnect']}, 'OS_SocketAccept_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl', 'OS_SetSocketDefaultFlags_Impl'], 'callers': ['OS_SocketAccept']}, 'OS_SocketRecvFrom_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_SelectSingle_Impl'], 'callers': ['OS_SocketRecvFrom']}, 'OS_SelectSingle': {'callees': ['OS_printf', 'OS_ObjectIdGetById', 'OS_SelectSingle_Impl', 'OS_ObjectIdRelease', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_ObjectIndexFromToken",
    "OS_OBJECT_TABLE_GET (macro)",
    "OS_impl_filehandle_table",
    "OS_impl_file_internal_record_t (structure definition)",
    "OS_DoSelect",
    "FD_ZERO (macro)",
    "FD_SET (macro)",
    "FD_ISSET (macro)",
    "fd_set (type definition)",
    "FD_SETSIZE (macro/constant)"
  ],
  "explanation": "To determine whether OS_SelectSingle_Impl violates the MISRA C rule about well-formed for loops, the analyzer must inspect not only any for statements in this function but also the bodies of any called macros/functions that are executed here (because the rule treats function calls within a for-loop body as part of the body). The listed symbols are required for that inspection:\n\n- OS_ObjectIndexFromToken: The target uses a table-get operation that maps the token to an object index. The implementation may contain for-loops or side-effecting code that could interact with loop counters or global state; inspect to ensure no hidden for-loops or loop-counter modifications are introduced.\n\n- OS_OBJECT_TABLE_GET (macro): The source uses this macro to obtain impl; the macro expansion may inline loops or calls. The macro definition must be checked for any for loops or side effects on objects that could be considered loop counters.\n\n- OS_impl_filehandle_table (global): The macro/OS_ObjectIndexFromToken uses this table; its type/definition may cause macro code to iterate over entries (for loops). Required to understand what the table access expands to and whether it introduces loops.\n\n- OS_impl_file_internal_record_t (structure definition): The code accesses impl->fd and impl->selectable. The struct layout is needed to confirm these fields are simple scalar objects (not e.g., macros or accessor functions) and to ensure no hidden side effects that might affect loop-counter analysis.\n\n- OS_DoSelect: This function is called from within OS_SelectSingle_Impl. If a for-loop existed in OS_SelectSingle_Impl that called OS_DoSelect in its body, the behaviour of that for-loop body would include OS_DoSelect. Even though OS_SelectSingle_Impl has no explicit for, the callee itself may contain for-loops that need checking or may expose patterns relevant to the MISRA checks (e.g., modifying objects that could be used as loop counters in a caller). Inspect OS_DoSelect for any for-loops or modifications to objects reachable from the caller.\n\n- FD_ZERO, FD_SET, FD_ISSET (macros): These macros operate on fd_set objects and could be implemented with loops (for example if they iterate bits). Their definitions must be checked to see if they contain for-loops or modify other objects that could violate the MISRA for-loop clauses if used inside a for statement.\n\n- fd_set (type definition): Knowing the underlying representation of fd_set is necessary to interpret FD_* macro implementations and to determine whether their implementations use for-loops or have side-effects on objects outside the macro.\n\n- FD_SETSIZE (macro/constant): Used in a range check against impl->fd. While not a for-loop symbol per se, its value and how it is defined could affect macro implementations or range-checking logic that might be implemented via loops in macros or inline helpers.\n\nNote: Fundamental scalar types (uint32, int32) and the stream-state constants (OS_STREAM_STATE_READABLE/WRITABLE) are not included because they are simple constants/bitmasks and do not themselves introduce loops; the above symbols focus on places where loops or hidden side effects may be introduced into the execution of OS_SelectSingle_Impl."
}