{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the filename portion is short but OS_MAX_FILE_NAME is larger than the remaining bytes in VirtualPath, memchr(name_ptr, 0, OS_MAX_FILE_NAME) can read past the end of the provided string. Example: VirtualPath = \"/a\" (length 2) and OS_MAX_FILE_NAME = 255. name_ptr points to \"a\\0\" but memchr is asked to scan 255 bytes starting at name_ptr, which may access memory beyond the VirtualPath buffer/object \u2014 undefined behavior and a violation of Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rename code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1367.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rename as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rename:\n```c\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rename code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1367.txt\", \"a\");\n    if (!f) return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Probe: log entry and input parameter snippets/lengths */\n    size_t old_len = 0;\n    size_t new_len = 0;\n\n    if (old != NULL)\n    {\n        old_len = strnlen(old, OS_MAX_LOCAL_PATH_LEN);\n    }\n    if (new != NULL)\n    {\n        new_len = strnlen(new, OS_MAX_LOCAL_PATH_LEN);\n    }\n\n    /* capture short snippets (up to 64 chars) to avoid over-reading */\n    size_t old_snip_len = old_len > 64 ? 64 : old_len;\n    size_t new_snip_len = new_len > 64 ? 64 : new_len;\n    char old_snip[65];\n    char new_snip[65];\n    if (old != NULL)\n    {\n        /* use precision in format to avoid reading beyond the known length */\n        snprintf(old_snip, sizeof(old_snip), \"%.*s\", (int)old_snip_len, old);\n    }\n    else\n    {\n        old_snip[0] = '\\0';\n    }\n    if (new != NULL)\n    {\n        snprintf(new_snip, sizeof(new_snip), \"%.*s\", (int)new_snip_len, new);\n    }\n    else\n    {\n        new_snip[0] = '\\0';\n    }\n\n    log_probe(\"OS_rename ENTER: old=%p len=%zu snip='%s' ; new=%p len=%zu snip='%s'\",\n              (const void *)old, old_len, old_snip, (const void *)new, new_len, new_snip);\n\n    return_code = OS_TranslatePath(old, old_path);\n    log_probe(\"OS_TranslatePath(old) -> return_code=%d\", return_code);\n    if (return_code == OS_SUCCESS)\n    {\n        /* log translated old_path details */\n        size_t trans_old_len = strnlen(old_path, OS_MAX_LOCAL_PATH_LEN);\n        log_probe(\"old_path='%.*s' len=%zu\", (int)(trans_old_len > 128 ? 128 : trans_old_len), old_path, trans_old_len);\n\n        return_code = OS_TranslatePath(new, new_path);\n        log_probe(\"OS_TranslatePath(new) -> return_code=%d\", return_code);\n        if (return_code == OS_SUCCESS)\n        {\n            size_t trans_new_len = strnlen(new_path, OS_MAX_LOCAL_PATH_LEN);\n            log_probe(\"new_path='%.*s' len=%zu\", (int)(trans_new_len > 128 ? 128 : trans_new_len), new_path, trans_new_len);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        log_probe(\"Calling OS_FileRename_Impl('%s','%s')\", old_path, new_path);\n        return_code = OS_FileRename_Impl(old_path, new_path);\n        log_probe(\"OS_FileRename_Impl -> return_code=%d\", return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        log_probe(\"Rename succeeded, iterating open objects to update stream names\");\n\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            /* Log stream object state before potential update */\n            size_t stream_name_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n            log_probe(\"iter token=%u socket_domain=%d stream_name='%.*s' len=%zu\",\n                      (unsigned)iter.token,\n                      (int)stream->socket_domain,\n                      (int)(stream_name_len > 128 ? 128 : stream_name_len),\n                      stream->stream_name,\n                      stream_name_len);\n\n            int cmp = -1;\n            if (old != NULL)\n            {\n                /* safe compare: strcmp is used in original logic; ensure old is not NULL */\n                cmp = strcmp(stream->stream_name, old);\n            }\n            log_probe(\"strcmp(stream->stream_name, old) -> %d\", cmp);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && cmp == 0)\n            {\n                /* log details about the copy about to happen */\n                size_t size_stream = sizeof(stream->stream_name);\n                size_t new_len_local = new ? strnlen(new, size_stream) : 0;\n                log_probe(\"About to strncpy into stream->stream_name: dest_size=%zu new_len=%zu new_snip='%.*s'\",\n                          size_stream,\n                          new_len_local,\n                          (int)(new_len_local > 128 ? 128 : new_len_local),\n                          new ? new : \"\");\n\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                size_t final_len = strnlen(stream->stream_name, sizeof(stream->stream_name));\n                log_probe(\"stream->stream_name updated -> '%.*s' len=%zu\",\n                          (int)(final_len > 128 ? 128 : final_len),\n                          stream->stream_name,\n                          final_len);\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    log_probe(\"OS_rename EXIT: return_code=%d\", return_code);\n    return return_code;\n}\n"
}