{
  "user_message": "An agent A claimed that the following OS_rename code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_rename.\n```c\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileRename_Impl(old_path, new_path);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts a const char * (VirtualPath) to void * when calling OS_ObjectIdGetBySearch: (void *)VirtualPath. This discards the const qualifier and passes a pointer to a non-const type, which violates MISRA C 2023 Rule 8.13. The correct fix is to avoid discarding const (e.g. change the callee to accept const void * or pass a non-const object), or otherwise ensure the const qualifier is preserved.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_rename(const char *old, const char *new)\n{\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n    int32                        return_code;\n    char                         old_path[OS_MAX_LOCAL_PATH_LEN];\n    char                         new_path[OS_MAX_LOCAL_PATH_LEN];\n    FILE                        *log = NULL;\n\n    /* Open probe log file to capture control flow and state for analysis */\n    log = fopen(\"/tmp/logs/1363.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"OS_rename called: old=%p \\\"%s\\\" new=%p \\\"%s\\\"\\n\", (const void *)old, old ? old : \"(null)\", (const void *)new, new ? new : \"(null)\");\n    }\n\n    return_code = OS_TranslatePath(old, old_path);\n    if (log)\n    {\n        fprintf(log, \"After OS_TranslatePath(old): return_code=%d old_path=\\\"%s\\\"\\n\", (int)return_code, return_code == OS_SUCCESS ? old_path : \"(invalid)\");\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TranslatePath(new, new_path);\n        if (log)\n        {\n            fprintf(log, \"After OS_TranslatePath(new): return_code=%d new_path=\\\"%s\\\"\\n\", (int)return_code, return_code == OS_SUCCESS ? new_path : \"(invalid)\");\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (log)\n        {\n            fprintf(log, \"Calling OS_FileRename_Impl with old_path=\\\"%s\\\" new_path=\\\"%s\\\"\\n\", old_path, new_path);\n        }\n\n        return_code = OS_FileRename_Impl(old_path, new_path);\n\n        if (log)\n        {\n            fprintf(log, \"After OS_FileRename_Impl: return_code=%d\\n\", (int)return_code);\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (log)\n        {\n            fprintf(log, \"OS_FileRename_Impl succeeded, iterating object table for LOCAL_OBJID_TYPE\\n\");\n        }\n\n        OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n            if (log)\n            {\n                /* Log each inspected stream: token, pointer, domain, and name */\n                fprintf(log, \"Inspecting stream token=%p stream_ptr=%p socket_domain=%d stream_name=\\\"%s\\\"\\n\",\n                        (const void *)&iter.token, (const void *)stream, (int)stream->socket_domain,\n                        stream->stream_name[0] ? stream->stream_name : \"(empty)\");\n            }\n\n            if (stream->socket_domain == OS_SocketDomain_INVALID && strcmp(stream->stream_name, old) == 0)\n            {\n                if (log)\n                {\n                    fprintf(log, \"Match found: stream->stream_name equals old. Preparing to update stream_name to new (new=%p \\\"%s\\\").\\n\",\n                            (const void *)new, new ? new : \"(null)\");\n                    fprintf(log, \"Before strncpy: stream_ptr=%p stream_name_addr=%p old_addr=%p new_addr=%p\\n\",\n                            (const void *)stream, (void *)stream->stream_name, (const void *)old, (const void *)new);\n                }\n\n                /* Preserve existing behavior: copy new name into stream->stream_name */\n                strncpy(stream->stream_name, new, sizeof(stream->stream_name) - 1);\n                stream->stream_name[sizeof(stream->stream_name) - 1] = 0;\n\n                if (log)\n                {\n                    fprintf(log, \"After strncpy: stream->stream_name=\\\"%s\\\"\\n\", stream->stream_name);\n                }\n            }\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n\n        if (log)\n        {\n            fprintf(log, \"Finished iterating object table.\\n\");\n        }\n    }\n\n    if (log)\n    {\n        fprintf(log, \"OS_rename returning return_code=%d\\n\\n\", (int)return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_rename. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is incorrect for the code shown. MISRA C:2023 Rule 8.13 requires that pointers point to const-qualified types when possible and that the const qualifier not be discarded. In the provided OS_rename implementation there is no cast that discards const qualification:\n\n- The function parameters are declared as const char *old and const char *new. \n- strcmp(stream->stream_name, old) takes a const char* for its second argument \u2014 passing old (const char*) is correct.\n- strncpy(stream->stream_name, new, ...) takes a const char* for src \u2014 passing new (const char*) is correct.\n- There is no call to OS_ObjectIdGetBySearch nor any explicit (void *) cast of a const char* in the supplied code.\n\nAgent A\u2019s scenario describes casting a const char* to void* (e.g. (void *)VirtualPath) which would indeed discard const and violate Rule 8.13, but that cast does not appear in the target OS_rename code presented. If such a cast existed elsewhere, the correct fix would be to change the callee to accept const void* or otherwise avoid discarding the const qualifier. For this function as shown, no Rule 8.13 violation occurs."
}