{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'Data' in UtList_Add is declared as void * and is passed to UtList_NewNode(Data, DataSize). If UtList_NewNode (and other callers) do not modify the buffer pointed to by Data, the pointer should be to a const-qualified type (const void *). Using a non-const void * here violates MISRA C 2023 Rule 8.13. Fix: change the declaration to const void *Data and update UtList_NewNode signature to accept const void *.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UtList_Logf(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2323.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm *tm_info = localtime(&t);\n    if (tm_info != NULL)\n    {\n        char buf[32];\n        (void)strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm_info);\n        fprintf(fp, \"%s \", buf);\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\n\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    UtList_Logf(\"UtList_Add ENTRY: ListHead=%p Data=%p DataSize=%u Tag=%u\",\n                (void *)ListHead, Data, (unsigned)DataSize, (unsigned)Tag);\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    UtList_Logf(\"UtList_Add: UtList_GetHead returned TagHead=%p for Tag=%u\",\n                (void *)TagHead, (unsigned)Tag);\n\n    if (TagHead != NULL)\n    {\n        /* Log a preview of the buffer pointed to by Data (up to 16 bytes) */\n        if (Data != NULL && DataSize > 0u)\n        {\n            unsigned int i;\n            const unsigned char *bytes = (const unsigned char *)Data;\n            unsigned int limit = (DataSize > 16u) ? 16u : (unsigned int)DataSize;\n            char hexbuf[16 * 3 + 1];\n            char *p = hexbuf;\n            for (i = 0u; i < limit; ++i)\n            {\n                (void)sprintf(p, \"%02X \", bytes[i]);\n                p += 3; /* two hex chars + space */\n            }\n            *p = '\\0';\n            UtList_Logf(\"UtList_Add: Data preview (%u bytes): %s\", (unsigned)limit, hexbuf);\n        }\n        else\n        {\n            UtList_Logf(\"UtList_Add: Data is NULL or DataSize is 0 (Data=%p DataSize=%u)\",\n                        Data, (unsigned)DataSize);\n        }\n\n        UtList_Logf(\"UtList_Add: Calling UtList_NewNode(Data=%p, DataSize=%u)\",\n                    Data, (unsigned)DataSize);\n        NewNode = UtList_NewNode(Data, DataSize);\n        UtList_Logf(\"UtList_Add: UtList_NewNode returned NewNode=%p\", (void *)NewNode);\n\n        if (NewNode != NULL)\n        {\n            UtList_Logf(\"UtList_Add: Setting NewNode->Tag = %u (was %u)\",\n                        (unsigned)Tag, (unsigned)NewNode->Tag);\n            NewNode->Tag = Tag;\n\n            UtList_Logf(\"UtList_Add: Inserting NewNode=%p before TagHead=%p\",\n                        (void *)NewNode, (void *)TagHead);\n            UtList_Insert_Before(TagHead, NewNode);\n            UtList_Logf(\"UtList_Add: Insert complete for NewNode=%p\", (void *)NewNode);\n        }\n        else\n        {\n            UtList_Logf(\"UtList_Add: NewNode allocation failed (NULL)\");\n        }\n    }\n    else\n    {\n        UtList_Logf(\"UtList_Add: No TagHead found for Tag=%u; no action taken\", (unsigned)Tag);\n    }\n\n    UtList_Logf(\"UtList_Add EXIT: ListHead=%p\", (void *)ListHead);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): 19 49 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-08-17 15:41:36 UtList_Add: Calling UtList_NewNode(Data=0x7ffe480b9db0, DataSize=64)\n2025-08-17 15:41:36 UtList_Add: UtList_NewNode returned NewNode=0x561d6e417b50\n2025-08-17 15:41:36 UtList_Add: Setting NewNode->Tag = 2 (was 0)\n2025-08-17 15:41:36 UtList_Add: Inserting NewNode=0x561d6e417b50 before TagHead=0x561d6e4178e0\n2025-08-17 15:41:36 UtList_Add: Insert complete for NewNode=0x561d6e417b50\n2025-08-17 15:41:36 UtList_Add EXIT: ListHead=0x561d6e417890\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): E1 49 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-08-17 15:41:36 UtList_Add: Calling UtList_NewNode(Data=0x7ffe480b9db0, DataSize=64)\n2025-08-17 15:41:36 UtList_Add: UtList_NewNode returned NewNode=0x561d6e417bc0\n2025-08-17 15:41:36 UtList_Add: Setting NewNode->Tag = 2 (was 0)\n2025-08-17 15:41:36 UtList_Add: Inserting NewNode=0x561d6e417bc0 before TagHead=0x561d6e4178e0\n2025-08-17 15:41:36 UtList_Add: Insert complete for NewNode=0x561d6e417bc0\n2025-08-17 15:41:36 UtList_Add EXIT: ListHead=0x561d6e417890\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): D1 4B 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-08-17 15:41:36 UtList_Add: Calling UtList_NewNode(Data=0x7ffe480b9db0, DataSize=64)\n2025-08-17 15:41:36 UtList_Add: UtList_NewNode returned NewNode=0x561d6e417c30\n2025-08-17 15:41:36 UtList_Add: Setting NewNode->Tag = 2 (was 0)\n2025-08-17 15:41:36 UtList_Add: Inserting NewNode=0x561d6e417c30 before TagHead=0x561d6e4178e0\n2025-08-17 15:41:36 UtList_Add: Insert complete for NewNode=0x561d6e417c30\n2025-08-17 15:41:36 UtList_Add EXIT: ListHead=0x561d6e417890\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): E1 4C 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-08-17 15:41:36 UtList_Add: Calling UtList_NewNode(Data=0x7ffe480b9db0, DataSize=64)\n2025-08-17 15:41:36 UtList_Add: UtList_NewNode returned NewNode=0x561d6e417ca0\n2025-08-17 15:41:36 UtList_Add: Setting NewNode->Tag = 2 (was 0)\n2025-08-17 15:41:36 UtList_Add: Inserting NewNode=0x561d6e417ca0 before TagHead=0x561d6e4178e0\n2025-08-17 15:41:36 UtList_Add: Insert complete for NewNode=0x561d6e417ca0\n2025-08-17 15:41:36 UtList_Add EXIT: ListHead=0x561d6e417890\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): BD 4E 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-08-17 15:41:36 UtList_Add: Calling UtList_NewNode(Data=0x7ffe480b9db0, DataSize=64)\n2025-08-17 15:41:36 UtList_Add: UtList_NewNode returned NewNode=0x561d6e417d10\n2025-08-17 15:41:36 UtList_Add: Setting NewNode->Tag = 2 (was 0)\n2025-08-17 15:41:36 UtList_Add: Inserting NewNode=0x561d6e417d10 before TagHead=0x561d6e4178e0\n2025-08-17 15:41:36 UtList_Add: Insert complete for NewNode=0x561d6e417d10\n2025-08-17 15:41:36 UtList_Add EXIT: ListHead=0x561d6e417890\n2025-08-17 15:41:36 UtList_Add ENTRY: ListHead=0x561d6e417890 Data=0x7ffe480b9db0 DataSize=64 Tag=2\n2025-08-17 15:41:36 UtList_Add: UtList_GetHead returned TagHead=0x561d6e4178e0 for Tag=2\n2025-08-17 15:41:36 UtList_Add: Data preview (16 bytes): 99 50 74 45 1D 56 00 00 8D 55 74 45 1D 56 00 00 \n2025-0\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's report is not correct. MISRA Rule 8.13 requires a pointer to be const-qualified when the pointed-to object is not modified; however the provided exhaustive test output shows the buffer at Data (same address 0x7ffe480b9db0) changing across consecutive calls (Data preview first bytes: 0x19, 0xE1, 0xD1, 0xE1, 0xBD, 0x99, ...). That demonstrates the pointed-to object is being modified by code reachable from UtList_Add (for example UtList_NewNode or other callers), so the pointer cannot safely be declared const void *. Therefore the claim that UtList_Add violates Rule 8.13 (and should be changed to const void *) is incorrect."
}