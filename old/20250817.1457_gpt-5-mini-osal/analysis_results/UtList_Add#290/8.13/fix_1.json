{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef uint32_t uint32;\nstruct UtListNode\n{\n    struct UtListNode *Next;\n    uint32 Tag;\n    void *Data;\n    uint32 DataSize;\n};\ntypedef struct UtListNode\n{\n    struct UtListNode *Next;\n    uint32 Tag;\n    void *Data;\n    uint32 DataSize;\n} UtListNode_t;\ntypedef struct\n{\n    UtListNode_t *Head;\n} UtListHead_t;\nstatic void UtList_Add_Log(const char *stage, UtListHead_t *ListHead, const void *Data, uint32 DataSize, uint32 Tag, const char *note)\n{\n    FILE *fp = fopen(\"/tmp/logs/2323.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Log the stage, list and pointer state. Use uintptr_t to print pointer values portably. */\n    fprintf(fp, \"Stage: %s\\n\", stage);\n    fprintf(fp, \"  ListHead=%p, ListHead->Head=%p\\n\", (void *)ListHead,\n            (void *)(ListHead ? (void *)ListHead->Head : NULL));\n    fprintf(fp, \"  Data=%p, DataSize=%u, Tag=%u\\n\", (void *)Data, (unsigned)DataSize, (unsigned)Tag);\n    if (note != NULL)\n    {\n        fprintf(fp, \"  Note: %s\\n\", note);\n    }\n    fprintf(fp, \"---\\n\");\n    fclose(fp);\n}\n\nstatic UtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    (void)Tag; /* Tag unused in this simplified stub */\n    return (ListHead != NULL) ? ListHead->Head : NULL;\n}\nstatic UtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    UtListNode_t *node = (UtListNode_t *)malloc(sizeof(UtListNode_t));\n    if (node != NULL)\n    {\n        node->Next = NULL;\n        node->Tag = 0u;\n        node->Data = Data;\n        node->DataSize = DataSize;\n    }\n    return node;\n}\nstatic void UtList_Insert_Before(UtListNode_t *TagHead, UtListNode_t *NewNode)\n{\n    if ((TagHead == NULL) || (NewNode == NULL))\n    {\n        return;\n    }\n    /* For this stub, insert NewNode immediately after TagHead. */\n    NewNode->Next = TagHead->Next;\n    TagHead->Next = NewNode;\n}\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    /* Log entry into the function and initial state */\n    UtList_Add_Log(\"enter\", ListHead, (const void *)Data, DataSize, Tag, \"entered UtList_Add\");\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n\n    /* Log the result of getting the tag head */\n    if (TagHead != NULL)\n    {\n        UtList_Add_Log(\"before_newnode\", ListHead, (const void *)Data, DataSize, Tag, \"TagHead found, about to create new node\");\n\n        NewNode      = UtList_NewNode(Data, DataSize);\n\n        /* Log after creating new node, including the returned node pointer and the Data pointer passed in */\n        UtList_Add_Log(\"after_newnode\", ListHead, (const void *)Data, DataSize, Tag, NewNode ? \"NewNode allocated\" : \"NewNode allocation failed\");\n\n        if (NewNode != NULL)\n        {\n            NewNode->Tag = Tag;\n\n            /* Log before insertion */\n            UtList_Add_Log(\"before_insert\", ListHead, (const void *)Data, DataSize, Tag, \"about to insert NewNode before TagHead\");\n\n            UtList_Insert_Before(TagHead, NewNode);\n\n            /* Log after insertion */\n            UtList_Add_Log(\"after_insert\", ListHead, (const void *)Data, DataSize, Tag, \"insertion complete\");\n        }\n    }\n    else\n    {\n        /* Log that there was no TagHead for this tag */\n        UtList_Add_Log(\"no_taghead\", ListHead, (const void *)Data, DataSize, Tag, \"no TagHead found; nothing inserted\");\n    }\n\n    /* Log exit */\n    UtList_Add_Log(\"exit\", ListHead, (const void *)Data, DataSize, Tag, \"exiting UtList_Add\");\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:124:16: error: redefinition of 'struct UtListNode'\n  124 | typedef struct UtListNode\n      |                ^~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:117:8: note: originally defined here\n  117 | struct UtListNode\n      |        ^~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:130:3: error: conflicting types for 'UtListNode_t'; have 'struct UtListNode'\n  130 | } UtListNode_t;\n      |   ^~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:62:3: note: previous declaration of 'UtListNode_t' with type 'UtListNode_t' {aka 'struct UtListNodeTag'}\n   62 | } UtListNode_t;\n      |   ^~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:134:3: error: conflicting types for 'UtListHead_t'; have 'struct <anonymous>'\n  134 | } UtListHead_t;\n      |   ^~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:68:3: note: previous declaration of 'UtListHead_t' with type 'UtListHead_t'\n   68 | } UtListHead_t;\n      |   ^~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c: In function 'UtList_Extract':\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:170:23: error: 'struct UtListNode' has no member named 'Prev'\n  170 |     ExistingNode->Next->Prev = ExistingNode->Prev;\n      |                       ^~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:170:44: error: 'UtListNode_t' {aka 'struct UtListNode'} has no member named 'Prev'\n  170 |     ExistingNode->Next->Prev = ExistingNode->Prev;\n      |                                            ^~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:171:17: error: 'UtListNode_t' {aka 'struct UtListNode'} has no member named 'Prev'\n  171 |     ExistingNode->Prev->Next = ExistingNode->Next;\n      |                 ^~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:173:17: error: 'UtListNode_t' {aka 'struct UtListNode'} has no member named 'Prev'\n  173 |     ExistingNode->Prev       = ExistingNode;\n      |                 ^~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c: At top level:\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:190:6: error: conflicting types for 'UtList_Add'; have 'void(UtListHead_t *, void *, uint32,  uint32)' {aka 'void(UtListHead_t *, void *, unsigned int,  unsigned int)'}\n  190 | void UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n      |      ^~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:91:6: note: previous declaration of 'UtList_Add' with type 'void(UtListHead_t *, void *, uint32,  uint32)' {aka 'void(UtListHead_t *, void *, unsigned int,  unsigned int)'}\n   91 | void UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag);\n      |      ^~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:234:6: error: conflicting types for 'UtList_DeleteNode'; have 'void(UtListNode_t *)' {aka 'void(struct UtListNode *)'}\n  234 | void UtList_DeleteNode(UtListNode_t *DeleteNode)\n      |      ^~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:95:6: note: previous declaration of 'UtList_DeleteNode' with type 'void(UtListNode_t *)' {aka 'void(struct UtListNodeTag *)'}\n   95 | void UtList_DeleteNode(UtListNode_t *DeleteNode);\n      |      ^~~~~~~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:245:6: error: conflicting types for 'UtList_IsEmpty'; have '_Bool(UtListNode_t *)' {aka '_Bool(struct UtListNode *)'}\n  245 | bool UtList_IsEmpty(UtListNode_t *TagHead)\n      |      ^~~~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:98:6: note: previous declaration of 'UtList_IsEmpty' with type '_Bool(UtListNode_t *)' {aka '_Bool(struct UtListNodeTag *)'}\n   98 | bool UtList_IsEmpty(UtListNode_t *TagHead);\n      |      ^~~~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:250:22: error: conflicting types for 'UtList_GetHead'; have 'UtListNode_t *(UtListHead_t *, uint32)' {aka 'struct UtListNode *(UtListHead_t *, unsigned int)'}\n  250 | static UtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n      |                      ^~~~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:101:15: note: previous declaration of 'UtList_GetHead' with type 'UtListNode_t *(UtListHead_t *, uint32)' {aka 'struct UtListNodeTag *(UtListHead_t *, unsigned int)'}\n  101 | UtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag);\n      |               ^~~~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:257:15: error: conflicting types for 'UtList_GetNext'; have 'UtListNode_t *(UtListNode_t *)' {aka 'struct UtListNode *(struct UtListNode *)'}\n  257 | UtListNode_t *UtList_GetNext(UtListNode_t *ListNode)\n      |               ^~~~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:104:15: note: previous declaration of 'UtList_GetNext' with type 'UtListNode_t *(UtListNode_t *)' {aka 'struct UtListNodeTag *(struct UtListNodeTag *)'}\n  104 | UtListNode_t *UtList_GetNext(UtListNode_t *ListNode);\n      |               ^~~~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:262:7: error: conflicting types for 'UtList_GetObject'; have 'void *(UtListNode_t *)' {aka 'void *(struct UtListNode *)'}\n  262 | void *UtList_GetObject(UtListNode_t *ListNode)\n      |       ^~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:107:7: note: previous declaration of 'UtList_GetObject' with type 'void *(UtListNode_t *)' {aka 'void *(struct UtListNodeTag *)'}\n  107 | void *UtList_GetObject(UtListNode_t *ListNode);\n      |       ^~~~~~~~~~~~~~~~\n/tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:267:6: error: conflicting types for 'UtList_IsEnd'; have '_Bool(UtListNode_t *, UtListNode_t *)' {aka '_Bool(struct UtListNode *, struct UtListNode *)'}\n  267 | bool UtList_IsEnd(UtListNode_t *TagHead, UtListNode_t *ListNode)\n      |      ^~~~~~~~~~~~\nIn file included from /tmp/tmpplzjx57q/src/ut_assert/src/utlist.c:39:\n/tmp/tmpplzjx57q/src/ut_assert/inc/utlist.h:110:6: note: previous declaration of 'UtList_IsEnd' with type '_Bool(UtListNode_t *, UtListNode_t *)' {aka '_Bool(struct UtListNodeTag *, struct UtListNodeTag *)'}\n  110 | bool UtList_IsEnd(UtListNode_t *TagHead, UtListNode_t *ListNode);\n      |      ^~~~~~~~~~~~\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:90: ut_assert/CMakeFiles/ut_assert.dir/src/utlist.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UtList_Add as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n\ntypedef uint32_t uint32;\n\n/* Define the node/tag names to match the public API that other files\n   would expect. This provides the Prev pointer (which the later code\n   uses) and avoids conflicting with any other header in this isolated\n   test. */\ntypedef struct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    uint32 Tag;\n    void *Data;\n    uint32 DataSize;\n} UtListNode_t;\n\ntypedef struct\n{\n    UtListNode_t *Head;\n} UtListHead_t;\n\nstatic void UtList_Add_Log(const char *stage, UtListHead_t *ListHead, const void *Data, uint32 DataSize, uint32 Tag, const char *note)\n{\n    FILE *fp = fopen(\"/tmp/logs/2323.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Log the stage, list and pointer state. Use uintptr_t to print pointer values portably. */\n    fprintf(fp, \"Stage: %s\\n\", stage);\n    fprintf(fp, \"  ListHead=%p, ListHead->Head=%p\\n\", (void *)ListHead,\n            (void *)(ListHead ? (void *)ListHead->Head : NULL));\n    fprintf(fp, \"  Data=%p, DataSize=%u, Tag=%u\\n\", (void *)Data, (unsigned)DataSize, (unsigned)Tag);\n    if (note != NULL)\n    {\n        fprintf(fp, \"  Note: %s\\n\", note);\n    }\n    fprintf(fp, \"---\\n\");\n    fclose(fp);\n}\n\nstatic UtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    (void)Tag; /* Tag unused in this simplified stub */\n    return (ListHead != NULL) ? ListHead->Head : NULL;\n}\n\nstatic UtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    UtListNode_t *node = (UtListNode_t *)malloc(sizeof(UtListNode_t));\n    if (node != NULL)\n    {\n        node->Next = NULL;\n        node->Prev = NULL;\n        node->Tag = 0u;\n        node->Data = Data;\n        node->DataSize = DataSize;\n    }\n    return node;\n}\n\nstatic void UtList_Insert_Before(UtListNode_t *TagHead, UtListNode_t *NewNode)\n{\n    if ((TagHead == NULL) || (NewNode == NULL))\n    {\n        return;\n    }\n\n    /* If Prev is not set (NULL), treat the list as a singly-linked list\n       and insert NewNode immediately after TagHead. Otherwise insert in\n       a doubly-linked fashion before TagHead. */\n    if (TagHead->Prev == NULL)\n    {\n        NewNode->Next = TagHead->Next;\n        NewNode->Prev = TagHead;\n        TagHead->Next = NewNode;\n        if (NewNode->Next != NULL)\n        {\n            NewNode->Next->Prev = NewNode;\n        }\n    }\n    else\n    {\n        NewNode->Next = TagHead;\n        NewNode->Prev = TagHead->Prev;\n        TagHead->Prev->Next = NewNode;\n        TagHead->Prev = NewNode;\n    }\n}\n\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    /* Log entry into the function and initial state */\n    UtList_Add_Log(\"enter\", ListHead, (const void *)Data, DataSize, Tag, \"entered UtList_Add\");\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n\n    /* Log the result of getting the tag head */\n    if (TagHead != NULL)\n    {\n        UtList_Add_Log(\"before_newnode\", ListHead, (const void *)Data, DataSize, Tag, \"TagHead found, about to create new node\");\n\n        NewNode      = UtList_NewNode(Data, DataSize);\n\n        /* Log after creating new node, including the returned node pointer and the Data pointer passed in */\n        UtList_Add_Log(\"after_newnode\", ListHead, (const void *)Data, DataSize, Tag, NewNode ? \"NewNode allocated\" : \"NewNode allocation failed\");\n\n        if (NewNode != NULL)\n        {\n            NewNode->Tag = Tag;\n\n            /* Log before insertion */\n            UtList_Add_Log(\"before_insert\", ListHead, (const void *)Data, DataSize, Tag, \"about to insert NewNode before TagHead\");\n\n            UtList_Insert_Before(TagHead, NewNode);\n\n            /* Log after insertion */\n            UtList_Add_Log(\"after_insert\", ListHead, (const void *)Data, DataSize, Tag, \"insertion complete\");\n        }\n    }\n    else\n    {\n        /* Log that there was no TagHead for this tag */\n        UtList_Add_Log(\"no_taghead\", ListHead, (const void *)Data, DataSize, Tag, \"no TagHead found; nothing inserted\");\n    }\n\n    /* Log exit */\n    UtList_Add_Log(\"exit\", ListHead, (const void *)Data, DataSize, Tag, \"exiting UtList_Add\");\n}\n",
  "explanation": "Removed the duplicate/conflicting type definitions and replaced them with a single consistent definition matching the expected public API: UtListNode_t now has Next and Prev members. This prevents the previous redefinition errors and provides the Prev member that later code uses. The insert helper now handles both singly- and doubly-linked cases (if Prev is NULL it does a safe singly-linked insertion), preserving the original UtList_Add logic while avoiding NULL dereferences. Standard headers were added so the file compiles standalone."
}