{
  "user_message": "An agent A claimed that the following UtList_Add code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtList_Add.\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer parameter 'Data' is not const-qualified even though the function body does not modify the object it points to (it only passes Data to UtList_NewNode). Per MISRA C 2023 Rule 8.13, Data should be declared as 'const void *Data' unless underlying callees require a non-const pointer. (The 'ListHead' parameter is correctly non-const because the list is being modified.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef uint32_t uint32;\nstruct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    uint32 Tag;\n    void *Data;\n    uint32 DataSize;\n};\ntypedef struct UtListNodeTag\n{\n    struct UtListNodeTag *Next;\n    struct UtListNodeTag *Prev;\n    uint32 Tag;\n    void *Data;\n    uint32 DataSize;\n} UtListNode_t;\ntypedef struct\n{\n    UtListNode_t *Head;\n} UtListHead_t;\nstatic void UtList_Add_Log(const char *stage, UtListHead_t *ListHead, const void *Data, uint32 DataSize, uint32 Tag, const char *note)\n{\n    FILE *fp = fopen(\"/tmp/logs/2323.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Log the stage, list and pointer state. Use uintptr_t to print pointer values portably. */\n    fprintf(fp, \"Stage: %s\\n\", stage);\n    fprintf(fp, \"  ListHead=%p, ListHead->Head=%p\\n\", (void *)ListHead,\n            (void *)(ListHead ? (void *)ListHead->Head : NULL));\n    fprintf(fp, \"  Data=%p, DataSize=%u, Tag=%u\\n\", (void *)Data, (unsigned)DataSize, (unsigned)Tag);\n    if (note != NULL)\n    {\n        fprintf(fp, \"  Note: %s\\n\", note);\n    }\n    fprintf(fp, \"---\\n\");\n    fclose(fp);\n}\n\nstatic UtListNode_t *UtList_GetHead(UtListHead_t *ListHead, uint32 Tag)\n{\n    (void)Tag; /* Tag unused in this simplified stub */\n    return (ListHead != NULL) ? ListHead->Head : NULL;\n}\nstatic UtListNode_t *UtList_NewNode(void *Data, uint32 DataSize)\n{\n    UtListNode_t *node = (UtListNode_t *)malloc(sizeof(UtListNode_t));\n    if (node != NULL)\n    {\n        node->Next = NULL;\n        node->Prev = NULL;\n        node->Tag = 0u;\n        node->Data = Data;\n        node->DataSize = DataSize;\n    }\n    return node;\n}\nstatic void UtList_Insert_Before(UtListNode_t *TagHead, UtListNode_t *NewNode)\n{\n    if ((TagHead == NULL) || (NewNode == NULL))\n    {\n        return;\n    }\n\n    /* If Prev is not set (NULL), treat the list as a singly-linked list\n       and insert NewNode immediately after TagHead. Otherwise insert in\n       a doubly-linked fashion before TagHead. */\n    if (TagHead->Prev == NULL)\n    {\n        NewNode->Next = TagHead->Next;\n        NewNode->Prev = TagHead;\n        TagHead->Next = NewNode;\n        if (NewNode->Next != NULL)\n        {\n            NewNode->Next->Prev = NewNode;\n        }\n    }\n    else\n    {\n        NewNode->Next = TagHead;\n        NewNode->Prev = TagHead->Prev;\n        TagHead->Prev->Next = NewNode;\n        TagHead->Prev = NewNode;\n    }\n}\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    /* Log entry into the function and initial state */\n    UtList_Add_Log(\"enter\", ListHead, (const void *)Data, DataSize, Tag, \"entered UtList_Add\");\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n\n    /* Log the result of getting the tag head */\n    if (TagHead != NULL)\n    {\n        UtList_Add_Log(\"before_newnode\", ListHead, (const void *)Data, DataSize, Tag, \"TagHead found, about to create new node\");\n\n        NewNode      = UtList_NewNode(Data, DataSize);\n\n        /* Log after creating new node, including the returned node pointer and the Data pointer passed in */\n        UtList_Add_Log(\"after_newnode\", ListHead, (const void *)Data, DataSize, Tag, NewNode ? \"NewNode allocated\" : \"NewNode allocation failed\");\n\n        if (NewNode != NULL)\n        {\n            NewNode->Tag = Tag;\n\n            /* Log before insertion */\n            UtList_Add_Log(\"before_insert\", ListHead, (const void *)Data, DataSize, Tag, \"about to insert NewNode before TagHead\");\n\n            UtList_Insert_Before(TagHead, NewNode);\n\n            /* Log after insertion */\n            UtList_Add_Log(\"after_insert\", ListHead, (const void *)Data, DataSize, Tag, \"insertion complete\");\n        }\n    }\n    else\n    {\n        /* Log that there was no TagHead for this tag */\n        UtList_Add_Log(\"no_taghead\", ListHead, (const void *)Data, DataSize, Tag, \"no TagHead found; nothing inserted\");\n    }\n\n    /* Log exit */\n    UtList_Add_Log(\"exit\", ListHead, (const void *)Data, DataSize, Tag, \"exiting UtList_Add\");\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct. MISRA C 2023 R8.13 urges that pointers should be const-qualified when possible, but you cannot sensibly change a parameter to const if the function must pass that pointer to callees or store it into locations typed as non-const without changing those other declarations. In the shown code UtList_Add forwards Data to UtList_NewNode (whose prototype takes void * and stores the pointer into node->Data which is a void *). That means the non-const type is required by the existing callee/storage types; making Data \"const void *\" would either require casts when calling UtList_NewNode or require changing the signatures and storage (UtList_NewNode and node->Data) to accept const, which the report did not demonstrate. Therefore, based on the provided code and callees, there is no standalone violation of R8.13 in UtList_Add. If the intent is that stored data is genuinely immutable, the proper fix is to propagate const throughout the API (change UtList_NewNode and node->Data to accept/hold const void *), but absent that change the agent's claim is incorrect."
}