{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nAllocNode->Node.Data = &AllocNode[1]; sets Data to a pointer one-past-the-end of the union object. Later memcpy(AllocNode->Node.Data, Data, DataSize) writes DataSize bytes starting at that address. Because the pointer is derived as a one-past-end pointer to the union object, the memcpy may access bytes beyond the bounds of the object referenced by that pointer (the union), which violates MISRA C 2023 Rule 21.17. Use (char *)AllocNode + sizeof(*AllocNode) or define a trailing flexible array member to obtain a pointer into the allocated region instead.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtList_Add code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2327.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtList_Add as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtList_Add:\n```c\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode;\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n    if (TagHead != NULL)\n    {\n        NewNode      = UtList_NewNode(Data, DataSize);\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n    }\n}\n```\n</target_code>\nPlease provide the modified UtList_Add code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe helper to log control flow and state for UtList_Add\n * Writes to /tmp/logs/2327.txt in append mode. */\nstatic void UtList_Add_Log(const void *ListHead, const void *Data, uint32_t DataSize, uint32_t Tag,\n                           const void *TagHead, const void *NewNodeBefore, const void *NewNodeAfter)\n{\n    FILE *f = fopen(\"/tmp/logs/2327.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n\n    fprintf(f, \"UtList_Add ENTER\\n\");\n    fprintf(f, \"  ListHead = %p\\n\", ListHead);\n    fprintf(f, \"  Data     = %p\\n\", Data);\n    fprintf(f, \"  DataSize = %u\\n\", (unsigned)DataSize);\n    fprintf(f, \"  Tag      = %u\\n\", (unsigned)Tag);\n    fprintf(f, \"  TagHead  = %p\\n\", TagHead);\n    fprintf(f, \"  NewNode before allocation = %p\\n\", NewNodeBefore);\n    fprintf(f, \"  NewNode after allocation  = %p\\n\", NewNodeAfter);\n    fprintf(f, \"UtList_Add LOG END\\n\\n\");\n\n    fclose(f);\n}\n\nvoid UtList_Add(UtListHead_t *ListHead, void *Data, uint32 DataSize, uint32 Tag)\n{\n    UtListNode_t *TagHead;\n    UtListNode_t *NewNode = NULL;\n\n    /* Log entry state (no NewNode yet) */\n    UtList_Add_Log(ListHead, Data, DataSize, Tag, NULL, NULL, NULL);\n\n    TagHead = UtList_GetHead(ListHead, Tag);\n\n    /* Log found TagHead */\n    UtList_Add_Log(ListHead, Data, DataSize, Tag, TagHead, NULL, NULL);\n\n    if (TagHead != NULL)\n    {\n        /* Allocate new node (original logic preserved) */\n        NewNode = UtList_NewNode(Data, DataSize);\n\n        /* Prepare detailed logging about the newly allocated node. Avoid dereferencing NewNode if NULL. */\n        if (NewNode != NULL)\n        {\n            void *node_data_ptr = NULL;\n\n            /* Try to observe Node.Data if available. This preserves original logic but does not alter it. */\n            /* Access guarded by NewNode != NULL to avoid further faults. */\n            /* The exact field names are used as in the original codebase (UtListNode_t assumed). */\n            /* The following is only observational and must not change program state. */\n            node_data_ptr = (void *)(&NewNode->Node.Data);\n\n            /* Compute a pointer one-past-the-end of the UtListNode_t object for comparison/logging. */\n            void *one_past = (void *)((char *)NewNode + sizeof(*NewNode));\n\n            /* Open a separate log entry with more details to help reproduce the violation scenario. */\n            FILE *f = fopen(\"/tmp/logs/2327.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"UtList_Add allocation details:\\n\");\n                fprintf(f, \"  NewNode = %p\\n\", (void *)NewNode);\n                fprintf(f, \"  &NewNode->Node.Data (address of field) = %p\\n\", node_data_ptr);\n                fprintf(f, \"  one-past-NewNode (computed) = %p\\n\", one_past);\n\n                /* If Node.Data itself is a pointer stored in the structure, try to print its value.\n                 * This reads the pointer value stored in the Node.Data field, not the memory it points to. */\n                /* To avoid undefined behavior in case of different layouts, perform a memcpy into a local pointer-sized buffer. */\n                {\n                    void *stored_data_ptr = NULL;\n                    /* Copy the raw bytes of the Node.Data field into stored_data_ptr if sizes match.\n                     * This is a conservative read of the field's bytes; it does not dereference the stored pointer. */\n                    (void)memcpy(&stored_data_ptr, &NewNode->Node.Data, sizeof(stored_data_ptr));\n                    fprintf(f, \"  value of NewNode->Node.Data (as pointer) = %p\\n\", stored_data_ptr);\n\n                    if (stored_data_ptr == one_past)\n                    {\n                        fprintf(f, \"  NOTE: NewNode->Node.Data == one-past-NewNode -> potential one-past-end pointer derived from allocation\\n\");\n                    }\n                    else if (stored_data_ptr == (void *)((char *)NewNode + sizeof(*NewNode)))\n                    {\n                        fprintf(f, \"  NOTE: NewNode->Node.Data equals (char*)NewNode + sizeof(*NewNode)\\n\");\n                    }\n                }\n\n                fprintf(f, \"  Data (input) = %p\\n\", Data);\n                fprintf(f, \"  DataSize = %u\\n\", (unsigned)DataSize);\n                fprintf(f, \"  Tag = %u\\n\", (unsigned)Tag);\n                fprintf(f, \"End allocation details\\n\\n\");\n                fclose(f);\n            }\n        }\n\n        /* Preserve original behavior exactly: set tag and insert node. */\n        NewNode->Tag = Tag;\n        UtList_Insert_Before(TagHead, NewNode);\n\n        /* Final log after insertion */\n        UtList_Add_Log(ListHead, Data, DataSize, Tag, TagHead, NULL, NewNode);\n    }\n}\n"
}