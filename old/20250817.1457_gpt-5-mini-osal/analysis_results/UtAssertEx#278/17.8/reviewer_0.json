{
  "user_message": "An agent A claimed that the following UtAssertEx code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of UtAssertEx.\n```c\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        CaseType = UTASSERT_CASETYPE_PASS;\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat, va);\n    va_end(va);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    return Expression;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function assigns to the parameter CaseType (CaseType = UTASSERT_CASETYPE_PASS;) which modifies a function parameter. This is a direct violation of MISRA C 2023 Rule 17.8. Fix: make a local copy (e.g., UtAssert_CaseType_t LocalCaseType = CaseType;) and modify/use that local variable instead of assigning to the parameter.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned int uint32;\ntypedef unsigned char uint8;\nenum UtAssert_CaseType_e\n{\n    UTASSERT_CASETYPE_PASS = 0,\n    UTASSERT_CASETYPE_FAIL = 1,\n    UTASSERT_CASETYPE_MAX  = 2\n};\ntypedef enum UtAssert_CaseType_e UtAssert_CaseType_t;\ntypedef struct\n{\n    uint32 TotalTestCases;\n    uint32 CaseCount[UTASSERT_CASETYPE_MAX];\n} UT_SegmentCounters_t;\ntypedef struct\n{\n    uint32 TestSegmentCount;\n} UT_TotalCounters_t;\nvoid UT_BSP_Lock(void) { /* noop for probe */ }\nvoid UT_BSP_Unlock(void) { /* noop for probe */ }\nstatic void LogProbe(const char *stage, bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line)\n{\n    FILE *f = fopen(\"/tmp/logs/2229.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"[Probe] Stage=%s Expression=%s CaseType=%u File=%s Line=%u\\n\",\n            stage, Expression ? \"true\" : \"false\", (unsigned)CaseType,\n            File ? File : \"(null)\", (unsigned)Line);\n    fclose(f);\n}\nstatic void LogCaseCount(const char *stage, UtAssert_CaseType_t CaseType, uint32 Count)\n{\n    FILE *f = fopen(\"/tmp/logs/2229.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"[Probe] Stage=%s CaseType=%u NewCount=%u\\n\", stage, (unsigned)CaseType, (unsigned)Count);\n    fclose(f);\n}\nstatic void LogFinal(const char *stage, const char *File, uint32 Line, uint32 TestSegmentCount, uint32 TotalTestCases,\n                     UtAssert_CaseType_t CaseType, uint32 Segment, const char *FinalMessage)\n{\n    FILE *f = fopen(\"/tmp/logs/2229.txt\", \"a\");\n    if (!f) return;\n    fprintf(f, \"[Probe] Stage=%s File=%s Line=%u TestSeg=%u Total=%u CaseType=%u Segment=%u FinalMessage=\\\"%s\\\"\\n\",\n            stage, File ? File : \"(null)\", (unsigned)Line, (unsigned)TestSegmentCount, (unsigned)TotalTestCases,\n            (unsigned)CaseType, (unsigned)Segment, FinalMessage ? FinalMessage : \"\");\n    fclose(f);\n}\n\nvoid UtAssert_DoReport(const char *File, uint32 Line, uint32 TestSegmentCount, uint32 TotalTestCases,\n                       UtAssert_CaseType_t CaseType, uint32 Segment, const char *FinalMessage)\n{\n    FILE *f = fopen(\"/tmp/logs/2229.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"UtAssert_DoReport: File=%s Line=%u TestSeg=%u Total=%u CaseType=%u Segment=%u Message=\\\"%s\\\"\\n\",\n                File ? File : \"(null)\", (unsigned)Line, (unsigned)TestSegmentCount, (unsigned)TotalTestCases,\n                (unsigned)CaseType, (unsigned)Segment, FinalMessage ? FinalMessage : \"\");\n        fclose(f);\n    }\n}\nvoid UtAssert_SetContext(UtAssert_CaseType_t Context)\n{\n    /* Simple context storage for completeness */\n    if ((uint32)Context < UTASSERT_CASETYPE_MAX)\n    {\n        UT_SegmentCounters.CaseCount[(uint32)Context] = UT_SegmentCounters.CaseCount[(uint32)Context];\n        (void)Context; /* no-op but keeps the function meaningful for linkage */\n    }\n}\nUtAssert_CaseType_t UtAssert_GetContext(void)\n{\n    /* Return a reasonable default */\n    return UTASSERT_CASETYPE_PASS;\n}\nconst char *UtAssert_GetCaseTypeAbbrev(UtAssert_CaseType_t CaseType)\n{\n    switch (CaseType)\n    {\n        case UTASSERT_CASETYPE_PASS: return \"P\";\n        case UTASSERT_CASETYPE_FAIL: return \"F\";\n        default: return \"?\";\n    }\n}\nbool UtAssertEx(bool Expression, UtAssert_CaseType_t CaseType, const char *File, uint32 Line, const char *MessageFormat,\n                ...)\n{\n    va_list va;\n    char    FinalMessage[256];\n    uint32  TestSegmentCount;\n    uint32  TotalTestCases;\n\n    /* Log entry into function with initial parameter values */\n    LogProbe(\"ENTRY\", Expression, CaseType, File, Line);\n\n    UT_BSP_Lock();\n\n    ++UT_SegmentCounters.TotalTestCases;\n\n    if (Expression)\n    {\n        /* Log state immediately before modifying the parameter CaseType (captures the violation) */\n        LogProbe(\"BEFORE_ASSIGN\", Expression, CaseType, File, Line);\n\n        /* This assignment modifies the function parameter (the violation scenario to be evidenced) */\n        CaseType = UTASSERT_CASETYPE_PASS;\n\n        /* Log state immediately after modifying the parameter */\n        LogProbe(\"AFTER_ASSIGN\", Expression, CaseType, File, Line);\n    }\n\n    if ((uint32)CaseType < UTASSERT_CASETYPE_MAX)\n    {\n        ++UT_SegmentCounters.CaseCount[(uint32)CaseType];\n        /* Log the updated case count for the selected CaseType */\n        LogCaseCount(\"INCREMENT_CASECOUNT\", CaseType, UT_SegmentCounters.CaseCount[(uint32)CaseType]);\n    }\n\n    TestSegmentCount = 1 + UT_TotalCounters.TestSegmentCount;\n    TotalTestCases   = UT_SegmentCounters.TotalTestCases;\n\n    UT_BSP_Unlock();\n\n    va_start(va, MessageFormat);\n    vsnprintf(FinalMessage, sizeof(FinalMessage), MessageFormat ? MessageFormat : \"\", va);\n    va_end(va);\n\n    /* Log the compiled final message and counters before reporting */\n    LogFinal(\"BEFORE_REPORT\", File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    UtAssert_DoReport(File, Line, TestSegmentCount, TotalTestCases, CaseType, CurrentSegment, FinalMessage);\n\n    /* Log exit from function including the CaseType that was passed back into report */\n    LogProbe(\"EXIT\", Expression, CaseType, File, Line);\n\n    return Expression;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C:2023 Rule 17.8 states that a function parameter shall not be modified. In the provided UtAssertEx implementation the statement\n    CaseType = UTASSERT_CASETYPE_PASS;\ndirectly assigns to the parameter CaseType (even though it is passed by value and thus only modifies the local parameter object). MISRA forbids modifying parameter objects themselves, so this is a violation. The suggested remedy (make a local copy, e.g. UtAssert_CaseType_t LocalCaseType = CaseType; and use/modify LocalCaseType) is appropriate."
}