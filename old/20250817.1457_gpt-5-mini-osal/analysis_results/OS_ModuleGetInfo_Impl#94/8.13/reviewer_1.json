{
  "user_message": "An agent A claimed that the following OS_ModuleGetInfo_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ModuleGetInfo_Impl.\n```c\nint32 OS_ModuleGetInfo_Impl(const OS_object_token_t *token, OS_module_prop_t *module_prop)\n{\n    /*\n     * Limiting strictly to POSIX-defined API means there is no defined\n     * method to get information about a module contents.\n     *\n     * The \"dlinfo()\" function might return some interesting information\n     * but this is actually a non-posix extension / platform-defined API.\n     *\n     * This returns success - although there is no information to add here,\n     * the parent/shared layer information is still valid.\n     */\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function OS_ModuleGetInfo_Impl accepts module_prop as a non-const pointer but the implementation does not modify the pointed-to object. According to MISRA C 2023 Rule 8.13, the pointer should be qualified as pointing to const (e.g. const OS_module_prop_t *module_prop) when modification is not required. Unless the non-const signature is mandated by an external API/override, this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ModuleGetInfo_Log(const void *token_ptr, const void *module_prop_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/755.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging fails, do not affect original logic. */\n        return;\n    }\n\n    fprintf(f, \"OS_ModuleGetInfo_Impl invoked\\n\");\n    fprintf(f, \"  token address: %p\\n\", token_ptr);\n    fprintf(f, \"  module_prop address: %p\\n\", module_prop_ptr);\n    fprintf(f, \"  module_prop_is_null: %d\\n\", (module_prop_ptr == NULL) ? 1 : 0);\n    fprintf(f, \"  Note: function does not modify *module_prop (intentional for this test)\\n\");\n    fprintf(f, \"---\\n\");\n\n    fclose(f);\n}\n\nint32 OS_ModuleGetInfo_Impl(const OS_object_token_t *token, OS_module_prop_t *module_prop)\n{\n    /* Log entry and state for reproducible evidence that module_prop is not modified. */\n    OS_ModuleGetInfo_Log((const void *)token, (const void *)module_prop);\n\n    /*\n     * Limiting strictly to POSIX-defined API means there is no defined\n     * method to get information about a module contents.\n     *\n     * The \"dlinfo()\" function might return some interesting information\n     * but this is actually a non-posix extension / platform-defined API.\n     *\n     * This returns success - although there is no information to add here,\n     * the parent/shared layer information is still valid.\n     */\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ModuleGetInfo_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 R8.13 recommends that pointers should point to const-qualified types where possible. Agent A\u2019s observation (this implementation does not modify *module_prop) is factually correct, but the rule applies to the type in the function\u2019s declared interface, not to a particular implementation body in isolation. OS_ModuleGetInfo_Impl is an implementation of an external/overridden interface (the OSAL hook); its signature must match the externally declared prototype. If that prototype declares module_prop as a non-const pointer, the implementation cannot change it to const without breaking the required linkage/signature. In that case the implementation is not in violation because the non-const is mandated by the external API. The provided runtime logging does not affect the static rule determination. Conclusion: the report is incomplete \u2014 this is only a MISRA violation if the function prototype is free to be changed; if the signature is mandated by the external interface, it is not a violation. Recommended actions: (a) if the prototype is not externally constrained, change the parameter to const OS_module_prop_t *module_prop; (b) if it is constrained, document the rationale (external API/override) and suppress/justify the deviation per project rules."
}