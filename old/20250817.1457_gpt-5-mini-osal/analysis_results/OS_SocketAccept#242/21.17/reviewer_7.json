{
  "user_message": "An agent A claimed that the following OS_SocketAccept code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAccept.\n```c\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If sock->stream_name contains no terminating NUL within its full size, OS_strnlen(sock->stream_name, sizeof(sock->stream_name)) will return len == sizeof(sock->stream_name). The subsequent call snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port) therefore passes a pointer to one-past-end of the array and a length of 0. While snprintf(\u2026,0) is specified not to write characters, passing a one-past-end pointer into a library function that might attempt to access the pointer can result in an access beyond the object bounds on some implementations (undefined behaviour). Thus the use can lead to out-of-bounds access in this corner case.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic size_t probe_strnlen_safe(const char *s, size_t max)\n{\n    size_t i;\n    if (s == NULL)\n    {\n        return 0U;\n    }\n    for (i = 0U; i < max; ++i)\n    {\n        if (s[i] == '\\0')\n        {\n            return i;\n        }\n    }\n    return max;\n}\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1943.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Log entry and parameters */\n    probe_log(\"OS_SocketAccept ENTRY: sock_id=%ld, connsock_id=%p, Addr=%p, timeout=%ld\",\n              (long)sock_id, (void *)connsock_id, (void *)Addr, (long)timeout);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    probe_log(\"OS_ObjectIdGetById returned %ld for sock_id=%ld\", (long)return_code, (long)sock_id);\n\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        probe_log(\"sock_record=%p, sock=%p\", (void *)sock_record, (void *)sock);\n\n        if (sock != NULL)\n        {\n            /* Try to safely measure the stream_name length up to its storage size */\n            size_t name_size = 0U;\n            size_t name_len  = 0U;\n\n            /* Guard access in case the structure does not have the field as expected */\n            /* This assumes OS_stream_internal_record_t has a member stream_name that is an array. */\n            /* Compute size only if it is available at compile time; otherwise skip. */\n            name_size = sizeof(sock->stream_name);\n            name_len  = probe_strnlen_safe(sock->stream_name, name_size);\n\n            probe_log(\"sock->stream_name addr=%p, name_size=%zu, name_len=%zu\", (void *)sock->stream_name, name_size, name_len);\n\n            /* Log a small sample of the bytes to help reproduce the missing NUL scenario */\n            {\n                size_t i;\n                size_t sample = (name_size < 32U) ? name_size : 32U;\n                probe_log(\"stream_name sample (up to %zu bytes):\", sample);\n                for (i = 0U; i < sample; ++i)\n                {\n                    probe_log(\"  [%zu] = 0x%02x\", i, (unsigned int)((unsigned char)sock->stream_name[i]));\n                }\n            }\n\n            if (name_len == name_size)\n            {\n                /* This is the corner case described: no terminating NUL within full size */\n                probe_log(\"CORNER CASE: stream_name has NO terminating NUL within its full size (%zu). Subsequent calls that compute &stream_name[len] may produce a pointer one-past-end.\", name_size);\n            }\n        }\n        else\n        {\n            probe_log(\"sock pointer is NULL after OS_ObjectIdGetById\");\n        }\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            probe_log(\"Incorrect socket type: %d (expected %d)\", (int)sock->socket_type, (int)OS_SocketType_STREAM);\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            probe_log(\"Incorrect socket state: stream_state=0x%08lx\", (unsigned long)sock->stream_state);\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            probe_log(\"Preparing to allocate new connection object (sock_token=%p)\", (void *)&sock_token);\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            probe_log(\"OS_ObjectIdAllocateNew returned %ld, conn_token=%p\", (long)return_code, (void *)&conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                probe_log(\"Calling OS_SocketAccept_Impl with sock_token=%p conn_token=%p\", (void *)&sock_token, (void *)&conn_token);\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n                probe_log(\"OS_SocketAccept_Impl returned %ld\", (long)return_code);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    probe_log(\"About to call OS_CreateSocketName for conn_token=%p\", (void *)&conn_token);\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    probe_log(\"OS_CreateSocketName returned; conn_record->name_entry=%p, conn->stream_name=%p\", (void *)conn_record->name_entry, (void *)conn->stream_name);\n\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n\n                    /* Log the newly created connection's stream_name contents and size */\n                    if (conn != NULL)\n                    {\n                        size_t c_name_size = sizeof(conn->stream_name);\n                        size_t c_name_len  = probe_strnlen_safe(conn->stream_name, c_name_size);\n                        probe_log(\"conn->stream_name addr=%p, size=%zu, len=%zu\", (void *)conn->stream_name, c_name_size, c_name_len);\n                    }\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n                probe_log(\"OS_ObjectIdFinalizeNew returned %ld, connsock_id=%p\", (long)return_code, (void *)connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    probe_log(\"OS_SocketAccept EXIT: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketAccept. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claimed violation is not supported by the code shown. The OS_SocketAccept implementation in the target_code does not call any of the <string.h> functions (no memcpy/memset/strnlen/snprintf etc. are present in the snippet). The agent\u2019s scenario describes a pattern (using strnlen to get len == sizeof(array) and then calling snprintf(&array[len], sizeof(array)-len, ...)) that could be problematic, but that pattern is not present in the provided OS_SocketAccept code \u2014 the only related call present is OS_CreateSocketName(...), whose implementation was not supplied.\n\nIf the actual string-handling that agent A describes exists inside OS_CreateSocketName (or some other function invoked from here), then the scenario is plausible: calling snprintf with a destination pointer equal to one-past-end of the array and a length of 0 can be unsafe under MISRA 21.17 because it may allow a library function to access memory beyond the object bounds (MISRA requires that use of <string.h> functions shall not result in accesses beyond object bounds). Whether that is UB in practice depends on the C library implementation, but MISRA forbids relying on such implementation details.\n\nConclusion: the report as applied to the code snippet provided (OS_SocketAccept) is not correct. To verify the concern, inspect the implementation of OS_CreateSocketName (or any other function that actually constructs stream_name) and ensure it never passes a one-past-end pointer to a string-handling function (or guard with a check like if (len < sizeof(array)) before calling snprintf)."
}