{
  "user_message": "An agent A claimed that the following OS_SocketAccept code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAccept.\n```c\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'sock_record' is declared as OS_common_record_t * but is only used for read-only access in this function (e.g. its name_entry is passed to OS_CreateSocketName). According to MISRA C 2023 Rule 8.13 it should be declared as a pointer to const (const OS_common_record_t *sock_record) so the pointer points to a const-qualified type whenever possible. Thus the current assignment via OS_OBJECT_TABLE_GET(&\u2026) violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SocketAccept_Probe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1939.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /* Log entry and parameters */\n    OS_SocketAccept_Probe(\"OS_SocketAccept ENTRY: sock_id=%lu, connsock_id_ptr=%p, Addr_ptr=%p, timeout=%ld\",\n                          (unsigned long)sock_id, (void *)connsock_id, (void *)Addr, (long)timeout);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    OS_SocketAccept_Probe(\"OS_ObjectIdGetById returned %ld for sock_id=%lu\", (long)return_code, (unsigned long)sock_id);\n\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        OS_SocketAccept_Probe(\"After lookup: sock_record=%p, sock=%p\", (void *)sock_record, (void *)sock);\n\n        if (sock != NULL)\n        {\n            OS_SocketAccept_Probe(\"sock fields: socket_type=%ld, stream_state=0x%lx, socket_domain=%ld\",\n                                  (long)sock->socket_type, (unsigned long)sock->stream_state, (long)sock->socket_domain);\n        }\n\n        if (sock_record != NULL)\n        {\n            /* name_entry may be an array; attempt to print if non-null */\n            const char *ne = \"(null)\";\n            if (sock_record->name_entry != NULL)\n            {\n                ne = sock_record->name_entry;\n            }\n            OS_SocketAccept_Probe(\"sock_record->name_entry=%s\", ne);\n        }\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            OS_SocketAccept_Probe(\"Socket type incorrect: expected STREAM, got %ld\", (long)sock->socket_type);\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            OS_SocketAccept_Probe(\"Socket state incorrect: stream_state=0x%lx\", (unsigned long)sock->stream_state);\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            OS_SocketAccept_Probe(\"Proceeding to allocate new connection object\");\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            OS_SocketAccept_Probe(\"OS_ObjectIdAllocateNew returned %ld\", (long)return_code);\n\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                OS_SocketAccept_Probe(\"Allocated conn_record=%p, conn=%p\", (void *)conn_record, (void *)conn);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                OS_SocketAccept_Probe(\"Calling OS_SocketAccept_Impl with sock_token and conn_token, Addr_ptr=%p, timeout=%ld\",\n                                      (void *)Addr, (long)timeout);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n                OS_SocketAccept_Probe(\"OS_SocketAccept_Impl returned %ld\", (long)return_code);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    /* Log sock_record state that is used read-only here to provide evidence for Rule 8.13 */\n                    if (sock_record != NULL)\n                    {\n                        const char *ne = \"(null)\";\n                        if (sock_record->name_entry != NULL)\n                        {\n                            ne = sock_record->name_entry;\n                        }\n\n                        OS_SocketAccept_Probe(\"About to call OS_CreateSocketName using sock_record->name_entry=%s (address=%p)\", ne, (void *)sock_record->name_entry);\n                    }\n                    else\n                    {\n                        OS_SocketAccept_Probe(\"About to call OS_CreateSocketName but sock_record is NULL\");\n                    }\n\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n\n                    /* Log result of CreateSocketName and updated conn_record state */\n                    if (conn_record != NULL)\n                    {\n                        const char *cs = \"(null)\";\n                        if (conn_record->name_entry != NULL)\n                        {\n                            cs = conn_record->name_entry;\n                        }\n                        OS_SocketAccept_Probe(\"conn_record->name_entry set to %s\", cs);\n                    }\n\n                    if (conn != NULL)\n                    {\n                        OS_SocketAccept_Probe(\"Setting conn->stream_state CONNECTED (before=0x%lx)\", (unsigned long)conn->stream_state);\n                    }\n\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n\n                    OS_SocketAccept_Probe(\"After connect: conn->stream_state=0x%lx, conn->stream_name=%s\",\n                                          (unsigned long)conn->stream_state,\n                                          (conn->stream_name != NULL) ? conn->stream_name : \"(null)\");\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n                OS_SocketAccept_Probe(\"OS_ObjectIdFinalizeNew completed, return_code=%ld, connsock_id(now)=%p (value may be encoded)\", (long)return_code, (void *)connsock_id);\n            }\n        }\n\n        OS_SocketAccept_Probe(\"Releasing sock_token and exiting (intermediate return_code=%ld)\", (long)return_code);\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    OS_SocketAccept_Probe(\"OS_SocketAccept EXIT: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketAccept. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown function sock_record is only read (its name_entry is read and passed to OS_CreateSocketName) and never used to modify the pointed-to OS_common_record_t object. According to MISRA C 2023 Rule 8.13 such a pointer should be declared to point to a const-qualified type (e.g. const OS_common_record_t *sock_record). Assigning the result of OS_OBJECT_TABLE_GET (which yields a non-const pointer) to a local const-qualified pointer is allowed and does not require changes to the object table API. Note that conn_record must remain non-const because the code writes conn_record->name_entry. The empty test log is unrelated to the correctness of the static rule assessment. Therefore the reported Rule 8.13 violation is valid."
}