{
  "user_message": "An agent A claimed that the following OS_SocketAccept code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAccept.\n```c\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer variable 'sock' is declared as OS_stream_internal_record_t *sock and is used only for read access in this function (e.g. if (sock->socket_type != OS_SocketType_STREAM)). According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. In this function 'sock' could be declared as const OS_stream_internal_record_t *sock (the OS_OBJECT_TABLE_GET result can be assigned to a pointer-to-const), avoiding accidental modification and satisfying the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SocketAccept_LogState(const char *stage,\n                                     const void *sock_ptr,\n                                     const void *conn_ptr,\n                                     const void *sock_record_ptr,\n                                     const void *conn_record_ptr,\n                                     const void *sock_token_ptr,\n                                     const void *conn_token_ptr,\n                                     int32_t return_code,\n                                     unsigned long socket_domain,\n                                     unsigned long socket_type,\n                                     unsigned long stream_state)\n{\n    FILE *f = fopen(\"/tmp/logs/1939.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_SocketAccept] stage=%s return_code=%d\\n\", stage, (int)return_code);\n    fprintf(f, \"  sock_ptr=%p conn_ptr=%p\\n\", sock_ptr, conn_ptr);\n    fprintf(f, \"  sock_record_ptr=%p conn_record_ptr=%p\\n\", sock_record_ptr, conn_record_ptr);\n    fprintf(f, \"  sock_token_ptr=%p conn_token_ptr=%p\\n\", sock_token_ptr, conn_token_ptr);\n    fprintf(f, \"  socket_domain=%lu socket_type=%lu stream_state=0x%lx\\n\",\n            socket_domain, socket_type, stream_state);\n    fprintf(f, \"----------------------------------------\\n\");\n\n    fclose(f);\n}\n\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        /* Log state immediately after retrieving the socket */\n        OS_SocketAccept_LogState(\"after_get\",\n                                 (const void *)sock,\n                                 (const void *)conn,\n                                 (const void *)sock_record,\n                                 (const void *)conn_record,\n                                 (const void *)&sock_token,\n                                 (const void *)&conn_token,\n                                 return_code,\n                                 (unsigned long)sock->socket_domain,\n                                 (unsigned long)sock->socket_type,\n                                 (unsigned long)sock->stream_state);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            /* Log incorrect type */\n            OS_SocketAccept_LogState(\"incorrect_type\",\n                                     (const void *)sock,\n                                     (const void *)conn,\n                                     (const void *)sock_record,\n                                     (const void *)conn_record,\n                                     (const void *)&sock_token,\n                                     (const void *)&conn_token,\n                                     OS_ERR_INCORRECT_OBJ_TYPE,\n                                     (unsigned long)sock->socket_domain,\n                                     (unsigned long)sock->socket_type,\n                                     (unsigned long)sock->stream_state);\n\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            /* Log incorrect state */\n            OS_SocketAccept_LogState(\"incorrect_state\",\n                                     (const void *)sock,\n                                     (const void *)conn,\n                                     (const void *)sock_record,\n                                     (const void *)conn_record,\n                                     (const void *)&sock_token,\n                                     (const void *)&conn_token,\n                                     OS_ERR_INCORRECT_OBJ_STATE,\n                                     (unsigned long)sock->socket_domain,\n                                     (unsigned long)sock->socket_type,\n                                     (unsigned long)sock->stream_state);\n\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            /* Log before allocation */\n            OS_SocketAccept_LogState(\"before_allocate_conn\",\n                                     (const void *)sock,\n                                     (const void *)conn,\n                                     (const void *)sock_record,\n                                     (const void *)conn_record,\n                                     (const void *)&sock_token,\n                                     (const void *)&conn_token,\n                                     return_code,\n                                     (unsigned long)sock->socket_domain,\n                                     (unsigned long)sock->socket_type,\n                                     (unsigned long)sock->stream_state);\n\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                /* Log after conn memset (should be zeroed) */\n                OS_SocketAccept_LogState(\"after_memset_conn\",\n                                         (const void *)sock,\n                                         (const void *)conn,\n                                         (const void *)sock_record,\n                                         (const void *)conn_record,\n                                         (const void *)&sock_token,\n                                         (const void *)&conn_token,\n                                         return_code,\n                                         (unsigned long)0,\n                                         (unsigned long)0,\n                                         (unsigned long)0);\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                /* Log after copying domain/type */\n                OS_SocketAccept_LogState(\"after_copy_domain_type\",\n                                         (const void *)sock,\n                                         (const void *)conn,\n                                         (const void *)sock_record,\n                                         (const void *)conn_record,\n                                         (const void *)&sock_token,\n                                         (const void *)&conn_token,\n                                         return_code,\n                                         (unsigned long)conn->socket_domain,\n                                         (unsigned long)conn->socket_type,\n                                         (unsigned long)conn->stream_state);\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                /* Log the result of the platform accept implementation */\n                OS_SocketAccept_LogState(\"after_impl\",\n                                         (const void *)sock,\n                                         (const void *)conn,\n                                         (const void *)sock_record,\n                                         (const void *)conn_record,\n                                         (const void *)&sock_token,\n                                         (const void *)&conn_token,\n                                         return_code,\n                                         (unsigned long)sock->socket_domain,\n                                         (unsigned long)sock->socket_type,\n                                         (unsigned long)sock->stream_state);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n\n                    /* Log after successful connection */\n                    OS_SocketAccept_LogState(\"connected\",\n                                             (const void *)sock,\n                                             (const void *)conn,\n                                             (const void *)sock_record,\n                                             (const void *)conn_record,\n                                             (const void *)&sock_token,\n                                             (const void *)&conn_token,\n                                             return_code,\n                                             (unsigned long)conn->socket_domain,\n                                             (unsigned long)conn->socket_type,\n                                             (unsigned long)conn->stream_state);\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n\n                /* Log after finalizing the new object id */\n                OS_SocketAccept_LogState(\"after_finalize\",\n                                         (const void *)sock,\n                                         (const void *)conn,\n                                         (const void *)sock_record,\n                                         (const void *)conn_record,\n                                         (const void *)&sock_token,\n                                         (const void *)&conn_token,\n                                         return_code,\n                                         (unsigned long)conn->socket_domain,\n                                         (unsigned long)conn->socket_type,\n                                         (unsigned long)conn->stream_state);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    /* Final log before returning */\n    OS_SocketAccept_LogState(\"exit\",\n                             (const void *)sock,\n                             (const void *)conn,\n                             (const void *)sock_record,\n                             (const void *)conn_record,\n                             (const void *)&sock_token,\n                             (const void *)&conn_token,\n                             return_code,\n                             (unsigned long)(sock ? sock->socket_domain : 0),\n                             (unsigned long)(sock ? sock->socket_type : 0),\n                             (unsigned long)(sock ? sock->stream_state : 0));\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketAccept. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In this function the local variable 'sock' is only used for read access (reads of socket_type, socket_domain, stream_state and being used as a source for copies). There are no writes performed through the 'sock' pointer in this function, so it can be declared as a pointer to const (const OS_stream_internal_record_t *sock) without preventing any required behaviour. Assigning the non-const result of OS_OBJECT_TABLE_GET to a pointer-to-const is allowed and would satisfy MISRA C 2023 Rule 8.13. (Note: there are unrelated issues in the function \u2014 e.g. reading fields through 'sock' after OS_ObjectIdRelease may be unsafe \u2014 but those do not affect the 8.13 diagnosis.)"
}