{
  "user_message": "An agent A claimed that the following OS_SocketAccept code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketAccept.\n```c\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'OS_stream_internal_record_t *sock' is only used for read-only accesses in OS_SocketAccept (e.g. sock->socket_type, sock->stream_state, sock->socket_domain) and is never used to modify the pointed object. According to MISRA C 2023 Rule 8.13 it should be declared as 'const OS_stream_internal_record_t *sock' to indicate and enforce read-only usage.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SocketAccept_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1939.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketAccept(osal_id_t sock_id, osal_id_t *connsock_id, OS_SockAddr_t *Addr, int32 timeout)\n{\n    OS_common_record_t *         sock_record;\n    OS_common_record_t *         conn_record;\n    OS_stream_internal_record_t *sock;\n    OS_stream_internal_record_t *conn;\n    OS_object_token_t            sock_token;\n    OS_object_token_t            conn_token;\n    int32                        return_code;\n\n    /* Log entry and parameters */\n    OS_SocketAccept_Log(\"Enter OS_SocketAccept: sock_id=%ld, connsock_id=%p, Addr=%p, timeout=%ld\",\n                        (long)sock_id, (void *)connsock_id, (void *)Addr, (long)timeout);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(Addr);\n    OS_CHECK_POINTER(connsock_id);\n\n    /*\n     * Note: setting \"connrecord\" here avoids a false warning\n     * from static analysis tools about the value being\n     * possibly used uninitialized (it cannot be, because\n     * return_code is checked, and return_code is only\n     * set to OS_SUCCESS when connrecord is also initialized)\n     */\n    conn_record = NULL;\n    sock_record = NULL;\n    sock        = NULL;\n    conn        = NULL;\n    memset(&sock_token, 0, sizeof(sock_token));\n    memset(&conn_token, 0, sizeof(conn_token));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &sock_token);\n    OS_SocketAccept_Log(\"OS_ObjectIdGetById returned %ld\", (long)return_code);\n    if (return_code == OS_SUCCESS)\n    {\n        sock_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, sock_token);\n        sock        = OS_OBJECT_TABLE_GET(OS_stream_table, sock_token);\n\n        /* Log the retrieved sock internal state */\n        if (sock != NULL)\n        {\n            OS_SocketAccept_Log(\"sock pointer obtained: socket_type=%ld, socket_domain=%ld, stream_state=0x%lx, sock_record=%p\",\n                                (long)sock->socket_type, (long)sock->socket_domain, (unsigned long)sock->stream_state, (void *)sock_record);\n        }\n        else\n        {\n            OS_SocketAccept_Log(\"sock pointer is NULL after OS_ObjectIdGetById\");\n        }\n\n        if (sock->socket_type != OS_SocketType_STREAM)\n        {\n            /* Socket must be of the STREAM variety */\n            OS_SocketAccept_Log(\"Rejecting: incorrect socket type (%ld) - expected %ld\", (long)sock->socket_type, (long)OS_SocketType_STREAM);\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((sock->stream_state & (OS_STREAM_STATE_BOUND | OS_STREAM_STATE_CONNECTED)) != OS_STREAM_STATE_BOUND)\n        {\n            /* Socket must be bound but not connected */\n            OS_SocketAccept_Log(\"Rejecting: incorrect socket state (stream_state=0x%lx)\", (unsigned long)sock->stream_state);\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            /* Now create a unique ID for the connection */\n            OS_SocketAccept_Log(\"Creating new connection object token\");\n            return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, NULL, &conn_token);\n            OS_SocketAccept_Log(\"OS_ObjectIdAllocateNew returned %ld\", (long)return_code);\n            if (return_code == OS_SUCCESS)\n            {\n                conn_record = OS_OBJECT_TABLE_GET(OS_global_stream_table, conn_token);\n                conn        = OS_OBJECT_TABLE_GET(OS_stream_table, conn_token);\n\n                /* Incr the refcount to record the fact that an operation is pending on this */\n                memset(conn, 0, sizeof(OS_stream_internal_record_t));\n\n                /* Log copying domain/type from listening socket to connection */\n                OS_SocketAccept_Log(\"Before copy: conn=%p (domain=%ld, type=%ld), copying from sock (domain=%ld, type=%ld)\",\n                                    (void *)conn, (long)conn->socket_domain, (long)conn->socket_type,\n                                    (long)sock->socket_domain, (long)sock->socket_type);\n\n                conn->socket_domain = sock->socket_domain;\n                conn->socket_type   = sock->socket_type;\n\n                OS_SocketAddrInit_Impl(Addr, sock->socket_domain);\n\n                OS_SocketAccept_Log(\"Calling OS_SocketAccept_Impl with sock_token and conn_token\");\n                return_code = OS_SocketAccept_Impl(&sock_token, &conn_token, Addr, timeout);\n                OS_SocketAccept_Log(\"OS_SocketAccept_Impl returned %ld\", (long)return_code);\n\n                if (return_code == OS_SUCCESS)\n                {\n                    /* Generate an entry name based on the remote address */\n                    OS_CreateSocketName(&conn_token, Addr, sock_record->name_entry);\n                    conn_record->name_entry = conn->stream_name;\n                    conn->stream_state |= OS_STREAM_STATE_CONNECTED;\n\n                    OS_SocketAccept_Log(\"Accept succeeded: conn->stream_state now 0x%lx, conn_record=%p, conn->stream_name=%s\",\n                                        (unsigned long)conn->stream_state, (void *)conn_record,\n                                        conn->stream_name ? conn->stream_name : \"(null)\");\n                }\n\n                return_code = OS_ObjectIdFinalizeNew(return_code, &conn_token, connsock_id);\n                OS_SocketAccept_Log(\"OS_ObjectIdFinalizeNew returned %ld, connsock_id=%p (out param)\", (long)return_code, (void *)connsock_id);\n            }\n        }\n\n        OS_ObjectIdRelease(&sock_token);\n        OS_SocketAccept_Log(\"Released sock_token and exiting critical section\");\n    }\n\n    OS_SocketAccept_Log(\"Exit OS_SocketAccept with return_code=%ld\", (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketAccept. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In the shown OS_SocketAccept implementation the local variable sock is only used for read-only accesses (sock->socket_type, sock->stream_state, sock->socket_domain) and is never used to modify the pointed object. Therefore, per MISRA C 2023 Rule 8.13 a pointer that can be const-qualified should be so declared. Changing the declaration to const OS_stream_internal_record_t *sock is safe here (conversion from non-const to const pointer is permitted) and would express the intended read-only usage.\n\nNotes/edge-cases: if OS_OBJECT_TABLE_GET or other code later (not shown) relied on sock being a non-const pointer (for example passing it to a function that takes a non-const pointer or writing through it), then const qualification would not be possible; no such usage appears in the provided function. The empty test log is irrelevant to the static rule assessment."
}