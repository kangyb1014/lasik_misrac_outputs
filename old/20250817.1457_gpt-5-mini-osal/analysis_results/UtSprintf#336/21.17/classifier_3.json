{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UtSprintf:\n```c\nchar *UtSprintf(const char *Spec, ...)\n{\n    va_list                     Args;\n    static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n    static uint32               TextIndex = 0;\n\n    ++TextIndex;\n    if (TextIndex >= UT_SNPRINTF_MAX_BUFS)\n        TextIndex = 0;\n\n    va_start(Args, Spec);\n    vsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n    va_end(Args);\n\n    return Buf[TextIndex].Text;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UtSprintf:\ntypedef struct\n{\n    char Text[UT_SNPRINTF_BUF_SIZE];\n} UT_Snprintf_Buffer_t\n...\n#define UT_SNPRINTF_MAX_BUFS 10\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the declaration 'static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];' by itself does not violate MISRA C 2023 Rule 21.17. In UtSprintf the buffer is indexed using TextIndex which is wrapped to the range 0..UT_SNPRINTF_MAX_BUFS-1, and vsnprintf is called with the size argument sizeof(Buf[TextIndex].Text), so writes are bounded to the buffer size. (Only a configuration error such as UT_SNPRINTF_MAX_BUFS == 0 would create a problem, but that is outside the shown code.)"
}