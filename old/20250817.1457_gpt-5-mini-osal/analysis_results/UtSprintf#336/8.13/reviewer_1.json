{
  "user_message": "An agent A claimed that the following UtSprintf code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtSprintf.\n```c\nchar *UtSprintf(const char *Spec, ...)\n{\n    va_list                     Args;\n    static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n    static uint32               TextIndex = 0;\n\n    ++TextIndex;\n    if (TextIndex >= UT_SNPRINTF_MAX_BUFS)\n        TextIndex = 0;\n\n    va_start(Args, Spec);\n    vsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n    va_end(Args);\n\n    return Buf[TextIndex].Text;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function returns a non-const char * that points to an internal static char array (Buf[TextIndex].Text). There is no need for callers to modify that buffer and the pointer type could be changed to const char * (e.g. const char *UtSprintf(...)) to express non\u2011modifiability. Therefore the fragment violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void WriteLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2691.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\nchar *UtSprintf(const char *Spec, ...)\n{\n    va_list                     Args;\n    static UT_Snprintf_Buffer_t Buf[UT_SNPRINTF_MAX_BUFS];\n    static uint32               TextIndex = 0;\n\n    /* Log entry and incoming parameters */\n    WriteLog(\"UtSprintf ENTER: Spec_ptr=%p Spec=\\\"%s\\\"\", (const void *)Spec, (Spec != NULL) ? Spec : \"<NULL>\");\n    WriteLog(\"TextIndex before increment=%u\", (unsigned)TextIndex);\n\n    ++TextIndex;\n    if (TextIndex >= UT_SNPRINTF_MAX_BUFS)\n    {\n        TextIndex = 0;\n        WriteLog(\"TextIndex wrapped to 0 (was >= UT_SNPRINTF_MAX_BUFS)\");\n    }\n    else\n    {\n        WriteLog(\"TextIndex incremented to %u\", (unsigned)TextIndex);\n    }\n\n    /* Log the target buffer address and size (for evidence of internal static buffer) */\n    WriteLog(\"Target buffer address=%p size_of_text=%zu\", (void *)Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text));\n\n    va_start(Args, Spec);\n    /* Log that we're about to format into the static buffer */\n    WriteLog(\"Calling vsnprintf into Buf[%u].Text\", (unsigned)TextIndex);\n    vsnprintf(Buf[TextIndex].Text, sizeof(Buf[TextIndex].Text), Spec, Args);\n    va_end(Args);\n\n    /* Log the resulting contents and the pointer to be returned */\n    WriteLog(\"After vsnprintf Buf[%u].Text=\\\"%s\\\"\", (unsigned)TextIndex, Buf[TextIndex].Text);\n    WriteLog(\"Returning pointer=%p (points into internal static buffer)\", (void *)Buf[TextIndex].Text);\n\n    return Buf[TextIndex].Text;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for UtSprintf. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 requires that pointer types be const-qualified where possible. In the snippet UtSprintf returns a plain char * that points into an internal static char array. Nothing in the function requires callers to be able to modify that buffer, and it would be possible (and more self\u2011documenting and MISRA\u2011compliant) to declare the function as returning const char * (a pointer to const) while keeping the internal buffer as a non\u2011const array (the function may still write into it with vsnprintf). Thus, based on the code shown, the agent A's claim is correct: the return type should be const char * to satisfy Rule 8.13 unless the API intentionally permits modification by callers. If the design does intentionally allow callers to modify the returned string, then the current signature would be acceptable and the report would be false; however, no such requirement is visible in the provided code, so the report is correct in this context."
}