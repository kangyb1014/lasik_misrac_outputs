{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN) can read up to OS_MAX_PATH_LEN bytes from VirtualPath. OS_CHECK_POINTER only ensures VirtualPath is non-NULL, not that the object is at least OS_MAX_PATH_LEN bytes or contains a NUL within that range. If the caller passed a pointer to a shorter buffer (or non-terminated data) with no terminating '\\0' within the first OS_MAX_PATH_LEN bytes, OS_strnlen (likely mapping to strnlen) will access memory beyond the bounds of the object \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_mv code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1351.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_mv as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_mv:\n```c\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* First try rename - this only works if it is on the same filesystem */\n    return_code = OS_rename(src, dest);\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_cp(src, dest);\n        if (return_code == OS_SUCCESS)\n        {\n            OS_remove(src);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_mv code.\n",
  "test_code": "#include <stdio.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <time.h>\n#include <string.h>\n\n/*\n * Probe logging helper for OS_mv. Writes control-flow and state information\n * to /tmp/logs/1351.txt so that callers and test harnesses can reproduce\n * and inspect the sequence of operations and the pointer values passed in.\n *\n * Note: The helper accepts a long for the numeric code to avoid depending on\n * the typedef of int32 in this snippet; callers cast their int32 return\n * values to long when invoking the logger.\n */\nstatic void os_mv_log(const char *stage, const char *src, const char *dest, long code)\n{\n    const char *logdir = \"/tmp/logs\";\n    const char *logfile = \"/tmp/logs/1351.txt\";\n    struct stat st;\n    FILE *f = NULL;\n    time_t t;\n\n    /* Attempt to ensure the directory exists (best-effort). */\n    if (stat(logdir, &st) != 0)\n    {\n        /* Ignore errors; mkdir is best-effort for the probe. */\n        (void)mkdir(logdir, 0755);\n    }\n\n    f = fopen(logfile, \"a\");\n    if (f == NULL)\n    {\n        /* Fallback if the directory does not exist or cannot be created. */\n        f = fopen(\"/tmp/1351.txt\", \"a\");\n        if (f == NULL)\n        {\n            /* If we cannot open any file, quietly return to avoid changing\n             * program behavior. The probe must not affect the original logic. */\n            return;\n        }\n    }\n\n    t = time(NULL);\n    /* Log timestamp, stage, pointer addresses and numeric code. */\n    (void)fprintf(f, \"%ld: stage=%s src=%p dest=%p code=%ld\\n\",\n                  (long)t,\n                  (stage != NULL) ? stage : \"(null)\",\n                  (const void *)src,\n                  (const void *)dest,\n                  code);\n\n    /* Extra diagnostic note to help reproduce the reported scenario.\n     * This documents the risk: calls like OS_strnlen(ptr, OS_MAX_PATH_LEN)\n     * may read up to OS_MAX_PATH_LEN bytes from ptr. The probe does not\n     * attempt to read user buffers itself to avoid introducing new out-of-\n     * bounds accesses. */\n    if ((stage != NULL) && (strcmp(stage, \"ENTRY\") == 0))\n    {\n        (void)fprintf(f, \"DIAG: Ensure buffers passed to string functions are at least OS_MAX_PATH_LEN bytes or NUL-terminated within that range.\\n\");\n    }\n\n    (void)fclose(f);\n}\n\n/* Original OS_mv with minimal instrumentation: logs control path and return codes.\n * The logic and call order are preserved exactly; only probe calls are added. */\nint32 OS_mv(const char *src, const char *dest)\n{\n    int32 return_code;\n\n    /* Entry probe: record pointers passed into the function. */\n    os_mv_log(\"ENTRY\", src, dest, 0L);\n\n    /* First try rename - this only works if it is on the same filesystem */\n    return_code = OS_rename(src, dest);\n    os_mv_log(\"AFTER_RENAME\", src, dest, (long)return_code);\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_cp(src, dest);\n        os_mv_log(\"AFTER_CP\", src, dest, (long)return_code);\n        if (return_code == OS_SUCCESS)\n        {\n            int32 rem_rc = OS_remove(src);\n            /* Log the result of the remove separately to capture its return code. */\n            os_mv_log(\"AFTER_REMOVE\", src, dest, (long)rem_rc);\n        }\n    }\n\n    /* Exit probe: final result of the operation. */\n    os_mv_log(\"EXIT\", src, dest, (long)return_code);\n\n    return return_code;\n}\n"
}