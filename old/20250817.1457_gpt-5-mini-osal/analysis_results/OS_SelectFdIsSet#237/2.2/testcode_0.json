{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe final '& 0x1' mask is redundant: the expression (Set->object_ids[local_id >> 3] >> (local_id & 0x7)) already yields a non\u2011zero integer when the bit is set and that will be converted to bool (true) by the function return. Executing the bitwise AND with 0x1 does not change the observable behaviour, so that operation is dead code and violates MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_SelectFdIsSet code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1898.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_SelectFdIsSet as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_SelectFdIsSet:\n```c\nbool OS_SelectFdIsSet(const OS_FdSet *Set, osal_id_t objid)\n{\n    int32        return_code;\n    osal_index_t local_id;\n\n    /* check parameters */\n    BUGCHECK(Set != NULL, false);\n\n    return_code = OS_ObjectIdToArrayIndex(OS_OBJECT_TYPE_OS_STREAM, objid, &local_id);\n    if (return_code != OS_SUCCESS)\n    {\n        return false;\n    }\n\n    /*\n     * Returns boolean for if the bit in the uint8 object_ids array that corresponds\n     * to the local_id is set where local_id >> 3 determines the array element,\n     * and the mask/shift checks the bit within that element.\n     */\n    return ((Set->object_ids[local_id >> 3] >> (local_id & 0x7)) & 0x1);\n}\n```\n</target_code>\nPlease provide the modified OS_SelectFdIsSet code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe logging helper: append execution details to /tmp/logs/1898.txt */\nstatic void OS_SelectFdIsSet_Log(const void *set_ptr, unsigned long long objid_val, int32_t return_code,\n                                 unsigned long long local_id_val, unsigned long index, unsigned int byte_val,\n                                 unsigned int shifted_val, unsigned int final_val)\n{\n    FILE *f = fopen(\"/tmp/logs/1898.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Best effort logging only; do not affect program behaviour */\n    }\n\n    fprintf(f, \"OS_SelectFdIsSet: Set=%p objid=%llu return_code=%d local_id=%llu index=%u byte=0x%02X shifted=0x%02X final=0x%02X\\n\",\n            set_ptr, objid_val, return_code, local_id_val, index, byte_val, shifted_val, final_val);\n    fclose(f);\n}\n\nbool OS_SelectFdIsSet(const OS_FdSet *Set, osal_id_t objid)\n{\n    int32        return_code;\n    osal_index_t local_id;\n\n    /* check parameters */\n    BUGCHECK(Set != NULL, false);\n\n    return_code = OS_ObjectIdToArrayIndex(OS_OBJECT_TYPE_OS_STREAM, objid, &local_id);\n    if (return_code != OS_SUCCESS)\n    {\n        /* Log the failure path with available information */\n        OS_SelectFdIsSet_Log((const void *)Set, (unsigned long long)objid, return_code, (unsigned long long)0, 0, 0U, 0U, 0U);\n        return false;\n    }\n\n    /*\n     * Returns boolean for if the bit in the uint8 object_ids array that corresponds\n     * to the local_id is set where local_id >> 3 determines the array element,\n     * and the mask/shift checks the bit within that element.\n     */\n    unsigned long      idx = (unsigned long)(local_id >> 3);\n    unsigned int       byte_val = (unsigned int)Set->object_ids[idx];\n    unsigned int       shift_amt = (unsigned int)(local_id & 0x7U);\n    unsigned int       shifted = (byte_val >> shift_amt);\n    unsigned int       final_val = (shifted & 0x1U);\n\n    /* Log the successful path and the intermediate values to allow reproducing the reported redundant operation */\n    OS_SelectFdIsSet_Log((const void *)Set, (unsigned long long)objid, return_code,\n                         (unsigned long long)local_id, idx, byte_val, shifted, final_val);\n\n    return ((Set->object_ids[local_id >> 3] >> (local_id & 0x7)) & 0x1);\n}\n"
}