{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_TimeBaseCreate_Impl:\n```c\nint32 OS_TimeBaseCreate_Impl(const OS_object_token_t *token)\n{\n    int32                               return_code;\n    int                                 status;\n    int                                 i;\n    osal_index_t                        idx;\n    struct sigevent                     evp;\n    struct timespec                     ts;\n    OS_impl_timebase_internal_record_t *local;\n    OS_timebase_internal_record_t *     timebase;\n    OS_VoidPtrValueWrapper_t            arg;\n\n    local    = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, *token);\n    timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, *token);\n\n    /*\n     * Spawn a dedicated time base handler thread\n     *\n     * This alleviates the need to handle expiration in the context of a signal handler -\n     * The handler thread can call a BSP synchronized delay implementation as well as the\n     * application callback function.  It should run with elevated priority to reduce latency.\n     *\n     * Note the thread will not actually start running until this function exits and releases\n     * the global table lock.\n     */\n    memset(&arg, 0, sizeof(arg));\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    arg.id      = OS_ObjectIdFromToken(token);\n    return_code = OS_Posix_InternalTaskCreate_Impl(&local->handler_thread, OSAL_PRIORITY_C(0), 0,\n                                                   OS_TimeBasePthreadEntry, arg.opaque_arg);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    local->assigned_signal = 0;\n    clock_gettime(OS_PREFERRED_CLOCK, &local->softsleep);\n\n    /*\n     * Set up the necessary OS constructs\n     *\n     * If an external sync function is used then there is nothing to do here -\n     * we simply call that function and it should synchronize to the time source.\n     *\n     * If no external sync function is provided then this will set up a POSIX\n     * timer to locally simulate the timer tick using the CPU clock.\n     */\n    if (timebase->external_sync == NULL)\n    {\n        sigemptyset(&local->sigset);\n\n        /*\n         * find an RT signal that is not used by another time base object.\n         * This is all done while the global lock is held so no chance of the\n         * underlying tables changing\n         */\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            if (OS_ObjectIdIsValid(OS_global_timebase_table[idx].active_id) &&\n                OS_impl_timebase_table[idx].assigned_signal != 0)\n            {\n                sigaddset(&local->sigset, OS_impl_timebase_table[idx].assigned_signal);\n            }\n        }\n\n        for (i = SIGRTMIN; i <= SIGRTMAX; ++i)\n        {\n            if (!sigismember(&local->sigset, i))\n            {\n                local->assigned_signal = i;\n                break;\n            }\n        }\n\n        do\n        {\n            if (local->assigned_signal == 0)\n            {\n                OS_DEBUG(\"No free RT signals to use for simulated time base\\n\");\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            sigemptyset(&local->sigset);\n            sigaddset(&local->sigset, local->assigned_signal);\n\n            /*\n             * Ensure that the chosen signal is NOT already pending.\n             *\n             * Perform a \"sigtimedwait\" with a zero timeout to poll the\n             * status of the selected signal.  RT signals are also queued,\n             * so this needs to be called in a loop to until sigtimedwait()\n             * returns an error.\n             *\n             * The max number of signals that can be queued is available\n             * via sysconf() as the _SC_SIGQUEUE_MAX value.\n             *\n             * The output is irrelevant here; the objective is to just ensure\n             * that the signal is not already pending.\n             */\n            i = sysconf(_SC_SIGQUEUE_MAX);\n            do\n            {\n                ts.tv_sec  = 0;\n                ts.tv_nsec = 0;\n                if (sigtimedwait(&local->sigset, NULL, &ts) < 0)\n                {\n                    /* signal is NOT pending */\n                    break;\n                }\n                --i;\n            } while (i > 0);\n\n            /*\n            **  Initialize the sigevent structures for the handler.\n            */\n            memset((void *)&evp, 0, sizeof(evp));\n            evp.sigev_notify = SIGEV_SIGNAL;\n            evp.sigev_signo  = local->assigned_signal;\n\n            /*\n             * Pass the Timer Index value of the object ID to the signal handler --\n             *  Note that the upper bits can be safely assumed as a timer ID to recreate the original,\n             *  and doing it this way should still work on a system where sizeof(sival_int) < sizeof(uint32)\n             *  (as long as sizeof(sival_int) >= number of bits in OS_OBJECT_INDEX_MASK)\n             */\n            evp.sigev_value.sival_int = (int)OS_ObjectIdToSerialNumber_Impl(OS_ObjectIdFromToken(token));\n\n            /*\n            ** Create the timer\n            ** Note using the \"MONOTONIC\" clock here as this will still produce consistent intervals\n            ** even if the system clock is stepped (e.g. clock_settime).\n            */\n            status = timer_create(OS_PREFERRED_CLOCK, &evp, &local->host_timerid);\n            if (status < 0)\n            {\n                return_code = OS_TIMER_ERR_UNAVAILABLE;\n                break;\n            }\n\n            timebase->external_sync = OS_TimeBase_SigWaitImpl;\n        } while (0);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        /*\n         * NOTE about the thread cancellation -- this technically is just a backup,\n         * we should not need to cancel it because the handler thread will exit automatically\n         * if the active ID does not match the expected value.  This check would fail\n         * if this function returns non-success (the ID in the global will be set zero)\n         */\n        pthread_cancel(local->handler_thread);\n        local->assigned_signal = 0;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_TimeBaseCreate_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_timebase_internal_record_t OS_impl_timebase_table[OS_MAX_TIMEBASES]\n...\nextern OS_timebase_internal_record_t OS_timebase_table[OS_MAX_TIMEBASES]\n...\nextern OS_common_record_t *const OS_global_timebase_table\n...\n#define OSAL_PRIORITY_C(X) ((osal_priority_t){X})\n...\nint32 OS_Posix_InternalTaskCreate_Impl(pthread_t *pthr, osal_priority_t priority, size_t stacksz,\n                                       PthreadFuncPtr_t entry, void *entry_arg)\n{\n    int                return_code = 0;\n    pthread_attr_t     custom_attr;\n    struct sched_param priority_holder;\n\n    /*\n     ** Initialize the pthread_attr structure.\n     ** The structure is used to set the stack and priority\n     */\n    memset(&custom_attr, 0, sizeof(custom_attr));\n    return_code = pthread_attr_init(&custom_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_init error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n     * Adjust the stack size parameter.\n     *\n     * POSIX has additional restrictions/limitations on the stack size of tasks that\n     * other RTOS environments may not have.  Specifically POSIX says that the stack\n     * size must be at least PTHREAD_STACK_MIN and may also need to be a multiple of the\n     * system page size.\n     *\n     * Rounding up means the user might get a bigger stack than they requested, but\n     * that should not break anything aside from consuming extra memory.\n     */\n    if (stacksz < PTHREAD_STACK_MIN)\n    {\n        stacksz = PTHREAD_STACK_MIN;\n    }\n\n    stacksz += POSIX_GlobalVars.PageSize - 1;\n    stacksz -= stacksz % POSIX_GlobalVars.PageSize;\n\n    /*\n    ** Set the Stack Size\n    */\n    return_code = pthread_attr_setstacksize(&custom_attr, stacksz);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_setstacksize error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n    ** Set the thread to be joinable by default\n    */\n    return_code = pthread_attr_setdetachstate(&custom_attr, PTHREAD_CREATE_JOINABLE);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_setdetachstate error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n    ** Test to see if the original main task scheduling priority worked.\n    ** If so, then also set the attributes for this task.  Otherwise attributes\n    ** are left at default.\n    */\n    if (POSIX_GlobalVars.EnableTaskPriorities)\n    {\n        /*\n        ** Set the scheduling inherit attribute to EXPLICIT\n        */\n        return_code = pthread_attr_setinheritsched(&custom_attr, PTHREAD_EXPLICIT_SCHED);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setinheritsched error in OS_TaskCreate, errno = %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set the scheduling policy\n        ** The best policy is determined during initialization\n        */\n        return_code = pthread_attr_setschedpolicy(&custom_attr, POSIX_GlobalVars.SelectedRtScheduler);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setschedpolity error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        /*\n        ** Set priority\n        */\n        return_code = pthread_attr_getschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_getschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n        priority_holder.sched_priority = OS_PriorityRemap(priority);\n        return_code                    = pthread_attr_setschedparam(&custom_attr, &priority_holder);\n        if (return_code != 0)\n        {\n            OS_DEBUG(\"pthread_attr_setschedparam error in OS_TaskCreate: %s\\n\", strerror(return_code));\n            return OS_ERROR;\n        }\n\n    } /* End if user is root */\n\n    /*\n     ** Create thread\n     */\n    return_code = pthread_create(pthr, &custom_attr, entry, entry_arg);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_create error in OS_TaskCreate: %s\\n\", strerror(return_code));\n        return OS_ERROR;\n    }\n\n    /*\n     ** Free the resources that are no longer needed\n     ** Since the task is now running - pthread_create() was successful -\n     ** Do not treat anything bad that happens after this point as fatal.\n     ** The task is running, after all - better to leave well enough alone.\n     */\n    return_code = pthread_attr_destroy(&custom_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"pthread_attr_destroy error in OS_TaskCreate: %s\\n\", strerror(return_code));\n    }\n\n    return OS_SUCCESS;\n}\n...\nstatic void *OS_TimeBasePthreadEntry(void *arg)\n{\n    OS_VoidPtrValueWrapper_t local_arg;\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    local_arg.opaque_arg = arg;\n    OS_TimeBase_CallbackThread(local_arg.id);\n\n    return NULL;\n}\n...\ntypedef union\n{\n    void *           opaque_arg;\n    OS_ArgCallback_t arg_callback_func;\n    osal_id_t        id;\n    osal_index_t     idx;\n} OS_VoidPtrValueWrapper_t\n...\ntypedef struct\n{\n    pthread_t       handler_thread;\n    pthread_mutex_t handler_mutex;\n    timer_t         host_timerid;\n    int             assigned_signal;\n    sigset_t        sigset;\n    sig_atomic_t    reset_flag;\n    struct timespec softsleep;\n} OS_impl_timebase_internal_record_t\n...\ntypedef struct\n{\n    char           timebase_name[OS_MAX_API_NAME];\n    OS_TimerSync_t external_sync;\n    uint32         accuracy_usec;\n    osal_id_t      first_cb;\n    uint32         freerun_time;\n    uint32         nominal_start_time;\n    uint32         nominal_interval_time;\n} OS_timebase_internal_record_t\n...\n#define OS_MAX_TIMEBASES 5\n...\n#define OS_PREFERRED_CLOCK CLOCK_MONOTONIC\n...\n#define OS_DEBUG(__VA_ARGS__) \n...\n#define OS_TIMER_ERR_UNAVAILABLE (-31)\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n...\nstatic inline uint32 OS_ObjectIdToSerialNumber_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) & OS_OBJECT_INDEX_MASK);\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No explicit compiler language extensions were detected in the provided code. Specific potentially concerning constructs were examined and are not compiler extensions:\n\n- The OSAL_PRIORITY_C macro uses a compound literal ((osal_priority_t){X}), which is standard C (C99), not a compiler extension.\n- The use of pthreads, POSIX timers/signals (pthread_create, timer_create, sigtimedwait, SIGRTMIN/SIGRTMAX, etc.) are POSIX API/library calls, not language extensions.\n- The union-based passing of a pointer/integer via OS_VoidPtrValueWrapper_t relies on union type-punning/representation; this can be implementation-defined or non-portable in some circumstances but is not a compiler language extension as described by compiler documentation.\n- Use of do/while(0), memset, casts, static inline, variadic macro (__VA_ARGS__), and other constructs in the code are standard C features (C99 and later) or library usage, not compiler-specific extensions.\n- No uses of known compiler extensions were found (no __attribute__, __extension__, __builtin_*, inline assembly, nested functions, statement-expressions, typeof, labels-as-values, or other documented compiler-specific keywords/constructs).\n\nTherefore there are no code fragments that need to be reported under MISRA C 2023 Rule 1.2 (language extensions) in this function."
}