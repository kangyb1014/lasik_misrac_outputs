{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdTransactionFinish:\n```c\nvoid OS_ObjectIdTransactionFinish(OS_object_token_t *token, const osal_id_t *final_id)\n{\n    OS_common_record_t *record;\n\n    if (token->lock_mode == OS_LOCK_MODE_NONE)\n    {\n        /* nothing to do */\n        return;\n    }\n\n    record = OS_ObjectIdGlobalFromToken(token);\n\n    /* re-acquire global table lock to adjust refcount */\n    if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE || token->lock_mode == OS_LOCK_MODE_REFCOUNT)\n    {\n        OS_Lock_Global(token);\n    }\n\n    if (record->refcount > 0)\n    {\n        --record->refcount;\n    }\n\n    /*\n     * at this point the global mutex is always held, either\n     * from re-acquiring it above or it is still held from\n     * the original lock when using OS_LOCK_MODE_GLOBAL.\n     *\n     * If an ID update was pending (i.e. for a create/delete op)\n     * then do the ID update now while holding the mutex.\n     */\n    if (final_id != NULL)\n    {\n        record->active_id = *final_id;\n    }\n    else if (token->lock_mode == OS_LOCK_MODE_EXCLUSIVE)\n    {\n        /*\n         * If the lock type was EXCLUSIVE, it means that the ID in the record\n         * was reset to OS_OBJECT_ID_RESERVED.  This must restore the original\n         * object ID from the token.\n         */\n        record->active_id = token->obj_id;\n    }\n\n    /* always unlock (this also covers OS_LOCK_MODE_GLOBAL case) */\n    OS_Unlock_Global(token);\n\n    /*\n     * Setting to \"NONE\" indicates that this token has been\n     * released, and should not be released again.\n     */\n    token->lock_mode = OS_LOCK_MODE_NONE;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nrecord = OS_ObjectIdGlobalFromToken(token);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The returned pointer 'record' is subsequently used to modify the object (record->refcount and record->active_id), so it must be a pointer to a non-const type. Rule 8.13 does not require const qualification when the object is intended to be modified; if the pointer were only used for read-only access, returning a const-qualified pointer would be preferable."
}