{
  "user_message": "An agent A claimed that the following OS_FileSysStatVolume code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStatVolume.\n```c\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts a const-qualified pointer to a non-const pointer: (void *)name where name is declared const char *. This removes the const qualification and allows potential modification of data through the resulting pointer, violating MISRA C 2023 Rule 8.13. Recommended fix: change the target API to accept a const void * (or avoid the cast) so the const qualification is preserved.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1395.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\nstatic void local_check_pathname(const char *name)\n{\n    if (name == NULL)\n    {\n        probe_log(\"OS_CHECK_PATHNAME: name == NULL\");\n    }\n    else\n    {\n        probe_log(\"OS_CHECK_PATHNAME: name='%s' (addr=%p)\", name, (const void *)name);\n    }\n}\nstatic void local_check_pointer(void *ptr)\n{\n    probe_log(\"OS_CHECK_POINTER: ptr=%p\", ptr);\n}\nstatic int32 local_ObjectIdGetBySearch(int lock_mode, int obj_type,\n                                      int (*search_func)(const void *, OS_object_token_t *),\n                                      void *search_key, OS_object_token_t *token)\n{\n    probe_log(\"OS_ObjectIdGetBySearch: lock_mode=%d, obj_type=%d, search_key=%p\", lock_mode, obj_type, search_key);\n\n    /* If the search_key looks like a string, log its contents (safe read) */\n    if (search_key != NULL)\n    {\n        const char *s = (const char *)search_key; /* note: treating as const here for logging */\n        /* Log up to 256 bytes or until NUL to avoid overruns in malformed tests */\n        char buf[257] = {0};\n        size_t i;\n        for (i = 0; i < 256 && s[i] != '\\0'; ++i)\n        {\n            buf[i] = s[i];\n        }\n        buf[i] = '\\0';\n        probe_log(\"OS_ObjectIdGetBySearch: search_key string preview='%s'\", buf);\n    }\n\n    /* Call the provided search function to simulate object lookup */\n    if (search_func != NULL)\n    {\n        int rc = search_func((const void *)search_key, token);\n        probe_log(\"OS_ObjectIdGetBySearch: search_func returned %d\", rc);\n        return rc;\n    }\n\n    probe_log(\"OS_ObjectIdGetBySearch: no search_func provided, returning failure\");\n    return -1;\n}\nstatic int32 local_FileSysStatVolume_Impl(const OS_object_token_t *token, OS_statvfs_t *statbuf)\n{\n    probe_log(\"OS_FileSysStatVolume_Impl: token=%p, token->dummy=%d, statbuf=%p\", (const void *)token, token ? token->dummy : -1, (void *)statbuf);\n    if (statbuf != NULL)\n    {\n        /* Populate a couple of dummy fields to simulate behavior */\n        statbuf->dummy = 123;\n    }\n    return OS_SUCCESS;\n}\nstatic void local_ObjectIdRelease(OS_object_token_t *token)\n{\n    probe_log(\"OS_ObjectIdRelease: token=%p, token->dummy=%d\", (void *)token, token ? token->dummy : -1);\n    /* No real action in this stub */\n}\nstatic int local_FileSys_FindVirtMountPoint(const void *search_key, OS_object_token_t *token)\n{\n    probe_log(\"OS_FileSys_FindVirtMountPoint: called with search_key=%p\", search_key);\n    if (search_key != NULL)\n    {\n        const char *name = (const char *)search_key;\n        probe_log(\"OS_FileSys_FindVirtMountPoint: mount name='%s'\", name);\n    }\n    if (token != NULL)\n    {\n        token->dummy = 42; /* dummy token content */\n        probe_log(\"OS_FileSys_FindVirtMountPoint: token->dummy set to %d\", token->dummy);\n    }\n    return OS_SUCCESS;\n}\n\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters using local helpers (do not invoke project macros) */\n    local_check_pathname(name);\n    local_check_pointer(statbuf);\n\n    /* Log the incoming parameters and note the const-qualified pointer */\n    probe_log(\"OS_FileSysStatVolume: entry name=%p, name_preview='%s', statbuf=%p\", (const void *)name, name ? name : \"(null)\", (void *)statbuf);\n\n    /*\n     * The original code casts away const qualification here: (void *)name\n     * Record explicit evidence of the cast occurrence and the pointer passed\n     * to the search routine so that other agents can reproduce the scenario.\n     */\n    probe_log(\"OS_FileSysStatVolume: about to call OS_ObjectIdGetBySearch with (void *)name (cast away const)\");\n\n    /* Preserve the original call semantics but use the local lookup helper */\n    return_code = local_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, local_FileSys_FindVirtMountPoint,\n                                           (void *)name, &token);\n\n    probe_log(\"OS_FileSysStatVolume: OS_ObjectIdGetBySearch returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"OS_FileSysStatVolume: calling OS_FileSysStatVolume_Impl with token=%p\", (void *)&token);\n        return_code = local_FileSysStatVolume_Impl(&token, statbuf);\n\n        probe_log(\"OS_FileSysStatVolume: OS_FileSysStatVolume_Impl returned %d\", return_code);\n\n        local_ObjectIdRelease(&token);\n        probe_log(\"OS_FileSysStatVolume: token released\");\n    }\n    else\n    {\n        probe_log(\"OS_FileSysStatVolume: object lookup failed, skipping Impl and release\");\n    }\n\n    probe_log(\"OS_FileSysStatVolume: exit return_code=%d\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is essentially correct. The call casts a const char * to void * ((void *)name), which discards the const qualifier. MISRA C 2023 Rule 8.13 (\u201cA pointer should point to a const-qualified type whenever possible\u201d) implies that data which is not modified should be passed using const-qualified pointer types. The presence of the cast indicates the called API (OS_ObjectIdGetBySearch) expects a non-const void *search_key; that API (or its declaration) should instead use a const void * if it does not modify the pointed-to object. \n\nStrictly speaking, Rule 8.13 is about declarations (pointer types should be const-qualified where possible), so the primary nonconformance is in the prototype of OS_ObjectIdGetBySearch (and any other APIs taking the search_key) rather than in the caller. Nevertheless, the caller\u2019s explicit cast that removes const qualification is non-ideal and contravenes the intent of the rule. The recommended fix (change the API to accept const void * or otherwise avoid the cast) is correct.\n\nNote: there are also other MISRA rules that prohibit casting away qualifiers; those would also be relevant if an explicit rule forbids qualification loss. But with respect to Rule 8.13 the agent\u2019s report and recommendation are correct: preserve const by changing the target API (or avoid the cast)."
}