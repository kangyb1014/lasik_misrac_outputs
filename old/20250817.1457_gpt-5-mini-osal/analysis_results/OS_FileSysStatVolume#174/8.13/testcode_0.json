{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code casts a const-qualified pointer to a non-const pointer: (void *)name where name is declared const char *. This removes the const qualification and allows potential modification of data through the resulting pointer, violating MISRA C 2023 Rule 8.13. Recommended fix: change the target API to accept a const void * (or avoid the cast) so the const qualification is preserved.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileSysStatVolume code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1395.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileSysStatVolume as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileSysStatVolume:\n```c\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FileSysStatVolume code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n/* Minimal type stubs to allow standalone compilation for testing */\ntypedef int32_t int32;\ntypedef struct\n{\n    int dummy;\n} OS_object_token_t;\n\ntypedef struct\n{\n    int dummy;\n} OS_statvfs_t;\n\n/* Constants (keep as ints so no macros are introduced) */\nenum\n{\n    OS_SUCCESS = 0,\n    LOCAL_OBJID_TYPE = 1,\n    OS_LOCK_MODE_GLOBAL = 2\n};\n\n/* Simple logging helper that appends to /tmp/logs/1395.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1395.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n/* Replacement for the project checks (kept as functions, not macros) */\nstatic void OS_CHECK_PATHNAME(const char *name)\n{\n    if (name == NULL)\n    {\n        probe_log(\"OS_CHECK_PATHNAME: name == NULL\");\n    }\n    else\n    {\n        probe_log(\"OS_CHECK_PATHNAME: name='%s' (addr=%p)\", name, (const void *)name);\n    }\n}\n\nstatic void OS_CHECK_POINTER(void *ptr)\n{\n    probe_log(\"OS_CHECK_POINTER: ptr=%p\", ptr);\n}\n\n/* Forward declarations of functions that exist in the real system. */\nstatic int OS_FileSys_FindVirtMountPoint(const void *search_key, OS_object_token_t *token);\n\nstatic int32 OS_ObjectIdGetBySearch(int lock_mode, int obj_type,\n                                    int (*search_func)(const void *, OS_object_token_t *),\n                                    void *search_key, OS_object_token_t *token)\n{\n    probe_log(\"OS_ObjectIdGetBySearch: lock_mode=%d, obj_type=%d, search_key=%p\", lock_mode, obj_type, search_key);\n\n    /* If the search_key looks like a string, log its contents (safe read) */\n    if (search_key != NULL)\n    {\n        const char *s = (const char *)search_key; /* note: treating as const here for logging */\n        /* Log up to 256 bytes or until NUL to avoid overruns in malformed tests */\n        char buf[257] = {0};\n        size_t i;\n        for (i = 0; i < 256 && s[i] != '\\0'; ++i)\n        {\n            buf[i] = s[i];\n        }\n        buf[i] = '\\0';\n        probe_log(\"OS_ObjectIdGetBySearch: search_key string preview='%s'\", buf);\n    }\n\n    /* Call the provided search function to simulate object lookup */\n    if (search_func != NULL)\n    {\n        int rc = search_func((const void *)search_key, token);\n        probe_log(\"OS_ObjectIdGetBySearch: search_func returned %d\", rc);\n        return rc;\n    }\n\n    probe_log(\"OS_ObjectIdGetBySearch: no search_func provided, returning failure\");\n    return -1;\n}\n\nstatic int OS_FileSys_FindVirtMountPoint(const void *search_key, OS_object_token_t *token)\n{\n    probe_log(\"OS_FileSys_FindVirtMountPoint: called with search_key=%p\", search_key);\n    if (search_key != NULL)\n    {\n        const char *name = (const char *)search_key;\n        probe_log(\"OS_FileSys_FindVirtMountPoint: mount name='%s'\", name);\n    }\n    if (token != NULL)\n    {\n        token->dummy = 42; /* dummy token content */\n        probe_log(\"OS_FileSys_FindVirtMountPoint: token->dummy set to %d\", token->dummy);\n    }\n    return OS_SUCCESS;\n}\n\nstatic int32 OS_FileSysStatVolume_Impl(const OS_object_token_t *token, OS_statvfs_t *statbuf)\n{\n    probe_log(\"OS_FileSysStatVolume_Impl: token=%p, token->dummy=%d, statbuf=%p\", (const void *)token, token ? token->dummy : -1, (void *)statbuf);\n    if (statbuf != NULL)\n    {\n        /* Populate a couple of dummy fields to simulate behavior */\n        statbuf->dummy = 123;\n    }\n    return OS_SUCCESS;\n}\n\nstatic void OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    probe_log(\"OS_ObjectIdRelease: token=%p, token->dummy=%d\", (void *)token, token ? token->dummy : -1);\n    /* No real action in this stub */\n}\n\n/*\n * Modified OS_FileSysStatVolume with inserted probes that log the control flow and\n * the state relevant to the const-to-void cast violation scenario.\n *\n * The original logic is preserved: input checks, call to OS_ObjectIdGetBySearch with\n * the (void *) cast, conditional invocation of the Impl function, and release.\n */\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    /* Log the incoming parameters and note the const-qualified pointer */\n    probe_log(\"OS_FileSysStatVolume: entry name=%p, name_preview='%s', statbuf=%p\", (const void *)name, name ? name : \"(null)\", (void *)statbuf);\n\n    /*\n     * The original code casts away const qualification here: (void *)name\n     * Record explicit evidence of the cast occurrence and the pointer passed\n     * to the search routine so that other agents can reproduce the scenario.\n     */\n    probe_log(\"OS_FileSysStatVolume: about to call OS_ObjectIdGetBySearch with (void *)name (cast away const)\");\n\n    /* Preserve the original call and cast to reproduce the violation scenario */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    probe_log(\"OS_FileSysStatVolume: OS_ObjectIdGetBySearch returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"OS_FileSysStatVolume: calling OS_FileSysStatVolume_Impl with token=%p\", (void *)&token);\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        probe_log(\"OS_FileSysStatVolume: OS_FileSysStatVolume_Impl returned %d\", return_code);\n\n        OS_ObjectIdRelease(&token);\n        probe_log(\"OS_FileSysStatVolume: token released\");\n    }\n    else\n    {\n        probe_log(\"OS_FileSysStatVolume: object lookup failed, skipping Impl and release\");\n    }\n\n    probe_log(\"OS_FileSysStatVolume: exit return_code=%d\", return_code);\n\n    return return_code;\n}\n"
}