{
  "user_message": "An agent A claimed that the following OS_FileSysStatVolume code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStatVolume.\n```c\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n    OS_CHECK_POINTER(statbuf);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code computes mplen from filesys->virtual_mountpt then calls strncmp(target, filesys->virtual_mountpt, mplen) and later reads target[mplen] without ensuring target has at least mplen bytes. If the search target is shorter than the virtual_mountpt (for example, filesys->virtual_mountpt = \"/mnt/abcdef\" but the caller supplied target = \"/mnt/ab\"), then mplen > strlen(target). In that case strncmp will read past the end of the target buffer and the access to target[mplen] is out-of-bounds, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1399.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n\n    fclose(f);\n}\nstatic void probe_dump_bytes(const void *ptr, size_t len)\n{\n    if (ptr == NULL || len == 0)\n    {\n        probe_log(\"probe_dump_bytes: ptr=%p len=%zu (nothing to dump)\", ptr, len);\n        return;\n    }\n\n    FILE *f = fopen(\"/tmp/logs/1399.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    const unsigned char *p = (const unsigned char *)ptr;\n    /* Print a short header then hex bytes (useful for opaque token inspection) */\n    fprintf(f, \"probe_dump_bytes: ptr=%p len=%zu bytes=\", ptr, len);\n    for (size_t i = 0; i < len; ++i)\n    {\n        fprintf(f, \"%02X\", (unsigned int)p[i]);\n    }\n    fprintf(f, \"\\n\");\n\n    fclose(f);\n}\n\nint32 OS_FileSysStatVolume(const char *name, OS_statvfs_t *statbuf)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    probe_log(\"ENTER: OS_FileSysStatVolume name=%p statbuf=%p\", (const void *)name, (void *)statbuf);\n\n    /* Check parameters (preserve original checks) */\n    probe_log(\"Before OS_CHECK_PATHNAME(name) name=%p\", (const void *)name);\n    OS_CHECK_PATHNAME(name);\n    probe_log(\"After OS_CHECK_PATHNAME(name)\");\n\n    probe_log(\"Before OS_CHECK_POINTER(statbuf) statbuf=%p\", (void *)statbuf);\n    OS_CHECK_POINTER(statbuf);\n    probe_log(\"After OS_CHECK_POINTER(statbuf)\");\n\n    probe_log(\"Calling OS_ObjectIdGetBySearch(mode=OS_LOCK_MODE_GLOBAL, type=LOCAL_OBJID_TYPE, search=OS_FileSys_FindVirtMountPoint, search_arg=%p)\", (const void *)name);\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    probe_log(\"OS_ObjectIdGetBySearch returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Dump raw token bytes to help other agents inspect opaque token contents */\n        probe_log(\"Token acquired: token_addr=%p token_size=%zu\", (void *)&token, (size_t)sizeof(token));\n        probe_dump_bytes(&token, sizeof(token));\n\n        probe_log(\"Calling OS_FileSysStatVolume_Impl with token=%p statbuf=%p\", (void *)&token, (void *)statbuf);\n        return_code = OS_FileSysStatVolume_Impl(&token, statbuf);\n        probe_log(\"OS_FileSysStatVolume_Impl returned %d\", return_code);\n\n        OS_ObjectIdRelease(&token);\n        probe_log(\"Token released\");\n    }\n\n    probe_log(\"EXIT: OS_FileSysStatVolume returning %d\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysStatVolume. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation (MISRA C 2023 Rule 21.17) concerns out\u2011of\u2011bounds accesses by functions from <string.h>. The code shown for OS_FileSysStatVolume itself does not call any <string.h> functions; it simply performs parameter checks and forwards the name pointer to OS_ObjectIdGetBySearch (which invokes a separate search callback OS_FileSys_FindVirtMountPoint). Therefore, based on the provided OS_FileSysStatVolume code alone, there is no direct violation of Rule 21.17.\n\nAgent A\u2019s scenario describes unsafe use of strncmp and an index access in OS_FileSys_FindVirtMountPoint (computing mplen from filesys->virtual_mountpt, calling strncmp(target, filesys->virtual_mountpt, mplen), then accessing target[mplen] without ensuring target is at least mplen bytes long). If that is indeed the implementation of OS_FileSys_FindVirtMountPoint (or any other callback invoked with the name pointer), then the bug and the Rule 21.17 violation would reside in that callback, not in OS_FileSysStatVolume. To confirm the actual MISRA violation you must inspect the implementation of OS_FileSys_FindVirtMountPoint (and any code that uses strncmp/strlen on the passed-in name). For safety, the callback should check the length of the target (e.g. use strlen or otherwise ensure the pointer refers to an appropriately sized, NUL-terminated buffer) or use comparisons that limit reads to the minimum of the two lengths.\n\nConclusion: the report is not correct as applied to OS_FileSysStatVolume; the plausible violation would be in the search callback, which must be reviewed and fixed if it performs the described unsafe accesses."
}