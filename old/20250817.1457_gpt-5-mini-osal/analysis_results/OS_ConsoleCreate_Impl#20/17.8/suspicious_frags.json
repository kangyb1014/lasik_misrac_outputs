{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleCreate_Impl:\n```c\nint32 OS_ConsoleCreate_Impl(const OS_object_token_t *token)\n{\n    OS_impl_console_internal_record_t *local;\n    OS_console_internal_record_t *     console;\n    pthread_t                          consoletask;\n    int32                              return_code;\n    OS_VoidPtrValueWrapper_t           local_arg = {0};\n\n    console = OS_OBJECT_TABLE_GET(OS_console_table, *token);\n    local   = OS_OBJECT_TABLE_GET(OS_impl_console_table, *token);\n\n    if (token->obj_idx == 0)\n    {\n        return_code = OS_SUCCESS;\n\n        if (console->IsAsync)\n        {\n            if (sem_init(&local->data_sem, 0, 0) < 0)\n            {\n                return_code = OS_SEM_FAILURE;\n            }\n            else\n            {\n                /* cppcheck-suppress unreadVariable // intentional use of other union member */\n                local_arg.id = OS_ObjectIdFromToken(token);\n                return_code  = OS_Posix_InternalTaskCreate_Impl(&consoletask, OS_CONSOLE_TASK_PRIORITY, 0,\n                                                               OS_ConsoleTask_Entry, local_arg.opaque_arg);\n\n                if (return_code != OS_SUCCESS)\n                {\n                    sem_destroy(&local->data_sem);\n                }\n            }\n        }\n    }\n    else\n    {\n        /* only one physical console device is implemented */\n        return_code = OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_ConsoleCreate_Impl:\nextern OS_console_internal_record_t OS_console_table[OS_MAX_CONSOLES]\n...\nOS_impl_console_internal_record_t OS_impl_console_table[OS_MAX_CONSOLES]\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No code fragments in OS_ConsoleCreate_Impl modify the parameter token (the pointer variable) or attempt to assign to it. token is declared as const OS_object_token_t * so any attempt to modify the pointed-to object through this pointer or to reassign the pointer itself would be either disallowed by the type or obvious in the code \u2014 neither occurs here. Specific uses and why they are safe:\n\n- Accesses token->obj_idx and token->obj_idx == 0: only read access to the object fields, not modification of the pointer or the pointed-to object.\n- OS_OBJECT_TABLE_GET(OS_console_table, *token) and OS_OBJECT_TABLE_GET(OS_impl_console_table, *token): these pass a copy of the object (*token) by value into the macro/function; they do not reassign token itself.\n- OS_ObjectIdFromToken(token): the helper is defined to return token->obj_id by value (taking a const pointer); it reads the object but does not modify the pointer or the object.\n- Passing token to OS_Posix_InternalTaskCreate_Impl via OS_ObjectIdFromToken and using local_arg: no modification of token occurs.\n\nGiven the const qualification and the absence of any assignment to token (no occurrences like token = ... or modifying '*token' in the code), there are no violations of MISRA C 2023 Rule 17.8 in this function. If any related macro (OS_OBJECT_TABLE_GET) or called function had side effects that modify the pointer itself, that would be a concern, but based on the provided definitions and typical usage (the helper inline functions are read-only), there is no evidence of such behavior in the supplied code."
}