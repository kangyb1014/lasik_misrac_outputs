{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_GetBaseForObjectType:\n```c\nuint32 OS_GetBaseForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_TASK_BASE;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_QUEUE_BASE;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_BINSEM_BASE;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_COUNTSEM_BASE;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MUTEX_BASE;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_STREAM_BASE;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_DIR_BASE;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_TIMEBASE_BASE;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_TIMECB_BASE;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MODULE_BASE;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_FILESYS_BASE;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_CONSOLE_BASE;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_CONDVAR_BASE;\n        default:\n            return 0;\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_GetBaseForObjectType:\n#define OS_OBJECT_TYPE_OS_TASK 0x01\n...\n#define OS_OBJECT_TYPE_OS_QUEUE 0x02\n...\n#define OS_OBJECT_TYPE_OS_BINSEM 0x04\n...\n#define OS_OBJECT_TYPE_OS_COUNTSEM 0x03\n...\n#define OS_OBJECT_TYPE_OS_MUTEX 0x05\n...\n#define OS_OBJECT_TYPE_OS_STREAM 0x06\n...\n#define OS_OBJECT_TYPE_OS_DIR 0x07\n...\n#define OS_OBJECT_TYPE_OS_TIMEBASE 0x08\n...\n#define OS_OBJECT_TYPE_OS_TIMECB 0x09\n...\n#define OS_OBJECT_TYPE_OS_MODULE 0x0A\n...\n#define OS_OBJECT_TYPE_OS_FILESYS 0x0B\n...\n#define OS_OBJECT_TYPE_OS_CONSOLE 0x0C\n...\n#define OS_OBJECT_TYPE_OS_CONDVAR 0x0D\n...\nuint32 OS_GetMaxForObjectType(osal_objtype_t idtype)\n{\n    switch (idtype)\n    {\n        case OS_OBJECT_TYPE_OS_TASK:\n            return OS_MAX_TASKS;\n        case OS_OBJECT_TYPE_OS_QUEUE:\n            return OS_MAX_QUEUES;\n        case OS_OBJECT_TYPE_OS_BINSEM:\n            return OS_MAX_BIN_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_COUNTSEM:\n            return OS_MAX_COUNT_SEMAPHORES;\n        case OS_OBJECT_TYPE_OS_MUTEX:\n            return OS_MAX_MUTEXES;\n        case OS_OBJECT_TYPE_OS_STREAM:\n            return OS_MAX_NUM_OPEN_FILES;\n        case OS_OBJECT_TYPE_OS_DIR:\n            return OS_MAX_NUM_OPEN_DIRS;\n        case OS_OBJECT_TYPE_OS_TIMEBASE:\n            return OS_MAX_TIMEBASES;\n        case OS_OBJECT_TYPE_OS_TIMECB:\n            return OS_MAX_TIMERS;\n        case OS_OBJECT_TYPE_OS_MODULE:\n            return OS_MAX_MODULES;\n        case OS_OBJECT_TYPE_OS_FILESYS:\n            return OS_MAX_FILE_SYSTEMS;\n        case OS_OBJECT_TYPE_OS_CONSOLE:\n            return OS_MAX_CONSOLES;\n        case OS_OBJECT_TYPE_OS_CONDVAR:\n            return OS_MAX_CONDVARS;\n        default:\n            return 0;\n    }\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic inline bool OS_ObjectIdDefined(osal_id_t object_id)\n{\n    return (OS_ObjectIdToInteger(object_id) != 0);\n}\n...\nstatic inline uint32 OS_ObjectIdToSerialNumber_Impl(osal_id_t id)\n{\n    return (OS_ObjectIdToInteger(id) & OS_OBJECT_INDEX_MASK);\n}\n...\nstatic inline void OS_ObjectIdCompose_Impl(osal_objtype_t idtype, uint32 idserial, osal_id_t *result)\n{\n    *result = OS_ObjectIdFromInteger((idtype << OS_OBJECT_TYPE_SHIFT) | idserial);\n}\n...\nosal_id_t OS_TaskGetId(void)\n{\n    osal_id_t task_id;\n\n    task_id = OS_TaskGetId_Impl();\n\n    return task_id;\n}\n...\nint32 OS_ObjectIdTransactionInit(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_object_token_t *token)\n{\n    memset(token, 0, sizeof(*token));\n\n    /*\n     * Confirm that OSAL has been fully initialized before allowing any transactions\n     */\n    if (OS_SharedGlobalVars.GlobalState != OS_INIT_MAGIC_NUMBER &&\n        OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * only \"exclusive\" locks allowed after shutdown request (this is mode used for delete).\n     * All regular ops will be blocked.\n     */\n    if (OS_SharedGlobalVars.GlobalState == OS_SHUTDOWN_MAGIC_NUMBER && lock_mode != OS_LOCK_MODE_EXCLUSIVE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Transactions cannot be started on an object type for which\n     * there are no actual objects\n     */\n    if (OS_GetMaxForObjectType(idtype) == 0)\n    {\n        return OS_ERR_INVALID_ID;\n    }\n\n    token->lock_mode = lock_mode;\n    token->obj_type  = idtype;\n    token->obj_idx   = OSAL_INDEX_C(-1);\n\n    if (lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Lock_Global(token);\n    }\n\n    return OS_SUCCESS;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic inline void OS_ObjectIdCompose_Impl(osal_objtype_t idtype, uint32 idserial, osal_id_t *result)\n{\n    *result = OS_ObjectIdFromInteger((idtype << OS_OBJECT_TYPE_SHIFT) | idserial);\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The function composes an object-id and writes it to *result; if called, removing the assignment would change program behaviour, so it is not dead code. If the inline function is never referenced it is simply unused/unreferenced (i.e. not executed/unreachable), which is not considered dead code by Rule 2.2."
}