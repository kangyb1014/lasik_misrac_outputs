{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe LENGTHCHECK(name, OS_MAX_API_NAME, ...) macro likely computes the string length (e.g. via strlen) to compare against OS_MAX_API_NAME. ARGCHECK only verifies name != NULL but does not guarantee a terminating NUL within the object bounds. If LENGTHCHECK uses an unbounded strlen (or other <string.h> functions that scan until NUL), and the supplied 'name' buffer is not NUL-terminated within its allocated bounds, the call can read past the end of the object. This would violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskGetIdByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2071.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskGetIdByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskGetIdByName:\n```c\nint32 OS_TaskGetIdByName(osal_id_t *task_id, const char *task_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(task_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, task_name, task_id);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskGetIdByName code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n/* Probe logging helpers. These are non-invasive and do not change\n * the original control flow or return values of OS_TaskGetIdByName.\n * They append human-readable diagnostics to /tmp/logs/2071.txt so\n * other agents can reproduce and collect evidence for the scenario. */\nstatic void os_probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2071.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If the log cannot be opened, do nothing to avoid affecting\n         * normal program behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\n\nstatic void os_probe_task_name(const char *name)\n{\n    os_probe_log(\"[probe] OS_TaskGetIdByName: task_name pointer=%p\", (const void *)name);\n\n    if (name == NULL)\n    {\n        os_probe_log(\"[probe] task_name is NULL\");\n        return;\n    }\n\n    /* If the build defines OS_MAX_API_NAME we can perform a bounded\n     * search for the terminating NUL using that bound. This mirrors\n     * the typical LENGTHCHECK semantics and avoids introducing a new\n     * unbounded scan that could itself cause an out-of-bounds access.\n     * If OS_MAX_API_NAME is not available we skip the scan to avoid\n     * introducing additional undefined behavior. */\n#ifdef OS_MAX_API_NAME\n    {\n        size_t bound = (size_t)OS_MAX_API_NAME;\n        const void *nul_pos = memchr(name, '\\0', bound);\n        if (nul_pos != NULL)\n        {\n            size_t idx = (const char *)nul_pos - name;\n            os_probe_log(\"[probe] NUL terminator found within OS_MAX_API_NAME (%zu) at index %zu\", bound, idx);\n        }\n        else\n        {\n            os_probe_log(\"[probe] NO NUL terminator within OS_MAX_API_NAME (%zu) - potential over-read if unbounded strlen is used\", bound);\n        }\n    }\n#else\n    os_probe_log(\"[probe] OS_MAX_API_NAME not defined - skipping bounded NUL check to avoid additional UB\");\n#endif\n}\n\n/* Original function with probes inserted. Logic and return value\n * are preserved exactly; the probes only collect runtime state. */\nint32 OS_TaskGetIdByName(osal_id_t *task_id, const char *task_name)\n{\n    int32 return_code;\n\n    os_probe_log(\"[probe] Enter OS_TaskGetIdByName\");\n    os_probe_log(\"[probe] task_id pointer=%p\", (const void *)task_id);\n    os_probe_log(\"[probe] task_name pointer=%p\", (const void *)task_name);\n\n    /* Record whether the provided name appears NUL-terminated within\n     * the expected bound (if available). This helps reproduce the\n     * violation scenario where an unbounded string scan (e.g. strlen)\n     * could read past the buffer. */\n    os_probe_task_name(task_name);\n\n    /* Check parameters (original checks retained). */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(task_name);\n\n    os_probe_log(\"[probe] After pointer checks - calling OS_ObjectIdFindByName\");\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, task_name, task_id);\n\n    os_probe_log(\"[probe] OS_ObjectIdFindByName returned %ld\", (long)return_code);\n    os_probe_log(\"[probe] Exit OS_TaskGetIdByName\");\n\n    return return_code;\n}\n"
}