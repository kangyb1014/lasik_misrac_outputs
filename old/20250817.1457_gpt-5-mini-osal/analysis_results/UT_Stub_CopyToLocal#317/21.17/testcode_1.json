{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe fragment only clamps ActualCopy to MaxSize but does not ensure the source index is valid. If StubPtr->Data.Buff.Position > StubPtr->Data.Buff.TotalSize, then &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position] forms a pointer beyond the array bounds (undefined behavior) and memcpy(LocalBuffer, ..., ActualCopy) can read out-of-bounds. Similarly, if MaxSize does not actually reflect the true size of LocalBuffer, copying up to MaxSize may overflow the destination. Thus the code can result in accesses beyond object bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_Stub_CopyToLocal code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2543.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_Stub_CopyToLocal as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CopyToLocal:\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\nPlease provide the modified UT_Stub_CopyToLocal code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Probe helper: log state to /tmp/logs/2543.txt without introducing UB in the probe itself. */\nstatic void UT_Log_CopyState(const char *stage, void *LocalBuffer, size_t MaxSize, size_t ActualCopy, void *stubptr_void)\n{\n    FILE *f = fopen(\"/tmp/logs/2543.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"---- UT_Stub_CopyToLocal: %s ----\\n\", stage);\n    fprintf(f, \" LocalBuffer=%p, MaxSize=%zu, ActualCopy=%zu\\n\", LocalBuffer, MaxSize, ActualCopy);\n\n    if (stubptr_void == NULL)\n    {\n        fprintf(f, \" StubPtr=NULL\\n\");\n        fprintf(f, \"-------------------------------\\n\");\n        fclose(f);\n        return;\n    }\n\n    /* We do not dereference array elements or form pointers that could be out-of-bounds. */\n    /* Accessing the struct members (Position, TotalSize, BasePtr) is allowed; do not compute &BasePtr[Position] here. */\n    /* The type UT_StubTableEntry_t is opaque here; we cast to access the expected layout as used by the function. */\n    typedef struct\n    {\n        struct\n        {\n            char *BasePtr;\n            size_t Position;\n            size_t TotalSize;\n        } Buff;\n    } _UT_Probe_SimpleBuf_t;\n\n    _UT_Probe_SimpleBuf_t *probe = (_UT_Probe_SimpleBuf_t *)stubptr_void;\n\n    fprintf(f, \" StubPtr=%p\\n\", stubptr_void);\n    fprintf(f, \"  BasePtr=%p, Position=%zu, TotalSize=%zu\\n\",\n            (void *)probe->Buff.BasePtr, probe->Buff.Position, probe->Buff.TotalSize);\n\n    if (probe->Buff.Position <= probe->Buff.TotalSize)\n    {\n        /* It is safe to report that the source pointer can be formed without UB (Position <= TotalSize). */\n        fprintf(f, \"  Source pointer can be formed: &BasePtr[%zu]\\n\", probe->Buff.Position);\n    }\n    else\n    {\n        /* Avoid forming the actual pointer to prevent UB inside the probe. */\n        fprintf(f, \"  WARNING: Position (%zu) > TotalSize (%zu) -> source pointer would be out-of-bounds\\n\",\n                probe->Buff.Position, probe->Buff.TotalSize);\n    }\n\n    /* Note: We cannot determine the actual size of LocalBuffer from here; report MaxSize and warn. */\n    fprintf(f, \"  Note: MaxSize is the caller-provided destination limit; if this does not match the real buffer size, overflow may occur.\\n\");\n\n    fprintf(f, \"-------------------------------\\n\");\n    fclose(f);\n}\n\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        /* Log entry state before computing ActualCopy */\n        UT_Log_CopyState(\"entry_found_before_compute\", LocalBuffer, MaxSize, ActualCopy, (void *)StubPtr);\n\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        /* Log state immediately before memcpy. The probe avoids forming out-of-bounds pointers. */\n        UT_Log_CopyState(\"before_memcpy\", LocalBuffer, MaxSize, ActualCopy, (void *)StubPtr);\n\n        /* Original logic retained: this memcpy can exhibit the out-of-bounds behavior described in the report. */\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /* Log state after memcpy (position updated) */\n        UT_Log_CopyState(\"after_memcpy\", LocalBuffer, MaxSize, ActualCopy, (void *)StubPtr);\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            /* Log that the entry was cleared */\n            UT_Log_CopyState(\"entry_cleared\", LocalBuffer, MaxSize, ActualCopy, NULL);\n        }\n    }\n\n    return ActualCopy;\n}\n"
}