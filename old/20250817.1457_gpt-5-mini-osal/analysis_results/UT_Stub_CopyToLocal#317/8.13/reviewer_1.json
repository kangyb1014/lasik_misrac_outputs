{
  "user_message": "An agent A claimed that the following UT_Stub_CopyToLocal code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyToLocal.\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If StubPtr->Data.Buff.BasePtr is declared as a pointer to a non-const element type (e.g. uint8_t *BasePtr) but the buffer is only read from (as here, passed as the source to memcpy), then the pointer should be declared to point to a const-qualified type (e.g. const uint8_t *BasePtr). In that case Rule 8.13 is violated. If BasePtr is already declared const (const uint8_t * or similar) then there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2539.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n\n    UT_LogProbe(\"UT_Stub_CopyToLocal ENTRY: FuncKey=%llu, LocalBuffer=%p, MaxSize=%zu\",\n                (unsigned long long) (uintptr_t) FuncKey, LocalBuffer, MaxSize);\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    UT_LogProbe(\"UT_GetStubEntry returned: StubPtr=%p\", (void *)StubPtr);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        UT_LogProbe(\"Computed initial ActualCopy = TotalSize(%zu) - Position(%zu) = %zu\",\n                    StubPtr->Data.Buff.TotalSize,\n                    StubPtr->Data.Buff.Position,\n                    ActualCopy);\n\n        if (MaxSize < ActualCopy)\n        {\n            UT_LogProbe(\"MaxSize(%zu) < ActualCopy(%zu) -> limiting ActualCopy to MaxSize\", MaxSize, ActualCopy);\n            ActualCopy = MaxSize;\n        }\n        else\n        {\n            UT_LogProbe(\"MaxSize(%zu) >= ActualCopy(%zu) -> keep ActualCopy\", MaxSize, ActualCopy);\n        }\n\n        /* Log the source pointer and a short hexdump of the first bytes we will copy. */\n        {\n            const unsigned char *src = (const unsigned char *)&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position];\n            UT_LogProbe(\"About to memcpy from src=%p, Position=%zu, TotalSize=%zu, ActualCopy=%zu\",\n                        (const void *)src,\n                        StubPtr->Data.Buff.Position,\n                        StubPtr->Data.Buff.TotalSize,\n                        ActualCopy);\n\n            /* Dump up to the first 16 bytes for inspection (safe read; identical to memcpy source reads) */\n            size_t dump = (ActualCopy < 16U) ? ActualCopy : 16U;\n            if (dump > 0U)\n            {\n                char hex[3 * 16 + 1];\n                char *p = hex;\n                size_t i;\n\n                for (i = 0U; i < dump; ++i)\n                {\n                    int written = snprintf(p, (size_t)(hex + sizeof(hex) - p), \"%02X \", (unsigned int)src[i]);\n                    if (written <= 0)\n                    {\n                        break;\n                    }\n                    p += written;\n                }\n                *p = '\\0';\n\n                UT_LogProbe(\"Source buffer first %zu bytes: %s\", dump, hex);\n            }\n            else\n            {\n                UT_LogProbe(\"No bytes to dump (dump=%zu)\", dump);\n            }\n        }\n\n        /* Perform the original copy operation */\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        UT_LogProbe(\"memcpy(LocalBuffer=%p, src=%p, ActualCopy=%zu) completed\",\n                    LocalBuffer,\n                    (const void *)&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position],\n                    ActualCopy);\n\n        StubPtr->Data.Buff.Position += ActualCopy;\n        UT_LogProbe(\"Updated Position -> %zu\", StubPtr->Data.Buff.Position);\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_LogProbe(\"Position (%zu) >= TotalSize (%zu): clearing stub entry %p\",\n                        StubPtr->Data.Buff.Position,\n                        StubPtr->Data.Buff.TotalSize,\n                        (void *)StubPtr);\n            UT_ClearStubEntry(StubPtr);\n        }\n        else\n        {\n            UT_LogProbe(\"Position (%zu) < TotalSize (%zu): leaving stub entry intact\",\n                        StubPtr->Data.Buff.Position,\n                        StubPtr->Data.Buff.TotalSize);\n        }\n    }\n    else\n    {\n        UT_LogProbe(\"No stub entry found for FuncKey=%llu\", (unsigned long long) (uintptr_t) FuncKey);\n    }\n\n    UT_LogProbe(\"UT_Stub_CopyToLocal EXIT: ActualCopy=%zu\", ActualCopy);\n\n    return ActualCopy;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_Stub_CopyToLocal ENTRY: FuncKey=94039602398559, LocalBuffer=0x7ffc33d65a70, MaxSize=20\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94039602398559\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94039602398559, LocalBuffer=0x7ffc33d65a70, MaxSize=20\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94039602398559\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934541352, LocalBuffer=0x7ffcd8b55670, MaxSize=24\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94744934541352\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934541352, LocalBuffer=0x7ffcd8b55670, MaxSize=24\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94744934541352\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934540963, LocalBuffer=0x7ffcd8b55610, MaxSize=48\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94744934540963\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934540963, LocalBuffer=0x7ffcd8b55610, MaxSize=48\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94744934540963\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934540963, LocalBuffer=0x7ffcd8b55610, MaxSize=48\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94744934540963\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94744934540963, LocalBuffer=0x7ffcd8b55610, MaxSize=48\nUT_GetStubEntry returned: StubPtr=0x562b862cac60\nComputed initial ActualCopy = TotalSize(48) - Position(0) = 48\nMaxSize(48) >= ActualCopy(48) -> keep ActualCopy\nAbout to memcpy from src=0x7ffcd8b556b0, Position=0, TotalSize=48, ActualCopy=48\nSource buffer first 16 bytes: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \nmemcpy(LocalBuffer=0x7ffcd8b55610, src=0x7ffcd8b556b0, ActualCopy=48) completed\nUpdated Position -> 48\nPosition (48) >= TotalSize (48): clearing stub entry 0x562b862cac60\nUT_Stub_CopyToLocal EXIT: ActualCopy=48\nUT_Stub_CopyToLocal ENTRY: FuncKey=94095530850611, LocalBuffer=0x7ffd73920a10, MaxSize=48\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94095530850611\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94724891750004, LocalBuffer=0x7ffec421af30, MaxSize=20\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94724891750004\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94724891750004, LocalBuffer=0x7ffec421af30, MaxSize=20\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94724891750004\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94291716309356, LocalBuffer=0x7ffdcad38fd0, MaxSize=24\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94291716309356\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94291716309356, LocalBuffer=0x7ffdcad38fa0, MaxSize=24\nUT_GetStubEntry returned: StubPtr=(nil)\nNo stub entry found for FuncKey=94291716309356\nUT_Stub_CopyToLocal EXIT: ActualCopy=0\nUT_Stub_CopyToLocal ENTRY: FuncKey=94298611314833, LocalBuffer=0x7ffdf4b969d0, MaxSize=8\nUT_GetStubEntry returned: StubPtr=0x55c39b3d2aa0\nComputed initial ActualCopy = TotalSize(8) - Position(0) = 8\nMaxSize(8) >= ActualCopy(8) -> keep ActualCopy\nAbout to memcpy from src=0x7ffdf4b96a30, Position=0, TotalSize=8, ActualCopy=8\nSource buffer first 8 bytes: 00 B1 3C 9B C3 55 00 00 \nmemcpy(LocalBuffer=0x7ffdf4b969d0, src=0x7ffdf4b96a30, ActualCopy=8) completed\nUpdated Position -> 8\nPosition (8) >= TotalSize (8): clearing stub entry 0x55c39b3d2aa0\nUT_Stub_CopyToLocal EXIT: ActualCopy=8\nUT_Stub_CopyToLocal ENTRY: FuncKey=94298611314833, LocalBuffer=0x7ffdf4b969d0, MaxSize=8\nUT_GetStubEntry returned: StubPtr=0x55c39b3d2aa0\nComputed initial ActualCopy = TotalSize(8) - Position(0) = 8\nMaxSize(8) >= ActualCopy(8) -> keep ActualCopy\nAbout to memcpy from src=0x7ffdf4b96a30, Position=0\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in substance. UT_Stub_CopyToLocal only reads from StubPtr->Data.Buff.BasePtr (uses it as the source for memcpy and performs no writes to the pointees). Per MISRA C 2023 Rule 8.13, a pointer that is only used to access data read-only should be declared to point to a const-qualified type. Therefore, if the BasePtr member is declared as a non-const pointer (e.g. uint8_t *BasePtr) this is a violation (it should be declared e.g. const uint8_t *BasePtr). If, however, BasePtr is already declared const, then there is no violation. The agent's scenario and conclusion about a possible Rule 8.13 violation are correct."
}