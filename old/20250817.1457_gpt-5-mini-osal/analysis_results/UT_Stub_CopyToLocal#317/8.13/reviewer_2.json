{
  "user_message": "An agent A claimed that the following UT_Stub_CopyToLocal code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_CopyToLocal.\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The expression takes the address of an element of StubPtr->Data.Buff.BasePtr and uses it as the source operand to memcpy. If BasePtr is declared as a non-const pointer (for example uint8_t *BasePtr or void *BasePtr) and the buffer is only read (not modified) then this violates MISRA C 2023 Rule 8.13 \u2014 the pointer should be to a const-qualified type (e.g. const uint8_t * or const void *).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    /* Ensure log directory exists (ignore error if it already exists) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    FILE *log = fopen(\"/tmp/logs/2539.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"\\n--- UT_Stub_CopyToLocal ENTRY ---\\n\");\n        fprintf(log, \"LocalBuffer=%p, MaxSize=%zu\\n\", LocalBuffer, MaxSize);\n    }\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (log != NULL)\n    {\n        fprintf(log, \"UT_GetStubEntry returned StubPtr=%p\\n\", (void *)StubPtr);\n    }\n\n    if (StubPtr != NULL)\n    {\n        /* Log buffer state before copy */\n        size_t total = StubPtr->Data.Buff.TotalSize;\n        size_t pos   = StubPtr->Data.Buff.Position;\n        void  *basep = (void *)StubPtr->Data.Buff.BasePtr;\n\n        if (log != NULL)\n        {\n            fprintf(log, \"Buffer state: TotalSize=%zu, Position=%zu, BasePtr=%p\\n\", total, pos, basep);\n        }\n\n        ActualCopy = total - pos;\n        if (log != NULL)\n        {\n            fprintf(log, \"Computed initial ActualCopy = TotalSize - Position = %zu\\n\", ActualCopy);\n        }\n\n        if (MaxSize < ActualCopy)\n        {\n            if (log != NULL)\n            {\n                fprintf(log, \"MaxSize (%zu) < ActualCopy (%zu) -> limiting ActualCopy to MaxSize\\n\", MaxSize, ActualCopy);\n            }\n            ActualCopy = MaxSize;\n        }\n\n        if (log != NULL)\n        {\n            /* Compute and log the source pointer passed to memcpy */\n            void *src_ptr = (void *)&StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position];\n            fprintf(log, \"Final ActualCopy=%zu, memcpy source address = %p\\n\", ActualCopy, src_ptr);\n\n            /* If possible, print up to the first 16 bytes from the source as hex for evidence (casts to unsigned char *) */\n            if (ActualCopy > 0u)\n            {\n                const unsigned char *bytes = (const unsigned char *)src_ptr;\n                size_t to_print = (ActualCopy < 16u) ? ActualCopy : 16u;\n                fprintf(log, \"Source bytes (up to 16):\");\n                for (size_t i = 0; i < to_print; ++i)\n                {\n                    fprintf(log, \" %02X\", (unsigned)bytes[i]);\n                }\n                if (ActualCopy > to_print)\n                {\n                    fprintf(log, \" ... (%zu more bytes)\", ActualCopy - to_print);\n                }\n                fprintf(log, \"\\n\");\n            }\n        }\n\n        /* Preserve original behavior: perform the copy and advance the position */\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        if (log != NULL)\n        {\n            fprintf(log, \"After memcpy: new Position=%zu\\n\", StubPtr->Data.Buff.Position);\n        }\n\n        /* Once the buffer is completely copied then drop this entry. */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            if (log != NULL)\n            {\n                fprintf(log, \"Position >= TotalSize -> clearing stub entry %p\\n\", (void *)StubPtr);\n            }\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n    else\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \"No stub entry found for FuncKey (no action taken).\\n\");\n        }\n    }\n\n    if (log != NULL)\n    {\n        fprintf(log, \"--- UT_Stub_CopyToLocal EXIT: ActualCopy=%zu ---\\n\", ActualCopy);\n        fclose(log);\n    }\n\n    return ActualCopy;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7fffa2bc9820, MaxSize=20\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7fffa2bc9820, MaxSize=20\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111be0, MaxSize=24\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111be0, MaxSize=24\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111b80, MaxSize=48\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111b80, MaxSize=48\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111b80, MaxSize=48\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffddc111b80, MaxSize=48\nUT_GetStubEntry returned StubPtr=0x55cb22bb7320\nBuffer state: TotalSize=48, Position=0, BasePtr=0x7ffddc111c20\nComputed initial ActualCopy = TotalSize - Position = 48\nFinal ActualCopy=48, memcpy source address = 0x7ffddc111c20\nSource bytes (up to 16): 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ... (32 more bytes)\nAfter memcpy: new Position=48\nPosition >= TotalSize -> clearing stub entry 0x55cb22bb7320\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=48 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffebb135110, MaxSize=48\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffcd851dc60, MaxSize=20\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffcd851dc60, MaxSize=20\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffea9d2c3c0, MaxSize=24\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffea9d2c390, MaxSize=24\nUT_GetStubEntry returned StubPtr=(nil)\nNo stub entry found for FuncKey (no action taken).\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=0 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7fff2538c0b0, MaxSize=8\nUT_GetStubEntry returned StubPtr=0x558797fbc300\nBuffer state: TotalSize=8, Position=0, BasePtr=0x7fff2538c110\nComputed initial ActualCopy = TotalSize - Position = 8\nFinal ActualCopy=8, memcpy source address = 0x7fff2538c110\nSource bytes (up to 16): C0 E0 FA 97 87 55 00 00\nAfter memcpy: new Position=8\nPosition >= TotalSize -> clearing stub entry 0x558797fbc300\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=8 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7fff2538c0b0, MaxSize=8\nUT_GetStubEntry returned StubPtr=0x558797fbc300\nBuffer state: TotalSize=8, Position=0, BasePtr=0x7fff2538c110\nComputed initial ActualCopy = TotalSize - Position = 8\nFinal ActualCopy=8, memcpy source address = 0x7fff2538c110\nSource bytes (up to 16): A0 F1 FA 97 87 55 00 00\nAfter memcpy: new Position=8\nPosition >= TotalSize -> clearing stub entry 0x558797fbc300\n--- UT_Stub_CopyToLocal EXIT: ActualCopy=8 ---\n\n--- UT_Stub_CopyToLocal ENTRY ---\nLocalBuffer=0x7ffda66d2310, MaxSi\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In UT_Stub_CopyToLocal the code takes the address of an element of StubPtr->Data.Buff.BasePtr and passes it as the source to memcpy without ever modifying the pointed-to object. According to MISRA C 2023 Rule 8.13, a pointer that is only used to access data for reading should be declared to point to a const-qualified type wherever possible. If BasePtr is declared as a non-const pointer (for example uint8_t * or void *), then it should instead be declared as const uint8_t * or const void * to reflect that the buffer is not modified through that pointer. Therefore the scenario described by agent A correctly identifies a violation of Rule 8.13."
}