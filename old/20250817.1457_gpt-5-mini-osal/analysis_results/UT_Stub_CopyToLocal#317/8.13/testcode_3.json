{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf Buff.BasePtr is declared as a non-const pointer (e.g. uint8_t *BasePtr or void *BasePtr) this is a violation: the code uses BasePtr only as a read-only source to memcpy, so BasePtr should be const-qualified (e.g. const uint8_t * or const void *) per MISRA C 2023 Rule 8.13. If BasePtr is already declared const, then there is no violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_Stub_CopyToLocal code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2539.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_Stub_CopyToLocal as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CopyToLocal:\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n</target_code>\nPlease provide the modified UT_Stub_CopyToLocal code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n\n/*\n * Modified UT_Stub_CopyToLocal with logging probes that write execution\n * trace and buffer state to /tmp/logs/2539.txt. The original logic is\n * preserved; probes only observe state and do not change behavior.\n *\n * Notes:\n * - This code does not attempt to infer const-qualification of\n *   BasePtr (a static property). Instead it logs the pointer value,\n *   buffer sizes, positions and a small hex dump of the source bytes\n *   to help reproduce and demonstrate read-only usage at runtime.\n */\n\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n    FILE                *log = NULL;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    /* Open log in append mode. Failure to open the log should not\n     * affect the logic: simply continue without logging. */\n    log = fopen(\"/tmp/logs/2539.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"UT_Stub_CopyToLocal called: LocalBuffer=%p MaxSize=%zu\\n\",\n                LocalBuffer, MaxSize);\n    }\n\n    if (StubPtr != NULL)\n    {\n        /* Log stub entry pointers and sizes before any modifications. */\n        if (log != NULL)\n        {\n            /* Print addresses and current size/position. BasePtr is printed\n             * as a void pointer for runtime inspection. */\n            (void)fprintf(log,\n                          \"StubPtr=%p TotalSize=%zu Position=%zu BasePtr=%p\\n\",\n                          (void *)StubPtr,\n                          (size_t)StubPtr->Data.Buff.TotalSize,\n                          (size_t)StubPtr->Data.Buff.Position,\n                          (void *)StubPtr->Data.Buff.BasePtr);\n        }\n\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (log != NULL)\n        {\n            fprintf(log, \"Initial computed ActualCopy=%zu (before clamp)\\n\", ActualCopy);\n        }\n\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n            if (log != NULL)\n            {\n                fprintf(log, \"Clamped ActualCopy to MaxSize=%zu\\n\", ActualCopy);\n            }\n        }\n\n        /* Prepare to log the source pointer used for memcpy and a small\n         * hex dump of the source contents (up to 32 bytes) to illustrate\n         * that the buffer is only being read. */\n        {\n            size_t oldPos = StubPtr->Data.Buff.Position;\n            const void *srcPtr = (const void *)&StubPtr->Data.Buff.BasePtr[oldPos];\n\n            if (log != NULL)\n            {\n                fprintf(log, \"About to memcpy: dst=%p src=%p bytes=%zu\\n\",\n                        LocalBuffer, srcPtr, ActualCopy);\n\n                /* Dump up to 32 bytes for evidence of read-only usage. */\n                size_t dump = (ActualCopy < 32u) ? ActualCopy : 32u;\n                if (dump > 0)\n                {\n                    const unsigned char *srcBytes = (const unsigned char *)srcPtr;\n                    fprintf(log, \"Source bytes (up to 32):\");\n                    for (size_t i = 0; i < dump; ++i)\n                    {\n                        fprintf(log, \" %02X\", srcBytes[i]);\n                    }\n                    fprintf(log, \"\\n\");\n                }\n            }\n\n            /* Preserve original behavior: perform the copy and update\n             * the position. */\n            memcpy(LocalBuffer, srcPtr, ActualCopy);\n\n            StubPtr->Data.Buff.Position = oldPos + ActualCopy;\n\n            if (log != NULL)\n            {\n                fprintf(log, \"After memcpy: new Position=%zu\\n\",\n                        StubPtr->Data.Buff.Position);\n            }\n        }\n\n        /* If buffer fully consumed, clear the stub entry (original logic). */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            if (log != NULL)\n            {\n                fprintf(log, \"Buffer fully consumed: clearing stub entry\\n\");\n            }\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n    else\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \"No stub entry found (StubPtr == NULL)\\n\");\n        }\n    }\n\n    if (log != NULL)\n    {\n        fclose(log);\n    }\n\n    return ActualCopy;\n}\n"
}