{
  "user_message": "Target function code is:\n```c\nsize_t UT_Stub_CopyToLocal(UT_EntryKey_t FuncKey, void *LocalBuffer, size_t MaxSize)\n{\n    size_t               ActualCopy;\n    UT_StubTableEntry_t *StubPtr;\n\n    ActualCopy = 0;\n    StubPtr    = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr != NULL)\n    {\n        ActualCopy = StubPtr->Data.Buff.TotalSize - StubPtr->Data.Buff.Position;\n        if (MaxSize < ActualCopy)\n        {\n            ActualCopy = MaxSize;\n        }\n\n        memcpy(LocalBuffer, &StubPtr->Data.Buff.BasePtr[StubPtr->Data.Buff.Position], ActualCopy);\n        StubPtr->Data.Buff.Position += ActualCopy;\n\n        /*\n         * Once the buffer is completely copied then drop this entry.\n         * The test harness will either refill it or there might be\n         * another entry in the table.\n         */\n        if (StubPtr->Data.Buff.Position >= StubPtr->Data.Buff.TotalSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n        }\n    }\n\n    return ActualCopy;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyToLocal': {'callees': ['UT_GetStubEntry', 'UT_ClearStubEntry'], 'callers': ['UT_DefaultHandler_OS_BinSemGetInfo', 'UT_DefaultHandler_OS_BinSemGetIdByName', 'UT_DefaultHandler_OS_GetLocalTime', 'UT_DefaultHandler_OS_CountSemGetIdByName', 'UT_DefaultHandler_OS_CountSemGetInfo', 'UT_DefaultHandler_OS_DirectoryRead', 'UT_DefaultHandler_OS_GetErrorName', 'UT_GenericReadStub', 'UT_DefaultHandler_OS_stat', 'UT_DefaultHandler_OS_FDGetInfo', 'UT_DefaultHandler_OS_FileSysStatVolume', 'UT_DefaultHandler_OS_TranslatePath', 'UT_DefaultHandler_OS_HeapGetInfo', 'UT_DefaultHandler_OS_ObjectIdToArrayIndex', 'UT_DefaultHandler_OS_GetResourceName', 'UT_DefaultHandler_OS_ForEachObjectOfType', 'UT_DefaultHandler_OS_ForEachObject', 'UT_DefaultHandler_OS_ModuleInfo', 'UT_DefaultHandler_OS_SymbolLookup', 'UT_DefaultHandler_OS_ModuleSymbolLookup', 'UT_DefaultHandler_OS_MutSemGetIdByName', 'UT_DefaultHandler_OS_MutSemGetInfo', 'UT_DefaultHandler_OS_NetworkGetHostName', 'UT_DefaultHandler_OS_QueueGet', 'UT_DefaultHandler_OS_QueueGetIdByName', 'UT_DefaultHandler_OS_QueueGetInfo', 'UT_DefaultHandler_OS_SocketRecvFrom', 'UT_DefaultHandler_OS_SocketGetIdByName', 'UT_DefaultHandler_OS_SocketGetInfo', 'UT_DefaultHandler_OS_SocketAddrInit', 'UT_DefaultHandler_OS_SocketAddrToString', 'UT_DefaultHandler_OS_SocketAddrFromString', 'UT_DefaultHandler_OS_SocketAddrGetPort', 'UT_DefaultHandler_OS_TaskGetIdByName', 'UT_DefaultHandler_OS_TaskGetInfo', 'UT_DefaultHandler_OS_TaskFindIdBySystemData', 'UT_DefaultHandler_OS_TimerGetIdByName', 'UT_DefaultHandler_OS_TimerGetInfo', 'UT_DefaultHandler_OS_TimeBaseGetIdByName', 'UT_DefaultHandler_OS_TimeBaseGetInfo', 'UT_DefaultHandler_OS_TimeBaseGetFreeRun']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_DefaultHandler_OS_BinSemGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_BinSemGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_GetLocalTime': {'callees': ['UT_Hook_GetArgPtr', 'UT_GetStubCount', 'UT_Stub_CopyToLocal', 'OS_TimeAssembleFromNanoseconds'], 'callers': []}, 'UT_DefaultHandler_OS_CountSemGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_CountSemGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_DirectoryRead': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_GetErrorName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_GenericReadStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_read', 'UT_DefaultHandler_OS_TimedRead']}, 'UT_DefaultHandler_OS_stat': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_FDGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_FileSysStatVolume': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_TranslatePath': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_HeapGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_ObjectIdToArrayIndex': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdDecompose'], 'callers': []}, 'UT_DefaultHandler_OS_GetResourceName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_ForEachObjectOfType': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_ForEachObject': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_ModuleInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SymbolLookup': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_ModuleSymbolLookup': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_MutSemGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_MutSemGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_NetworkGetHostName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGet': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'OS_ObjectIdToInteger', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_SocketRecvFrom': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_SocketGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_SocketAddrInit': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketAddrToString': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketAddrFromString': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_SocketAddrGetPort': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal'], 'callers': []}, 'UT_DefaultHandler_OS_TaskGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TaskGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TaskFindIdBySystemData': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TimerGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TimerGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TimeBaseGetIdByName': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TimeBaseGetInfo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_ObjIdCompose'], 'callers': []}, 'UT_DefaultHandler_OS_TimeBaseGetFreeRun': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_GetStubCount'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t (full struct/union/type definition)",
    "UT_EntryKey_t (typedef/definition)",
    "UT_GetStubEntry (declaration/definition or macro expansion)",
    "UT_ClearStubEntry (declaration/definition or macro expansion)",
    "UT_ENTRYTYPE_DATA_BUFFER (macro/enum definition)",
    "memcpy (declaration; e.g. <string.h>)",
    "size_t (typedef; e.g. <stddef.h>)",
    "NULL (macro definition)"
  ],
  "explanation": "For determining whether UT_Stub_CopyToLocal uses any language/compiler extensions you must inspect the actual definitions and declarations of the identifiers and types it uses (not just this function body). Specifically:\n\n- UT_StubTableEntry_t (full struct/union/type definition): The function dereferences and indexes fields of this type (Data, Buff, BasePtr, TotalSize, Position). The type's definition must be checked for language extensions such as anonymous structs/unions, zero-length arrays, flexible array members implemented as extensions, unnamed bit-fields, GCC/Clang attributes (__attribute__), packed/aligned pragmas, or other non\u2011standard constructs.\n\n- UT_EntryKey_t (typedef/definition): The key type passed into UT_GetStubEntry might itself be a compiler extension (e.g. typedefs using typeof/statement expressions). Its definition is required to rule out such extensions.\n\n- UT_GetStubEntry (declaration/definition or macro expansion): The call to this symbol could be a function or a macro that expands into compiler\u2011specific constructs (statement expressions, inline asm, typeof, attributes, etc.). Its real form must be inspected for extensions.\n\n- UT_ClearStubEntry (declaration/definition or macro expansion): Same rationale as UT_GetStubEntry \u2014 must ensure it is a plain function (or at least not a macro using language extensions).\n\n- UT_ENTRYTYPE_DATA_BUFFER (macro/enum definition): This argument may be a macro that expands to a compound literal, statement expression, or other extension; or it may be an enum/const \u2014 its definition is needed to confirm no extensions are used.\n\n- memcpy (declaration; e.g. <string.h>): Although standard, memcpy could be redefined as a macro or inline variant using compiler intrinsics/attributes. The actual declaration in the build must be checked to ensure no extension is introduced.\n\n- size_t (typedef; e.g. <stddef.h>): Verify that size_t is the standard typedef and not redefined via compiler extension.\n\n- NULL (macro definition): The code uses NULL (via UT_GetStubEntry return comparison). Some projects redefine NULL in nonstandard ways (e.g. ((void *)0) is standard C, but other forms could be extension-dependent); include to be thorough.\n\nCollectively these symbols are required because MISRA Language-Extensions checks must examine the original declarations/definitions (and any macros) that could hide compiler-specific or nonstandard constructs. Inspecting only the function body is insufficient to determine whether constructs used (types, macros, or called symbols) rely on language extensions."
}