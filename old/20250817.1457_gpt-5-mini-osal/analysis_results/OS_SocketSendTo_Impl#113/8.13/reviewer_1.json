{
  "user_message": "An agent A claimed that the following OS_SocketSendTo_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketSendTo_Impl.\n```c\nint32 OS_SocketSendTo_Impl(const OS_object_token_t *token, const void *buffer, size_t buflen,\n                           const OS_SockAddr_t *RemoteAddr)\n{\n    int                             os_result;\n    socklen_t                       addrlen;\n    const struct sockaddr *         sa;\n    OS_impl_file_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    sa = (const struct sockaddr *)&RemoteAddr->AddrData;\n    switch (sa->sa_family)\n    {\n        case AF_INET:\n            addrlen = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrlen = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            addrlen = 0;\n            break;\n    }\n\n    if (addrlen != RemoteAddr->ActualLength)\n    {\n        return OS_ERR_BAD_ADDRESS;\n    }\n\n    os_result = sendto(impl->fd, buffer, buflen, MSG_DONTWAIT, sa, addrlen);\n    if (os_result < 0)\n    {\n        OS_DEBUG(\"sendto: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n\n    return os_result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'impl' is declared as a non-const pointer (OS_impl_file_internal_record_t *impl) and is assigned from OS_OBJECT_TABLE_GET(...). In OS_SocketSendTo_Impl the code only reads impl->fd (no modification of the pointed object), so the pointer could/should be declared as pointing to a const-qualified type (const OS_impl_file_internal_record_t *impl) or the table accessor should return a pointer to const. The dereference of the parameter '*token' is not the issue (token is already const), but the non-const 'impl' violates the guidance that pointers should point to const-qualified types whenever possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_SocketSendTo_Impl(const OS_object_token_t *token, const void *buffer, size_t buflen,\n                           const OS_SockAddr_t *RemoteAddr)\n{\n    int                             os_result;\n    socklen_t                       addrlen;\n    const struct sockaddr *         sa;\n    OS_impl_file_internal_record_t *impl;\n\n    /* Probe log file to capture control flow and state for analysis */\n    FILE *log = fopen(\"/tmp/logs/907.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"ENTER OS_SocketSendTo_Impl: token=%p buffer=%p buflen=%zu RemoteAddr=%p\\n\",\n                (const void *)token, buffer, buflen, (const void *)RemoteAddr);\n        fflush(log);\n    }\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n\n    if (log != NULL)\n    {\n        /* Log information relevant to the Rule 8.13 report: the pointer returned from the table\n           and the fact that in source it is a non-const pointer (investigator note). */\n        fprintf(log, \"OS_OBJECT_TABLE_GET returned impl=%p (declared non-const in source)\\n\", (void *)impl);\n        if (impl != NULL)\n        {\n            /* Attempt to log the file descriptor that will be used for sendto. This is the key\n               state referenced in the violation scenario (impl->fd is only read). */\n            fprintf(log, \"impl->fd=%d\\n\", impl->fd);\n        }\n        else\n        {\n            fprintf(log, \"impl is NULL\\n\");\n        }\n        fflush(log);\n    }\n\n    sa = (const struct sockaddr *)&RemoteAddr->AddrData;\n    if (log != NULL)\n    {\n        fprintf(log, \"sa=%p sa_family=%d\\n\", (const void *)sa, (int)sa->sa_family);\n        fflush(log);\n    }\n\n    switch (sa->sa_family)\n    {\n        case AF_INET:\n            addrlen = sizeof(struct sockaddr_in);\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            addrlen = sizeof(struct sockaddr_in6);\n            break;\n#endif\n        default:\n            addrlen = 0;\n            break;\n    }\n\n    if (addrlen != RemoteAddr->ActualLength)\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \"addrlen mismatch: computed=%u RemoteAddr->ActualLength=%u -> returning OS_ERR_BAD_ADDRESS\\n\",\n                    (unsigned)addrlen, (unsigned)RemoteAddr->ActualLength);\n            fclose(log);\n        }\n\n        return OS_ERR_BAD_ADDRESS;\n    }\n\n    if (log != NULL)\n    {\n        fprintf(log, \"Calling sendto(fd=%d, buffer=%p, buflen=%zu, flags=%d, sa=%p, addrlen=%u)\\n\",\n                (impl != NULL) ? impl->fd : -1, buffer, buflen, MSG_DONTWAIT, (const void *)sa, (unsigned)addrlen);\n        fflush(log);\n    }\n\n    os_result = sendto(impl->fd, buffer, buflen, MSG_DONTWAIT, sa, addrlen);\n    if (os_result < 0)\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \"sendto error: %s (errno=%d) -> returning OS_ERROR\\n\", strerror(errno), errno);\n            fclose(log);\n        }\n\n        OS_DEBUG(\"sendto: %s\\n\", strerror(errno));\n        return OS_ERROR;\n    }\n\n    if (log != NULL)\n    {\n        fprintf(log, \"sendto success: bytes_sent=%d -> returning\\n\", os_result);\n        fclose(log);\n    }\n\n    return os_result;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketSendTo_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_SocketSendTo_Impl the local pointer impl is only used for read access (impl->fd) and is never used to modify the pointed object. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible \u2014 here the pointer could and should be declared as const OS_impl_file_internal_record_t *impl (or the table accessor could return a pointer-to-const). Changing the local declaration to point-to-const introduces no semantic problem (conversion from pointer-to-non-const to pointer-to-const is allowed) and prevents accidental modification via this pointer. The added test/logging is unrelated to the rule and the empty log simply indicates the function was not exercised. Recommendation: change the local declaration to const OS_impl_file_internal_record_t *impl (or update the accessor API to return const), which resolves the Rule 8.13 concern."
}