{
  "user_message": "An agent A claimed that the following OS_TimeBase_SigWaitImpl code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBase_SigWaitImpl.\n```c\nstatic uint32 OS_TimeBase_SigWaitImpl(osal_id_t obj_id)\n{\n    int                                 ret;\n    OS_object_token_t                   token;\n    OS_impl_timebase_internal_record_t *impl;\n    OS_timebase_internal_record_t *     timebase;\n    uint32                              interval_time;\n    int                                 sig;\n\n    interval_time = 0;\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMEBASE, obj_id, &token) == OS_SUCCESS)\n    {\n        impl     = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        ret = sigwait(&impl->sigset, &sig);\n\n        if (ret != 0)\n        {\n            /*\n             * the sigwait call failed.\n             * returning 0 will cause the process to repeat.\n             */\n        }\n        else if (impl->reset_flag == 0)\n        {\n            /*\n             * Normal steady-state behavior.\n             * interval_time reflects the configured interval time.\n             */\n            interval_time = timebase->nominal_interval_time;\n        }\n        else\n        {\n            /*\n             * Reset/First interval behavior.\n             * timer_set() was invoked since the previous interval occurred (if any).\n             * interval_time reflects the configured start time.\n             */\n            interval_time    = timebase->nominal_start_time;\n            impl->reset_flag = 0;\n        }\n    }\n\n    return interval_time;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memset(token, 0, sizeof(*token)) will write sizeof(OS_object_token_t) bytes starting at the address in token. If the caller passes token == NULL or a pointer to an object smaller than OS_object_token_t (for example a pointer to a different/shorter buffer), this will write out of bounds (NULL-dereference or buffer overflow). Although the shown caller OS_ObjectIdGetById passes &token (a local OS_object_token_t) and is therefore safe, the function OS_ObjectIdTransactionInit does not check the token pointer before using it. Hence, in the general case this use can result in out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_timebase_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/591.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nstatic uint32 OS_TimeBase_SigWaitImpl(osal_id_t obj_id)\n{\n    int                                 ret;\n    OS_object_token_t                   token;\n    OS_impl_timebase_internal_record_t *impl;\n    OS_timebase_internal_record_t *     timebase;\n    uint32                              interval_time;\n    int                                 sig;\n\n    interval_time = 0;\n\n    os_timebase_log(\"OS_TimeBase_SigWaitImpl START: obj_id=%u, token_addr=%p\", (unsigned)obj_id, (void *)&token);\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMEBASE, obj_id, &token) == OS_SUCCESS)\n    {\n        impl     = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        os_timebase_log(\"OS_ObjectIdGetById SUCCEEDED: obj_id=%u, token=%p, impl=%p, timebase=%p\", (unsigned)obj_id, (void *)&token, (void *)impl, (void *)timebase);\n\n        ret = sigwait(&impl->sigset, &sig);\n\n        os_timebase_log(\"sigwait returned: ret=%d, sig=%d, impl=%p\", ret, sig, (void *)impl);\n\n        if (ret != 0)\n        {\n            /*\n             * the sigwait call failed.\n             * returning 0 will cause the process to repeat.\n             */\n            os_timebase_log(\"sigwait failed (ret=%d). Will return interval_time=0 (repeat).\", ret);\n        }\n        else if (impl->reset_flag == 0)\n        {\n            /*\n             * Normal steady-state behavior.\n             * interval_time reflects the configured interval time.\n             */\n            interval_time = timebase->nominal_interval_time;\n            os_timebase_log(\"steady-state: reset_flag=0, nominal_interval_time=%u, interval_time=%u\", (unsigned)timebase->nominal_interval_time, (unsigned)interval_time);\n        }\n        else\n        {\n            /*\n             * Reset/First interval behavior.\n             * timer_set() was invoked since the previous interval occurred (if any).\n             * interval_time reflects the configured start time.\n             */\n            interval_time    = timebase->nominal_start_time;\n            impl->reset_flag = 0;\n            os_timebase_log(\"reset-state: reset_flag was non-zero, nominal_start_time=%u, interval_time=%u, reset_flag now=%d\", (unsigned)timebase->nominal_start_time, (unsigned)interval_time, impl->reset_flag);\n        }\n    }\n    else\n    {\n        os_timebase_log(\"OS_ObjectIdGetById FAILED for obj_id=%u; returning interval_time=0\", (unsigned)obj_id);\n    }\n\n    os_timebase_log(\"OS_TimeBase_SigWaitImpl END: obj_id=%u, returning interval_time=%u\", (unsigned)obj_id, (unsigned)interval_time);\n\n    return interval_time;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBase_SigWaitImpl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the shown OS_TimeBase_SigWaitImpl. Rule 21.17 concerns use of <string.h> functions (memcpy, memset, etc.) producing out-of-bounds accesses. The OS_TimeBase_SigWaitImpl code contains no calls to any <string.h> functions. The local variable token is passed as &token to OS_ObjectIdGetById, which is a valid address of a local object, so there is no out-of-bounds write caused by this function. Agent A\u2019s scenario references a memset(token,...) in some other routine (OS_ObjectIdTransactionInit) and speculates about a missing null check there; if such a memset exists and can be invoked with an invalid pointer, that other routine could violate Rule 21.17 \u2014 but that is a separate issue and not a violation in OS_TimeBase_SigWaitImpl itself. Therefore the report that OS_TimeBase_SigWaitImpl violates MISRA C 2023 Rule 21.17 is incorrect."
}