{
  "user_message": "An agent A claimed that the following OS_TimeBase_SigWaitImpl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBase_SigWaitImpl.\n```c\nstatic uint32 OS_TimeBase_SigWaitImpl(osal_id_t obj_id)\n{\n    int                                 ret;\n    OS_object_token_t                   token;\n    OS_impl_timebase_internal_record_t *impl;\n    OS_timebase_internal_record_t *     timebase;\n    uint32                              interval_time;\n    int                                 sig;\n\n    interval_time = 0;\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMEBASE, obj_id, &token) == OS_SUCCESS)\n    {\n        impl     = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        ret = sigwait(&impl->sigset, &sig);\n\n        if (ret != 0)\n        {\n            /*\n             * the sigwait call failed.\n             * returning 0 will cause the process to repeat.\n             */\n        }\n        else if (impl->reset_flag == 0)\n        {\n            /*\n             * Normal steady-state behavior.\n             * interval_time reflects the configured interval time.\n             */\n            interval_time = timebase->nominal_interval_time;\n        }\n        else\n        {\n            /*\n             * Reset/First interval behavior.\n             * timer_set() was invoked since the previous interval occurred (if any).\n             * interval_time reflects the configured start time.\n             */\n            interval_time    = timebase->nominal_start_time;\n            impl->reset_flag = 0;\n        }\n    }\n\n    return interval_time;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer variable 'timebase' is declared as OS_timebase_internal_record_t * but is only used for read access (reading nominal_start_time and nominal_interval_time). It could be declared as a pointer to const (const OS_timebase_internal_record_t *timebase) to prevent modification. Therefore Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TimeBase_LogProbe(const char *stage, osal_id_t obj_id,\n                                 OS_impl_timebase_internal_record_t *impl,\n                                 OS_timebase_internal_record_t *timebase,\n                                 int ret, int sig, uint32 interval_time)\n{\n    FILE *f = fopen(\"/tmp/logs/587.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Safely obtain values guarded by NULL checks */\n        int reset_flag_val = -1;\n        unsigned long long nominal_interval = 0ULL;\n        unsigned long long nominal_start = 0ULL;\n\n        if (impl != NULL)\n        {\n            reset_flag_val = impl->reset_flag;\n        }\n\n        if (timebase != NULL)\n        {\n            nominal_interval = (unsigned long long)timebase->nominal_interval_time;\n            nominal_start    = (unsigned long long)timebase->nominal_start_time;\n        }\n\n        fprintf(f,\n                \"Stage=%s, obj_id=%llu, impl=%p, timebase=%p, ret=%d, sig=%d, reset_flag=%d, nominal_interval=%llu, nominal_start=%llu, interval_time=%llu\\n\",\n                stage,\n                (unsigned long long)obj_id,\n                (void *)impl,\n                (void *)timebase,\n                ret,\n                sig,\n                reset_flag_val,\n                nominal_interval,\n                nominal_start,\n                (unsigned long long)interval_time);\n        fclose(f);\n    }\n}\n\nstatic uint32 OS_TimeBase_SigWaitImpl(osal_id_t obj_id)\n{\n    int                                 ret;\n    OS_object_token_t                   token;\n    OS_impl_timebase_internal_record_t *impl;\n    OS_timebase_internal_record_t *     timebase;\n    uint32                              interval_time;\n    int                                 sig;\n\n    interval_time = 0;\n\n    /* Log entry state */\n    OS_TimeBase_LogProbe(\"entry\", obj_id, NULL, NULL, 0, 0, interval_time);\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMEBASE, obj_id, &token) == OS_SUCCESS)\n    {\n        impl     = OS_OBJECT_TABLE_GET(OS_impl_timebase_table, token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, token);\n\n        /* Log after successfully obtaining object table entries */\n        OS_TimeBase_LogProbe(\"after_get\", obj_id, impl, timebase, 0, 0, interval_time);\n\n        ret = sigwait(&impl->sigset, &sig);\n\n        /* Log result of sigwait */\n        OS_TimeBase_LogProbe(\"after_sigwait\", obj_id, impl, timebase, ret, sig, interval_time);\n\n        if (ret != 0)\n        {\n            /*\n             * the sigwait call failed.\n             * returning 0 will cause the process to repeat.\n             */\n            OS_TimeBase_LogProbe(\"sigwait_failed\", obj_id, impl, timebase, ret, sig, interval_time);\n        }\n        else if (impl->reset_flag == 0)\n        {\n            /*\n             * Normal steady-state behavior.\n             * interval_time reflects the configured interval time.\n             */\n            interval_time = timebase->nominal_interval_time;\n\n            /* Log steady-state selection */\n            OS_TimeBase_LogProbe(\"steady_state_after\", obj_id, impl, timebase, ret, sig, interval_time);\n        }\n        else\n        {\n            /*\n             * Reset/First interval behavior.\n             * timer_set() was invoked since the previous interval occurred (if any).\n             * interval_time reflects the configured start time.\n             */\n            /* Log reset-before values */\n            OS_TimeBase_LogProbe(\"reset_before\", obj_id, impl, timebase, ret, sig, interval_time);\n\n            interval_time    = timebase->nominal_start_time;\n            impl->reset_flag = 0;\n\n            /* Log reset-after values */\n            OS_TimeBase_LogProbe(\"reset_after\", obj_id, impl, timebase, ret, sig, interval_time);\n        }\n    }\n\n    /* Log exit value */\n    OS_TimeBase_LogProbe(\"exit\", obj_id, NULL, NULL, 0, 0, interval_time);\n\n    return interval_time;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBase_SigWaitImpl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In the shown function the timebase pointer is only used for read access (reading nominal_interval_time and nominal_start_time) and is never used to modify the pointed object. Per MISRA C 2023 Rule 8.13 the pointer should be const-qualified when possible; therefore declaring it as const OS_timebase_internal_record_t *timebase would be the preferred (compliant) form. (Assigning the non-const pointer returned by the object-table macro to a const-qualified pointer is permitted and there is no evidence in the snippet that timebase needs to be mutable.)"
}