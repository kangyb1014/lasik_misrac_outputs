{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef int32_t int32;\nstatic void probe_ensure_log_dir(void)\n{\n    /* Create the directory if it doesn't exist. Ignore errors other than \"already exists\". */\n    if (mkdir(\"/tmp/logs\", 0777) != 0)\n    {\n        if (errno != EEXIST)\n        {\n            /* If directory creation fails for another reason, we still proceed and let fopen fail later. */\n        }\n    }\n}\nstatic void probe_log(const char *fmt, ...)\n{\n    probe_ensure_log_dir();\n\n    FILE *f = fopen(\"/tmp/logs/1354.txt\", \"a\");\n    if (!f)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    /* Timestamp for easier correlation */\n    time_t t = time(NULL);\n    struct tm tm;\n    if (localtime_r(&t, &tm) == NULL)\n    {\n        fprintf(f, \"[time=?] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tm) > 0)\n        {\n            fprintf(f, \"[%s] \", buf);\n        }\n        else\n        {\n            fprintf(f, \"[time=?] \");\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic int32 OS_TranslatePath(const char *path, char *local_path)\n{\n    if (path == NULL || local_path == NULL)\n    {\n        probe_log(\"OS_TranslatePath: invalid arguments path=%p local_path=%p\", (void*)path, (void*)local_path);\n        return -1; /* error */\n    }\n\n    /* Copy up to buffer size and ensure null termination */\n    strncpy(local_path, path, OS_MAX_LOCAL_PATH_LEN - 1);\n    local_path[OS_MAX_LOCAL_PATH_LEN - 1] = '\\0';\n\n    probe_log(\"OS_TranslatePath: input path='%s' -> local_path='%s'\", path, local_path);\n    return OS_SUCCESS;\n}\nstatic int32 OS_FileRemove_Impl(const char *local_path)\n{\n    if (local_path == NULL)\n    {\n        probe_log(\"OS_FileRemove_Impl: local_path is NULL\");\n        return -1;\n    }\n\n    /* For test purposes, do not actually remove files. Simulate success. */\n    probe_log(\"OS_FileRemove_Impl: called with local_path='%s' (simulated remove)\", local_path);\n    return OS_SUCCESS;\n}\n\nint32 OS_remove(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    probe_log(\"OS_remove: called with path='%s'\", path ? path : \"(null)\");\n\n    /* Preserve original logic: translate path, then remove if translation succeeds. */\n    return_code = OS_TranslatePath(path, local_path);\n    probe_log(\"OS_remove: OS_TranslatePath returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"OS_remove: translation successful, local_path='%s' - invoking OS_FileRemove_Impl\", local_path);\n        return_code = OS_FileRemove_Impl(local_path);\n        probe_log(\"OS_remove: OS_FileRemove_Impl returned %d\", return_code);\n    }\n    else\n    {\n        probe_log(\"OS_remove: translation failed with code %d, skipping file removal\", return_code);\n    }\n\n    probe_log(\"OS_remove: returning %d\", return_code);\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpp8zg1gif/src/src/os/shared/src/osapi-file.c:388:14: error: static declaration of 'OS_TranslatePath' follows non-static declaration\n  388 | static int32 OS_TranslatePath(const char *path, char *local_path)\n      |              ^~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpp8zg1gif/src/src/os/shared/src/osapi-file.c:58:\n/tmp/tmpp8zg1gif/src/src/os/inc/osapi-filesys.h:288:7: note: previous declaration of 'OS_TranslatePath' with type 'int32(const char *, char *)' {aka 'int(const char *, char *)'}\n  288 | int32 OS_TranslatePath(const char *VirtualPath, char *LocalPath);\n      |       ^~~~~~~~~~~~~~~~\n/tmp/tmpp8zg1gif/src/src/os/shared/src/osapi-file.c:403:14: error: static declaration of 'OS_FileRemove_Impl' follows non-static declaration\n  403 | static int32 OS_FileRemove_Impl(const char *local_path)\n      |              ^~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpp8zg1gif/src/src/os/shared/src/osapi-file.c:52:\n/tmp/tmpp8zg1gif/src/src/os/shared/inc/os-shared-file.h:155:7: note: previous declaration of 'OS_FileRemove_Impl' with type 'int32(const char *)' {aka 'int(const char *)'}\n  155 | int32 OS_FileRemove_Impl(const char *local_path);\n      |       ^~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_remove as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <time.h>\n\ntypedef int32_t int32;\n\nenum { OS_MAX_LOCAL_PATH_LEN = 256, OS_SUCCESS = 0 };\n\nstatic void probe_ensure_log_dir(void)\n{\n    /* Create the directory if it doesn't exist. Ignore errors other than \"already exists\". */\n    if (mkdir(\"/tmp/logs\", 0777) != 0)\n    {\n        if (errno != EEXIST)\n        {\n            /* If directory creation fails for another reason, we still proceed and let fopen fail later. */\n        }\n    }\n}\n\nstatic void probe_log(const char *fmt, ...)\n{\n    probe_ensure_log_dir();\n\n    FILE *f = fopen(\"/tmp/logs/1354.txt\", \"a\");\n    if (!f)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    /* Timestamp for easier correlation */\n    time_t t = time(NULL);\n    struct tm tm;\n    if (localtime_r(&t, &tm) == NULL)\n    {\n        fprintf(f, \"[time=?] \");\n    }\n    else\n    {\n        char buf[64];\n        if (strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", &tm) > 0)\n        {\n            fprintf(f, \"[%s] \", buf);\n        }\n        else\n        {\n            fprintf(f, \"[time=?] \");\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Removed 'static' to match external declaration in headers. */\nint32 OS_TranslatePath(const char *path, char *local_path)\n{\n    if (path == NULL || local_path == NULL)\n    {\n        probe_log(\"OS_TranslatePath: invalid arguments path=%p local_path=%p\", (void*)path, (void*)local_path);\n        return -1; /* error */\n    }\n\n    /* Copy up to buffer size and ensure null termination */\n    strncpy(local_path, path, OS_MAX_LOCAL_PATH_LEN - 1);\n    local_path[OS_MAX_LOCAL_PATH_LEN - 1] = '\\0';\n\n    probe_log(\"OS_TranslatePath: input path='%s' -> local_path='%s'\", path, local_path);\n    return OS_SUCCESS;\n}\n\n/* Removed 'static' to match external declaration in headers. */\nint32 OS_FileRemove_Impl(const char *local_path)\n{\n    if (local_path == NULL)\n    {\n        probe_log(\"OS_FileRemove_Impl: local_path is NULL\");\n        return -1;\n    }\n\n    /* For test purposes, do not actually remove files. Simulate success. */\n    probe_log(\"OS_FileRemove_Impl: called with local_path='%s' (simulated remove)\", local_path);\n    return OS_SUCCESS;\n}\n\nint32 OS_remove(const char *path)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    probe_log(\"OS_remove: called with path='%s'\", path ? path : \"(null)\");\n\n    /* Preserve original logic: translate path, then remove if translation succeeds. */\n    return_code = OS_TranslatePath(path, local_path);\n    probe_log(\"OS_remove: OS_TranslatePath returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"OS_remove: translation successful, local_path='%s' - invoking OS_FileRemove_Impl\", local_path);\n        return_code = OS_FileRemove_Impl(local_path);\n        probe_log(\"OS_remove: OS_FileRemove_Impl returned %d\", return_code);\n    }\n    else\n    {\n        probe_log(\"OS_remove: translation failed with code %d, skipping file removal\", return_code);\n    }\n\n    probe_log(\"OS_remove: returning %d\", return_code);\n    return return_code;\n}\n",
  "explanation": "The build error was caused by defining OS_TranslatePath and OS_FileRemove_Impl as static while the headers declare them as non-static (external). I removed the static storage-class specifier from those two functions so their definitions match the (external) declarations. I also added the necessary includes and provided reasonable definitions for OS_MAX_LOCAL_PATH_LEN and OS_SUCCESS (via an enum) so the file compiles standalone while preserving the original OS_remove logic. No other logic was changed."
}