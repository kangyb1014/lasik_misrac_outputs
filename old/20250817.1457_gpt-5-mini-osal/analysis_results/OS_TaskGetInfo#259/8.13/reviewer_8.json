{
  "user_message": "An agent A claimed that the following OS_TaskGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskGetInfo.\n```c\nint32 OS_TaskGetInfo(osal_id_t task_id, OS_task_prop_t *task_prop)\n{\n    OS_common_record_t *       record;\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_prop);\n\n    memset(task_prop, 0, sizeof(OS_task_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_task_table, token);\n        task   = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(task_prop->name, record->name_entry, sizeof(task_prop->name) - 1);\n            task_prop->name[sizeof(task_prop->name) - 1] = 0;\n        }\n        task_prop->creator    = record->creator;\n        task_prop->stack_size = task->stack_size;\n        task_prop->priority   = task->priority;\n\n        return_code = OS_TaskGetInfo_Impl(&token, task_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro OS_OBJECT_TABLE_GET(tbl, tok) expands to &tbl[OS_ObjectIndexFromToken(&(tok))], yielding a pointer to a non-const element. In OS_TaskGetInfo this is used as:\n- record = OS_OBJECT_TABLE_GET(OS_global_task_table, token); // yields OS_common_record_t *\n- task   = OS_OBJECT_TABLE_GET(OS_task_table, token);        // yields OS_task_internal_record_t *\nBoth 'record' and 'task' are only read (fields are accessed but not modified), so they could/should be declared as pointers to const (e.g. const OS_common_record_t * and const OS_task_internal_record_t *). Because the macro and resulting pointers are not const-qualified where they could be, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_TaskGetInfo(osal_id_t task_id, OS_task_prop_t *task_prop)\n{\n    OS_common_record_t *       record;\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Open log for probe information */\n    FILE *log = fopen(\"/tmp/logs/2075.txt\", \"a\");\n    if (log)\n    {\n        fprintf(log, \"\\n--- OS_TaskGetInfo ENTRY ---\\n\");\n        fprintf(log, \"task_id (raw) = %lu\\n\", (unsigned long)task_id);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_prop);\n\n    memset(task_prop, 0, sizeof(OS_task_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (log)\n    {\n        fprintf(log, \"OS_ObjectIdGetById returned %ld\\n\", (long)return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_task_table, token);\n        task   = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        if (log)\n        {\n            fprintf(log, \"OS_OBJECT_TABLE_GET: record=%p, task=%p, token_addr=%p\\n\",\n                    (void *)record, (void *)task, (void *)&token);\n\n            if (record != NULL)\n            {\n                if (record->name_entry != NULL)\n                {\n                    /* print up to a reasonable length to avoid huge logs */\n                    char name_buf[128];\n                    strncpy(name_buf, record->name_entry, sizeof(name_buf) - 1);\n                    name_buf[sizeof(name_buf) - 1] = '\\0';\n                    fprintf(log, \"record->name_entry = '%s'\\n\", name_buf);\n                }\n                else\n                {\n                    fprintf(log, \"record->name_entry = NULL\\n\");\n                }\n\n                /* print creator if it's a scalar type (best effort) */\n                fprintf(log, \"record->creator = %lu\\n\", (unsigned long)record->creator);\n            }\n            else\n            {\n                fprintf(log, \"record is NULL\\n\");\n            }\n\n            if (task != NULL)\n            {\n                fprintf(log, \"task->stack_size = %lu\\n\", (unsigned long)task->stack_size);\n                fprintf(log, \"task->priority   = %lu\\n\", (unsigned long)task->priority);\n            }\n            else\n            {\n                fprintf(log, \"task is NULL\\n\");\n            }\n        }\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(task_prop->name, record->name_entry, sizeof(task_prop->name) - 1);\n            task_prop->name[sizeof(task_prop->name) - 1] = 0;\n        }\n        task_prop->creator    = record->creator;\n        task_prop->stack_size = task->stack_size;\n        task_prop->priority   = task->priority;\n\n        if (log)\n        {\n            fprintf(log, \"About to call OS_TaskGetInfo_Impl with token_addr=%p\\n\", (void *)&token);\n        }\n\n        return_code = OS_TaskGetInfo_Impl(&token, task_prop);\n\n        if (log)\n        {\n            fprintf(log, \"OS_TaskGetInfo_Impl returned %ld\\n\", (long)return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        if (log)\n        {\n            fprintf(log, \"OS_ObjectIdRelease called for token_addr=%p\\n\", (void *)&token);\n        }\n    }\n\n    if (log)\n    {\n        fprintf(log, \"OS_TaskGetInfo EXIT with return_code=%ld\\n\", (long)return_code);\n        fclose(log);\n    }\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n\n--- OS_TaskGetInfo ENTRY ---\ntask_id (raw) = 3735928559\nOS_ObjectIdGetById returned -35\nOS_TaskGetInfo EXIT with return_code=-35\n\n--- OS_TaskGetInfo ENTRY ---\ntask_id (raw) = 0\nOS_ObjectIdGetById returned -35\nOS_TaskGetInfo EXIT with return_code=-35\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 requires that pointer declarations should use a pointer-to-const type whenever the pointed-to object is not modified through that pointer. In the posted OS_TaskGetInfo implementation the local variables 'record' and 'task' are declared as non-const pointers (OS_common_record_t * and OS_task_internal_record_t *), yet they are only used for read-only access (their fields are accessed but never modified, and they are not passed to any callees that modify them). Therefore both could and should be declared as pointers to const (e.g. const OS_common_record_t * and const OS_task_internal_record_t *). The fact that the OS_OBJECT_TABLE_GET macro yields an address of a table element (a non-const object) does not prevent assigning that address to a pointer-to-const \u2014 such an implicit conversion is allowed and exactly what the rule encourages. Consequently the agent A report is correct: the code violates MISRA C 2023 Rule 8.13."
}