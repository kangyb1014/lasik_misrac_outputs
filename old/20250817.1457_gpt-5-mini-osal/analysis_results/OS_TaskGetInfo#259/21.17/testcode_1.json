{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe strncpy call uses sizeof(task_prop->name) - 1 as the maximum copy length but does not guarantee that record->name_entry points to a source buffer that is at least that long or that it is NUL-terminated within that many bytes. If record->name_entry refers to a shorter buffer or a non-NUL-terminated string, strncpy may read past the end of the source object, violating Rule 21.17. (The destination sizing is safe, but the source length is not validated.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskGetInfo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2079.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskGetInfo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskGetInfo:\n```c\nint32 OS_TaskGetInfo(osal_id_t task_id, OS_task_prop_t *task_prop)\n{\n    OS_common_record_t *       record;\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_prop);\n\n    memset(task_prop, 0, sizeof(OS_task_prop_t));\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_task_table, token);\n        task   = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(task_prop->name, record->name_entry, sizeof(task_prop->name) - 1);\n            task_prop->name[sizeof(task_prop->name) - 1] = 0;\n        }\n        task_prop->creator    = record->creator;\n        task_prop->stack_size = task->stack_size;\n        task_prop->priority   = task->priority;\n\n        return_code = OS_TaskGetInfo_Impl(&token, task_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskGetInfo code.\n",
  "test_code": "static size_t safe_strnlen(const char *s, size_t max)\n{\n    size_t i;\n\n    if (s == NULL)\n        return 0;\n\n    for (i = 0; i < max; ++i)\n    {\n        if (s[i] == '\\0')\n            return i;\n    }\n\n    return max;\n}\n\nint32 OS_TaskGetInfo(osal_id_t task_id, OS_task_prop_t *task_prop)\n{\n    OS_common_record_t *       record;\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(task_prop);\n\n    memset(task_prop, 0, sizeof(OS_task_prop_t));\n\n    /* Log entry and parameters */\n    {\n        FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n        if (logf)\n        {\n            /* task_id may be an integer typedef in this codebase; cast to unsigned long for logging */\n            fprintf(logf, \"OS_TaskGetInfo ENTRY: task_id=%lu task_prop=%p\\n\",\n                    (unsigned long)task_id,\n                    (void *)task_prop);\n            fclose(logf);\n        }\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_task_table, token);\n        task   = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Log resolved objects */\n        {\n            FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"OS_TaskGetInfo: resolved token. record=%p task=%p name_entry=%p\\n\",\n                        (void *)record, (void *)task, (void *)(record ? record->name_entry : NULL));\n                fclose(logf);\n            }\n        }\n\n        if (record->name_entry != NULL)\n        {\n            size_t max_copy = sizeof(task_prop->name) - 1;\n\n            /* Compute reported source length up to the same limit used for strncpy. This mirrors the\n             * existing strncpy behavior (so we don't increase the risk of out-of-bounds reads), and\n             * provides evidence whether the source has a NUL within that bound. */\n            size_t src_len = safe_strnlen(record->name_entry, max_copy);\n\n            {\n                FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf,\n                            \"OS_TaskGetInfo: about to strncpy: dest=%p dest_size=%zu max_copy=%zu src=%p src_len_reported=%zu\\n\",\n                            (void *)task_prop->name, sizeof(task_prop->name), max_copy, (void *)record->name_entry, src_len);\n\n                    if (src_len == max_copy)\n                    {\n                        fprintf(logf, \"OS_TaskGetInfo WARNING: source has no NUL within max_copy -> potential out-of-bounds read by strncpy\\n\");\n                    }\n\n                    fclose(logf);\n                }\n            }\n\n            /* Original copy logic preserved */\n            strncpy(task_prop->name, record->name_entry, max_copy);\n            task_prop->name[max_copy] = 0;\n\n            /* Log resulting destination contents (safe: destination is sized) */\n            {\n                FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n                if (logf)\n                {\n                    fprintf(logf, \"OS_TaskGetInfo: after strncpy dest_name='%s'\\n\", task_prop->name);\n                    fclose(logf);\n                }\n            }\n        }\n        task_prop->creator    = record->creator;\n        task_prop->stack_size = task->stack_size;\n        task_prop->priority   = task->priority;\n\n        /* Log other fields prior to calling platform-specific implementation */\n        {\n            FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"OS_TaskGetInfo: creator=%u stack_size=%lu priority=%u\\n\",\n                        (unsigned)task_prop->creator,\n                        (unsigned long)task_prop->stack_size,\n                        (unsigned)task_prop->priority);\n                fclose(logf);\n            }\n        }\n\n        return_code = OS_TaskGetInfo_Impl(&token, task_prop);\n\n        /* Log return from implementation */\n        {\n            FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n            if (logf)\n            {\n                fprintf(logf, \"OS_TaskGetInfo: OS_TaskGetInfo_Impl returned %d\\n\", return_code);\n                fclose(logf);\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    /* Log exit */\n    {\n        FILE *logf = fopen(\"/tmp/logs/2079.txt\", \"a\");\n        if (logf)\n        {\n            fprintf(logf, \"OS_TaskGetInfo EXIT: return_code=%d\\n\", return_code);\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n"
}