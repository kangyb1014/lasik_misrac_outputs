{
  "user_message": "An agent A claimed that the following OS_cp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_cp.\n```c\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 potential violation: local_path is a fixed-size buffer (char local_path[OS_MAX_LOCAL_PATH_LEN]) passed to OS_TranslatePath and then to OS_FileOpen_Impl without passing its size. If OS_TranslatePath or OS_FileOpen_Impl use <string.h> functions (e.g. strcpy, strcat, strlen, memcpy) assuming the buffer is large enough or null-terminated, a long input path (longer than OS_MAX_LOCAL_PATH_LEN-1) could cause writes or reads beyond local_path bounds. For example: a very long 'path' causes OS_TranslatePath to copy more bytes into local_path than its capacity (or fail to NUL-terminate); later OS_FileOpen_Impl calls strlen/strcpy/strcat/memcpy on local_path and thus performs out-of-bounds access. Because the buffer length is not communicated/checked, the fragment can lead to a Rule 21.17 violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_cp_log_raw(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1335.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void OS_cp_log_enter(const char *src, const char *dest)\n{\n    /* Log entry and pointer values only (do not dereference potentially unterminated strings). */\n    OS_cp_log_raw(\"ENTER: OS_cp(src=%p, dest=%p)\", (const void *)src, (const void *)dest);\n    if (src == NULL)\n    {\n        OS_cp_log_raw(\"ENTER: src is NULL\");\n    }\n    else\n    {\n        OS_cp_log_raw(\"ENTER: src pointer non-NULL (content not logged to avoid OOB read)\");\n    }\n    if (dest == NULL)\n    {\n        OS_cp_log_raw(\"ENTER: dest is NULL\");\n    }\n    else\n    {\n        OS_cp_log_raw(\"ENTER: dest pointer non-NULL (content not logged to avoid OOB read)\");\n    }\n}\nstatic void OS_cp_log_open_result(int return_code, void *file1, void *file2)\n{\n    OS_cp_log_raw(\"OPEN_RESULT: return_code=%d, file1=%p, file2=%p\", return_code, file1, file2);\n}\nstatic void OS_cp_log_read(int file1, int requested, int rd_size)\n{\n    OS_cp_log_raw(\"READ: file1=%d, requested=%d, rd_size=%d\", file1, requested, rd_size);\n}\nstatic void OS_cp_log_write_attempt(int file2, int to_write, int wr_size, int wr_total)\n{\n    OS_cp_log_raw(\"WRITE: file2=%d, to_write=%d, wr_size=%d, wr_total=%d\", file2, to_write, wr_size, wr_total);\n}\nstatic void OS_cp_log_close_and_return(int32 return_code, osal_id_t file1, osal_id_t file2)\n{\n    OS_cp_log_raw(\"EXIT: return_code=%d, file1=%p, file2=%p\", (int)return_code, (void *)file1, (void *)file2);\n}\n\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Probe log: entry */\n    OS_cp_log_enter(src, dest);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n\n    /* Log result of first open */\n    OS_cp_log_open_result(return_code, (void *)file1, (void *)file2);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n        /* Log result of second open */\n        OS_cp_log_open_result(return_code, (void *)file1, (void *)file2);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        /* Log upcoming read request */\n        OS_cp_log_raw(\"LOOP: preparing to read up to %zu bytes\", sizeof(copyblock));\n\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n\n        /* Log read results */\n        OS_cp_log_read((int)file1, (int)sizeof(copyblock), (int)rd_size);\n\n        if (rd_size < 0)\n        {\n            OS_cp_log_raw(\"ERROR: OS_read returned negative value: %d\", (int)rd_size);\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            OS_cp_log_raw(\"INFO: OS_read returned 0 (EOF)\");\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n\n            /* Log each write attempt */\n            OS_cp_log_write_attempt((int)file2, (int)(rd_size - wr_total), (int)wr_size, (int)wr_total);\n\n            if (wr_size < 0)\n            {\n                OS_cp_log_raw(\"ERROR: OS_write returned negative value: %d\", (int)wr_size);\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_cp_log_raw(\"CLOSE: closing file1=%p\", (void *)file1);\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_cp_log_raw(\"CLOSE: closing file2=%p\", (void *)file2);\n        OS_close(file2);\n    }\n\n    /* Final exit log */\n    OS_cp_log_close_and_return(return_code, file1, file2);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_cp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for this OS_cp fragment. MISRA C:2023 Rule 21.17 specifically concerns the use of the <string.h> functions (strlen/strcpy/memcpy/etc.) and ensuring those calls cannot access beyond the bounds of the objects pointed to by their pointer parameters. The OS_cp implementation shown does not call any <string.h> functions; it only forwards the const char *src and const char *dest pointers to OS_OpenCreate and performs file I/O with OS_read/OS_write. Any misuse of string.h functions (overflow or OOB reads) would be an issue in the implementations of OS_OpenCreate, OS_TranslatePath, OS_FileOpen_Impl, etc., not in this OS_cp function itself. Note: OS_cp does check pointers for NULL (OS_CHECK_POINTER), but it does not and need not know caller buffer lengths \u2014 ensuring that src/dest point to valid NUL\u2011terminated strings is the caller\u2019s responsibility and/or the responsibility of the callee functions that operate on those strings. Therefore agent A\u2019s scenario describes a possible vulnerability in other modules, but does not establish a Rule 21.17 violation in this OS_cp code fragment."
}