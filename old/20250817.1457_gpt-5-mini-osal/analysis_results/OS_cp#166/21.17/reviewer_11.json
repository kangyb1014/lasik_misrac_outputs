{
  "user_message": "An agent A claimed that the following OS_cp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_cp.\n```c\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_OpenCreate forwards the caller-supplied src to OS_TranslatePath which copies/translates into a fixed local_path buffer of size OS_MAX_LOCAL_PATH_LEN but no buffer length is provided. If src points to a path string whose length >= OS_MAX_LOCAL_PATH_LEN, a string handling function used inside OS_TranslatePath (e.g. strcpy/memcpy/strcat) may write beyond local_path (or read/write beyond the src/destination buffers), violating Rule 21.17. The caller only checks src != NULL, not its length, so passing an overly long path demonstrates the violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void ensure_log_dir(void)\n{\n    /* Try to create the directory if it does not exist. Ignore errors if it already exists. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n}\nstatic void log_event(const char *fmt, ...)\n{\n    ensure_log_dir();\n    FILE *f = fopen(\"/tmp/logs/1335.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fflush(f);\n    fclose(f);\n}\nstatic size_t safe_strnlen(const char *s, size_t max)\n{\n    size_t i;\n    if (s == NULL)\n        return 0;\n    for (i = 0; i < max; ++i)\n    {\n        if (s[i] == '\\0')\n            return i;\n    }\n    return max;\n}\nstatic void log_string_preview(FILE *f, const char *s, size_t maxchars)\n{\n    size_t i;\n    for (i = 0; i < maxchars && s[i] != '\\0'; ++i)\n    {\n        unsigned char c = (unsigned char)s[i];\n        if (c >= 32 && c < 127)\n            fputc(c, f);\n        else\n            fputc('.', f);\n    }\n    if (i == maxchars && s[i] != '\\0')\n    {\n        fputs(\"...\", f);\n    }\n}\n\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    /* Log entry and parameter information (safe) */\n    {\n        size_t src_len = safe_strnlen(src, 4096);\n        size_t dest_len = safe_strnlen(dest, 4096);\n        ensure_log_dir();\n        FILE *f = fopen(\"/tmp/logs/1335.txt\", \"a\");\n        if (f)\n        {\n            fprintf(f, \"OS_cp ENTRY: src=%p dest=%p\\n\", (void *)src, (void *)dest);\n            fprintf(f, \"OS_cp PARAMS: src_len=%zu dest_len=%zu\\n\", src_len, dest_len);\n            fprintf(f, \"OS_cp SRC_PREVIEW: '\");\n            log_string_preview(f, src ? src : \"(null)\", 256);\n            fprintf(f, \"'\\n\");\n            fprintf(f, \"OS_cp DEST_PREVIEW: '\");\n            log_string_preview(f, dest ? dest : \"(null)\", 256);\n            fprintf(f, \"'\\n\");\n            fclose(f);\n        }\n    }\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n\n    /* Log result of opening source */\n    log_event(\"OS_cp: OS_OpenCreate(source) returned %d file1=%d\\n\", (int)return_code, (int)file1);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n        log_event(\"OS_cp: OS_OpenCreate(dest) returned %d file2=%d\\n\", (int)return_code, (int)file2);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        log_event(\"OS_cp: OS_read returned rd_size=%d\\n\", (int)rd_size);\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            log_event(\"OS_cp: read error, setting return_code=%d\\n\", (int)return_code);\n            break;\n        }\n        if (rd_size == 0)\n        {\n            log_event(\"OS_cp: reached EOF (rd_size==0)\\n\");\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            log_event(\"OS_cp: OS_write requested=%d wrote=%d\\n\", (int)(rd_size - wr_total), (int)wr_size);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                log_event(\"OS_cp: write error, setting return_code=%d\\n\", (int)return_code);\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n        log_event(\"OS_cp: closed file1=%d\\n\", (int)file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n        log_event(\"OS_cp: closed file2=%d\\n\", (int)file2);\n    }\n\n    log_event(\"OS_cp EXIT: return_code=%d\\n\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_cp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not attributable to OS_cp itself. MISRA C:2023 Rule 21.17 concerns the use of <string.h> functions that can access beyond the bounds of the objects referenced by their pointer parameters. The OS_cp implementation shown does not call any string.h routines; it only checks pointers for NULL and forwards the src/dest pointers to OS_OpenCreate. If a buffer overflow can occur it would be caused by unsafe string handling inside OS_OpenCreate/OS_TranslatePath (or some other callee), not by OS_cp directly. \n\nTherefore Agent A's scenario is plausible (passing an overly long src could trigger an out-of-bounds write inside OS_TranslatePath if that function uses unsafe strcpy/memcpy/strcat without size checks), but the actual violation would be in the implementation of OS_OpenCreate/OS_TranslatePath. The claim that OS_cp itself violates MISRA 21.17 is incorrect. To remediate: inspect and fix OS_OpenCreate/OS_TranslatePath to use bounded string APIs or accept a buffer length and validate input lengths (or have callers enforce max path length) so that no string.h call can access beyond its object bounds."
}