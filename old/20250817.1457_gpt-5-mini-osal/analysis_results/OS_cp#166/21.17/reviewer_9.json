{
  "user_message": "An agent A claimed that the following OS_cp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_cp.\n```c\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes a fixed-size local_path buffer (char local_path[OS_MAX_LOCAL_PATH_LEN]) to OS_TranslatePath without supplying its size. If OS_TranslatePath internally uses functions from <string.h> such as strcpy, strcat or memcpy without checking/truncating to OS_MAX_LOCAL_PATH_LEN, a long path string can be copied/concatenated past the end of local_path (e.g. strcpy(local_path, path) when strlen(path) >= OS_MAX_LOCAL_PATH_LEN), causing writes beyond the object bounds and violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OSCP_LogState(const char *stage,\n                          const char *src,\n                          const char *dest,\n                          long long file1_id,\n                          long long file2_id,\n                          int rd_size,\n                          int wr_size,\n                          int wr_total,\n                          int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1335.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log stage, pointer values, file ids (as numeric), sizes and return code */\n    fprintf(f, \"[OS_cp] %s: src=%p dest=%p file1=%lld file2=%lld rd_size=%d wr_size=%d wr_total=%d return=%d\\n\",\n            stage, (void *)src, (void *)dest, file1_id, file2_id, rd_size, wr_size, wr_total, return_code);\n\n    fclose(f);\n}\n\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    /* Initial log entry */\n    OSCP_LogState(\"enter\", src, dest, (long long)OS_OBJECT_ID_UNDEFINED, (long long)OS_OBJECT_ID_UNDEFINED, -1, -1, -1, -999);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n\n    /* Log result of opening source */\n    OSCP_LogState(\"after_open_src\", src, dest, (long long)file1, (long long)file2, -1, -1, -1, (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n        /* Log result of opening/creating dest */\n        OSCP_LogState(\"after_open_dest\", src, dest, (long long)file1, (long long)file2, -1, -1, -1, (int)return_code);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n\n        /* Log read result */\n        OSCP_LogState(\"after_read\", src, dest, (long long)file1, (long long)file2, (int)rd_size, -1, -1, (int)return_code);\n\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            OSCP_LogState(\"read_error\", src, dest, (long long)file1, (long long)file2, (int)rd_size, -1, -1, (int)return_code);\n            break;\n        }\n        if (rd_size == 0)\n        {\n            /* EOF */\n            OSCP_LogState(\"read_eof\", src, dest, (long long)file1, (long long)file2, 0, -1, -1, (int)return_code);\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n\n            /* Log write attempt */\n            OSCP_LogState(\"after_write\", src, dest, (long long)file1, (long long)file2, (int)rd_size, (int)wr_size, (int)wr_total, (int)return_code);\n\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                OSCP_LogState(\"write_error\", src, dest, (long long)file1, (long long)file2, (int)rd_size, (int)wr_size, (int)wr_total, (int)return_code);\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OSCP_LogState(\"close_file1\", src, dest, (long long)file1, (long long)file2, -1, -1, -1, (int)return_code);\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OSCP_LogState(\"close_file2\", src, dest, (long long)file1, (long long)file2, -1, -1, -1, (int)return_code);\n        OS_close(file2);\n    }\n\n    OSCP_LogState(\"exit\", src, dest, (long long)file1, (long long)file2, -1, -1, -1, (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_cp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the provided OS_cp implementation. Rule 21.17 concerns calls to string.h functions that can write past the bounds of the objects referenced by their pointer parameters. The OS_cp code shown performs file open/read/write/close operations and manipulates a local byte buffer (copyblock) with OS_read/OS_write; it contains no calls to any <string.h> functions (strcpy, strcat, memcpy, etc.). Therefore OS_cp itself cannot, based on the shown code, violate Rule 21.17.\n\nThe scenario described by agent A involves an OS_TranslatePath that copies into a fixed-size local_path without a size argument. If true, that would be a potential Rule 21.17 violation \u2014 but it would be a problem in OS_TranslatePath (or in OS_OpenCreate if it invokes OS_TranslatePath incorrectly), not in OS_cp. In other words, a defective implementation of OS_TranslatePath/OS_OpenCreate might violate Rule 21.17, but that does not make the OS_cp function (as shown) non-compliant.\n\nAlso, the empty test log has no bearing on whether OS_cp uses string.h functions; it only indicates the test harness did not exercise the function or logging did not occur.\n\nRecommendation: inspect the implementations of OS_OpenCreate and OS_TranslatePath (or any other function called by OS_cp) for unsafe uses of string.h functions and ensure they use size-aware APIs or proper bounds checks. But the specific claim that OS_cp violates MISRA C 2023 Rule 21.17 is incorrect."
}