{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_cp:\n```c\nint32 OS_cp(const char *src, const char *dest)\n{\n    int32     return_code;\n    int32     rd_size;\n    int32     wr_size;\n    int32     wr_total;\n    osal_id_t file1;\n    osal_id_t file2;\n    uint8     copyblock[OS_CP_BLOCK_SIZE];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(src);\n    OS_CHECK_POINTER(dest);\n\n    file1       = OS_OBJECT_ID_UNDEFINED;\n    file2       = OS_OBJECT_ID_UNDEFINED;\n    return_code = OS_OpenCreate(&file1, src, OS_FILE_FLAG_NONE, OS_READ_ONLY);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_OpenCreate(&file2, dest, OS_FILE_FLAG_CREATE | OS_FILE_FLAG_TRUNCATE, OS_WRITE_ONLY);\n    }\n\n    while (return_code == OS_SUCCESS)\n    {\n        rd_size = OS_read(file1, copyblock, sizeof(copyblock));\n        if (rd_size < 0)\n        {\n            return_code = rd_size;\n            break;\n        }\n        if (rd_size == 0)\n        {\n            break;\n        }\n        wr_total = 0;\n        while (wr_total < rd_size)\n        {\n            wr_size = OS_write(file2, &copyblock[wr_total], rd_size - wr_total);\n            if (wr_size < 0)\n            {\n                return_code = wr_size;\n                break;\n            }\n            wr_total += wr_size;\n        }\n    }\n\n    if (OS_ObjectIdDefined(file1))\n    {\n        OS_close(file1);\n    }\n    if (OS_ObjectIdDefined(file2))\n    {\n        OS_close(file2);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_cp:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CP_BLOCK_SIZE 512\n...\ntypedef int32_t   int32\n...\ntypedef uint8_t   uint8\n...\ntypedef uint32 osal_id_t\n...\n#define OS_OBJECT_ID_UNDEFINED ((osal_id_t){0})\n...\n#define OS_SUCCESS (0)\n...\n#define OS_READ_ONLY 0\n...\n#define OS_WRITE_ONLY 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define OS_OBJECT_ID_UNDEFINED ((osal_id_t){0})\n```\nFocus on the above code fragment and judge whether it violates the rule 1.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The macro uses a C99 compound literal ((osal_id_t){0}), which is part of standard ISO C (C99 and later) rather than a compiler-specific extension, so Rule 1.2 is not violated."
}