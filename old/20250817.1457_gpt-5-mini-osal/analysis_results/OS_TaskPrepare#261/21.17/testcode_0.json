{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to memset(token, 0, sizeof(*token)) can access memory out-of-bounds if the caller passes a NULL or invalid token pointer. OS_ObjectIdTransactionInit does not validate that token is non-NULL before calling memset, so any caller that supplies NULL (or an invalid pointer) will cause memset to dereference that pointer and violate the rule. For example, if some caller invokes OS_ObjectIdTransactionInit(lock_mode, idtype, NULL) or passes an uninitialized pointer, the memset will result in an out-of-bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskPrepare code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2095.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskPrepare as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskPrepare:\n```c\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        return_code = OS_TaskMatch_Impl(&token);\n        *entrypt    = task->entry_function_pointer;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TaskRegister_Impl(task_id);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Give event callback to the application */\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        *entrypt = NULL;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskPrepare code.\n",
  "test_code": "/* Probe-enhanced OS_TaskPrepare for logging control flow and state.\n * Writes logs to /tmp/logs/2095.txt. This file is appended each call.\n * The original logic is preserved; only non-invasive logging calls were added.\n */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n/* Keep original signature exactly as provided. The surrounding build\n * environment is expected to provide the actual type definitions and\n * function implementations referenced below. */\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Helper: append a formatted log line with timestamp to the logfile. */\n    static void probe_log(const char *fmt, ...)\n    {\n        FILE *f = fopen(\"/tmp/logs/2095.txt\", \"a\");\n        if (f == NULL)\n        {\n            return; /* Do not disturb program flow if logging fails. */\n        }\n\n        time_t t = time(NULL);\n        struct tm tm_buf;\n        if (localtime_r(&t, &tm_buf) != NULL)\n        {\n            char timestr[64];\n            if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf) > 0)\n            {\n                fprintf(f, \"%s - \", timestr);\n            }\n        }\n\n        va_list ap;\n        va_start(ap, fmt);\n        vfprintf(f, fmt, ap);\n        va_end(ap);\n\n        fprintf(f, \"\\n\");\n        fflush(f);\n        fclose(f);\n    }\n\n    /* Log entry into function with inputs */\n    probe_log(\"OS_TaskPrepare ENTER: task_id=%u, entrypt=%p\", (unsigned)task_id, (void *)entrypt);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    probe_log(\"After OS_ObjectIdGetById: return_code=%d, token_addr=%p\", (int)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n        probe_log(\"Resolved task pointer: task=%p\", (void *)task);\n\n        return_code = OS_TaskMatch_Impl(&token);\n        probe_log(\"After OS_TaskMatch_Impl: return_code=%d, token_addr=%p\", (int)return_code, (void *)&token);\n\n        /* Log the task's entry_function_pointer if task appears non-NULL. */\n        if (task != NULL)\n        {\n            probe_log(\"Task entry_function_pointer (about to assign): %p\", (void *)task->entry_function_pointer);\n        }\n        else\n        {\n            probe_log(\"Warning: task is NULL after OS_OBJECT_TABLE_GET\");\n        }\n\n        *entrypt    = task->entry_function_pointer;\n        probe_log(\"Assigned *entrypt = %p (entrypt pointer=%p)\", (void *)task->entry_function_pointer, (void *)entrypt);\n\n        OS_ObjectIdRelease(&token);\n        probe_log(\"Called OS_ObjectIdRelease on token at %p\", (void *)&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TaskRegister_Impl(task_id);\n        probe_log(\"After OS_TaskRegister_Impl: return_code=%d\", (int)return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Give event callback to the application */\n        probe_log(\"About to call OS_NotifyEvent: event=OS_EVENT_TASK_STARTUP, task_id=%u\", (unsigned)task_id);\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n        probe_log(\"After OS_NotifyEvent: return_code=%d\", (int)return_code);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Failure path: return_code=%d, setting *entrypt = NULL (entrypt=%p)\", (int)return_code, (void *)entrypt);\n        *entrypt = NULL;\n    }\n    else\n    {\n        probe_log(\"Success path: return_code=%d, final entrypt=%p, *entrypt=%p\", (int)return_code, (void *)entrypt, (void *)(entrypt ? *entrypt : NULL));\n    }\n\n    probe_log(\"OS_TaskPrepare EXIT: return_code=%d\", (int)return_code);\n    return return_code;\n}\n"
}