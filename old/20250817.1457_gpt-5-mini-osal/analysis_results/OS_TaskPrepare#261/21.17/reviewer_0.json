{
  "user_message": "An agent A claimed that the following OS_TaskPrepare code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskPrepare.\n```c\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        return_code = OS_TaskMatch_Impl(&token);\n        *entrypt    = task->entry_function_pointer;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TaskRegister_Impl(task_id);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Give event callback to the application */\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        *entrypt = NULL;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to memset(token, 0, sizeof(*token)) can access memory out-of-bounds if the caller passes a NULL or invalid token pointer. OS_ObjectIdTransactionInit does not validate that token is non-NULL before calling memset, so any caller that supplies NULL (or an invalid pointer) will cause memset to dereference that pointer and violate the rule. For example, if some caller invokes OS_ObjectIdTransactionInit(lock_mode, idtype, NULL) or passes an uninitialized pointer, the memset will result in an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\ntypedef void (*osal_task_entry)(void);\ntypedef struct\n{\n    uint32_t index;\n} OS_object_token_t;\ntypedef struct\n{\n    osal_task_entry entry_function_pointer;\n} OS_task_internal_record_t;\nint32 OS_ObjectIdGetById(int lock_mode, int object_type, osal_id_t id, OS_object_token_t *token);\nint32 OS_TaskMatch_Impl(OS_object_token_t *token);\nvoid  OS_ObjectIdRelease(OS_object_token_t *token);\nint32 OS_TaskRegister_Impl(osal_id_t id);\nint32 OS_NotifyEvent(int event, osal_id_t id, void *data);\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2095.txt\", \"a\");\n    if (f == NULL)\n    {\n        return; /* Do not disturb program flow if logging fails. */\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    if (localtime_r(&t, &tm_buf) != NULL)\n    {\n        char timestr[64];\n        if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf) > 0)\n        {\n            fprintf(f, \"%s - \", timestr);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nstatic int32 OS_TaskPrepare(osal_id_t task_id, osal_task_entry *entrypt)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Log entry into function with inputs */\n    probe_log(\"OS_TaskPrepare ENTER: task_id=%u, entrypt=%p\", (unsigned)task_id, (void *)entrypt);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, OS_OBJECT_TYPE_OS_TASK, task_id, &token);\n    probe_log(\"After OS_ObjectIdGetById: return_code=%d, token_addr=%p\", (int)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Resolve the task pointer from the table using the token.index */\n        task = &OS_task_table[token.index];\n        probe_log(\"Resolved task pointer: task=%p\", (void *)task);\n\n        return_code = OS_TaskMatch_Impl(&token);\n        probe_log(\"After OS_TaskMatch_Impl: return_code=%d, token_addr=%p\", (int)return_code, (void *)&token);\n\n        /* Log the task's entry_function_pointer if task appears non-NULL. */\n        if (task != NULL)\n        {\n            probe_log(\"Task entry_function_pointer (about to assign): %p\", (void *)task->entry_function_pointer);\n        }\n        else\n        {\n            probe_log(\"Warning: task is NULL after resolving from OS_task_table\");\n        }\n\n        *entrypt    = task->entry_function_pointer;\n        probe_log(\"Assigned *entrypt = %p (entrypt pointer=%p)\", (void *)task->entry_function_pointer, (void *)entrypt);\n\n        OS_ObjectIdRelease(&token);\n        probe_log(\"Called OS_ObjectIdRelease on token at %p\", (void *)&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_TaskRegister_Impl(task_id);\n        probe_log(\"After OS_TaskRegister_Impl: return_code=%d\", (int)return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Give event callback to the application */\n        probe_log(\"About to call OS_NotifyEvent: event=OS_EVENT_TASK_STARTUP, task_id=%u\", (unsigned)task_id);\n        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, NULL);\n        probe_log(\"After OS_NotifyEvent: return_code=%d\", (int)return_code);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        probe_log(\"Failure path: return_code=%d, setting *entrypt = NULL (entrypt=%p)\", (int)return_code, (void *)entrypt);\n        *entrypt = NULL;\n    }\n    else\n    {\n        probe_log(\"Success path: return_code=%d, final entrypt=%p, *entrypt=%p\", (int)return_code, (void *)entrypt, (void *)(entrypt ? *entrypt : NULL));\n    }\n\n    probe_log(\"OS_TaskPrepare EXIT: return_code=%d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 21.17 concerns use of string.h functions (e.g. memset) that must not access beyond the bounds of the objects referenced by their pointer parameters. The OS_TaskPrepare implementation shown does not call any string.h functions itself and does not pass a NULL token pointer to the call shown: it declares a local token (OS_object_token_t token;) and calls OS_ObjectIdGetById(..., &token). That guarantees the pointer passed in this call references a valid stack object, so any internal memset(token, 0, sizeof(*token)) inside OS_ObjectIdGetById/OS_ObjectIdTransactionInit would not dereference NULL or access out-of-bounds for this particular caller.\n\nAgent A\u2019s scenario describes a potential defect inside OS_ObjectIdTransactionInit if callers sometimes pass NULL or invalid pointers to it. If that function uses memset on its token parameter without validating the pointer and the function\u2019s contract allows NULL, then that function could violate Rule 21.17. However, that is a defect in OS_ObjectIdTransactionInit (or in callers that pass NULL contrary to its contract), not in OS_TaskPrepare. The provided test stub also didn\u2019t demonstrate a real NULL-pointer call and failed to compile, so no evidence was shown that OS_TaskPrepare ever passes NULL.\n\nVerdict: the claim that OS_TaskPrepare violates MISRA C 2023 Rule 21.17 is incorrect. If needed, review the implementation and contract of OS_ObjectIdGetById/OS_ObjectIdTransactionInit to ensure they either document \u2018\u2018non-NULL required\u2019\u2019 or explicitly check for NULL before calling string.h functions."
}