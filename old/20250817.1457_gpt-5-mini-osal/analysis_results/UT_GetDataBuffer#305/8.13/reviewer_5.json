{
  "user_message": "An agent A claimed that the following UT_GetDataBuffer code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetDataBuffer.\n```c\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If StubPtr->Data.Buff.BasePtr has type void * (i.e. it is a non-const pointer to the buffer) then Rule 8.13 is violated. In the shown fragment the value is assigned into a non-const void * (ResultDataBuffer) and returned via a void ** out-parameter, so any const-qualification on the referenced object is not preserved. According to MISRA C 2023 R8.13 the pointer should be const-qualified whenever possible (for example change BasePtr to const void * and the API to use const void ** / const void * as appropriate), otherwise the rule is broken.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogDataBufferState(const char *stage,\n                                  void *stub_ptr,\n                                  void *result_data_buffer,\n                                  size_t result_max_size,\n                                  size_t result_position,\n                                  void **out_DataBuffer,\n                                  size_t *out_MaxSize,\n                                  size_t *out_Position)\n{\n    FILE *fp = fopen(\"/tmp/logs/2443.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* best-effort logging, do not disturb function behavior */\n    }\n\n    fprintf(fp, \"---- UT_GetDataBuffer: %s ----\\n\", (stage != NULL) ? stage : \"(null)\");\n    fprintf(fp, \"StubPtr (addr): %p\\n\", stub_ptr);\n    fprintf(fp, \"ResultDataBuffer (addr): %p\\n\", result_data_buffer);\n    fprintf(fp, \"ResultMaxSize: %zu\\n\", result_max_size);\n    fprintf(fp, \"ResultPosition: %zu\\n\", result_position);\n    fprintf(fp, \"Out param DataBuffer (addr): %p\\n\", (void *)out_DataBuffer);\n    fprintf(fp, \"Out param MaxSize (addr): %p\\n\", (void *)out_MaxSize);\n    fprintf(fp, \"Out param Position (addr): %p\\n\", (void *)out_Position);\n\n    /* If the out DataBuffer pointer is provided, log what will be written. */\n    if (out_DataBuffer != NULL)\n    {\n        fprintf(fp, \"Will write *DataBuffer = %p\\n\", result_data_buffer);\n    }\n    else\n    {\n        fprintf(fp, \"DataBuffer out-parameter is NULL; no write\\n\");\n    }\n\n    if (out_MaxSize != NULL)\n    {\n        fprintf(fp, \"Will write *MaxSize = %zu\\n\", result_max_size);\n    }\n    else\n    {\n        fprintf(fp, \"MaxSize out-parameter is NULL; no write\\n\");\n    }\n\n    if (out_Position != NULL)\n    {\n        fprintf(fp, \"Will write *Position = %zu\\n\", result_position);\n    }\n    else\n    {\n        fprintf(fp, \"Position out-parameter is NULL; no write\\n\");\n    }\n\n    fprintf(fp, \"---- end ----\\n\\n\");\n    fclose(fp);\n}\n\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    /* Log entry into function (FuncKey not printed to avoid type assumptions) */\n    UT_LogDataBufferState(\"entering UT_GetDataBuffer (before UT_GetStubEntry)\",\n                          NULL, NULL, 0u, 0u, DataBuffer, MaxSize, Position);\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    UT_LogDataBufferState(\"after UT_GetStubEntry\",\n                          (void *)StubPtr, NULL, 0u, 0u, DataBuffer, MaxSize, Position);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0u;\n        ResultPosition   = 0u;\n\n        UT_LogDataBufferState(\"stub NULL: prepared default results\",\n                              (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                              DataBuffer, MaxSize, Position);\n    }\n    else\n    {\n        /* Preserve original assignments */\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n\n        /* Log the values obtained from the stub entry. This captures the pointer\n         * value that demonstrates whether a non-const void * is being returned. */\n        UT_LogDataBufferState(\"stub valid: obtained results from StubPtr\",\n                              (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                              DataBuffer, MaxSize, Position);\n    }\n\n    /* Before performing writes to out-parameters, log intent */\n    UT_LogDataBufferState(\"before writing out-parameters\",\n                          (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                          DataBuffer, MaxSize, Position);\n\n    if (DataBuffer != NULL)\n    {\n        /* Log the specific assignment and then perform it (preserve behavior) */\n        UT_LogDataBufferState(\"assigning *DataBuffer\",\n                              (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                              DataBuffer, MaxSize, Position);\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        UT_LogDataBufferState(\"assigning *MaxSize\",\n                              (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                              DataBuffer, MaxSize, Position);\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        UT_LogDataBufferState(\"assigning *Position\",\n                              (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                              DataBuffer, MaxSize, Position);\n        *Position = ResultPosition;\n    }\n\n    /* Final state after all writes */\n    UT_LogDataBufferState(\"exiting UT_GetDataBuffer (final state)\",\n                          (void *)StubPtr, ResultDataBuffer, ResultMaxSize, ResultPosition,\n                          DataBuffer, MaxSize, Position);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n---- UT_GetDataBuffer: entering UT_GetDataBuffer (before UT_GetStubEntry) ----\nStubPtr (addr): (nil)\nResultDataBuffer (addr): (nil)\nResultMaxSize: 0\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = (nil)\nWill write *MaxSize = 0\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: after UT_GetStubEntry ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): (nil)\nResultMaxSize: 0\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = (nil)\nWill write *MaxSize = 0\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: stub valid: obtained results from StubPtr ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: before writing out-parameters ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: assigning *DataBuffer ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: assigning *MaxSize ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: exiting UT_GetDataBuffer (final state) ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: entering UT_GetDataBuffer (before UT_GetStubEntry) ----\nStubPtr (addr): (nil)\nResultDataBuffer (addr): (nil)\nResultMaxSize: 0\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = (nil)\nWill write *MaxSize = 0\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: after UT_GetStubEntry ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): (nil)\nResultMaxSize: 0\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = (nil)\nWill write *MaxSize = 0\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: stub valid: obtained results from StubPtr ----\nStubPtr (addr): 0x55fa354ebee0\nResultDataBuffer (addr): 0x55fa354d1ae0\nResultMaxSize: 32768\nResultPosition: 0\nOut param DataBuffer (addr): 0x7ffedc14eea0\nOut param MaxSize (addr): 0x7ffedc14eea8\nOut param Position (addr): (nil)\nWill write *DataBuffer = 0x55fa354d1ae0\nWill write *MaxSize = 32768\nPosition out-parameter is NULL; no write\n---- end ----\n\n---- UT_GetDataBuffer: before writing out-parameters ----\nStubPtr (addr): 0x55\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA R8.13 recommends that pointers should point to const-qualified types when the pointed-to object need not be modified, but it does not automatically require every pointer to be const. A violation would occur if the code discards an existing const qualification (for example assigning a const void * to a void * or a const void ** to a void **). In the shown fragment there is no evidence of discarding const \u2014 StubPtr->Data.Buff.BasePtr is used as a void * and propagated as a void * (no conversion from const to non-const is performed). Returning a non-const void * via a void ** is appropriate if the API is intended to provide a mutable buffer to callers. Therefore, based on the provided code and logs, there is no MISRA R8.13 violation as claimed by agent A."
}