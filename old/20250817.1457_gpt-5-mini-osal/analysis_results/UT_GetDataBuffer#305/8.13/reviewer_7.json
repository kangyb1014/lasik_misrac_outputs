{
  "user_message": "An agent A claimed that the following UT_GetDataBuffer code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetDataBuffer.\n```c\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer StubPtr is only used to read fields (StubPtr->Data.Buff.BasePtr, TotalSize, Position) and is never used to modify the pointed-to object. Therefore it could and should be declared as a pointer to const: const UT_StubTableEntry_t *StubPtr; Declaring it non-const when a const-qualified type is possible violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogAppend(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2443.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid UT_GetDataBuffer(UT_EntryKey_t FuncKey, void **DataBuffer, size_t *MaxSize, size_t *Position)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ResultDataBuffer;\n    size_t               ResultMaxSize;\n    size_t               ResultPosition;\n\n    /* Log function entry and key value (print as uintptr_t for portability) */\n    UT_LogAppend(\"UT_GetDataBuffer: entry - FuncKey=%\" PRIuPTR, (uintptr_t)FuncKey);\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        UT_LogAppend(\"UT_GetDataBuffer: no stub entry found (StubPtr=NULL)\");\n\n        ResultDataBuffer = NULL;\n        ResultMaxSize    = 0;\n        ResultPosition   = 0;\n    }\n    else\n    {\n        /* Log the stub pointer address and the fields that are read. */\n        UT_LogAppend(\"UT_GetDataBuffer: StubPtr=%p\", (void *)StubPtr);\n\n        /* Log the fields that are read from the stub entry. */\n        UT_LogAppend(\"UT_GetDataBuffer: StubPtr->Data.Buff.BasePtr=%p\", (void *)StubPtr->Data.Buff.BasePtr);\n        UT_LogAppend(\"UT_GetDataBuffer: StubPtr->Data.Buff.TotalSize=%zu\", (size_t)StubPtr->Data.Buff.TotalSize);\n        UT_LogAppend(\"UT_GetDataBuffer: StubPtr->Data.Buff.Position=%zu\", (size_t)StubPtr->Data.Buff.Position);\n\n        ResultDataBuffer = StubPtr->Data.Buff.BasePtr;\n        ResultMaxSize    = StubPtr->Data.Buff.TotalSize;\n        ResultPosition   = StubPtr->Data.Buff.Position;\n    }\n\n    /* Log what will be written back to the caller pointers (if they exist). */\n    UT_LogAppend(\"UT_GetDataBuffer: OutParams - DataBuffer=%p, MaxSize=%p, Position=%p\",\n                 (void *)DataBuffer, (void *)MaxSize, (void *)Position);\n\n    if (DataBuffer != NULL)\n    {\n        *DataBuffer = ResultDataBuffer;\n        UT_LogAppend(\"UT_GetDataBuffer: wrote *DataBuffer=%p\", ResultDataBuffer);\n    }\n    if (MaxSize != NULL)\n    {\n        *MaxSize = ResultMaxSize;\n        UT_LogAppend(\"UT_GetDataBuffer: wrote *MaxSize=%zu\", ResultMaxSize);\n    }\n    if (Position != NULL)\n    {\n        *Position = ResultPosition;\n        UT_LogAppend(\"UT_GetDataBuffer: wrote *Position=%zu\", ResultPosition);\n    }\n\n    UT_LogAppend(\"UT_GetDataBuffer: exit\");\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_GetDataBuffer: entry - FuncKey=94708299287893\nUT_GetDataBuffer: StubPtr=0x5622fe8b92c0\nUT_GetDataBuffer: StubPtr->Data.Buff.BasePtr=0x5622fe8a9ae0\nUT_GetDataBuffer: StubPtr->Data.Buff.TotalSize=32768\nUT_GetDataBuffer: StubPtr->Data.Buff.Position=0\nUT_GetDataBuffer: OutParams - DataBuffer=0x7ffc824c47c0, MaxSize=0x7ffc824c47c8, Position=(nil)\nUT_GetDataBuffer: wrote *DataBuffer=0x5622fe8a9ae0\nUT_GetDataBuffer: wrote *MaxSize=32768\nUT_GetDataBuffer: exit\nUT_GetDataBuffer: entry - FuncKey=94708299287893\nUT_GetDataBuffer: StubPtr=0x5622fe8b92c0\nUT_GetDataBuffer: StubPtr->Data.Buff.BasePtr=0x5622fe8a9ae0\nUT_GetDataBuffer: StubPtr->Data.Buff.TotalSize=32768\nUT_GetDataBuffer: StubPtr->Data.Buff.Position=0\nUT_GetDataBuffer: OutParams - DataBuffer=0x7ffc824c47c0, MaxSize=0x7ffc824c47c8, Position=(nil)\nUT_GetDataBuffer: wrote *DataBuffer=0x5622fe8a9ae0\nUT_GetDataBuffer: wrote *MaxSize=32768\nUT_GetDataBuffer: exit\nUT_GetDataBuffer: entry - FuncKey=94708299288753\nUT_GetDataBuffer: StubPtr=0x5622fe8bdac0\nUT_GetDataBuffer: StubPtr->Data.Buff.BasePtr=0x5622fe8a9ae0\nUT_GetDataBuffer: StubPtr->Data.Buff.TotalSize=32768\nUT_GetDataBuffer: StubPtr->Data.Buff.Position=0\nUT_GetDataBuffer: OutParams - DataBuffer=0x7ffc824c47d8, MaxSize=0x7ffc824c47e0, Position=(nil)\nUT_GetDataBuffer: wrote *DataBuffer=0x5622fe8a9ae0\nUT_GetDataBuffer: wrote *MaxSize=32768\nUT_GetDataBuffer: exit\nUT_GetDataBuffer: entry - FuncKey=94708299287893\nUT_GetDataBuffer: StubPtr=0x5622fe8b92c0\nUT_GetDataBuffer: StubPtr->Data.Buff.BasePtr=0x5622fe8a9ae0\nUT_GetDataBuffer: StubPtr->Data.Buff.TotalSize=32768\nUT_GetDataBuffer: StubPtr->Data.Buff.Position=0\nUT_GetDataBuffer: OutParams - DataBuffer=0x7ffc824c47c0, MaxSize=0x7ffc824c47c8, Position=(nil)\nUT_GetDataBuffer: wrote *DataBuffer=0x5622fe8a9ae0\nUT_GetDataBuffer: wrote *MaxSize=32768\nUT_GetDataBuffer: exit\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the function StubPtr is only used to read fields (StubPtr->Data.Buff.BasePtr, TotalSize, Position) and there are no writes through StubPtr. Under MISRA C:2023 Rule 8.13 a pointer shall point to a const-qualified type whenever possible, so StubPtr should be declared as const UT_StubTableEntry_t *StubPtr; (assigning the non-const result of UT_GetStubEntry to a const pointer is permitted). Therefore the current non-const declaration violates Rule 8.13."
}