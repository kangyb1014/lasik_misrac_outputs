{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The code only checks for NULL pointers before calling strcmp but does not guarantee the pointed-to character arrays are NUL-terminated or within their allocated bounds. For example, if RvcPtr->TypeName points to a 3-byte buffer filled with {'a','b','c'} (no terminating '\\0') or to a substring inside a larger allocation where the terminator lies beyond the intended object, strcmp(RvcPtr->TypeName, WantTypeName) can read past the end of the object and access out-of-bounds memory. This would violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_DefaultStubImplWithArgs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2415.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_DefaultStubImplWithArgs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_DefaultStubImplWithArgs:\n```c\nint32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n```\n</target_code>\nPlease provide the modified UT_DefaultStubImplWithArgs code.\n",
  "test_code": "int32 UT_DefaultStubImplWithArgs(const char *FunctionName, UT_EntryKey_t FuncKey, int32 DefaultRc, va_list ArgList)\n{\n    const char *         RetcodeString;\n    UT_StubTableEntry_t *StubPtr;\n    UT_StubTableEntry_t *ContextTblPtr;\n    UT_StubTableEntry_t *RvcPtr;\n    UT_StubContext_t     LocalContext;\n    uint32               Counter;\n    va_list              ArgListCopy;\n    bool                 GotInt32StatusFromHook;\n\n    /*\n     * Probe: helper for logging key state to /tmp/logs/2415.txt\n     * This helper intentionally only prints pointer values and numeric sizes/flags\n     * to avoid dereferencing potentially invalid pointers.\n     */\n    {\n        FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n        if (probe_f != NULL)\n        {\n            fprintf(probe_f, \"\\n---- UT_DefaultStubImplWithArgs ENTRY: FunctionName=%p FuncKey=%p DefaultRc=%d\\n\",\n                    (const void *)FunctionName, (const void *)((uintptr_t)FuncKey), (int)DefaultRc);\n            fclose(probe_f);\n        }\n    }\n\n    /*\n     * In this implementation a context is _always_ needed.\n     *\n     * First see if the stub has an already-registered context.  Any non-trivial stub\n     * should already have registered some arguments and/or a return code buffer.\n     *\n     * To handle an old-style/incomplete stub function or simple void/void stubs that\n     * do not have any arguments, a blank entry can be created on the fly.\n     */\n    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (ContextTblPtr != NULL)\n    {\n        LocalContext = ContextTblPtr->Data.Context;\n\n        /* Always clear the context entry -- the next call will have a different one */\n        UT_ClearStubEntry(ContextTblPtr);\n    }\n    else\n    {\n        memset(&LocalContext, 0, sizeof(LocalContext));\n    }\n\n    /* Probe: log context state */\n    {\n        FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n        if (probe_f != NULL)\n        {\n            fprintf(probe_f, \"ContextTblPtr=%p LocalContext.Int32StatusIsSet=%d LocalContext.Int32StatusCode=%ld\\n\",\n                    (void *)ContextTblPtr, (int)LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n            fclose(probe_f);\n        }\n    }\n\n    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);\n\n    /* Probe: log RvcPtr discovery */\n    {\n        FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n        if (probe_f != NULL)\n        {\n            if (RvcPtr == NULL)\n            {\n                fprintf(probe_f, \"RvcPtr=NULL\\n\");\n            }\n            else\n            {\n                /* Print fields that are used later in this function: EntryType, Genre, Buf pointer, ActualSz if present */\n                fprintf(probe_f,\n                        \"RvcPtr=%p EntryType=%d Genre=%d Data.Rvc.Buf=%p Data.Rvc.Buf.IndirectPtr=%p Data.Rvc.ActualSz=%lu\\n\",\n                        (void *)RvcPtr, (int)RvcPtr->EntryType, (int)RvcPtr->Data.Rvc.Genre,\n                        (void *)&RvcPtr->Data.Rvc.Buf, (void *)RvcPtr->Data.Rvc.Buf.IndirectPtr,\n                        (unsigned long)RvcPtr->Data.Rvc.ActualSz);\n            }\n            fclose(probe_f);\n        }\n    }\n\n    /* For legacy compatibility, determine the int32 status code (this may or may not be relevent) */\n    if (RvcPtr != NULL && UT_Stub_IsValueCompatible(&RvcPtr->Data.Rvc, \"int32\", UT_ValueGenre_INTEGER))\n    {\n        /* Probe: about to call UT_LoadRetval with buffer pointer & size info */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f,\n                        \"About to UT_LoadRetval for int32: dest=&LocalContext.Int32StatusCode (%p), dest_sz=%lu, src_buf=%p, src_genre=%d\\n\",\n                        (void *)&LocalContext.Int32StatusCode, (unsigned long)sizeof(LocalContext.Int32StatusCode),\n                        (void *)&RvcPtr->Data.Rvc.Buf, (int)RvcPtr->Data.Rvc.Genre);\n                fclose(probe_f);\n            }\n        }\n\n        LocalContext.Int32StatusIsSet =\n            UT_LoadRetval(&LocalContext.Int32StatusCode, sizeof(LocalContext.Int32StatusCode), &RvcPtr->Data.Rvc.Buf,\n                          UT_ValueGenre_INTEGER);\n\n        /* Probe: log result of UT_LoadRetval */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"UT_LoadRetval returned %d LocalContext.Int32StatusCode=%ld\\n\",\n                        (int)LocalContext.Int32StatusIsSet, (long)LocalContext.Int32StatusCode);\n                fclose(probe_f);\n            }\n        }\n    }\n\n    if (!LocalContext.Int32StatusIsSet)\n    {\n        LocalContext.Int32StatusCode = DefaultRc;\n    }\n\n    if (FunctionName != NULL)\n    {\n        if (!LocalContext.Int32StatusIsSet)\n        {\n            RetcodeString = \"DEFAULT\";\n        }\n        else\n        {\n            /* Indicate that this invocation got a non-default return code */\n            RetcodeString = \"*SPECIAL*\";\n        }\n\n        UtDebug(\"%s called (%s,%ld)\", FunctionName, RetcodeString, (long)LocalContext.Int32StatusCode);\n\n        /* Probe: log that function debug was invoked but only log pointers/sizes to avoid extra reads */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"UtDebug invoked: FunctionName=%p RetcodeString=%p LocalContext.Int32StatusCode=%ld\\n\",\n                        (const void *)FunctionName, (const void *)RetcodeString, (long)LocalContext.Int32StatusCode);\n                fclose(probe_f);\n            }\n        }\n    }\n\n    Counter = 0;\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr == NULL)\n    {\n        /* Creating counter entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set counter - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->EntryType = UT_ENTRYTYPE_COUNTER;\n        StubPtr->FuncKey   = FuncKey;\n        Counter            = StubPtr->Data.Rc.Count;\n        ++StubPtr->Data.Rc.Count;\n        StubPtr->Data.Rc.Value = LocalContext.Int32StatusCode;\n\n        /* Probe: log counter info */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"Counter stub updated StubPtr=%p Count=%lu Value=%ld\\n\",\n                        (void *)StubPtr, (unsigned long)StubPtr->Data.Rc.Count, (long)StubPtr->Data.Rc.Value);\n                fclose(probe_f);\n            }\n        }\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            va_copy(ArgListCopy, ArgList);\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.VaHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext, ArgListCopy);\n            va_end(ArgListCopy);\n        }\n        else\n        {\n            LocalContext.Int32StatusCode = StubPtr->Data.Cb.Ptr.SimpleHook(\n                StubPtr->Data.Cb.CallbackArg, LocalContext.Int32StatusCode, Counter, &LocalContext);\n        }\n\n        GotInt32StatusFromHook        = true;\n        LocalContext.Int32StatusIsSet = true;\n\n        /* Probe: log that hook was called and new status */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"Hook invoked StubPtr=%p IsVarg=%d NewStatus=%ld\\n\",\n                        (void *)StubPtr, (int)StubPtr->Data.Cb.IsVarg, (long)LocalContext.Int32StatusCode);\n                fclose(probe_f);\n            }\n        }\n    }\n    else\n    {\n        GotInt32StatusFromHook = false;\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);\n    if (StubPtr != NULL)\n    {\n        if (StubPtr->Data.Cb.IsVarg)\n        {\n            StubPtr->Data.Cb.Ptr.VaHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext, ArgList);\n        }\n        else\n        {\n            StubPtr->Data.Cb.Ptr.SimpleHandler(StubPtr->Data.Cb.CallbackArg, FuncKey, &LocalContext);\n        }\n\n        /* Probe: log final handler invocation */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"Final handler invoked StubPtr=%p IsVarg=%d\\n\",\n                        (void *)StubPtr, (int)StubPtr->Data.Cb.IsVarg);\n                fclose(probe_f);\n            }\n        }\n    }\n\n    /*\n     * Handle propagation of return code.\n     *\n     *   \"old style\" stubs will translate the int32 return value from this function.\n     *     - Return Buffer will always be unset with these stubs\n     *     - This should continue to work with no special handling.\n     *\n     *   \"new style\" stubs will provide a return value buffer via UT_ENTRYTYPE_RETURN_BUFFER in the context.\n     *     - In this pattern the int32 return value of this function is _IGNORED_ by the calling stub.\n     *     - The only way to return a value to the caller is via the buffer.\n     *     - If the handler did _not_ populate the return value, then attempt to translate the local\n     *       Retcode here to the return value buffer.  This eases the transition, as the vast majority\n     *       of functions do return an int32, this can be the automatic case.\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL && StubPtr->Data.Buff.Position == 0)\n    {\n        /* If a hook function was used, it is expected that this will override any configured retval */\n        if (GotInt32StatusFromHook && StubPtr->Data.Buff.TotalSize == sizeof(LocalContext.Int32StatusCode))\n        {\n            /* Probe: about to memcpy Int32StatusCode into return buffer */\n            {\n                FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n                if (probe_f != NULL)\n                {\n                    fprintf(probe_f,\n                            \"About to memcpy int32 to return buffer: dest=%p TotalSize=%lu src_int=%ld\\n\",\n                            (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize,\n                            (long)LocalContext.Int32StatusCode);\n                    fclose(probe_f);\n                }\n            }\n\n            memcpy(StubPtr->Data.Buff.BasePtr, &LocalContext.Int32StatusCode, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n        else if (RvcPtr != NULL)\n        {\n            /*\n             * Opaque values allow for arbitrarily large return values, but size must match exactly\n             * to what is expected, it cannot be truncated or expanded if there is a mismatch\n             * between the test and the stub.  Conversely, numeric values can be size-adjusted\n             * if the test supplied one size but the stub needs a different size, such as 32-bit\n             * to 16-bit or 64-bit ints.  Note that historically UT assert only supported 32-bit\n             * integer return values to be directly configured, so older test cases are likely to\n             * set a 32-bit value even if the return value is a different size.\n             */\n            if (RvcPtr->Data.Rvc.Genre == UT_ValueGenre_OPAQUE)\n            {\n                /* Probe: log opaque copy attempt */\n                {\n                    FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n                    if (probe_f != NULL)\n                    {\n                        fprintf(probe_f,\n                                \"Opaque retval path: StubBufTotalSize=%lu StubRvcActualSz=%lu StubBuf.BasePtr=%p Rvc.Buf.IndirectPtr=%p ContentType=%s\\n\",\n                                (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                (unsigned long)StubPtr->Data.Rvc.ActualSz,\n                                (void *)StubPtr->Data.Buff.BasePtr,\n                                (void *)StubPtr->Data.Rvc.Buf.IndirectPtr,\n                                StubPtr->Data.Buff.ContentTypeStr ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\");\n                        fclose(probe_f);\n                    }\n                }\n\n                if (StubPtr->Data.Rvc.ActualSz != StubPtr->Data.Buff.TotalSize)\n                {\n                    UtAssert_Failed(\"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\", FunctionName,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                    (unsigned long)StubPtr->Data.Rvc.ActualSz, StubPtr->Data.Buff.ContentTypeStr);\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Rvc.Buf.IndirectPtr, StubPtr->Data.Buff.TotalSize);\n                    StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                    /* Probe: log that opaque memcpy completed */\n                    {\n                        FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n                        if (probe_f != NULL)\n                        {\n                            fprintf(probe_f, \"Opaque memcpy done dest=%p src=%p size=%lu\\n\",\n                                    (void *)StubPtr->Data.Buff.BasePtr,\n                                    (void *)StubPtr->Data.Rvc.Buf.IndirectPtr,\n                                    (unsigned long)StubPtr->Data.Buff.TotalSize);\n                            fclose(probe_f);\n                        }\n                    }\n                }\n            }\n            else if (UT_LoadRetval(StubPtr->Data.Buff.BasePtr, StubPtr->Data.Buff.TotalSize, &RvcPtr->Data.Rvc.Buf,\n                                   RvcPtr->Data.Rvc.Genre))\n            {\n                StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n\n                /* Probe: log UT_LoadRetval success for non-opaque */\n                {\n                    FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n                    if (probe_f != NULL)\n                    {\n                        fprintf(probe_f, \"UT_LoadRetval to return buffer succeeded dest=%p size=%lu src_buf=%p genre=%d\\n\",\n                                (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize,\n                                (void *)&RvcPtr->Data.Rvc.Buf, (int)RvcPtr->Data.Rvc.Genre);\n                        fclose(probe_f);\n                    }\n                }\n            }\n        }\n\n        if (StubPtr->Data.Buff.Position == 0)\n        {\n            /*\n             * This means that no suitable return value was configured for this call.\n             * The final fallback in this case is to zero-fill it.\n             *\n             * For logical values this should become \"false\", for pointers it is \"NULL\", and for any numeric\n             * value - signed, unsigned, or float - it should become 0.\n             */\n            /* Probe: about to memset zero fill return buffer */\n            {\n                FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n                if (probe_f != NULL)\n                {\n                    fprintf(probe_f, \"Zero-filling return buffer dest=%p size=%lu\\n\",\n                            (void *)StubPtr->Data.Buff.BasePtr, (unsigned long)StubPtr->Data.Buff.TotalSize);\n                    fclose(probe_f);\n                }\n            }\n\n            memset(StubPtr->Data.Buff.BasePtr, 0, StubPtr->Data.Buff.TotalSize);\n            StubPtr->Data.Buff.Position = StubPtr->Data.Buff.TotalSize;\n        }\n    }\n\n    /*\n     * Deferred retval configs should be expunged after they are used, so the next call will\n     * get the next config (if applicable).  Constant return values are NOT cleared, they may\n     * be re-used if the same stub is invoked again.\n     */\n    if (RvcPtr != NULL && RvcPtr->EntryType == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED)\n    {\n        /* Probe: clearing deferred RVC entry */\n        {\n            FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n            if (probe_f != NULL)\n            {\n                fprintf(probe_f, \"Clearing deferred RvcPtr=%p EntryType=%d\\n\", (void *)RvcPtr, (int)RvcPtr->EntryType);\n                fclose(probe_f);\n            }\n        }\n        UT_ClearStubEntry(RvcPtr);\n    }\n\n    /* Final probe: log return value */\n    {\n        FILE *probe_f = fopen(\"/tmp/logs/2415.txt\", \"a\");\n        if (probe_f != NULL)\n        {\n            fprintf(probe_f, \"EXIT: Returning LocalContext.Int32StatusCode=%ld GotInt32FromHook=%d Counter=%lu\\n\",\n                    (long)LocalContext.Int32StatusCode, (int)GotInt32StatusFromHook, (unsigned long)Counter);\n            fclose(probe_f);\n        }\n    }\n\n    return LocalContext.Int32StatusCode;\n}\n"
}