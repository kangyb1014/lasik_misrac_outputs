{
  "user_message": "An agent A claimed that the following OS_FileSysStartVolume_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStartVolume_Impl.\n```c\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    break;\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The bare declaration 'char *address;' is a potential violation of MISRA C 2023 Rule 8.13 if the pointed-to object is not intended to be modified. For example, if address is used to point at read\u2011only data such as a string literal, a device path, or a memory\u2011mapped ROM/constant image, it should be declared 'const char *address;' and the current 'char *' would violate Rule 8.13. If, however, code elsewhere legitimately writes through this pointer, then the non-const declaration is appropriate and there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f;\n\n    /* Try to create /tmp/logs - ignore errors (may already exist) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/315.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    probe_log(\"ENTER OS_FileSysStartVolume_Impl token=%p local=%p\", (const void *)token, (const void *)local);\n    if (local != NULL)\n    {\n        probe_log(\"initial fstype=%d device_name='%s' volume_name='%s' system_mountpt='%s'\",\n                  (int)local->fstype,\n                  local->device_name ? local->device_name : \"(null)\",\n                  local->volume_name ? local->volume_name : \"(null)\",\n                  local->system_mountpt ? local->system_mountpt : \"(null)\");\n    }\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        probe_log(\"device_name '%s' matches POSIX prefix '%s' - setting fstype UNKNOWN->NORMAL_DISK\",\n                  local->device_name, OS_POSIX_DEVICEFILE_PREFIX);\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        probe_log(\"fstype is VOLATILE_DISK - searching for suitable tmpdir\");\n\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            probe_log(\"iteration %u selected candidate tmpdir='%s'\", i, tmpdir ? tmpdir : \"(null)\");\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                probe_log(\"stat('%s') succeeded mode=0%o uid=%u gid=%u\",\n                          tmpdir, (unsigned int)stat_buf.st_mode, (unsigned int)stat_buf.st_uid, (unsigned int)stat_buf.st_gid);\n\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    probe_log(\"write permission check passed for '%s' (mode=0%o)\", tmpdir, (unsigned int)stat_buf.st_mode);\n                    break;\n                }\n                else\n                {\n                    probe_log(\"no suitable write permission on '%s' (mode=0%o)\", tmpdir, (unsigned int)stat_buf.st_mode);\n                }\n            }\n            else\n            {\n                if (tmpdir != NULL)\n                {\n                    probe_log(\"stat('%s') failed: errno=%d (%s)\", tmpdir, errno, strerror(errno));\n                }\n                else\n                {\n                    probe_log(\"candidate tmpdir is NULL - skipping\");\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            probe_log(\"No storage location for volatile volumes - tmpdir is NULL\");\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        probe_log(\"chosen tmpdir='%s'\", tmpdir);\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        probe_log(\"after snprintf mplen=%zu system_mountpt='%s' (truncated if >= %zu)\", mplen,\n                  local->system_mountpt, sizeof(local->system_mountpt));\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            probe_log(\"volume_name length vollen=%zu (buffer size %zu)\", vollen, sizeof(local->volume_name));\n\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                probe_log(\"volume name would overflow system_mountpt; truncating to fit\");\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n\n            probe_log(\"final system_mountpt='%s' (length=%zu)\", local->system_mountpt, OS_strnlen(local->system_mountpt, sizeof(local->system_mountpt)));\n        }\n    }\n\n    probe_log(\"EXIT OS_FileSysStartVolume_Impl returning OS_SUCCESS\");\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysStartVolume_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is not correct for the code shown. In this function the only pointer declarations are:\n- const OS_object_token_t *token (parameter) \u2014 already const-qualified.\n- OS_filesys_internal_record_t *local \u2014 non-const pointer to a record that the function modifies (it updates local->fstype and local->system_mountpt), so it must not be const.\n- const char *tmpdir \u2014 correctly const-qualified; note assigning the result of getenv (char *) to const char * is allowed and appropriate since the function does not modify the pointed-to string.\n\nThere are no bare char * local pointer declarations in this function that should be const. Thus, with respect to the provided function, Rule 8.13 is respected. (If the struct member types such as device_name in the definition of OS_filesys_internal_record_t were non-const but never modified anywhere, that could be a separate issue originating in the struct declaration, but that is outside the scope of this function and was not shown.)"
}