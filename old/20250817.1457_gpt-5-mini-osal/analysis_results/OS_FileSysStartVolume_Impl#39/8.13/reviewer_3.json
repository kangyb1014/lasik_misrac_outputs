{
  "user_message": "An agent A claimed that the following OS_FileSysStartVolume_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysStartVolume_Impl.\n```c\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    break;\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n        }\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro takes the address of its second parameter without preserving const. In OS_FileSysStartVolume_Impl the call OS_OBJECT_TABLE_GET(OS_filesys_table, *token) passes *token where token is declared const OS_object_token_t *; the macro expands to &(*token) (i.e. a const OS_object_token_t *), but the macro (and likely the called function OS_ObjectIndexFromToken) does not use a const-qualified pointer parameter, causing a const qualification to be discarded. This fails the requirement that pointers should point to const-qualified types whenever possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FileSysStartVolume_Impl_log(const char *tag, const void *token_ptr, const void *local_ptr, const void *extra_ptr, size_t extra_size)\n{\n    FILE *f = fopen(\"/tmp/logs/315.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"---- %s ----\\n\", tag);\n    fprintf(f, \"token ptr = %p\\n\", token_ptr);\n    if (token_ptr != NULL && extra_ptr != NULL && extra_size > 0)\n    {\n        const unsigned char *bytes = (const unsigned char *)extra_ptr;\n        size_t i;\n        fprintf(f, \"token raw (first %zu bytes):\", extra_size);\n        for (i = 0; i < extra_size; ++i)\n        {\n            fprintf(f, \" %02X\", (unsigned)bytes[i]);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fprintf(f, \"local ptr = %p\\n\", local_ptr);\n    fflush(f);\n    fclose(f);\n}\n\nint32 OS_FileSysStartVolume_Impl(const OS_object_token_t *token)\n{\n    OS_filesys_internal_record_t *local;\n    struct stat                   stat_buf;\n    const char *                  tmpdir;\n    size_t                        mplen;\n    size_t                        vollen;\n    uint32                        i;\n    enum\n    {\n        VOLATILE_DISK_LOC_DEV_SHM,\n        VOLATILE_DISK_LOC_ENV,\n        VOLATILE_DISK_LOC_VARTMP,\n        VOLATILE_DISK_LOC_TMP,\n        VOLATILE_DISK_LOC_MAX\n    };\n\n    /* Log entry and token raw bytes (copy limited to a reasonable size) */\n    {\n        size_t token_bytes = 0;\n        if (token != NULL)\n        {\n            /* Capture up to 32 bytes of the token for diagnostics without modifying it */\n            token_bytes = (sizeof(*token) < 32u) ? sizeof(*token) : 32u;\n            unsigned char buf[32];\n            memcpy(buf, token, token_bytes);\n            OS_FileSysStartVolume_Impl_log(\"entering OS_FileSysStartVolume_Impl\", (const void *)token, NULL, buf, token_bytes);\n        }\n        else\n        {\n            OS_FileSysStartVolume_Impl_log(\"entering OS_FileSysStartVolume_Impl (null token)\", NULL, NULL, NULL, 0);\n        }\n    }\n\n    /* Preserve original call - this is the expression reported as the source of const discard */\n    local = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    /* Log result of table lookup and some local fields if available */\n    if (local != NULL)\n    {\n        /* Compose a small string with some fields to avoid dereferencing unknown parts later */\n        char local_info[256];\n        int n = snprintf(local_info, sizeof(local_info), \"fstype=%d device_name=\\\"%s\\\" volume_name=\\\"%s\\\"\",\n                         (int)local->fstype,\n                         (local->device_name != NULL) ? local->device_name : \"(null)\",\n                         (local->volume_name != NULL) ? local->volume_name : \"(null)\");\n        (void)n;\n        OS_FileSysStartVolume_Impl_log(\"after OS_OBJECT_TABLE_GET\", (const void *)token, (const void *)local, local_info, strlen(local_info));\n    }\n    else\n    {\n        OS_FileSysStartVolume_Impl_log(\"after OS_OBJECT_TABLE_GET (null local)\", (const void *)token, NULL, NULL, 0);\n    }\n\n    /*\n     * Determine basic type of filesystem, if not already known\n     */\n    if (local->fstype == OS_FILESYS_TYPE_UNKNOWN &&\n        strncmp(local->device_name, OS_POSIX_DEVICEFILE_PREFIX, sizeof(OS_POSIX_DEVICEFILE_PREFIX) - 1) == 0)\n    {\n        /*\n         * If referring to a real device in the /dev filesystem,\n         * then assume it is a normal disk.\n         */\n        local->fstype = OS_FILESYS_TYPE_NORMAL_DISK;\n        /* Log the change of type */\n        OS_FileSysStartVolume_Impl_log(\"fstype set to NORMAL_DISK\", (const void *)token, (const void *)local, NULL, 0);\n    }\n\n    /*\n     * For VOLATILE volumes, there are two options:\n     *  - The /dev/shm filesystem, if it exists\n     *  - The /tmp filesystem\n     *\n     * The /dev/shm is preferable because it should actually be a ramdisk, but\n     * it is system-specific - should exist on Linux if it is mounted.\n     * The /tmp file system might be a regular persistent disk, but should always exist\n     * on any POSIX-compliant OS.\n     */\n\n    tmpdir = NULL;\n    if (local->fstype == OS_FILESYS_TYPE_VOLATILE_DISK)\n    {\n        /* find a suitable location to keep the volatile disk */\n        for (i = 0; i <= VOLATILE_DISK_LOC_MAX; ++i)\n        {\n            switch (i)\n            {\n                case VOLATILE_DISK_LOC_DEV_SHM:\n                    /* This is most preferable because it should actually be a ramdisk */\n                    tmpdir = \"/dev/shm\";\n                    break;\n                case VOLATILE_DISK_LOC_ENV:\n                    /* try the TMPDIR environment variable, if set */\n                    tmpdir = getenv(\"TMPDIR\");\n                    break;\n                case VOLATILE_DISK_LOC_VARTMP:\n                    /* try /var/tmp directory */\n                    tmpdir = \"/var/tmp\";\n                    break;\n                case VOLATILE_DISK_LOC_TMP:\n                    /* use /tmp directory as a last resort */\n                    tmpdir = \"/tmp\";\n                    break;\n                default:\n                    tmpdir = NULL;\n                    break;\n            }\n\n            /* Log candidate tmpdir being tested */\n            if (tmpdir != NULL)\n            {\n                OS_FileSysStartVolume_Impl_log(\"testing tmpdir candidate\", (const void *)token, (const void *)local, tmpdir, strlen(tmpdir));\n            }\n\n            if (tmpdir != NULL && stat(tmpdir, &stat_buf) == 0)\n            {\n                /* check if the user has write permission to the directory */\n                if ((stat_buf.st_mode & S_IWOTH) != 0 ||\n                    ((stat_buf.st_mode & S_IWGRP) != 0 && stat_buf.st_gid == getegid()) ||\n                    ((stat_buf.st_mode & S_IWUSR) != 0 && stat_buf.st_uid == geteuid()))\n                {\n                    /* Log successful tmpdir selection */\n                    OS_FileSysStartVolume_Impl_log(\"selected tmpdir\", (const void *)token, (const void *)local, tmpdir, strlen(tmpdir));\n                    break;\n                }\n                else\n                {\n                    OS_FileSysStartVolume_Impl_log(\"tmpdir not writable\", (const void *)token, (const void *)local, tmpdir, strlen(tmpdir));\n                }\n            }\n        }\n\n        if (tmpdir == NULL)\n        {\n            /* OS provides no place to put the volume */\n            OS_DEBUG(\"No storage location for volatile volumes\");\n            OS_FileSysStartVolume_Impl_log(\"no storage location for volatile volumes\", (const void *)token, (const void *)local, NULL, 0);\n            return OS_FS_ERR_DRIVE_NOT_CREATED;\n        }\n\n        /*\n         * Note - performing the concatenation in a single snprintf() call seems\n         * to trigger a (false) pointer overlap warning, because volume_name should\n         * always be null terminated.  To get around this, calculate the\n         * string size and check that it is within the expected size, and do the\n         * append of volume_name explicitly.\n         */\n        mplen = snprintf(local->system_mountpt, sizeof(local->system_mountpt), \"%s/osal:\", tmpdir);\n        if (mplen < sizeof(local->system_mountpt))\n        {\n            vollen = OS_strnlen(local->volume_name, sizeof(local->volume_name));\n            if ((vollen + mplen) >= sizeof(local->system_mountpt))\n            {\n                vollen = sizeof(local->system_mountpt) - mplen - 1;\n            }\n            memcpy(&local->system_mountpt[mplen], local->volume_name, vollen);\n            local->system_mountpt[mplen + vollen] = 0;\n\n            /* Log final mountpoint */\n            OS_FileSysStartVolume_Impl_log(\"mounted volatile volume\", (const void *)token, (const void *)local, local->system_mountpt, strlen(local->system_mountpt));\n        }\n    }\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysStartVolume_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not demonstrated by the code shown. In OS_FileSysStartVolume_Impl the parameter is declared const OS_object_token_t *token; the expression *token has type const OS_object_token_t and &(*token) (what the macro would produce) has type const OS_object_token_t *. A const qualification is only discarded if some later operation (the macro expansion or the function it invokes) requires a non-const pointer type. The supplied function does not show the macro or OS_ObjectIndexFromToken definitions, so there is no evidence in the submitted snippet that a const qualifier is actually dropped. The fact the test build completed without a const-discard diagnostic also suggests the compile path did not produce an implicit const-to-non-const conversion here.\n\nTherefore the report is speculative: the potential violation would live in the macro or the called function signature (they should accept a pointer-to-const if they do not modify the token), not in this function itself. To confirm or fix, inspect/modify the definitions of OS_OBJECT_TABLE_GET and any called functions so they take const OS_object_token_t * (or otherwise avoid discarding const)."
}