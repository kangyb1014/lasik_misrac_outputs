{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter UserObj is declared as void * and is assigned into StubPtr->Data.Cb.CallbackArg (also a non-const pointer). The code does not modify the pointed-to object, so both the parameter and the stored CallbackArg could and should be const-qualified (e.g. const void *). Therefore this use omits a const qualification and violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogProbe(const char *stage, UT_EntryKey_t FuncKey, UT_EntryType_t EntryType,\n                        UT_HookFuncPtr_t Value, void *UserObj, bool IsVarg, UT_StubTableEntry_t *StubPtr)\n{\n    FILE *f = fopen(\"/tmp/logs/2419.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log a short human readable stage description */\n    fprintf(f, \"---- UT_DoSetHookFunction: %s ----\\n\", stage);\n\n    /* Log key state values - cast to unsigned long for portable printing of integer enums */\n    fprintf(f, \"FuncKey=%lu EntryType=%lu Value.Addr=%p UserObj=%p IsVarg=%d StubPtr=%p\\n\",\n            (unsigned long)FuncKey,\n            (unsigned long)EntryType,\n            (void *)Value.Addr,\n            UserObj,\n            (int)IsVarg,\n            (void *)StubPtr);\n\n    /* Add a separator and flush/close */\n    fprintf(f, \"----------------------------------------\\n\");\n    fclose(f);\n}\n\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /* Log entry to function with initial parameter values */\n    UT_LogProbe(\"Enter - initial parameters\", FuncKey, EntryType, Value, UserObj, IsVarg, NULL);\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n\n    /* Log result of initial search */\n    UT_LogProbe(\"After first UT_GetStubEntry\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        UT_LogProbe(\"No existing entry and Value non-NULL - searching for unused slot\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        /* Log result of unused-slot search */\n        UT_LogProbe(\"After second UT_GetStubEntry (unused slot)\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        if (StubPtr == NULL)\n        {\n            /* Log right before abort so evidence exists in the logs */\n            UT_LogProbe(\"Abort condition - no slot available to set hook\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_LogProbe(\"Deleting entry - calling UT_ClearStubEntry\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n        UT_ClearStubEntry(StubPtr);\n        /* Log after deletion */\n        UT_LogProbe(\"Deleted entry - after UT_ClearStubEntry\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        UT_LogProbe(\"Setting entry - about to populate StubPtr fields\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n\n        /* Log after populating fields - capture stored pointer values to demonstrate assignment of UserObj */\n        UT_LogProbe(\"Set entry - after populating StubPtr\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n    }\n\n    /* Final exit log */\n    UT_LogProbe(\"Exit UT_DoSetHookFunction\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n---- UT_DoSetHookFunction: Enter - initial parameters ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After first UT_GetStubEntry ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: No existing entry and Value non-NULL - searching for unused slot ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After second UT_GetStubEntry (unused slot) ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=0x55c2d06aa280\n----------------------------------------\n---- UT_DoSetHookFunction: Setting entry - about to populate StubPtr fields ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=0x55c2d06aa280\n----------------------------------------\n---- UT_DoSetHookFunction: Set entry - after populating StubPtr ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=0x55c2d06aa280\n----------------------------------------\n---- UT_DoSetHookFunction: Exit UT_DoSetHookFunction ----\nFuncKey=94295208539455 EntryType=6 Value.Addr=0x55c2d068d5ec UserObj=(nil) IsVarg=0 StubPtr=0x55c2d06aa280\n----------------------------------------\n---- UT_DoSetHookFunction: Enter - initial parameters ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After first UT_GetStubEntry ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: No existing entry and Value non-NULL - searching for unused slot ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After second UT_GetStubEntry (unused slot) ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=0x5559afc392e0\n----------------------------------------\n---- UT_DoSetHookFunction: Setting entry - about to populate StubPtr fields ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=0x5559afc392e0\n----------------------------------------\n---- UT_DoSetHookFunction: Set entry - after populating StubPtr ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=0x5559afc392e0\n----------------------------------------\n---- UT_DoSetHookFunction: Exit UT_DoSetHookFunction ----\nFuncKey=93843689143143 EntryType=6 Value.Addr=0x5559afc1826f UserObj=(nil) IsVarg=0 StubPtr=0x5559afc392e0\n----------------------------------------\n---- UT_DoSetHookFunction: Enter - initial parameters ----\nFuncKey=93843689134787 EntryType=6 Value.Addr=0x5559afc16ed3 UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After first UT_GetStubEntry ----\nFuncKey=93843689134787 EntryType=6 Value.Addr=0x5559afc16ed3 UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: No existing entry and Value non-NULL - searching for unused slot ----\nFuncKey=93843689134787 EntryType=6 Value.Addr=0x5559afc16ed3 UserObj=(nil) IsVarg=0 StubPtr=(nil)\n----------------------------------------\n---- UT_DoSetHookFunction: After second UT_GetStubEntry (unused slot) ----\nFuncKey=93843689134787 EntryType=6 Value.Addr=0x5559afc16ed3 UserObj=(nil) IsVarg=0 StubPtr=0x5559afc39760\n----------------------------------------\n---- UT_DoSetHookFunction: Setting entry - about to populate StubPtr fields ----\nFuncKey=93843689134787 EntryType=6 Value.Addr=0x5559afc16ed3 UserObj=(nil) IsVarg=0 StubPtr=0x5559afc39760\n------------------------------------\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not justified given the available code. MISRA C:2023 Rule 8.13 is an advisory (should) that encourages pointer types to be const-qualified when the pointed-to object is not modified. In this function the UserObj parameter is merely received and stored into StubPtr->Data.Cb.CallbackArg (both are non-const). That observation alone does not prove a Rule 8.13 violation because making the parameter const would require the stored field and all uses of that field throughout the code base to accept a const pointer as well. Without analysing the rest of the program (how CallbackArg is later used/passed) you cannot conclude that const qualification is possible. The provided runtime logs only show UserObj values (mostly NULL) at runtime and do not demonstrate that the pointed-to object is never modified elsewhere or that changing the declaration to const is feasible. Therefore the report that this code violates MISRA Rule 8.13 is not correct."
}