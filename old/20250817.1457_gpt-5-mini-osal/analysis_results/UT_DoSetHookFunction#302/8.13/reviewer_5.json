{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function takes a pointer parameter 'void *UserObj' which is not const-qualified even though the function does not modify the pointee (it only stores the pointer in StubPtr->Data.Cb.CallbackArg). According to MISRA C 2023 Rule 8.13 this should be declared as 'const void *UserObj'. Additionally, the UT_HookFuncPtr_t union contains pointer members (e.g. Addr) that are not const-qualified; if those pointers are not used to modify the pointees they too should be const-qualified.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_AppendLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2419.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void UT_LogEntryPoint(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj, bool IsVarg)\n{\n    /* Log the incoming parameters and immediate state */\n    UT_AppendLog(\"ENTER UT_DoSetHookFunction: FuncKey=%llu EntryType=%llu Value.Addr=%p UserObj=%p IsVarg=%d\",\n                 (unsigned long long)FuncKey,\n                 (unsigned long long)EntryType,\n                 (void *)Value.Addr,\n                 UserObj,\n                 (int)IsVarg);\n\n    /* Note about const-qualification (for auditors) - record that UserObj is passed as non-const */\n    UT_AppendLog(\"NOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\");\n}\nstatic void UT_LogAfterFind(UT_StubTableEntry_t *StubPtr)\n{\n    UT_AppendLog(\"After UT_GetStubEntry: StubPtr=%p\", (void *)StubPtr);\n}\nstatic void UT_LogBeforeClear(UT_StubTableEntry_t *StubPtr)\n{\n    UT_AppendLog(\"Clearing stub entry at %p\", (void *)StubPtr);\n}\nstatic void UT_LogBeforeSet(UT_StubTableEntry_t *StubPtr, UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj, bool IsVarg)\n{\n    UT_AppendLog(\"Setting stub at %p: new FuncKey=%llu EntryType=%llu Value.Addr=%p UserObj=%p IsVarg=%d\",\n                 (void *)StubPtr,\n                 (unsigned long long)FuncKey,\n                 (unsigned long long)EntryType,\n                 (void *)Value.Addr,\n                 UserObj,\n                 (int)IsVarg);\n}\nstatic void UT_LogAfterSet(UT_StubTableEntry_t *StubPtr)\n{\n    /* Attempt to log stored fields to capture the exact stored state */\n    if (StubPtr != NULL)\n    {\n        UT_AppendLog(\"After set: StubPtr=%p Stored.FuncKey=%llu Stored.EntryType=%llu Stored.CallbackArg=%p Stored.Ptr=%p Stored.IsVarg=%d\",\n                     (void *)StubPtr,\n                     (unsigned long long)StubPtr->FuncKey,\n                     (unsigned long long)StubPtr->EntryType,\n                     (void *)StubPtr->Data.Cb.CallbackArg,\n                     (void *)StubPtr->Data.Cb.Ptr.Addr,\n                     (int)StubPtr->Data.Cb.IsVarg);\n    }\n    else\n    {\n        UT_AppendLog(\"After set: StubPtr is NULL\");\n    }\n}\n\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /* Log entry */\n    UT_LogEntryPoint(FuncKey, EntryType, Value, UserObj, IsVarg);\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    UT_LogAfterFind(StubPtr);\n\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        UT_AppendLog(\"No existing stub and Value.Addr != NULL - searching for UNUSED slot\");\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        UT_LogAfterFind(StubPtr);\n        if (StubPtr == NULL)\n        {\n            UT_AppendLog(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low? About to abort\");\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_LogBeforeClear(StubPtr);\n        UT_ClearStubEntry(StubPtr);\n        UT_AppendLog(\"Cleared stub entry at %p\", (void *)StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        UT_LogBeforeSet(StubPtr, FuncKey, EntryType, Value, UserObj, IsVarg);\n\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n\n        /* Log the stored state for later analysis */\n        UT_LogAfterSet(StubPtr);\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER UT_DoSetHookFunction: FuncKey=94696048534879 EntryType=6 Value.Addr=0x56202455c60c UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x5620245764a0\nSetting stub at 0x5620245764a0: new FuncKey=94696048534879 EntryType=6 Value.Addr=0x56202455c60c UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x5620245764a0 Stored.FuncKey=94696048534879 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56202455c60c Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510020999 EntryType=6 Value.Addr=0x56409ce3128f UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x56409ce50040\nSetting stub at 0x56409ce50040: new FuncKey=94835510020999 EntryType=6 Value.Addr=0x56409ce3128f UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x56409ce50040 Stored.FuncKey=94835510020999 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56409ce3128f Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510012643 EntryType=6 Value.Addr=0x56409ce2fef3 UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x56409ce504c0\nSetting stub at 0x56409ce504c0: new FuncKey=94835510012643 EntryType=6 Value.Addr=0x56409ce2fef3 UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x56409ce504c0 Stored.FuncKey=94835510012643 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56409ce2fef3 Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510001268 EntryType=6 Value.Addr=0x56409ce2df21 UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x56409ce4dfa0\nSetting stub at 0x56409ce4dfa0: new FuncKey=94835510001268 EntryType=6 Value.Addr=0x56409ce2df21 UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x56409ce4dfa0 Stored.FuncKey=94835510001268 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56409ce2df21 Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510016569 EntryType=6 Value.Addr=0x56409ce30116 UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x56409ce4c6e0\nSetting stub at 0x56409ce4c6e0: new FuncKey=94835510016569 EntryType=6 Value.Addr=0x56409ce30116 UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x56409ce4c6e0 Stored.FuncKey=94835510016569 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56409ce30116 Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510014729 EntryType=6 Value.Addr=0x56409ce30331 UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.Addr != NULL - searching for UNUSED slot\nAfter UT_GetStubEntry: StubPtr=0x56409ce56fa0\nSetting stub at 0x56409ce56fa0: new FuncKey=94835510014729 EntryType=6 Value.Addr=0x56409ce30331 UserObj=(nil) IsVarg=0\nAfter set: StubPtr=0x56409ce56fa0 Stored.FuncKey=94835510014729 Stored.EntryType=6 Stored.CallbackArg=(nil) Stored.Ptr=0x56409ce30331 Stored.IsVarg=0\nENTER UT_DoSetHookFunction: FuncKey=94835510014198 EntryType=6 Value.Addr=0x56409ce2ffe3 UserObj=(nil) IsVarg=0\nNOTE: UserObj parameter is non-const (type: void *). Value.Addr member is non-const pointer (if used).\nAfter UT_GetStubEntry: StubPtr=(nil)\nNo existing stub and Value.A\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UT_DoSetHookFunction takes a pointer parameter UserObj of type void * and never dereferences or modifies the pointee; it only stores the pointer into StubPtr->Data.Cb.CallbackArg. Under MISRA C 2023 Rule 8.13 (\u201cA pointer should point to a const\u2011qualified type whenever possible\u201d), the parameter should be declared as const void * (and the corresponding CallbackArg field in the stub table should be const void * to avoid qualifier discarding). The test logs supplied by agent A confirm the parameter is declared non\u2011const (the code records a NOTE that UserObj is of type void *), supporting the claim. Similarly, any data\u2011pointer members inside the UT_HookFuncPtr_t union that are used only for pointing (not for modifying pointees) should be const\u2011qualified; function pointer members are a different case, but data pointers in the union should be reviewed and const\u2011qualified where appropriate. Therefore the agent\u2019s report that the code violates MISRA C 2023 Rule 8.13 is correct."
}