{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The union member UT_HookFuncPtr_t::Addr is declared as void * but is only used for inspection/storage (checked against NULL and copied), not for modifying pointee data. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so Addr should be const void * (or otherwise const-qualified) if it is not intended to allow modification through the pointer. The conditional if (StubPtr == NULL && Value.Addr != NULL) therefore uses a non-const pointer where a const-qualified pointer would be appropriate \u2014 this constitutes a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogHookEvent(const char *event, UT_EntryKey_t FuncKey, UT_EntryType_t EntryType,\n                            UT_HookFuncPtr_t Value, void *UserObj, bool IsVarg, UT_StubTableEntry_t *StubPtr)\n{\n    FILE *fp = fopen(\"/tmp/logs/2419.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* Best effort logging; do not interfere with normal flow */\n    }\n\n    /* Log the event and relevant state. Cast keys/types to uintptr_t for portable integer printing. */\n    fprintf(fp, \"Event: %s\\n\", event);\n    fprintf(fp, \"  FuncKey   = 0x%\" PRIxPTR \"\\n\", (uintptr_t)FuncKey);\n    fprintf(fp, \"  EntryType = 0x%\" PRIxPTR \"\\n\", (uintptr_t)EntryType);\n    fprintf(fp, \"  StubPtr   = %p\\n\", (void *)StubPtr);\n    fprintf(fp, \"  Value.Addr= %p\\n\", (void *)Value.Addr);\n    fprintf(fp, \"  UserObj   = %p\\n\", UserObj);\n    fprintf(fp, \"  IsVarg    = %d\\n\", (IsVarg) ? 1 : 0);\n    fprintf(fp, \"----------------------------------------\\n\");\n    fflush(fp);\n    fclose(fp);\n}\n\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /* Log entry into the function with initial parameters */\n    UT_LogHookEvent(\"UT_DoSetHookFunction - enter\", FuncKey, EntryType, Value, UserObj, IsVarg, NULL);\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n\n    /* Log result of initial lookup */\n    UT_LogHookEvent(\"UT_DoSetHookFunction - after initial lookup\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        UT_LogHookEvent(\"UT_DoSetHookFunction - need to create force fail entry (no existing stub)\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        /* Log result of unused-slot lookup */\n        UT_LogHookEvent(\"UT_DoSetHookFunction - after lookup for unused slot\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        if (StubPtr == NULL)\n        {\n            UT_LogHookEvent(\"UT_DoSetHookFunction - aborting: no slot available\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_LogHookEvent(\"UT_DoSetHookFunction - deleting entry (Value.Addr == NULL)\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        UT_LogHookEvent(\"UT_DoSetHookFunction - setting entry (store values)\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n\n        /* Log after storing */\n        UT_LogHookEvent(\"UT_DoSetHookFunction - after storing entry\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n    }\n\n    /* Final log to capture exit state */\n    UT_LogHookEvent(\"UT_DoSetHookFunction - exit\", FuncKey, EntryType, Value, UserObj, IsVarg, StubPtr);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEvent: UT_DoSetHookFunction - enter\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after initial lookup\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - need to create force fail entry (no existing stub)\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after lookup for unused slot\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = 0x561a1a8bfd80\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - setting entry (store values)\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = 0x561a1a8bfd80\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after storing entry\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = 0x561a1a8bfd80\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - exit\n  FuncKey   = 0x561a1a89f55f\n  EntryType = 0x6\n  StubPtr   = 0x561a1a8bfd80\n  Value.Addr= 0x561a1a8a160c\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - enter\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after initial lookup\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - need to create force fail entry (no existing stub)\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after lookup for unused slot\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = 0x55eeea744c80\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - setting entry (store values)\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = 0x55eeea744c80\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after storing entry\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = 0x55eeea744c80\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - exit\n  FuncKey   = 0x55eeea720b87\n  EntryType = 0x6\n  StubPtr   = 0x55eeea744c80\n  Value.Addr= 0x55eeea72128f\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - enter\n  FuncKey   = 0x55eeea71eae3\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea71fef3\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after initial lookup\n  FuncKey   = 0x55eeea71eae3\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea71fef3\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - need to create force fail entry (no existing stub)\n  FuncKey   = 0x55eeea71eae3\n  EntryType = 0x6\n  StubPtr   = (nil)\n  Value.Addr= 0x55eeea71fef3\n  UserObj   = (nil)\n  IsVarg    = 0\n----------------------------------------\nEvent: UT_DoSetHookFunction - after lookup for unused slot\n  FuncKey   = 0x55eeea71eae3\n  EntryType = 0x6\n  StubPtr   = 0x55eeea745100\n  Value.Addr= 0x55eeea71fef3\n  UserObj\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 8.13 states that a pointer should point to a const-qualified type whenever possible. In the UT_DoSetHookFunction implementation Value.Addr is only inspected (compared to NULL) and copied into the stub table; it is never dereferenced or used to modify the pointee. The logged execution trace shows only NULL checks and storage operations. Therefore the pointer represents read-only usage and should be declared with a const-qualified target (e.g. const void *), so the current declaration (void *) violates Rule 8.13."
}