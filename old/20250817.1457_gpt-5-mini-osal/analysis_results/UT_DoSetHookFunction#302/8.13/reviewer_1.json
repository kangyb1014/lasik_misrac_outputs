{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The union has a non-const data pointer member: 'void * Addr'. This member is used to hold hook/callback addresses (read-only references to code/data) and could be const-qualified (e.g., 'const void * Addr') to prevent modification through the pointer. Since at least one pointer in the union can reasonably and safely be made to point to a const-qualified type, Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned long UT_EntryKey_t;\ntypedef struct\n{\n    void *CallbackArg;\n    UT_HookFuncPtr_t Ptr;\n    int IsVarg;\n} UT_CbData_t;\nextern void UtAssert_Abort(const char *msg);\nstatic void UT_AppendLog(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2419.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputs(\"\\n\", f);\n    fclose(f);\n}\nstatic void UT_LogPointerLabel(const char *label, const void *p)\n{\n    UT_AppendLog(\"%s: %p\", label, p);\n}\nstatic void UT_LogKeyAndType(const char *prefix, unsigned long key, unsigned long type)\n{\n    UT_AppendLog(\"%s FuncKey=0x%lx EntryType=0x%lx\", prefix, key, type);\n}\nstatic void UT_LogBool(const char *label, int b)\n{\n    UT_AppendLog(\"%s: %s\", label, b ? \"true\" : \"false\");\n}\nstatic void UT_LogStubEntryState(UT_StubTableEntry_t *StubPtr)\n{\n    if (StubPtr == NULL)\n    {\n        UT_AppendLog(\"StubPtr: NULL\");\n        return;\n    }\n\n    /* Attempt to log key fields; cast to unsigned long for portability in logs */\n    UT_AppendLog(\"StubPtr: %p\", (void *)StubPtr);\n    UT_AppendLog(\"  ->FuncKey=0x%lx\", (unsigned long)StubPtr->FuncKey);\n    UT_AppendLog(\"  ->EntryType=0x%lx\", (unsigned long)StubPtr->EntryType);\n    UT_AppendLog(\"  ->Data.Cb.CallbackArg=%p\", (void *)StubPtr->Data.Cb.CallbackArg);\n\n    /* StubPtr->Data.Cb.Ptr is a UT_HookFuncPtr_t (not a raw pointer). Log its Addr member. */\n    UT_AppendLog(\"  ->Data.Cb.Ptr=%p\", (const void *)StubPtr->Data.Cb.Ptr.Addr);\n\n    UT_AppendLog(\"  ->Data.Cb.IsVarg=%d\", (int)StubPtr->Data.Cb.IsVarg);\n}\n\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    UT_AppendLog(\"ENTER UT_DoSetHookFunction\");\n    UT_LogKeyAndType(\"Inputs\", (unsigned long)FuncKey, (unsigned long)EntryType);\n    UT_LogPointerLabel(\"Value.Addr\", (const void *)Value.Addr);\n    UT_LogPointerLabel(\"UserObj\", UserObj);\n    UT_LogBool(\"IsVarg\", IsVarg);\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    UT_AppendLog(\"After first UT_GetStubEntry call\");\n    UT_LogStubEntryState(StubPtr);\n\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        UT_AppendLog(\"No existing entry found and Value.Addr != NULL -> looking for unused slot\");\n\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, (UT_EntryType_t)0 /* UT_ENTRYTYPE_UNUSED placeholder */);\n        UT_AppendLog(\"After second UT_GetStubEntry (unused) call\");\n        UT_LogStubEntryState(StubPtr);\n\n        if (StubPtr == NULL)\n        {\n            UT_AppendLog(\"ERROR: No unused slot found - about to abort\");\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_AppendLog(\"Deleting existing entry (Value.Addr == NULL && StubPtr != NULL)\");\n        UT_LogStubEntryState(StubPtr);\n\n        UT_ClearStubEntry(StubPtr);\n\n        UT_AppendLog(\"After UT_ClearStubEntry\");\n        UT_LogStubEntryState(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        UT_AppendLog(\"Setting entry (StubPtr != NULL && Value.Addr != NULL)\");\n        UT_AppendLog(\"Before assignment:\");\n        UT_LogStubEntryState(StubPtr);\n\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n\n        UT_AppendLog(\"After assignment:\");\n        UT_LogStubEntryState(StubPtr);\n\n        /* Explicitly log the observed Value.Addr to highlight potential const-qualification issue */\n        UT_AppendLog(\"Observed hook address (Value.Addr) = %p\", (const void *)Value.Addr);\n    }\n\n    UT_AppendLog(\"EXIT UT_DoSetHookFunction\");\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER UT_DoSetHookFunction\nInputs FuncKey=0x55f455c1455f EntryType=0x6\nValue.Addr: 0x55f455c1660c\nUserObj: (nil)\nIsVarg: false\nAfter first UT_GetStubEntry call\nStubPtr: NULL\nNo existing entry found and Value.Addr != NULL -> looking for unused slot\nAfter second UT_GetStubEntry (unused) call\nStubPtr: 0x55f455c2fcc0\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nSetting entry (StubPtr != NULL && Value.Addr != NULL)\nBefore assignment:\nStubPtr: 0x55f455c2fcc0\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nAfter assignment:\nStubPtr: 0x55f455c2fcc0\n  ->FuncKey=0x55f455c1455f\n  ->EntryType=0x6\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=0x55f455c1660c\n  ->Data.Cb.IsVarg=0\nObserved hook address (Value.Addr) = 0x55f455c1660c\nEXIT UT_DoSetHookFunction\nENTER UT_DoSetHookFunction\nInputs FuncKey=0x55a787b7ab87 EntryType=0x6\nValue.Addr: 0x55a787b7b28f\nUserObj: (nil)\nIsVarg: false\nAfter first UT_GetStubEntry call\nStubPtr: NULL\nNo existing entry found and Value.Addr != NULL -> looking for unused slot\nAfter second UT_GetStubEntry (unused) call\nStubPtr: 0x55a787b9b8c0\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nSetting entry (StubPtr != NULL && Value.Addr != NULL)\nBefore assignment:\nStubPtr: 0x55a787b9b8c0\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nAfter assignment:\nStubPtr: 0x55a787b9b8c0\n  ->FuncKey=0x55a787b7ab87\n  ->EntryType=0x6\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=0x55a787b7b28f\n  ->Data.Cb.IsVarg=0\nObserved hook address (Value.Addr) = 0x55a787b7b28f\nEXIT UT_DoSetHookFunction\nENTER UT_DoSetHookFunction\nInputs FuncKey=0x55a787b78ae3 EntryType=0x6\nValue.Addr: 0x55a787b79ef3\nUserObj: (nil)\nIsVarg: false\nAfter first UT_GetStubEntry call\nStubPtr: NULL\nNo existing entry found and Value.Addr != NULL -> looking for unused slot\nAfter second UT_GetStubEntry (unused) call\nStubPtr: 0x55a787b9bd40\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nSetting entry (StubPtr != NULL && Value.Addr != NULL)\nBefore assignment:\nStubPtr: 0x55a787b9bd40\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nAfter assignment:\nStubPtr: 0x55a787b9bd40\n  ->FuncKey=0x55a787b78ae3\n  ->EntryType=0x6\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=0x55a787b79ef3\n  ->Data.Cb.IsVarg=0\nObserved hook address (Value.Addr) = 0x55a787b79ef3\nEXIT UT_DoSetHookFunction\nENTER UT_DoSetHookFunction\nInputs FuncKey=0x55a787b75e74 EntryType=0x6\nValue.Addr: 0x55a787b77f21\nUserObj: (nil)\nIsVarg: false\nAfter first UT_GetStubEntry call\nStubPtr: NULL\nNo existing entry found and Value.Addr != NULL -> looking for unused slot\nAfter second UT_GetStubEntry (unused) call\nStubPtr: 0x55a787b99820\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nSetting entry (StubPtr != NULL && Value.Addr != NULL)\nBefore assignment:\nStubPtr: 0x55a787b99820\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nAfter assignment:\nStubPtr: 0x55a787b99820\n  ->FuncKey=0x55a787b75e74\n  ->EntryType=0x6\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=0x55a787b77f21\n  ->Data.Cb.IsVarg=0\nObserved hook address (Value.Addr) = 0x55a787b77f21\nEXIT UT_DoSetHookFunction\nENTER UT_DoSetHookFunction\nInputs FuncKey=0x55a787b79a39 EntryType=0x6\nValue.Addr: 0x55a787b7a116\nUserObj: (nil)\nIsVarg: false\nAfter first UT_GetStubEntry call\nStubPtr: NULL\nNo existing entry found and Value.Addr != NULL -> looking for unused slot\nAfter second UT_GetStubEntry (unused) call\nStubPtr: 0x55a787b97f60\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n  ->Data.Cb.IsVarg=0\nSetting entry (StubPtr != NULL && Value.Addr != NULL)\nBefore assignment:\nStubPtr: 0x55a787b97f60\n  ->FuncKey=0x0\n  ->EntryType=0x0\n  ->Data.Cb.CallbackArg=(nil)\n  ->Data.Cb.Ptr=(nil)\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 requires adding const qualification only when the pointer\u2019s target is not modified through that pointer for the entire program usage. The evidence shown is limited to this function\u2019s read-only uses (storing and comparing addresses) but does not prove that the Addr member is, for the whole program, only ever used to point to read-only objects. In typical implementations UT_HookFuncPtr_t is a union that carries different pointer kinds (including function pointers). Function types cannot meaningfully be const-qualified and converting between function pointers and object pointers (void *) is problematic and governed by other rules; changing Addr to const void * would be neither universally correct nor practical across all union variants and call sites. Therefore, based on the actual code semantics and typical usage, the pointer cannot be unilaterally made const without further whole-program changes, so the claimed violation of Rule 8.13 is not established."
}