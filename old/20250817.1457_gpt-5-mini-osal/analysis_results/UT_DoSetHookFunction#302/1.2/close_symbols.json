{
  "user_message": "Target function code is:\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_DoSetHookFunction': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort', 'UT_ClearStubEntry'], 'callers': ['UT_SetHookFunction', 'UT_SetVaHookFunction', 'UT_SetHandlerFunction', 'UT_SetVaHandlerFunction']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_ClearStubEntry': {'callees': [], 'callers': ['UT_ResetState', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_DefaultStubImplWithArgs']}, 'UT_SetHookFunction': {'callees': ['UT_DoSetHookFunction'], 'callers': []}, 'UT_SetVaHookFunction': {'callees': ['UT_DoSetHookFunction'], 'callers': []}, 'UT_SetHandlerFunction': {'callees': ['UT_DoSetHookFunction'], 'callers': ['UT_ExecuteBasicHandler']}, 'UT_SetVaHandlerFunction': {'callees': ['UT_DoSetHookFunction'], 'callers': ['UT_ExecuteVaHandler']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t",
    "UT_EntryType_t",
    "UT_HookFuncPtr_t",
    "UT_StubTableEntry_t",
    "UT_GetStubEntry",
    "UT_ClearStubEntry",
    "UtAssert_Abort",
    "UT_ENTRYTYPE_UNUSED",
    "UT_MAX_FUNC_STUBS",
    "bool / stdbool.h or project's bool typedef",
    "NULL / <stddef.h> or project NULL definition"
  ],
  "explanation": "For determining whether UT_DoSetHookFunction uses any compiler language extensions you must inspect the concrete declarations/definitions that could hide extensions or non\u2011standard constructs used by this function:\n\n- UT_EntryKey_t: the typedef may be an alias to a compiler\u2011specific type or use extension syntax (e.g. attributes, unusual storage class). Need the definition to check for extensions.\n- UT_EntryType_t: likely an enum or typedef; its definition can use compiler extensions (attributes, non\u2011standard enum size) that affect how the function uses it.\n- UT_HookFuncPtr_t: this type is inspected in the function (Value.Addr is compared to NULL and Value is assigned into a struct field). You must see whether UT_HookFuncPtr_t is a struct/union or a function pointer type, and whether it uses compiler extensions (anonymous members, GCC attributes, pointer-to-function/data conversions, non\u2011standard representations).\n- UT_StubTableEntry_t: the function reads and writes fields of this struct (FuncKey, EntryType, Data.Cb.CallbackArg, Data.Cb.Ptr, Data.Cb.IsVarg). The struct definition must be checked for extensions such as anonymous structs/unions, packed/align attributes, bit\u2011fields with implementation\u2011defined layout, or other compiler\u2011specific qualifiers.\n- UT_GetStubEntry (declaration/definition): called by this function; its prototype/definition must be checked for compiler extensions (e.g. __attribute__ ((...)), non\u2011standard calling conventions, inline/extern variations) that would make the call site use language extensions.\n- UT_ClearStubEntry (declaration/definition): as above, its declaration/definition must be inspected for attributes or extension usage.\n- UtAssert_Abort (declaration/definition): used to abort with a message; its prototype/definition may carry compiler attributes (noreturn, format, etc.) or use other extensions that affect portability/standard conformance.\n- UT_ENTRYTYPE_UNUSED (macro/enum value): the macro/constant used in the conditional may be defined using non\u2011standard constructs or macros that expand to compiler\u2011specific code; its definition must be checked.\n- UT_MAX_FUNC_STUBS: referenced by the abort message text; inspect its definition in case it is produced by non\u2011standard constructs or used elsewhere in ways that introduce extensions.\n- bool / stdbool.h or project bool typedef: the parameter IsVarg is of type bool. Verify whether the project uses the standard C99 stdbool.h or a project typedef or macro that might be a compiler extension.\n- NULL / <stddef.h> or project NULL definition: the code compares pointers to NULL; check the definition of NULL in the project (some projects redefine NULL in non\u2011standard ways) though this is less likely to be an extension.\n\nProvide these symbols (their typedef/struct/enum/macro/function definitions) to the next analyzer so it can detect any compiler\u2011specific attributes, anonymous/implementation\u2011defined constructs, or other language extensions hidden behind these declarations."
}