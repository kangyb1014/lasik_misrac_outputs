{
  "user_message": "An agent A claimed that the following UT_DoSetHookFunction code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of UT_DoSetHookFunction.\n```c\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:UT_BSP_DoText calls strlen(OutputMessage) without checking that OutputMessage is non-NULL and points to a NUL-terminated buffer. If UT_BSP_DoText is ever invoked with a NULL pointer or with a pointer to a char buffer that is not NUL-terminated (for example, a slice/partial buffer or user-supplied data), strlen will read past the object bounds to search for the terminating '\\0', violating MISRA C 2023 Rule 21.17. (Note: the specific call from UT_DoSetHookFunction/UtAssert_Abort uses a string literal so is safe, but the UT_BSP_DoText implementation itself lacks the required guarantees.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void UT_DoSetHookFunction(UT_EntryKey_t FuncKey, UT_EntryType_t EntryType, UT_HookFuncPtr_t Value, void *UserObj,\n                                 bool IsVarg)\n{\n    UT_StubTableEntry_t *StubPtr;\n    FILE *log = fopen(\"/tmp/logs/2423.txt\", \"a\");\n\n    if (log != NULL)\n    {\n        /* Log entry and parameter state. Avoid dereferencing unknown pointers; only log whether Value.Addr is NULL. */\n        fprintf(log, \"UT_DoSetHookFunction ENTER: FuncKey=%u EntryType=%u Value.Addr_is_null=%d UserObj=%p IsVarg=%d\\n\",\n                (unsigned)FuncKey,\n                (unsigned)EntryType,\n                (Value.Addr == NULL) ? 1 : 0,\n                UserObj,\n                IsVarg ? 1 : 0);\n        fflush(log);\n    }\n\n    /*\n     * First find an existing hook entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, EntryType);\n\n    if (log != NULL)\n    {\n        fprintf(log, \"After first UT_GetStubEntry: StubPtr=%p\\n\", (void *)StubPtr);\n        fflush(log);\n    }\n\n    if (StubPtr == NULL && Value.Addr != NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        if (log != NULL)\n        {\n            fprintf(log, \"No existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\\n\");\n            fflush(log);\n        }\n\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (log != NULL)\n        {\n            fprintf(log, \"After second UT_GetStubEntry(UNUSED): StubPtr=%p\\n\", (void *)StubPtr);\n            fflush(log);\n        }\n\n        if (StubPtr == NULL)\n        {\n            if (log != NULL)\n            {\n                fprintf(log, \"Cannot set hook function - no unused slots available, about to call UtAssert_Abort\\n\");\n                fflush(log);\n                fclose(log);\n                log = NULL;\n            }\n\n            /* Preserve original behavior */\n            UtAssert_Abort(\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\");\n        }\n    }\n\n    if (Value.Addr == NULL && StubPtr != NULL)\n    {\n        /* Caller wants to delete the entry */\n        if (log != NULL)\n        {\n            fprintf(log, \"Deleting stub entry at %p (clear)\\n\", (void *)StubPtr);\n            fflush(log);\n        }\n\n        UT_ClearStubEntry(StubPtr);\n    }\n    else if (StubPtr != NULL && Value.Addr != NULL)\n    {\n        /* Caller wants to set the entry */\n        if (log != NULL)\n        {\n            fprintf(log, \"Setting stub entry at %p: FuncKey=%u EntryType=%u UserObj=%p IsVarg=%d\\n\",\n                    (void *)StubPtr,\n                    (unsigned)FuncKey,\n                    (unsigned)EntryType,\n                    UserObj,\n                    IsVarg ? 1 : 0);\n            fflush(log);\n        }\n\n        StubPtr->FuncKey             = FuncKey;\n        StubPtr->EntryType           = EntryType;\n        StubPtr->Data.Cb.CallbackArg = UserObj;\n        StubPtr->Data.Cb.Ptr         = Value;\n        StubPtr->Data.Cb.IsVarg      = IsVarg;\n\n        if (log != NULL)\n        {\n            fprintf(log, \"Stub entry set at %p\\n\", (void *)StubPtr);\n            fflush(log);\n        }\n    }\n\n    if (log != NULL)\n    {\n        fprintf(log, \"UT_DoSetHookFunction EXIT\\n\");\n        fclose(log);\n    }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_DoSetHookFunction ENTER: FuncKey=1148380511 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x559544750840\nSetting stub entry at 0x559544750840: FuncKey=1148380511 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x559544750840\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744216455 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a3939380\nSetting stub entry at 0x55e6a3939380: FuncKey=2744216455 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a3939380\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744208099 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a3939800\nSetting stub entry at 0x55e6a3939800: FuncKey=2744208099 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a3939800\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744196724 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a39372e0\nSetting stub entry at 0x55e6a39372e0: FuncKey=2744196724 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a39372e0\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744212025 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a3935a20\nSetting stub entry at 0x55e6a3935a20: FuncKey=2744212025 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a3935a20\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744210185 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a3932300\nSetting stub entry at 0x55e6a3932300: FuncKey=2744210185 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a3932300\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=2744209654 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55e6a3936d40\nSetting stub entry at 0x55e6a3936d40: FuncKey=2744209654 EntryType=6 UserObj=(nil) IsVarg=0\nStub entry set at 0x55e6a3936d40\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=220246227 EntryType=3 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55df0d224460\nSetting stub entry at 0x55df0d224460: FuncKey=220246227 EntryType=3 UserObj=(nil) IsVarg=0\nStub entry set at 0x55df0d224460\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=1747343036 EntryType=3 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter first UT_GetStubEntry: StubPtr=(nil)\nNo existing stub found and a non-NULL hook provided - attempting to grab UNUSED slot\nAfter second UT_GetStubEntry(UNUSED): StubPtr=0x55db6828ca80\nSetting stub entry at 0x55db6828ca80: FuncKey=1747343036 EntryType=3 UserObj=(nil) IsVarg=0\nStub entry set at 0x55db6828ca80\nUT_DoSetHookFunction EXIT\nUT_DoSetHookFunction ENTER: FuncKey=1747319254 EntryType=6 Value.Addr_is_null=0 UserObj=(nil) IsVarg=0\nAfter fi\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.17 concerns use of string.h functions that may read/write past the bounds of the objects referenced by pointer parameters. The UT_DoSetHookFunction implementation shown contains no calls to any string.h functions (memcpy, strlen, etc.). The only function that could conceivably lead to a string operation is UtAssert_Abort, but it is invoked here with a string literal (\"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\"), which is a NUL-terminated static object and thus safe. The supplied test trace also shows that the UtAssert_Abort path was not taken (unused slots were found and stubs were set), so there is no runtime evidence that this function led to an out\u2011of\u2011bounds string access. Agent A\u2019s scenario points to a potential problem in UT_BSP_DoText itself (if it calls strlen on a possibly NULL/non-terminated pointer), but that is a separate implementation issue and does not demonstrate a violation in UT_DoSetHookFunction as shown. Therefore the report that UT_DoSetHookFunction violates MISRA Rule 21.17 is not correct."
}