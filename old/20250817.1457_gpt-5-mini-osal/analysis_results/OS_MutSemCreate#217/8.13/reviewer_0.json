{
  "user_message": "An agent A claimed that the following OS_MutSemCreate code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemCreate.\n```c\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_MutSemCreate_Impl(&token, options);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_MutSemCreate_Impl is called with &token where the comment says the implementation only \"reads info from the table\". If OS_MutSemCreate_Impl is declared to take a non-const pointer (e.g. OS_object_token_t *token) but does not modify the pointed-to object, then the parameter should be const-qualified (const OS_object_token_t *). In that case the current prototype/use violates MISRA C 2023 Rule 8.13 because a pointer that could be to a const-qualified type is not declared const.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_1739_Log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1739.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails, do not change program behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n\n    /* Log entry and parameters */\n    OS_1739_Log(\"OS_MutSemCreate entry: sem_id_ptr=%p, sem_name=%s, options=0x%08\" PRIx32,\n                (void *)sem_id,\n                (sem_name != NULL) ? sem_name : \"(null)\",\n                (uint32)options);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    OS_1739_Log(\"OS_ObjectIdAllocateNew returned %ld, token_addr=%p\", (long)return_code, (void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n        OS_1739_Log(\"OS_OBJECT_TABLE_GET returned mutex_ptr=%p for token_addr=%p\", (void *)mutex, (void *)&token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n        OS_1739_Log(\"OS_OBJECT_INIT called: token_addr=%p, name=%s\", (void *)&token, (sem_name != NULL) ? sem_name : \"(null)\");\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        OS_1739_Log(\"Calling OS_MutSemCreate_Impl with token_addr=%p, options=0x%08\" PRIx32, (void *)&token, (uint32)options);\n        return_code = OS_MutSemCreate_Impl(&token, options);\n        OS_1739_Log(\"OS_MutSemCreate_Impl returned %ld\", (long)return_code);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n        if (sem_id != NULL)\n        {\n            OS_1739_Log(\"OS_ObjectIdFinalizeNew result=%ld, sem_id_ptr=%p, sem_id_value=0x%08\" PRIxPTR,\n                        (long)return_code, (void *)sem_id, (uintptr_t)(*sem_id));\n        }\n        else\n        {\n            OS_1739_Log(\"OS_ObjectIdFinalizeNew result=%ld, sem_id_ptr=(null)\", (long)return_code);\n        }\n    }\n\n    OS_1739_Log(\"OS_MutSemCreate exit: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not substantiated by the supplied snippet. MISRA C 2023 Rule 8.13 concerns pointer declarations (a pointer should point to a const-qualified type whenever possible), not the mere act of taking the address of a local object. Whether there is a violation depends on the declaration/definition of OS_MutSemCreate_Impl: if that function is declared to take a non-const OS_object_token_t * and its implementation does not modify the pointed-to object, then the function\u2019s parameter should be const-qualified and the codebase would be nonconforming. However, nothing in the provided OS_MutSemCreate body shows the prototype or definition of OS_MutSemCreate_Impl or proves it does not modify the object. Therefore the claim as stated cannot be confirmed.\n\nTo determine correctness: inspect the prototype and definition of OS_MutSemCreate_Impl. If it is declared as OS_object_token_t * and the function does not (and need not) modify the token, change it to const OS_object_token_t * (and update any callers). If the implementation does modify the token (or must pass it to APIs that require a non-const pointer), a non-const parameter is justified and there is no Rule 8.13 violation. Note also that changing the parameter to const may be an API-breaking change and must be assessed across the codebase."
}