{
  "user_message": "An agent A claimed that the following OS_MutSemCreate code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemCreate.\n```c\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_MutSemCreate_Impl(&token, options);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro assigns the address of the object-name array (ref->namefield, type char[]) to the global object\u2019s name_entry pointer via OS_ObjectIdGlobalFromToken(&tok)->name_entry = ref->namefield. If name_entry is declared as a non-const char * (likely), it should instead be declared as const char * because the name is read-only (originating from const char *sem_name) and there is no need to modify it through that pointer. Declaring name_entry as const char * would satisfy MISRA C 2023 Rule 8.13 (a pointer should point to a const-qualified type whenever possible).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_MutSemCreate(osal_id_t *sem_id, const char *sem_name, uint32 options)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_mutex_internal_record_t *mutex;\n    FILE *logf = NULL;\n\n    /* Prepare log file directory and file. Do not alter function logic. */\n    (void)mkdir(\"/tmp/logs\", 0755); /* ignore error if directory exists */\n    logf = fopen(\"/tmp/logs/1739.txt\", \"a\");\n    if (logf)\n    {\n        fprintf(logf, \"--- OS_MutSemCreate ENTRY ---\\n\");\n        fprintf(logf, \"sem_id pointer: %p\\n\", (void *)sem_id);\n        fprintf(logf, \"sem_name pointer: %p\\n\", (const void *)sem_name);\n        if (sem_name)\n        {\n            /* Safe print of the provided name (if non-NULL) */\n            fprintf(logf, \"sem_name contents: \\\"%s\\\"\\n\", sem_name);\n        }\n        fprintf(logf, \"options: %u\\n\", (unsigned)options);\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sem_id);\n    OS_CHECK_APINAME(sem_name);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, sem_name, &token);\n    if (logf)\n    {\n        fprintf(logf, \"OS_ObjectIdAllocateNew returned: %d\\n\", (int)return_code);\n        fprintf(logf, \"token address: %p\\n\", (void *)&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        mutex = OS_OBJECT_TABLE_GET(OS_mutex_table, token);\n        if (logf)\n        {\n            fprintf(logf, \"OS_OBJECT_TABLE_GET -> mutex pointer: %p\\n\", (void *)mutex);\n        }\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, mutex, obj_name, sem_name);\n        if (logf)\n        {\n            /* We cannot safely assume the exact type of the stored name field here (char * vs const char *),\n             * but we can log that OS_OBJECT_INIT was invoked and the sem_name pointer used to initialize it.\n             * This will help reproduce the scenario where a non-const pointer might be assigned the address\n             * of a read-only name buffer. */\n            fprintf(logf, \"OS_OBJECT_INIT called with token: %p, mutex: %p, sem_name pointer: %p\\n\",\n                    (void *)&token, (void *)mutex, (const void *)sem_name);\n        }\n\n        /* Now call the OS-specific implementation.  This reads info from the table. */\n        return_code = OS_MutSemCreate_Impl(&token, options);\n        if (logf)\n        {\n            fprintf(logf, \"OS_MutSemCreate_Impl returned: %d\\n\", (int)return_code);\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, sem_id);\n        if (logf)\n        {\n            fprintf(logf, \"OS_ObjectIdFinalizeNew returned: %d\\n\", (int)return_code);\n            fprintf(logf, \"sem_id pointer after finalize: %p\\n\", (void *)sem_id);\n        }\n    }\n\n    if (logf)\n    {\n        fprintf(logf, \"--- OS_MutSemCreate EXIT: return_code=%d ---\\n\\n\", (int)return_code);\n        fclose(logf);\n    }\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f74\nsem_name pointer: 0x5629273c0abe\nsem_name contents: \"MutexSem 1\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -1\ntoken address: 0x7fff91915f10\n--- OS_MutSemCreate EXIT: return_code=-1 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f74\nsem_name pointer: 0x5629273c0abe\nsem_name contents: \"MutexSem 1\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f10\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f20\nsem_name pointer: 0x7fff91915f30\nsem_name contents: \"MUTSEM0\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915ef0\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f24\nsem_name pointer: 0x5629273c338a\nsem_name contents: \"DUPLICATE\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915ef0\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f20\nsem_name pointer: 0x5629273c3422\nsem_name contents: \"Good\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915ef0\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f74\nsem_name pointer: 0x5629273c34d0\nsem_name contents: \"DeleteTest\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f40\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f74\nsem_name pointer: 0x5629273c355e\nsem_name contents: \"GiveTest\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f40\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f74\nsem_name pointer: 0x5629273c3616\nsem_name contents: \"TakeTest\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f40\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f4c\nsem_name pointer: 0x5629273c3726\nsem_name contents: \"GetIDByName\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f10\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f5c\nsem_name pointer: 0x5629273c3810\nsem_name contents: \"InvalidPtr\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f20\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f5c\nsem_name pointer: 0x5629273c3873\nsem_name contents: \"GetInfo\"\noptions: 0\nOS_ObjectIdAllocateNew returned: -35\ntoken address: 0x7fff91915f20\n--- OS_MutSemCreate EXIT: return_code=-35 ---\n\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f20\nsem_name pointer: 0x7fff91915f50\nsem_name contents: \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\noptions: 0\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: 0x7fff91915f20\nsem_name pointer: (nil)\noptions: 0\n--- OS_MutSemCreate ENTRY ---\nsem_id pointer: (nil)\nsem_name pointer: 0x5629273c3204\nsem_name contents: \"MutSem1\"\noptions: 0\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 recommends that pointers point to const-qualified types when possible, but Agent A's scenario assumes an assignment of a const char * sem_name directly into a non-const char * field. The shown OS_MutSemCreate code calls OS_OBJECT_INIT to \u201creset the table entry and save the name\u201d; in typical implementations this macro copies the provided sem_name into an internal char[] obj_name buffer (i.e. writable storage) rather than storing the original const char * pointer. In that case the global name_entry would point at the internal char array (a mutable object), so the pointer type must be non-const (char *) and marking it const would be incorrect. Moreover, an implicit assignment from const char * to char * is not permitted by C (it would require an explicit cast), so the code as given would not silently perform the prohibited conversion claimed. The provided logs do not show any evidence of a direct const-to-non-const pointer assignment or a cast; they only show input pointers and return codes. Therefore there is no basis from the code or logs to conclude a Rule 8.13 violation."
}