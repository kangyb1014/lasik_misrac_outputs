{
  "user_message": "An agent A claimed that the following OS_FDGetInfo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FDGetInfo.\n```c\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(fd_prop->Path, record->name_entry, sizeof(fd_prop->Path) - 1);\n        }\n        fd_prop->User    = record->creator;\n        fd_prop->IsValid = true;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'record' is declared as OS_common_record_t *record but is only read from (record->creator, record->name_entry). According to MISRA C 2023 Rule 8.13 this pointer should point to a const-qualified type (i.e. declare it as const OS_common_record_t *record) since the function does not modify the object. The fd_prop parameter cannot be const because it is written to (memset/strncpy).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FDGetInfo_log(const char *fmt, ...)\n{\n    FILE *fp = NULL;\n    va_list ap;\n\n    /* Try to ensure the directory exists (best-effort, ignore return) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    fp = fopen(\"/tmp/logs/1275.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* If logging cannot be opened, do not affect program flow */\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Log entry and parameters */\n    OS_FDGetInfo_log(\"OS_FDGetInfo ENTRY: filedes=%lu, fd_prop=%p\", (unsigned long)filedes, (void *)fd_prop);\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    /* Log before clearing fd_prop */\n    OS_FDGetInfo_log(\"Zeroing fd_prop at %p (size=%zu)\", (void *)fd_prop, sizeof(OS_file_prop_t));\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    OS_FDGetInfo_log(\"Calling OS_ObjectIdGetById for filedes=%lu\", (unsigned long)filedes);\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    OS_FDGetInfo_log(\"OS_ObjectIdGetById returned %ld\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        /* Log record pointer and selected fields */\n        OS_FDGetInfo_log(\"Obtained record at %p\", (void *)record);\n        if (record != NULL)\n        {\n            /* Log creator value */\n            OS_FDGetInfo_log(\"record->creator=%lu\", (unsigned long)record->creator);\n\n            /* Log name_entry pointer and truncated contents if present */\n            if (record->name_entry != NULL)\n            {\n                char name_buf[256] = {0};\n                /* Copy a safe, truncated view for logging */\n                (void)strncpy(name_buf, record->name_entry, sizeof(name_buf) - 1);\n                OS_FDGetInfo_log(\"record->name_entry=%p contents='%s'\", (void *)record->name_entry, name_buf);\n\n                /* Preserve original behavior: copy path into fd_prop */\n                strncpy(fd_prop->Path, record->name_entry, sizeof(fd_prop->Path) - 1);\n                OS_FDGetInfo_log(\"Copied Path into fd_prop->Path='%s'\", fd_prop->Path);\n            }\n            else\n            {\n                OS_FDGetInfo_log(\"record->name_entry is NULL\");\n            }\n\n            fd_prop->User    = record->creator;\n            OS_FDGetInfo_log(\"Set fd_prop->User=%lu\", (unsigned long)fd_prop->User);\n\n            fd_prop->IsValid = true;\n            OS_FDGetInfo_log(\"Set fd_prop->IsValid=true\");\n        }\n        else\n        {\n            OS_FDGetInfo_log(\"record is NULL after OS_OBJECT_TABLE_GET\");\n        }\n\n        OS_ObjectIdRelease(&token);\n        OS_FDGetInfo_log(\"Released token\");\n    }\n\n    OS_FDGetInfo_log(\"OS_FDGetInfo EXIT: return_code=%ld\", (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FDGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The local variable record is only used to read fields (record->name_entry and record->creator) and is never used to modify the underlying object; per MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible. Declaring it as const OS_common_record_t *record expresses that intent and is a safe change here (assigning the non-const return of OS_OBJECT_TABLE_GET to a pointer-to-const is allowed). The fd_prop parameter cannot be const because it is written to, so the only applicable change is to make record point to a const-qualified type."
}