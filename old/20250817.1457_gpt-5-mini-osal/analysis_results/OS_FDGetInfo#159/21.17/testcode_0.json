{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nAlthough the call uses sizeof(fd_prop->Path) - 1 which prevents writing past the destination (the destination was also zeroed earlier), the code does not ensure that the source object (record->name_entry) has at least that many accessible bytes or contains a NUL within that bound. If record->name_entry points to a shorter/non-NUL-terminated buffer, strncpy may read beyond the bounds of the source object. Therefore the use of strncpy here can result in out-of-bounds access of the source and violates Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FDGetInfo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1279.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FDGetInfo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FDGetInfo:\n```c\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(fd_prop->Path, record->name_entry, sizeof(fd_prop->Path) - 1);\n        }\n        fd_prop->User    = record->creator;\n        fd_prop->IsValid = true;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_FDGetInfo code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n/* Probe logging helper - appends lines to /tmp/logs/1279.txt */\nstatic void OS_LogProbe(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1279.txt\", \"a\");\n    if (!fp)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    OS_LogProbe(\"OS_FDGetInfo: entry - filedes=%d, fd_prop=%p\", (int)filedes, (void *)fd_prop);\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n    OS_LogProbe(\"OS_FDGetInfo: fd_prop zeroed (size=%zu)\", sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    OS_LogProbe(\"OS_FDGetInfo: OS_ObjectIdGetById returned %d\", return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n        OS_LogProbe(\"OS_FDGetInfo: record obtained: record=%p\", (void *)record);\n\n        if (record != NULL)\n        {\n            /* Log the name_entry pointer but do NOT dereference it - reading it may be unsafe */\n            OS_LogProbe(\"OS_FDGetInfo: record->name_entry pointer=%p\", (void *)record->name_entry);\n\n            if (record->name_entry != NULL)\n            {\n                size_t copy_len = sizeof(fd_prop->Path) - 1;\n                OS_LogProbe(\"OS_FDGetInfo: about to strncpy dest=%p, src=%p, len=%zu\",\n                            (void *)fd_prop->Path, (void *)record->name_entry, copy_len);\n\n                /* Original semantics preserved - potential source over-read exists here in some scenarios */\n                strncpy(fd_prop->Path, record->name_entry, copy_len);\n\n                /* Because fd_prop was zeroed above, printing it as a C-string is safe (it will be NUL-terminated)\n                   even if record->name_entry did not contain a NUL within copy_len \u2014 the previous memset\n                   guarantees a terminating NUL within fd_prop->Path's bounds. */\n                OS_LogProbe(\"OS_FDGetInfo: fd_prop->Path after strncpy: '%s'\", fd_prop->Path);\n            }\n            else\n            {\n                OS_LogProbe(\"OS_FDGetInfo: record->name_entry is NULL; no strncpy performed\");\n            }\n\n            /* Log creator; cast to unsigned long long to avoid format issues if type varies */\n            OS_LogProbe(\"OS_FDGetInfo: record->creator=%llu\", (unsigned long long)record->creator);\n\n            fd_prop->User    = record->creator;\n            fd_prop->IsValid = true;\n\n            OS_LogProbe(\"OS_FDGetInfo: fd_prop->User set and IsValid=true\");\n\n            OS_ObjectIdRelease(&token);\n            OS_LogProbe(\"OS_FDGetInfo: token released\");\n        }\n        else\n        {\n            OS_LogProbe(\"OS_FDGetInfo: record retrieved was NULL\");\n            /* If record is NULL, maintain original behavior: do not dereference */\n            OS_ObjectIdRelease(&token);\n            OS_LogProbe(\"OS_FDGetInfo: token released after NULL record\");\n        }\n    }\n\n    OS_LogProbe(\"OS_FDGetInfo: exit - return_code=%d\", return_code);\n    return return_code;\n}\n"
}