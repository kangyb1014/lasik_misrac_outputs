{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CloseAllFiles:\n```c\nint32 OS_CloseAllFiles(void)\n{\n    int32            return_code;\n    int32            close_code;\n    OS_object_iter_t iter;\n\n    return_code = OS_SUCCESS;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        /* call OS_close() on the entry referred to by the iterator */\n        close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n        if (close_code != OS_SUCCESS)\n        {\n            return_code = close_code;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nclose_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call passes a pointer to an iterator object (&iter) to OS_ObjectIdIteratorProcessEntry. If that function legitimately modifies the iterator state (advancing it, marking entries processed, etc.) then the pointer must be non\u2011const and there is no MISRA 8.13 violation. A violation would only occur if the prototype of OS_ObjectIdIteratorProcessEntry takes a non\u2011const OS_object_iter_t * but does not modify the iterator; in that case the parameter should be changed to const OS_object_iter_t * and the current non\u2011const use would breach Rule 8.13."
}