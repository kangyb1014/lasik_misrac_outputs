{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CloseAllFiles:\n```c\nint32 OS_CloseAllFiles(void)\n{\n    int32            return_code;\n    int32            close_code;\n    OS_object_iter_t iter;\n\n    return_code = OS_SUCCESS;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        /* call OS_close() on the entry referred to by the iterator */\n        close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n        if (close_code != OS_SUCCESS)\n        {\n            return_code = close_code;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CloseAllFiles:\nint32 OS_FileIteratorClose(osal_id_t filedes, void *arg)\n{\n    return OS_close(filedes);\n}\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n...\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t objtype,\n                              OS_object_iter_t *iter)\n{\n    iter->match = matchfunc;\n    iter->arg   = matcharg;\n    iter->limit = OS_GetMaxForObjectType(objtype);\n    iter->base  = &OS_common_table[OS_GetBaseForObjectType(objtype)];\n\n    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &iter->token);\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\nvoid OS_ObjectIdTransactionCancel(OS_object_token_t *token)\n{\n    if (token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        OS_Unlock_Global(token);\n        token->lock_mode = OS_LOCK_MODE_NONE;\n    }\n}\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n...\nvoid OS_Lock_Global(OS_object_token_t *token)\n{\n    osal_id_t           self_task_id;\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype      = &OS_objtype_state[token->obj_type];\n        self_task_id = OS_TaskGetId_Impl();\n\n        OS_Lock_Global_Impl(token->obj_type);\n\n        /*\n         * Track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done after successfully locking, so this has exclusive access\n         * to the state object.\n         */\n        if (!OS_ObjectIdIsValid(self_task_id))\n        {\n            /*\n             * This just means the calling context is not an OSAL-created task.\n             * This is not necessarily an error, but it should be tracked.\n             * Also note that the root/initial task also does not have an ID.\n             */\n            self_task_id = OS_OBJECT_ID_RESERVED; /* nonzero, but also won't alias a known task */\n        }\n\n        /*\n         * The key value is computed with fixed/nonzero flag bits combined\n         * with the lower 24 bits of the task ID xor'ed with transaction id.\n         * This makes it different for every operation, and different depending\n         * on what task is calling the function.\n         */\n        token->lock_key.key_value =\n            OS_LOCK_KEY_FIXED_VALUE | ((OS_ObjectIdToInteger(self_task_id) ^ objtype->transaction_count) & 0xFFFFFF);\n\n        ++objtype->transaction_count;\n\n        if (objtype->owner_key.key_value != 0)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u acquired by task 0x%lx when already assigned key 0x%lx\\n\",\n                     (unsigned int)token->obj_type, OS_ObjectIdToInteger(self_task_id),\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n        else\n        {\n            objtype->owner_key = token->lock_key;\n        }\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot lock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n...\nvoid OS_Unlock_Global(OS_object_token_t *token)\n{\n    OS_objtype_state_t *objtype;\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        objtype = &OS_objtype_state[token->obj_type];\n\n        /*\n         * Un-track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done before unlocking, while this has exclusive access\n         * to the state object.\n         */\n        if ((objtype->owner_key.key_value & 0xFF000000) != OS_LOCK_KEY_FIXED_VALUE ||\n            objtype->owner_key.key_value != token->lock_key.key_value)\n        {\n            /* this is almost certainly a bug */\n            OS_DEBUG(\"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\\n\",\n                     (unsigned int)token->obj_type, (unsigned long)token->lock_key.key_value,\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n\n        objtype->owner_key = OS_LOCK_KEY_INVALID;\n        token->lock_key    = OS_LOCK_KEY_INVALID;\n\n        OS_Unlock_Global_Impl(token->obj_type);\n    }\n    else\n    {\n        OS_DEBUG(\"ERROR: cannot unlock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n...\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_close(osal_id_t filedes)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_GenericClose_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_FDGetInfo(osal_id_t filedes, OS_file_prop_t *fd_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(fd_prop);\n\n    memset(fd_prop, 0, sizeof(OS_file_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, filedes, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        if (record->name_entry != NULL)\n        {\n            strncpy(fd_prop->Path, record->name_entry, sizeof(fd_prop->Path) - 1);\n        }\n        fd_prop->User    = record->creator;\n        fd_prop->IsValid = true;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n...\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n...\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nVirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: OS_strnlen is called with the object pointer and sizeof(filesys->virtual_mountpt), which bounds the read to the storage size of virtual_mountpt and prevents out-of-bounds access assuming virtual_mountpt is an array member of the struct. (A potential violation would occur if virtual_mountpt were actually a char * \u2014 then sizeof(filesys->virtual_mountpt) would yield the pointer size, not the buffer size, and strnlen could read beyond the actual buffer.)"
}