{
  "user_message": "An agent A claimed that the following OS_QueueGet_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGet_Impl.\n```c\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable impl is declared as OS_impl_queue_internal_record_t *impl but is only used for read access (impl->id) in this function. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible, so it should be declared as const OS_impl_queue_internal_record_t *impl (or equivalent). As written, the non-const pointer usage (impl->id) constitutes a violation because the pointee is not modified and could be const-qualified.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueueGet_LogProbe(const char *stage,\n                                 const void *token_ptr,\n                                 const void *impl_ptr,\n                                 int timeout,\n                                 ssize_t sizeCopied,\n                                 int return_code,\n                                 size_t size_copied_val)\n{\n    int saved_errno = errno;\n    FILE *f = fopen(\"/tmp/logs/435.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Try to avoid any complex formatting that can depend on unavailable types. */\n        fprintf(f, \"Stage=%s, token=%p, impl=%p\", stage, token_ptr, impl_ptr);\n        if (impl_ptr != NULL)\n        {\n            /* Attempt to print impl->id if possible; cast to long long to be generic. */\n            /* Note: this relies on the caller passing impl pointer which points to a struct\n             * that contains an 'id' member. If compiled in the same translation unit as the\n             * original code, this will match. If not, it will simply not attempt to access it.\n             */\n            /* We don't dereference impl_ptr here to avoid any type assumptions in this helper. */\n        }\n        fprintf(f, \", timeout=%d, sizeCopied=%lld, errno=%d (%s)\", timeout, (long long)sizeCopied, saved_errno, strerror(saved_errno));\n        if (return_code != 0)\n        {\n            fprintf(f, \", return_code=%d\", return_code);\n        }\n        fprintf(f, \", size_copied=%zu\\n\", size_copied_val);\n        fclose(f);\n    }\n    errno = saved_errno;\n}\n\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /* Log the pointer returned by the object table lookup. This captures the fact that\n     * 'impl' is only read from below (impl->id is used) which is the subject of the\n     * Rule 8.13 discussion. */\n    OS_QueueGet_LogProbe(\"after_lookup\", token, impl, timeout, -1, 0, 0);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            /* Log before attempting mq_receive so the control flow is visible */\n            OS_QueueGet_LogProbe(\"before_mq_receive_pend\", token, impl, timeout, sizeCopied, 0, 0);\n\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n\n            /* Log after mq_receive to record the result and errno */\n            OS_QueueGet_LogProbe(\"after_mq_receive_pend\", token, impl, timeout, sizeCopied, 0, 0);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            /* Log before timed receive */\n            OS_QueueGet_LogProbe(\"before_mq_timedreceive\", token, impl, timeout, sizeCopied, 0, 0);\n\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n\n            /* Log after timed receive */\n            OS_QueueGet_LogProbe(\"after_mq_timedreceive\", token, impl, timeout, sizeCopied, 0, 0);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    /* Final log with the evaluated return code and size_copied */\n    OS_QueueGet_LogProbe(\"before_return\", token, impl, timeout, sizeCopied, (int)return_code, *size_copied);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueueGet_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_QueueGet_Impl the local variable impl is only read (impl->id is accessed) and never used to modify the underlying object, so per MISRA C 2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. const OS_impl_queue_internal_record_t *impl). Making it const documents the intent and prevents accidental modification through this pointer. The only caveat is if OS_OBJECT_TABLE_GET or other APIs require a non-const lvalue (or the code later modified the object through this pointer), but in the shown function there is no such modification, so changing the declaration to a pointer-to-const is appropriate and would remove the rule violation."
}