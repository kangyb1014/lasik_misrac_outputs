{
  "user_message": "An agent A claimed that the following OS_QueueGet_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGet_Impl.\n```c\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code assigns the result of OS_OBJECT_TABLE_GET(...) to a non-const pointer (impl) even though the function only reads from the record (uses impl->id) and does not modify the object. According to MISRA C 2023 Rule 8.13, impl should be declared as a pointer-to-const (e.g. const OS_impl_queue_internal_record_t *impl) when possible. Thus this use of a non-const pointer is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueueGet_Impl_log(const char *stage,\n                                 const void *token_ptr,\n                                 unsigned long long token_val,\n                                 void *impl_ptr,\n                                 unsigned long long impl_id_val,\n                                 size_t size,\n                                 int32_t timeout,\n                                 ssize_t sizeCopied,\n                                 int saved_errno,\n                                 int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/435.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t now = time(NULL);\n        fprintf(f, \"[%ld] stage=%s token_ptr=%p token_val=%llu impl_ptr=%p impl_id=%llu size=%zu timeout=%d sizeCopied=%zd errno=%d return_code=%d\\n\",\n                (long)now,\n                stage,\n                token_ptr,\n                token_val,\n                impl_ptr,\n                impl_id_val,\n                size,\n                (int)timeout,\n                sizeCopied,\n                saved_errno,\n                return_code);\n        if (saved_errno != 0)\n        {\n            fprintf(f, \"  errno_str=%s\\n\", strerror(saved_errno));\n        }\n        fclose(f);\n    }\n}\n\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    /* Log entry */\n    /* Note: cast the token pointer itself to an integer for logging instead of dereferencing it\n     * to avoid treating an aggregate value as an integer. */\n    OS_QueueGet_Impl_log(\"enter\", token, (unsigned long long)(uintptr_t)token, NULL, 0ULL, size, timeout, -1, 0, -1);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /* Log after lookup of impl */\n    OS_QueueGet_Impl_log(\"after_lookup\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, -1, 0, -1);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            int saved_errno_before = errno;\n            OS_QueueGet_Impl_log(\"before_mq_receive\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_before, -1);\n\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n\n            int saved_errno_after = errno;\n            OS_QueueGet_Impl_log(\"after_mq_receive\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_after, -1);\n\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            int saved_errno_before = errno;\n            OS_QueueGet_Impl_log(\"before_mq_timedreceive\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_before, -1);\n\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n\n            int saved_errno_after = errno;\n            OS_QueueGet_Impl_log(\"after_mq_timedreceive\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_after, -1);\n\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n\n        /* Log the error path with the chosen return code and errno */\n        OS_QueueGet_Impl_log(\"error_path\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, errno, return_code);\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n\n        /* Log the success path */\n        OS_QueueGet_Impl_log(\"success_path\", token, (unsigned long long)(uintptr_t)token, (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, 0, return_code);\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueueGet_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_QueueGet_Impl the variable impl is only used for read-only access (impl->id is read; there are no writes through impl). MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types whenever possible \u2014 here impl can and should be declared as const OS_impl_queue_internal_record_t *impl to reflect read-only usage and prevent accidental modification. Assigning the result of OS_OBJECT_TABLE_GET(...) (a non-const pointer) to a pointer-to-const is allowed, so changing the local declaration to a pointer-to-const is feasible. (Only if some other operation in this function required modifying the record or if external APIs required a non-const pointer would this not apply.)"
}