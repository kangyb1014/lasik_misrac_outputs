{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe pointer 'impl' is declared as a mutable pointer (OS_impl_queue_internal_record_t *impl) but in this function it is only used for read access (e.g. impl->id) and the pointed object is not modified. Therefore the pointer could be declared as pointing to a const-qualified type (const OS_impl_queue_internal_record_t *impl). Because the pointer is not const-qualified even though it could be, this violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_QueueGet_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/435.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_QueueGet_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_QueueGet_Impl:\n```c\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_QueueGet_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/* Probe logging helper - appends human-readable logs to /tmp/logs/435.txt */\nstatic void os_queue_get_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/435.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    os_queue_get_log(\"OS_QueueGet_Impl ENTRY: token=%p, data=%p, size=%zu, timeout=%d\", (const void *)token, data, size, (int)timeout);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    os_queue_get_log(\"Resolved impl: %p (impl->id=%ld)\", (void *)impl, (long)impl->id);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        os_queue_get_log(\"Branch: OS_PEND - using mq_receive loop\");\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            os_queue_get_log(\"Calling mq_receive: impl->id=%ld, buffer=%p, size=%zu\", (long)impl->id, data, size);\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n            os_queue_get_log(\"mq_receive returned: sizeCopied=%zd, errno=%d (%s)\", sizeCopied, errno, strerror(errno));\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        os_queue_get_log(\"Branch: timeout != OS_PEND (timeout=%d)\", (int)timeout);\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n            os_queue_get_log(\"Timeout is OS_CHECK - using zeroed ts\");\n        }\n        else\n        {\n            os_queue_get_log(\"Computing absolute delay time for timeout=%d\", (int)timeout);\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n            os_queue_get_log(\"Computed ts: tv_sec=%ld, tv_nsec=%ld\", (long)ts.tv_sec, (long)ts.tv_nsec);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            os_queue_get_log(\"Calling mq_timedreceive: impl->id=%ld, buffer=%p, size=%zu, timeout=%s\", (long)impl->id, data, size, (timeout == OS_CHECK) ? \"OS_CHECK\" : \"TIMED\");\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n            os_queue_get_log(\"mq_timedreceive returned: sizeCopied=%zd, errno=%d (%s)\", sizeCopied, errno, strerror(errno));\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n        os_queue_get_log(\"No data received (sizeCopied == -1). errno=%d (%s)\", errno, strerror(errno));\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n            os_queue_get_log(\"Mapped errno EMSGSIZE -> OS_QUEUE_INVALID_SIZE\");\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n            os_queue_get_log(\"Mapped error -> OS_ERROR (timeout=%d, errno=%d)\", (int)timeout, errno);\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n            os_queue_get_log(\"Mapped timeout OS_CHECK -> OS_QUEUE_EMPTY\");\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n            os_queue_get_log(\"Mapped timeout -> OS_QUEUE_TIMEOUT\");\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n        os_queue_get_log(\"Data received: sizeCopied=%zd -> *size_copied=%zu, return_code=OS_SUCCESS\", sizeCopied, (size_t)*size_copied);\n    }\n\n    os_queue_get_log(\"OS_QueueGet_Impl EXIT: return_code=%d, *size_copied=%zu\", (int)return_code, (size_t)*size_copied);\n\n    return return_code;\n}\n"
}