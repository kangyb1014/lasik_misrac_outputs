{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe code assigns the result of OS_OBJECT_TABLE_GET(...) to a non-const pointer (impl) even though the function only reads from the record (uses impl->id) and does not modify the object. According to MISRA C 2023 Rule 8.13, impl should be declared as a pointer-to-const (e.g. const OS_impl_queue_internal_record_t *impl) when possible. Thus this use of a non-const pointer is a violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_QueueGet_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/435.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_QueueGet_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_QueueGet_Impl:\n```c\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_QueueGet_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n\n/* Probe logging helper. Appends human-readable control-flow and state info to /tmp/logs/435.txt */\nstatic void OS_QueueGet_Impl_log(const char *stage,\n                                 const void *token_ptr,\n                                 unsigned long long token_val,\n                                 void *impl_ptr,\n                                 unsigned long long impl_id_val,\n                                 size_t size,\n                                 int32_t timeout,\n                                 ssize_t sizeCopied,\n                                 int saved_errno,\n                                 int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/435.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t now = time(NULL);\n        fprintf(f, \"[%ld] stage=%s token_ptr=%p token_val=%llu impl_ptr=%p impl_id=%llu size=%zu timeout=%d sizeCopied=%zd errno=%d return_code=%d\\n\",\n                (long)now,\n                stage,\n                token_ptr,\n                token_val,\n                impl_ptr,\n                impl_id_val,\n                size,\n                (int)timeout,\n                sizeCopied,\n                saved_errno,\n                return_code);\n        if (saved_errno != 0)\n        {\n            fprintf(f, \"  errno_str=%s\\n\", strerror(saved_errno));\n        }\n        fclose(f);\n    }\n}\n\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    /* Log entry */\n    OS_QueueGet_Impl_log(\"enter\", token, (unsigned long long)(uintptr_t)(*token), NULL, 0ULL, size, timeout, -1, 0, -1);\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /* Log after lookup of impl */\n    OS_QueueGet_Impl_log(\"after_lookup\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, -1, 0, -1);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            int saved_errno_before = errno;\n            OS_QueueGet_Impl_log(\"before_mq_receive\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_before, -1);\n\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n\n            int saved_errno_after = errno;\n            OS_QueueGet_Impl_log(\"after_mq_receive\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_after, -1);\n\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            int saved_errno_before = errno;\n            OS_QueueGet_Impl_log(\"before_mq_timedreceive\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_before, -1);\n\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n\n            int saved_errno_after = errno;\n            OS_QueueGet_Impl_log(\"after_mq_timedreceive\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, saved_errno_after, -1);\n\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n\n        /* Log the error path with the chosen return code and errno */\n        OS_QueueGet_Impl_log(\"error_path\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, errno, return_code);\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n\n        /* Log the success path */\n        OS_QueueGet_Impl_log(\"success_path\", token, (unsigned long long)(uintptr_t)(*token), (void *)impl, (unsigned long long)(uintptr_t)(impl ? impl->id : 0ULL), size, timeout, sizeCopied, 0, return_code);\n    }\n\n    return return_code;\n}\n"
}