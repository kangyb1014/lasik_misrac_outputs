{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable impl is declared as OS_impl_queue_internal_record_t *impl but is only used for read access (impl->id) in this function. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible, so it should be declared as const OS_impl_queue_internal_record_t *impl (or equivalent). As written, the non-const pointer usage (impl->id) constitutes a violation because the pointee is not modified and could be const-qualified.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_QueueGet_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/435.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_QueueGet_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_QueueGet_Impl:\n```c\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_QueueGet_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <time.h>\n#include <stddef.h>\n\n/* Probe helper: write a log line to /tmp/logs/435.txt.  This preserves errno. */\nstatic void OS_QueueGet_LogProbe(const char *stage,\n                                 const void *token_ptr,\n                                 const void *impl_ptr,\n                                 int timeout,\n                                 ssize_t sizeCopied,\n                                 int return_code,\n                                 size_t size_copied_val)\n{\n    int saved_errno = errno;\n    FILE *f = fopen(\"/tmp/logs/435.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Try to avoid any complex formatting that can depend on unavailable types. */\n        fprintf(f, \"Stage=%s, token=%p, impl=%p\", stage, token_ptr, impl_ptr);\n        if (impl_ptr != NULL)\n        {\n            /* Attempt to print impl->id if possible; cast to long long to be generic. */\n            /* Note: this relies on the caller passing impl pointer which points to a struct\n             * that contains an 'id' member. If compiled in the same translation unit as the\n             * original code, this will match. If not, it will simply not attempt to access it.\n             */\n            /* We don't dereference impl_ptr here to avoid any type assumptions in this helper. */\n        }\n        fprintf(f, \", timeout=%d, sizeCopied=%lld, errno=%d (%s)\", timeout, (long long)sizeCopied, saved_errno, strerror(saved_errno));\n        if (return_code != 0)\n        {\n            fprintf(f, \", return_code=%d\", return_code);\n        }\n        fprintf(f, \", size_copied=%zu\\n\", size_copied_val);\n        fclose(f);\n    }\n    errno = saved_errno;\n}\n\nint32 OS_QueueGet_Impl(const OS_object_token_t *token, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    int32                            return_code;\n    ssize_t                          sizeCopied;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /* Log the pointer returned by the object table lookup. This captures the fact that\n     * 'impl' is only read from below (impl->id is used) which is the subject of the\n     * Rule 8.13 discussion. */\n    OS_QueueGet_LogProbe(\"after_lookup\", token, impl, timeout, -1, 0, 0);\n\n    /*\n     ** Read the message queue for data\n     */\n    sizeCopied = -1;\n    if (timeout == OS_PEND)\n    {\n        /*\n         ** A signal can interrupt the mq_receive call, so the call has to be done with\n         ** a loop\n         */\n        do\n        {\n            /* Log before attempting mq_receive so the control flow is visible */\n            OS_QueueGet_LogProbe(\"before_mq_receive_pend\", token, impl, timeout, sizeCopied, 0, 0);\n\n            sizeCopied = mq_receive(impl->id, data, size, NULL);\n\n            /* Log after mq_receive to record the result and errno */\n            OS_QueueGet_LogProbe(\"after_mq_receive_pend\", token, impl, timeout, sizeCopied, 0, 0);\n        } while (sizeCopied < 0 && errno == EINTR);\n    }\n    else\n    {\n        /*\n         * NOTE - a prior implementation of OS_CHECK would check the mq_attr for a nonzero depth\n         * and then call mq_receive().  This is insufficient since another thread might do the same\n         * thing at the same time in which case one thread will read and the other will block.\n         *\n         * Calling mq_timedreceive with a zero timeout effectively does the same thing in the typical\n         * case, but for the case where two threads do a simultaneous read, one will get the message\n         * while the other will NOT block (as expected).\n         */\n        if (timeout == OS_CHECK)\n        {\n            memset(&ts, 0, sizeof(ts));\n        }\n        else\n        {\n            OS_Posix_CompAbsDelayTime(timeout, &ts);\n        }\n\n        /*\n         ** If the mq_timedreceive call is interrupted by a system call or signal,\n         ** call it again.\n         */\n        do\n        {\n            /* Log before timed receive */\n            OS_QueueGet_LogProbe(\"before_mq_timedreceive\", token, impl, timeout, sizeCopied, 0, 0);\n\n            sizeCopied = mq_timedreceive(impl->id, data, size, NULL, &ts);\n\n            /* Log after timed receive */\n            OS_QueueGet_LogProbe(\"after_mq_timedreceive\", token, impl, timeout, sizeCopied, 0, 0);\n        } while (timeout != OS_CHECK && sizeCopied < 0 && errno == EINTR);\n\n    } /* END timeout */\n\n    /* Figure out the return code */\n    if (sizeCopied == -1)\n    {\n        *size_copied = OSAL_SIZE_C(0);\n\n        /* Map the system errno to the most appropriate OSAL return code */\n        if (errno == EMSGSIZE)\n        {\n            return_code = OS_QUEUE_INVALID_SIZE;\n        }\n        else if (timeout == OS_PEND || errno != ETIMEDOUT)\n        {\n            /* OS_PEND was supposed to pend forever until a message arrived\n             * so something else is wrong.  Otherwise, at this point the only\n             * \"acceptable\" errno is TIMEDOUT for the other cases.\n             */\n            return_code = OS_ERROR;\n        }\n        else if (timeout == OS_CHECK)\n        {\n            return_code = OS_QUEUE_EMPTY;\n        }\n        else\n        {\n            return_code = OS_QUEUE_TIMEOUT;\n        }\n    }\n    else\n    {\n        *size_copied = OSAL_SIZE_C(sizeCopied);\n        return_code  = OS_SUCCESS;\n    }\n\n    /* Final log with the evaluated return code and size_copied */\n    OS_QueueGet_LogProbe(\"before_return\", token, impl, timeout, sizeCopied, (int)return_code, *size_copied);\n\n    return return_code;\n}\n"
}