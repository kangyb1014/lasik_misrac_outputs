{
  "user_message": "An agent A claimed that the following OS_TaskCreate code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskCreate.\n```c\nint32 OS_TaskCreate(osal_id_t *task_id, const char *task_name, osal_task_entry function_pointer,\n                    osal_stackptr_t stack_pointer, size_t stack_size, osal_priority_t priority, uint32 flags)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /*\n     * Check parameters\n     *\n     * Note \"stack_pointer\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(function_pointer);\n    OS_CHECK_APINAME(task_name);\n    OS_CHECK_SIZE(stack_size);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, task_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, task, task_name, task_name);\n\n        task->stack_size             = stack_size;\n        task->priority               = priority;\n        task->entry_function_pointer = function_pointer;\n        task->stack_pointer          = stack_pointer;\n\n        /* Add default flags */\n        flags |= OS_ADD_TASK_FLAGS;\n\n        /* Now call the OS-specific implementation.  This reads info from the task table. */\n        return_code = OS_TaskCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, task_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro OS_CHECK_APINAME(task_name) expands to OS_CHECK_STRING(...). If that macro invokes unbounded string.h functions (e.g. strlen, strcpy, strcat) on the task_name pointer, a read beyond the object bounds can occur. Example violation: the caller supplies a non-NULL pointer to a character buffer that is not NUL-terminated within its allocated size (or not NUL-terminated within OS_MAX_API_NAME bytes). A call to strlen(task_name) (or another unbounded string function) will then read past the buffer boundary, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TaskCreate_Log(const char *phase, const char *task_name, int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/2031.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log basic control-phase, pointer value and return code. */\n    uintptr_t addr = (uintptr_t)task_name;\n    fprintf(f, \"OS_TaskCreate: %s\\n\", phase);\n    fprintf(f, \"  task_name_ptr = %p (0x%\" PRIXPTR \")\\n\", (void *)addr, (uintptr_t)addr);\n    fprintf(f, \"  return_code   = %ld\\n\", (long)return_code);\n\n    /* Log first byte (if readable); avoid calling any unbounded string functions. */\n    if (task_name != NULL)\n    {\n        unsigned char first = (unsigned char)task_name[0];\n        if (first >= 32 && first < 127)\n        {\n            fprintf(f, \"  task_name[0]  = '%c' (0x%02X)\\n\", (char)first, first);\n        }\n        else\n        {\n            fprintf(f, \"  task_name[0]  = 0x%02X\\n\", first);\n        }\n    }\n    else\n    {\n        fprintf(f, \"  task_name is NULL\\n\");\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_TaskCreate(osal_id_t *task_id, const char *task_name, osal_task_entry function_pointer,\n                    osal_stackptr_t stack_pointer, size_t stack_size, osal_priority_t priority, uint32 flags)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n\n    /* Log entry and initial parameter state. */\n    OS_TaskCreate_Log(\"ENTER\", task_name, -1);\n\n    /*\n     * Check parameters\n     *\n     * Note \"stack_pointer\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(task_id);\n    OS_CHECK_POINTER(function_pointer);\n\n    /* Log before name checks (this is where the reported violation scenario may originate). */\n    OS_TaskCreate_Log(\"BEFORE_OS_CHECK_APINAME\", task_name, -1);\n\n    OS_CHECK_APINAME(task_name);\n\n    /* Log after name checks so callers can see that the macro was invoked. */\n    OS_TaskCreate_Log(\"AFTER_OS_CHECK_APINAME\", task_name, -1);\n\n    OS_CHECK_SIZE(stack_size);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, task_name, &token);\n\n    /* Log the result of ObjectIdAllocateNew and token address for tracing. */\n    OS_TaskCreate_Log(\"AFTER_ObjectIdAllocateNew\", task_name, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, task, task_name, task_name);\n\n        /* Log after object init and before filling task fields. */\n        OS_TaskCreate_Log(\"AFTER_OS_OBJECT_INIT\", task_name, return_code);\n\n        task->stack_size             = stack_size;\n        task->priority               = priority;\n        task->entry_function_pointer = function_pointer;\n        task->stack_pointer          = stack_pointer;\n\n        /* Add default flags */\n        flags |= OS_ADD_TASK_FLAGS;\n\n        /* Now call the OS-specific implementation.  This reads info from the task table. */\n        return_code = OS_TaskCreate_Impl(&token, flags);\n\n        /* Log after OS-specific implementation returned. */\n        OS_TaskCreate_Log(\"AFTER_OS_TaskCreate_Impl\", task_name, return_code);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, task_id);\n\n        /* Final log before returning. */\n        OS_TaskCreate_Log(\"BEFORE_RETURN\", task_name, return_code);\n    }\n    else\n    {\n        /* Log early failure path. */\n        OS_TaskCreate_Log(\"ALLOCATE_FAILED\", task_name, return_code);\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is plausible but not proven by the code shown. The OS_TaskCreate function itself does not call any <string.h> functions; the only place a string operation might occur is inside the OS_CHECK_APINAME macro (or other called routines such as OS_ObjectIdAllocateNew or OS_OBJECT_INIT). MISRA C 2023 Rule 21.17 would be violated only if one of those macros/functions invokes an unbounded string handling routine (e.g. strlen, strcpy, strcat) on task_name without guaranteeing a terminating NUL within the accessible object bounds (or without bounding the scan with a maximum length such as OS_MAX_API_NAME). Because the snippet does not show the expansion/implementation of OS_CHECK_APINAME or the other helpers, you cannot conclude a violation from this snippet alone.\n\nTherefore:\n- If OS_CHECK_APINAME (or later callers) uses unbounded functions on task_name (strlen, strcpy, etc.) without first ensuring a valid NUL-terminated buffer or applying length bounds (e.g. using strnlen/strncpy/memcpy with an explicit maximum), then Agent A\u2019s scenario is correct and Rule 21.17 would be breached.\n- If OS_CHECK_APINAME and the other routines use bounded variants (strnlen with OS_MAX_API_NAME, or otherwise ensure the buffer is NUL-terminated and length-checked before any unbounded operation), then there is no Rule 21.17 violation.\n\nRecommendation: Inspect the definitions of OS_CHECK_APINAME, OS_CHECK_STRING (if present), OS_ObjectIdAllocateNew, OS_OBJECT_INIT and any string-copy/scan operations. Ensure they either (a) validate NUL-termination within a known max length before calling unbounded functions, or (b) use bounded string routines (strnlen, memcpy/strncpy with documented maxima)."
}