{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\ntypedef struct\n{\n    uint32_t key_value;\n} OS_lock_key_t;\ntypedef struct\n{\n    unsigned int obj_type;\n    unsigned int lock_mode;\n    OS_lock_key_t lock_key;\n} OS_object_token_t;\nconst OS_lock_key_t OS_LOCK_KEY_INVALID = { 0U };\nvoid OS_Unlock_Global_Impl(unsigned int obj_type)\n{\n    /* preserve original behaviour: do nothing here for the test stub */\n    (void)obj_type;\n}\nvoid OS_DEBUG(const char *fmt, ...) { (void)fmt; }\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1658.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm *tm = localtime(&t);\n    if (tm != NULL)\n    {\n        fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \", tm->tm_year + 1900, tm->tm_mon + 1,\n                tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid OS_Unlock_Global(OS_object_token_t *token)\n{\n    OS_objtype_state_t *objtype;\n\n    /* Log entry and token basic state */\n    if (token == NULL)\n    {\n        probe_log(\"OS_Unlock_Global: token is NULL\");\n        return;\n    }\n\n    probe_log(\"OS_Unlock_Global: entry obj_type=%u lock_mode=%u lock_key=0x%08lx\",\n              (unsigned int)token->obj_type, (unsigned int)token->lock_mode,\n              (unsigned long)token->lock_key.key_value);\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        probe_log(\"OS_Unlock_Global: condition true (obj_type < OS_OBJECT_TYPE_USER && lock_mode != NONE)\");\n\n        objtype = &OS_objtype_state[token->obj_type];\n\n        /*\n         * Un-track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done before unlocking, while this has exclusive access\n         * to the state object.\n         */\n        if ((objtype->owner_key.key_value & 0xFF000000) != OS_LOCK_KEY_FIXED_VALUE ||\n            objtype->owner_key.key_value != token->lock_key.key_value)\n        {\n            /* this is almost certainly a bug */\n            /* Probe log before the (empty) OS_DEBUG to capture state */\n            probe_log(\"MISMATCHED KEY: global=%u released using mismatched key=0x%lx expected=0x%lx\",\n                      (unsigned int)token->obj_type,\n                      (unsigned long)token->lock_key.key_value,\n                      (unsigned long)objtype->owner_key.key_value);\n\n            /* Call OS_DEBUG as in original code (here it is an empty stub) */\n            OS_DEBUG(\"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\\n\",\n                     (unsigned int)token->obj_type, (unsigned long)token->lock_key.key_value,\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n\n        /* Log the state just before clearing ownership */\n        probe_log(\"Clearing ownership: obj_type=%u old_owner=0x%lx old_token_key=0x%lx\",\n                  (unsigned int)token->obj_type,\n                  (unsigned long)objtype->owner_key.key_value,\n                  (unsigned long)token->lock_key.key_value);\n\n        objtype->owner_key = OS_LOCK_KEY_INVALID;\n        token->lock_key    = OS_LOCK_KEY_INVALID;\n\n        probe_log(\"Ownership cleared: obj_type=%u new_owner=0x%lx new_token_key=0x%lx\",\n                  (unsigned int)token->obj_type,\n                  (unsigned long)objtype->owner_key.key_value,\n                  (unsigned long)token->lock_key.key_value);\n\n        OS_Unlock_Global_Impl(token->obj_type);\n\n        probe_log(\"OS_Unlock_Global: exit (unlocked) obj_type=%u\", (unsigned int)token->obj_type);\n    }\n    else\n    {\n        probe_log(\"OS_Unlock_Global: condition false -> entering else branch: obj_type=%u lock_mode=%u\",\n                  (unsigned int)token->obj_type, (unsigned int)token->lock_mode);\n\n        /* Mirror original behaviour: call OS_DEBUG (empty stub) and also log */\n        probe_log(\"ERROR: cannot unlock global %u for mode %u\",\n                  (unsigned int)token->obj_type, (unsigned int)token->lock_mode);\n\n        OS_DEBUG(\"ERROR: cannot unlock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:752:3: error: conflicting types for 'OS_object_token_t'; have 'struct <anonymous>'\n  752 | } OS_object_token_t;\n      |   ^~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-common.h:30,\n                 from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:58:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-globaldefs.h:60:32: note: previous declaration of 'OS_object_token_t' with type 'OS_object_token_t' {aka 'struct OS_object_token'}\n   60 | typedef struct OS_object_token OS_object_token_t;\n      |                                ^~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:67:47: error: expected ')' before '{' token\n   67 | #define OS_LOCK_KEY_INVALID     ((osal_key_t) {0})\n      |                                               ^\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:753:21: note: in expansion of macro 'OS_LOCK_KEY_INVALID'\n  753 | const OS_lock_key_t OS_LOCK_KEY_INVALID = { 0U };\n      |                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:759:37: error: expected identifier or '(' before '{' token\n  759 | void OS_DEBUG(const char *fmt, ...) { (void)fmt; }\n      |                                     ^\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:786:6: error: conflicting types for 'OS_Unlock_Global'; have 'void(OS_object_token_t *)'\n  786 | void OS_Unlock_Global(OS_object_token_t *token)\n      |      ^~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:199:6: note: previous declaration of 'OS_Unlock_Global' with type 'void(OS_object_token_t *)' {aka 'void(struct OS_object_token *)'}\n  199 | void OS_Unlock_Global(OS_object_token_t *token);\n      |      ^~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_Unlock_Global':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:67:33: error: incompatible types when assigning to type 'OS_lock_key_t' from type 'osal_key_t'\n   67 | #define OS_LOCK_KEY_INVALID     ((osal_key_t) {0})\n      |                                 ^\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:838:30: note: in expansion of macro 'OS_LOCK_KEY_INVALID'\n  838 |         token->lock_key    = OS_LOCK_KEY_INVALID;\n      |                              ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:873:6: error: conflicting types for 'OS_WaitForStateChange'; have 'void(OS_object_token_t *, uint32)' {aka 'void(OS_object_token_t *, unsigned int)'}\n  873 | void OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts)\n      |      ^~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:218:6: note: previous declaration of 'OS_WaitForStateChange' with type 'void(OS_object_token_t *, uint32)' {aka 'void(struct OS_object_token *, unsigned int)'}\n  218 | void OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts);\n      |      ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:921:7: error: conflicting types for 'OS_ObjectIdFinalizeNew'; have 'int32(int32,  OS_object_token_t *, osal_id_t *)' {aka 'int(int,  OS_object_token_t *, unsigned int *)'}\n  921 | int32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid)\n      |       ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:457:7: note: previous declaration of 'OS_ObjectIdFinalizeNew' with type 'int32(int32,  OS_object_token_t *, osal_id_t *)' {aka 'int(int,  struct OS_object_token *, unsigned int *)'}\n  457 | int32 OS_ObjectIdFinalizeNew(int32 operation_status, OS_object_token_t *token, osal_id_t *outid);\n      |       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdFinalizeNew':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:934:25: error: 'OS_object_token_t' has no member named 'obj_id'\n  934 |         final_id = token->obj_id;\n      |                         ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:947:56: error: 'OS_object_token_t' has no member named 'obj_id'\n  947 |         OS_NotifyEvent(OS_EVENT_RESOURCE_CREATED, token->obj_id, NULL);\n      |                                                        ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:964:7: error: conflicting types for 'OS_ObjectIdFinalizeDelete'; have 'int32(int32,  OS_object_token_t *)' {aka 'int(int,  OS_object_token_t *)'}\n  964 | int32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:468:7: note: previous declaration of 'OS_ObjectIdFinalizeDelete' with type 'int32(int32,  OS_object_token_t *)' {aka 'int(int,  struct OS_object_token *)'}\n  468 | int32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token);\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdFinalizeDelete':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:976:25: error: 'OS_object_token_t' has no member named 'obj_id'\n  976 |         final_id = token->obj_id;\n      |                         ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:985:56: error: 'OS_object_token_t' has no member named 'obj_id'\n  985 |         OS_NotifyEvent(OS_EVENT_RESOURCE_DELETED, token->obj_id, NULL);\n      |                                                        ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1003:7: error: conflicting types for 'OS_ObjectIdGetBySearch'; have 'int32(OS_lock_mode_t,  osal_objtype_t,  _Bool (*)(void *, const OS_object_token_t *, const OS_common_record_t *), void *, OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  _Bool (*)(void *, const struct OS_object_token *, const struct OS_common_record *), void *, OS_object_token_t *)'}\n 1003 | int32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n      |       ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:398:7: note: previous declaration of 'OS_ObjectIdGetBySearch' with type 'int32(OS_lock_mode_t,  osal_objtype_t,  _Bool (*)(void *, const OS_object_token_t *, const OS_common_record_t *), void *, OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  _Bool (*)(void *, const struct OS_object_token *, const struct OS_common_record *), void *, struct OS_object_token *)'}\n  398 | int32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n      |       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1041:7: error: conflicting types for 'OS_ObjectIdGetByName'; have 'int32(OS_lock_mode_t,  osal_objtype_t,  const char *, OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  const char *, OS_object_token_t *)'}\n 1041 | int32 OS_ObjectIdGetByName(OS_lock_mode_t lock_mode, osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n      |       ^~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:408:7: note: previous declaration of 'OS_ObjectIdGetByName' with type 'int32(OS_lock_mode_t,  osal_objtype_t,  const char *, OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  const char *, struct OS_object_token *)'}\n  408 | int32 OS_ObjectIdGetByName(OS_lock_mode_t lock_mode, osal_objtype_t idtype, const char *name, OS_object_token_t *token);\n      |       ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdFindByName':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1071:27: error: 'OS_object_token_t' has no member named 'obj_id'\n 1071 |         *object_id = token.obj_id;\n      |                           ^\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1093:7: error: conflicting types for 'OS_ObjectIdGetById'; have 'int32(OS_lock_mode_t,  osal_objtype_t,  osal_id_t,  OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  unsigned int,  OS_object_token_t *)'}\n 1093 | int32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n      |       ^~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:417:7: note: previous declaration of 'OS_ObjectIdGetById' with type 'int32(OS_lock_mode_t,  osal_objtype_t,  osal_id_t,  OS_object_token_t *)' {aka 'int(OS_lock_mode_t,  unsigned int,  unsigned int,  struct OS_object_token *)'}\n  417 | int32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token);\n      |       ^~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdGetById':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1103:61: error: 'OS_object_token_t' has no member named 'obj_idx'\n 1103 |     return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n      |                                                             ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1106:14: error: 'OS_object_token_t' has no member named 'obj_id'\n 1106 |         token->obj_id = id;\n      |              ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1139:6: error: conflicting types for 'OS_ObjectIdTransactionFinish'; have 'void(OS_object_token_t *, const osal_id_t *)' {aka 'void(OS_object_token_t *, const unsigned int *)'}\n 1139 | void OS_ObjectIdTransactionFinish(OS_object_token_t *token, const osal_id_t *final_id)\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:371:6: note: previous declaration of 'OS_ObjectIdTransactionFinish' with type 'void(OS_object_token_t *, const osal_id_t *)' {aka 'void(struct OS_object_token *, const unsigned int *)'}\n  371 | void OS_ObjectIdTransactionFinish(OS_object_token_t *token, const osal_id_t *final_id);\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdTransactionFinish':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1181:34: error: 'OS_object_token_t' has no member named 'obj_id'\n 1181 |         record->active_id = token->obj_id;\n      |                                  ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1206:6: error: conflicting types for 'OS_ObjectIdRelease'; have 'void(OS_object_token_t *)'\n 1206 | void OS_ObjectIdRelease(OS_object_token_t *token)\n      |      ^~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:426:6: note: previous declaration of 'OS_ObjectIdRelease' with type 'void(OS_object_token_t *)' {aka 'void(struct OS_object_token *)'}\n  426 | void OS_ObjectIdRelease(OS_object_token_t *token);\n      |      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1239:7: error: conflicting types for 'OS_ObjectIdAllocateNew'; have 'int32(osal_objtype_t,  const char *, OS_object_token_t *)' {aka 'int(unsigned int,  const char *, OS_object_token_t *)'}\n 1239 | int32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token)\n      |       ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:446:7: note: previous declaration of 'OS_ObjectIdAllocateNew' with type 'int32(osal_objtype_t,  const char *, OS_object_token_t *)' {aka 'int(unsigned int,  const char *, struct OS_object_token *)'}\n  446 | int32 OS_ObjectIdAllocateNew(osal_objtype_t idtype, const char *name, OS_object_token_t *token);\n      |       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: In function 'OS_ObjectIdAllocateNew':\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1289:72: error: 'OS_object_token_t' has no member named 'obj_id'\n 1289 |         return_code = OS_NotifyEvent(OS_EVENT_RESOURCE_ALLOCATED, token->obj_id, NULL);\n      |                                                                        ^~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c: At top level:\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1309:6: error: conflicting types for 'OS_ObjectIdTransferToken'; have 'void(OS_object_token_t *, OS_object_token_t *)'\n 1309 | void OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:435:6: note: previous declaration of 'OS_ObjectIdTransferToken' with type 'void(OS_object_token_t *, OS_object_token_t *)' {aka 'void(struct OS_object_token *, struct OS_object_token *)'}\n  435 | void OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to);\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:1341:6: error: conflicting types for 'OS_ObjectFilterActive'; have '_Bool(void *, const OS_object_token_t *, const OS_common_record_t *)' {aka '_Bool(void *, const OS_object_token_t *, const struct OS_common_record *)'}\n 1341 | bool OS_ObjectFilterActive(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n      |      ^~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmpo68snflc/src/src/os/shared/src/osapi-idmap.c:59:\n/tmp/tmpo68snflc/src/src/os/shared/inc/os-shared-idmap.h:531:7: note: previous declaration of 'OS_ObjectFilterActive' with type '_Bool(void *, const OS_object_token_t *, const OS_common_record_t *)' {aka '_Bool(void *, const struct OS_object_token *, const struct OS_common_record *)'}\n  531 | bool  OS_ObjectFilterActive(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj);\n      |       ^~~~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:216: CMakeFiles/osal.dir/src/os/shared/src/osapi-idmap.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_Unlock_Global as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <stdint.h>\n\n/* probe_log is a helper logging function used only in this compilation unit */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1658.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* timestamp */\n    time_t t = time(NULL);\n    struct tm *tm = localtime(&t);\n    if (tm != NULL)\n    {\n        fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \", tm->tm_year + 1900, tm->tm_mon + 1,\n                tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * Implementation of OS_Unlock_Global. This function must match the\n * declaration in the project's headers (it uses the existing\n * OS_object_token_t and related types defined there). Do not redefine\n * those types here to avoid conflicts with the shared headers.\n */\nvoid OS_Unlock_Global(OS_object_token_t *token)\n{\n    OS_objtype_state_t *objtype;\n\n    /* Log entry and token basic state */\n    if (token == NULL)\n    {\n        probe_log(\"OS_Unlock_Global: token is NULL\");\n        return;\n    }\n\n    probe_log(\"OS_Unlock_Global: entry obj_type=%u lock_mode=%u lock_key=0x%08lx\",\n              (unsigned int)token->obj_type, (unsigned int)token->lock_mode,\n              (unsigned long)token->lock_key.key_value);\n\n    if (token->obj_type < OS_OBJECT_TYPE_USER && token->lock_mode != OS_LOCK_MODE_NONE)\n    {\n        probe_log(\"OS_Unlock_Global: condition true (obj_type < OS_OBJECT_TYPE_USER && lock_mode != NONE)\");\n\n        objtype = &OS_objtype_state[token->obj_type];\n\n        /*\n         * Un-track ownership of this table.  It should only be owned by one\n         * task at a time, and this aids in recovery if the owning task is\n         * deleted or experiences an exception causing it to not be freed.\n         *\n         * This is done before unlocking, while this has exclusive access\n         * to the state object.\n         */\n        if ((objtype->owner_key.key_value & 0xFF000000) != OS_LOCK_KEY_FIXED_VALUE ||\n            objtype->owner_key.key_value != token->lock_key.key_value)\n        {\n            /* this is almost certainly a bug */\n            /* Probe log before the (empty) OS_DEBUG to capture state */\n            probe_log(\"MISMATCHED KEY: global=%u released using mismatched key=0x%lx expected=0x%lx\",\n                      (unsigned int)token->obj_type,\n                      (unsigned long)token->lock_key.key_value,\n                      (unsigned long)objtype->owner_key.key_value);\n\n            /* Call OS_DEBUG as in original code (may be an empty stub in the project) */\n            OS_DEBUG(\"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\\n\",\n                     (unsigned int)token->obj_type, (unsigned long)token->lock_key.key_value,\n                     (unsigned long)objtype->owner_key.key_value);\n        }\n\n        /* Log the state just before clearing ownership */\n        probe_log(\"Clearing ownership: obj_type=%u old_owner=0x%lx old_token_key=0x%lx\",\n                  (unsigned int)token->obj_type,\n                  (unsigned long)objtype->owner_key.key_value,\n                  (unsigned long)token->lock_key.key_value);\n\n        objtype->owner_key = OS_LOCK_KEY_INVALID;\n        token->lock_key    = OS_LOCK_KEY_INVALID;\n\n        probe_log(\"Ownership cleared: obj_type=%u new_owner=0x%lx new_token_key=0x%lx\",\n                  (unsigned int)token->obj_type,\n                  (unsigned long)objtype->owner_key.key_value,\n                  (unsigned long)token->lock_key.key_value);\n\n        OS_Unlock_Global_Impl(token->obj_type);\n\n        probe_log(\"OS_Unlock_Global: exit (unlocked) obj_type=%u\", (unsigned int)token->obj_type);\n    }\n    else\n    {\n        probe_log(\"OS_Unlock_Global: condition false -> entering else branch: obj_type=%u lock_mode=%u\",\n                  (unsigned int)token->obj_type, (unsigned int)token->lock_mode);\n\n        /* Mirror original behaviour: call OS_DEBUG (may be empty) and also log */\n        probe_log(\"ERROR: cannot unlock global %u for mode %u\",\n                  (unsigned int)token->obj_type, (unsigned int)token->lock_mode);\n\n        OS_DEBUG(\"ERROR: cannot unlock global %u for mode %u\\n\", (unsigned int)token->obj_type,\n                 (unsigned int)token->lock_mode);\n    }\n}\n",
  "explanation": "Removed redefinitions that conflicted with the project's shared headers. Specifically:\n- Removed local typedefs for OS_object_token_t and OS_lock_key_t and the local const OS_LOCK_KEY_INVALID which conflicted with types/macros declared in the included headers.\n- Removed local stubs for OS_DEBUG and OS_Unlock_Global_Impl so the implementation in this file uses the project's existing declarations/definitions.\n- Kept probe_log and the implementation of OS_Unlock_Global, preserving the original logic and logging, but relying on the shared types and macros provided by the project's headers to avoid type/macro conflicts.\n\nThese changes eliminate the conflicting type/macro declarations while preserving the original OS_Unlock_Global behavior."
}