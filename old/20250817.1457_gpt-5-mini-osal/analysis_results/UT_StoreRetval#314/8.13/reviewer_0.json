{
  "user_message": "An agent A claimed that the following UT_StoreRetval code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_StoreRetval.\n```c\nbool UT_StoreRetval(UT_RetvalBuf_t *Buf, const void *ValuePtr, size_t ValueSize, UT_ValueGenre_t ValueGenre)\n{\n    /* Copy the value based on width, so it will be properly extended, if applicable:\n     * - all numeric values need to be aligned per endianness of the host\n     * - signed ints must be sign-extended,\n     * - single-precision floating points will be extended to double-precision\n     *\n     * Pointers must all be the expected size, however.\n     */\n    switch (UT_GENRE_SIZE(ValueGenre, ValueSize))\n    {\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int8)):\n            Buf->Integer = *((int8 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int16)):\n            Buf->Integer = *((int16 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int32)):\n            Buf->Integer = *((int32 const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int64)):\n            Buf->Integer = *((int64 const *)ValuePtr);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(float)):\n            Buf->FloatingPt = *((float const *)ValuePtr);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(double)):\n            Buf->FloatingPt = *((double const *)ValuePtr);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_POINTER, sizeof(void *)):\n            Buf->Ptr = *((void *const *)ValuePtr);\n            break;\n\n        default:\n            return UtAssert_Failed(\"Cannot store return value - ValueSize not valid\");\n    }\n\n    return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code casts the const void * ValuePtr to (void *const *) and then dereferences to store into Buf->Ptr (type void *). This can discard a const qualification on the pointed-to data. For example, if the caller passes a pointer-to-const (const char *p; UT_StoreRetval(&buf, &p, sizeof(p), UT_ValueGenre_POINTER);) the function will store a non-const void * into Buf->Ptr, losing the const qualification. The safe approach would be to preserve the const (e.g. use const void * in the buffer or cast to (const void * const *) before dereference).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_AppendLog(const char *fmt, ...)\n{\n    FILE *f;\n    va_list ap;\n\n    /* Try to create directory (ignore errors if it already exists) */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/2515.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void UT_DumpHex(const void *ptr, size_t len)\n{\n    const unsigned char *p = (const unsigned char *)ptr;\n    size_t i;\n    char buf[64];\n    size_t off = 0;\n\n    for (i = 0; i < len && off + 3 < sizeof(buf); ++i)\n    {\n        off += snprintf(buf + off, sizeof(buf) - off, \"%02X\", p[i]);\n        if (i + 1 < len && off + 1 < sizeof(buf))\n        {\n            buf[off++] = ' ';\n            buf[off] = '\\0';\n        }\n    }\n    UT_AppendLog(\"hex[%zu]: %s\", len, buf);\n}\n\nbool UT_StoreRetval(UT_RetvalBuf_t *Buf, const void *ValuePtr, size_t ValueSize, UT_ValueGenre_t ValueGenre)\n{\n    /* Log entry and basic parameters */\n    UT_AppendLog(\"UT_StoreRetval ENTER: Buf=%p, ValuePtr=%p, ValueSize=%zu, ValueGenre=%d\", (void *)Buf, ValuePtr, ValueSize, (int)ValueGenre);\n\n    /* If ValuePtr is not NULL, dump the raw bytes that will be interpreted */\n    if (ValuePtr != NULL && ValueSize > 0)\n    {\n        /* Cap the dump to pointer size to avoid overly long logs */\n        size_t dump_len = ValueSize;\n        if (dump_len > sizeof(void *))\n        {\n            dump_len = sizeof(void *);\n        }\n        UT_DumpHex(ValuePtr, dump_len);\n    }\n\n    /* Copy the value based on width, so it will be properly extended, if applicable:\n     * - all numeric values need to be aligned per endianness of the host\n     * - signed ints must be sign-extended,\n     * - single-precision floating points will be extended to double-precision\n     *\n     * Pointers must all be the expected size, however.\n     */\n    switch (UT_GENRE_SIZE(ValueGenre, ValueSize))\n    {\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int8)):\n            Buf->Integer = *((int8 const *)ValuePtr);\n            UT_AppendLog(\"case INTEGER/8: Buf->Integer=%lld\", (long long)Buf->Integer);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int16)):\n            Buf->Integer = *((int16 const *)ValuePtr);\n            UT_AppendLog(\"case INTEGER/16: Buf->Integer=%lld\", (long long)Buf->Integer);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int32)):\n            Buf->Integer = *((int32 const *)ValuePtr);\n            UT_AppendLog(\"case INTEGER/32: Buf->Integer=%lld\", (long long)Buf->Integer);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_INTEGER, sizeof(int64)):\n            Buf->Integer = *((int64 const *)ValuePtr);\n            UT_AppendLog(\"case INTEGER/64: Buf->Integer=%lld\", (long long)Buf->Integer);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(float)):\n            Buf->FloatingPt = *((float const *)ValuePtr);\n            UT_AppendLog(\"case FLOAT/float: Buf->FloatingPt=%f\", (double)Buf->FloatingPt);\n            break;\n        case UT_GENRE_SIZE(UT_ValueGenre_FLOAT, sizeof(double)):\n            Buf->FloatingPt = *((double const *)ValuePtr);\n            UT_AppendLog(\"case FLOAT/double: Buf->FloatingPt=%f\", Buf->FloatingPt);\n            break;\n\n        case UT_GENRE_SIZE(UT_ValueGenre_POINTER, sizeof(void *)):\n        {\n            /* Before performing the original assignment (which casts away const),\n             * capture the pointer value from the raw bytes in ValuePtr for logging.\n             * Use memcpy from the const source to avoid casting away const for the probe.\n             */\n            void *tmpPtr = NULL;\n            if (ValuePtr != NULL)\n            {\n                memcpy(&tmpPtr, ValuePtr, sizeof(tmpPtr));\n                UT_AppendLog(\"pointer raw value read (via memcpy) => %p\", tmpPtr);\n            }\n\n            /* Original behavior kept to preserve logic (note: this is the line\n             * identified in the violation scenario; it may discard const).\n             */\n            Buf->Ptr = *((void *const *)ValuePtr);\n\n            UT_AppendLog(\"after assignment: Buf->Ptr=%p\", Buf->Ptr);\n            break;\n        }\n\n        default:\n            UT_AppendLog(\"UT_StoreRetval ERROR: Cannot store return value - ValueSize not valid (ValueSize=%zu)\", ValueSize);\n            return UtAssert_Failed(\"Cannot store return value - ValueSize not valid\");\n    }\n\n    UT_AppendLog(\"UT_StoreRetval EXIT: success\");\n    return true;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nUT_StoreRetval ENTER: Buf=0x564890377e18, ValuePtr=0x7ffc289562f0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x56489037ec58, ValuePtr=0x7ffc289562f0, ValueSize=8, ValueGenre=1\nhex[8]: FA FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-6\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x564890383e78, ValuePtr=0x7ffc289562f0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x564890377f38, ValuePtr=0x7ffc289562e0, ValueSize=8, ValueGenre=1\nhex[8]: FA FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-6\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x56489037a458, ValuePtr=0x7ffc289562e0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55b976985838, ValuePtr=0x7ffe98f6b2c0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55b976980a98, ValuePtr=0x7ffe98f6b300, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55b976987d58, ValuePtr=0x7ffe98f6b2f0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55e672871098, ValuePtr=0x7ffde07f8ae0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55e67286e6f8, ValuePtr=0x7ffde07f8ae0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55e67286fb38, ValuePtr=0x7ffde07f8b10, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55e672876cd8, ValuePtr=0x7ffde07f8af8, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55e67286bc38, ValuePtr=0x7ffde07f8af8, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55b550817cd8, ValuePtr=0x7ffecd8e99b0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x55b55080d658, ValuePtr=0x7ffecd8e99b0, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecdca78, ValuePtr=0x7ffc4b2e7640, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecdccb8, ValuePtr=0x7ffc4b2e7640, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecd2e18, ValuePtr=0x7ffc4b2e7660, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecd0598, ValuePtr=0x7ffc4b2e7660, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecd1f78, ValuePtr=0x7ffc4b2e7660, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecd23f8, ValuePtr=0x7ffc4b2e7650, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRetval EXIT: success\nUT_StoreRetval ENTER: Buf=0x5622cecd0598, ValuePtr=0x7ffc4b2e7610, ValueSize=8, ValueGenre=1\nhex[8]: FF FF FF FF FF FF FF FF\ncase INTEGER/64: Buf->Integer=-1\nUT_StoreRet\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The implementation casts the incoming const void * (ValuePtr) to (void *const *) and dereferences that to produce a non-const void * stored in Buf->Ptr. That cast discards the const qualification of the pointed-to pointer object and therefore fails to ensure pointers point to const-qualified types when possible. For example, passing &p where p has type const char * will end up storing a non-const void * that points at const data, losing the const qualification. This is a breach of MISRA C 2023 Rule 8.13. A safe alternative would preserve const (e.g. use a const void * target in the buffer or cast to (const void * const *) and store into a const-qualified pointer type)."
}