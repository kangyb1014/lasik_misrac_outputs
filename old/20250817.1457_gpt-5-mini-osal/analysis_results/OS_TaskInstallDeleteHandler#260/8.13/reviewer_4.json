{
  "user_message": "An agent A claimed that the following OS_TaskInstallDeleteHandler code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskInstallDeleteHandler.\n```c\nint32 OS_TaskInstallDeleteHandler(osal_task_entry function_pointer)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_id_t                  task_id;\n\n    task_id     = OS_TaskGetId_Impl();\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /*\n        ** Install the pointer\n        */\n        task->delete_hook_pointer = function_pointer;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The field entry_arg is declared as void * in OS_task_internal_record_t but is used to hold the task\u2019s start-parameter (an argument supplied by the caller and not modified by the OS). In that common usage the pointer should be const-qualified to express that the OS does not modify the pointee and to avoid callers having to cast away const. As written (void *entry_arg) it fails to qualify the pointer as pointing to a const-qualified type and therefore violates MISRA C 2023 Rule 8.13. (If, however, the OS actually modifies the object via entry_arg, then a non-const pointer would be justified and there would be no violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_Task_LogInstall(osal_id_t task_id, int32 return_code, OS_object_token_t *token, OS_task_internal_record_t *task, osal_task_entry function_pointer, const char *stage)\n{\n    FILE *f = fopen(\"/tmp/logs/2083.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log the high-level call information. */\n    fprintf(f, \"OS_TaskInstallDeleteHandler: stage=%s task_id=%ld return_code=%ld token=%p\\n\",\n            stage, (long)task_id, (long)return_code, (void *)token);\n\n    if (task != NULL)\n    {\n        /* Log internal task pointers and state. Do not dereference entry_arg. */\n        fprintf(f, \"  task_ptr=%p\\n\", (void *)task);\n\n        /* Log the function pointer being installed. Cast to uintptr_t to print as pointer-sized integer. */\n        fprintf(f, \"  installing_function_pointer=%#\" PRIxPTR \"\\n\", (uintptr_t)function_pointer);\n\n        /* Log the current delete hook pointer (before/after assignment caller will capture both). */\n        fprintf(f, \"  current_delete_hook_pointer=%#\" PRIxPTR \"\\n\", (uintptr_t)task->delete_hook_pointer);\n\n        /* Log the entry_arg pointer value to provide evidence of the pointer used as start-parameter. */\n        fprintf(f, \"  entry_arg_pointer=%p\\n\", (void *)task->entry_arg);\n    }\n    else\n    {\n        fprintf(f, \"  task == NULL\\n\");\n    }\n\n    fclose(f);\n}\n\nint32 OS_TaskInstallDeleteHandler(osal_task_entry function_pointer)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_id_t                  task_id;\n\n    task_id     = OS_TaskGetId_Impl();\n\n    /* Log: entry into the function with task id. */\n    OS_Task_LogInstall(task_id, -1, NULL, NULL, function_pointer, \"entry\");\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Log: token resolved and task pointer obtained (before install). */\n        OS_Task_LogInstall(task_id, return_code, &token, task, function_pointer, \"before_install\");\n\n        /*\n        ** Install the pointer\n        */\n        task->delete_hook_pointer = function_pointer;\n\n        /* Log: after install to capture the new value and the entry_arg pointer for inspection. */\n        OS_Task_LogInstall(task_id, return_code, &token, task, function_pointer, \"after_install\");\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log: after token release */\n        OS_Task_LogInstall(task_id, return_code, NULL, task, function_pointer, \"after_release\");\n    }\n    else\n    {\n        /* Log failure path so callers can see why the install did not happen. */\n        OS_Task_LogInstall(task_id, return_code, NULL, NULL, function_pointer, \"id_get_failed\");\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the material provided. MISRA C 2023 Rule 8.13 is about the types used in pointer declarations \u2014 a pointer should point to a const-qualified type when the pointed-to object is not modified through that pointer. The code shown in the target function only assigns a function pointer into task->delete_hook_pointer and logs task->entry_arg; it does not show the declaration of OS_task_internal_record_t nor any code that dereferences or modifies the object pointed to by entry_arg. Agent A\u2019s scenario refers to a separate field (entry_arg) being declared as void * and being used as a non-modifiable start-parameter. That might be a real issue if (a) entry_arg is indeed declared as void * and (b) the OS never modifies the pointee \u2014 in that case changing the declaration to const void * would satisfy Rule 8.13. However, based on the provided code there is no evidence of such a declaration or of non-modification of the pointee, and the shown assignment to delete_hook_pointer is unrelated to qualifying entry_arg as const. The test/logging code failed to produce output and the declaration/usage of entry_arg was not shown, so the report cannot be confirmed. Recommendation: inspect OS_task_internal_record_t and all uses of entry_arg; if the OS does not modify the pointee then change the field to const void * (or otherwise justify a deviation)."
}