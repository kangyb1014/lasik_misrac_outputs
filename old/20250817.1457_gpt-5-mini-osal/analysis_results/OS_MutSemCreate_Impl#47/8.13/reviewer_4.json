{
  "user_message": "An agent A claimed that the following OS_MutSemCreate_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemCreate_Impl.\n```c\nint32 OS_MutSemCreate_Impl(const OS_object_token_t *token, uint32 options)\n{\n    int                              return_code;\n    pthread_mutexattr_t              mutex_attr;\n    OS_impl_mutex_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_mutex_table, *token);\n\n    /*\n    ** initialize the attribute with default values\n    */\n    return_code = pthread_mutexattr_init(&mutex_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_init failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(return_code));\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    ** Allow the mutex to use priority inheritance\n    */\n    return_code = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_setprotocol failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(return_code));\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    **  Set the mutex type to RECURSIVE so a thread can do nested locks\n    */\n    return_code = pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_settype failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), strerror(return_code));\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    ** create the mutex\n    ** upon successful initialization, the state of the mutex becomes initialized and unlocked\n    */\n    return_code = pthread_mutex_init(&impl->id, &mutex_attr);\n    if (return_code != 0)\n    {\n        OS_DEBUG(\"Error: Mutex could not be created. ID = %lu: %s\\n\", OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),\n                 strerror(return_code));\n        return OS_SEM_FAILURE;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to strerror(return_code) yields a char * (non-const) which is immediately passed to OS_DEBUG as a %s argument. The error message returned by strerror is conceptually read-only and could/should be treated as const char *. Under MISRA C 2023 Rule 8.13, pointers should point to const-qualified types when possible, so using the non-const result here is a violation. Remediation: bind the result to a const char * (e.g. const char *msg = strerror(return_code)) or use a reentrant API (strerror_r) or cast to (const char *).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef uint32_t OS_object_token_t;\nstruct { int dummy; };\ntypedef struct { int dummy; } pthread_mutex_t;\ntypedef int pthread_mutexattr_t;\nstruct\n{\n    pthread_mutex_t id;\n};\ntypedef struct\n{\n    pthread_mutex_t id;\n} OS_impl_mutex_internal_record_t;\nstatic OS_impl_mutex_internal_record_t OS_impl_mutex_table_single;\nenum\n{\n    OS_SEM_FAILURE = -1,\n    OS_SUCCESS = 0\n};\nstatic OS_impl_mutex_internal_record_t *OS_OBJECT_TABLE_GET(void *table, OS_object_token_t token)\n{\n    (void)table;\n    (void)token;\n    /* Always return the single record in this test harness */\n    return &OS_impl_mutex_table_single;\n}\nstatic OS_object_token_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return *token;\n}\nstatic unsigned long OS_ObjectIdToInteger(OS_object_token_t id)\n{\n    return (unsigned long)id;\n}\nstatic void OS_DEBUG(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n}\nstatic void probe_log(const char *stage, const OS_object_token_t *token, int return_code, const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/379.txt\", \"a\");\n    if (f == NULL)\n    {\n        fprintf(stderr, \"probe_log: could not open /tmp/logs/379.txt\\n\");\n        return;\n    }\n\n    fprintf(f, \"[probe] stage=%s token=%lu return_code=%d msg_ptr=%p msg_text=\\\"%s\\\"\\n\",\n            stage,\n            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),\n            return_code,\n            (const void *)msg,\n            (msg != NULL) ? msg : \"(null)\");\n\n    fprintf(f, \"[probe] note=string_from_strerror_is_read_only_treated_as_const_char_ptr\\n\");\n\n    fclose(f);\n}\n\nint32_t OS_MutSemCreate_Impl(const OS_object_token_t *token, uint32_t options)\n{\n    int                              return_code;\n    pthread_mutexattr_t              mutex_attr;\n    OS_impl_mutex_internal_record_t *impl;\n\n    (void)options; /* Keep unused parameter from generating warnings in this test harness */\n\n    impl = OS_OBJECT_TABLE_GET(&OS_impl_mutex_table_single, *token);\n\n    /*\n    ** initialize the attribute with default values\n    ** In this self-contained harness we simulate success (return_code = 0)\n    ** so the normal initialization path is taken.\n    */\n    return_code = 0; /* simulated pthread_mutexattr_init(&mutex_attr) */\n    if (return_code != 0)\n    {\n        const char *msg = strerror(return_code);\n        probe_log(\"pthread_mutexattr_init\", token, return_code, msg);\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_init failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), msg);\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    ** Allow the mutex to use priority inheritance\n    */\n    return_code = 0; /* simulated pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT) */\n    if (return_code != 0)\n    {\n        const char *msg = strerror(return_code);\n        probe_log(\"pthread_mutexattr_setprotocol\", token, return_code, msg);\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_setprotocol failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), msg);\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    **  Set the mutex type to RECURSIVE so a thread can do nested locks\n    */\n    return_code = 0; /* simulated pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE) */\n    if (return_code != 0)\n    {\n        const char *msg = strerror(return_code);\n        probe_log(\"pthread_mutexattr_settype\", token, return_code, msg);\n        OS_DEBUG(\"Error: Mutex could not be created. pthread_mutexattr_settype failed ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), msg);\n        return OS_SEM_FAILURE;\n    }\n\n    /*\n    ** create the mutex\n    ** upon successful initialization, the state of the mutex becomes initialized and unlocked\n    */\n    return_code = 0; /* simulated pthread_mutex_init(&impl->id, &mutex_attr) */\n    if (return_code != 0)\n    {\n        const char *msg = strerror(return_code);\n        probe_log(\"pthread_mutex_init\", token, return_code, msg);\n        OS_DEBUG(\"Error: Mutex could not be created. ID = %lu: %s\\n\",\n                 OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)), msg);\n        return OS_SEM_FAILURE;\n    }\n\n    (void)mutex_attr; /* silence unused variable warnings in this harness */\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 8.13 concerns the declarations of pointer objects: where a pointer object is declared it should point to a const-qualified type whenever that is feasible. In the original OS_MutSemCreate_Impl there is no pointer variable declared to hold the result of strerror \u2014 the return value of strerror(return_code) is passed directly as a function argument. That does not introduce a non-const pointer object in the code and therefore is not, by itself, a violation of Rule 8.13.\n\nThat said, the agent\u2019s suggested remediation (bind the result to a const char *: const char *msg = strerror(return_code)) is good practice and would make the intent explicit and satisfy Rule 8.13 if a local pointer is needed. But the mere use of strerror\u2019s char * return value as an argument does not constitute a direct MISRA 8.13 breach in the shown code. Also note that the signature of strerror in the C library returns char * (not const char *), so the library API itself cannot be changed; converting/assigning it to const char * in user code is the appropriate approach when a pointer variable is required."
}