{
  "user_message": "An agent A claimed that the following OS_ObjectIdFindByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFindByName.\n```c\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The LENGTHCHECK macro expands to memchr(str, '\\0', len). memchr will read up to 'len' bytes from 'str'. If 'str' points to an object that is smaller than 'len' bytes (for example a caller passes a pointer to a 6-byte buffer containing a short string but LENGTHCHECK is invoked with len = OS_MAX_API_NAME (20)), memchr will access bytes beyond the bounds of that object, causing undefined behavior. Thus the macro can result in out-of-bounds access unless the code guarantees the pointed object is at least 'len' bytes long.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1567.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    /* Cast to the platform's va_list to avoid type-mismatch with any\n     * project-specific typedefs (e.g. OCS_va_list) used in the build. */\n    vfprintf(f, fmt, (va_list)ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic int protected_memchr_probe(const char *str, size_t len, int *found)\n{\n    struct sigaction old_segv, old_bus, act;\n    sigjmp_buf env;\n    volatile int sig_caught = 0;\n\n    /* signal handler that longjmps back to the probe */\n    void handler(int sig)\n    {\n        sig_caught = sig;\n        siglongjmp(env, 1);\n    }\n\n    memset(&act, 0, sizeof(act));\n    act.sa_handler = handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n\n    /* Install handlers for SIGSEGV and SIGBUS (if available) */\n    sigaction(SIGSEGV, &act, &old_segv);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &act, &old_bus);\n#endif\n\n    if (sigsetjmp(env, 1) == 0)\n    {\n        /* Try the memchr call that the LENGTHCHECK macro could invoke */\n        void *res = memchr((const void *)str, '\\0', len);\n        *found = (res != NULL) ? 1 : 0;\n\n        /* restore handlers */\n        sigaction(SIGSEGV, &old_segv, NULL);\n#ifdef SIGBUS\n        sigaction(SIGBUS, &old_bus, NULL);\n#endif\n\n        return 0; /* completed without signal */\n    }\n    else\n    {\n        /* We landed here because handler longjmp'd */\n        /* restore handlers */\n        sigaction(SIGSEGV, &old_segv, NULL);\n#ifdef SIGBUS\n        sigaction(SIGBUS, &old_bus, NULL);\n#endif\n\n        return sig_caught ? sig_caught : 1;\n    }\n}\n\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log function entry and key parameter values (pointer addresses only).\n     * Do NOT dereference 'name' here to avoid introducing new UB. */\n    probe_log(\"OS_ObjectIdFindByName ENTRY: idtype=%d, name_ptr=%p, object_id_ptr=%p\",\n              (int)idtype, (const void *)name, (void *)object_id);\n\n    /* If name is non-NULL, attempt a protected memchr probe that may\n     * detect a SIGSEGV/SIGBUS when memchr reads past the caller's\n     * provided buffer. This is used only for logging/evidence. */\n    if (name != NULL)\n    {\n        int found = 0;\n        int sig = protected_memchr_probe(name, (size_t)OS_MAX_API_NAME, &found);\n\n        if (sig == 0)\n        {\n            probe_log(\"protected_memchr_probe: completed without signal; nul_found=%d, probe_len=%d\",\n                      found, (int)OS_MAX_API_NAME);\n        }\n        else\n        {\n            probe_log(\"protected_memchr_probe: signal caught while probing memchr: sig=%d, probe_len=%d, name_ptr=%p\",\n                      sig, (int)OS_MAX_API_NAME, (const void *)name);\n        }\n    }\n    else\n    {\n        probe_log(\"protected_memchr_probe: skipped because name == NULL\");\n    }\n\n    /* Preserve original logic: keep the ARGCHECK and LENGTHCHECK calls\n     * as in the original implementation so behavior is unchanged. */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n\n    probe_log(\"OS_ObjectIdGetByName returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        probe_log(\"Found object: token.obj_id=%d; releasing token\", (int)token.obj_id);\n\n        OS_ObjectIdRelease(&token);\n\n        probe_log(\"Token released\");\n    }\n\n    probe_log(\"OS_ObjectIdFindByName EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct unless there is an external, enforced precondition that the object pointed to by name has at least OS_MAX_API_NAME bytes. memchr(s, '\\0', len) will read up to len bytes from s; if the caller supplies a pointer to an object that is shorter than len (for example a 6-byte buffer), memchr can access memory beyond the object bounds, which is undefined behaviour and falls squarely under MISRA C 2023 Rule 21.17. The code shown does not itself guarantee or check that the pointee object is that large (ARGCHECK only checks for NULL, and LENGTHCHECK as described expands to memchr), so the use can result in out-of-bounds access. The failed probe compile does not refute the logical issue. To comply, the code must either (a) require and document a precondition that name refers to an object of at least OS_MAX_API_NAME bytes, or (b) change the check to a bounds-safe approach (e.g. accept an explicit buffer length, use a safe library that takes object size, or copy into a local fixed-size buffer and ensure it is null-terminated before scanning)."
}