{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe LENGTHCHECK macro expands to memchr(str, '\\0', len). memchr will read up to 'len' bytes from 'str'. If 'str' points to an object that is smaller than 'len' bytes (for example a caller passes a pointer to a 6-byte buffer containing a short string but LENGTHCHECK is invoked with len = OS_MAX_API_NAME (20)), memchr will access bytes beyond the bounds of that object, causing undefined behavior. Thus the macro can result in out-of-bounds access unless the code guarantees the pointed object is at least 'len' bytes long.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdFindByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1567.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdFindByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdFindByName:\n```c\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdFindByName code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n\n/*\n * Probe / logging helpers\n * These write human-readable traces of control flow and state to\n * /tmp/logs/1567.txt so other agents can observe the inputs that\n * may lead to the LENGTHCHECK / memchr out-of-bounds scenario.\n *\n * NOTE: This file only adds logging and a protected memchr probe that\n * installs a temporary SIGSEGV/SIGBUS handler to detect if memchr\n * provokes an access-fault. It does not alter the original control\n * flow or return behavior of OS_ObjectIdFindByName (the original\n * ARGCHECK/LENGTHCHECK usage is retained).\n */\n\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1567.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Protected memchr probe: attempt to call memchr(str, '\\0', len)\n * while catching SIGSEGV/SIGBUS. Returns:\n *   0  -> memchr completed without generating a signal; *found set to 0/1\n *   >0 -> signal number caught while performing memchr; *found is undefined\n */\nstatic int protected_memchr_probe(const char *str, size_t len, int *found)\n{\n    struct sigaction old_segv, old_bus, act;\n    sigjmp_buf env;\n    volatile int sig_caught = 0;\n\n    /* signal handler that longjmps back to the probe */\n    void handler(int sig)\n    {\n        sig_caught = sig;\n        siglongjmp(env, 1);\n    }\n\n    memset(&act, 0, sizeof(act));\n    act.sa_handler = handler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n\n    /* Install handlers for SIGSEGV and SIGBUS (if available) */\n    sigaction(SIGSEGV, &act, &old_segv);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &act, &old_bus);\n#endif\n\n    if (sigsetjmp(env, 1) == 0)\n    {\n        /* Try the memchr call that the LENGTHCHECK macro could invoke */\n        void *res = memchr((const void *)str, '\\0', len);\n        *found = (res != NULL) ? 1 : 0;\n\n        /* restore handlers */\n        sigaction(SIGSEGV, &old_segv, NULL);\n#ifdef SIGBUS\n        sigaction(SIGBUS, &old_bus, NULL);\n#endif\n\n        return 0; /* completed without signal */\n    }\n    else\n    {\n        /* We landed here because handler longjmp'd */\n        /* restore handlers */\n        sigaction(SIGSEGV, &old_segv, NULL);\n#ifdef SIGBUS\n        sigaction(SIGBUS, &old_bus, NULL);\n#endif\n\n        return sig_caught ? sig_caught : 1;\n    }\n}\n\n/*\n * Modified OS_ObjectIdFindByName with embedded probes. The original\n * ARGCHECK and LENGTHCHECK macros are still invoked as in the\n * original source; the probes only log information and perform a\n * protected memchr to provide evidence that running memchr(str, '\\0', len)\n * can cause a signal (which is one manifestation of out-of-bounds\n * access). The probes take care not to dereference 'name' when it is\n * NULL.\n */\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log function entry and key parameter values (pointer addresses only).\n     * Do NOT dereference 'name' here to avoid introducing new UB. */\n    probe_log(\"OS_ObjectIdFindByName ENTRY: idtype=%d, name_ptr=%p, object_id_ptr=%p\",\n              (int)idtype, (const void *)name, (void *)object_id);\n\n    /* If name is non-NULL, attempt a protected memchr probe that may\n     * detect a SIGSEGV/SIGBUS when memchr reads past the caller's\n     * provided buffer. This is used only for logging/evidence. */\n    if (name != NULL)\n    {\n        int found = 0;\n        int sig = protected_memchr_probe(name, (size_t)OS_MAX_API_NAME, &found);\n\n        if (sig == 0)\n        {\n            probe_log(\"protected_memchr_probe: completed without signal; nul_found=%d, probe_len=%d\",\n                      found, (int)OS_MAX_API_NAME);\n        }\n        else\n        {\n            probe_log(\"protected_memchr_probe: signal caught while probing memchr: sig=%d, probe_len=%d, name_ptr=%p\",\n                      sig, (int)OS_MAX_API_NAME, (const void *)name);\n        }\n    }\n    else\n    {\n        probe_log(\"protected_memchr_probe: skipped because name == NULL\");\n    }\n\n    /* Preserve original logic: keep the ARGCHECK and LENGTHCHECK calls\n     * as in the original implementation so behavior is unchanged. */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n\n    probe_log(\"OS_ObjectIdGetByName returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        probe_log(\"Found object: token.obj_id=%d; releasing token\", (int)token.obj_id);\n\n        OS_ObjectIdRelease(&token);\n\n        probe_log(\"Token released\");\n    }\n\n    probe_log(\"OS_ObjectIdFindByName EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n"
}