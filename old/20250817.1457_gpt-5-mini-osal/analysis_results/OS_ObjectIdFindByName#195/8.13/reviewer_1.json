{
  "user_message": "An agent A claimed that the following OS_ObjectIdFindByName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFindByName.\n```c\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The chain passes a const char * (name) through a non-const void * parameter. OS_ObjectIdGetByName casts (void *)name when calling OS_ObjectIdGetBySearch, and OS_ObjectIdGetBySearch/OS_ObjectIdFindNextMatch accept void *arg (not const void *). This discards the const qualifier and therefore violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_write_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1563.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging is not available, silently continue to preserve original behavior. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fclose(fp);\n}\n\nint32 OS_ObjectIdFindByName(osal_objtype_t idtype, const char *name, osal_id_t *object_id)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log function entry and input state. */\n    probe_write_log(\"[1563] ENTRY: OS_ObjectIdFindByName idtype=%ld, name_ptr=%p, name=\\\"%s\\\"\\n\",\n                    (long)idtype, (const void *)name, (name != NULL) ? name : \"(null)\");\n\n    /*\n     * As this is an internal-only function, calling it with NULL is allowed.\n     * This is required by the file/dir/socket API since these DO allow multiple\n     * instances of the same name.\n     */\n    ARGCHECK(name, OS_ERR_NAME_NOT_FOUND);\n    LENGTHCHECK(name, OS_MAX_API_NAME, OS_ERR_NAME_TOO_LONG);\n\n    /* Log that argument checks passed. If the macros returned early, no further logs will appear. */\n    probe_write_log(\"[1563] After checks: name_ptr=%p\\n\", (const void *)name);\n\n    probe_write_log(\"[1563] About to call OS_ObjectIdGetByName with idtype=%ld, name_ptr=%p\\n\",\n                    (long)idtype, (const void *)name);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &token);\n\n    probe_write_log(\"[1563] Returned from OS_ObjectIdGetByName: return_code=%ld\\n\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        *object_id = token.obj_id;\n\n        probe_write_log(\"[1563] Match found: token.obj_id=%lu; releasing token\\n\", (unsigned long)token.obj_id);\n\n        OS_ObjectIdRelease(&token);\n\n        probe_write_log(\"[1563] Token released for obj_id=%lu\\n\", (unsigned long)token.obj_id);\n    }\n    else\n    {\n        probe_write_log(\"[1563] No match found for name_ptr=%p name=\\\"%s\\\"\\n\",\n                        (const void *)name, (name != NULL) ? name : \"(null)\");\n    }\n\n    probe_write_log(\"[1563] EXIT: OS_ObjectIdFindByName return_code=%ld\\n\", (long)return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[1563] ENTRY: OS_ObjectIdFindByName idtype=4, name_ptr=0x7fff5f09cdf0, name=\"YYYYYYYYYYYYYYYYYYYYYYYYYYYYY\"\n[1563] ENTRY: OS_ObjectIdFindByName idtype=4, name_ptr=0x55fc852136b1, name=\"NameNotFound\"\n[1563] After checks: name_ptr=0x55fc852136b1\n[1563] About to call OS_ObjectIdGetByName with idtype=4, name_ptr=0x55fc852136b1\n[1563] Returned from OS_ObjectIdGetByName: return_code=-17\n[1563] No match found for name_ptr=0x55fc852136b1 name=\"NameNotFound\"\n[1563] EXIT: OS_ObjectIdFindByName return_code=-17\n[1563] ENTRY: OS_ObjectIdFindByName idtype=3, name_ptr=0x7fff5f09cdf0, name=\"YYYYYYYYYYYYYYYYYYYYYYYYYYYYY\"\n[1563] ENTRY: OS_ObjectIdFindByName idtype=3, name_ptr=0x55fc85215f7d, name=\"NotFound\"\n[1563] After checks: name_ptr=0x55fc85215f7d\n[1563] About to call OS_ObjectIdGetByName with idtype=3, name_ptr=0x55fc85215f7d\n[1563] Returned from OS_ObjectIdGetByName: return_code=-17\n[1563] No match found for name_ptr=0x55fc85215f7d name=\"NotFound\"\n[1563] EXIT: OS_ObjectIdFindByName return_code=-17\n[1563] ENTRY: OS_ObjectIdFindByName idtype=5, name_ptr=0x7fff5f09cdf0, name=\"YYYYYYYYYYYYYYYYYYYYYYYYYYYYY\"\n[1563] ENTRY: OS_ObjectIdFindByName idtype=5, name_ptr=0x55fc852166d9, name=\"NotFound\"\n[1563] After checks: name_ptr=0x55fc852166d9\n[1563] About to call OS_ObjectIdGetByName with idtype=5, name_ptr=0x55fc852166d9\n[1563] Returned from OS_ObjectIdGetByName: return_code=-17\n[1563] No match found for name_ptr=0x55fc852166d9 name=\"NotFound\"\n[1563] EXIT: OS_ObjectIdFindByName return_code=-17\n[1563] ENTRY: OS_ObjectIdFindByName idtype=2, name_ptr=0x7fff5f09cdf0, name=\"YYYYYYYYYYYYYYYYYYYYYYYYYYYYY\"\n[1563] ENTRY: OS_ObjectIdFindByName idtype=2, name_ptr=0x55fc85214f50, name=\"NameNotFound\"\n[1563] After checks: name_ptr=0x55fc85214f50\n[1563] About to call OS_ObjectIdGetByName with idtype=2, name_ptr=0x55fc85214f50\n[1563] Returned from OS_ObjectIdGetByName: return_code=-17\n[1563] No match found for name_ptr=0x55fc85214f50 name=\"NameNotFound\"\n[1563] EXIT: OS_ObjectIdFindByName return_code=-17\n[1563] ENTRY: OS_ObjectIdFindByName idtype=1, name_ptr=0x55fc85483d70, name=\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n[1563] ENTRY: OS_ObjectIdFindByName idtype=1, name_ptr=0x55fc85217975, name=\"NotFound\"\n[1563] After checks: name_ptr=0x55fc85217975\n[1563] About to call OS_ObjectIdGetByName with idtype=1, name_ptr=0x55fc85217975\n[1563] Returned from OS_ObjectIdGetByName: return_code=-17\n[1563] No match found for name_ptr=0x55fc85217975 name=\"NotFound\"\n[1563] EXIT: OS_ObjectIdFindByName return_code=-17\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. OS_ObjectIdFindByName takes a const char *name but the name is forwarded into a search API that accepts a non-const void * (the chain performs a (void *) cast). That discards the const qualifier on the pointer; per MISRA C 2023 Rule 8.13, pointers should point to a const-qualified type whenever possible, and the const qualifier should be preserved when the callee does not need to modify the pointee. The provided probe logs show the same name pointer being passed through the call chain (addresses unchanged), which is consistent with forwarding a const pointer into a non-const parameter; this constitutes the qualifier being dropped and thus a violation of Rule 8.13."
}