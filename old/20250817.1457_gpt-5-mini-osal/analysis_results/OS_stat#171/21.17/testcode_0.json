{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation: memchr(name_ptr, 0, OS_MAX_FILE_NAME) can read past the end of the object pointed to by name_ptr. name_ptr points inside the VirtualPath string (one past the last '/'), but the code only guarantees a NUL byte within the first OS_MAX_PATH_LEN bytes of VirtualPath. There is no guarantee that there are OS_MAX_FILE_NAME bytes available starting at name_ptr. For example, if VirtualPath is a buffer of size OS_MAX_PATH_LEN and the '/' is at index OS_MAX_PATH_LEN-2 (so name_ptr is at OS_MAX_PATH_LEN-1), a memchr with n = OS_MAX_FILE_NAME > 1 will read beyond the buffer boundary. Therefore this use of memchr can access out-of-bounds memory and violates MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_stat code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1375.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_stat as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_stat:\n```c\nint32 OS_stat(const char *path, os_fstat_t *filestats)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(filestats);\n\n    memset(filestats, 0, sizeof(*filestats));\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileStat_Impl(local_path, filestats);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_stat code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/*\n * Probes and logging for OS_stat to help reproduce possible out-of-bounds\n * string handling elsewhere in the code base. This preserves the original\n * logic of OS_stat and only adds logging side-effects. Logs go to\n * /tmp/logs/1375.txt. No main() is defined.\n */\n\nstatic void ensure_log_dir(void)\n{\n    /* try to create the directory if it does not exist; ignore errors */\n    (void)mkdir(\"/tmp/logs\", 0755);\n}\n\nstatic void log_os_stat_before(const char *path, const void *filestats_ptr)\n{\n    ensure_log_dir();\n    FILE *fp = fopen(\"/tmp/logs/1375.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    fprintf(fp, \"[OS_stat] ENTRY\\n\");\n    fprintf(fp, \"  path ptr: %p\\n\", (const void *)path);\n    fprintf(fp, \"  filestats ptr: %p\\n\", filestats_ptr);\n\n    /* Do not dereference `path` here to avoid reading past the caller's object.\n     * Only log its pointer value. The problematic memchr reported occurs when\n     * other code (e.g. OS_TranslatePath/VirtualPath handling) uses offsets\n     * starting inside a buffer. The pointer address here helps correlate\n     * logs with those later reads. */\n\n    fclose(fp);\n}\n\nstatic void log_os_stat_after(const char *path, const char *local_path, size_t local_path_size,\n                              void *filestats_ptr, int32_t translate_rc, int32_t filestat_rc)\n{\n    ensure_log_dir();\n    FILE *fp = fopen(\"/tmp/logs/1375.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    fprintf(fp, \"[OS_stat] AFTER OS_TranslatePath\\n\");\n    fprintf(fp, \"  original path ptr: %p\\n\", (const void *)path);\n    fprintf(fp, \"  translated local_path buffer addr: %p, size: %zu\\n\", (const void *)local_path, local_path_size);\n\n    /* Safely compute length of local_path up to the provided buffer size. */\n    size_t tlen = 0;\n    if (local_path != NULL && local_path_size > 0)\n    {\n        tlen = strnlen(local_path, local_path_size);\n    }\n\n    fprintf(fp, \"  translated path length (bounded): %zu\\n\", tlen);\n    if (tlen > 0)\n    {\n        /* print the translated path limited to the bounded length */\n        fprintf(fp, \"  translated path: %.*s\\n\", (int)tlen, local_path);\n\n        /* Also print hex bytes for the bounded range to aid forensic analysis. */\n        fprintf(fp, \"  translated path bytes (hex):\");\n        for (size_t i = 0; i < tlen; ++i)\n        {\n            fprintf(fp, \" %02x\", (unsigned char)local_path[i]);\n        }\n        fprintf(fp, \"\\n\");\n    }\n\n    fprintf(fp, \"  OS_TranslatePath return: %d\\n\", (int)translate_rc);\n    fprintf(fp, \"  OS_FileStat_Impl return: %d\\n\", (int)filestat_rc);\n    fprintf(fp, \"[OS_stat] EXIT\\n\\n\");\n\n    fclose(fp);\n}\n\n/*\n * The original OS_stat implementation with logging probes inserted. The\n * semantics and control flow are preserved; only logging side-effects are\n * added to aid reproduction of the memchr out-of-bounds scenario reported by\n * static analysis.\n */\nint32 OS_stat(const char *path, os_fstat_t *filestats)\n{\n    int32 return_code;\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(filestats);\n\n    /* Probe: entry state */\n    log_os_stat_before(path, (const void *)filestats);\n\n    memset(filestats, 0, sizeof(*filestats));\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Probe: after a successful translate, capture translated path contents */\n        log_os_stat_after(path, local_path, sizeof(local_path), (void *)filestats, return_code, -1);\n\n        return_code = OS_FileStat_Impl(local_path, filestats);\n\n        /* Probe: final state including result of file stat */\n        log_os_stat_after(path, local_path, sizeof(local_path), (void *)filestats, 0, return_code);\n    }\n    else\n    {\n        /* Probe: translation failed; record that and skip file stat */\n        log_os_stat_after(path, NULL, 0, (void *)filestats, return_code, -1);\n    }\n\n    return return_code;\n}\n"
}