{
  "user_message": "An agent A claimed that the following OS_FileSysAddFixedMap code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FileSysAddFixedMap.\n```c\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_OBJECT_INIT expands to memset(ref,0,sizeof(*ref)) and strncpy(ref->device_name, dev_name, sizeof(ref->device_name)-1). The memset is safe, but the strncpy can read from the source pointer dev_name up to sizeof(device_name)-1 bytes. The prior check uses memchr(dev_name, 0, sizeof(filesys->volume_name)) \u2014 a different size \u2014 so there is no guarantee that a NUL exists within the first sizeof(device_name)-1 bytes. If OS_FS_DEV_NAME_LEN (sizeof(device_name)) is larger than OS_FS_VOL_NAME_LEN (sizeof(volume_name)) or otherwise the sizes do not match, strncpy may read past the terminating NUL of the source (or past the allocated phys_path region), causing an out-of-bounds access of the source. Therefore Rule 21.17 can be violated in that scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FileSysAddFixedMap(osal_id_t *filesys_id, const char *phys_path, const char *virt_path)\n{\n    OS_filesys_internal_record_t *filesys;\n    int32                         return_code;\n    OS_object_token_t             token;\n    const char *                  dev_name;\n\n    /* File for logging probe information to help reproduce the scenario */\n    FILE *logf = fopen(\"/tmp/logs/1391.txt\", \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"\\n--- OS_FileSysAddFixedMap entry ---\\n\");\n        fprintf(logf, \"phys_path=%p, virt_path=%p, filesys_id=%p\\n\", (const void *)phys_path, (const void *)virt_path, (void *)filesys_id);\n    }\n\n    /*\n     * Validate inputs\n     */\n    OS_CHECK_POINTER(filesys_id);\n    OS_CHECK_STRING(phys_path, sizeof(filesys->system_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_PATHNAME(virt_path);\n\n    /*\n     * Generate a dev name by taking the basename of the phys_path.\n     */\n    dev_name = strrchr(phys_path, '/');\n    if (dev_name == NULL)\n    {\n        dev_name = phys_path;\n    }\n    else\n    {\n        ++dev_name;\n    }\n\n    /*\n     * Probe/log the sizes and the dev_name content (safely, bounded by the same size used below)\n     * Note: sizeof on members is a compile-time constant and does not dereference 'filesys'.\n     */\n    if (logf != NULL)\n    {\n        size_t size_volume = sizeof(filesys->volume_name);\n        size_t size_device = sizeof(filesys->device_name);\n        size_t size_system_mountpt = sizeof(filesys->system_mountpt);\n\n        /* compute dev_name length safely up to size_volume using memchr (no out-of-bounds) */\n        const void *nulp = memchr(dev_name, 0, size_volume);\n        size_t dev_len = (nulp != NULL) ? ((const char *)nulp - dev_name) : size_volume;\n\n        fprintf(logf, \"dev_name_ptr=%p, dev_name_len_bounded_by_volume=%zu\\n\", (const void *)dev_name, dev_len);\n        fprintf(logf, \"size_volume=%zu, size_device=%zu, size_system_mountpt=%zu\\n\", size_volume, size_device, size_system_mountpt);\n\n        /* Log the first up-to-size_volume bytes of dev_name as hex and ASCII (bounded) */\n        fprintf(logf, \"dev_name (bounded content): '\");\n        for (size_t i = 0; i < dev_len; ++i)\n        {\n            unsigned char c = (unsigned char)dev_name[i];\n            /* Print printable ASCII or '.' otherwise */\n            fputc((c >= 0x20 && c < 0x7f) ? c : '.', logf);\n        }\n        fprintf(logf, \"'\\n\");\n    }\n\n    if (memchr(dev_name, 0, sizeof(filesys->volume_name)) == NULL)\n    {\n        if (logf != NULL)\n        {\n            fprintf(logf, \"memchr(dev_name,0,sizeof(volume_name)) returned NULL: name too long -> returning OS_ERR_NAME_TOO_LONG\\n\");\n            fclose(logf);\n        }\n        return OS_ERR_NAME_TOO_LONG;\n    }\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, dev_name, &token);\n\n    if (logf != NULL)\n    {\n        fprintf(logf, \"OS_ObjectIdAllocateNew returned %ld\\n\", (long)return_code);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Allocated filesys record at %p\\n\", (void *)filesys);\n            fprintf(logf, \"About to call OS_OBJECT_INIT with device name (dev_name=%p)\\n\", (const void *)dev_name);\n        }\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, filesys, device_name, dev_name);\n\n        if (logf != NULL)\n        {\n            /* Safely log the stored device_name up to its buffer size */\n            size_t size_device = sizeof(filesys->device_name);\n            const void *nulp_dev = memchr(filesys->device_name, 0, size_device);\n            size_t dev_stored_len = (nulp_dev != NULL) ? ((const char *)nulp_dev - filesys->device_name) : size_device;\n\n            fprintf(logf, \"After OS_OBJECT_INIT: filesys->device_name (bounded len=%zu): '\", dev_stored_len);\n            for (size_t i = 0; i < dev_stored_len; ++i)\n            {\n                unsigned char c = (unsigned char)filesys->device_name[i];\n                fputc((c >= 0x20 && c < 0x7f) ? c : '.', logf);\n            }\n            fprintf(logf, \"'\\n\");\n        }\n\n        strncpy(filesys->volume_name, dev_name, sizeof(filesys->volume_name) - 1);\n        strncpy(filesys->system_mountpt, phys_path, sizeof(filesys->system_mountpt) - 1);\n        strncpy(filesys->virtual_mountpt, virt_path, sizeof(filesys->virtual_mountpt) - 1);\n\n        if (logf != NULL)\n        {\n            /* Log the fields copied by strncpy using safe bounded inspection */\n            size_t sv = sizeof(filesys->volume_name);\n            const void *vnulp = memchr(filesys->volume_name, 0, sv);\n            size_t vlen = (vnulp != NULL) ? ((const char *)vnulp - filesys->volume_name) : sv;\n\n            size_t sm = sizeof(filesys->system_mountpt);\n            const void *sm_nulp = memchr(filesys->system_mountpt, 0, sm);\n            size_t smlen = (sm_nulp != NULL) ? ((const char *)sm_nulp - filesys->system_mountpt) : sm;\n\n            size_t vm = sizeof(filesys->virtual_mountpt);\n            const void *vm_nulp = memchr(filesys->virtual_mountpt, 0, vm);\n            size_t vmlen = (vm_nulp != NULL) ? ((const char *)vm_nulp - filesys->virtual_mountpt) : vm;\n\n            fprintf(logf, \"After strncpy: volume_name bounded_len=%zu, system_mountpt bounded_len=%zu, virtual_mountpt bounded_len=%zu\\n\", vlen, smlen, vmlen);\n            fprintf(logf, \"volume_name (bounded content): '\");\n            for (size_t i = 0; i < vlen; ++i)\n            {\n                unsigned char c = (unsigned char)filesys->volume_name[i];\n                fputc((c >= 0x20 && c < 0x7f) ? c : '.', logf);\n            }\n            fprintf(logf, \"'\\n\");\n        }\n\n        /*\n         * mark the entry that it is a fixed disk\n         */\n        filesys->fstype = OS_FILESYS_TYPE_FS_BASED;\n        filesys->flags  = OS_FILESYS_FLAG_IS_FIXED;\n\n        /*\n         * The \"mount\" implementation is required as it will\n         * create the mountpoint if it does not already exist\n         */\n        return_code = OS_FileSysStartVolume_Impl(&token);\n\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_FileSysStartVolume_Impl returned %ld\\n\", (long)return_code);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            filesys->flags |= OS_FILESYS_FLAG_IS_READY;\n            return_code = OS_FileSysMountVolume_Impl(&token);\n\n            if (logf != NULL)\n            {\n                fprintf(logf, \"OS_FileSysMountVolume_Impl returned %ld\\n\", (long)return_code);\n            }\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /*\n             * mark the entry that it is a fixed disk\n             */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n        }\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, filesys_id);\n\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_ObjectIdFinalizeNew returned %ld, final filesys_id=%p\\n\", (long)return_code, (void *)filesys_id);\n            fclose(logf);\n        }\n    }\n    else\n    {\n        if (logf != NULL)\n        {\n            fclose(logf);\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FileSysAddFixedMap. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The agent's scenario depends on the idea that a subsequent strncpy can read past the terminating NUL of dev_name because the prior memchr checked a different size. In fact the memchr(dev_name, 0, sizeof(filesys->volume_name)) both (a) ensures there is a NUL byte within the first sizeof(filesys->volume_name) bytes and (b) necessarily accessed those bytes while searching. Therefore any later strncpy of dev_name will either: - copy at most the number of bytes up to that NUL (which memchr already proved reachable), or - if strncpy is asked to copy more bytes than the NUL position, it will encounter the NUL before reaching the larger count and stop/pad. In all cases the bytes that strncpy reads are within the region memchr already accessed, so strncpy will not read beyond the bounds of the source object as used here. The only way a Rule 21.17 violation could occur is if a different check allowed memchr to inspect fewer bytes than are later read (or there is a different copy that uses an unchecked larger bound), or if the macros invoked (OS_CHECK_STRING, OS_OBJECT_INIT) behaved differently than assumed. Given the actual checks shown (OS_CHECK_STRING on phys_path and the memchr guard), the strncpy calls in this function do not cause out-of-bounds reads of the source and thus do not violate MISRA C 2023 Rule 21.17."
}