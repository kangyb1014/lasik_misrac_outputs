{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_QueueCreate_Impl:\n```c\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n    }\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n        if (errno == EINVAL)\n        {\n            OS_DEBUG(\"Your queue depth may be too large for the\\n\");\n            OS_DEBUG(\"OS to handle. Please check the msg_max\\n\");\n            OS_DEBUG(\"parameter located in /proc/sys/fs/mqueue/msg_max\\n\");\n            OS_DEBUG(\"on your Linux file system and raise it if you\\n\");\n            OS_DEBUG(\" need to or run as root\\n\");\n        }\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_QueueCreate_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_queue_internal_record_t OS_impl_queue_table[OS_MAX_QUEUES]\n...\nextern OS_queue_internal_record_t OS_queue_table[OS_MAX_QUEUES]\n...\ntypedef struct OS_object_token OS_object_token_t\n...\ntypedef struct\n{\n    mqd_t id;\n} OS_impl_queue_internal_record_t\n...\ntypedef struct\n{\n    char              queue_name[OS_MAX_API_NAME];\n    size_t            max_size;\n    osal_blockcount_t max_depth;\n} OS_queue_internal_record_t\n...\n#define OS_MAX_API_NAME 20\n...\nextern POSIX_GlobalVars_t POSIX_GlobalVars\n...\n#define OS_DEBUG(__VA_ARGS__) \n...\n#define OS_SUCCESS (0)\n...\n#define OS_ERROR (-1)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nOS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The OS_DEBUG macro is defined as empty (#define OS_DEBUG(__VA_ARGS__)), so the call OS_DEBUG(\"OS_QueueCreate Error. ...\"); compiles to a null statement. That null operation is executed but has no effect and its removal would not change program behaviour in this build configuration \u2014 therefore it is dead code and violates MISRA C 2023 Rule 2.2."
}