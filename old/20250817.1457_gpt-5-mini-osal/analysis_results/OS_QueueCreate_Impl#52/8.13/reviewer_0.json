{
  "user_message": "An agent A claimed that the following OS_QueueCreate_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueCreate_Impl.\n```c\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n    }\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n        if (errno == EINVAL)\n        {\n            OS_DEBUG(\"Your queue depth may be too large for the\\n\");\n            OS_DEBUG(\"OS to handle. Please check the msg_max\\n\");\n            OS_DEBUG(\"parameter located in /proc/sys/fs/mqueue/msg_max\\n\");\n            OS_DEBUG(\"on your Linux file system and raise it if you\\n\");\n            OS_DEBUG(\" need to or run as root\\n\");\n        }\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'queue' is declared as OS_queue_internal_record_t * but is only used for read-only access (queue->max_depth, queue->max_size, queue->queue_name). It is initialized by the expression queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token); per MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. Thus 'queue' should be declared as const OS_queue_internal_record_t * (or the OS_OBJECT_TABLE_GET macro/table should yield a pointer to const) to reflect that the pointed-to object is not modified.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueueCreate_Impl_LogProbe(const char *stage,\n                                         const OS_object_token_t *token,\n                                         OS_impl_queue_internal_record_t *impl,\n                                         OS_queue_internal_record_t *queue,\n                                         const struct mq_attr *attr,\n                                         const char *name,\n                                         mqd_t queueDesc)\n{\n    FILE *f = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"--- OS_QueueCreate_Impl probe: %s ---\\n\", stage);\n    fprintf(f, \"token ptr=%p\\n\", (const void *)token);\n    fprintf(f, \"impl ptr=%p\\n\", (void *)impl);\n    fprintf(f, \"queue ptr=%p\\n\", (void *)queue);\n\n    if (queue != NULL)\n    {\n        /* Print read-only fields which demonstrate the pointer is only used for reads */\n        fprintf(f, \"queue->max_depth=%lu\\n\", (unsigned long)queue->max_depth);\n        fprintf(f, \"queue->max_size=%lu\\n\", (unsigned long)queue->max_size);\n        fprintf(f, \"queue->queue_name=%s\\n\", (queue->queue_name != NULL) ? queue->queue_name : \"(null)\");\n    }\n\n    if (attr != NULL)\n    {\n        fprintf(f, \"attr->mq_maxmsg=%ld\\n\", (long)attr->mq_maxmsg);\n        fprintf(f, \"attr->mq_msgsize=%ld\\n\", (long)attr->mq_msgsize);\n    }\n\n    fprintf(f, \"POSIX_GlobalVars.TruncateQueueDepth=%ld\\n\", (long)POSIX_GlobalVars.TruncateQueueDepth);\n\n    if (name != NULL)\n    {\n        fprintf(f, \"generated name=%s\\n\", name);\n    }\n\n    if (queueDesc != (mqd_t)(-1))\n    {\n        fprintf(f, \"mq_open returned descriptor=%ld\\n\", (long)queueDesc);\n    }\n    else\n    {\n        fprintf(f, \"mq_open failed, errno=%d (%s)\\n\", errno, strerror(errno));\n    }\n\n    fprintf(f, \"--- end probe: %s ---\\n\\n\", stage);\n    fclose(f);\n}\n\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    /* Log state right after retrieving table entries */\n    OS_QueueCreate_Impl_LogProbe(\"after_table_lookup\", token, impl, queue, NULL, NULL, (mqd_t)(-1));\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    /* Log attributes after initial set */\n    OS_QueueCreate_Impl_LogProbe(\"after_attr_set\", token, impl, queue, &queueAttr, NULL, (mqd_t)(-1));\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n    }\n\n    /* Log attributes after possible truncation */\n    OS_QueueCreate_Impl_LogProbe(\"after_truncate_check\", token, impl, queue, &queueAttr, NULL, (mqd_t)(-1));\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n\n    /* Log the generated name */\n    OS_QueueCreate_Impl_LogProbe(\"after_name_constructed\", token, impl, queue, &queueAttr, name, (mqd_t)(-1));\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n\n    /* Log result of mq_open */\n    OS_QueueCreate_Impl_LogProbe(\"after_mq_open\", token, impl, queue, &queueAttr, name, queueDesc);\n\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n        if (errno == EINVAL)\n        {\n            OS_DEBUG(\"Your queue depth may be too large for the\\n\");\n            OS_DEBUG(\"OS to handle. Please check the msg_max\\n\");\n            OS_DEBUG(\"parameter located in /proc/sys/fs/mqueue/msg_max\\n\");\n            OS_DEBUG(\"on your Linux file system and raise it if you\\n\");\n            OS_DEBUG(\" need to or run as root\\n\");\n        }\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n    }\n\n    /* Final state log before return */\n    OS_QueueCreate_Impl_LogProbe(\"final\", token, impl, queue, &queueAttr, name, queueDesc);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueueCreate_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In this function the local pointer 'queue' is only used to read fields (queue->max_depth, queue->max_size, queue->queue_name) and is never used to modify the pointed-to object. MISRA C 2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever possible; therefore 'queue' should be declared as const OS_queue_internal_record_t *queue (or the table lookup macro should yield a pointer-to-const) to satisfy the rule. Assigning the result of OS_OBJECT_TABLE_GET (pointer-to-non-const) to a pointer-to-const is allowed, so this change is feasible here unless there are other callsites or API requirements that force a non-const type. The provided test probe does not change this conclusion (it neither exercises the function nor demonstrates any writes through 'queue'). Note: Rule 8.13 is a \u201cshould\u201d (advisory) recommendation in MISRA; if there is a documented rationale why a non-const pointer is required (e.g., API constraints, future modifications through the same pointer), that should be recorded as a deviation. Otherwise the code as shown violates the guidance and should be updated."
}