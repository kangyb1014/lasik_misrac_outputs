{
  "user_message": "An agent A claimed that the following OS_QueueCreate_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueCreate_Impl.\n```c\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n    }\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n        if (errno == EINVAL)\n        {\n            OS_DEBUG(\"Your queue depth may be too large for the\\n\");\n            OS_DEBUG(\"OS to handle. Please check the msg_max\\n\");\n            OS_DEBUG(\"parameter located in /proc/sys/fs/mqueue/msg_max\\n\");\n            OS_DEBUG(\"on your Linux file system and raise it if you\\n\");\n            OS_DEBUG(\" need to or run as root\\n\");\n        }\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'queue' is declared as OS_queue_internal_record_t * but in OS_QueueCreate_Impl it is only used to read fields (queue->max_depth, queue->max_size, queue->queue_name). According to MISRA C 2023 Rule 8.13 it should be declared as pointing to a const-qualified type (const OS_queue_internal_record_t *) since the function does not modify the pointed-to object. Note: it is safe to point a pointer-to-const at a non-const object (OS_queue_table), so the fix is to change the declaration to 'const OS_queue_internal_record_t *queue;'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueueCreate_Log(const char *fmt, ...)\n{\n    va_list args;\n    FILE *fp = fopen(\"/tmp/logs/419.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fprintf(fp, \"\\n\");\n    fflush(fp);\n    fclose(fp);\n}\n\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    OS_QueueCreate_Log(\"ENTER: OS_QueueCreate_Impl token=%p flags=%u\", (const void *)token, (unsigned)flags);\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    OS_QueueCreate_Log(\"Lookup tables -> impl=%p queue=%p\", (const void *)impl, (const void *)queue);\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n\n    /* Log the fields read from queue (this is the read-only usage reported) */\n    if (queue != NULL)\n    {\n        OS_QueueCreate_Log(\"queue->max_depth=%ld queue->max_size=%ld queue->queue_name=%s\",\n                           (long)queue->max_depth, (long)queue->max_size, (queue->queue_name != NULL) ? queue->queue_name : \"(null)\");\n    }\n    else\n    {\n        OS_QueueCreate_Log(\"queue pointer is NULL\");\n    }\n\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    OS_QueueCreate_Log(\"Initial queueAttr.mq_maxmsg=%ld mq_msgsize=%ld\", (long)queueAttr.mq_maxmsg, (long)queueAttr.mq_msgsize);\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        OS_QueueCreate_Log(\"TruncateQueueDepth active: original=%ld truncate=%ld\",\n                           (long)queueAttr.mq_maxmsg, (long)POSIX_GlobalVars.TruncateQueueDepth);\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n        OS_QueueCreate_Log(\"Truncated queueAttr.mq_maxmsg=%ld\", (long)queueAttr.mq_maxmsg);\n    }\n    else\n    {\n        OS_QueueCreate_Log(\"No truncation applied: TruncateQueueDepth=%ld queueAttr.mq_maxmsg=%ld\",\n                           (long)POSIX_GlobalVars.TruncateQueueDepth, (long)queueAttr.mq_maxmsg);\n    }\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n    OS_QueueCreate_Log(\"Constructed queue name: %s\", name);\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_QueueCreate_Log(\"mq_open failed: errno=%d (%s)\", errno, strerror(errno));\n\n        if (errno == EINVAL)\n        {\n            OS_QueueCreate_Log(\"mq_open EINVAL: possible queue depth too large (msg_max)\");\n            OS_QueueCreate_Log(\"Your queue depth may be too large for the OS to handle. Please check msg_max in /proc/sys/fs/mqueue/msg_max\");\n        }\n\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        OS_QueueCreate_Log(\"mq_open succeeded: descriptor=%ld\", (long)queueDesc);\n\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_QueueCreate_Log(\"mq_unlink failed: errno=%d (%s)\", errno, strerror(errno));\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n        else\n        {\n            OS_QueueCreate_Log(\"mq_unlink succeeded for name: %s\", name);\n        }\n\n        OS_QueueCreate_Log(\"impl->id set to %ld, return_code=%d\", (long)impl->id, (int)return_code);\n    }\n\n    OS_QueueCreate_Log(\"EXIT: OS_QueueCreate_Impl return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueueCreate_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In OS_QueueCreate_Impl the local pointer 'queue' is only used to read members (queue->max_depth, queue->max_size, queue->queue_name) and is never used to modify the pointed-to object. MISRA C:2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever possible; therefore this pointer should be declared as const OS_queue_internal_record_t *queue;. It is allowed to point a pointer-to-const at a non-const object (the object table lookup need not change), so making the pointer const does not create a semantic problem in this function. Note that the other pointer 'impl' must remain non-const because impl->id is written. The empty runtime test log does not affect the static correctness of the rule application."
}