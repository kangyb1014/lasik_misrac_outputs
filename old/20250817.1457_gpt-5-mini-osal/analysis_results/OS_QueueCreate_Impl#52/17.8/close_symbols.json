{
  "user_message": "Target function code is:\n```c\nint32 OS_QueueCreate_Impl(const OS_object_token_t *token, uint32 flags)\n{\n    int                              return_code;\n    mqd_t                            queueDesc;\n    struct mq_attr                   queueAttr;\n    char                             name[OS_MAX_API_NAME * 2];\n    OS_impl_queue_internal_record_t *impl;\n    OS_queue_internal_record_t *     queue;\n\n    impl  = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n    queue = OS_OBJECT_TABLE_GET(OS_queue_table, *token);\n\n    /* set queue attributes */\n    memset(&queueAttr, 0, sizeof(queueAttr));\n    queueAttr.mq_maxmsg  = queue->max_depth;\n    queueAttr.mq_msgsize = queue->max_size;\n\n    /*\n     * The \"TruncateQueueDepth\" indicates a soft limit to the size of a queue.\n     * If nonzero, anything larger than this will be silently truncated\n     * (Supports running applications as non-root)\n     */\n    if (POSIX_GlobalVars.TruncateQueueDepth > 0 && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg)\n    {\n        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth;\n    }\n\n    /*\n    ** Construct the queue name:\n    ** The name will consist of \"/<process_id>.queue_name\"\n    */\n    snprintf(name, sizeof(name), \"/%d.%s\", (int)getpid(), queue->queue_name);\n\n    /*\n     ** create message queue\n     */\n    queueDesc = mq_open(name, O_CREAT | O_RDWR, 0666, &queueAttr);\n    if (queueDesc == (mqd_t)(-1))\n    {\n        OS_DEBUG(\"OS_QueueCreate Error. errno = %d (%s)\\n\", errno, strerror(errno));\n        if (errno == EINVAL)\n        {\n            OS_DEBUG(\"Your queue depth may be too large for the\\n\");\n            OS_DEBUG(\"OS to handle. Please check the msg_max\\n\");\n            OS_DEBUG(\"parameter located in /proc/sys/fs/mqueue/msg_max\\n\");\n            OS_DEBUG(\"on your Linux file system and raise it if you\\n\");\n            OS_DEBUG(\" need to or run as root\\n\");\n        }\n        return_code = OS_ERROR;\n    }\n    else\n    {\n        impl->id    = queueDesc;\n        return_code = OS_SUCCESS;\n\n        /*\n         * Unlink the queue right now --\n         * queues have kernel persistence and if we do a lot of restarts (i.e. during debugging)\n         * a lot of stale message queues will collect in the system.  It is OK to unlink right now\n         * as this only affects the ability of another process to open the same queue, but we do\n         * not need that to happen anyway.\n         */\n        if (mq_unlink(name) != 0)\n        {\n            OS_DEBUG(\"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\\n\", errno, strerror(errno));\n            /* Note - since the queue is already closed, we cannot really handle this failure gracefully,\n             * The queue is no longer usable so we can't return an error and go back to the way things were.\n             * In this case we need to return OS_SUCCESS so the rest of the entry will be cleaned up.\n             */\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_QueueCreate_Impl': {'callees': ['OS_ObjectIndexFromToken'], 'callers': ['OS_QueueCreate']}, 'OS_ObjectIndexFromToken': {'callees': [], 'callers': ['OS_BinSemCreate_Impl', 'OS_BinSemDelete_Impl', 'OS_BinSemGive_Impl', 'OS_BinSemFlush_Impl', 'OS_GenericBinSemTake_Impl', 'OS_BinSemGetInfo_Impl', 'OS_ConsoleWakeup_Impl', 'OS_ConsoleTask_Entry', 'OS_ConsoleCreate_Impl', 'OS_CondVarCreate_Impl', 'OS_CondVarDelete_Impl', 'OS_CondVarUnlock_Impl', 'OS_CondVarLock_Impl', 'OS_CondVarSignal_Impl', 'OS_CondVarBroadcast_Impl', 'OS_CondVarWait_Impl', 'OS_CondVarTimedWait_Impl', 'OS_CountSemCreate_Impl', 'OS_CountSemDelete_Impl', 'OS_CountSemGive_Impl', 'OS_CountSemTake_Impl', 'OS_CountSemTimedWait_Impl', 'OS_CountSemGetInfo_Impl', 'OS_FileSysStartVolume_Impl', 'OS_FileSysMountVolume_Impl', 'OS_FileSysStatVolume_Impl', 'OS_MutSemCreate_Impl', 'OS_MutSemDelete_Impl', 'OS_MutSemGive_Impl', 'OS_MutSemTake_Impl', 'OS_QueueCreate_Impl', 'OS_QueueDelete_Impl', 'OS_QueueGet_Impl', 'OS_QueuePut_Impl', 'OS_TaskCreate_Impl', 'OS_TaskDetach_Impl', 'OS_TaskMatch_Impl', 'OS_TaskDelete_Impl', 'OS_TaskSetPriority_Impl', 'OS_TaskIdMatchSystemData_Impl', 'OS_TimeBaseLock_Impl', 'OS_TimeBaseUnlock_Impl', 'OS_TimeBase_SigWaitImpl', 'OS_TimeBaseCreate_Impl', 'OS_TimeBaseSet_Impl', 'OS_TimeBaseDelete_Impl', 'OS_ConsoleOutput_Impl', 'OS_SelectSingle_Impl', 'OS_GenericClose_Impl', 'OS_GenericSeek_Impl', 'OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_FileOpen_Impl', 'OS_DirOpen_Impl', 'OS_DirClose_Impl', 'OS_DirRead_Impl', 'OS_DirRewind_Impl', 'OS_ModuleLoad_Impl', 'OS_ModuleUnload_Impl', 'OS_ModuleSymbolLookup_Impl', 'OS_SetSocketDefaultFlags_Impl', 'OS_SocketOpen_Impl', 'OS_SocketBindAddress_Impl', 'OS_SocketListen_Impl', 'OS_SocketConnect_Impl', 'OS_SocketShutdown_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SocketSendTo_Impl', 'OS_BinSemCreate', 'OS_BinSemGetInfo', 'OS_CondVarCreate', 'OS_CondVarGetInfo', 'OS_CountSemCreate', 'OS_CountSemGetInfo', 'OS_DirectoryOpen', 'OS_OpenCreate', 'OS_rename', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_CloseFileByName', 'OS_FileSys_FindVirtMountPoint', 'OS_FileSys_Initialize', 'OS_FileSysAddFixedMap', 'OS_mount', 'OS_unmount', 'OS_FS_GetPhysDriveName', 'OS_TranslatePath', 'OS_ObjectIdFindNextMatch', 'OS_ObjectIdIteratorGetNext', 'OS_ModuleLoad', 'OS_ModuleUnload', 'OS_ModuleInfo', 'OS_ModuleSymbolLookup', 'OS_MutSemCreate', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_MutSemGetInfo', 'OS_ConsoleAPI_Init', 'OS_ConsoleWrite', 'OS_QueueCreate', 'OS_QueueGet', 'OS_QueuePut', 'OS_QueueGetInfo', 'OS_CreateSocketName', 'OS_SocketOpen', 'OS_SocketListen', 'OS_SocketBindAddress', 'OS_SocketAccept', 'OS_SocketConnect', 'OS_SocketShutdown', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketGetInfo', 'OS_TaskPrepare', 'OS_TaskCreate', 'OS_TaskDelete', 'OS_TaskSetPriority', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TimeBaseCreate', 'OS_TimeBaseSet', 'OS_TimeBaseGetInfo', 'OS_TimeBaseGetFreeRun', 'OS_TimeBase_CallbackThread', 'OS_DoTimerAdd', 'OS_TimerSet', 'OS_TimerDelete', 'OS_TimerGetInfo']}, 'OS_QueueCreate': {'callees': ['OS_printf', 'OS_ObjectIdAllocateNew', 'OS_ObjectIndexFromToken', 'OS_ObjectIdGlobalFromToken', 'OS_QueueCreate_Impl', 'OS_ObjectIdFinalizeNew', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_OBJECT_TABLE_GET",
    "OS_ObjectIndexFromToken",
    "OS_object_token_t",
    "OS_impl_queue_table",
    "OS_queue_table"
  ],
  "explanation": "To determine if the function parameter 'token' is modified you must inspect the mechanisms that consume or translate the token value in this function:\n\n- OS_OBJECT_TABLE_GET: This macro/function is used directly with '*token' (twice). Its definition/expansion must be examined to ensure it does not perform any assignment to the pointer parameter (or otherwise cause side-effects that alter the parameter). Macros can hide assignments or other side effects.\n\n- OS_ObjectIndexFromToken: The static call graph indicates this routine is involved in object/token handling (and OS_OBJECT_TABLE_GET implementations often call it). Its signature and implementation are required to verify it does not modify the token parameter or perform unexpected side effects on the token object.\n\n- OS_object_token_t: The type definition is needed to know whether '*token' is an object type or an integer/struct and whether it is legal/possible for code inlined/macro-expanded to modify the object via the token expression. It also clarifies constness semantics of what is pointed to.\n\n- OS_impl_queue_table and OS_queue_table: These table symbols are passed to OS_OBJECT_TABLE_GET and their definitions/typings show how the macro/indexing is implemented (array, accessor, or something that could write through the token expression). Knowing their declarations helps determine whether the expression '*token' may be used as an lvalue or otherwise trigger modifications.\n\nThese symbols are minimal and sufficient to analyze whether any call/macro used with '*token' could modify either the pointer parameter or the object it points to, which is what the MISRA rule requires checking."
}