{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe macro itself does not call any <string.h> functions, but it delegates to LENGTHCHECK which commonly uses strlen/strspn. If LENGTHCHECK is implemented like: if (strlen(str) >= maxlen) { return errcode; } then calling strlen on a non-terminated/too-long input will read past the bounds of the referenced object and violate MISRA C 2023 Rule 21.17. For example, if str points to a buffer of length N which is not NUL-terminated within maxlen, strlen(str) can access bytes beyond the object. A safe implementation would use a bounded operation such as strnlen(str, maxlen) (and compare the result) or otherwise ensure the maximum reachable length is enforced before calling unbounded string functions.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_mount code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1463.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_mount as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_mount:\n```c\nint32 OS_mount(const char *devname, const char *mountpoint)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_STRING(devname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(mountpoint, sizeof(filesys->virtual_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /*\n         * READY flag should be set (mkfs/initfs must have been called on this FS)\n         * MOUNTED SYSTEM/VIRTUAL should always be unset.\n         *\n         * FIXED flag _should_ always be unset (these don't support mount/unmount)\n         * but to support abstraction this is not enforced.\n         */\n        if ((filesys->flags & ~OS_FILESYS_FLAG_IS_FIXED) != OS_FILESYS_FLAG_IS_READY)\n        {\n            /* mount() cannot be used on this file system at this time */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if (filesys->system_mountpt[0] == 0)\n        {\n            /*\n             * The system mount point should be a non-empty string.\n             */\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            return_code = OS_FileSysMountVolume_Impl(&token);\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* mark as mounted in the local table.\n             * For now this does both sides (system and virtual) */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n            strncpy(filesys->virtual_mountpt, mountpoint, sizeof(filesys->virtual_mountpt) - 1);\n            filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = 0;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_mount code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n/* Probe helpers for logging. These are intentionally lightweight and avoid\n * calling unbounded string functions on caller-provided pointers (devname,\n * mountpoint) to avoid introducing new violations. They log pointer values\n * and length limits used by the checks, and later log the validated\n * filesys record contents once the record pointer is available.\n */\nstatic void probe_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\n\nstatic void probe_log_fmt(const char *fmt, void *p1, size_t v1, void *p2, size_t v2)\n{\n    FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n    if (f)\n    {\n        /* Log two pointer/size pairs in a single line */\n        fprintf(f, fmt, p1, (unsigned long)v1, p2, (unsigned long)v2);\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\n/* Log initial parameters to OS_mount before any string library checks run.\n * This intentionally does NOT attempt to read the pointed-to strings, it\n * only logs the pointer values and the maximum lengths used for bounds\n * checking, to allow reproducing that LENGTHCHECK/OS_CHECK_STRING was\n * invoked with these parameters.\n */\nstatic void probe_before_checks(const char *devname, const char *mountpoint, size_t devname_maxlen, size_t mountpoint_maxlen)\n{\n    probe_log(\"OS_mount: entering\");\n    probe_log_fmt(\"OS_mount: check-string devname ptr=%p maxlen=%lu, mountpoint ptr=%p maxlen=%lu\",\n                  (void *)devname, devname_maxlen, (void *)mountpoint, mountpoint_maxlen);\n}\n\n/* Log the filesys internal record state after a successful lookup. This is\n * safe because 'filesys' points into the local object table (an in-process\n * structure), so reading its fixed-size character arrays using memcpy is\n * bounded by sizeof(the array) rather than by the external caller-provided\n * strings. The content is truncated to a local buffer for logging.\n */\nstatic void probe_after_getbyname(void *filesys_void /* actual type is OS_filesys_internal_record_t * */, int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n    if (!f) return;\n\n    fprintf(f, \"OS_mount: after OS_ObjectIdGetByName, return_code=%d, filesys_ptr=%p\\n\", (int)return_code, filesys_void);\n\n    if (filesys_void == NULL)\n    {\n        fprintf(f, \"OS_mount: filesys pointer is NULL\\n\");\n        fclose(f);\n        return;\n    }\n\n    /* We cannot refer to the concrete type here directly (to avoid\n     * introducing assumptions about the full struct); but in the caller\n     * context we do have that type and will provide a typed probe below.\n     * This generic probe just notes that a non-NULL pointer was obtained. */\n    fclose(f);\n}\n\n/* The modified OS_mount with inserted probes. Note: keeps original logic\n * and original calls (including OS_CHECK_STRING). The probes are placed so\n * they do not call unsafe unbounded string functions on caller-provided\n * pointers.\n */\nint32 OS_mount(const char *devname, const char *mountpoint)\n{\n    int32                         return_code;\n    OS_object_token_t             token;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Probe: log parameters and the compile-time sizes used by the checks.\n     * sizeof(filesys->device_name) and sizeof(filesys->virtual_mountpt)\n     * do not dereference 'filesys' and are valid to compute here. */\n    probe_before_checks(devname, mountpoint,\n                        sizeof(filesys->device_name),\n                        sizeof(filesys->virtual_mountpt));\n\n    /* Check parameters */\n    OS_CHECK_STRING(devname, sizeof(filesys->device_name), OS_FS_ERR_PATH_TOO_LONG);\n    OS_CHECK_STRING(mountpoint, sizeof(filesys->virtual_mountpt), OS_FS_ERR_PATH_TOO_LONG);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Additional detailed probe now that filesys points to a valid record.\n         * Log flags, system_mountpt and virtual_mountpt safely by copying\n         * bounded numbers of bytes (the arrays are part of the local record).\n         */\n        {\n            FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n            if (f)\n            {\n                fprintf(f, \"OS_mount: filesys record at %p\\n\", (void *)filesys);\n                fprintf(f, \"OS_mount: filesys->flags = 0x%08x\\n\", (unsigned)filesys->flags);\n\n                /* Safely copy system_mountpt and virtual_mountpt into local\n                 * buffers for logging. Use sizeof on the member types which\n                 * is compile-time known and bounded. */\n                char sysbuf[256];\n                size_t syssz = (sizeof(filesys->system_mountpt) < sizeof(sysbuf) - 1) ? sizeof(filesys->system_mountpt) : sizeof(sysbuf) - 1;\n                memcpy(sysbuf, filesys->system_mountpt, syssz);\n                sysbuf[syssz] = '\\0';\n\n                char virtbuf[256];\n                size_t virtsz = (sizeof(filesys->virtual_mountpt) < sizeof(virtbuf) - 1) ? sizeof(filesys->virtual_mountpt) : sizeof(virtbuf) - 1;\n                memcpy(virtbuf, filesys->virtual_mountpt, virtsz);\n                virtbuf[virtsz] = '\\0';\n\n                fprintf(f, \"OS_mount: filesys->system_mountpt (truncated) = '%s'\\n\", sysbuf);\n                fprintf(f, \"OS_mount: filesys->virtual_mountpt (before mount) (truncated) = '%s'\\n\", virtbuf);\n\n                fclose(f);\n            }\n        }\n\n        /*\n         * READY flag should be set (mkfs/initfs must have been called on this FS)\n         * MOUNTED SYSTEM/VIRTUAL should always be unset.\n         *\n         * FIXED flag _should_ always be unset (these don't support mount/unmount)\n         * but to support abstraction this is not enforced.\n         */\n        if ((filesys->flags & ~OS_FILESYS_FLAG_IS_FIXED) != OS_FILESYS_FLAG_IS_READY)\n        {\n            /* mount() cannot be used on this file system at this time */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n\n            probe_log(\"OS_mount: aborting - incorrect object state\");\n        }\n        else if (filesys->system_mountpt[0] == 0)\n        {\n            /*\n             * The system mount point should be a non-empty string.\n             */\n            return_code = OS_FS_ERR_PATH_INVALID;\n\n            probe_log(\"OS_mount: aborting - system_mountpt empty/invalid\");\n        }\n        else\n        {\n            return_code = OS_FileSysMountVolume_Impl(&token);\n\n            {\n                FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n                if (f)\n                {\n                    fprintf(f, \"OS_mount: OS_FileSysMountVolume_Impl returned %d\\n\", (int)return_code);\n                    fclose(f);\n                }\n            }\n        }\n\n        if (return_code == OS_SUCCESS)\n        {\n            /* mark as mounted in the local table.\n             * For now this does both sides (system and virtual) */\n            filesys->flags |= OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM | OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL;\n\n            /* Preserve original behavior of copying mountpoint into the\n             * filesys table. This uses strncpy as in the original code. */\n            strncpy(filesys->virtual_mountpt, mountpoint, sizeof(filesys->virtual_mountpt) - 1);\n            filesys->virtual_mountpt[sizeof(filesys->virtual_mountpt) - 1] = 0;\n\n            /* Log the new virtual_mountpt safely (bounded by sizeof member). */\n            {\n                FILE *f = fopen(\"/tmp/logs/1463.txt\", \"a\");\n                if (f)\n                {\n                    char virtbuf2[256];\n                    size_t virtsz2 = (sizeof(filesys->virtual_mountpt) < sizeof(virtbuf2) - 1) ? sizeof(filesys->virtual_mountpt) : sizeof(virtbuf2) - 1;\n                    memcpy(virtbuf2, filesys->virtual_mountpt, virtsz2);\n                    virtbuf2[virtsz2] = '\\0';\n                    fprintf(f, \"OS_mount: filesys marked mounted, new virtual_mountpt (truncated) = '%s'\\n\", virtbuf2);\n                    fprintf(f, \"OS_mount: filesys->flags after mount = 0x%08x\\n\", (unsigned)filesys->flags);\n                    fclose(f);\n                }\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n\n        probe_log(\"OS_mount: final return - name not found / error path\");\n    }\n\n    /* Final return (unchanged) */\n    return return_code;\n}\n"
}