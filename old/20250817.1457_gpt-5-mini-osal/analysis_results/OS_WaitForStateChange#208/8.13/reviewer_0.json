{
  "user_message": "An agent A claimed that the following OS_WaitForStateChange code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_WaitForStateChange.\n```c\nvoid OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts)\n{\n    osal_key_t          saved_unlock_key;\n    OS_objtype_state_t *objtype;\n\n    /*\n     * This needs to release the lock, to allow other\n     * tasks to make a change to the table.  But to avoid\n     * ownership warnings the key must also be temporarily\n     * cleared too, and restored after waiting.\n     */\n\n    objtype          = &OS_objtype_state[token->obj_type];\n    saved_unlock_key = objtype->owner_key;\n\n    /* temporarily release the table */\n    objtype->owner_key = OS_LOCK_KEY_INVALID;\n\n    /*\n     * The implementation layer takes care of the actual unlock + wait.\n     * This permits use of condition variables where these two actions\n     * are done atomically.\n     */\n    OS_WaitForStateChange_Impl(token->obj_type, attempts);\n\n    /*\n     * After return, this task owns the table again\n     */\n    /* cppcheck-suppress redundantAssignment */\n    objtype->owner_key = saved_unlock_key;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_WaitForStateChange takes a non-const pointer parameter (OS_object_token_t *token) but only reads from the pointed object (uses token->obj_type). The pointer could and should be declared const OS_object_token_t *token to indicate immutability and satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned int uint32;\ntypedef unsigned int osal_key_t;\ntypedef struct\n{\n    unsigned int obj_type;\n    /* Other members are not required for this test / function. */\n} OS_object_token_t;\nstatic const osal_key_t OS_LOCK_KEY_INVALID = (osal_key_t)0u;\nvoid OS_WaitForStateChange_Impl(unsigned int obj_type, uint32 attempts)\n{\n    FILE *f = fopen(\"/tmp/logs/1667.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"OS_WaitForStateChange_Impl called: obj_type=%u, attempts=%u\\n\", obj_type, (unsigned)attempts);\n        fclose(f);\n    }\n}\nstatic void log_append(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1667.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts)\n{\n    osal_key_t          saved_unlock_key;\n    OS_objtype_state_t *objtype;\n\n    /* Log function entry and token information (address and obj_type). */\n    if (token == NULL)\n    {\n        log_append(\"OS_WaitForStateChange entry: token=NULL, attempts=%u\", (unsigned)attempts);\n        return;\n    }\n\n    log_append(\"OS_WaitForStateChange entry: token=%p, token->obj_type=%u, attempts=%u\",\n               (void *)token, (unsigned)token->obj_type, (unsigned)attempts);\n\n    /*\n     * This needs to release the lock, to allow other\n     * tasks to make a change to the table.  But to avoid\n     * ownership warnings the key must also be temporarily\n     * cleared too, and restored after waiting.\n     */\n\n    if (token->obj_type >= OS_OBJTYPE_MAX)\n    {\n        log_append(\"OS_WaitForStateChange: token->obj_type out of range: %u\", (unsigned)token->obj_type);\n        return;\n    }\n\n    objtype          = &OS_objtype_state[token->obj_type];\n    saved_unlock_key = objtype->owner_key;\n\n    /* Log the saved owner key prior to modification */\n    log_append(\"Read objtype (index=%u) owner_key before release: %u\",\n               (unsigned)token->obj_type, (unsigned)saved_unlock_key);\n\n    /* temporarily release the table */\n    objtype->owner_key = OS_LOCK_KEY_INVALID;\n\n    /* Log the owner_key after it has been set to invalid */\n    log_append(\"objtype (index=%u) owner_key after release set to: %u\",\n               (unsigned)token->obj_type, (unsigned)objtype->owner_key);\n\n    /*\n     * The implementation layer takes care of the actual unlock + wait.\n     * This permits use of condition variables where these two actions\n     * are done atomically.\n     */\n    log_append(\"About to call OS_WaitForStateChange_Impl with obj_type=%u, attempts=%u\",\n               (unsigned)token->obj_type, (unsigned)attempts);\n\n    OS_WaitForStateChange_Impl(token->obj_type, attempts);\n\n    /*\n     * After return, this task owns the table again\n     */\n    /* cppcheck-suppress redundantAssignment */\n    objtype->owner_key = saved_unlock_key;\n\n    /* Log the restoration of the owner_key and function exit */\n    log_append(\"objtype (index=%u) owner_key restored to: %u\",\n               (unsigned)token->obj_type, (unsigned)objtype->owner_key);\n\n    log_append(\"OS_WaitForStateChange exit: token=%p, token->obj_type=%u\",\n               (void *)token, (unsigned)token->obj_type);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown implementation OS_WaitForStateChange the parameter token is only read (token->obj_type is used to index OS_objtype_state and passed to OS_WaitForStateChange_Impl); there are no writes through token. MISRA C 2023 Rule 8.13 requires a pointer to be to a const-qualified type whenever possible, so the parameter should be declared as const OS_object_token_t *token (unless there is some external API compatibility reason preventing that). The inability to compile the provided test harness does not change the fact that, for the code shown, marking the pointer const is feasible and would satisfy the rule. Potential exceptions would be deliberate API constraints or callers that rely on a non-const prototype, but none are evident in the presented code."
}