{
  "user_message": "Target function code is:\n```c\nvoid OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts)\n{\n    osal_key_t          saved_unlock_key;\n    OS_objtype_state_t *objtype;\n\n    /*\n     * This needs to release the lock, to allow other\n     * tasks to make a change to the table.  But to avoid\n     * ownership warnings the key must also be temporarily\n     * cleared too, and restored after waiting.\n     */\n\n    objtype          = &OS_objtype_state[token->obj_type];\n    saved_unlock_key = objtype->owner_key;\n\n    /* temporarily release the table */\n    objtype->owner_key = OS_LOCK_KEY_INVALID;\n\n    /*\n     * The implementation layer takes care of the actual unlock + wait.\n     * This permits use of condition variables where these two actions\n     * are done atomically.\n     */\n    OS_WaitForStateChange_Impl(token->obj_type, attempts);\n\n    /*\n     * After return, this task owns the table again\n     */\n    /* cppcheck-suppress redundantAssignment */\n    objtype->owner_key = saved_unlock_key;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_WaitForStateChange': {'callees': ['OS_WaitForStateChange_Impl'], 'callers': ['OS_ObjectIdConvertToken']}, 'OS_WaitForStateChange_Impl': {'callees': [], 'callers': ['OS_WaitForStateChange']}, 'OS_ObjectIdConvertToken': {'callees': ['OS_ObjectIdGlobalFromToken', 'OS_ObjectIdFromToken', 'OS_ObjectIdIsValid', 'OS_ObjectIdEqual', 'OS_WaitForStateChange', 'OS_Unlock_Global'], 'callers': ['OS_ObjectIdGetBySearch', 'OS_ObjectIdGetById', 'OS_ObjectIdAllocateNew']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_object_token_t (definition, including the obj_type member)",
    "uint32 (typedef)",
    "osal_key_t (typedef)",
    "OS_objtype_state (struct definition, including owner_key member)",
    "OS_objtype_state (global array/variable)",
    "OS_LOCK_KEY_INVALID (macro/constant definition)",
    "OS_WaitForStateChange_Impl (function prototype/declaration including any attributes)"
  ],
  "explanation": "To determine whether the target function uses any compiler language extensions you must inspect any referenced types, globals, macros, and callees that could hide extension usage. Reason for each symbol:\n\n- OS_object_token_t (definition, including the obj_type member): The code indexes token->obj_type into OS_objtype_state. You must see the token type and obj_type declaration to check for non-standard extensions (bit-fields with implementation-defined layout, anonymous/unnamed struct/union members, or compiler-specific attributes on the field).\n\n- uint32 (typedef): This is not a standard C type name; inspect its typedef to ensure it is a standard C typedef (e.g., to uint32_t) and not a compiler-specific extended type.\n\n- osal_key_t (typedef): owner_key and saved_unlock_key use this type. The typedef could be a compiler extension (e.g., aliasing to a nonstandard integer kind, extended integer width, or have attributes). Its definition is needed to confirm no extensions.\n\n- OS_objtype_state (struct definition, including owner_key member): The code accesses objtype->owner_key and takes the address of an element. The struct definition may contain anonymous structs/unions, compiler attributes, bit-fields, or other extensions that would violate the MISRA rule.\n\n- OS_objtype_state (global array/variable): The symbol used as an array (OS_objtype_state[token->obj_type]) must be inspected for its declaration (e.g., extern definition, special linkage, or attributes such as section placement, visibility, or compiler-specific storage class modifiers).\n\n- OS_LOCK_KEY_INVALID (macro/constant definition): This macro may expand to compiler-specific syntax or use casts/attributes that are extensions. Checking its definition ensures it is standard C.\n\n- OS_WaitForStateChange_Impl (function prototype/declaration including any attributes): The callee may be declared with compiler-specific function attributes (e.g., __attribute__((...)), calling convention modifiers, noreturn, weak, inline semantics) that are language extensions; the prototype must be inspected for such annotations.\n\nCollecting these symbols (their declarations/definitions) allows checking for GCC/MSVC/other compiler-specific attributes, anonymous/unnamed language constructs, nonstandard integer types, or other extensions that would violate the MISRA rule about language extensions."
}