{
  "user_message": "Target function code is:\n```c\nvoid OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts)\n{\n    osal_key_t          saved_unlock_key;\n    OS_objtype_state_t *objtype;\n\n    /*\n     * This needs to release the lock, to allow other\n     * tasks to make a change to the table.  But to avoid\n     * ownership warnings the key must also be temporarily\n     * cleared too, and restored after waiting.\n     */\n\n    objtype          = &OS_objtype_state[token->obj_type];\n    saved_unlock_key = objtype->owner_key;\n\n    /* temporarily release the table */\n    objtype->owner_key = OS_LOCK_KEY_INVALID;\n\n    /*\n     * The implementation layer takes care of the actual unlock + wait.\n     * This permits use of condition variables where these two actions\n     * are done atomically.\n     */\n    OS_WaitForStateChange_Impl(token->obj_type, attempts);\n\n    /*\n     * After return, this task owns the table again\n     */\n    /* cppcheck-suppress redundantAssignment */\n    objtype->owner_key = saved_unlock_key;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_WaitForStateChange': {'callees': ['OS_WaitForStateChange_Impl'], 'callers': ['OS_ObjectIdConvertToken']}, 'OS_WaitForStateChange_Impl': {'callees': [], 'callers': ['OS_WaitForStateChange']}, 'OS_ObjectIdConvertToken': {'callees': ['OS_ObjectIdGlobalFromToken', 'OS_ObjectIdFromToken', 'OS_ObjectIdIsValid', 'OS_ObjectIdEqual', 'OS_WaitForStateChange', 'OS_Unlock_Global'], 'callers': ['OS_ObjectIdGetBySearch', 'OS_ObjectIdGetById', 'OS_ObjectIdAllocateNew']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_object_token_t",
    "uint32",
    "OS_objtype_state_t",
    "OS_objtype_state",
    "osal_key_t",
    "OS_LOCK_KEY_INVALID",
    "OS_WaitForStateChange_Impl"
  ],
  "explanation": "OS_object_token_t: Needed to see the definition of the parameter 'token' (its type and members). In particular the type and semantics of token->obj_type must be known to confirm that the function only reads a member and does not assign to the pointer parameter itself.\n\nuint32: Needed to confirm the type of the 'attempts' parameter (to verify no implicit modification or aliasing of the parameter occurs via conversions or macros).\n\nOS_objtype_state_t: The element type of the OS_objtype_state array. Required to inspect the owner_key member and to ensure that operations on *objtype are modifications of the pointed-to object (allowed) rather than modifications of the parameter variable 'token' (disallowed).\n\nOS_objtype_state: The global array or variable being indexed with token->obj_type. Required to confirm that the expression &OS_objtype_state[token->obj_type] does not involve any side effects that modify the parameter 'token' or the pointer value.\n\nosal_key_t: Type of saved_unlock_key and objtype->owner_key. Needed to confirm the semantics of the assignments to owner_key (that they are ordinary assignments to a field of the object obtained via token->obj_type, i.e., modification of the pointed-to object\u2014not of the parameter pointer).\n\nOS_LOCK_KEY_INVALID: The constant written into objtype->owner_key. Included to confirm it is a simple constant and that writing it is not implemented as a macro or function that could modify the parameter pointer.\n\nOS_WaitForStateChange_Impl: The prototype/implementation is required to ensure the call OS_WaitForStateChange_Impl(token->obj_type, attempts) cannot modify the 'token' parameter (for example via macros or global side-effects tied to the call). Although only token->obj_type is passed, the implementation could have hidden dependencies; inspecting it verifies that the pointer parameter itself is not modified indirectly.\n\nThese symbols together allow checking (a) whether any assignment to the parameter variable 'token' occurs, (b) whether only the object pointed to by token is modified (permitted), and (c) whether any called/expanded symbol could indirectly modify the parameter pointer (which would violate the MISRA rule)."
}