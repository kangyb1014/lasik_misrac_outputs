{
  "user_message": "An agent A claimed that the following OS_QueueGetIdByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGetIdByName.\n```c\nint32 OS_QueueGetIdByName(osal_id_t *queue_id, const char *queue_name)\n{\n    int32 return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_POINTER(queue_name);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, queue_name, queue_id);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_QueueGetIdByName only checks that queue_name is non-NULL (OS_CHECK_POINTER) and then passes it to OS_ObjectIdFindByName. That callee uses LENGTHCHECK/ARGCHECK which likely invoke string functions (e.g. strlen/strcmp). If the caller supplies a non-NULL pointer that is not a NUL-terminated string or points to a buffer shorter than the expected maximum, those string functions can read past the object bounds. Therefore the call can lead to out-of-bounds access by string.h routines.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_probe(const char *phase, const void *queue_id_ptr, const void *queue_name_ptr, int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1863.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log: phase, pointer values, and return code (if meaningful). Do not print queue_name as a string. */\n    fprintf(f, \"%s: queue_id=%p queue_name_ptr=%p return_code=%d\\n\",\n            phase, queue_id_ptr, queue_name_ptr, (int)return_code);\n    fflush(f);\n    fclose(f);\n}\n\nint32 OS_QueueGetIdByName(osal_id_t *queue_id, const char *queue_name)\n{\n    int32 return_code;\n\n    /* Entry probe */\n    os_log_probe(\"ENTRY\", (const void *)queue_id, (const void *)queue_name, 0);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_POINTER(queue_name);\n\n    /* After parameter checks probe */\n    os_log_probe(\"AFTER_CHECKS\", (const void *)queue_id, (const void *)queue_name, 0);\n\n    /* About to call the resolver that may use string.h routines */\n    os_log_probe(\"BEFORE_CALL\", (const void *)queue_id, (const void *)queue_name, 0);\n\n    return_code = OS_ObjectIdFindByName(LOCAL_OBJID_TYPE, queue_name, queue_id);\n\n    /* After call probe: capture the return code from the callee */\n    os_log_probe(\"AFTER_CALL\", (const void *)queue_id, (const void *)queue_name, (int32_t)return_code);\n\n    /* Final return probe */\n    os_log_probe(\"RETURN\", (const void *)queue_id, (const void *)queue_name, (int32_t)return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: queue_id=(nil) queue_name_ptr=0x5597b19a1ecb return_code=0\nENTRY: queue_id=0x7ffd0abde09c queue_name_ptr=(nil) return_code=0\nENTRY: queue_id=0x7ffd0abde09c queue_name_ptr=0x7ffd0abde0a0 return_code=0\nAFTER_CHECKS: queue_id=0x7ffd0abde09c queue_name_ptr=0x7ffd0abde0a0 return_code=0\nBEFORE_CALL: queue_id=0x7ffd0abde09c queue_name_ptr=0x7ffd0abde0a0 return_code=0\nAFTER_CALL: queue_id=0x7ffd0abde09c queue_name_ptr=0x7ffd0abde0a0 return_code=-13\nRETURN: queue_id=0x7ffd0abde09c queue_name_ptr=0x7ffd0abde0a0 return_code=-13\nENTRY: queue_id=0x7ffd0abde09c queue_name_ptr=0x5597b19a1f50 return_code=0\nAFTER_CHECKS: queue_id=0x7ffd0abde09c queue_name_ptr=0x5597b19a1f50 return_code=0\nBEFORE_CALL: queue_id=0x7ffd0abde09c queue_name_ptr=0x5597b19a1f50 return_code=0\nAFTER_CALL: queue_id=0x7ffd0abde09c queue_name_ptr=0x5597b19a1f50 return_code=-17\nRETURN: queue_id=0x7ffd0abde09c queue_name_ptr=0x5597b19a1f50 return_code=-17\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. OS_QueueGetIdByName itself does not call any <string.h> routines \u2014 it only checks the pointers for non-NULL (OS_CHECK_POINTER) and delegates the name handling to OS_ObjectIdFindByName. MISRA Rule 21.17 concerns uses of the string handling functions that can access beyond object bounds. That obligation can be satisfied by the callee that actually examines the string. The supplied exhaustive test traces show the function progressed through the parameter checks and that OS_ObjectIdFindByName returned error codes (e.g. -13, -17) rather than any out\u2011of\u2011bounds behavior or crash. Those return codes indicate the resolver validated the argument and handled invalid/non-terminated inputs safely. Given the test evidence and that no string.h routines are used in OS_QueueGetIdByName itself, the claim that this function violates MISRA C 2023 Rule 21.17 is incorrect."
}