{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe parameter 'arg' is declared as void * but is not used to modify the pointed-to object; per MISRA C 2023 Rule 8.13 it should be const-qualified (i.e. const void *arg) when possible. Note: if this function must match an external thread-entry API (e.g. pthreads) that requires void *(*)(void *), then the non-const signature is unavoidable and the rule cannot be applied here.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ConsoleTask_Entry code that contains useful probe functions that print useful logs to a file \"/tmp/logs/171.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ConsoleTask_Entry as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ConsoleTask_Entry:\n```c\nstatic void *OS_ConsoleTask_Entry(void *arg)\n{\n    OS_VoidPtrValueWrapper_t           local_arg;\n    OS_impl_console_internal_record_t *local;\n    OS_object_token_t                  token;\n\n    /* cppcheck-suppress unreadVariable // intentional use of other union member */\n    local_arg.opaque_arg = arg;\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_CONSOLE, local_arg.id, &token) == OS_SUCCESS)\n    {\n        local = OS_OBJECT_TABLE_GET(OS_impl_console_table, token);\n\n        /* Loop forever (unless shutdown is set) */\n        while (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n        {\n            OS_ConsoleOutput_Impl(&token);\n            sem_wait(&local->data_sem);\n        }\n        OS_ObjectIdRelease(&token);\n    }\n    return NULL;\n}\n```\n</target_code>\nPlease provide the modified OS_ConsoleTask_Entry code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n/* Probe logging helpers: append human-readable trace to /tmp/logs/171.txt */\nstatic void OS_ConsoleTask_Logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/171.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fflush(f);\n    fclose(f);\n}\n\nstatic void OS_ConsoleTask_LogEvent(const char *event, void *arg, unsigned long id, int res, unsigned long global, unsigned int iter)\n{\n    /* event: short tag; arg: original opaque pointer; id: interpreted id value; res: result code (-1 if N/A);\n       global: snapshot of OS_SharedGlobalVars.GlobalState; iter: loop iteration count */\n    OS_ConsoleTask_Logf(\"[%s] arg=%p id=%lu res=%d global=0x%lx iter=%u\",\n                        event, arg, id, res, global, iter);\n}\n\nstatic void *OS_ConsoleTask_Entry(void *arg)\n{\n    OS_VoidPtrValueWrapper_t           local_arg;\n    OS_impl_console_internal_record_t *local;\n    OS_object_token_t                  token;\n\n    /* Log entry and the opaque pointer value. This helps demonstrate the violation scenario\n       where the parameter is declared void * but not used to modify the pointed-to object. */\n    local_arg.opaque_arg = arg;\n    OS_ConsoleTask_LogEvent(\"ENTER\", arg, (unsigned long)local_arg.id, -1, (unsigned long)OS_SharedGlobalVars.GlobalState, 0);\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_CONSOLE, local_arg.id, &token) == OS_SUCCESS)\n    {\n        int result = OS_SUCCESS;\n        local = OS_OBJECT_TABLE_GET(OS_impl_console_table, token);\n\n        /* Loop forever (unless shutdown is set) */\n        unsigned int iter = 0u;\n        while (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n        {\n            /* Log before producing console output; record iteration and current GlobalState snapshot. */\n            OS_ConsoleTask_LogEvent(\"LOOP_START\", arg, (unsigned long)local_arg.id, result, (unsigned long)OS_SharedGlobalVars.GlobalState, iter);\n\n            OS_ConsoleOutput_Impl(&token);\n\n            /* Log immediately before waiting on the semaphore so callers can see sequencing. */\n            OS_ConsoleTask_LogEvent(\"BEFORE_SEM_WAIT\", arg, (unsigned long)local_arg.id, result, (unsigned long)OS_SharedGlobalVars.GlobalState, iter);\n\n            sem_wait(&local->data_sem);\n\n            /* Log after sem_wait unblocks (if it does) to capture sequencing. */\n            OS_ConsoleTask_LogEvent(\"AFTER_SEM_WAIT\", arg, (unsigned long)local_arg.id, result, (unsigned long)OS_SharedGlobalVars.GlobalState, iter);\n\n            ++iter;\n        }\n        OS_ConsoleTask_LogEvent(\"SHUTDOWN\", arg, (unsigned long)local_arg.id, result, (unsigned long)OS_SharedGlobalVars.GlobalState, iter);\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        /* Log failure to acquire token so callers can reproduce the path where the function\n           receives a void * but does not modify the pointed-to data. */\n        OS_ConsoleTask_LogEvent(\"GETBYID_FAILED\", arg, (unsigned long)local_arg.id, -1, (unsigned long)OS_SharedGlobalVars.GlobalState, 0);\n    }\n    return NULL;\n}\n"
}