{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nOS_ObjectIdFindNextMatch is called with arg pointing at devname which was validated only against OS_MAX_PATH_LEN (64) via OS_CHECK_PATHNAME. If the object-name matching function (e.g. OS_ObjectNameMatch) uses string.h routines that assume/copy into an internal name buffer sized by OS_MAX_API_NAME (20) or otherwise does not bound operations by the actual buffer sizes, then a devname longer than OS_MAX_API_NAME (but <= OS_MAX_PATH_LEN) can cause string functions (strcpy, strlen, memcpy, etc.) to access beyond the bounds of the destination/source. Because the code permits a larger input length (64) than the likely object-name buffer (20) and passes the pointer through to the match routine, this can result in out-of-bounds accesses of string handling functions.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_rmfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1471.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_rmfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_rmfs:\n```c\nint32 OS_rmfs(const char *devname)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(devname);\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, devname, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * NOTE: It is likely that if the file system is mounted,\n         * this call to stop the volume will fail.\n         *\n         * It would be prudent to first check the flags to ensure that\n         * the filesystem is unmounted first, but this would break\n         * compatibility with the existing unit tests.\n         */\n        return_code = OS_FileSysStopVolume_Impl(&token);\n\n        /* Free the entry in the master table  */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_rmfs code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n\n/* Probe helpers for logging control flow and state to /tmp/logs/1471.txt */\nstatic void ensure_log_dir(void)\n{\n    /* Try to create the directory; ignore error if it already exists. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n}\n\nstatic void append_log(const char *fmt, ...)\n{\n    ensure_log_dir();\n    FILE *f = fopen(\"/tmp/logs/1471.txt\", \"a\");\n    if (!f) return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic void append_log_devname(const char *tag, const char *devname)\n{\n    ensure_log_dir();\n    FILE *f = fopen(\"/tmp/logs/1471.txt\", \"a\");\n    if (!f) return;\n\n    /* Use strnlen to avoid reading beyond an unexpectedly unterminated buffer. */\n    size_t max_capture = 256; /* capture at most 256 bytes for logging */\n    size_t len = strnlen(devname, max_capture);\n\n    fprintf(f, \"%s: devname ptr=%p, len_reported=%zu, content=\\\"\", tag, (const void *)devname, len);\n    if (len > 0)\n    {\n        fwrite(devname, 1, len, f);\n    }\n    if (len == max_capture)\n    {\n        fprintf(f, \"...\");\n    }\n    fprintf(f, \"\\\"\");\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Original function with inserted probes. */\nint32 OS_rmfs(const char *devname)\n{\n    int32             return_code;\n    OS_object_token_t token;\n\n    /* Log entry and the incoming devname pointer/length safely */\n    append_log(\"OS_rmfs: entry\");\n    if (devname == NULL)\n    {\n        append_log(\"OS_rmfs: devname is NULL\");\n    }\n    else\n    {\n        append_log_devname(\"OS_rmfs: incoming\", devname);\n    }\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(devname);\n\n    append_log(\"OS_rmfs: after OS_CHECK_PATHNAME\");\n\n    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, devname, &token);\n\n    append_log(\"OS_rmfs: OS_ObjectIdGetByName returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token raw bytes (size may vary); do not assume contents. */\n        {\n            FILE *f = fopen(\"/tmp/logs/1471.txt\", \"a\");\n            if (f)\n            {\n                fprintf(f, \"OS_rmfs: token addr=%p, sizeof(token)=%zu\\n\", (void *)&token, sizeof(token));\n                /* Write a hex dump of the token for later inspection */\n                const unsigned char *p = (const unsigned char *)&token;\n                size_t i;\n                fprintf(f, \"OS_rmfs: token bytes=\");\n                for (i = 0; i < sizeof(token); ++i)\n                {\n                    fprintf(f, \"%02X\", (unsigned)p[i]);\n                }\n                fprintf(f, \"\\n\");\n                fclose(f);\n            }\n        }\n\n        /*\n         * NOTE: It is likely that if the file system is mounted,\n         * this call to stop the volume will fail.\n         *\n         * It would be prudent to first check the flags to ensure that\n         * the filesystem is unmounted first, but this would break\n         * compatibility with the existing unit tests.\n         */\n        append_log(\"OS_rmfs: calling OS_FileSysStopVolume_Impl\");\n        return_code = OS_FileSysStopVolume_Impl(&token);\n        append_log(\"OS_rmfs: OS_FileSysStopVolume_Impl returned %d\", (int)return_code);\n\n        /* Free the entry in the master table  */\n        append_log(\"OS_rmfs: calling OS_ObjectIdFinalizeDelete with return_code=%d\", (int)return_code);\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        append_log(\"OS_rmfs: OS_ObjectIdFinalizeDelete returned %d\", (int)return_code);\n    }\n    else\n    {\n        append_log(\"OS_rmfs: name not found, setting return_code=OS_ERR_NAME_NOT_FOUND\");\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    append_log(\"OS_rmfs: exit with return_code=%d\", (int)return_code);\n    return return_code;\n}\n"
}