{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation: strncmp(target, filesys->virtual_mountpt, mplen) uses mplen derived from filesys->virtual_mountpt (OS_strnlen(...)). While this guarantees mplen is <= sizeof(filesys->virtual_mountpt) (and the filesys buffer is safe), there is no check that the 'target' string (the caller-supplied name) has at least mplen bytes accessible. If target is shorter than mplen (e.g. filesys->virtual_mountpt = \"/mnt/virtual\" with mplen = 12 and target = \"/mnt\" length 4), strncmp will attempt to read up to mplen bytes from target and can read beyond the bounds of the target object, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_chkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1439.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_chkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_chkfs:\n```c\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_chkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n/*\n * Probe helpers: these functions append diagnostic logs to /tmp/logs/1439.txt.\n * They are intentionally conservative and use safe bounded operations to avoid\n * introducing any new undefined behavior or buffer overruns.\n */\nstatic void OS_chkfs_log_open_context(const char *name)\n{\n    FILE *f = fopen(\"/tmp/logs/1439.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"--- OS_chkfs ENTRY ---\\n\");\n    fprintf(f, \"name pointer: %p\\n\", (const void *)name);\n\n    /* Safe bounded length probe for the caller-supplied name (target) */\n    if (name == NULL)\n    {\n        fprintf(f, \"name: NULL\\n\");\n    }\n    else\n    {\n        size_t safe_len = strnlen(name, 1024U); /* bound to avoid long traversal */\n        fprintf(f, \"name_len (strnlen bound 1024) = %zu\\n\", safe_len);\n\n        /* Print a preview of the name up to a limited number of characters */\n        fprintf(f, \"name_preview: '\");\n        for (size_t i = 0U; i < safe_len && i < 256U; ++i)\n        {\n            int c = (unsigned char)name[i];\n            /* print as-is; non-printables still get written as bytes */\n            fputc(c, f);\n        }\n        if (safe_len > 256U)\n        {\n            fprintf(f, \"...\");\n        }\n        fprintf(f, \"'\\n\");\n    }\n\n    fclose(f);\n}\n\nstatic void OS_chkfs_log_event(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen(\"/tmp/logs/1439.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * Original function preserved. Added probes to log the control flow and state\n * relevant to the reported Rule 21.17 violation scenario. The probes do NOT\n * change the logic or side-effects of the original function.\n */\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Probe: log entry and caller-supplied name details */\n    OS_chkfs_log_open_context(name);\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    OS_chkfs_log_event(\"Calling OS_ObjectIdGetBySearch with name=%p\", (const void *)name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    OS_chkfs_log_event(\"OS_ObjectIdGetBySearch returned %ld\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log that token was acquired. Do not read token internals to avoid\n         * potential ABI/structure assumptions; just log its address/value. */\n        OS_chkfs_log_event(\"Acquired token at %p\", (void *)&token);\n\n        OS_chkfs_log_event(\"Calling OS_FileSysCheckVolume_Impl with repair=%d\", (int)repair);\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n        OS_chkfs_log_event(\"OS_FileSysCheckVolume_Impl returned %ld\", (long)return_code);\n\n        OS_ObjectIdRelease(&token);\n        OS_chkfs_log_event(\"Released token at %p\", (void *)&token);\n    }\n\n    OS_chkfs_log_event(\"OS_chkfs returning %ld\", (long)return_code);\n    return return_code;\n}\n"
}