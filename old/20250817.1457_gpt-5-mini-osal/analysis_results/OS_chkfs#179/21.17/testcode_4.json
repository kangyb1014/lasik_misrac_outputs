{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf the passed-in name is shorter than the filesystem virtual_mountpt length (mplen), then OS_FileSys_FindVirtMountPoint will call strncmp(target, filesys->virtual_mountpt, mplen) and later access target[mplen]. If OS_CHECK_PATHNAME does not guarantee that name has at least mplen+1 accessible bytes (it typically only checks upper bound and null-termination), these operations can read beyond the bounds of the object referenced by name, so Rule 21.17 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_chkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1439.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_chkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_chkfs:\n```c\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_chkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n/* Probe logging helpers for OS_chkfs. These functions are kept minimal and\n * do not alter program control flow. They attempt to create /tmp/logs if\n * missing and append human-readable state info to /tmp/logs/1439.txt.\n * The code intentionally limits string inspections to avoid reads beyond\n * the first N bytes (using strnlen).\n */\nstatic void OS_chkfs_log_open(FILE **out)\n{\n    /* Try to create the directory if it doesn't exist. Ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    *out = fopen(\"/tmp/logs/1439.txt\", \"a\");\n}\n\nstatic void OS_chkfs_log_state(const char *phase, const char *name, int return_code)\n{\n    FILE *fp = NULL;\n    OS_chkfs_log_open(&fp);\n    if (fp == NULL)\n    {\n        /* Logging not available; do nothing. */\n        return;\n    }\n\n    /* Limit how much of 'name' we inspect to avoid reading unbounded memory.\n     * This uses strnlen so it will stop at a null terminator or the limit.\n     */\n    const size_t MAX_INSPECT = 256;\n    size_t nlen = 0;\n    if (name != NULL)\n    {\n        nlen = strnlen(name, MAX_INSPECT);\n    }\n\n    fprintf(fp, \"[OS_chkfs] phase=%s name_ptr=%p name_len=%zu return_code=%d\\n\",\n            phase, (void *)name, nlen, return_code);\n\n    if (name != NULL && nlen > 0)\n    {\n        /* Print a safe, limited preview of the name (printable chars or hex). */\n        fprintf(fp, \"[OS_chkfs] name_preview=\\\"\");\n        for (size_t i = 0; i < nlen && i < 64; ++i)\n        {\n            unsigned char c = (unsigned char)name[i];\n            if (c >= 32 && c < 127)\n            {\n                fputc((int)c, fp);\n            }\n            else\n            {\n                fprintf(fp, \"\\\\x%02x\", c);\n            }\n        }\n        if (nlen > 64)\n        {\n            fprintf(fp, \"...(%zu bytes truncated)\", nlen - 64);\n        }\n        fprintf(fp, \"\\\"\\n\");\n    }\n\n    fflush(fp);\n    fclose(fp);\n}\n\n/* Modified OS_chkfs: inserts probes but preserves original logic. */\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Log state after pathname check (name should be NUL-terminated if check passed). */\n    OS_chkfs_log_state(\"after_OS_CHECK_PATHNAME\", name, 0);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    /* Log outcome of the search call and the input state. */\n    OS_chkfs_log_state(\"after_OS_ObjectIdGetBySearch\", name, (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log that we obtained the token and are about to check the volume. */\n        OS_chkfs_log_state(\"before_OS_FileSysCheckVolume_Impl\", name, (int)return_code);\n\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        /* Log result of the volume check. */\n        OS_chkfs_log_state(\"after_OS_FileSysCheckVolume_Impl\", name, (int)return_code);\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after releasing the token. */\n        OS_chkfs_log_state(\"after_OS_ObjectIdRelease\", name, (int)return_code);\n    }\n\n    return return_code;\n}\n"
}