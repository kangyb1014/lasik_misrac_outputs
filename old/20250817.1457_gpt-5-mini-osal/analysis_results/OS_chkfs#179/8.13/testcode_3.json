{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe call casts the const char * name to a plain void *: (void *)name. This discards the const qualifier (name points to const char) when passing it to OS_ObjectIdGetBySearch(void *arg), violating MISRA C 2023 Rule 8.13. In this code the match function (OS_FileSys_FindVirtMountPoint) only reads the string (it treats ref as a const char *), so the correct fix is to propagate constness: change the match-func and OS_ObjectIdGetBySearch prototypes (OS_ObjectMatchFunc_t) to accept const void *arg (and the match function to take const void *ref), and then call OS_ObjectIdGetBySearch without casting.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_chkfs code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1435.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_chkfs as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_chkfs:\n```c\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(name);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_chkfs code.\n",
  "test_code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/* Minimal type aliases to match the original environment */\ntypedef int32_t int32;\n\n/* Opaque token type used by the OS object layer. */\ntypedef struct\n{\n    int dummy;\n} OS_object_token_t;\n\n/* External symbols from the surrounding system (declared here so this file compiles\n * as a translation unit for testing/logging purposes). These are NOT defined here. */\nextern int32 OS_ObjectIdGetBySearch(int32 lock_mode, int32 obj_type, void *match_func, void *arg, OS_object_token_t *token);\nextern int32 OS_FileSysCheckVolume_Impl(OS_object_token_t *token, bool repair);\nextern void   OS_ObjectIdRelease(OS_object_token_t *token);\nextern void   OS_CHECK_PATHNAME(const char *name);\n\n/* Configuration tokens/constants from the OS layer (declared as extern so linking\n * happens in the real system). */\nextern const int32 OS_LOCK_MODE_REFCOUNT;\nextern const int32 LOCAL_OBJID_TYPE;\nextern const int32 OS_SUCCESS;\n\n/*\n * Probe helper: append a structured log entry to /tmp/logs/1435.txt. This function\n * is deliberately small and conservative (it does not change program state other\n * than writing the log file). It is intended to document the control flow and the\n * pointers/values involved in the violation scenario for later analysis.\n */\nstatic void OS_chkfs_log_probe(const char *stage, const char *name, void *casted_arg, const OS_object_token_t *token, int32 return_code)\n{\n    FILE *fp = fopen(\"/tmp/logs/1435.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails we silently continue to avoid changing original behavior. */\n        return;\n    }\n\n    /* Print a compact but informative record: stage, name (if available), pointer values,\n     * token address, and return code. Uses uintptr_t to print pointer values portably. */\n    uintptr_t name_ptr = (uintptr_t)name;\n    uintptr_t arg_ptr  = (uintptr_t)casted_arg;\n    uintptr_t token_ptr = (uintptr_t)token;\n\n    fprintf(fp, \"OS_chkfs: stage=%s\\n\", stage);\n    if (name != NULL)\n    {\n        /* Print the supplied pathname and its pointer value. */\n        fprintf(fp, \"  name=\"\"%s\"\"\\n\", name);\n    }\n    else\n    {\n        fprintf(fp, \"  name=(NULL)\\n\");\n    }\n\n    fprintf(fp, \"  name_ptr=0x%\" PRIxPTR \"\\n\", name_ptr);\n    fprintf(fp, \"  casted_arg( (void *)name )=0x%\" PRIxPTR \"\\n\", arg_ptr);\n    fprintf(fp, \"  token_address=0x%\" PRIxPTR \"\\n\", token_ptr);\n    fprintf(fp, \"  return_code=%d\\n\", (int)return_code);\n    fprintf(fp, \"---\\n\");\n\n    fclose(fp);\n}\n\n/*\n * Modified OS_chkfs function with logging probes inserted. The original logic is\n * preserved: parameter checking, the call to OS_ObjectIdGetBySearch (including the\n * cast (void *)name that discards const), handling of success case, and return of\n * the return code. The probes record the key data needed to reproduce and examine\n * the violation scenario.\n */\nint32 OS_chkfs(const char *name, bool repair)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Parameter check (kept as in original). This is declared extern above so that\n     * the real implementation in the system is used at link time. */\n    OS_CHECK_PATHNAME(name);\n\n    /* Log the input and the fact that a cast is about to happen. This captures the\n     * pointer value and the string contents so tools/agents can later inspect that\n     * a const-qualified pointer was cast to a plain void* when passed below. */\n    OS_chkfs_log_probe(\"before_ObjectIdGetBySearch\", name, (void *)name, &token, -1);\n\n    /* Get a reference lock, as a filesystem check could take some time. Note the\n     * explicit cast (void *)name is preserved here; it is the operation that\n     * discards the const qualifier and is central to the reported MISRA Rule 8.13\n     * violation scenario. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)name, &token);\n\n    /* Log the result of the search call and the token address. */\n    OS_chkfs_log_probe(\"after_ObjectIdGetBySearch\", name, (void *)name, &token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log before invoking the volume check implementation. */\n        OS_chkfs_log_probe(\"before_FileSysCheckVolume_Impl\", name, (void *)name, &token, return_code);\n\n        return_code = OS_FileSysCheckVolume_Impl(&token, repair);\n\n        /* Log after volume check (token still valid until released). */\n        OS_chkfs_log_probe(\"after_FileSysCheckVolume_Impl\", name, (void *)name, &token, return_code);\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log after token release so callers can see the full lifecycle recorded. */\n        OS_chkfs_log_probe(\"after_ObjectIdRelease\", name, (void *)name, &token, return_code);\n    }\n\n    return return_code;\n}\n"
}