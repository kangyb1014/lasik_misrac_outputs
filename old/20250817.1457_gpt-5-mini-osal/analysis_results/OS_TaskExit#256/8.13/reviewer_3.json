{
  "user_message": "An agent A claimed that the following OS_TaskExit code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_TaskExit.\n```c\nvoid OS_TaskExit()\n{\n    osal_id_t         task_id;\n    OS_object_token_t token;\n\n    task_id = OS_TaskGetId_Impl();\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token) == OS_SUCCESS)\n    {\n        OS_TaskDetach_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token);\n    }\n\n    /* call the implementation */\n    OS_TaskExit_Impl();\n\n    /* Impl function never returns */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the function OS_ObjectIdFinalizeDelete has the prototype OS_Status_t OS_ObjectIdFinalizeDelete(OS_Status_t status, OS_object_token_t *token) (i.e. pointer to non-const) but the function does not modify the object referred to by token, then the pointer parameter should be const-qualified (const OS_object_token_t *). In that case the call OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token); indicates a violation of Rule 8.13 because a pointer is not pointing to a const-qualified type when it could be.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log_printf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2051.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void probe_log_token_bytes(const char *label, const void *token, size_t token_size)\n{\n    FILE *f = fopen(\"/tmp/logs/2051.txt\", \"a\");\n    if (f == NULL || token == NULL)\n    {\n        if (f) fclose(f);\n        return;\n    }\n\n    fprintf(f, \"%s: token_ptr=%#lx token_size=%zu bytes=\", label, (unsigned long)(uintptr_t)token, token_size);\n\n    const unsigned char *p = (const unsigned char *)token;\n    size_t max = token_size;\n    if (max > 64) /* cap the number of bytes printed */\n    {\n        max = 64;\n    }\n\n    for (size_t i = 0; i < max; ++i)\n    {\n        fprintf(f, \"%02X\", p[i]);\n    }\n\n    if (token_size > max)\n    {\n        fprintf(f, \"..(truncated)\");\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid OS_TaskExit()\n{\n    osal_id_t         task_id;\n    OS_object_token_t token;\n\n    task_id = OS_TaskGetId_Impl();\n    probe_log_printf(\"OS_TaskExit: obtained task_id=%u\", (unsigned)task_id);\n\n    if (OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, task_id, &token) == OS_SUCCESS)\n    {\n        probe_log_printf(\"OS_TaskExit: OS_ObjectIdGetById succeeded for task_id=%u\", (unsigned)task_id);\n        /* Log the token state before any operations */\n        probe_log_token_bytes(\"OS_TaskExit: token before detach\", &token, sizeof(token));\n\n        probe_log_printf(\"OS_TaskExit: calling OS_TaskDetach_Impl(&token) with token_ptr=%#lx\", (unsigned long)(uintptr_t)&token);\n        OS_TaskDetach_Impl(&token);\n        probe_log_printf(\"OS_TaskExit: returned from OS_TaskDetach_Impl(&token)\");\n\n        /* Complete the operation via the common routine */\n        probe_log_printf(\"OS_TaskExit: calling OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token) with token_ptr=%#lx\", (unsigned long)(uintptr_t)&token);\n        probe_log_token_bytes(\"OS_TaskExit: token before finalize\", &token, sizeof(token));\n\n        OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token);\n\n        probe_log_printf(\"OS_TaskExit: returned from OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token)\");\n        probe_log_token_bytes(\"OS_TaskExit: token after finalize\", &token, sizeof(token));\n    }\n    else\n    {\n        probe_log_printf(\"OS_TaskExit: OS_ObjectIdGetById failed for task_id=%u\", (unsigned)task_id);\n    }\n\n    /* call the implementation */\n    probe_log_printf(\"OS_TaskExit: calling OS_TaskExit_Impl() - this function should not return\");\n    OS_TaskExit_Impl();\n\n    /* Impl function never returns */\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TaskExit. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 8.13 says that pointer types should be const-qualified when possible (i.e. when the pointee is not modified). The code fragment shown only shows a call: OS_ObjectIdFinalizeDelete(OS_SUCCESS, &token);. A violation of Rule 8.13 would exist only if the function\u2019s declared parameter type is non-const even though the function\u2019s implementation does not (and need not) modify the object. You have not provided the declaration/definition of OS_ObjectIdFinalizeDelete, so you cannot determine from this call site alone whether the rule is violated.\n\nConcretely:\n- The call site passing &token to a function taking OS_object_token_t * is not itself a Rule 8.13 violation. The rule concerns whether pointer types in declarations/definitions should be const-qualified where possible.\n- To establish a real violation you must inspect the prototype and implementation of OS_ObjectIdFinalizeDelete. If its parameter is declared as OS_object_token_t * but the function never modifies the token (and it is logically an input-only parameter), then the function prototype should be changed to take const OS_object_token_t * and that would be the violation to correct. If the function does modify the token (or may modify it in some code path), then the non-const parameter is appropriate and there is no Rule 8.13 issue.\n- The test/probe code and empty log do not provide evidence about whether OS_ObjectIdFinalizeDelete modifies its argument.\n\nTherefore the agent A\u2019s report \u2014 which asserts a Rule 8.13 violation based solely on this call \u2014 is not supported by the provided information."
}