{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code calls strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) without validating either pointer or guaranteeing NUL-termination. The stored ContentTypeStr is set from a caller-provided pointer in UT_Stub_RegisterReturnType and may be NULL, dangling (e.g. pointer to a stack buffer that went out of scope), or point to a non-terminated buffer. Example violation: a test registers the return type with a local buffer (char name[16]; UT_Stub_RegisterReturnType(..., name)), the function returns (name is no longer valid), and later UT_Stub_GetReturnValuePtr invokes strcmp on the dangling pointer \u2014 strcmp can read beyond the object bounds leading to undefined behavior.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryRewind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1223.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryRewind as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryRewind:\n```c\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirRewind_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryRewind code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n/*\n * Probe / logging helpers to capture control flow and state relevant to\n * the reported strcmp/content-type pointer violation scenario.\n * Logs are appended to /tmp/logs/1223.txt so other agents can inspect\n * pointer values and control flow without introducing new undefined behavior.\n *\n * These helper functions intentionally do NOT dereference caller-provided\n * pointers (except for NULL checks) to avoid creating new UB. They record\n * addresses and basic properties so a reproducer can correlate events with\n * later unsafe strcmp calls.\n */\n\nstatic void UT_Probe_LogEvent_Header(FILE *f)\n{\n    if (!f) return;\n    fprintf(f, \"---- UT Probe Log Entry ----\\n\");\n}\n\n/* Log a generic event with a textual tag and the numeric id passed into\n * OS_DirectoryRewind. Does not alter program logic.\n */\nstatic void UT_Probe_LogDirRewindCall(osal_id_t dir_id, int32 return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"OS_DirectoryRewind called: dir_id=%\" PRIu64 \", initial_return_code=%d\\n\",\n            (uint64_t)(uintptr_t)dir_id, (int)return_code);\n    fclose(f);\n}\n\n/* Log information about the two pointers involved in the reported strcmp\n * (TypeName and ContentTypeStr). Only pointer values and NULL check are\n * recorded to avoid dereferencing potentially dangling pointers.\n *\n * Callers that want to capture buffer contents for reproduction should pass\n * stable, valid buffers; these probes will still only log addresses and the\n * fact that they're non-NULL. This prevents introducing new UB while giving\n * reproducible evidence (addresses, ordering, and presence/absence) of the\n * problematic pointers.\n */\nvoid UT_Probe_LogCompareState(const char *context, const char *TypeName, const char *ContentTypeStr)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"Context: %s\\n\", context ? context : \"(null)\");\n    fprintf(f, \"  TypeName pointer: %p  (%s)\\n\", (const void *)TypeName,\n            (TypeName == NULL) ? \"NULL\" : \"non-NULL\");\n    fprintf(f, \"  ContentTypeStr pointer: %p  (%s)\\n\", (const void *)ContentTypeStr,\n            (ContentTypeStr == NULL) ? \"NULL\" : \"non-NULL\");\n\n    /* Heuristic warning: if either pointer is NULL, record that strcmp would crash\n     * if used without checking. If both non-NULL, record that strcmp may still\n     * read beyond the object bounds if ContentTypeStr is not NUL-terminated\n     * or is dangling.\n     */\n    if (TypeName == NULL || ContentTypeStr == NULL)\n    {\n        fprintf(f, \"  WARNING: One or more pointers are NULL. Unsafe strcmp(TypeName, ContentTypeStr) would be invalid.\\n\");\n    }\n    else\n    {\n        fprintf(f, \"  NOTE: Both pointers non-NULL. strcmp(TypeName, ContentTypeStr) may still be unsafe if either is non-terminated or dangling.\\n\");\n    }\n\n    fclose(f);\n}\n\n/* Log that an unsafe strcmp is about to be performed with the given pointers.\n * This function is intended to be invoked right before the actual unsafe call\n * in order to provide a timestamped record showing the exact arguments that\n * were used when the violation occurred.\n */\nvoid UT_Probe_LogAboutToCallStrcmp(const char *TypeName, const char *ContentTypeStr)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"About to call strcmp(TypeName, ContentTypeStr)\\n\");\n    fprintf(f, \"  TypeName ptr=%p (%s)\\n\", (const void *)TypeName, (TypeName==NULL)?\"NULL\":\"non-NULL\");\n    fprintf(f, \"  ContentTypeStr ptr=%p (%s)\\n\", (const void *)ContentTypeStr, (ContentTypeStr==NULL)?\"NULL\":\"non-NULL\");\n    fprintf(f, \"  ACTION: This probe does NOT perform the strcmp. It only logs state so a reproducer can compare timings and arguments.\\n\");\n\n    fclose(f);\n}\n\n/* Original OS_DirectoryRewind implementation preserved, with lightweight\n * probes inserted to log entry and exit states. The logic and return value\n * semantics are unchanged.\n */\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry with dir_id. Use a sentinel initial return code value (-1)\n     * until OS_ObjectIdGetById sets the real value.\n     */\n    UT_Probe_LogDirRewindCall(dir_id, -1);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log that we are about to invoke the implementation layer. */\n        FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n        if (f)\n        {\n            UT_Probe_LogEvent_Header(f);\n            fprintf(f, \"OS_DirectoryRewind: OS_ObjectIdGetById returned OS_SUCCESS; calling OS_DirRewind_Impl. dir_id=%\" PRIu64 \"\\n\",\n                    (uint64_t)(uintptr_t)dir_id);\n            fclose(f);\n        }\n\n        return_code = OS_DirRewind_Impl(&token);\n    }\n\n    /* Log the exit return code so callers can correlate with other logged events. */\n    UT_Probe_LogDirRewindCall(dir_id, return_code);\n\n    return return_code;\n}\n"
}