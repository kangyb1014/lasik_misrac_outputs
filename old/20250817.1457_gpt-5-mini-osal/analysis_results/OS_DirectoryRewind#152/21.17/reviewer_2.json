{
  "user_message": "An agent A claimed that the following OS_DirectoryRewind code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_DirectoryRewind.\n```c\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirRewind_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) without validating either pointer or guaranteeing NUL-termination. The stored ContentTypeStr is set from a caller-provided pointer in UT_Stub_RegisterReturnType and may be NULL, dangling (e.g. pointer to a stack buffer that went out of scope), or point to a non-terminated buffer. Example violation: a test registers the return type with a local buffer (char name[16]; UT_Stub_RegisterReturnType(..., name)), the function returns (name is no longer valid), and later UT_Stub_GetReturnValuePtr invokes strcmp on the dangling pointer \u2014 strcmp can read beyond the object bounds leading to undefined behavior.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_Probe_LogEvent_Header(FILE *f)\n{\n    if (!f) return;\n    fprintf(f, \"---- UT Probe Log Entry ----\\n\");\n}\nstatic void UT_Probe_LogDirRewindCall(osal_id_t dir_id, int32 return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"OS_DirectoryRewind called: dir_id=%\" PRIu64 \", initial_return_code=%d\\n\",\n            (uint64_t)(uintptr_t)dir_id, (int)return_code);\n    fclose(f);\n}\nvoid UT_Probe_LogCompareState(const char *context, const char *TypeName, const char *ContentTypeStr)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"Context: %s\\n\", context ? context : \"(null)\");\n    fprintf(f, \"  TypeName pointer: %p  (%s)\\n\", (const void *)TypeName,\n            (TypeName == NULL) ? \"NULL\" : \"non-NULL\");\n    fprintf(f, \"  ContentTypeStr pointer: %p  (%s)\\n\", (const void *)ContentTypeStr,\n            (ContentTypeStr == NULL) ? \"NULL\" : \"non-NULL\");\n\n    /* Heuristic warning: if either pointer is NULL, record that strcmp would crash\n     * if used without checking. If both non-NULL, record that strcmp may still\n     * read beyond the object bounds if ContentTypeStr is not NUL-terminated\n     * or is dangling.\n     */\n    if (TypeName == NULL || ContentTypeStr == NULL)\n    {\n        fprintf(f, \"  WARNING: One or more pointers are NULL. Unsafe strcmp(TypeName, ContentTypeStr) would be invalid.\\n\");\n    }\n    else\n    {\n        fprintf(f, \"  NOTE: Both pointers non-NULL. strcmp(TypeName, ContentTypeStr) may still be unsafe if either is non-terminated or dangling.\\n\");\n    }\n\n    fclose(f);\n}\nvoid UT_Probe_LogAboutToCallStrcmp(const char *TypeName, const char *ContentTypeStr)\n{\n    FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n    if (!f) return;\n\n    UT_Probe_LogEvent_Header(f);\n    fprintf(f, \"About to call strcmp(TypeName, ContentTypeStr)\\n\");\n    fprintf(f, \"  TypeName ptr=%p (%s)\\n\", (const void *)TypeName, (TypeName==NULL)?\"NULL\":\"non-NULL\");\n    fprintf(f, \"  ContentTypeStr ptr=%p (%s)\\n\", (const void *)ContentTypeStr, (ContentTypeStr==NULL)?\"NULL\":\"non-NULL\");\n    fprintf(f, \"  ACTION: This probe does NOT perform the strcmp. It only logs state so a reproducer can compare timings and arguments.\\n\");\n\n    fclose(f);\n}\n\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry with dir_id. Use a sentinel initial return code value (-1)\n     * until OS_ObjectIdGetById sets the real value.\n     */\n    UT_Probe_LogDirRewindCall(dir_id, -1);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log that we are about to invoke the implementation layer. */\n        FILE *f = fopen(\"/tmp/logs/1223.txt\", \"a\");\n        if (f)\n        {\n            UT_Probe_LogEvent_Header(f);\n            fprintf(f, \"OS_DirectoryRewind: OS_ObjectIdGetById returned OS_SUCCESS; calling OS_DirRewind_Impl. dir_id=%\" PRIu64 \"\\n\",\n                    (uint64_t)(uintptr_t)dir_id);\n            fclose(f);\n        }\n\n        return_code = OS_DirRewind_Impl(&token);\n    }\n\n    /* Log the exit return code so callers can correlate with other logged events. */\n    UT_Probe_LogDirRewindCall(dir_id, return_code);\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the provided OS_DirectoryRewind code. MISRA C:2023 Rule 21.17 concerns use of <string.h> functions (e.g. strcmp) that may access beyond object bounds. The target function OS_DirectoryRewind and the supplied modified variant do not call any string.h functions \u2014 they only call OS_ObjectIdGetById, OS_DirRewind_Impl and use I/O functions (fprintf/fopen) for logging. The scenario described by agent A refers to a strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) usage in a different stub/UT helper and to UT_Stub_RegisterReturnType/UT_Stub_GetReturnValuePtr, which are not present in the OS_DirectoryRewind code shown. Without evidence that OS_DirectoryRewind (or a function it definitely calls) invokes a string.h routine on unchecked/possibly dangling/non-NUL-terminated pointers, there is no basis to claim a Rule 21.17 violation for this function. Note: if OS_DirRewind_Impl (called indirectly) contained an unchecked strcmp on caller-provided pointers, that could be a Rule 21.17 violation, but no such code or trace was provided. Also the test probe code did not compile, so it could not demonstrate the alleged runtime scenario."
}