{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nIf the implementation prototype is declared as OS_DirRewind_Impl(OS_object_token_t *token) (i.e. a pointer to a non-const type) but the function does not modify the token, then the pointer should instead point to a const-qualified type. In that situation the call return_code = OS_DirRewind_Impl(&token); violates MISRA C 2023 Rule 8.13 because a non-const pointer is used where a const-qualified pointer would be appropriate. If, however, OS_DirRewind_Impl is declared to take const OS_object_token_t * or the function legitimately modifies the token, then there is no violation.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DirectoryRewind code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1219.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DirectoryRewind as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DirectoryRewind:\n```c\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_DirRewind_Impl(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DirectoryRewind code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n/*\n * Probe logging helper: append formatted entries to /tmp/logs/1219.txt\n */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1219.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* Forward declarations for external functions used by this module.\n * The actual definitions are provided elsewhere in the codebase.  We do\n * not change their signatures here; we only add logging around their use.\n */\nextern int32 OS_ObjectIdGetById(int lock_mode, int local_obj_type, osal_id_t id, OS_object_token_t *token);\nextern int32 OS_DirRewind_Impl(OS_object_token_t *token);\n\nint32 OS_DirectoryRewind(osal_id_t dir_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry point. Cast dir_id to unsigned long long for generic printing;\n     * this is only for diagnostic logging and should not affect program logic.\n     */\n    probe_log(\"OS_DirectoryRewind: entry (dir_id=%llu)\", (unsigned long long)dir_id);\n\n    /* Make sure the file descriptor is legit before using it */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, dir_id, &token);\n    probe_log(\"OS_ObjectIdGetById returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Capture token raw bytes before call */\n        {\n            unsigned char *bytes_before = (unsigned char *)&token;\n            size_t bytes_len = sizeof(token);\n\n            /* Build a hex representation of the token bytes */\n            char *hex_before = (char *)malloc(bytes_len * 2 + 1);\n            if (hex_before != NULL)\n            {\n                for (size_t i = 0; i < bytes_len; ++i)\n                {\n                    unsigned int val = bytes_before[i];\n                    unsigned int idx = (unsigned int)i;\n                    sprintf(&hex_before[idx * 2], \"%02X\", val);\n                }\n                hex_before[bytes_len * 2] = '\\0';\n                probe_log(\"Token before OS_DirRewind_Impl: addr=%p len=%zu data=%s\", (void *)&token, bytes_len, hex_before);\n                free(hex_before);\n            }\n            else\n            {\n                probe_log(\"Token before: addr=%p len=%zu (hex alloc failed)\", (void *)&token, bytes_len);\n            }\n        }\n\n        probe_log(\"Calling OS_DirRewind_Impl with token addr=%p\", (void *)&token);\n        return_code = OS_DirRewind_Impl(&token);\n        probe_log(\"OS_DirRewind_Impl returned %d\", (int)return_code);\n\n        /* Capture token raw bytes after call and compare */\n        {\n            unsigned char *bytes_after = (unsigned char *)&token;\n            size_t bytes_len = sizeof(token);\n\n            char *hex_after = (char *)malloc(bytes_len * 2 + 1);\n            if (hex_after != NULL)\n            {\n                for (size_t i = 0; i < bytes_len; ++i)\n                {\n                    unsigned int val = bytes_after[i];\n                    unsigned int idx = (unsigned int)i;\n                    sprintf(&hex_after[idx * 2], \"%02X\", val);\n                }\n                hex_after[bytes_len * 2] = '\\0';\n                probe_log(\"Token after  OS_DirRewind_Impl: addr=%p len=%zu data=%s\", (void *)&token, bytes_len, hex_after);\n\n                /* Compare before/after by re-creating the before-hex to detect modifications */\n                /* Recreate before sequence to compare in-memory rather than strings */\n                /* (We already freed the before buffer; do a raw memcmp instead by re-reading) */\n\n                /* Reconstruct raw bytes from the printed after hex is only used for logging; do a memcmp against a fresh snapshot is more direct.\n                 * For simplicity, re-obtain a fresh snapshot of the token (in-place) and compare with the hex_after content (which came from the same snapshot)\n                 * However, the crucial part is that the logs contain both a before and after hex dump so an external agent can determine whether a modification occurred.\n                 */\n\n                free(hex_after);\n            }\n            else\n            {\n                probe_log(\"Token after: addr=%p len=%zu (hex alloc failed)\", (void *)&token, bytes_len);\n            }\n        }\n\n        /* Attempt to detect modification directly: create two byte snapshots and compare them. */\n        {\n            size_t bytes_len = sizeof(token);\n            unsigned char *snap_before = (unsigned char *)malloc(bytes_len);\n            unsigned char *snap_after  = (unsigned char *)malloc(bytes_len);\n\n            if (snap_before != NULL && snap_after != NULL)\n            {\n                /* Re-run OS_ObjectIdGetById to rebuild the before-snapshot would be intrusive; instead,\n                 * we re-create the before-snapshot by reading the log file. The log contains the hex of the\n                 * before state, so external agents can compare. Here we only perform an in-memory comparison\n                 * using the current snapshot (after) and the original before snapshot if we had saved it.\n                 * To avoid altering behavior, we do not attempt to re-populate snap_before from external sources.\n                 * Instead we still provide a best-effort local comparison: copy current token to snap_after and\n                 * mark that external log comparison is the authoritative evidence.\n                 */\n                memcpy(snap_after, &token, bytes_len);\n\n                /* Mark in the log that external comparison should be used to determine modification. */\n                probe_log(\"Note: raw before/after hex dumps are recorded above. External agent should compare them to detect token modification.\");\n\n                free(snap_before);\n                free(snap_after);\n            }\n            else\n            {\n                if (snap_before) free(snap_before);\n                if (snap_after) free(snap_after);\n                probe_log(\"Failed to allocate working snapshot buffers for modification detection\");\n            }\n        }\n    }\n\n    probe_log(\"OS_DirectoryRewind: exit with return_code=%d\", (int)return_code);\n    return return_code;\n}\n"
}