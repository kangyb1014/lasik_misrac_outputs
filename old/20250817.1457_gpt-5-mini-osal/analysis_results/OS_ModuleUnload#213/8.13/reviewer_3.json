{
  "user_message": "An agent A claimed that the following OS_ModuleUnload code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ModuleUnload.\n```c\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            return_code = OS_ModuleUnload_Impl(&token);\n        }\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'module' is declared as a mutable pointer (OS_module_internal_record_t *module) but is only used for read access (module->module_type) and never modifies the pointed-at object. According to MISRA C 2023 Rule 8.13, it should be declared to point to a const-qualified type whenever possible (e.g. const OS_module_internal_record_t *module).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ModuleUnload_Log(const char *stage,\n                                osal_id_t module_id,\n                                const OS_module_internal_record_t *module,\n                                int32 return_code,\n                                const OS_object_token_t *token)\n{\n    FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n    if (f != NULL)\n    {\n        fprintf(f, \"OS_ModuleUnload: %s\\n\", stage);\n        fprintf(f, \"  module_id=%lu\\n\", (unsigned long)module_id);\n        fprintf(f, \"  token_addr=%p\\n\", (const void *)token);\n        fprintf(f, \"  return_code=%ld\\n\", (long)return_code);\n        if (module != NULL)\n        {\n            fprintf(f, \"  module_ptr=%p\\n\", (const void *)module);\n            /* Print the module_type value observed (read-only observation) */\n            fprintf(f, \"  module->module_type=%lu\\n\", (unsigned long)module->module_type);\n            /* Indicate whether the dynamic branch will be taken */\n            if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n            {\n                fprintf(f, \"  branch: module is DYNAMIC\\n\");\n            }\n            else\n            {\n                fprintf(f, \"  branch: module is NOT DYNAMIC\\n\");\n            }\n        }\n        else\n        {\n            fprintf(f, \"  module_ptr=(null)\\n\");\n        }\n        fprintf(f, \"--\\n\");\n        fclose(f);\n    }\n}\n\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    /* Log entry state */\n    OS_ModuleUnload_Log(\"entry_before_GetById\", module_id, NULL, 0, NULL);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of lookup */\n    OS_ModuleUnload_Log(\"after_GetById\", module_id, NULL, return_code, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /* Log after resolving the module pointer */\n        OS_ModuleUnload_Log(\"after_table_get\", module_id, module, return_code, &token);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            OS_ModuleUnload_Log(\"before_unload_impl\", module_id, module, return_code, &token);\n            return_code = OS_ModuleUnload_Impl(&token);\n            OS_ModuleUnload_Log(\"after_unload_impl\", module_id, module, return_code, &token);\n        }\n\n        /* Complete the operation via the common routine */\n        OS_ModuleUnload_Log(\"before_finalize\", module_id, module, return_code, &token);\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        OS_ModuleUnload_Log(\"after_finalize\", module_id, module, return_code, &token);\n    }\n\n    OS_ModuleUnload_Log(\"exit\", module_id, NULL, return_code, NULL);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ModuleUnload. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown OS_ModuleUnload implementation the local pointer module is only used for read-only access (module->module_type) and is never used to modify the object it points to. Per MISRA C 2023 Rule 8.13, such a pointer should be declared to point to a const-qualified type (e.g. const OS_module_internal_record_t *module) where possible.\n\nPractical notes:\n- Converting the local declaration to const is safe here: assigning a non-const T * (the result of OS_OBJECT_TABLE_GET) to a const T * is allowed without a cast.\n- Ensure no later code in this function needs to modify the record via module; if it does, const cannot be used.\n- The provided test/log code being empty does not invalidate the static observation that the pointer is only read.\n\nRecommendation: change the declaration to const OS_module_internal_record_t *module (unless other uses elsewhere require write access)."
}