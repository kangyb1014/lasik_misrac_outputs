{
  "user_message": "An agent A claimed that the following OS_ModuleUnload code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ModuleUnload.\n```c\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            return_code = OS_ModuleUnload_Impl(&token);\n        }\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_ModuleUnload obtains a non-const pointer to an element of OS_module_table even though it only reads the record. The macro OS_OBJECT_TABLE_GET(&tbl, token) expands to &tbl[index], and OS_module_table is declared as a non-const array: \"OS_module_internal_record_t OS_module_table[OS_MAX_MODULES]\". In OS_ModuleUnload the code does: module = OS_OBJECT_TABLE_GET(OS_module_table, token); then only reads module->module_type. According to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type when possible (e.g. use const OS_module_internal_record_t *module or declare OS_module_table as const if it is never modified). Because a non-const pointer is produced/used where a const-qualified pointer would suffice, this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ModuleUnload_LogProbe(osal_id_t module_id,\n                                    const OS_object_token_t *token,\n                                    const OS_module_internal_record_t *module,\n                                    int32 return_code,\n                                    const char *stage)\n{\n    FILE *f = fopen(\"/tmp/logs/1707.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Print basic state: stage, module_id (as long), addresses of token/module, module_type (if available), and return_code */\n        (void)fprintf(f,\n                      \"[%s] module_id=%ld token_ptr=%p module_ptr=%p module_type=%d return_code=%ld\\n\",\n                      (stage != NULL) ? stage : \"(null)\",\n                      (long)module_id,\n                      (const void *)token,\n                      (const void *)module,\n                      (module != NULL) ? (int)module->module_type : -1,\n                      (long)return_code);\n        (void)fclose(f);\n    }\n}\n\nint32 OS_ModuleUnload(osal_id_t module_id)\n{\n    OS_module_internal_record_t *module;\n    int32                        return_code;\n    OS_object_token_t            token;\n\n    /* Log entry before attempting to resolve the ID. token is uninitialized here so we only log its address. */\n    OS_ModuleUnload_LogProbe(module_id, &token, NULL, -1, \"entry_before_GetById\");\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, module_id, &token);\n\n    /* Log result of ID resolution */\n    OS_ModuleUnload_LogProbe(module_id, &token, NULL, return_code, \"after_GetById\");\n\n    if (return_code == OS_SUCCESS)\n    {\n        module = OS_OBJECT_TABLE_GET(OS_module_table, token);\n\n        /* Log pointer obtained from table and the current module_type (if readable) */\n        OS_ModuleUnload_LogProbe(module_id, &token, module, return_code, \"after_table_get\");\n\n        /*\n         * Only call the implementation if the file was actually loaded.\n         * If this is a static module, then this is just a placeholder and\n         * it means there was no file actually loaded.\n         */\n        if (module->module_type == OS_MODULE_TYPE_DYNAMIC)\n        {\n            OS_ModuleUnload_LogProbe(module_id, &token, module, return_code, \"before_impl_call\");\n            return_code = OS_ModuleUnload_Impl(&token);\n            OS_ModuleUnload_LogProbe(module_id, &token, module, return_code, \"after_impl_call\");\n        }\n\n        /* Complete the operation via the common routine */\n        OS_ModuleUnload_LogProbe(module_id, &token, module, return_code, \"before_finalize\");\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n        OS_ModuleUnload_LogProbe(module_id, &token, module, return_code, \"after_finalize\");\n    }\n\n    OS_ModuleUnload_LogProbe(module_id, &token, NULL, return_code, \"exit\");\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ModuleUnload. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C:2023 Rule 8.13 requires that a pointer should point to a const-qualified type whenever possible. In OS_ModuleUnload the local variable module is declared as OS_module_internal_record_t * and is assigned from the table element via the macro (which yields &OS_module_table[index]). The code only reads module->module_type (it does not modify the object through module), so the pointer can and should be declared as a pointer-to-const: const OS_module_internal_record_t *module. Alternatively, if the entire table is truly immutable it could be declared const, but that is less likely in this codebase. Declaring the local pointer const addresses the rule without preventing other code paths that legitimately modify the table via non-const accesses. Therefore the reported violation is valid."
}