{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) has no checks that either pointer is non-NULL or that the pointed-to buffers are null-terminated. If TypeName is NULL or if ContentTypeStr is not a valid null-terminated string (e.g. uninitialized or truncated buffer), strcmp will read beyond the bounds of the referenced object(s), violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_SetDeferredRetcode code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2511.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_SetDeferredRetcode as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_SetDeferredRetcode:\n```c\nvoid UT_SetDeferredRetcode(UT_EntryKey_t FuncKey, int32 Count, UT_IntReturn_t Retcode)\n{\n    /* The count should always be a positive integer, if not there is a bug in the test */\n    if (Count <= 0)\n    {\n        UtAssert_Failed(\"BUG: Invalid Count (%ld) passed to UT_SetDeferredRetcode()\", (long)Count);\n    }\n    else\n    {\n        UT_ConfigureGenericStubReturnValue(FuncKey, &Retcode, sizeof(Retcode), UT_ValueGenre_INTEGER, Count, NULL);\n    }\n}\n```\n</target_code>\nPlease provide the modified UT_SetDeferredRetcode code.\n",
  "test_code": "#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n\n/* Prototypes for external symbols used by the original function (provided elsewhere in the test harness) */\nextern void UT_ConfigureGenericStubReturnValue(void *FuncKey, const void *RetPtr, unsigned long Size, int Genre, int Count, void *Arg);\nextern void UtAssert_Failed(const char *Spec, ...);\n\n/* Helper: append a timestamped message to the log file */\nstatic void UT_LogMessage(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2511.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n#if defined(_WIN32)\n    localtime_s(&tm_buf, &t);\n#else\n    localtime_r(&t, &tm_buf);\n#endif\n\n    char timestr[64];\n    if (strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf) == 0)\n    {\n        timestr[0] = '\\0';\n    }\n\n    fprintf(fp, \"%s - \", timestr);\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\n/* Probe function for logging parameters that are commonly involved in strcmp-like calls.\n * This function intentionally does NOT dereference the pointer arguments; it only logs\n * their pointer values and null-ness so that callers can establish whether a NULL\n * pointer might be the cause of an out-of-bounds read in strcmp.\n *\n * Note: Do NOT call this with pointers you expect to be invalid (dangling) if you\n * want to avoid potential crashes when other parts of the system dereference them.\n */\nvoid UT_Probe_LogStrcmpParams(const char *s1, const char *s2, const char *context)\n{\n    UT_LogMessage(\"Probe: UT_Probe_LogStrcmpParams invoked (context='%s')\", context ? context : \"(null)\");\n    UT_LogMessage(\"  s1 pointer: %p (%s)\", (const void *)s1, (s1 == NULL) ? \"NULL\" : \"non-NULL\");\n    UT_LogMessage(\"  s2 pointer: %p (%s)\", (const void *)s2, (s2 == NULL) ? \"NULL\" : \"non-NULL\");\n    /* Provide guidance for other agents: if either pointer is NULL the strcmp call will be UB */\n    if (s1 == NULL || s2 == NULL)\n    {\n        UT_LogMessage(\"  WARNING: One or more strcmp parameters are NULL. A subsequent strcmp() would be undefined behavior (out-of-bounds access).\");\n    }\n    else\n    {\n        UT_LogMessage(\"  NOTE: Both parameters are non-NULL. This probe does not attempt to check null-termination to avoid further undefined behavior.\");\n        UT_LogMessage(\"  Suggestion: use an instrumented check in the code that has size information to verify null-termination before calling strcmp.\");\n    }\n}\n\n/* A small probe that logs the address of a string pointer and whether it is NULL.\n * This is useful if the call-site of strcmp passes through intermediate structures\n * (for instance, StubPtr->Data.Buff.ContentTypeStr). Agents can call this with the\n * pointer from the structure to capture its state at runtime.\n */\nvoid UT_Probe_LogStringPointer(const char *strptr, const char *name)\n{\n    UT_LogMessage(\"Probe: UT_Probe_LogStringPointer: %s -> %p (%s)\", name ? name : \"(unnamed)\", (const void *)strptr, (strptr == NULL) ? \"NULL\" : \"non-NULL\");\n}\n\n/* Modified UT_SetDeferredRetcode with additional logging probes. The original logic\n * is preserved: when Count <= 0 the UtAssert_Failed path is taken, otherwise the\n * deferred return value is configured via UT_ConfigureGenericStubReturnValue.\n *\n * The additional logs record the entry, parameters, and which path was taken so\n * other agents can correlate this invocation with any downstream misuse of string\n * functions (such as a strcmp on NULL or unterminated buffers).\n */\nvoid UT_SetDeferredRetcode(UT_EntryKey_t FuncKey, int32 Count, UT_IntReturn_t Retcode)\n{\n    /* Log entry and parameters */\n    UT_LogMessage(\"UT_SetDeferredRetcode ENTRY: FuncKey=%p, Count=%ld, Retcode=%lld\", (void *)FuncKey, (long)Count, (long long)Retcode);\n\n    /* The count should always be a positive integer, if not there is a bug in the test */\n    if (Count <= 0)\n    {\n        UT_LogMessage(\"UT_SetDeferredRetcode: Count <= 0 taken path. About to call UtAssert_Failed\");\n        UtAssert_Failed(\"BUG: Invalid Count (%ld) passed to UT_SetDeferredRetcode()\", (long)Count);\n    }\n    else\n    {\n        UT_LogMessage(\"UT_SetDeferredRetcode: configuring deferred retcode via UT_ConfigureGenericStubReturnValue\");\n        UT_ConfigureGenericStubReturnValue(FuncKey, &Retcode, sizeof(Retcode), UT_ValueGenre_INTEGER, Count, NULL);\n        UT_LogMessage(\"UT_SetDeferredRetcode: UT_ConfigureGenericStubReturnValue completed\");\n    }\n\n    UT_LogMessage(\"UT_SetDeferredRetcode EXIT: FuncKey=%p, Count=%ld\", (void *)FuncKey, (long)Count);\n}\n"
}