{
  "user_message": "An agent A claimed that the following OS_ObjectIdFindNextFree code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFindNextFree.\n```c\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    uint32              max_id;\n    uint32              base_id;\n    uint32              local_id = 0;\n    uint32              serial;\n    uint32              i;\n    int32               return_code;\n    OS_common_record_t *obj = NULL;\n    OS_objtype_state_t *objtype_state;\n\n    base_id       = OS_GetBaseForObjectType(token->obj_type);\n    max_id        = OS_GetMaxForObjectType(token->obj_type);\n    objtype_state = &OS_objtype_state[token->obj_type];\n\n    if (max_id == 0)\n    {\n        /* if the max id is zero, then this build of OSAL\n         * does not include any support for that object type.\n         * Return the \"not implemented\" to differentiate between\n         * this case vs. running out of valid slots  */\n        return_code = OS_ERR_NOT_IMPLEMENTED;\n        serial      = 0;\n    }\n    else\n    {\n        return_code = OS_ERR_NO_FREE_IDS;\n        serial      = OS_ObjectIdToSerialNumber_Impl(objtype_state->last_id_issued);\n    }\n\n    for (i = 0; i < max_id; ++i)\n    {\n        local_id = (++serial) % max_id;\n        if (serial >= OS_OBJECT_INDEX_MASK)\n        {\n            /* reset to beginning of ID space */\n            serial = local_id;\n        }\n        obj = &OS_common_table[local_id + base_id];\n        if (!OS_ObjectIdDefined(obj->active_id))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(local_id);\n        OS_ObjectIdCompose_Impl(token->obj_type, serial, &token->obj_id);\n\n        /* Ensure any data in the record has been cleared */\n        obj->active_id  = token->obj_id;\n        obj->name_entry = NULL;\n        obj->creator    = OS_TaskGetId();\n        obj->refcount   = 0;\n\n        /* preemptively update the last id issued */\n        objtype_state->last_id_issued = token->obj_id;\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(-1);\n        token->obj_id  = OS_OBJECT_ID_UNDEFINED;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strlen(string) can read past the bounds of the object referenced by 'string' if that object is not NUL-terminated (or if 'string' is NULL). Example violation: char buf[4] = {'a','b','c','d'}; /* no '\\0' */ size_t length = strlen(buf); \u2014 strlen will scan past buf causing an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_1575_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1575.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_ObjectIdFindNextFree(OS_object_token_t *token)\n{\n    uint32              max_id;\n    uint32              base_id;\n    uint32              local_id = 0;\n    uint32              serial;\n    uint32              i;\n    int32               return_code;\n    OS_common_record_t *obj = NULL;\n    OS_objtype_state_t *objtype_state;\n\n    /* Log entry and input token pointer */\n    OS_1575_log(\"OS_ObjectIdFindNextFree ENTRY: token=%p\", (void *)token);\n\n    base_id       = OS_GetBaseForObjectType(token->obj_type);\n    max_id        = OS_GetMaxForObjectType(token->obj_type);\n    objtype_state = &OS_objtype_state[token->obj_type];\n\n    OS_1575_log(\"Computed base_id=%u max_id=%u obj_type=%u objtype_state=%p\",\n                (unsigned)base_id, (unsigned)max_id, (unsigned)token->obj_type, (void *)objtype_state);\n\n    if (max_id == 0)\n    {\n        /* if the max id is zero, then this build of OSAL\n         * does not include any support for that object type.\n         * Return the \"not implemented\" to differentiate between\n         * this case vs. running out of valid slots  */\n        return_code = OS_ERR_NOT_IMPLEMENTED;\n        serial      = 0;\n\n        OS_1575_log(\"max_id==0 -> return_code=OS_ERR_NOT_IMPLEMENTED serial=%u\", (unsigned)serial);\n    }\n    else\n    {\n        return_code = OS_ERR_NO_FREE_IDS;\n        serial      = OS_ObjectIdToSerialNumber_Impl(objtype_state->last_id_issued);\n\n        OS_1575_log(\"Starting search: return_code=OS_ERR_NO_FREE_IDS last_id_issued=0x%08x serial(start)=%u\",\n                    (unsigned)objtype_state->last_id_issued, (unsigned)serial);\n    }\n\n    for (i = 0; i < max_id; ++i)\n    {\n        local_id = (++serial) % max_id;\n        if (serial >= OS_OBJECT_INDEX_MASK)\n        {\n            /* reset to beginning of ID space */\n            serial = local_id;\n            OS_1575_log(\"serial reached OS_OBJECT_INDEX_MASK, reset serial to local_id=%u\", (unsigned)local_id);\n        }\n\n        obj = &OS_common_table[local_id + base_id];\n\n        /* Log candidate index and object pointer and current active_id */\n        OS_1575_log(\"Iteration %u: serial=%u local_id=%u obj_array_index=%u obj=%p active_id=0x%08x\",\n                    (unsigned)i, (unsigned)serial, (unsigned)local_id, (unsigned)(local_id + base_id), (void *)obj,\n                    (unsigned)obj->active_id);\n\n        if (!OS_ObjectIdDefined(obj->active_id))\n        {\n            return_code = OS_SUCCESS;\n            OS_1575_log(\"Found free slot at local_id=%u serial=%u\", (unsigned)local_id, (unsigned)serial);\n            break;\n        }\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(local_id);\n        OS_ObjectIdCompose_Impl(token->obj_type, serial, &token->obj_id);\n\n        /* Ensure any data in the record has been cleared */\n        obj->active_id  = token->obj_id;\n        obj->name_entry = NULL;\n        obj->creator    = OS_TaskGetId();\n        obj->refcount   = 0;\n\n        /* preemptively update the last id issued */\n        objtype_state->last_id_issued = token->obj_id;\n\n        OS_1575_log(\"Assigned obj: token->obj_idx=%d token->obj_id=0x%08x obj=%p active_id=0x%08x creator=%d refcount=%u last_id_issued=0x%08x\",\n                    token->obj_idx, (unsigned)token->obj_id, (void *)obj, (unsigned)obj->active_id, (int)obj->creator,\n                    (unsigned)obj->refcount, (unsigned)objtype_state->last_id_issued);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        token->obj_idx = OSAL_INDEX_C(-1);\n        token->obj_id  = OS_OBJECT_ID_UNDEFINED;\n\n        OS_1575_log(\"No free id found: return_code=%d token->obj_idx=%d token->obj_id=0x%08x\",\n                    (int)return_code, (int)token->obj_idx, (unsigned)token->obj_id);\n    }\n\n    OS_1575_log(\"OS_ObjectIdFindNextFree EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdFindNextFree. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct. MISRA C 2023 Rule 21.17 concerns use of functions from <string.h> (memcpy, strlen, strcpy, etc.) potentially reading/writing past object bounds. The provided OS_ObjectIdFindNextFree implementation contains no calls to any <string.h> functions. The agent\u2019s example (strlen reading past a non-NUL-terminated buffer) is a valid illustration of a 21.17 violation in general, but it does not apply to this target function. The added test logging uses stdio (vfprintf/fprintf), which is unrelated to <string.h>. Note: if any called helper functions (e.g., OS_ObjectIdCompose_Impl, OS_ObjectIdToSerialNumber_Impl) internally used unsafe <string.h> calls that read out-of-bounds, that would be a separate issue, but there is no evidence of such usage in the submitted code. Therefore the report that this function violates Rule 21.17 is incorrect."
}