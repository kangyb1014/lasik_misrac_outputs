{
  "user_message": "Target function code is:\n```c\nint32 OS_Milli2Ticks(uint32 milli_seconds, int *ticks)\n{\n    uint64 num_of_ticks;\n    int32  return_code = OS_SUCCESS;\n\n    num_of_ticks = (((uint64)milli_seconds * OS_SharedGlobalVars.TicksPerSecond) + 999) / 1000;\n\n    /* Check against maximum int32 (limit from some OS's) */\n    if (num_of_ticks <= INT_MAX)\n    {\n        *ticks = (int)num_of_ticks;\n    }\n    else\n    {\n        return_code = OS_ERROR;\n        *ticks      = 0;\n    }\n\n    return return_code;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SharedGlobalVars (declaration/type)",
    "OS_SharedGlobalVars.TicksPerSecond (definition / initialization / configuration value or bounds)",
    "Any configuration macros or constants that bound TicksPerSecond (e.g. OS_TICKS_PER_SECOND, default config values)",
    "Call sites and API documentation for OS_Milli2Ticks (all callers and any documented preconditions on milli_seconds)",
    "typedefs: uint32, uint64, int32 (their exact widths)",
    "Platform int width and INT_MAX (limits.h value on the target platform)",
    "Any static analysis annotations or assertions that constrain milli_seconds or TicksPerSecond (compile-time asserts, range annotations)"
  ],
  "explanation": "To decide whether any executed operations in OS_Milli2Ticks are dead (i.e. can be removed without changing behaviour) you must reason about the numeric ranges that determine which branches and assignments can actually execute. The following symbols are required and why:\n\n- OS_SharedGlobalVars (declaration/type): shows where TicksPerSecond lives, whether the global is volatile/const, and the struct layout. If the member is compile-time constant or never changes, some branches may be provably always/never taken.\n\n- OS_SharedGlobalVars.TicksPerSecond (definition / initialization / configuration value or bounds): the value or allowable range of TicksPerSecond is needed to compute the expression (((uint64)milli_seconds * TicksPerSecond) + 999)/1000 and decide if num_of_ticks can ever exceed INT_MAX. If TicksPerSecond is fixed or bounded tightly, the else branch might be dead.\n\n- Any configuration macros or constants that bound TicksPerSecond (e.g. OS_TICKS_PER_SECOND, default config values): TicksPerSecond is often set from a configuration macro. Those compile-time values or documented maxima are needed to determine the maximum possible product and thus branch reachability.\n\n- Call sites and API documentation for OS_Milli2Ticks (all callers and any documented preconditions on milli_seconds): callers or API contracts may constrain milli_seconds (for example only small values are ever passed). Such constraints can make the else-branch unreachable-in-practice and therefore its body might be dead code.\n\n- typedefs: uint32, uint64, int32 (their exact widths): the arithmetic and casts rely on these widths. Knowing their exact sizes (e.g. uint32 == 32-bit) is required to compute upper bounds on the multiplication and to ensure no unexpected wrap/overflow that would change reachability of the branches.\n\n- Platform int width and INT_MAX (limits.h value on the target platform): the comparison is against INT_MAX and the code casts num_of_ticks to (int). The actual INT_MAX on the target platform and the width of int determine whether the condition can ever be false and whether the cast can truncate \u2014 critical to decide if the else branch is ever executed or removable.\n\n- Any static analysis annotations or assertions that constrain milli_seconds or TicksPerSecond (compile-time asserts, range annotations): additional invariants (e.g. static_assert, __attribute__ ranges) can make parts of the function provably unnecessary. These must be considered to judge dead code.\n\nCollecting these symbols (definitions, config values, platform limits, and caller constraints) permits a sound range analysis to determine whether the else branch and/or any assignment statements are executed in any feasible execution and thus whether they constitute dead code under the MISRA definition."
}