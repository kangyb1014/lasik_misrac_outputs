{
  "user_message": "Target function code is:\n```c\nint32 OS_Milli2Ticks(uint32 milli_seconds, int *ticks)\n{\n    uint64 num_of_ticks;\n    int32  return_code = OS_SUCCESS;\n\n    num_of_ticks = (((uint64)milli_seconds * OS_SharedGlobalVars.TicksPerSecond) + 999) / 1000;\n\n    /* Check against maximum int32 (limit from some OS's) */\n    if (num_of_ticks <= INT_MAX)\n    {\n        *ticks = (int)num_of_ticks;\n    }\n    else\n    {\n        return_code = OS_ERROR;\n        *ticks      = 0;\n    }\n\n    return return_code;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SharedGlobalVars",
    "OS_SharedGlobalVars.TicksPerSecond",
    "OS_SUCCESS",
    "OS_ERROR",
    "INT_MAX",
    "uint64",
    "uint32",
    "int32",
    "ticks  (preprocessor macro check)",
    "milli_seconds  (preprocessor macro check)"
  ],
  "explanation": "You must inspect the definitions of the above symbols because a MISRA check for \"a function parameter shall not be modified\" depends not only on the visible source text but on macro/type expansions and external definitions that could introduce side effects or token replacement:\n\n- OS_SharedGlobalVars and OS_SharedGlobalVars.TicksPerSecond: used in the arithmetic expression that computes num_of_ticks. If either identifier is a macro (or its member expands to a macro expression) it could contain side effects or comma-operators that alter variables or expressions (including accidentally referencing or modifying the parameter). Verify they are plain objects/fields with no hidden side effects.\n\n- OS_SUCCESS and OS_ERROR: these appear in return_code assignments. They may be macros; if they expand to expressions with side-effects they could modify state (or, in pathological cases, reference the parameter). Confirm they are simple constant macros or enum/constants.\n\n- INT_MAX: used in the conditional. Although normally a constant from <limits.h>, a non-standard or redefined INT_MAX macro could expand oddly; confirm it is a simple constant.\n\n- uint64, uint32, int32: these type names may be typedefs or preprocessor macros. If they are macros, they could perform token substitution that changes the semantics of expressions involving the parameters. Confirm they are plain type typedefs.\n\n- ticks (preprocessor macro check) and milli_seconds (preprocessor macro check): ensure there are no #define macros with the same names as the parameter identifiers. Macro replacement occurs before parsing, so a macro named 'ticks' or 'milli_seconds' could change the function body and introduce an assignment to the pointer variable itself (or other modifications). The MISRA rule applies to the pointer parameter (the pointer object itself), so any hidden macro expansion that assigns to 'ticks' (e.g., replacing 'ticks' with '(some_expr, ticks_ptr = ... )') must be ruled out.\n\nIn short: verify that all of the above are plain constants/typedefs/objects (not macros with side effects) so that the only write to the pointer in this function is to *ticks (the pointee), which is permitted by the MISRA rule while any direct assignment to ticks would violate it."
}