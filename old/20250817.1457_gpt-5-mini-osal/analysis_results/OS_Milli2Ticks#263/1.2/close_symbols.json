{
  "user_message": "Target function code is:\n```c\nint32 OS_Milli2Ticks(uint32 milli_seconds, int *ticks)\n{\n    uint64 num_of_ticks;\n    int32  return_code = OS_SUCCESS;\n\n    num_of_ticks = (((uint64)milli_seconds * OS_SharedGlobalVars.TicksPerSecond) + 999) / 1000;\n\n    /* Check against maximum int32 (limit from some OS's) */\n    if (num_of_ticks <= INT_MAX)\n    {\n        *ticks = (int)num_of_ticks;\n    }\n    else\n    {\n        return_code = OS_ERROR;\n        *ticks      = 0;\n    }\n\n    return return_code;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "uint32",
    "uint64",
    "int32",
    "OS_SharedGlobalVars",
    "OS_SharedGlobalVars.TicksPerSecond",
    "OS_SUCCESS",
    "OS_ERROR",
    "INT_MAX",
    "<stdint.h> (or the project header that defines uint32/uint64/int32)",
    "<limits.h> (or the header that defines INT_MAX)"
  ],
  "explanation": "For checking MISRA C \"Language extensions should not be used\" you must inspect the declarations/definitions these identifiers resolve to, because the rule is violated only if those underlying definitions use compiler-specific extensions. Brief rationale for each symbol:\n\n- uint32, uint64, int32\n  - These typedef names hide the actual underlying integer types. You must see their typedefs to determine whether they map to standard C types (e.g. uint32_t/int32_t from stdint.h) or to compiler-specific/extended types (e.g. compiler-only __int64, __int128, nonstandard attributes, or other extensions).\n\n- OS_SharedGlobalVars and OS_SharedGlobalVars.TicksPerSecond\n  - You need the structure/variable definition and the declared type of the TicksPerSecond member to know what type participates in the arithmetic. The member declaration could use non\u2011standard storage-class specifiers, bit-fields, attributes, or compiler extensions that would violate the rule.\n\n- OS_SUCCESS, OS_ERROR\n  - These return-code symbols may be macros or enum constants. Their definitions must be inspected to ensure they are defined with standard C constructs and not via compiler-specific extensions (macro tricks, attributes, assembly inserts, etc.).\n\n- INT_MAX\n  - Typically defined in <limits.h>. Confirming its origin ensures it is the standard macro and not a project macro that uses extensions.\n\n- <stdint.h> (or the project header that defines uint32/uint64/int32)\n  - If the project relies on stdint.h typedefs, that is standard C (since C99). If instead a project header provides these typedefs, you must inspect that header for any use of compiler extensions when creating those typedefs.\n\n- <limits.h> (or the project header that defines INT_MAX)\n  - To verify INT_MAX is the standard macro and that no nonstandard extension is used in its definition.\n\nIn short: fetch the typedefs and macro/enum/struct definitions (the headers that define uint32/uint64/int32, OS_SharedGlobalVars and its member, OS_SUCCESS/OS_ERROR, and INT_MAX) so you can determine whether any of those definitions introduce compiler/language extensions. Only after examining those definitions can you conclude whether the target function itself uses a language extension."
}