{
  "user_message": "An agent A claimed that the following OS_ObjectIdGetBySearch code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdGetBySearch.\n```c\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In OS_ObjectIdFindNextMatch the local pointer is declared as \"OS_common_record_t *record;\" but the code only reads from the record (checks record->active_id and passes it to MatchFunc which expects a const OS_common_record_t *). Since the pointer is never used to modify the object here it could and should be declared as \"const OS_common_record_t *record;\". This omission violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1595.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", fp);\n    fclose(fp);\n}\n\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /* Log entry and input parameters (pointer values only; do not dereference unknown structures) */\n    probe_log(\"OS_ObjectIdGetBySearch ENTRY: lock_mode=%d, idtype=%d, MatchFunc=%p, arg=%p, token=%p\",\n              (int)lock_mode, (int)idtype, (void *)MatchFunc, arg, (void *)token);\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    probe_log(\"After OS_ObjectIdTransactionInit: token=%p\", (void *)token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    probe_log(\"After OS_ObjectIdFindNextMatch: return_code=%d, token=%p\",\n              (int)return_code, (void *)token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        probe_log(\"Match found: about to convert token for lock_mode=%d\", (int)lock_mode);\n\n        /* The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n\n        probe_log(\"After OS_ObjectIdConvertToken: return_code=%d, token=%p\",\n                  (int)return_code, (void *)token);\n    }\n    else\n    {\n        probe_log(\"No match found: cancelling transaction (return_code=%d)\", (int)return_code);\n        OS_ObjectIdTransactionCancel(token);\n        probe_log(\"After OS_ObjectIdTransactionCancel: token=%p\", (void *)token);\n    }\n\n    probe_log(\"OS_ObjectIdGetBySearch EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=4, MatchFunc=0x555f92b4a170, arg=0x555f92b636b1, token=0x7ffe866cc370\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc370\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc370\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc370\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=3, MatchFunc=0x555f92b4a170, arg=0x555f92b65f7d, token=0x7ffe866cc370\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc370\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc370\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc370\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=5, MatchFunc=0x555f92b4a170, arg=0x555f92b666d9, token=0x7ffe866cc370\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc370\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc370\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc370\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=2, MatchFunc=0x555f92b4a170, arg=0x555f92b64f50, token=0x7ffe866cc370\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc370\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc370\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc370\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=11, MatchFunc=0x555f92b4a170, arg=0x555f92b651e9, token=0x7ffe866cc3e0\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc3e0\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc3e0\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc3e0\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=11, MatchFunc=0x555f92b478d6, arg=0x555f92b652b8, token=0x7ffe866cc2f0\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc2f0\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc2f0\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc2f0\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=11, MatchFunc=0x555f92b478d6, arg=0x555f92b652b8, token=0x7ffe866cc320\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc320\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc320\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc320\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=11, MatchFunc=0x555f92b478d6, arg=0x555f92b65290, token=0x7ffe866cc3e0\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc3e0\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc3e0\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc3e0\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=3, idtype=11, MatchFunc=0x555f92b4a170, arg=0x555f92b651e9, token=0x7ffe866cc3e0\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc3e0\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc3e0\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc3e0\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=11, MatchFunc=0x555f92b4a170, arg=0x555f92b651e9, token=0x7ffe866cc3e0\nAfter OS_ObjectIdTransactionInit: token=0x7ffe866cc3e0\nAfter OS_ObjectIdFindNextMatch: return_code=-17, token=0x7ffe866cc3e0\nNo match found: cancelling transaction (return_code=-17)\nAfter OS_ObjectIdTransactionCancel: token=0x7ffe866cc3e0\nOS_ObjectIdGetBySearch EXIT: return_code=-17\nOS_ObjectIdGetBySearch ENTRY: lock_mode=1, idtype=\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the evidence. The provided code (OS_ObjectIdGetBySearch) contains no local pointer that could/should be const-qualified; it only calls OS_ObjectIdFindNextMatch. The agent\u2019s narrative points to a local pointer inside OS_ObjectIdFindNextMatch (record declared as OS_common_record_t *record) \u2014 that function\u2019s source was not provided, so you cannot conclude the shown OS_ObjectIdGetBySearch function violates Rule 8.13. Moreover, passing a pointer-to-non-const to a function that takes a pointer-to-const is allowed (no const-correctness violation at the call site). The test logs only show runtime call sequences and return codes; they do not demonstrate a declaration-level const-qualification issue. Therefore the report as stated (that OS_ObjectIdGetBySearch violates MISRA C 2023 Rule 8.13) is incorrect."
}