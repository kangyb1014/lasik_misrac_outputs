{
  "user_message": "An agent A claimed that the following OS_ObjectIdGetBySearch code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdGetBySearch.\n```c\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memset(token, 0, sizeof(*token)) can write to an invalid address if the caller passes an invalid pointer (e.g. token == NULL) or a pointer to a smaller object. There is no check that 'token' is non-NULL and points to at least sizeof(OS_object_token_t) bytes before the memset. Example violation: caller calls OS_ObjectIdGetBySearch(..., NULL) -> OS_ObjectIdTransactionInit executes memset(NULL, 0, sizeof(*token)) which attempts to write through a NULL pointer (out-of-bounds access).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_1599_log_before(const char *stage, const void *token, unsigned int idtype, int lock_mode, const void *matchfunc, const void *arg)\n{\n    FILE *f = fopen(\"/tmp/logs/1599.txt\", \"a\");\n    if (!f)\n        return;\n\n    fprintf(f, \"[BEFORE] %s\\n\", stage);\n    fprintf(f, \"  token=%p, idtype=%u, lock_mode=%d, matchfunc=%p, arg=%p\\n\",\n            token, idtype, lock_mode, matchfunc, arg);\n    fclose(f);\n}\nstatic void os_1599_log_after(const char *stage, const void *token, int32_t return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1599.txt\", \"a\");\n    if (!f)\n        return;\n\n    fprintf(f, \"[AFTER]  %s\\n\", stage);\n    fprintf(f, \"  token=%p, return_code=%d\\n\", token, (int)return_code);\n    fclose(f);\n}\n\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /* Log state immediately before starting the transaction. This captures the\n     * token pointer value (which may be NULL or invalid) without dereferencing it.\n     * This helps reproduce scenarios where OS_ObjectIdTransactionInit writes via\n     * the token pointer (e.g. a memset) and causes an out-of-bounds access. */\n    os_1599_log_before(\"entering OS_ObjectIdTransactionInit\", (const void *)token, (unsigned int)idtype, (int)lock_mode,\n                       (const void *)MatchFunc, arg);\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    /* If the program crashes inside OS_ObjectIdTransactionInit (for example due\n     * to a NULL token being passed and then written), the logs above will show\n     * the pointer value and call context recorded just before the crash. */\n    os_1599_log_after(\"returned from OS_ObjectIdTransactionInit\", (const void *)token, 0);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n    os_1599_log_after(\"returned from OS_ObjectIdFindNextMatch\", (const void *)token, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        os_1599_log_before(\"about to call OS_ObjectIdConvertToken\", (const void *)token, (unsigned int)idtype, (int)lock_mode,\n                           (const void *)MatchFunc, arg);\n\n        return_code = OS_ObjectIdConvertToken(token);\n\n        os_1599_log_after(\"returned from OS_ObjectIdConvertToken\", (const void *)token, return_code);\n    }\n    else\n    {\n        os_1599_log_before(\"about to call OS_ObjectIdTransactionCancel\", (const void *)token, (unsigned int)idtype, (int)lock_mode,\n                           (const void *)MatchFunc, arg);\n\n        OS_ObjectIdTransactionCancel(token);\n\n        os_1599_log_after(\"returned from OS_ObjectIdTransactionCancel\", (const void *)token, 0);\n    }\n\n    os_1599_log_after(\"exiting OS_ObjectIdGetBySearch\", (const void *)token, return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, idtype=4, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2d96b1\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, idtype=4, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2d96b1\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, idtype=3, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2dbf7d\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, idtype=3, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2dbf7d\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, idtype=5, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2dc6d9\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, idtype=5, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2dc6d9\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, idtype=2, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2daf50\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, idtype=2, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2daf50\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9ff0, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51e9ff0, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51ea060, idtype=11, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2db1e9\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51ea060, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51ea060, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51ea060, idtype=11, lock_mode=1, matchfunc=0x55662c2c0150, arg=0x55662c2db1e9\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51ea060, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51ea060, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9f70, idtype=11, lock_mode=1, matchfunc=0x55662c2bd8b6, arg=0x55662c2db2b8\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9f70, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9f70, return_code=-17\n[BEFORE] about to call OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9f70, idtype=11, lock_mode=1, matchfunc=0x55662c2bd8b6, arg=0x55662c2db2b8\n[AFTER]  returned from OS_ObjectIdTransactionCancel\n  token=0x7ffeb51e9f70, return_code=0\n[AFTER]  exiting OS_ObjectIdGetBySearch\n  token=0x7ffeb51e9f70, return_code=-17\n[BEFORE] entering OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9fa0, idtype=11, lock_mode=1, matchfunc=0x55662c2bd8b6, arg=0x55662c2db2b8\n[AFTER]  returned from OS_ObjectIdTransactionInit\n  token=0x7ffeb51e9fa0, return_code=0\n[AFTER]  returned from OS_ObjectIdFindNextMatch\n  token=0x7ffeb51e9fa0, return_code=-17\n[BEFORE] about t\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the code shown. MISRA C 2023 Rule 21.17 concerns use of <string.h> functions (memset, memcpy, etc.) causing out-of-bounds accesses. The body of OS_ObjectIdGetBySearch shown does not call any string.h functions itself \u2014 it merely forwards the token pointer to helper routines (OS_ObjectIdTransactionInit, OS_ObjectIdFindNextMatch, OS_ObjectIdConvertToken, OS_ObjectIdTransactionCancel). If a memset(token, 0, sizeof(*token)) exists it would be inside OS_ObjectIdTransactionInit (or another callee), and any violation of 21.17 would be attributable to that routine, not to OS_ObjectIdGetBySearch. The provided logs also show non-NULL token addresses and successful returns from OS_ObjectIdTransactionInit, with no evidence of an out-of-bounds write originating from OS_ObjectIdGetBySearch. Therefore the claim that OS_ObjectIdGetBySearch violates MISRA Rule 21.17 is not supported by the code and logs given."
}