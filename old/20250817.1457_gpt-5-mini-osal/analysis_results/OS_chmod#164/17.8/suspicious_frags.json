{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_chmod:\n```c\nint32 OS_chmod(const char *path, uint32 access_mode)\n{\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n    int32 return_code;\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileChmod_Impl(local_path, access_mode);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_chmod:\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n        }\n    }\n\n    close(fd);\n\n    return status;\n}\n...\nvoid UT_ExecuteBasicHandler(UT_EntryKey_t FuncKey, const char *FunctionName, UT_HandlerFunc_t DefaultHandler)\n{\n    /* Check if the test case registered a hook, and use the default if not */\n    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER) == NULL && DefaultHandler != NULL)\n    {\n        UT_SetHandlerFunction(FuncKey, DefaultHandler, NULL);\n    }\n\n    UT_DefaultStubImpl(FunctionName, FuncKey, 0, NULL);\n}\n...\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n...\nvoid UT_Stub_RegisterContextWithMetaData(UT_EntryKey_t FuncKey, const char *Name, UT_StubContext_Arg_Type_t ParamType,\n                                         const void *ParamPtr, size_t ParamSize)\n{\n    UT_StubTableEntry_t * StubPtr;\n    UT_StubArgMetaData_t *MetaPtr;\n\n    /*\n     * First find an existing context entry for the function.\n     * In case one is already set we do not duplicate\n     */\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);\n    if (StubPtr == NULL)\n    {\n        /* Creating force fail entry - repeat search and grab any unused slot */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n    }\n\n    if (StubPtr == NULL)\n    {\n        UtAssert_Abort(\"Cannot set context - UT_MAX_FUNC_STUBS too low?\");\n    }\n    else\n    {\n        StubPtr->FuncKey   = FuncKey;\n        StubPtr->EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;\n        if (StubPtr->Data.Context.ArgCount < UT_STUBCONTEXT_MAXSIZE)\n        {\n            StubPtr->Data.Context.ArgPtr[StubPtr->Data.Context.ArgCount] = ParamPtr;\n\n            MetaPtr       = &StubPtr->Data.Context.Meta[StubPtr->Data.Context.ArgCount];\n            MetaPtr->Size = ParamSize;\n            MetaPtr->Type = ParamType;\n\n            /*\n             * If name was specified, then trim any leading address operator (&)\n             * and/or whitespace, keeping only the actual name part.\n             */\n            if (Name != NULL)\n            {\n                /*\n                 * If the _address_ of the stack variable was actually passed in,\n                 * the mark this as indirect (i.e. hook must dereference ArgPtr\n                 * to get actual parameter value).  Otherwise assume it as direct.\n                 */\n                MetaPtr->Name = Name;\n                while (*MetaPtr->Name != 0)\n                {\n                    if (*MetaPtr->Name == '&')\n                    {\n                        /* this means its a pointer to the value, not the value itself */\n                        if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                        {\n                            MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;\n                        }\n                    }\n                    else if (*MetaPtr->Name != ' ')\n                    {\n                        /* stop at non-whitespace */\n                        break;\n                    }\n                    ++MetaPtr->Name;\n                }\n\n                if (MetaPtr->Type == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED)\n                {\n                    MetaPtr->Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;\n                }\n            }\n            ++StubPtr->Data.Context.ArgCount;\n        }\n    }\n}\n...\nvoid *UT_Stub_GetReturnValuePtr(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n    void *               ReturnPtr;\n\n    ReturnPtr = NULL;\n    StubPtr   = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n\n    if (StubPtr == NULL)\n    {\n        /* This shouldn't happen, it means the stub tried to use a\n         * return buffer that does not exist.\n         *\n         * It is most likely caused by a mismatch/incompatibility between\n         * stub and handler.  Aborting now is better than segfaulting later,\n         * as the errored call should still be on the stack trace\n         */\n        UtAssert_Abort(\"Return buffer invalid\");\n    }\n    else\n    {\n        ReturnPtr = StubPtr->Data.Buff.BasePtr;\n\n        /*\n         * Sanity check on the size and type name.\n         *\n         * In a generated stub these should always match, but if any patches\n         * were done or if a hand-written stub is used, mistakes could be made.\n         */\n        if (StubPtr->Data.Buff.Position != ReturnSize || strcmp(TypeName, StubPtr->Data.Buff.ContentTypeStr) != 0)\n        {\n            UtAssert_Failed(\"Return value mismatch, expected %s(%lu) got %s(%lu)\", TypeName, (unsigned long)ReturnSize,\n                            StubPtr->Data.Buff.ContentTypeStr, (unsigned long)StubPtr->Data.Buff.Position);\n        }\n    }\n\n    return ReturnPtr;\n}\n...\n#define OS_MAX_LOCAL_PATH_LEN (OS_MAX_PATH_LEN+OS_FS_PHYS_NAME_LEN)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no code fragments that modify function parameters themselves (which would violate MISRA C 2023 Rule 17.8). Specific justifications:\n\n- OS_chmod: does not assign to or increment either parameter (path or access_mode); it only passes path to OS_TranslatePath and uses access_mode as an argument to OS_FileChmod_Impl.\n\n- OS_TranslatePath: does not assign to the parameter variables VirtualPath or LocalPath. It reads from VirtualPath and writes to the object pointed to by LocalPath (via memcpy and indexing), which is permitted (the rule allows modification of the object referred to by a pointer parameter). Local pointer values (e.g., name_ptr) are local variables and not function parameters. The cast (void *)VirtualPath used when calling OS_ObjectIdGetBySearch is only a cast; it does not modify the parameter variable in this function. (If there is concern about the called function modifying the object pointed to, that is a separate const-correctness issue but not a direct violation of 17.8 in this function.)\n\n- OS_FileChmod_Impl: does not modify the parameter variables local_path or access_mode. It uses local copies/locals and modifies the st structure (a local variable), then calls fchmod using that data.\n\n- UT_ExecuteBasicHandler, UT_Stub_RegisterReturnType, UT_Stub_RegisterContextWithMetaData, UT_Stub_GetReturnValuePtr: none of these assign to their parameter variables. In particular, UT_Stub_RegisterContextWithMetaData assigns MetaPtr->Name = Name and then increments MetaPtr->Name (a struct member), but it does not modify the Name parameter variable itself.\n\n- Macros and helpers used (e.g., OS_CHECK_POINTER) are not shown as modifying parameter variables; their typical behavior is checking for NULL rather than assigning to the parameter.\n\nBecause no function parameter variable is reassigned, incremented, or otherwise modified in the provided code fragments, there are no fragments to flag for MISRA C 2023 Rule 17.8. If you want, I can also inspect implementations of called functions (e.g., OS_ObjectIdGetBySearch) or macro definitions to ensure they do not modify passed-in parameter variables when given pointers."
}