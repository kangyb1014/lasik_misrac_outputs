{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of OS_chmod:\n```c\nint32 OS_chmod(const char *path, uint32 access_mode)\n{\n    char  local_path[OS_MAX_LOCAL_PATH_LEN];\n    int32 return_code;\n\n    return_code = OS_TranslatePath(path, local_path);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_FileChmod_Impl(local_path, access_mode);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function OS_chmod:\nint32 OS_TranslatePath(const char *VirtualPath, char *LocalPath)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    const char *                  name_ptr;\n    OS_filesys_internal_record_t *filesys;\n    size_t                        SysMountPointLen;\n    size_t                        VirtPathLen;\n    size_t                        VirtPathBegin;\n\n    /*\n    ** Check to see if the path pointers are NULL\n    */\n    /* Check parameters */\n    OS_CHECK_POINTER(VirtualPath);\n    OS_CHECK_POINTER(LocalPath);\n\n    /*\n    ** Check length\n    */\n    VirtPathLen = OS_strnlen(VirtualPath, OS_MAX_PATH_LEN);\n    if (VirtPathLen >= OS_MAX_PATH_LEN)\n    {\n        return OS_FS_ERR_PATH_TOO_LONG;\n    }\n\n    /* checks to see if there is a '/' somewhere in the path */\n    name_ptr = strrchr(VirtualPath, '/');\n    if (name_ptr == NULL)\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* strrchr returns a pointer to the last '/' char, so we advance one char */\n    name_ptr = name_ptr + 1;\n    if (memchr(name_ptr, 0, OS_MAX_FILE_NAME) == NULL)\n    {\n        return OS_FS_ERR_NAME_TOO_LONG;\n    }\n\n    SysMountPointLen = 0;\n    VirtPathBegin    = VirtPathLen;\n\n    /*\n    ** All valid Virtual paths must start with a '/' character\n    */\n    if (VirtualPath[0] != '/')\n    {\n        return OS_FS_ERR_PATH_INVALID;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)VirtualPath, &token);\n\n    if (return_code != OS_SUCCESS)\n    {\n        return_code = OS_FS_ERR_PATH_INVALID;\n    }\n    else\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            SysMountPointLen = OS_strnlen(filesys->system_mountpt, sizeof(filesys->system_mountpt));\n            VirtPathBegin    = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n            if (SysMountPointLen < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(LocalPath, filesys->system_mountpt, SysMountPointLen);\n            }\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (VirtPathLen < VirtPathBegin)\n        {\n            return_code = OS_FS_ERR_PATH_INVALID;\n        }\n        else\n        {\n            VirtPathLen -= VirtPathBegin;\n            if ((SysMountPointLen + VirtPathLen) < OS_MAX_LOCAL_PATH_LEN)\n            {\n                memcpy(&LocalPath[SysMountPointLen], &VirtualPath[VirtPathBegin], VirtPathLen);\n                LocalPath[SysMountPointLen + VirtPathLen] = 0;\n            }\n            else\n            {\n                return_code = OS_FS_ERR_PATH_TOO_LONG;\n            }\n        }\n    }\n\n    return return_code;\n}\n...\nint32 OS_FileChmod_Impl(const char *local_path, uint32 access_mode)\n{\n    mode_t      readbits;\n    mode_t      writebits;\n    struct stat st;\n    int         fd;\n    int32       status;\n\n    /* Open file to avoid filename race potential */\n    fd = open(local_path, O_RDONLY, 0);\n    if (fd < 0)\n    {\n        fd = open(local_path, O_WRONLY, 0);\n        if (fd < 0)\n        {\n            OS_DEBUG(\"open(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n            return OS_ERROR;\n        }\n    }\n\n    /*\n     * NOTE: After this point, execution must proceed to the end of this routine\n     * so that the \"fd\" opened above can be properly closed.\n     */\n\n    /*\n     * In order to preserve any OTHER mode bits,\n     * first stat() the file and then modify the st_mode\n     * to match the desired access level.\n     *\n     * In particular, this should preserve the execute bit,\n     * which is generally not part of the OSAL API, but\n     * is important for the underlying OS.\n     */\n    if (fstat(fd, &st) < 0)\n    {\n        OS_DEBUG(\"fstat(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n        status = OS_ERROR;\n    }\n    else\n    {\n        /* always check world bits */\n        readbits  = S_IROTH;\n        writebits = S_IWOTH;\n\n        if (OS_IMPL_SELF_EUID == st.st_uid)\n        {\n            /* we own the file so use user bits */\n            readbits |= S_IRUSR;\n            writebits |= S_IWUSR;\n        }\n\n        if (OS_IMPL_SELF_EGID == st.st_gid)\n        {\n            /* our group owns the file so use group bits */\n            readbits |= S_IRGRP;\n            writebits |= S_IWGRP;\n        }\n\n        if (access_mode == OS_WRITE_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"write\" mode bits */\n            st.st_mode |= writebits;\n        }\n        else\n        {\n            /* clear all \"write\" mode bits */\n            st.st_mode &= ~writebits;\n        }\n\n        if (access_mode == OS_READ_ONLY || access_mode == OS_READ_WRITE)\n        {\n            /* set all \"read\" mode bits */\n            st.st_mode |= readbits;\n        }\n        else\n        {\n            /* clear all \"read\" mode bits */\n            st.st_mode &= ~readbits;\n        }\n\n        /* finally, write the modified mode back to the file */\n        if (fchmod(fd, st.st_mode) < 0)\n        {\n            /*\n             * These particular errnos generally indicate that the\n             * underlying filesystem does not support chmod()\n             *\n             * This is often the case for FAT / DOSFS filesystems\n             * which do not have UNIX-style permissions, or (in the\n             * case of EROFS) if the filesystem is mounted read-only.\n             */\n            if (errno == ENOTSUP || errno == ENOSYS || errno == EROFS)\n            {\n                status = OS_ERR_NOT_IMPLEMENTED;\n            }\n            else\n            {\n                OS_DEBUG(\"fchmod(%s): %s (%d)\\n\", local_path, strerror(errno), errno);\n                status = OS_ERROR;\n            }\n        }\n        else\n        {\n            status = OS_SUCCESS;\n        }\n    }\n\n    close(fd);\n\n    return status;\n}\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\nstatic inline size_t OS_strnlen(const char *s, size_t maxlen)\n{\n    const char *end = (const char *)memchr(s, 0, maxlen);\n    if (end != NULL)\n    {\n        /* actual length of string is difference */\n        maxlen = end - s;\n    }\n    return maxlen;\n}\n...\n#define OS_MAX_LOCAL_PATH_LEN (OS_MAX_PATH_LEN+OS_FS_PHYS_NAME_LEN)\n...\n#define OS_SUCCESS (0)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I reviewed all provided code fragments and searched for any use of the Standard Library function memcmp. No occurrences of memcmp are present. The code uses memchr and memcpy in OS_TranslatePath and OS_strnlen, and functions such as strrchr, open, fstat, fchmod, etc., but none of these perform a memcmp-style comparison of null-terminated strings. OS_strnlen uses memchr to locate the terminating NUL within a bounded length (not a memcmp). The visible macros and helper functions shown (e.g. OS_CHECK_POINTER, OS_OBJECT_TABLE_GET) do not contain memcmp in the provided snippets. Therefore there are no fragments that need investigation under MISRA C 2023 Rule 21.14 in the supplied code."
}