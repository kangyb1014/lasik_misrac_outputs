{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf OS_BSP_GetArgV() returns NULL or the ArgV array contains a NULL element (e.g. ArgV == NULL or ArgV[0] == NULL) or ArgV[0] is not NUL-terminated within its accessible bounds, then calling strcmp(ArgV[0], \"-d\") will dereference a NULL pointer or read past the object bounds. The code does not explicitly check ArgV and ArgV[0] for NULL or verify termination before calling strcmp, so this can violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_Application_Startup code that contains useful probe functions that print useful logs to a file \"/tmp/logs/63.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_Application_Startup as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_Application_Startup:\n```c\nvoid OS_Application_Startup(void)\n{\n    int32 Status;\n\n    Status = OS_API_Init();\n    if (Status != OS_SUCCESS)\n    {\n        BSP_DEBUG(\"Error: OS_API_Init() failed with status=%d\\n\", (int)Status);\n        OS_ApplicationExit(Status);\n    }\n}\n```\n</target_code>\nPlease provide the modified OS_Application_Startup code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe helper: append a log entry to /tmp/logs/63.txt. */\nstatic void Probe_Log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    fprintf(f, \"%s\\n\", msg);\n    (void)fclose(f);\n}\n\n/* Probe helper: log formatted information (small wrapper to keep simple calls). */\nstatic void Probe_LogFmt(const char *fmt, uintptr_t p, size_t val)\n{\n    FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n    /* Print pointer and a size/offset value for diagnostics. */\n    fprintf(f, fmt, (void *)p, (unsigned long)val);\n    fprintf(f, \"\\n\");\n    (void)fclose(f);\n}\n\n/* Probe the program argument vector returned by OS_BSP_GetArgV().\n * This function attempts to capture the following evidence:\n *  - Whether OS_BSP_GetArgV() returned NULL\n *  - The pointer value of ArgV and ArgV[0]\n *  - Whether ArgV[0] is NULL\n *  - Whether ArgV[0] contains a NUL character within a small bounded window\n *  - The printable contents (up to the bound) of ArgV[0]\n *\n * The probe uses a bounded scan to reduce the chance of large out-of-bounds reads.\n */\nstatic void Probe_ArgV_State(void)\n{\n    /* Attempt to obtain the argument vector from the BSP. */\n    char **ArgV = NULL;\n\n    /* OS_BSP_GetArgV is expected to be provided by the platform. */\n    ArgV = OS_BSP_GetArgV();\n\n    /* Log the returned pointer value for ArgV. */\n    {\n        char buf[128];\n        (void)snprintf(buf, sizeof(buf), \"probe: OS_BSP_GetArgV() returned %p\", (void *)ArgV);\n        Probe_Log(buf);\n    }\n\n    if (ArgV == NULL)\n    {\n        Probe_Log(\"probe: ArgV is NULL\");\n        return;\n    }\n\n    /* Log ArgV[0] pointer value. */\n    {\n        char buf[128];\n        (void)snprintf(buf, sizeof(buf), \"probe: ArgV[0] pointer = %p\", (void *)ArgV[0]);\n        Probe_Log(buf);\n    }\n\n    if (ArgV[0] == NULL)\n    {\n        Probe_Log(\"probe: ArgV[0] is NULL\");\n        return;\n    }\n\n    /* Bounded scan for NUL termination. If no NUL is found within MAX_CHECK,\n     * the probe records that fact. This is done to provide evidence that a\n     * subsequent unbounded string operation (e.g. strcmp) could read beyond\n     * the accessible object and cause a violation/CRASH.\n     */\n    const size_t MAX_CHECK = 256U;\n    size_t i;\n    int nul_found = 0;\n\n    for (i = 0U; i < MAX_CHECK; ++i)\n    {\n        /* Access ArgV[0][i] only after confirming ArgV[0] is non-NULL. This\n         * still may fault if ArgV[0] points to invalid memory; such a fault is\n         * exactly the kind of evidence the probe is intended to capture.\n         */\n        char c = ArgV[0][i];\n        if (c == '\\0')\n        {\n            nul_found = 1;\n            break;\n        }\n    }\n\n    if (nul_found)\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"probe: ArgV[0] NUL found at index %zu\", i);\n        Probe_Log(buf);\n\n        /* Log the printable content up to the NUL. */\n        FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"probe: ArgV[0] content (len=%zu): \", i);\n            /* Use a precision specifier to limit the output to i characters. */\n            fprintf(f, \"%.*s\\n\", (int)i, ArgV[0]);\n            (void)fclose(f);\n        }\n    }\n    else\n    {\n        char buf[256];\n        (void)snprintf(buf, sizeof(buf), \"probe: ArgV[0] did NOT NUL-terminate within %zu bytes\", MAX_CHECK);\n        Probe_Log(buf);\n\n        /* Log the first MAX_CHECK bytes (may contain non-printable bytes). */\n        FILE *f = fopen(\"/tmp/logs/63.txt\", \"a\");\n        if (f != NULL)\n        {\n            fprintf(f, \"probe: ArgV[0] first %zu bytes (binary-safe dump): \", MAX_CHECK);\n            /* fwrite is used to avoid interpretation; follow with newline. */\n            (void)fwrite(ArgV[0], 1, MAX_CHECK, f);\n            fprintf(f, \"\\n\");\n            (void)fclose(f);\n        }\n    }\n}\n\n/* Modified OS_Application_Startup: preserves original control flow. The probe is\n * invoked after successful OS_API_Init() to capture argument vector state that\n * may lead to Rule 21.17 violations when unguarded string functions are used.\n */\nvoid OS_Application_Startup(void)\n{\n    int32 Status;\n\n    Status = OS_API_Init();\n    if (Status != OS_SUCCESS)\n    {\n        BSP_DEBUG(\"Error: OS_API_Init() failed with status=%d\\n\", (int)Status);\n        OS_ApplicationExit(Status);\n    }\n\n    /* Probe current argument state for diagnostic evidence. This does not\n     * change program logic or error handling; it only emits logs for\n     * investigation of potential string handling violations. */\n    Probe_ArgV_State();\n}\n"
}