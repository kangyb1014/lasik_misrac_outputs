{
  "user_message": "Target function code is:\n```c\nvoid OS_Posix_CompAbsDelayTime(uint32 msecs, struct timespec *tm)\n{\n    clock_gettime(CLOCK_REALTIME, tm);\n\n    /* add the delay to the current time */\n    tm->tv_sec += (time_t)(msecs / 1000);\n    /* convert residue ( msecs )  to nanoseconds */\n    tm->tv_nsec += (msecs % 1000) * 1000000L;\n\n    if (tm->tv_nsec >= 1000000000L)\n    {\n        tm->tv_nsec -= 1000000000L;\n        tm->tv_sec++;\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_Posix_CompAbsDelayTime': {'callees': [], 'callers': ['OS_BinSemTimedWait_Impl', 'OS_CountSemTimedWait_Impl', 'OS_QueueGet_Impl']}, 'OS_BinSemTimedWait_Impl': {'callees': ['OS_Posix_CompAbsDelayTime', 'OS_GenericBinSemTake_Impl'], 'callers': ['OS_BinSemTimedWait']}, 'OS_CountSemTimedWait_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_Posix_CompAbsDelayTime'], 'callers': ['OS_CountSemTimedWait']}, 'OS_QueueGet_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_Posix_CompAbsDelayTime'], 'callers': ['OS_QueueGet']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "clock_gettime",
    "CLOCK_REALTIME",
    "struct timespec",
    "time_t",
    "uint32 (typedef for parameter msecs)"
  ],
  "explanation": "To decide whether OS_Posix_CompAbsDelayTime uses any compiler language extensions you must inspect the declarations/definitions of all non-local symbols and types it relies on:\n\n- clock_gettime: This is an external POSIX function or macro; its prototype/definition must be checked to see if it is provided via a standard header or if it is implemented as a compiler/library extension or macro that uses compiler-specific constructs/attributes.\n\n- CLOCK_REALTIME: This macro/constant comes from the system headers. Its definition must be examined to ensure it is a standard macro and not a compiler-specific extension or alias to some nonstandard entity.\n\n- struct timespec: The structure layout and member types (tv_sec, tv_nsec) must be inspected for any nonstandard/implementation-specific types or compiler extensions (e.g. use of __attribute__, nonstandard integer widths, or compiler-specific member types).\n\n- time_t: The type of tv_sec and the cast (time_t)(...) must be checked to determine whether time_t is a standard typedef or a compiler/library extension (for example a nonstandard width type or an implementation that requires feature-test macros).\n\n- uint32 (typedef for parameter msecs): The parameter type must be resolved to its underlying type (e.g. unsigned int, uint32_t, unsigned long, or a compiler-specific typedef). If uint32 is a project typedef that maps to a nonstandard or compiler-specific width/type, that could be a language/implementation extension.\n\nInspecting these symbols (typically via the relevant headers such as <time.h> and the project typedefs) is sufficient to determine whether the function relies on any compiler-specific language extensions. Other tokens in the function (casts, integer suffix 'L', arithmetic, member access) are standard C constructs and only need type/declaration information above to verify they do not hide extensions."
}