{
  "user_message": "An agent A claimed that the following OS_BinSemDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_BinSemDelete.\n```c\nint32 OS_BinSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_BinSemDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_NotifyEvent takes a non-const void *data parameter but does not modify the pointed-to data \u2014 it only forwards the pointer to the registered EventHandler. According to MISRA C 2023 Rule 8.13, the pointer should be to a const-qualified type when possible. Therefore the parameter should be declared as const void *data (and the EventHandler callback type updated accordingly). If the design intentionally allows the handler to mutate the data, then the non-const is justified; otherwise this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_BinSemDelete_Log(const char *stage, unsigned long sem_id_val, long return_code_val, const void *token_ptr)\n{\n    FILE *f = fopen(\"/tmp/logs/939.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* timestamp would be useful but avoid extra dependencies; keep entry concise */\n        fprintf(f, \"%s: sem_id=%lu, return_code=%ld, token_ptr=%p\\n\", stage, sem_id_val, return_code_val, token_ptr);\n        fclose(f);\n    }\n}\n\nint32 OS_BinSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry point and the semaphore id. token address is stable even before initialization. */\n    OS_BinSemDelete_Log(\"Entry\", (unsigned long)sem_id, 0L, (const void *)&token);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Record result of lookup and the token address returned to caller */\n    OS_BinSemDelete_Log(\"After_GetById\", (unsigned long)sem_id, (long)return_code, (const void *)&token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Record before calling the platform-specific implementation */\n        OS_BinSemDelete_Log(\"Before_Impl\", (unsigned long)sem_id, (long)return_code, (const void *)&token);\n\n        return_code = OS_BinSemDelete_Impl(&token);\n\n        /* Record after implementation completes */\n        OS_BinSemDelete_Log(\"After_Impl\", (unsigned long)sem_id, (long)return_code, (const void *)&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Record finalization result */\n        OS_BinSemDelete_Log(\"After_FinalizeDelete\", (unsigned long)sem_id, (long)return_code, (const void *)&token);\n    }\n\n    /* Log exit and final return code */\n    OS_BinSemDelete_Log(\"Exit\", (unsigned long)sem_id, (long)return_code, (const void *)&token);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEntry: sem_id=0, return_code=0, token_ptr=0x7ffff9c9a120\nAfter_GetById: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a120\nExit: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a120\nEntry: sem_id=0, return_code=0, token_ptr=0x7ffff9c9a0a0\nAfter_GetById: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a0a0\nExit: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a0a0\nEntry: sem_id=3735928559, return_code=0, token_ptr=0x7ffff9c9a150\nAfter_GetById: sem_id=3735928559, return_code=-16, token_ptr=0x7ffff9c9a150\nExit: sem_id=3735928559, return_code=-16, token_ptr=0x7ffff9c9a150\nEntry: sem_id=0, return_code=0, token_ptr=0x7ffff9c9a150\nAfter_GetById: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a150\nExit: sem_id=0, return_code=-16, token_ptr=0x7ffff9c9a150\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 requires pointers to be const-qualified only when the pointed-to object is not intended to be modified. In OS_BinSemDelete the address of a local OS_object_token_t is passed to OS_ObjectIdGetById, OS_BinSemDelete_Impl and OS_ObjectIdFinalizeDelete; these APIs are intended to populate/consume and potentially modify the token (e.g. GetById fills the token, FinalizeDelete will operate on it). Therefore the token parameter cannot reasonably be declared const, so no Rule 8.13 violation exists here. Additionally, the scenario offered by agent A discusses OS_NotifyEvent and a void *data parameter \u2014 a different API than the code shown \u2014 so it does not demonstrate a Rule 8.13 violation in OS_BinSemDelete. Consequently the report is incorrect."
}