{
  "user_message": "An agent A claimed that the following OS_SocketOpen_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketOpen_Impl.\n```c\nint32 OS_SocketOpen_Impl(const OS_object_token_t *token)\n{\n    int                             os_domain;\n    int                             os_type;\n    int                             os_proto;\n    int                             os_flags;\n    OS_impl_file_internal_record_t *impl;\n    OS_stream_internal_record_t *   stream;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n    stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    os_proto = 0;\n\n    switch (stream->socket_type)\n    {\n        case OS_SocketType_DATAGRAM:\n            os_type  = SOCK_DGRAM;\n            os_proto = IPPROTO_UDP;\n            break;\n\n        case OS_SocketType_STREAM:\n            os_type  = SOCK_STREAM;\n            os_proto = IPPROTO_TCP;\n            break;\n\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    switch (stream->socket_domain)\n    {\n        case OS_SocketDomain_INET:\n            os_domain = AF_INET;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            os_domain = AF_INET6;\n            break;\n#endif\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    impl->fd = socket(os_domain, os_type, os_proto);\n    if (impl->fd < 0)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Setting the REUSEADDR flag helps during debugging when there might be frequent\n     * code restarts.  However if setting the option fails then it is not worth bailing out over.\n     */\n    os_flags = 1;\n    setsockopt(impl->fd, SOL_SOCKET, SO_REUSEADDR, &os_flags, sizeof(os_flags));\n\n    /*\n     * Set the standard options on the filehandle by default --\n     * this may set it to non-blocking mode if the implementation supports it.\n     * any blocking would be done explicitly via the select() wrappers\n     *\n     * NOTE: The implementation still generally works without this flag set, but\n     * nonblock mode does improve robustness in the event that multiple tasks\n     * attempt to accept new connections from the same server socket at the same time.\n     */\n    OS_IMPL_SET_SOCKET_FLAGS(token);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'stream' is declared as a non-const pointer (OS_stream_internal_record_t *stream) but is only used for read-only access (reading socket_type and socket_domain). Per MISRA C 2023 Rule 8.13 it should point to a const-qualified type, e.g. const OS_stream_internal_record_t *stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SocketOpen_LogState(const OS_object_token_t *token,\n                                  const OS_stream_internal_record_t *stream,\n                                  OS_impl_file_internal_record_t *impl,\n                                  const char *stage,\n                                  int os_domain,\n                                  int os_type,\n                                  int os_proto)\n{\n    FILE *f = fopen(\"/tmp/logs/891.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"Stage: %s\\n\", stage ? stage : \"(null)\");\n    fprintf(f, \"token: %p\\n\", (const void *)token);\n\n    if (stream != NULL)\n    {\n        /* log the two fields reported in the violation scenario */\n        fprintf(f, \"stream: %p, socket_type: %d, socket_domain: %d\\n\",\n                (const void *)stream,\n                (int)stream->socket_type,\n                (int)stream->socket_domain);\n    }\n    else\n    {\n        fprintf(f, \"stream: NULL\\n\");\n    }\n\n    if (impl != NULL)\n    {\n        fprintf(f, \"impl: %p, fd: %d\\n\", (void *)impl, impl->fd);\n    }\n    else\n    {\n        fprintf(f, \"impl: NULL\\n\");\n    }\n\n    if (os_domain >= 0 || os_type >= 0 || os_proto >= 0)\n    {\n        fprintf(f, \"os_domain: %d, os_type: %d, os_proto: %d\\n\",\n                os_domain, os_type, os_proto);\n    }\n\n    fprintf(f, \"errno: %d (%s)\\n\", errno, strerror(errno));\n    fprintf(f, \"----\\n\");\n    fclose(f);\n}\n\nint32 OS_SocketOpen_Impl(const OS_object_token_t *token)\n{\n    int                             os_domain;\n    int                             os_type;\n    int                             os_proto;\n    int                             os_flags;\n    OS_impl_file_internal_record_t *impl;\n    OS_stream_internal_record_t *   stream;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n    stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    /* Log state after object table lookups */\n    OS_SocketOpen_LogState(token, stream, impl, \"after_lookup\", -1, -1, -1);\n\n    os_proto = 0;\n\n    switch (stream->socket_type)\n    {\n        case OS_SocketType_DATAGRAM:\n            os_type  = SOCK_DGRAM;\n            os_proto = IPPROTO_UDP;\n            break;\n\n        case OS_SocketType_STREAM:\n            os_type  = SOCK_STREAM;\n            os_proto = IPPROTO_TCP;\n            break;\n\n        default:\n            /* Log unsupported socket type and return */\n            OS_SocketOpen_LogState(token, stream, impl, \"unsupported_socket_type\", -1, -1, -1);\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    switch (stream->socket_domain)\n    {\n        case OS_SocketDomain_INET:\n            os_domain = AF_INET;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            os_domain = AF_INET6;\n            break;\n#endif\n        default:\n            /* Log unsupported socket domain and return */\n            OS_SocketOpen_LogState(token, stream, impl, \"unsupported_socket_domain\", -1, -1, -1);\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    /* Log parameters selected for socket creation */\n    OS_SocketOpen_LogState(token, stream, impl, \"before_socket\", os_domain, os_type, os_proto);\n\n    impl->fd = socket(os_domain, os_type, os_proto);\n    if (impl->fd < 0)\n    {\n        /* Log socket failure including errno */\n        OS_SocketOpen_LogState(token, stream, impl, \"socket_failed\", os_domain, os_type, os_proto);\n        return OS_ERROR;\n    }\n\n    /* Log successful socket creation */\n    OS_SocketOpen_LogState(token, stream, impl, \"socket_created\", os_domain, os_type, os_proto);\n\n    /*\n     * Setting the REUSEADDR flag helps during debugging when there might be frequent\n     * code restarts.  However if setting the option fails then it is not worth bailing out over.\n     */\n    os_flags = 1;\n    setsockopt(impl->fd, SOL_SOCKET, SO_REUSEADDR, &os_flags, sizeof(os_flags));\n\n    /*\n     * Set the standard options on the filehandle by default --\n     * this may set it to non-blocking mode if the implementation supports it.\n     * any blocking would be done explicitly via the select() wrappers\n     *\n     * NOTE: The implementation still generally works without this flag set, but\n     * nonblock mode does improve robustness in the event that multiple tasks\n     * attempt to accept new connections from the same server socket at the same time.\n     */\n    OS_IMPL_SET_SOCKET_FLAGS(token);\n\n    /* Final state before successful return */\n    OS_SocketOpen_LogState(token, stream, impl, \"return_success\", os_domain, os_type, os_proto);\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketOpen_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the shown OS_SocketOpen_Impl implementation the local pointer variable stream is only used for read-only accesses (stream->socket_type and stream->socket_domain) and is never used to modify the pointed object. Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so declaring stream as const OS_stream_internal_record_t *stream (or otherwise const-qualifying the result of OS_OBJECT_TABLE_GET when assigned) would be the appropriate correction. The presence of impl as a non-const pointer is fine because impl->fd is written. The logging/test code and typical macro behavior do not prevent making stream const; conversion from OS_stream_internal_record_t * to const OS_stream_internal_record_t * is allowed. (If some other code or macro used later required a non-const pointer, that would be a reason not to qualify const, but nothing in the provided function prevents making stream const.)"
}