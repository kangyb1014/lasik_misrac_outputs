{
  "user_message": "An agent A claimed that the following OS_SocketOpen_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketOpen_Impl.\n```c\nint32 OS_SocketOpen_Impl(const OS_object_token_t *token)\n{\n    int                             os_domain;\n    int                             os_type;\n    int                             os_proto;\n    int                             os_flags;\n    OS_impl_file_internal_record_t *impl;\n    OS_stream_internal_record_t *   stream;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n    stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    os_proto = 0;\n\n    switch (stream->socket_type)\n    {\n        case OS_SocketType_DATAGRAM:\n            os_type  = SOCK_DGRAM;\n            os_proto = IPPROTO_UDP;\n            break;\n\n        case OS_SocketType_STREAM:\n            os_type  = SOCK_STREAM;\n            os_proto = IPPROTO_TCP;\n            break;\n\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    switch (stream->socket_domain)\n    {\n        case OS_SocketDomain_INET:\n            os_domain = AF_INET;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            os_domain = AF_INET6;\n            break;\n#endif\n        default:\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    impl->fd = socket(os_domain, os_type, os_proto);\n    if (impl->fd < 0)\n    {\n        return OS_ERROR;\n    }\n\n    /*\n     * Setting the REUSEADDR flag helps during debugging when there might be frequent\n     * code restarts.  However if setting the option fails then it is not worth bailing out over.\n     */\n    os_flags = 1;\n    setsockopt(impl->fd, SOL_SOCKET, SO_REUSEADDR, &os_flags, sizeof(os_flags));\n\n    /*\n     * Set the standard options on the filehandle by default --\n     * this may set it to non-blocking mode if the implementation supports it.\n     * any blocking would be done explicitly via the select() wrappers\n     *\n     * NOTE: The implementation still generally works without this flag set, but\n     * nonblock mode does improve robustness in the event that multiple tasks\n     * attempt to accept new connections from the same server socket at the same time.\n     */\n    OS_IMPL_SET_SOCKET_FLAGS(token);\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer 'stream' is declared as a non-const pointer (OS_stream_internal_record_t *stream) but is only used for reads (stream->socket_type and stream->socket_domain) and is not modified in OS_SocketOpen_Impl. According to MISRA C 2023 Rule 8.13, it should be declared to point to a const-qualified type (const OS_stream_internal_record_t *stream). Assigning the non-const result of OS_OBJECT_TABLE_GET to a const-qualified pointer is permissible, so the current declaration violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_SocketOpen_Impl(const OS_object_token_t *token)\n{\n    int                             os_domain;\n    int                             os_type;\n    int                             os_proto;\n    int                             os_flags;\n    OS_impl_file_internal_record_t *impl;\n    OS_stream_internal_record_t *   stream;\n\n    impl   = OS_OBJECT_TABLE_GET(OS_impl_filehandle_table, *token);\n    stream = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    /* Probe: Log initial state immediately after retrieving the objects */\n    {\n        FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n        if (log != NULL)\n        {\n            /* Print the token pointer (token may be an aggregate type) */\n            fprintf(log, \"OS_SocketOpen_Impl: entry token=%p impl=%p stream=%p socket_type=%d socket_domain=%d\\n\",\n                    (const void *)token, (void *)impl, (void *)stream,\n                    (int)stream->socket_type, (int)stream->socket_domain);\n            fclose(log);\n        }\n    }\n\n    os_proto = 0;\n\n    switch (stream->socket_type)\n    {\n        case OS_SocketType_DATAGRAM:\n            os_type  = SOCK_DGRAM;\n            os_proto = IPPROTO_UDP;\n            /* Log decision for datagram */\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_type=DATAGRAM -> os_type=%d os_proto=%d\\n\",\n                            os_type, os_proto);\n                    fclose(log);\n                }\n            }\n            break;\n\n        case OS_SocketType_STREAM:\n            os_type  = SOCK_STREAM;\n            os_proto = IPPROTO_TCP;\n            /* Log decision for stream */\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_type=STREAM -> os_type=%d os_proto=%d\\n\",\n                            os_type, os_proto);\n                    fclose(log);\n                }\n            }\n            break;\n\n        default:\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_type=UNKNOWN (%d) -> NOT_IMPLEMENTED\\n\",\n                            (int)stream->socket_type);\n                    fclose(log);\n                }\n            }\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    switch (stream->socket_domain)\n    {\n        case OS_SocketDomain_INET:\n            os_domain = AF_INET;\n            /* Log domain selection */\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_domain=INET -> os_domain=%d\\n\", os_domain);\n                    fclose(log);\n                }\n            }\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case OS_SocketDomain_INET6:\n            os_domain = AF_INET6;\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_domain=INET6 -> os_domain=%d\\n\", os_domain);\n                    fclose(log);\n                }\n            }\n            break;\n#endif\n        default:\n            {\n                FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n                if (log != NULL)\n                {\n                    fprintf(log, \"OS_SocketOpen_Impl: socket_domain=UNKNOWN (%d) -> NOT_IMPLEMENTED\\n\",\n                            (int)stream->socket_domain);\n                    fclose(log);\n                }\n            }\n            return OS_ERR_NOT_IMPLEMENTED;\n    }\n\n    impl->fd = socket(os_domain, os_type, os_proto);\n\n    /* Log the result of the socket() call */\n    {\n        FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_SocketOpen_Impl: socket() -> fd=%d\\n\", impl->fd);\n            fclose(log);\n        }\n    }\n\n    if (impl->fd < 0)\n    {\n        FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_SocketOpen_Impl: socket() failed -> OS_ERROR\\n\");\n            fclose(log);\n        }\n        return OS_ERROR;\n    }\n\n    /*\n     * Setting the REUSEADDR flag helps during debugging when there might be frequent\n     * code restarts.  However if setting the option fails then it is not worth bailing out over.\n     */\n    os_flags = 1;\n    setsockopt(impl->fd, SOL_SOCKET, SO_REUSEADDR, &os_flags, sizeof(os_flags));\n\n    /*\n     * Set the standard options on the filehandle by default --\n     * this may set it to non-blocking mode if the implementation supports it.\n     * any blocking would be done explicitly via the select() wrappers\n     *\n     * NOTE: The implementation still generally works without this flag set, but\n     * nonblock mode does improve robustness in the event that multiple tasks\n     * attempt to accept new connections from the same server socket at the same time.\n     */\n    OS_IMPL_SET_SOCKET_FLAGS(token);\n\n    /* Final log on success */\n    {\n        FILE *log = fopen(\"/tmp/logs/891.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"OS_SocketOpen_Impl: exit -> OS_SUCCESS token=%p impl=%p stream=%p fd=%d\\n\",\n                    (const void *)token, (void *)impl, (void *)stream, impl->fd);\n            fclose(log);\n        }\n    }\n\n    return OS_SUCCESS;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketOpen_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In OS_SocketOpen_Impl the local variable stream is only used to read members (stream->socket_type and stream->socket_domain) and is never used to modify the pointed-to object. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so stream could and should be declared as const OS_stream_internal_record_t *stream. Assigning the non-const result of OS_OBJECT_TABLE_GET to a pointer-to-const is permitted, so the current non-const declaration constitutes a violation of the rule (unless a documented rationale/deviation exists). Note that impl must remain non-const because impl->fd is written, and that changing stream to const should be verified against any other uses (macros or later edits) that might require a non-const pointer."
}