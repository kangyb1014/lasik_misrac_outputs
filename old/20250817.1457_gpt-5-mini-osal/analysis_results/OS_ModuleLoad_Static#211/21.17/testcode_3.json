{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe code calls strcmp(StaticSym->Module, ModuleName) after checking only that StaticSym->Module != NULL, but it does not check ModuleName. If ModuleName is NULL (or points to a non-null-terminated or too-short buffer), strcmp will dereference beyond the bounds of the object referenced by ModuleName, causing undefined behavior and violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ModuleLoad_Static code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1695.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ModuleLoad_Static as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ModuleLoad_Static:\n```c\nint32 OS_ModuleLoad_Static(const char *ModuleName)\n{\n    int32                      return_code = OS_ERR_NAME_NOT_FOUND;\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    while (StaticSym != NULL)\n    {\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list  */\n            break;\n        }\n        if (StaticSym->Module != NULL && strcmp(StaticSym->Module, ModuleName) == 0)\n        {\n            /* found matching module name */\n            return_code = OS_SUCCESS;\n            break;\n        }\n\n        ++StaticSym;\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ModuleLoad_Static code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Minimal local type aliases so this file is self-contained for compilation. */\ntypedef int32_t int32;\n\ntypedef struct OS_static_symbol_record\n{\n    const char *Name;\n    const char *Module;\n} OS_static_symbol_record_t;\n\n/* The real symbol table pointer is provided elsewhere in the system. */\nextern OS_static_symbol_record_t *OS_STATIC_SYMTABLE_SOURCE;\n\n/*\n * Logging helper - append a single line describing the current state to the\n * investigation log. This function intentionally does NOT dereference\n * ModuleName (other than printing its pointer value) to avoid creating new\n * undefined behavior during logging. It only prints pointer values and\n * simple flags. The file is opened/appended on every call to keep logs even\n * if the process is terminated unexpectedly.\n */\nstatic void probe_log_state(const char *stage, const OS_static_symbol_record_t *sym, const char *ModuleName,\n                            int name_is_null, int module_is_null, int cmp_valid, int cmp_value)\n{\n    FILE *f = fopen(\"/tmp/logs/1695.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Print stage, addresses, null flags and optional strcmp result. */\n    fprintf(f, \"stage=%s sym=%p Name_ptr=%p Module_ptr=%p ModuleName_ptr=%p name_is_null=%d module_is_null=%d\",\n            stage,\n            (void *)sym,\n            (void *)(sym ? (void *)sym->Name : NULL),\n            (void *)(sym ? (void *)sym->Module : NULL),\n            (void *)ModuleName,\n            name_is_null,\n            module_is_null);\n\n    if (cmp_valid)\n    {\n        fprintf(f, \" cmp=%d\", cmp_value);\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/*\n * The original function logic is preserved. Logging probes are inserted so\n * that callers and testers can observe the control path and the pointer\n * values leading up to the strcmp invocation which may trigger the\n * violation scenario when ModuleName is NULL or otherwise invalid.\n */\nint32 OS_ModuleLoad_Static(const char *ModuleName)\n{\n    int32                      return_code = (int32) -1; /* OS_ERR_NAME_NOT_FOUND */\n    OS_static_symbol_record_t *StaticSym   = OS_STATIC_SYMTABLE_SOURCE;\n\n    /* Log entry into function with ModuleName pointer */\n    probe_log_state(\"enter\", StaticSym, ModuleName, 0, 0, 0, 0);\n\n    while (StaticSym != NULL)\n    {\n        /* Log the state at start of iteration. Do not dereference ModuleName. */\n        probe_log_state(\"iter_start\", StaticSym, ModuleName,\n                        (StaticSym->Name == NULL) ? 1 : 0,\n                        (StaticSym->Module == NULL) ? 1 : 0,\n                        0, 0);\n\n        if (StaticSym->Name == NULL)\n        {\n            /* end of list  */\n            probe_log_state(\"end_of_list\", StaticSym, ModuleName, 1,\n                            (StaticSym->Module == NULL) ? 1 : 0, 0, 0);\n            break;\n        }\n\n        if (StaticSym->Module != NULL && strcmp(StaticSym->Module, ModuleName) == 0)\n        {\n            /* Log that we performed strcmp and observed equality */\n            /* We call strcmp exactly as in the original logic to preserve behavior. */\n            /* To capture the actual strcmp result we re-evaluate and log the value. */\n            int cmp = strcmp(StaticSym->Module, ModuleName);\n            probe_log_state(\"strcmp_after_call\", StaticSym, ModuleName, 0, 0, 1, cmp);\n\n            if (cmp == 0)\n            {\n                /* found matching module name */\n                return_code = 0; /* OS_SUCCESS */\n                probe_log_state(\"found\", StaticSym, ModuleName, 0, 0, 1, cmp);\n                break;\n            }\n        }\n\n        ++StaticSym;\n    }\n\n    probe_log_state(\"exit\", StaticSym, ModuleName, 0, 0, 0, 0);\n    return return_code;\n}\n"
}