{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nCalling strcmp(ArgV[0], \"-q\") can read beyond bounds if ArgV or ArgV[0] is NULL or ArgV[0] does not point to a NUL-terminated buffer. The code only checks ArgC>0 but does not validate that OS_BSP_GetArgV() returned a non-NULL pointer nor that ArgV[0] is non-NULL/NUL-terminated. If OS_BSP_GetArgV() returned NULL or an array with a NULL/unterminated element, the strcmp call would access out-of-bounds.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UT_BSP_DoText code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2711.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UT_BSP_DoText as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UT_BSP_DoText:\n```c\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n```\n</target_code>\nPlease provide the modified UT_BSP_DoText code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <string.h>\n\n/* Helper logging function that appends timestamped diagnostic lines to /tmp/logs/2711.txt */\nstatic void UT_BSP_Log(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f;\n\n    /* Ensure directory exists; ignore errors if it already exists */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    f = fopen(\"/tmp/logs/2711.txt\", \"a\");\n    if (!f)\n    {\n        return; /* Best-effort logging only */\n    }\n\n    /* Timestamp */\n    {\n        time_t t = time(NULL);\n        struct tm tm;\n        if (localtime_r(&t, &tm) != NULL)\n        {\n            fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n                    tm.tm_hour, tm.tm_min, tm.tm_sec);\n        }\n    }\n\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    /* Log entry and key parameter state (pointer values only to avoid additional risky reads) */\n    UT_BSP_Log(\"ENTER: UT_BSP_DoText MessageType=%u OutputMessage_ptr=%p CurrVerbosity=0x%08x\",\n               (unsigned)MessageType, (const void *)OutputMessage, (unsigned)BSP_UT_Global.CurrVerbosity);\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Log(\"Path: MsgEnabled & 1 is true (MsgEnabled=0x%08x)\", (unsigned)MsgEnabled);\n\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                UT_BSP_Log(\"Switch: ABORT/FAIL - TermModeBits set to 0x%08x\", (unsigned)TermModeBits);\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                UT_BSP_Log(\"Switch: MIR/WARN - TermModeBits set to 0x%08x\", (unsigned)TermModeBits);\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                UT_BSP_Log(\"Switch: TSF/TTF - TermModeBits set to 0x%08x\", (unsigned)TermModeBits);\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                UT_BSP_Log(\"Switch: BEGIN - writing extra newline\");\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                UT_BSP_Log(\"Switch: PASS - TermModeBits set to 0x%08x\", (unsigned)TermModeBits);\n                break;\n            default:\n                UT_BSP_Log(\"Switch: default - no special term mode\");\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n            UT_BSP_Log(\"MsgEnabled <= 1 - forcing TermModeBits to NORMAL\");\n        }\n\n        /* Capture the case-type abbreviation pointer and, if available, its text (best-effort) */\n        const char *abbrev = UtAssert_GetCaseTypeAbbrev(MessageType);\n        if (abbrev != NULL)\n        {\n            /* Log pointer and a bounded snapshot of the abbreviation string */\n            char abbrev_snap[32] = {0};\n            /* Use strncpy-like safe copy but do not assume source length; copy up to sizeof(abbrev_snap)-1 */\n            (void)strncpy(abbrev_snap, abbrev, sizeof(abbrev_snap) - 1);\n            UT_BSP_Log(\"Abbrev_ptr=%p Abbrev_text=\\\"%s\\\"\", (const void *)abbrev, abbrev_snap);\n        }\n        else\n        {\n            UT_BSP_Log(\"Abbrev_ptr=NULL\");\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            UT_BSP_Log(\"Setting console mode to 0x%08x before writing prefix\", (unsigned)TermModeBits);\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n\n        /* Log pointer again before the strlen call to capture pointer state prior to potential risky read */\n        UT_BSP_Log(\"About to compute MsgLen: OutputMessage_ptr=%p\", (const void *)OutputMessage);\n\n        MsgLen = strlen(OutputMessage);\n        UT_BSP_Log(\"Computed MsgLen=%zu for OutputMessage_ptr=%p\", MsgLen, (const void *)OutputMessage);\n\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n            UT_BSP_Log(\"Appended terminating newline for message (was_missing=%d)\", (int)(MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n'));\n        }\n\n        UT_BSP_Unlock();\n\n        UT_BSP_Log(\"Exit: completed message output path for MessageType=%u\", (unsigned)MessageType);\n    }\n    else\n    {\n        UT_BSP_Log(\"Path: MsgEnabled & 1 is false (MsgEnabled=0x%08x) - skipping output\", (unsigned)MsgEnabled);\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        UT_BSP_Log(\"MessageType is ABORT - calling OS_BSP_Shutdown_Impl\");\n        OS_BSP_Shutdown_Impl();\n    }\n    else\n    {\n        UT_BSP_Log(\"No shutdown - MessageType=%u\", (unsigned)MessageType);\n    }\n}\n"
}