{
  "user_message": "An agent A claimed that the following UT_BSP_DoText code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_BSP_DoText.\n```c\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n        MsgLen = strlen(OutputMessage);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        OS_BSP_Shutdown_Impl();\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes a const char * (OutputMessage) to OS_BSP_ConsoleOutput_Impl. If OS_BSP_ConsoleOutput_Impl is declared as taking a non-const pointer (e.g. void OS_BSP_ConsoleOutput_Impl(char *buf, size_t len)), this discards the const qualifier and thus violates MISRA C 2023 Rule 8.13. The remedy is to declare the function parameter as const char * (e.g. void OS_BSP_ConsoleOutput_Impl(const char *buf, size_t len)).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_BSP_EnsureLogDir(void)\n{\n    /* Attempt to create the directory; ignore errors other than non-existence.\n     * If the directory already exists, mkdir will fail and errno will be EEXIST. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n}\nstatic void UT_BSP_AppendLog(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fp;\n\n    UT_BSP_EnsureLogDir();\n    fp = fopen(\"/tmp/logs/2707.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\nstatic void UT_BSP_LogEventEntry(uint8 MessageType, const char *OutputMessage, uint32 MsgEnabled)\n{\n    UT_BSP_AppendLog(\"ENTER UT_BSP_DoText: MessageType=%u OutputMessage=%p MsgEnabled=%u\",\n                     (unsigned)MessageType, (const void *)OutputMessage, (unsigned)MsgEnabled);\n\n    if (OutputMessage != NULL)\n    {\n        /* Print a small prefix of the message to avoid huge logs */\n        UT_BSP_AppendLog(\"  OutputMessage[0..63] = '%.*s'\",\n                         64, OutputMessage);\n    }\n    else\n    {\n        UT_BSP_AppendLog(\"  OutputMessage is NULL\");\n    }\n}\nstatic void UT_BSP_LogModeCall(const char *who, uint32 ModeBits)\n{\n    UT_BSP_AppendLog(\"MODE CALL %s: ModeBits=0x%08x\", who, (unsigned)ModeBits);\n}\nstatic void UT_BSP_LogOutputCall(const char *who, const char *buf, size_t len)\n{\n    /* Log caller, pointer, length and a truncated preview of the buffer contents. */\n    size_t preview = (len > 128) ? 128U : len;\n    UT_BSP_AppendLog(\"OUTPUT CALL %s: buf=%p len=%zu preview='%.*s'\",\n                     who, (const void *)buf, len, (int)preview, (buf != NULL) ? buf : \"(null)\");\n}\n\nvoid UT_BSP_DoText(uint8 MessageType, const char *OutputMessage)\n{\n    char   Buffer[16];\n    size_t MsgLen;\n    uint32 TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n    uint32 MsgEnabled   = BSP_UT_Global.CurrVerbosity >> MessageType;\n\n    /* Log entry after MsgEnabled is computed so callers can reproduce the scenario. */\n    UT_BSP_LogEventEntry(MessageType, OutputMessage, MsgEnabled);\n\n    if (MsgEnabled & 1)\n    {\n        UT_BSP_Lock();\n\n        /* Determine if the message type warrants special treatment (color/highlight/etc). */\n        switch (MessageType)\n        {\n            case UTASSERT_CASETYPE_ABORT:\n            case UTASSERT_CASETYPE_FAILURE:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED;\n                break;\n            case UTASSERT_CASETYPE_MIR:\n            case UTASSERT_CASETYPE_WARN:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            case UTASSERT_CASETYPE_TSF:\n            case UTASSERT_CASETYPE_TTF:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_RED | OS_BSP_CONSOLEMODE_BLUE;\n                break;\n            case UTASSERT_CASETYPE_BEGIN:\n                /* log before calling the console output implementation with a string literal */\n                UT_BSP_LogOutputCall(\"Begin-Newline\", \"\\n\", 1);\n                OS_BSP_ConsoleOutput_Impl(\"\\n\", 1); /* add a bit of extra whitespace between tests */\n                break;\n            case UTASSERT_CASETYPE_PASS:\n                TermModeBits = OS_BSP_CONSOLEMODE_HIGHLIGHT | OS_BSP_CONSOLEMODE_GREEN;\n                break;\n            default:\n                break;\n        }\n\n        if (MsgEnabled <= 1)\n        {\n            TermModeBits = OS_BSP_CONSOLEMODE_NORMAL;\n        }\n\n        snprintf(Buffer, sizeof(Buffer), \"[%5s]\", UtAssert_GetCaseTypeAbbrev(MessageType));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            UT_BSP_LogModeCall(\"Pre-SetMode\", TermModeBits);\n            OS_BSP_ConsoleSetMode_Impl(TermModeBits);\n        }\n\n        /* Log the Buffer output before calling the implementation */\n        UT_BSP_LogOutputCall(\"Buffer\", Buffer, strlen(Buffer));\n        OS_BSP_ConsoleOutput_Impl(Buffer, strlen(Buffer));\n\n        if (TermModeBits != OS_BSP_CONSOLEMODE_NORMAL)\n        {\n            UT_BSP_LogModeCall(\"Restore-Normal\", OS_BSP_CONSOLEMODE_NORMAL);\n            OS_BSP_ConsoleSetMode_Impl(OS_BSP_CONSOLEMODE_NORMAL);\n        }\n\n        UT_BSP_LogOutputCall(\"Space\", \" \", 1);\n        OS_BSP_ConsoleOutput_Impl(\" \", 1);\n\n        MsgLen = strlen(OutputMessage);\n\n        /* Log the potentially problematic call where a const char* is passed to the impl */\n        UT_BSP_LogOutputCall(\"OutputMessage\", OutputMessage, MsgLen);\n        OS_BSP_ConsoleOutput_Impl(OutputMessage, MsgLen);\n\n        if (MsgLen == 0 || OutputMessage[MsgLen - 1] != '\\n')\n        {\n            UT_BSP_LogOutputCall(\"Trailing-Newline\", \"\\n\", 1);\n            OS_BSP_ConsoleOutput_Impl(\"\\n\", 1);\n        }\n\n        UT_BSP_Unlock();\n    }\n\n    /*\n     * If any ABORT (major failure) message is thrown,\n     * then call a BSP-provided routine to stop the test and possibly dump a core\n     */\n    if (MessageType == UTASSERT_CASETYPE_ABORT)\n    {\n        UT_BSP_AppendLog(\"ABORT: invoking OS_BSP_Shutdown_Impl\");\n        OS_BSP_Shutdown_Impl();\n    }\n\n    UT_BSP_AppendLog(\"EXIT UT_BSP_DoText: MessageType=%u\", (unsigned)MessageType);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER UT_BSP_DoText: MessageType=8 OutputMessage=0x555ad3da6ee9 MsgEnabled=15\n  OutputMessage[0..63] = 'UNIT TEST'\nOUTPUT CALL Begin-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b6a0 len=7 preview='[BEGIN]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x555ad3da6ee9 len=9 preview='UNIT TEST'\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=8\nENTER UT_BSP_DoText: MessageType=8 OutputMessage=0x7ffe89f0b620 MsgEnabled=15\n  OutputMessage[0..63] = '01 SETUP'\nOUTPUT CALL Begin-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b5e0 len=7 preview='[BEGIN]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b620 len=8 preview='01 SETUP'\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=8\nENTER UT_BSP_DoText: MessageType=9 OutputMessage=0x555ad3da6878 MsgEnabled=7\n  OutputMessage[0..63] = 'No test cases\n'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b610 len=7 preview='[  END]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x555ad3da6878 len=14 preview='No test cases\n'\nEXIT UT_BSP_DoText: MessageType=9\nENTER UT_BSP_DoText: MessageType=8 OutputMessage=0x7ffe89f0b5f0 MsgEnabled=15\n  OutputMessage[0..63] = '01 OS_VxWorks_BinSemAPI_Impl_Init'\nOUTPUT CALL Begin-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b5b0 len=7 preview='[BEGIN]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b5f0 len=33 preview='01 OS_VxWorks_BinSemAPI_Impl_Init'\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=8\nENTER UT_BSP_DoText: MessageType=13 OutputMessage=0x7ffe89f0b190 MsgEnabled=0\n  OutputMessage[0..63] = 'utstubs.c:1096:OCS_memset called (DEFAULT,0)'\nEXIT UT_BSP_DoText: MessageType=13\nENTER UT_BSP_DoText: MessageType=11 OutputMessage=0x7ffe89f0b2f0 MsgEnabled=1\n  OutputMessage[0..63] = '01.001 coveragetest-binsem.c:42 - UT_Call_OS_VxWorks_BinSemAPI_I'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b280 len=7 preview='[ PASS]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b2f0 len=96 preview='01.001 coveragetest-binsem.c:42 - UT_Call_OS_VxWorks_BinSemAPI_Impl_Init() (0) == OS_SUCCESS (0)'\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=11\nENTER UT_BSP_DoText: MessageType=10 OutputMessage=0x7ffe89f0b560 MsgEnabled=3\n  OutputMessage[0..63] = '                       ABORT::0     WARN::0     FLOW::0     DEBU'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b520 len=7 preview='[ INFO]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b560 len=82 preview='                       ABORT::0     WARN::0     FLOW::0     DEBUG::0     N/A::0   '\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=10\nENTER UT_BSP_DoText: MessageType=9 OutputMessage=0x7ffe89f0b560 MsgEnabled=7\n  OutputMessage[0..63] = '01 OS_VxWorks_BinSemAPI_Impl_Init TOTAL::1     PASS::1     FAIL:'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b520 len=7 preview='[  END]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b560 len=102 preview='01 OS_VxWorks_BinSemAPI_Impl_Init TOTAL::1     PASS::1     FAIL::0     MIR::0     TSF::0     TTF::0   '\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nEXIT UT_BSP_DoText: MessageType=9\nENTER UT_BSP_DoText: MessageType=8 OutputMessage=0x7ffe89f0b5f0 MsgEnabled=15\n  OutputMessage[0..63] = '02 OS_BinSemCreate_Impl'\nOUTPUT CALL Begin-Newline: buf=0x555ad3da6ff6 len=1 preview='\n'\nOUTPUT CALL Buffer: buf=0x7ffe89f0b5b0 len=7 preview='[BEGIN]'\nOUTPUT CALL Space: buf=0x555ad3da702e len=1 preview=' '\nOUTPUT CALL OutputMessage: buf=0x7ffe89f0b5f0 len=23 preview='02 OS_BinSemCreate_Impl'\nOUTPUT CALL Trailing-Newline: buf=0x555ad3da6ff6 len=1 pre\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. UT_BSP_DoText declares OutputMessage as const char * (which conforms to the intent of Rule 8.13), but agent A\u2019s scenario demonstrates that this const-qualified pointer is passed to OS_BSP_ConsoleOutput_Impl. If that implementation is declared to take a non-const pointer type (e.g. char *), the const qualifier is effectively discarded at the call site. MISRA C 2023 Rule 8.13 requires pointer types to be const-qualified whenever possible, so the callee\u2019s parameter should be declared as const (for example const char * or const void *) if it does not modify the pointed-to data. The provided logs show the call site labeled \u201cOutputMessage\u201d where the const char * value is passed to the implementation, supporting the claim that the callee\u2019s prototype needs the const qualifier. The recommended remedy \u2014 change OS_BSP_ConsoleOutput_Impl to accept a pointer to a const-qualified type \u2014 is appropriate."
}