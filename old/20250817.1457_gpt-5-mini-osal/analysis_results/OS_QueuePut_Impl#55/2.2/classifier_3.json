{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_QueuePut_Impl:\n```c\nint32 OS_QueuePut_Impl(const OS_object_token_t *token, const void *data, size_t size, uint32 flags)\n{\n    int32                            return_code;\n    int                              result;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     * NOTE - using a zero timeout here for the same reason that QueueGet does ---\n     * checking the attributes and doing the actual send is non-atomic, and if\n     * two threads call QueuePut() at the same time on a nearly-full queue,\n     * one could block.\n     */\n    memset(&ts, 0, sizeof(ts));\n\n    /* send message */\n    do\n    {\n        result = mq_timedsend(impl->id, data, size, 1, &ts);\n    } while (result == -1 && errno == EINTR);\n\n    if (result == 0)\n    {\n        return_code = OS_SUCCESS;\n    }\n    else if (errno == ETIMEDOUT)\n    {\n        return_code = OS_QUEUE_FULL;\n    }\n    else\n    {\n        /* Something else went wrong */\n        return_code = OS_ERROR;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_QueuePut_Impl:\nstatic inline osal_index_t OS_ObjectIndexFromToken(const OS_object_token_t *token)\n{\n    return token->obj_idx;\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_queue_internal_record_t OS_impl_queue_table[OS_MAX_QUEUES]\n...\ntypedef struct\n{\n    mqd_t id;\n} OS_impl_queue_internal_record_t\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_SUCCESS (0)\n...\n#define OS_QUEUE_FULL (-9)\n...\n#define OS_ERROR (-1)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ndo\n    {\n        result = mq_timedsend(impl->id, data, size, 1, &ts);\n    } while (result == -1 && errno == EINTR);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The do/while retry loop actively handles the case where mq_timedsend is interrupted (result == -1 && errno == EINTR) by retrying the call. Removing the loop would change program behavior when mq_timedsend is interrupted by a signal, so the code is not dead."
}