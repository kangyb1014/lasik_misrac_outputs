{
  "user_message": "An agent A claimed that the following OS_QueuePut_Impl code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueuePut_Impl.\n```c\nint32 OS_QueuePut_Impl(const OS_object_token_t *token, const void *data, size_t size, uint32 flags)\n{\n    int32                            return_code;\n    int                              result;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     * NOTE - using a zero timeout here for the same reason that QueueGet does ---\n     * checking the attributes and doing the actual send is non-atomic, and if\n     * two threads call QueuePut() at the same time on a nearly-full queue,\n     * one could block.\n     */\n    memset(&ts, 0, sizeof(ts));\n\n    /* send message */\n    do\n    {\n        result = mq_timedsend(impl->id, data, size, 1, &ts);\n    } while (result == -1 && errno == EINTR);\n\n    if (result == 0)\n    {\n        return_code = OS_SUCCESS;\n    }\n    else if (errno == ETIMEDOUT)\n    {\n        return_code = OS_QUEUE_FULL;\n    }\n    else\n    {\n        /* Something else went wrong */\n        return_code = OS_ERROR;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The variable 'impl' is declared as a non-const pointer (OS_impl_queue_internal_record_t *impl) but within OS_QueuePut_Impl it is only read (only impl->id is used). The macro OS_OBJECT_TABLE_GET yields a pointer to the table element (non-const), but according to MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type whenever possible. Here 'impl' could and should be declared as 'const OS_impl_queue_internal_record_t *impl' (or the macro/table be exposed as an array of const records for read-only access), so the current non-const declaration violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueuePut_Impl_log_probe(const OS_impl_queue_internal_record_t *impl,\n                                       const OS_object_token_t *token,\n                                       const void *data,\n                                       size_t size,\n                                       unsigned int flags,\n                                       int result,\n                                       int errcode,\n                                       int retried,\n                                       int32 return_code,\n                                       const char *branch)\n{\n    FILE *f = fopen(\"/tmp/logs/443.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Best-effort logging only; do not alter behavior if logging fails. */\n        return;\n    }\n\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] OS_QueuePut_Impl probe:\\n\", (long)t);\n    fprintf(f, \"  token=%p\\n\", (const void *)token);\n    fprintf(f, \"  impl_ptr=%p\\n\", (const void *)impl);\n    /* impl->id is read-only in this function; print it for evidence. */\n    fprintf(f, \"  impl->id=%lld\\n\", (long long)impl->id);\n    fprintf(f, \"  data=%p size=%zu flags=%u\\n\", data, size, flags);\n    fprintf(f, \"  mq_timedsend result=%d errno=%d (%s) retried=%d\\n\",\n            result, errcode, errcode ? strerror(errcode) : \"0\", retried);\n    fprintf(f, \"  selected_return_code=%d branch=%s\\n\", return_code, branch);\n    fprintf(f, \"---\\n\");\n\n    fclose(f);\n}\n\nint32 OS_QueuePut_Impl(const OS_object_token_t *token, const void *data, size_t size, uint32 flags)\n{\n    int32                            return_code;\n    int                              result;\n    struct timespec                  ts;\n    OS_impl_queue_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_queue_table, *token);\n\n    /*\n     * NOTE - using a zero timeout here for the same reason that QueueGet does ---\n     * checking the attributes and doing the actual send is non-atomic, and if\n     * two threads call QueuePut() at the same time on a nearly-full queue,\n     * one could block.\n     */\n    memset(&ts, 0, sizeof(ts));\n\n    /* send message */\n    {\n        int retried = 0;\n\n        do\n        {\n            result = mq_timedsend(impl->id, data, size, 1, &ts);\n            if (result == -1 && errno == EINTR)\n            {\n                /* Count transient interruptions for logging/evidence. */\n                ++retried;\n            }\n        } while (result == -1 && errno == EINTR);\n\n        /* Capture errno immediately so logging does not overwrite it. */\n        int saved_errno = errno;\n\n        if (result == 0)\n        {\n            return_code = OS_SUCCESS;\n            /* Log successful send */\n            OS_QueuePut_Impl_log_probe((const OS_impl_queue_internal_record_t *)impl, token, data, size, (unsigned int)flags, result, saved_errno, retried, return_code, \"OS_SUCCESS\");\n        }\n        else if (saved_errno == ETIMEDOUT)\n        {\n            return_code = OS_QUEUE_FULL;\n            /* Log timeout case */\n            OS_QueuePut_Impl_log_probe((const OS_impl_queue_internal_record_t *)impl, token, data, size, (unsigned int)flags, result, saved_errno, retried, return_code, \"OS_QUEUE_FULL\");\n        }\n        else\n        {\n            /* Something else went wrong */\n            return_code = OS_ERROR;\n            /* Log error case */\n            OS_QueuePut_Impl_log_probe((const OS_impl_queue_internal_record_t *)impl, token, data, size, (unsigned int)flags, result, saved_errno, retried, return_code, \"OS_ERROR\");\n        }\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_QueuePut_Impl. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_QueuePut_Impl the local variable impl is only used for read access (impl->id) and is not modified, so it can and should be declared as pointing to a const-qualified type (e.g. const OS_impl_queue_internal_record_t *impl). That is precisely what MISRA C 2023 Rule 8.13 requires: a pointer should point to a const-qualified type whenever possible. Assigning the (non-const) result of OS_OBJECT_TABLE_GET to a pointer-to-const is a valid implicit conversion in C, so changing the local declaration to const does not generally require changing the macro. The only caveat is if the broader API or other code relies on modifying the table element via this pointer (which is not the case in this function); in such situations const cannot be used. Given the code shown, however, the current non-const declaration violates Rule 8.13 and should be changed to a const-qualified pointer (or the object-table accessors be const-correct)."
}