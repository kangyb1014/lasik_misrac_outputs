{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The macro calls strncpy(ref->namefield, nameval, sizeof(ref->namefield)-1) where the length argument is derived from the destination size but there is no guarantee in the macro that the source (nameval) is a NUL-terminated string with at least that many accessible bytes. If nameval points to a shorter object (or is not NUL-terminated within sizeof(ref->namefield)-1 bytes), strncpy may read up to the specified n bytes from the source and thus access memory beyond the bounds of the object referenced by nameval. (Note: the destination is protected by the prior memset and the size argument, but the source-read issue still violates MISRA C 2023 Rule 21.17.)\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_DoTimerAdd code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2175.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_DoTimerAdd as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_DoTimerAdd:\n```c\nstatic int32 OS_DoTimerAdd(osal_id_t *timer_id, const char *timer_name, osal_id_t timebase_ref_id,\n                           OS_ArgCallback_t callback_ptr, void *callback_arg, uint32 flags)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              listcb_token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /*\n     * Check parameters\n     *\n     * Note \"callback_arg\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timer_name);\n    OS_CHECK_POINTER(callback_ptr);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Check that the timebase reference is valid\n     * If successful, then after this statement, we MUST decrement the refcount\n     * if we leave this routine with an error.\n     */\n    return_code =\n        OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_TIMEBASE, timebase_ref_id, &timebase_token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_TIMECB, timer_name, &timecb_token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timebase_token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(timecb_token, timecb, timer_name, timer_name);\n\n        /*\n         * transfer ownership so the refcount obtained earlier is now\n         * associated with the timecb object, and will be retained until\n         * the object is deleted.\n         */\n        OS_ObjectIdTransferToken(&timebase_token, &timecb->timebase_token);\n\n        timecb->callback_ptr = callback_ptr;\n        timecb->callback_arg = callback_arg;\n        timecb->flags        = flags;\n        timecb->prev_cb      = OS_ObjectIdFromToken(&timecb_token);\n        timecb->next_cb      = OS_ObjectIdFromToken(&timecb_token);\n\n        /*\n         * Now we need to add it to the time base callback ring, so take the\n         * timebase-specific lock to prevent a tick from being processed at this moment.\n         */\n        OS_TimeBaseLock_Impl(&timebase_token);\n\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timebase->first_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n\n            timecb->next_cb = OS_ObjectIdFromToken(&listcb_token);\n            timecb->prev_cb = list_timecb->prev_cb;\n\n            if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n                OS_SUCCESS)\n            {\n                list_timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n                list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n                list_timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n            }\n        }\n\n        timebase->first_cb = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_TimeBaseUnlock_Impl(&timebase_token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &timecb_token, timer_id);\n    }\n    else\n    {\n        OS_ObjectIdRelease(&timebase_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_DoTimerAdd code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n/* Probe logging helper for violation investigation. Appends to /tmp/logs/2175.txt */\nstatic void OS_Log2175(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2175.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    struct tm *tm = localtime_r(&t, &tm_buf);\n    if (tm)\n    {\n        fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n                tm->tm_hour, tm->tm_min, tm->tm_sec);\n    }\n    else\n    {\n        fprintf(f, \"[time_unknown] \");\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int32 OS_DoTimerAdd(osal_id_t *timer_id, const char *timer_name, osal_id_t timebase_ref_id,\n                           OS_ArgCallback_t callback_ptr, void *callback_arg, uint32 flags)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              listcb_token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Log entry and parameter values (do not dereference timer_name to avoid introducing reads) */\n    OS_Log2175(\"ENTER: OS_DoTimerAdd timer_id=%p timer_name=%p timebase_ref_id=%ld callback_ptr=%p callback_arg=%p flags=0x%08lx\",\n               (void *)timer_id, (void *)timer_name, (long)timebase_ref_id, (void *)callback_ptr, callback_arg,\n               (unsigned long)flags);\n\n    /*\n     * Check parameters\n     *\n     * Note \"callback_arg\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timer_name);\n    OS_CHECK_POINTER(callback_ptr);\n\n    OS_Log2175(\"After parameter checks: timer_id=%p timer_name=%p callback_ptr=%p\", (void *)timer_id,\n               (void *)timer_name, (void *)callback_ptr);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    OS_Log2175(\"Context check: objtype=%d\", (int)objtype);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        OS_Log2175(\"Context error: called from a timebase callback (objtype=%d). Returning OS_ERR_INCORRECT_OBJ_STATE\",\n                   (int)objtype);\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Check that the timebase reference is valid\n     * If successful, then after this statement, we MUST decrement the refcount\n     * if we leave this routine with an error.\n     */\n    return_code =\n        OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_TIMEBASE, timebase_ref_id, &timebase_token);\n    OS_Log2175(\"OS_ObjectIdGetById(timebase) returned %d, timebase_token local addr=%p\", (int)return_code,\n               (void *)&timebase_token);\n    if (return_code != OS_SUCCESS)\n    {\n        OS_Log2175(\"Timebase lookup failed: return_code=%d. Exiting.\", (int)return_code);\n        return return_code;\n    }\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_TIMECB, timer_name, &timecb_token);\n    OS_Log2175(\"OS_ObjectIdAllocateNew(OS_TIMECB) returned %d, timecb_token local addr=%p\", (int)return_code,\n               (void *)&timecb_token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timebase_token);\n\n        OS_Log2175(\"Allocated timecb=%p timebase=%p\", (void *)timecb, (void *)timebase);\n\n        /* Reset the table entry and save the name */\n        OS_Log2175(\"Calling OS_OBJECT_INIT for timecb=%p with timer_name=%p (note: not dereferencing timer_name)\",\n                   (void *)timecb, (void *)timer_name);\n        OS_OBJECT_INIT(timecb_token, timecb, timer_name, timer_name);\n\n        /*\n         * transfer ownership so the refcount obtained earlier is now\n         * associated with the timecb object, and will be retained until\n         * the object is deleted.\n         */\n        OS_ObjectIdTransferToken(&timebase_token, &timecb->timebase_token);\n        OS_Log2175(\"Transferred timebase_token to timecb. timecb->timebase_token local addr=%p\",\n                   (void *)&timecb->timebase_token);\n\n        timecb->callback_ptr = callback_ptr;\n        timecb->callback_arg = callback_arg;\n        timecb->flags        = flags;\n        timecb->prev_cb      = OS_ObjectIdFromToken(&timecb_token);\n        timecb->next_cb      = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_Log2175(\"timecb fields set: callback_ptr=%p callback_arg=%p flags=0x%08lx prev_cb=%ld next_cb=%ld\",\n                   (void *)timecb->callback_ptr, timecb->callback_arg, (unsigned long)timecb->flags,\n                   (long)timecb->prev_cb, (long)timecb->next_cb);\n\n        /*\n         * Now we need to add it to the time base callback ring, so take the\n         * timebase-specific lock to prevent a tick from being processed at this moment.\n         */\n        OS_Log2175(\"Locking timebase for update: timebase=%p\", (void *)timebase);\n        OS_TimeBaseLock_Impl(&timebase_token);\n        OS_Log2175(\"Locked timebase: timebase=%p\", (void *)timebase);\n\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timebase->first_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n\n            OS_Log2175(\"Existing first_cb found: list_timecb=%p listcb_token local addr=%p\",\n                       (void *)list_timecb, (void *)&listcb_token);\n\n            timecb->next_cb = OS_ObjectIdFromToken(&listcb_token);\n            timecb->prev_cb = list_timecb->prev_cb;\n\n            OS_Log2175(\"Inserted relative pointers: timecb->next_cb=%ld timecb->prev_cb=%ld\",\n                       (long)timecb->next_cb, (long)timecb->prev_cb);\n\n            if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n                OS_SUCCESS)\n            {\n                list_timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n                list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n                list_timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n\n                OS_Log2175(\"Updated neighbor callbacks: neighbor=%p next_cb=%ld prev_cb=%ld\",\n                           (void *)list_timecb, (long)list_timecb->next_cb, (long)list_timecb->prev_cb);\n            }\n        }\n\n        timebase->first_cb = OS_ObjectIdFromToken(&timecb_token);\n        OS_Log2175(\"timebase->first_cb set to %ld\", (long)timebase->first_cb);\n\n        OS_TimeBaseUnlock_Impl(&timebase_token);\n        OS_Log2175(\"Unlocked timebase: timebase=%p\", (void *)timebase);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &timecb_token, timer_id);\n        OS_Log2175(\"OS_ObjectIdFinalizeNew returned %d. timer_id now=%p (value at pointer may be system-specific)\",\n                   (int)return_code, (void *)timer_id);\n    }\n    else\n    {\n        OS_Log2175(\"Allocation failed, releasing timebase_token and exiting. return_code=%d\", (int)return_code);\n        OS_ObjectIdRelease(&timebase_token);\n    }\n\n    OS_Log2175(\"EXIT: OS_DoTimerAdd returning %d\", (int)return_code);\n    return return_code;\n}\n"
}