{
  "user_message": "An agent A claimed that the following OS_DoTimerAdd code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_DoTimerAdd.\n```c\nstatic int32 OS_DoTimerAdd(osal_id_t *timer_id, const char *timer_name, osal_id_t timebase_ref_id,\n                           OS_ArgCallback_t callback_ptr, void *callback_arg, uint32 flags)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              listcb_token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /*\n     * Check parameters\n     *\n     * Note \"callback_arg\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timer_name);\n    OS_CHECK_POINTER(callback_ptr);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /*\n     * Check that the timebase reference is valid\n     * If successful, then after this statement, we MUST decrement the refcount\n     * if we leave this routine with an error.\n     */\n    return_code =\n        OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, OS_OBJECT_TYPE_OS_TIMEBASE, timebase_ref_id, &timebase_token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_TIMECB, timer_name, &timecb_token);\n    if (return_code == OS_SUCCESS)\n    {\n        timecb   = OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = OS_OBJECT_TABLE_GET(OS_timebase_table, timebase_token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(timecb_token, timecb, timer_name, timer_name);\n\n        /*\n         * transfer ownership so the refcount obtained earlier is now\n         * associated with the timecb object, and will be retained until\n         * the object is deleted.\n         */\n        OS_ObjectIdTransferToken(&timebase_token, &timecb->timebase_token);\n\n        timecb->callback_ptr = callback_ptr;\n        timecb->callback_arg = callback_arg;\n        timecb->flags        = flags;\n        timecb->prev_cb      = OS_ObjectIdFromToken(&timecb_token);\n        timecb->next_cb      = OS_ObjectIdFromToken(&timecb_token);\n\n        /*\n         * Now we need to add it to the time base callback ring, so take the\n         * timebase-specific lock to prevent a tick from being processed at this moment.\n         */\n        OS_TimeBaseLock_Impl(&timebase_token);\n\n        if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timebase->first_cb, &listcb_token) ==\n            OS_SUCCESS)\n        {\n            list_timecb = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n\n            timecb->next_cb = OS_ObjectIdFromToken(&listcb_token);\n            timecb->prev_cb = list_timecb->prev_cb;\n\n            if (OS_ObjectIdGetById(OS_LOCK_MODE_NONE, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n                OS_SUCCESS)\n            {\n                list_timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n                list_timecb          = OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n                list_timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n            }\n        }\n\n        timebase->first_cb = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_TimeBaseUnlock_Impl(&timebase_token);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &timecb_token, timer_id);\n    }\n    else\n    {\n        OS_ObjectIdRelease(&timebase_token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. The macro calls strncpy(ref->namefield, nameval, sizeof(ref->namefield)-1) where the length argument is derived from the destination size but there is no guarantee in the macro that the source (nameval) is a NUL-terminated string with at least that many accessible bytes. If nameval points to a shorter object (or is not NUL-terminated within sizeof(ref->namefield)-1 bytes), strncpy may read up to the specified n bytes from the source and thus access memory beyond the bounds of the object referenced by nameval. (Note: the destination is protected by the prior memset and the size argument, but the source-read issue still violates MISRA C 2023 Rule 21.17.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uint32_t uint32;\ntypedef int32 osal_id_t;\ntypedef void (*OS_ArgCallback_t)(void *);\ntypedef enum\n{\n    OS_OBJECT_TYPE_OS_TIMEBASE = 1,\n    OS_OBJECT_TYPE_OS_TIMECB   = 2\n} osal_objtype_t;\ntypedef struct\n{\n    int dummy;\n} OS_object_token_t;\nstruct OS_timecb_internal_record\n{\n    OS_object_token_t timebase_token;\n    OS_ArgCallback_t  callback_ptr;\n    void *            callback_arg;\n    uint32            flags;\n    osal_id_t         prev_cb;\n    osal_id_t         next_cb;\n};\ntypedef struct OS_timecb_internal_record\n{\n    OS_object_token_t timebase_token;\n    OS_ArgCallback_t  callback_ptr;\n    void *            callback_arg;\n    uint32            flags;\n    osal_id_t         prev_cb;\n    osal_id_t         next_cb;\n} OS_timecb_internal_record_t;\nstruct OS_timebase_internal_record\n{\n    osal_id_t first_cb;\n};\ntypedef struct OS_timebase_internal_record\n{\n    osal_id_t first_cb;\n} OS_timebase_internal_record_t;\nextern void OS_CHECK_POINTER(void *ptr);\nextern void OS_CHECK_APINAME(const char *name);\nextern osal_objtype_t OS_ObjectIdToType_Impl(osal_id_t id);\nextern osal_id_t OS_TaskGetId_Impl(void);\nextern int32 OS_ObjectIdGetById(int lockmode, osal_objtype_t type, osal_id_t id, OS_object_token_t *token);\nextern int32 OS_ObjectIdAllocateNew(osal_objtype_t type, const char *name, OS_object_token_t *token);\nextern void *OS_timebase_table;\nextern void *OS_OBJECT_TABLE_GET(void *table, OS_object_token_t token);\nextern void OS_OBJECT_INIT(OS_object_token_t token, void *obj, const char *n1, const char *n2);\nextern void OS_ObjectIdTransferToken(OS_object_token_t *src, OS_object_token_t *dst);\nextern osal_id_t OS_ObjectIdFromToken(OS_object_token_t *token);\nextern void OS_TimeBaseLock_Impl(OS_object_token_t *token);\nextern void OS_TimeBaseUnlock_Impl(OS_object_token_t *token);\nextern int32 OS_ObjectIdFinalizeNew(int32 previous_return, OS_object_token_t *token, osal_id_t *out_id);\nextern void OS_ObjectIdRelease(OS_object_token_t *token);\nstatic void OS_Log2175(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2175.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    struct tm *tm = localtime_r(&t, &tm_buf);\n    if (tm)\n    {\n        fprintf(f, \"[%04d-%02d-%02d %02d:%02d:%02d] \", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n                tm->tm_hour, tm->tm_min, tm->tm_sec);\n    }\n    else\n    {\n        fprintf(f, \"[time_unknown] \");\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    /* Cast to the standard va_list in case the build environment uses a different typedef for va_list in stubs. */\n    vfprintf(f, fmt, (va_list)args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int32 OS_DoTimerAdd(osal_id_t *timer_id, const char *timer_name, osal_id_t timebase_ref_id,\n                           OS_ArgCallback_t callback_ptr, void *callback_arg, uint32 flags)\n{\n    int32                          return_code;\n    osal_objtype_t                 objtype;\n    OS_object_token_t              timebase_token;\n    OS_object_token_t              timecb_token;\n    OS_object_token_t              listcb_token;\n    OS_timecb_internal_record_t *  timecb;\n    OS_timecb_internal_record_t *  list_timecb;\n    OS_timebase_internal_record_t *timebase;\n\n    /* Log entry and parameter values (do not dereference timer_name to avoid introducing reads) */\n    OS_Log2175(\"ENTER: OS_DoTimerAdd timer_id=%p timer_name=%p timebase_ref_id=%ld callback_ptr=%p callback_arg=%p flags=0x%08lx\",\n               (void *)timer_id, (void *)timer_name, (long)timebase_ref_id, (void *)callback_ptr, callback_arg,\n               (unsigned long)flags);\n\n    /*\n     * Check parameters\n     *\n     * Note \"callback_arg\" is not checked, because in certain configurations it can be validly null.\n     */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timer_name);\n    OS_CHECK_POINTER(callback_ptr);\n\n    OS_Log2175(\"After parameter checks: timer_id=%p timer_name=%p callback_ptr=%p\", (void *)timer_id,\n               (void *)timer_name, (void *)callback_ptr);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    OS_Log2175(\"Context check: objtype=%d\", (int)objtype);\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        OS_Log2175(\"Context error: called from a timebase callback (objtype=%d). Returning OS_ERR_INCORRECT_OBJ_STATE\",\n                   (int)objtype);\n        return -1; /* Placeholder error code; real code uses OS_ERR_INCORRECT_OBJ_STATE */\n    }\n\n    /*\n     * Check that the timebase reference is valid\n     * If successful, then after this statement, we MUST decrement the refcount\n     * if we leave this routine with an error.\n     */\n    return_code =\n        OS_ObjectIdGetById(0 /* OS_LOCK_MODE_REFCOUNT */, OS_OBJECT_TYPE_OS_TIMEBASE, timebase_ref_id, &timebase_token);\n    OS_Log2175(\"OS_ObjectIdGetById(timebase) returned %d, timebase_token local addr=%p\", (int)return_code,\n               (void *)&timebase_token);\n    if (return_code != 0 /* OS_SUCCESS */)\n    {\n        OS_Log2175(\"Timebase lookup failed: return_code=%d. Exiting.\", (int)return_code);\n        return return_code;\n    }\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(OS_OBJECT_TYPE_OS_TIMECB, timer_name, &timecb_token);\n    OS_Log2175(\"OS_ObjectIdAllocateNew(OS_TIMECB) returned %d, timecb_token local addr=%p\", (int)return_code,\n               (void *)&timecb_token);\n    if (return_code == 0 /* OS_SUCCESS */)\n    {\n        timecb   = (OS_timecb_internal_record_t *)OS_OBJECT_TABLE_GET(OS_timecb_table, timecb_token);\n        timebase = (OS_timebase_internal_record_t *)OS_OBJECT_TABLE_GET(OS_timebase_table, timebase_token);\n\n        OS_Log2175(\"Allocated timecb=%p timebase=%p\", (void *)timecb, (void *)timebase);\n\n        /* Reset the table entry and save the name */\n        OS_Log2175(\"Calling OS_OBJECT_INIT for timecb=%p with timer_name=%p (note: not dereferencing timer_name)\",\n                   (void *)timecb, (void *)timer_name);\n        OS_OBJECT_INIT(timecb_token, timecb, timer_name, timer_name);\n\n        /*\n         * transfer ownership so the refcount obtained earlier is now\n         * associated with the timecb object, and will be retained until\n         * the object is deleted.\n         */\n        OS_ObjectIdTransferToken(&timebase_token, &timecb->timebase_token);\n        OS_Log2175(\"Transferred timebase_token to timecb. timecb->timebase_token local addr=%p\",\n                   (void *)&timecb->timebase_token);\n\n        timecb->callback_ptr = callback_ptr;\n        timecb->callback_arg = callback_arg;\n        timecb->flags        = flags;\n        timecb->prev_cb      = OS_ObjectIdFromToken(&timecb_token);\n        timecb->next_cb      = OS_ObjectIdFromToken(&timecb_token);\n\n        OS_Log2175(\"timecb fields set: callback_ptr=%p callback_arg=%p flags=0x%08lx prev_cb=%ld next_cb=%ld\",\n                   (void *)timecb->callback_ptr, timecb->callback_arg, (unsigned long)timecb->flags,\n                   (long)timecb->prev_cb, (long)timecb->next_cb);\n\n        /*\n         * Now we need to add it to the time base callback ring, so take the\n         * timebase-specific lock to prevent a tick from being processed at this moment.\n         */\n        OS_Log2175(\"Locking timebase for update: timebase=%p\", (void *)timebase);\n        OS_TimeBaseLock_Impl(&timebase_token);\n        OS_Log2175(\"Locked timebase: timebase=%p\", (void *)timebase);\n\n        if (OS_ObjectIdGetById(0 /* OS_LOCK_MODE_NONE */, OS_OBJECT_TYPE_OS_TIMECB, timebase->first_cb, &listcb_token) ==\n            0 /* OS_SUCCESS */)\n        {\n            list_timecb = (OS_timecb_internal_record_t *)OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n\n            OS_Log2175(\"Existing first_cb found: list_timecb=%p listcb_token local addr=%p\",\n                       (void *)list_timecb, (void *)&listcb_token);\n\n            timecb->next_cb = OS_ObjectIdFromToken(&listcb_token);\n            timecb->prev_cb = list_timecb->prev_cb;\n\n            OS_Log2175(\"Inserted relative pointers: timecb->next_cb=%ld timecb->prev_cb=%ld\",\n                       (long)timecb->next_cb, (long)timecb->prev_cb);\n\n            if (OS_ObjectIdGetById(0 /* OS_LOCK_MODE_NONE */, OS_OBJECT_TYPE_OS_TIMECB, timecb->prev_cb, &listcb_token) ==\n                0 /* OS_SUCCESS */)\n            {\n                list_timecb->prev_cb = OS_ObjectIdFromToken(&timecb_token);\n                list_timecb          = (OS_timecb_internal_record_t *)OS_OBJECT_TABLE_GET(OS_timecb_table, listcb_token);\n                list_timecb->next_cb = OS_ObjectIdFromToken(&timecb_token);\n\n                OS_Log2175(\"Updated neighbor callbacks: neighbor=%p next_cb=%ld prev_cb=%ld\",\n                           (void *)list_timecb, (long)list_timecb->next_cb, (long)list_timecb->prev_cb);\n            }\n        }\n\n        timebase->first_cb = OS_ObjectIdFromToken(&timecb_token);\n        OS_Log2175(\"timebase->first_cb set to %ld\", (long)timebase->first_cb);\n\n        OS_TimeBaseUnlock_Impl(&timebase_token);\n        OS_Log2175(\"Unlocked timebase: timebase=%p\", (void *)timebase);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &timecb_token, timer_id);\n        OS_Log2175(\"OS_ObjectIdFinalizeNew returned %d. timer_id now=%p (value at pointer may be system-specific)\",\n                   (int)return_code, (void *)timer_id);\n    }\n    else\n    {\n        OS_Log2175(\"Allocation failed, releasing timebase_token and exiting. return_code=%d\", (int)return_code);\n        OS_ObjectIdRelease(&timebase_token);\n    }\n\n    OS_Log2175(\"EXIT: OS_DoTimerAdd returning %d\", (int)return_code);\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The presented OS_DoTimerAdd implementation does not itself call any functions from <string.h>, so there is no direct evidence in the shown code of a Rule 21.17 violation. The only place that could perform a string copy is the OS_OBJECT_INIT macro (not shown). Agent A\u2019s scenario rests on two implicit assumptions: (a) OS_OBJECT_INIT uses strncpy(dest, src, sizeof(dest)-1), and (b) there is no prior guarantee that src (timer_name) is a NUL-terminated object at least that large. Neither assumption is proven by the posted code. In fact the routine calls OS_CHECK_APINAME(timer_name) before OS_OBJECT_INIT; that macro is likely intended to validate the API name parameter (e.g. non-NULL and length/NUL-termination constraints). Because the copy behavior is in an external macro and the code contains a name-check call immediately beforehand, the report is not supported by the evidence shown. To definitively determine a MISRA 21.17 violation you must inspect the implementations of OS_OBJECT_INIT and OS_CHECK_APINAME: if OS_OBJECT_INIT uses a copy that can read up to n bytes from the source without those bytes being guaranteed present, that would violate 21.17; if OS_CHECK_APINAME ensures the source is a properly NUL-terminated string with acceptable length (or the copy uses a safe bounded routine that does not read past the source), then there is no violation. The submitted test code also did not compile so it does not demonstrate the claimed behavior."
}