{
  "user_message": "An agent A claimed that the following OS_QueueGet code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueGet.\n```c\nint32 OS_QueueGet(osal_id_t queue_id, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_POINTER(size_copied);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        if (size < queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is potentially too small\n            */\n            *size_copied = 0;\n            return_code  = OS_QUEUE_INVALID_SIZE;\n        }\n        else\n        {\n            return_code = OS_QueueGet_Impl(&token, data, size, size_copied, timeout);\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'impl' is declared as a non-const pointer (OS_impl_queue_internal_record_t *impl) but is only used for read access (impl = OS_OBJECT_TABLE_GET(...); then only impl->id is read). According to MISRA C 2023 Rule 8.13, this should be declared as a pointer to a const-qualified type (const OS_impl_queue_internal_record_t *impl) because the function does not modify the pointed-to object. Thus the current declaration violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_QueueGet_Log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1851.txt\", \"a\");\n    if (f != NULL)\n    {\n        va_list ap;\n        va_start(ap, fmt);\n        vfprintf(f, fmt, ap);\n        fprintf(f, \"\\n\");\n        va_end(ap);\n        fclose(f);\n    }\n}\n\nint32 OS_QueueGet(osal_id_t queue_id, void *data, size_t size, size_t *size_copied, int32 timeout)\n{\n    OS_object_token_t           token;\n    int32                       return_code;\n    OS_queue_internal_record_t *queue;\n\n    /* Log entry and input state */\n    OS_QueueGet_Log(\"ENTER OS_QueueGet: queue_id=%lu size=%zu timeout=%ld\", (unsigned long)queue_id, size, (long)timeout);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(data);\n    OS_CHECK_POINTER(size_copied);\n    OS_CHECK_SIZE(size);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_NONE, LOCAL_OBJID_TYPE, queue_id, &token);\n    OS_QueueGet_Log(\"OS_ObjectIdGetById returned %ld\", (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        if (queue == NULL)\n        {\n            OS_QueueGet_Log(\"OS_OBJECT_TABLE_GET returned NULL for token\");\n        }\n        else\n        {\n            /* Log the retrieved object's key readable fields (read-only observation) */\n            OS_QueueGet_Log(\"Retrieved queue ptr=%p max_size=%zu\", (void *)queue, queue->max_size);\n        }\n\n        if (queue != NULL && size < queue->max_size)\n        {\n            /*\n            ** The buffer that the user is passing in is potentially too small\n            */\n            *size_copied = 0;\n            return_code  = OS_QUEUE_INVALID_SIZE;\n            OS_QueueGet_Log(\"Branch: INVALID_SIZE - provided size=%zu < max_size=%zu; size_copied set to 0; return_code=%ld\",\n                             size, queue->max_size, (long)return_code);\n        }\n        else if (queue != NULL)\n        {\n            OS_QueueGet_Log(\"Branch: calling OS_QueueGet_Impl with size=%zu\", size);\n            return_code = OS_QueueGet_Impl(&token, data, size, size_copied, timeout);\n            OS_QueueGet_Log(\"OS_QueueGet_Impl returned %ld size_copied=%zu\", (long)return_code, *size_copied);\n        }\n    }\n\n    OS_QueueGet_Log(\"EXIT OS_QueueGet: return_code=%ld\", (long)return_code);\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER OS_QueueGet: queue_id=3735928559 size=4 timeout=0\nOS_ObjectIdGetById returned -35\nEXIT OS_QueueGet: return_code=-35\nENTER OS_QueueGet: queue_id=0 size=4 timeout=0\nOS_ObjectIdGetById returned -35\nEXIT OS_QueueGet: return_code=-35\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the shown OS_QueueGet implementation the local pointer variable (queue) is only used for read-only access (e.g. queue->max_size) and the function never modifies the pointed-to object. Under MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so the local declaration should be changed to point to a const-qualified record (e.g. const OS_queue_internal_record_t *queue). Assigning the non-const result of OS_OBJECT_TABLE_GET to a const pointer is allowed and would enforce the read-only intent. The provided runtime log only shows OS_ObjectIdGetById returning an error (so the path that reads queue->max_size was not exercised), but that does not affect the static-language rule: the code as written fails to apply the const qualification and therefore violates Rule 8.13."
}