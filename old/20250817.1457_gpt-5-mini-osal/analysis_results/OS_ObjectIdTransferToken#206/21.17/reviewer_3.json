{
  "user_message": "An agent A claimed that the following OS_ObjectIdTransferToken code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdTransferToken.\n```c\nvoid OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* start with a simple copy */\n    *token_to = *token_from;\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code passes the caller-supplied pointer 'name' (only checked for NULL) to OS_ObjectIdFindNextMatch/OS_ObjectNameMatch via a void* cast. If OS_ObjectNameMatch uses standard <string.h> routines (e.g. strcmp/strncpy/strcpy/strncat) on that pointer or on an internal fixed-size name buffer without first ensuring the input is a NUL-terminated string and/or that destination buffers are large enough, those calls can access beyond the bounds of the objects (read past the source buffer or write past the destination). For example, if OS_ObjectNameMatch does strcmp(record->name, (char*)name) and the provided name is not NUL-terminated, strcmp will read out of bounds; or if it does strcpy(record->name, (char*)name) and record->name is smaller than strlen(name)+1, strcpy will write out of bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_ObjectIdTransferToken_log(const OS_object_token_t *from, const OS_object_token_t *to)\n{\n    FILE *f = fopen(\"/tmp/logs/1655.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    fprintf(f, \"\\n--- OS_ObjectIdTransferToken log entry (%ld) ---\\n\", (long)t);\n\n    /* Pointer values */\n    fprintf(f, \"token_from ptr: %p\\n\", (const void *)from);\n    fprintf(f, \"token_to   ptr: %p\\n\", (const void *)to);\n    fprintf(f, \"token_from == token_to ? %s\\n\", (from == to) ? \"yes\" : \"no\");\n\n    /* Safe reporting of lock_mode field (existing field used by original code) */\n    /* Cast to int for printing in case it's an enum or similar. */\n    fprintf(f, \"token_from->lock_mode: %d\\n\", (int)from->lock_mode);\n    fprintf(f, \"token_to->lock_mode:   %d\\n\", (int)to->lock_mode);\n\n    /* Hex dump of the token structures up to a reasonable maximum to show internal state\n     * We use sizeof *from which is a compile-time constant and identical to the copy performed\n     * by the function. Limit output to at most 256 bytes to avoid excessive logs. */\n    size_t struct_size = sizeof *from;\n    size_t max_dump = 256;\n    size_t dump_len = (struct_size < max_dump) ? struct_size : max_dump;\n\n    fprintf(f, \"sizeof(*token) = %zu, dumping first %zu bytes of token_from (hex):\\n\", struct_size, dump_len);\n\n    const unsigned char *bytes = (const unsigned char *)from;\n    for (size_t i = 0; i < dump_len; ++i)\n    {\n        if ((i % 16) == 0)\n        {\n            fprintf(f, \"%04zx: \", i);\n        }\n        fprintf(f, \"%02x \", bytes[i]);\n        if ((i % 16) == 15) fprintf(f, \"\\n\");\n    }\n    if (dump_len % 16) fprintf(f, \"\\n\");\n    if (struct_size > dump_len)\n    {\n        fprintf(f, \"(dump truncated; full size %zu bytes)\\n\", struct_size);\n    }\n\n    /* Note: we intentionally do NOT dereference any pointers embedded inside the token\n     * (e.g. name pointers) to avoid introducing additional out-of-bounds accesses.\n     * The raw hex of the token structure and the lock_mode values should help reproduce\n     * scenarios where a caller-supplied pointer (inside the token) might not be NUL-terminated\n     * or might be inconsistent with expectations of consumers like OS_ObjectNameMatch. */\n\n    fprintf(f, \"--- end log entry ---\\n\");\n    fclose(f);\n}\n\nvoid OS_ObjectIdTransferToken(OS_object_token_t *token_from, OS_object_token_t *token_to)\n{\n    /* start with a simple copy */\n    *token_to = *token_from;\n\n    /* Emit diagnostics after the copy but before we nullify the source token.\n     * This preserves the original logic while providing a reproducible trace of the\n     * token contents and pointers that may be relevant to Rule 21.17 investigations. */\n    OS_ObjectIdTransferToken_log(token_from, token_to);\n\n    /*\n     * nullify the old token, such that if release/cancel\n     * is invoked it will have no effect (the real lock is\n     * now on token_to).\n     */\n    token_from->lock_mode = OS_LOCK_MODE_NONE;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_ObjectIdTransferToken. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the shown OS_ObjectIdTransferToken implementation. MISRA C 2023 Rule 21.17 concerns the use of the <string.h> functions and accesses beyond object bounds caused by them. The provided OS_ObjectIdTransferToken simply performs a structure assignment (*token_to = *token_from) and then writes a single field (token_from->lock_mode = ...). There are no calls to any <string.h> routines (strcmp, strcpy, memcpy, etc.) in this function, so this function by itself cannot violate Rule 21.17.\n\nAgent A's scenario describes a potential problem in some other function (OS_ObjectNameMatch or callers that treat a pointer as a NUL-terminated string). If OS_ObjectNameMatch or related code uses string.h functions on an input that is not NUL-terminated or on a destination that is too small, then that other code could indeed violate Rule 21.17. But that would be a fault in those functions or in the API contract/validation, not in OS_ObjectIdTransferToken as shown. The shallow structure copy does duplicate any internal pointers, which may be an ownership/aliasing concern, but that is a separate semantic issue and not a direct violation of Rule 21.17.\n\nTherefore the report is incorrect for the presented function. To address the underlying concern, ensure that any functions that operate on string pointers validate NUL-termination and buffer sizes (or use bounded-safe APIs) so they do not invoke out-of-bounds accesses when using <string.h> functions."
}