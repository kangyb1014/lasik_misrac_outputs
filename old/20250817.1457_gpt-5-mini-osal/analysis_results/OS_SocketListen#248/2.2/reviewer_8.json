{
  "user_message": "An agent A claimed that the following OS_SocketListen code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketListen.\n```c\nint32 OS_SocketListen(osal_id_t sock_id)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* This call is only applicable to stream sockets */\n        if (stream->socket_domain == OS_SocketDomain_INVALID || stream->socket_type != OS_SocketType_STREAM)\n        {\n            /* Not a stream socket */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else if ((stream->stream_state & OS_STREAM_STATE_BOUND) == 0)\n        {\n            /* Socket must be bound to an address already */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_LISTENING | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither listening nor connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n        else\n        {\n            return_code = OS_SocketListen_Impl(&token);\n\n            if (return_code == OS_SUCCESS)\n            {\n                stream->stream_state |= OS_STREAM_STATE_LISTENING;\n            }\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The explicit assignments and memsets at the start of OS_SocketAccept (setting conn_record = NULL; sock_record = NULL; sock = NULL; conn = NULL; and memset(&sock_token,0,...); memset(&conn_token,0,...)) are executed but have no effect on program behaviour. On the successful path these variables are overwritten/initialized before any use; on the failure path the function returns without ever using them. Therefore removing those assignments/memsets would not change runtime behaviour, so they constitute dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/1986.txt\", \"a\");\n    if (f != NULL)\n    {\n        va_list ap;\n        va_start(ap, fmt);\n        vfprintf(f, fmt, ap);\n        va_end(ap);\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n}\n\nint32 OS_SocketListen(osal_id_t sock_id)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    probe_log(\"OS_SocketListen: entry sock_id=%ld\", (long)sock_id);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sock_id, &token);\n    probe_log(\"OS_SocketListen: OS_ObjectIdGetById returned %ld\", (long)return_code);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n        probe_log(\"OS_SocketListen: stream=%p token=%p\", (void *)stream, (void *)&token);\n\n        /* Log current socket attributes for later analysis */\n        probe_log(\"OS_SocketListen: socket_domain=%d socket_type=%d stream_state=0x%X\",\n                  (int)stream->socket_domain,\n                  (int)stream->socket_type,\n                  (unsigned int)stream->stream_state);\n\n        /* This call is only applicable to stream sockets */\n        if (stream->socket_domain == OS_SocketDomain_INVALID || stream->socket_type != OS_SocketType_STREAM)\n        {\n            /* Not a stream socket */\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n            probe_log(\"OS_SocketListen: branch NOT_STREAM -> return_code=%ld\", (long)return_code);\n        }\n        else if ((stream->stream_state & OS_STREAM_STATE_BOUND) == 0)\n        {\n            /* Socket must be bound to an address already */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n            probe_log(\"OS_SocketListen: branch NOT_BOUND -> return_code=%ld\", (long)return_code);\n        }\n        else if ((stream->stream_state & (OS_STREAM_STATE_LISTENING | OS_STREAM_STATE_CONNECTED)) != 0)\n        {\n            /* Socket must be neither listening nor connected */\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n            probe_log(\"OS_SocketListen: branch LISTENING_OR_CONNECTED -> return_code=%ld\", (long)return_code);\n        }\n        else\n        {\n            probe_log(\"OS_SocketListen: calling OS_SocketListen_Impl with token=%p\", (void *)&token);\n            return_code = OS_SocketListen_Impl(&token);\n            probe_log(\"OS_SocketListen: OS_SocketListen_Impl returned %ld\", (long)return_code);\n\n            if (return_code == OS_SUCCESS)\n            {\n                stream->stream_state |= OS_STREAM_STATE_LISTENING;\n                probe_log(\"OS_SocketListen: set STREAM_STATE_LISTENING; new stream_state=0x%X\", (unsigned int)stream->stream_state);\n            }\n        }\n\n        probe_log(\"OS_SocketListen: releasing token %p\", (void *)&token);\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        probe_log(\"OS_SocketListen: object get failed, returning %ld\", (long)return_code);\n    }\n\n    probe_log(\"OS_SocketListen: exit return_code=%ld\", (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketListen. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the code shown. The provided OS_SocketListen implementation does not contain the described initial assignments/memsets (those belong to OS_SocketAccept in the scenario), so the claimed dead code does not exist in the target function. Moreover, the operations that are present in OS_SocketListen are not dead: the call to OS_SocketListen_Impl and the stream->stream_state |= OS_STREAM_STATE_LISTENING change runtime behaviour and removing them would alter program behaviour. The token acquisition and release are also meaningful when OS_ObjectIdGetById succeeds. The test probe produced no logs because the function was not exercised by the test harness, which does not demonstrate dead code. Finally, even for the OS_SocketAccept case described, trivial initializations may be intentional defensive programming (and MISRA notes that initialization/avoiding use of uninitialized data is relevant); such initializations should be evaluated in context rather than declared dead outright. Therefore the reported MISRA Rule 2.2 violation is incorrect for the shown code."
}