{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}, 'OS_FdSet_ConvertIn_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_FdSet_ConvertOut_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_SelectMultiple': {'callees': ['OS_SelectMultiple_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "int32",
    "OS_FdSet",
    "fd_set",
    "FD_ZERO",
    "OS_SUCCESS",
    "OS_ERR_INVALID_ID",
    "OS_FdSet_ConvertIn_Impl (prototype/definition)",
    "OS_FdSet_ConvertOut_Impl (prototype/definition)",
    "OS_DoSelect (prototype/definition)"
  ],
  "explanation": "To determine whether OS_SelectMultiple_Impl uses any compiler language extensions you must inspect the definitions/declarations that could hide nonstandard constructs or extension syntax. Specifically:\n\n- int32: this typedef/alias must be checked to ensure it is a standard C type (e.g. typedef int32_t) and does not use compiler-specific keywords or attributes (e.g. __int128, __attribute__, asm, typeof).\n\n- OS_FdSet: the OS-specific file-descriptor container type passed into the function could be a struct/union using extensions (bit\u2011fields with implementation-specific widths, unnamed fields, flexible array members implemented with nonstandard extensions, compiler attributes). Its definition is required.\n\n- fd_set: the system fd_set type and its internals (usually defined in <sys/select.h>) must be inspected because its implementation could use nonstandard constructs or macros that are compiler extensions.\n\n- FD_ZERO: this macro (and any related FD_* macros) may be implemented using nonstandard macro extensions (statement-expressions, typeof, inline asm, GCC extensions). The macro expansion must be examined.\n\n- OS_SUCCESS and OS_ERR_INVALID_ID: these result constants/macros should be checked to ensure they are ordinary integer constants/macros and not defined via extension constructs or attributes.\n\n- OS_FdSet_ConvertIn_Impl (prototype/definition): the callee\u2019s declaration/definition must be inspected for use of extension features in parameter declarations, return type, inline asm, attributes, or nonstandard calling conventions.\n\n- OS_FdSet_ConvertOut_Impl (prototype/definition): same reasoning as above for the output conversion routine.\n\n- OS_DoSelect (prototype/definition): the select wrapper\u2019s declaration/definition must be checked for extensions (attributes, inline asm, compiler-specific pragmas) since it is called directly and its prototype could employ nonstandard constructs.\n\nInspecting these symbols (their typedefs, macros, and function declarations/definitions) is sufficient to detect any explicit compiler language extensions used either directly in OS_SelectMultiple_Impl or indirectly via the types/macros/functions it depends on."
}