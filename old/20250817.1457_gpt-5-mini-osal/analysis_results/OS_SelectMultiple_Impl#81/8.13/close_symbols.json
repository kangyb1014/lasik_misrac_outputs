{
  "user_message": "Target function code is:\n```c\nint32 OS_SelectMultiple_Impl(OS_FdSet *ReadSet, OS_FdSet *WriteSet, int32 msecs)\n{\n    fd_set wr_set;\n    fd_set rd_set;\n    int    maxfd;\n    int32  return_code;\n\n    FD_ZERO(&rd_set);\n    FD_ZERO(&wr_set);\n    maxfd = -1;\n    if (ReadSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &rd_set, ReadSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n    if (WriteSet != NULL)\n    {\n        return_code = OS_FdSet_ConvertIn_Impl(&maxfd, &wr_set, WriteSet);\n        if (return_code != OS_SUCCESS)\n        {\n            return return_code;\n        }\n    }\n\n    if (maxfd >= 0)\n    {\n        return_code = OS_DoSelect(maxfd, &rd_set, &wr_set, msecs);\n    }\n    else\n    {\n        /*\n         * This return code will be used if the set(s) were\n         * both empty/NULL or otherwise did not contain valid filehandles.\n         */\n        return_code = OS_ERR_INVALID_ID;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        if (ReadSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&rd_set, ReadSet);\n        }\n        if (WriteSet != NULL)\n        {\n            OS_FdSet_ConvertOut_Impl(&wr_set, WriteSet);\n        }\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}, 'OS_FdSet_ConvertIn_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_FdSet_ConvertOut_Impl': {'callees': [], 'callers': ['OS_SelectMultiple_Impl']}, 'OS_SelectMultiple': {'callees': ['OS_SelectMultiple_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_FdSet (type definition)",
    "OS_FdSet_ConvertIn_Impl (prototype/definition)",
    "OS_FdSet_ConvertOut_Impl (prototype/definition)",
    "OS_SelectMultiple (public wrapper/prototype)"
  ],
  "explanation": "- OS_FdSet (type definition): You must know the concrete type of OS_FdSet to determine whether applying const to OS_FdSet * makes sense (e.g., is it an array, struct with mutable fields, etc.) and to understand what \"pointing to const\" would semantically mean for this API.\n- OS_FdSet_ConvertIn_Impl (prototype/definition): This function is called with ReadSet/WriteSet as input. Its prototype/implementation reveals whether it mutates the OS_FdSet object or only reads it, and whether it already accepts a const OS_FdSet *. That determines if the target function could declare its parameters as const when only passing them to this callee.\n- OS_FdSet_ConvertOut_Impl (prototype/definition): This function is called to write results back into ReadSet/WriteSet. Its prototype/implementation will show whether it modifies the pointed OS_FdSet (necessitating non-const) and thus is decisive for whether the target function\u2019s parameters must be non-const.\n- OS_SelectMultiple (public wrapper/prototype): The public wrapper/signature may impose API-level constness requirements that the implementation must match. Inspecting the wrapper/prototype ensures the implementation\u2019s parameter const qualifications are compatible with the externally visible API."
}