{
  "user_message": "An agent A claimed that the following OS_QueueCreate code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_QueueCreate.\n```c\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        return_code = OS_QueueCreate_Impl(&token, flags);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call casts away const: 'name' is declared as 'const char *name' in OS_ObjectIdAllocateNew but is passed as (void *)name to OS_ObjectIdFindNextMatch. This removes the const-qualification from the pointer and allows the callee to treat the data as modifiable. According to MISRA C 2023 Rule 8.13 a pointer should be to a const-qualified type whenever possible. The correct fix is to change the callee/signature to accept a 'const void *' (or otherwise preserve const) instead of taking a plain 'void *'.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_queue_log_impl(const char *buf)\n{\n    FILE *f = fopen(\"/tmp/logs/1835.txt\", \"a\");\n    if (f)\n    {\n        (void)fputs(buf, f);\n        (void)fputc('\\n', f);\n        (void)fclose(f);\n    }\n}\nstatic void os_queue_logf(const char *fmt, ...)\n{\n    char localbuf[512];\n    va_list ap;\n    va_start(ap, fmt);\n    (void)vsnprintf(localbuf, sizeof(localbuf), fmt, ap);\n    va_end(ap);\n    os_queue_log_impl(localbuf);\n}\n\nint32 OS_QueueCreate(osal_id_t *queue_id, const char *queue_name, osal_blockcount_t queue_depth, size_t data_size,\n                     uint32 flags)\n{\n    int32                       return_code;\n    OS_object_token_t           token;\n    OS_queue_internal_record_t *queue;\n\n    /* Entry log: record parameters and pointer values (without casting away const). */\n    os_queue_logf(\"OS_QueueCreate ENTRY: queue_id=%p, queue_name=%p, queue_name_str=\\\"%s\\\", queue_depth=%u, data_size=%zu, flags=0x%08x\",\n                  (void *)queue_id, (const void *)queue_name, (queue_name != NULL) ? queue_name : \"(null)\",\n                  (unsigned)queue_depth, data_size, (unsigned)flags);\n\n    /* validate inputs */\n    OS_CHECK_POINTER(queue_id);\n    OS_CHECK_APINAME(queue_name);\n    OS_CHECK_SIZE(data_size);\n    ARGCHECK(queue_depth <= OS_QUEUE_MAX_DEPTH, OS_QUEUE_INVALID_SIZE);\n\n    /* Note - the common ObjectIdAllocate routine will lock the object type and leave it locked. */\n    os_queue_logf(\"OS_QueueCreate: calling OS_ObjectIdAllocateNew with name=%p (const char *)\\\"%s\\\"\",\n                  (const void *)queue_name, (queue_name != NULL) ? queue_name : \"(null)\");\n\n    return_code = OS_ObjectIdAllocateNew(LOCAL_OBJID_TYPE, queue_name, &token);\n\n    os_queue_logf(\"OS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=%d, token_addr=%p, token_size=%zu\",\n                  (int)return_code, (void *)&token, sizeof(token));\n\n    if (return_code == OS_SUCCESS)\n    {\n        queue = OS_OBJECT_TABLE_GET(OS_queue_table, token);\n\n        /* Log the obtained table entry pointer */\n        os_queue_logf(\"OS_QueueCreate: obtained queue table entry queue=%p\", (void *)queue);\n\n        /* Reset the table entry and save the name */\n        OS_OBJECT_INIT(token, queue, queue_name, queue_name);\n\n        /* After initialization, log the preserved name pointer (const) and configured sizes */\n        os_queue_logf(\"OS_QueueCreate: after OS_OBJECT_INIT token=%p, queue->max_depth=%u, queue->max_size=%zu, name_ptr=%p, name_str=\\\"%s\\\"\",\n                      (void *)&token,\n                      (unsigned)queue_depth, data_size,\n                      (const void *)queue_name, (queue_name != NULL) ? queue_name : \"(null)\");\n\n        queue->max_depth = queue_depth;\n        queue->max_size  = data_size;\n\n        /* Now call the OS-specific implementation.  This reads info from the queue table. */\n        os_queue_logf(\"OS_QueueCreate: calling OS_QueueCreate_Impl with token=%p, flags=0x%08x\", (void *)&token, (unsigned)flags);\n        return_code = OS_QueueCreate_Impl(&token, flags);\n        os_queue_logf(\"OS_QueueCreate: returned from OS_QueueCreate_Impl return_code=%d\", (int)return_code);\n\n        /* Check result, finalize record, and unlock global table. */\n        return_code = OS_ObjectIdFinalizeNew(return_code, &token, queue_id);\n        os_queue_logf(\"OS_QueueCreate: after OS_ObjectIdFinalizeNew return_code=%d, queue_id=%p\", (int)return_code, (void *)queue_id);\n    }\n    else\n    {\n        os_queue_logf(\"OS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=%d\", (int)return_code);\n    }\n\n    os_queue_logf(\"OS_QueueCreate EXIT: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d488, queue_name=0x557a278af992, queue_name_str=\"Queue A\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278af992 (const char *)\"Queue A\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-1, token_addr=0x7ffd0998d450, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-1\nOS_QueueCreate EXIT: return_code=-1\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d488, queue_name=0x557a278af992, queue_name_str=\"Queue A\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278af992 (const char *)\"Queue A\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d450, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=(nil), queue_name=0x557a278b031c, queue_name_str=\"Queue1\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=(nil), queue_name_str=\"(null)\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=0x557a278b031c, queue_name_str=\"Queue1\", queue_depth=10, data_size=0, flags=0x00000000\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=0x557a278b031c, queue_name_str=\"Queue1\", queue_depth=51, data_size=4, flags=0x00000000\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=0x7ffd0998d490, queue_name_str=\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=0x7ffd0998d470, queue_name_str=\"QUEUE0\", queue_depth=2, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x7ffd0998d470 (const char *)\"QUEUE0\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d430, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d464, queue_name=0x557a278b062f, queue_name_str=\"DUPLICATE\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278b062f (const char *)\"DUPLICATE\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d430, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d460, queue_name=0x557a278b0713, queue_name_str=\"Good\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278b0713 (const char *)\"Good\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d430, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d4b4, queue_name=0x557a278b07df, queue_name_str=\"DeleteTest\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278b07df (const char *)\"DeleteTest\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d480, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d4ac, queue_name=0x557a278b0bbd, queue_name_str=\"QueuePut\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: calling OS_ObjectIdAllocateNew with name=0x557a278b0bbd (const char *)\"QueuePut\"\nOS_QueueCreate: returned from OS_ObjectIdAllocateNew return_code=-35, token_addr=0x7ffd0998d470, token_size=20\nOS_QueueCreate: OS_ObjectIdAllocateNew failed with return_code=-35\nOS_QueueCreate EXIT: return_code=-35\nOS_QueueCreate ENTRY: queue_id=0x7ffd0998d4ac, queue_name=0x557a278b0bbd, queue_name_str=\"QueuePut\", queue_depth=10, data_size=4, flags=0x00000000\nOS_QueueCreate: call\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The OS_QueueCreate implementation shown correctly accepts queue_name as a const char * and forwards it without casting away const. There is no cast-away-of-const in the code you provided. If, as Agent A describes, OS_ObjectIdAllocateNew internally casts (void *)name to call an OS_ObjectIdFindNextMatch that takes a non-const void *, that would indeed be a violation of MISRA C 2023 Rule 8.13 \u2014 but that violation would be in OS_ObjectIdAllocateNew/OS_ObjectIdFindNextMatch, not in OS_QueueCreate itself. Therefore the report that the shown OS_QueueCreate code violates Rule 8.13 is incorrect. The correct fix (if the internal cast exists) is to change the callee(s) to accept const-qualified pointer types (e.g., const void *) so const-qualification is preserved."
}