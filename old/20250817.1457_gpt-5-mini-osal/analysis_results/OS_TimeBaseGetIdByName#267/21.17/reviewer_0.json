{
  "user_message": "An agent A claimed that the following OS_TimeBaseGetIdByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_TimeBaseGetIdByName.\n```c\nint32 OS_TimeBaseGetIdByName(osal_id_t *timer_id, const char *timebase_name)\n{\n    int32          return_code;\n    osal_objtype_t objtype;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timebase_name);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_TIMEBASE, timebase_name, timer_id);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes timebase_name into OS_ObjectIdFindByName which performs ARGCHECK/LENGTHCHECK and then name-based lookup. If ARGCHECK/LENGTHCHECK (or the subsequent name-match routine) use unbounded string.h functions such as strlen/strcmp/strcpy on the provided pointer, a non\u2013NUL-terminated or undersized buffer will be read/written out of bounds. Example: caller provides char buf[8] filled with 8 non\u2011NUL bytes and passes buf as timebase_name; if LENGTHCHECK is implemented as strlen(name) > OS_MAX_API_NAME (or the name-comparison uses strcmp), strlen/strcmp will read past buf\u2019s bounds, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_TimeBaseGetIdByName_LogProbe(const osal_id_t *timer_id, const char *timebase_name, osal_objtype_t objtype, int32 return_code, const char *stage)\n{\n    FILE *f = fopen(\"/tmp/logs/2143.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"Stage: %s\\n\", stage);\n    fprintf(f, \"  timer_id ptr: %p\\n\", (const void *)timer_id);\n    fprintf(f, \"  timebase_name ptr: %p\\n\", (const void *)timebase_name);\n\n    if (timebase_name == NULL)\n    {\n        fprintf(f, \"  timebase_name: NULL\\n\");\n    }\n    else\n    {\n        /* Safely examine only the first byte to avoid reading past the caller's buffer. */\n        unsigned char first = (unsigned char)timebase_name[0];\n        fprintf(f, \"  timebase_name[0] = 0x%02x (%s)\\n\", first, (first == 0) ? \"NUL\" : \"non-NUL\");\n    }\n\n    fprintf(f, \"  objtype (if known): %d\\n\", (int)objtype);\n    fprintf(f, \"  return_code (if known): %d\\n\", (int)return_code);\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\nint32 OS_TimeBaseGetIdByName(osal_id_t *timer_id, const char *timebase_name)\n{\n    int32          return_code;\n    osal_objtype_t objtype;\n\n    /* Entry probe */\n    OS_TimeBaseGetIdByName_LogProbe(timer_id, timebase_name, (osal_objtype_t)-1, -1, \"entry\");\n\n    /* Check parameters */\n    OS_CHECK_POINTER(timer_id);\n    OS_CHECK_APINAME(timebase_name);\n\n    /*\n     * Check our context.  Not allowed to use the timer API from a timer callback.\n     * Just interested in the object type returned.\n     */\n    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());\n    if (objtype == OS_OBJECT_TYPE_OS_TIMEBASE)\n    {\n        /* Log incorrect object state and return */\n        OS_TimeBaseGetIdByName_LogProbe(timer_id, timebase_name, objtype, OS_ERR_INCORRECT_OBJ_STATE, \"incorrect_obj_state\");\n        return OS_ERR_INCORRECT_OBJ_STATE;\n    }\n\n    /* Log before calling the name lookup routine */\n    OS_TimeBaseGetIdByName_LogProbe(timer_id, timebase_name, objtype, -1, \"before_find_by_name\");\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_TIMEBASE, timebase_name, timer_id);\n\n    /* Log after calling the name lookup routine, including the returned code. */\n    OS_TimeBaseGetIdByName_LogProbe(timer_id, timebase_name, objtype, return_code, \"after_find_by_name\");\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_TimeBaseGetIdByName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not demonstrated by the code shown. OS_TimeBaseGetIdByName itself does not call any <string.h> functions; it delegates validation to OS_CHECK_APINAME and lookup to OS_ObjectIdFindByName. MISRA C 2023 Rule 21.17 prohibits unsafe uses of string.h functions that can read/write past object bounds. If OS_CHECK_APINAME or OS_ObjectIdFindByName internally call strlen/strcmp/etc. on a non\u2013NUL-terminated buffer, that implementation would violate Rule 21.17 \u2014 but that would be a flaw in those routines, not in OS_TimeBaseGetIdByName itself. Thus Agent A\u2019s scenario only shows a possible downstream violation conditional on the implementations of the called helpers, not a proven violation in the posted function. To settle this conclusively, inspect the implementations of OS_CHECK_APINAME and OS_ObjectIdFindByName (and any name-matching code) to ensure they either (a) enforce documented preconditions that the caller supplies a NUL-terminated name of bounded length, or (b) use length-bounded/string-safe APIs (e.g. strnlen/strncmp or explicit length checks) before calling unbounded string functions."
}