{
  "user_message": "An agent A claimed that the following OS_SocketSendTo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketSendTo.\n```c\nint32 OS_SocketSendTo(osal_id_t sock_id, const void *buffer, size_t buflen, const OS_SockAddr_t *RemoteAddr)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buflen);\n    OS_CHECK_POINTER(RemoteAddr);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        if (stream->socket_type != OS_SocketType_DATAGRAM)\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else\n        {\n            return_code = OS_SocketSendTo_Impl(&token, buffer, buflen, RemoteAddr);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'stream' is only used to read fields (e.g. stream->socket_type) and is not modified in this function, so it should be declared to point to a const-qualified type (e.g. 'const OS_stream_internal_record_t *stream;'). Declaring it non-const when only read violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SocketSendTo_Log(const char *stage,\n                                unsigned long sock_id_val,\n                                const void *buffer,\n                                size_t buflen,\n                                const void *RemoteAddr,\n                                const void *stream_ptr,\n                                int socket_type_val,\n                                int32 return_code)\n{\n    FILE *fp = fopen(\"/tmp/logs/2011.txt\", \"a\");\n    if (fp == NULL)\n    {\n        /* If logging fails, do not alter program behavior. */\n        return;\n    }\n\n    fprintf(fp, \"[OS_SocketSendTo] stage=%s sock_id=%lu buffer=%p buflen=%zu RemoteAddr=%p stream=%p socket_type=%d return_code=%d\\n\",\n            stage, sock_id_val, buffer, buflen, RemoteAddr, stream_ptr, socket_type_val, return_code);\n\n    fclose(fp);\n}\n\nint32 OS_SocketSendTo(osal_id_t sock_id, const void *buffer, size_t buflen, const OS_SockAddr_t *RemoteAddr)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Log entry into function with initial parameters */\n    OS_SocketSendTo_Log(\"entry\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, NULL, -1, -1);\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buflen);\n    OS_CHECK_POINTER(RemoteAddr);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &token);\n    OS_SocketSendTo_Log(\"after_ObjectIdGetById\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, NULL, -1, return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Log stream pointer and the observed socket_type */\n        {\n            int socket_type_val = -1;\n            if (stream != NULL)\n            {\n                /* Read-only observation of stream->socket_type for logging */\n                socket_type_val = (int)stream->socket_type;\n            }\n            OS_SocketSendTo_Log(\"after_table_get\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, (const void *)stream, socket_type_val, return_code);\n        }\n\n        if (stream->socket_type != OS_SocketType_DATAGRAM)\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n\n            /* Log branch taken: incorrect object type */\n            OS_SocketSendTo_Log(\"incorrect_obj_type\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, (const void *)stream, (int)stream->socket_type, return_code);\n        }\n        else\n        {\n            /* Log branch taken: calling implementation */\n            OS_SocketSendTo_Log(\"calling_impl\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, (const void *)stream, (int)stream->socket_type, return_code);\n\n            return_code = OS_SocketSendTo_Impl(&token, buffer, buflen, RemoteAddr);\n\n            /* Log result from implementation call */\n            OS_SocketSendTo_Log(\"after_impl\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, (const void *)stream, (int)stream->socket_type, return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log token release */\n        OS_SocketSendTo_Log(\"after_release\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, (const void *)stream, (int)stream->socket_type, return_code);\n    }\n\n    /* Final return logging */\n    OS_SocketSendTo_Log(\"exit\", (unsigned long)sock_id, buffer, buflen, RemoteAddr, NULL, -1, return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketSendTo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the original function the local variable stream is only assigned and then its members are read (stream->socket_type); there are no writes through stream in this function. According to MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever possible, so stream should be declared as a pointer to const (e.g. const OS_stream_internal_record_t *stream). Assigning the result of OS_OBJECT_TABLE_GET (presumably a non-const pointer) to a pointer-to-const is allowed (adding const), so declaring stream const would be valid and would avoid accidental modification. If there is a specific reason the API requires a non-const pointer (or the macro/type system prevents the change), that should be documented or a justified deviation provided; otherwise the code violates Rule 8.13."
}