{
  "user_message": "An agent A claimed that the following OS_SocketSendTo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketSendTo.\n```c\nint32 OS_SocketSendTo(osal_id_t sock_id, const void *buffer, size_t buflen, const OS_SockAddr_t *RemoteAddr)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buflen);\n    OS_CHECK_POINTER(RemoteAddr);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        if (stream->socket_type != OS_SocketType_DATAGRAM)\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else\n        {\n            return_code = OS_SocketSendTo_Impl(&token, buffer, buflen, RemoteAddr);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'stream' is declared as a non-const OS_stream_internal_record_t * but in this function it is only read (stream->socket_type). Therefore it could and should be declared as a pointer to const (const OS_stream_internal_record_t *stream). As written the code does not use a const-qualified pointer when possible, so Rule 8.13 is violated. (If OS_OBJECT_TABLE_GET must return a mutable pointer because callers modify the object, the local variable here should still be const if this function does not modify the object.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_SendTo_LogProbe(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2011.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n\n    fclose(f);\n}\n\nint32 OS_SocketSendTo(osal_id_t sock_id, const void *buffer, size_t buflen, const OS_SockAddr_t *RemoteAddr)\n{\n    OS_stream_internal_record_t *stream;\n    OS_object_token_t            token;\n    int32                        return_code;\n\n    /* Check Parameters */\n    OS_CHECK_POINTER(buffer);\n    OS_CHECK_SIZE(buflen);\n    OS_CHECK_POINTER(RemoteAddr);\n\n    /* Log entry with key parameters (addresses and sizes) */\n    OS_SendTo_LogProbe(\"OS_SocketSendTo entry: sock_id=%llu, buffer=%p, buflen=%zu, RemoteAddr=%p\",\n                       (unsigned long long) sock_id, buffer, buflen, (const void *) RemoteAddr);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_REFCOUNT, LOCAL_OBJID_TYPE, sock_id, &token);\n\n    OS_SendTo_LogProbe(\"OS_ObjectIdGetById returned: %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, token);\n\n        /* Log the retrieved stream pointer and token address for reproduction */\n        OS_SendTo_LogProbe(\"OS_OBJECT_TABLE_GET -> stream=%p, token_addr=%p\", (void *)stream, (void *)&token);\n\n        /* Log the observed socket_type value read from the stream */\n        /* Cast to int for logging; the exact enum/integer type is platform-dependent */\n        OS_SendTo_LogProbe(\"stream->socket_type=%d\", (int)stream->socket_type);\n\n        if (stream->socket_type != OS_SocketType_DATAGRAM)\n        {\n            OS_SendTo_LogProbe(\"Decision: incorrect object type (expected DATAGRAM). Setting return_code=OS_ERR_INCORRECT_OBJ_TYPE\");\n            return_code = OS_ERR_INCORRECT_OBJ_TYPE;\n        }\n        else\n        {\n            OS_SendTo_LogProbe(\"Decision: socket_type is DATAGRAM. Calling OS_SocketSendTo_Impl\");\n            return_code = OS_SocketSendTo_Impl(&token, buffer, buflen, RemoteAddr);\n            OS_SendTo_LogProbe(\"OS_SocketSendTo_Impl returned: %d\", (int)return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n        OS_SendTo_LogProbe(\"OS_ObjectIdRelease called for token at %p\", (void *)&token);\n    }\n\n    OS_SendTo_LogProbe(\"OS_SocketSendTo exit: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketSendTo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_SocketSendTo the local variable stream is only used for a read access (stream->socket_type) and is never modified or passed to a callee that expects to alter the object. MISRA C 2023 Rule 8.13 advises that pointers should point to const-qualified types whenever possible; therefore the local declaration could and should be changed to const OS_stream_internal_record_t *stream. Assigning the non-const result of OS_OBJECT_TABLE_GET to a const-qualified pointer is allowed (adding const), so this change is safe in this function. A possible counterargument is that OS_OBJECT_TABLE_GET is intended to return a modifiable pointer for other callers \u2014 that does not prevent this function from declaring its local pointer as const since it does not perform modifications. The empty test log does not affect the static qualification issue. Thus the agent A\u2019s claim that the code violates Rule 8.13 is correct."
}