{
  "user_message": "An agent A claimed that the following OS_FS_GetPhysDriveName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FS_GetPhysDriveName.\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The member 'char *address' is a non-const pointer to character data. MISRA C 2023 Rule 8.13 requires pointers to be const-qualified when possible. In the shown code there is no evidence that the data pointed-to by address is modified through this pointer (e.g. device names or statically-initialized strings are typically read-only). If address is intended only for read access (for example filesys.address = \"dev0\" or pointing to immutable metadata), it should be declared as 'const char *address'. As written, this is a violation because the pointer is not const-qualified when it could/should be.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void osfs_log(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1379.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return; /* If logging fails, do not affect original logic */\n    }\n\n    /* Timestamp */\n    time_t t = time(NULL);\n    struct tm *tm = localtime(&t);\n    if (tm != NULL)\n    {\n        char ts[32];\n        if (strftime(ts, sizeof(ts), \"%Y-%m-%d %H:%M:%S\", tm) > 0)\n        {\n            fprintf(fp, \"%s - \", ts);\n        }\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Log entry and parameters */\n    osfs_log(\"ENTER OS_FS_GetPhysDriveName: PhysDriveName=%p, MountPoint=%p\", (void *)PhysDriveName, (const void *)MountPoint);\n    if (MountPoint != NULL)\n    {\n        /* Log a limited view of the mount point string to avoid huge logs */\n        char mpbuf[128] = {0};\n        strncpy(mpbuf, MountPoint, sizeof(mpbuf) - 1);\n        osfs_log(\"MountPoint contents: '%s'\", mpbuf);\n    }\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    osfs_log(\"OS_ObjectIdGetBySearch returned %d\", (int)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n        osfs_log(\"Found filesys record at %p\", (void *)filesys);\n\n        if (filesys != NULL)\n        {\n            osfs_log(\"filesys->flags = 0x%08x\", (unsigned int)filesys->flags);\n\n            if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n            {\n                /* Log information about the system_mountpt prior to copy */\n                if (filesys->system_mountpt != NULL)\n                {\n                    char smbuf[256] = {0};\n                    strncpy(smbuf, filesys->system_mountpt, sizeof(smbuf) - 1);\n                    osfs_log(\"filesys->system_mountpt ptr=%p contents='%s'\", (void *)filesys->system_mountpt, smbuf);\n                }\n                else\n                {\n                    osfs_log(\"filesys->system_mountpt is NULL\");\n                }\n\n                /* Preserve original logic: copy the system mount point into PhysDriveName */\n                strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n                PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n\n                /* Log the result of the copy */\n                {\n                    char pdbuf[OS_FS_PHYS_NAME_LEN + 1];\n                    strncpy(pdbuf, PhysDriveName, OS_FS_PHYS_NAME_LEN);\n                    pdbuf[OS_FS_PHYS_NAME_LEN - 1] = '\\0';\n                    osfs_log(\"After strncpy, PhysDriveName ptr=%p contents='%s'\", (void *)PhysDriveName, pdbuf);\n                }\n            }\n            else\n            {\n                osfs_log(\"filesys is not a mounted system (flags 0x%08x) -> returning OS_ERR_INCORRECT_OBJ_STATE\", (unsigned int)filesys->flags);\n                return_code = OS_ERR_INCORRECT_OBJ_STATE;\n            }\n        }\n        else\n        {\n            osfs_log(\"OS_OBJECT_TABLE_GET returned NULL for token (token addr=%p)\", (void *)&token);\n            return_code = OS_ERR_NAME_NOT_FOUND;\n        }\n\n        OS_ObjectIdRelease(&token);\n        osfs_log(\"Released token (token addr=%p)\", (void *)&token);\n    }\n    else\n    {\n        osfs_log(\"OS_ObjectIdGetBySearch did not succeed -> returning OS_ERR_NAME_NOT_FOUND\");\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    osfs_log(\"EXIT OS_FS_GetPhysDriveName: return_code=%d\", (int)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FS_GetPhysDriveName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report as stated is not correct. The submitted code already declares MountPoint as const char * (so it is const-qualified). Agent A refers to a member named 'char *address' which does not appear in the shown function, so that specific claim is unsupported by the target code. The only suspicious const-related operation in the function is the cast (void *)MountPoint when calling OS_ObjectIdGetBySearch, which discards the const qualifier. That is a const-correctness issue (the callee should accept a const void * if it does not modify the data) but it is not the scenario A described and is better classified as \u201ccasting away const / discarding qualifiers\u201d (a different MISRA concern) rather than a plain violation of Rule 8.13 as claimed. Also, PhysDriveName is an output buffer and must be non-const, so it is correctly declared as char *. In summary: A\u2019s specific report is incorrect (is_report_correct = false), though the code does contain a cast that discards const and should be fixed by changing the callee prototype to accept a const void * or otherwise preserving const-correctness."
}