{
  "user_message": "An agent A claimed that the following OS_FS_GetPhysDriveName code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_FS_GetPhysDriveName.\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function OS_ObjectIdGetBySearch takes a void *arg and the MatchFunc type uses a void *ref parameter. Callers (e.g. OS_FS_GetPhysDriveName) pass a const char *MountPoint and cast it to (void *)MountPoint, discarding const. The actual match function (OS_FileSys_FindVirtMountPoint) treats the arg as a const char * (it does const char *target = (const char *)ref;), so the parameter should be declared const void * to preserve const-qualification. Casting away const and using a non-const pointer where a const-qualified pointer is appropriate violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_FS_WriteLog(const char *stage, const char *mountpoint, const void *ref_ptr, const void *extra_ptr, long return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1379.txt\", \"a\");\n    if (f != NULL)\n    {\n        char mpbuf[256];\n        if (mountpoint != NULL)\n        {\n            /* Copy safely so we don't read beyond if the string is long */\n            strncpy(mpbuf, mountpoint, sizeof(mpbuf) - 1);\n            mpbuf[sizeof(mpbuf) - 1] = '\\0';\n        }\n        else\n        {\n            mpbuf[0] = '\\0';\n        }\n\n        /* Log stage, mountpoint (truncated), pointer addresses and return code. */\n        fprintf(f, \"[OS_FS_GetPhysDriveName] stage=%s mountpoint=\\\"%s\\\" mountpoint_addr=%p ref_ptr=%p extra_ptr=%p return_code=%ld\\n\",\n                stage, (mpbuf[0] != '\\0') ? mpbuf : \"(null)\", (const void *)mountpoint, ref_ptr, extra_ptr, return_code);\n        fflush(f);\n        fclose(f);\n    }\n}\n\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Log entry and the parameters observed before the search call */\n    OS_FS_WriteLog(\"entry\", MountPoint, (const void *)MountPoint, NULL, -1);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    /* NOTE: The original code casts away const here; keep that original behavior\n       but log the const pointer value separately so the evidence of the cast is recorded. */\n    OS_FS_WriteLog(\"before_OS_ObjectIdGetBySearch_call\", MountPoint, (const void *)MountPoint, NULL, -1);\n\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    /* Log outcome of the search call */\n    OS_FS_WriteLog(\"after_OS_ObjectIdGetBySearch_call\", MountPoint, (const void *)MountPoint, (const void *)&token, (long)return_code);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Log filesys pointer and some of its state before making decisions */\n        OS_FS_WriteLog(\"filesys_resolved\", MountPoint, (const void *)MountPoint, (const void *)filesys, (long)return_code);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            /* Log the system_mountpt about to be copied */\n            OS_FS_WriteLog(\"copy_system_mountpt\", filesys->system_mountpt, (const void *)MountPoint, (const void *)filesys, (long)return_code);\n\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n\n            /* Log that the copy completed and what was written (truncated to avoid long lines) */\n            OS_FS_WriteLog(\"physdrive_written\", PhysDriveName, (const void *)MountPoint, (const void *)filesys, (long)return_code);\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n\n            OS_FS_WriteLog(\"incorrect_obj_state\", MountPoint, (const void *)MountPoint, (const void *)filesys, (long)return_code);\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n        OS_FS_WriteLog(\"name_not_found\", MountPoint, (const void *)MountPoint, NULL, (long)return_code);\n    }\n\n    /* Final log before returning */\n    OS_FS_WriteLog(\"exit\", MountPoint, (const void *)MountPoint, NULL, (long)return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FS_GetPhysDriveName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In OS_FS_GetPhysDriveName the caller passes a const char *MountPoint but explicitly casts it to (void *) when calling OS_ObjectIdGetBySearch, thereby discarding const-qualification. The match function OS_FileSys_FindVirtMountPoint then immediately treats the argument as a const char * (const char *target = (const char *)ref;), which shows the referenced data is not modified. Under MISRA C 2023 Rule 8.13 (\"A pointer should point to a const-qualified type whenever possible\") the API should preserve the const qualification \u2014 i.e. the search API and the MatchFunc type should use const void * (and the match function parameter should be const void *) so callers do not need to cast away const. Casting away const in the caller is therefore a violation of the rule in this usage. Note: if the search API or other callers legitimately require a mutable pointer (i.e. the function can modify the pointed-to data), then changing the API to const would be incorrect; in that case the cast would be necessary and the codebase must justify the design. Given the evidence that the match function only reads the string, the agent A's report is justified."
}