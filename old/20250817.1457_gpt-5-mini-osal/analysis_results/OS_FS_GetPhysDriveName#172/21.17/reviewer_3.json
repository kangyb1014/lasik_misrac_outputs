{
  "user_message": "An agent A claimed that the following OS_FS_GetPhysDriveName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_FS_GetPhysDriveName.\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the caller supplies PhysDriveName pointing to a buffer smaller than OS_FS_PHYS_NAME_LEN bytes, the preceding strncpy(PhysDriveName, ..., OS_FS_PHYS_NAME_LEN - 1) may copy up to OS_FS_PHYS_NAME_LEN-1 bytes and the subsequent write PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0 will write past the end of the buffer. Because the code does not check the actual size of the destination buffer, this can result in an out-of-bounds access related to the use of string handling functions, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Probe log file path */\n    const char *logpath = \"/tmp/logs/1383.txt\";\n    FILE *logf = NULL;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Log entry and initial pointers */\n    logf = fopen(logpath, \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"ENTRY: OS_FS_GetPhysDriveName called. PhysDriveName=%p, MountPoint=%p\\n\",\n                (void *)PhysDriveName, (void *)MountPoint);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    /* Log result of object search */\n    logf = fopen(logpath, \"a\");\n    if (logf != NULL)\n    {\n        fprintf(logf, \"After OS_ObjectIdGetBySearch: return_code=%d, token=%p\\n\",\n                (int)return_code, (void *)&token);\n        fclose(logf);\n        logf = NULL;\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        /* Log filesystem record pointer and flags */\n        logf = fopen(logpath, \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"filesys=%p, filesys->flags=0x%08X\\n\",\n                    (void *)filesys, (unsigned int)filesys->flags);\n            if (filesys->system_mountpt != NULL)\n            {\n                /* Log the source mount point string (safe read) */\n                fprintf(logf, \"filesys->system_mountpt='%s'\\n\", filesys->system_mountpt);\n            }\n            else\n            {\n                fprintf(logf, \"filesys->system_mountpt=NULL\\n\");\n            }\n            fclose(logf);\n            logf = NULL;\n        }\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            /* Log pre-copy diagnostic: intended copy length and terminator index */\n            logf = fopen(logpath, \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"About to strncpy to PhysDriveName=%p, copy_len=%d, terminator_index=%d (dest_address=%p)\\n\",\n                        (void *)PhysDriveName,\n                        (int)(OS_FS_PHYS_NAME_LEN - 1),\n                        (int)(OS_FS_PHYS_NAME_LEN - 1),\n                        (void *)(PhysDriveName + (OS_FS_PHYS_NAME_LEN - 1)));\n                fclose(logf);\n                logf = NULL;\n            }\n\n            /* Original behavior retained: may overflow if caller buffer smaller than OS_FS_PHYS_NAME_LEN */\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n\n            /* Log post-copy state (only pointer info, do NOT print PhysDriveName as string to avoid reading out-of-bounds) */\n            logf = fopen(logpath, \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"After copy: wrote terminator at index %d (address=%p).\\n\",\n                        (int)(OS_FS_PHYS_NAME_LEN - 1), (void *)(PhysDriveName + (OS_FS_PHYS_NAME_LEN - 1)));\n                fclose(logf);\n                logf = NULL;\n            }\n        }\n        else\n        {\n            /* Log incorrect object state */\n            logf = fopen(logpath, \"a\");\n            if (logf != NULL)\n            {\n                fprintf(logf, \"Filesystem not mounted system: flags=0x%08X, setting return_code=OS_ERR_INCORRECT_OBJ_STATE\\n\",\n                        (unsigned int)filesys->flags);\n                fclose(logf);\n                logf = NULL;\n            }\n\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n\n        /* Log release and final return code for this branch */\n        logf = fopen(logpath, \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"Released token. Returning return_code=%d\\n\", (int)return_code);\n            fclose(logf);\n            logf = NULL;\n        }\n    }\n    else\n    {\n        /* Log name not found case and final return code */\n        logf = fopen(logpath, \"a\");\n        if (logf != NULL)\n        {\n            fprintf(logf, \"OS_ObjectIdGetBySearch failed, setting return_code=OS_ERR_NAME_NOT_FOUND (%d)\\n\",\n                    (int)OS_ERR_NAME_NOT_FOUND);\n            fclose(logf);\n            logf = NULL;\n        }\n\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_FS_GetPhysDriveName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1) and then writes PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0 without any check of the actual size of the destination buffer pointed to by PhysDriveName. MISRA C 2023 Rule 21.17 prohibits using string.h functions in a way that can access beyond the bounds of the objects referenced by their pointer parameters. If the caller supplies a buffer smaller than OS_FS_PHYS_NAME_LEN, the strncpy can copy up to OS_FS_PHYS_NAME_LEN-1 bytes and the explicit write of the terminator can write past the end of the buffer, producing an out-of-bounds access. \n\nNote: If the API contract for OS_FS_GetPhysDriveName mandates (and callers are guaranteed to provide) a destination buffer of at least OS_FS_PHYS_NAME_LEN bytes, then in practice the calls are safe; however, the source code itself performs no validation of destination size, so absent an enforceable/proven precondition this is a MISRA-relevant defect. Recommended fixes include taking a dest-size parameter or using a copy bounded by the actual destination size (or otherwise statically proving the buffer size)."
}