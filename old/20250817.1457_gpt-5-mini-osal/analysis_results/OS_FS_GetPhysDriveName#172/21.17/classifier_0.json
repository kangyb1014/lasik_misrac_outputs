{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_FS_GetPhysDriveName:\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n{\n    OS_object_token_t             token;\n    int32                         return_code;\n    OS_filesys_internal_record_t *filesys;\n\n    /* Check parameters */\n    OS_CHECK_PATHNAME(MountPoint);\n    OS_CHECK_POINTER(PhysDriveName);\n\n    /* Get a reference lock, as a filesystem check could take some time. */\n    return_code = OS_ObjectIdGetBySearch(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, OS_FileSys_FindVirtMountPoint,\n                                         (void *)MountPoint, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, token);\n\n        if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM) != 0)\n        {\n            strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1);\n            PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0;\n        }\n        else\n        {\n            return_code = OS_ERR_INCORRECT_OBJ_STATE;\n        }\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        return_code = OS_ERR_NAME_NOT_FOUND;\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_FS_GetPhysDriveName:\ntypedef struct\n{\n    char device_name[OS_FS_DEV_NAME_LEN]; /**< The name of the underlying block device, if applicable */\n    char volume_name[OS_FS_VOL_NAME_LEN];\n    char system_mountpt[OS_MAX_LOCAL_PATH_LEN]; /**< The name/prefix where the contents are accessible in the host\n                                                   operating system */\n    char virtual_mountpt[OS_MAX_PATH_LEN]; /**< The name/prefix in the OSAL Virtual File system exposed to applications\n                                            */\n    char *            address;\n    size_t            blocksize;\n    osal_blockcount_t numblocks;\n    uint8             flags;\n    uint8             fstype;\n} OS_filesys_internal_record_t\n...\nOS_filesys_internal_record_t OS_filesys_table[LOCAL_NUM_OBJECTS]\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\n#define OS_FS_PHYS_NAME_LEN 64\n...\n#define OS_FILESYS_FLAG_IS_MOUNTED_SYSTEM 0x10\n...\nbool OS_FileSys_FindVirtMountPoint(void *ref, const OS_object_token_t *token, const OS_common_record_t *obj)\n{\n    OS_filesys_internal_record_t *filesys;\n    const char *                  target = (const char *)ref;\n    size_t                        mplen;\n\n    filesys = OS_OBJECT_TABLE_GET(OS_filesys_table, *token);\n\n    if ((filesys->flags & OS_FILESYS_FLAG_IS_MOUNTED_VIRTUAL) == 0)\n    {\n        return false;\n    }\n\n    mplen = OS_strnlen(filesys->virtual_mountpt, sizeof(filesys->virtual_mountpt));\n\n    /*\n     * The virtual_mountpt member should be a substring of the search target.\n     * If this matches a basic substring check then it may be match\n     */\n    if (mplen == 0 || mplen >= sizeof(filesys->virtual_mountpt) ||\n        strncmp(target, filesys->virtual_mountpt, mplen) != 0)\n    {\n        /* not a substring, so not a match */\n        return false;\n    }\n\n    /*\n     * Confirm that the substring ends at either a directory separator\n     * or the end of string  (so exact mount points also match).\n     *\n     * For instance consider a virtual_mountpt of /mnt/abc and searching\n     * for target=/mnt/abcd - this should return false in that case.\n     */\n    return (target[mplen] == '/' || target[mplen] == 0);\n}\n...\nint32 OS_ObjectIdGetBySearch(OS_lock_mode_t lock_mode, osal_objtype_t idtype, OS_ObjectMatchFunc_t MatchFunc, void *arg,\n                             OS_object_token_t *token)\n{\n    int32 return_code;\n\n    OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n\n    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"lock_mode\" parameter.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n    else\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n...\nvoid OS_ObjectIdRelease(OS_object_token_t *token)\n{\n    OS_ObjectIdTransactionFinish(token, NULL);\n}\n...\ntypedef struct OS_object_token OS_object_token_t\n...\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_CHECK_PATHNAME(str) OS_CHECK_STRING(str,OS_MAX_PATH_LEN,OS_FS_ERR_PATH_TOO_LONG)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nint32 OS_FS_GetPhysDriveName(char *PhysDriveName, const char *MountPoint)\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The function calls strncpy(PhysDriveName, filesys->system_mountpt, OS_FS_PHYS_NAME_LEN - 1) and then writes PhysDriveName[OS_FS_PHYS_NAME_LEN - 1] = 0 without validating that the caller-supplied PhysDriveName actually points to an object of at least OS_FS_PHYS_NAME_LEN bytes. If a caller passes a smaller buffer (e.g. char buf[16]; OS_FS_GetPhysDriveName(buf, ...)), the strncpy will write up to 63 bytes and the subsequent write of index 63 will overflow buf. Also, strncpy may read up to OS_FS_PHYS_NAME_LEN-1 bytes from filesys->system_mountpt; if filesys->system_mountpt's array size or termination is smaller than that, this can read beyond its bounds. Therefore Rule 21.17 is violated."
}