{
  "user_message": "An agent A claimed that the following OS_MutSemDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemDelete.\n```c\nint32 OS_MutSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_MutSemDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes a non-const OS_object_token_t * (token) to OS_WaitForStateChange. If OS_WaitForStateChange does not modify the token, its parameter should be declared as const OS_object_token_t * and the call should pass a pointer-to-const. Thus, if the OS_WaitForStateChange prototype is void OS_WaitForStateChange(OS_object_token_t *token, uint32 attempts) but the function does not modify *token, this violates MISRA C 2023 Rule 8.13. Change the callee to take const OS_object_token_t *token (and adjust callers) to comply.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_log_write_simple(const char *tag, osal_id_t sem_id, int32 return_code, const void *token_addr)\n{\n    FILE *f = fopen(\"/tmp/logs/1747.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"%s: sem_id=%lu return_code=%ld token_addr=%p\\n\",\n            tag, (unsigned long)sem_id, (long)return_code, token_addr);\n    fclose(f);\n}\nstatic void os_log_token_bytes(const char *tag, osal_id_t sem_id, int32 return_code, const OS_object_token_t *token)\n{\n    FILE *f = fopen(\"/tmp/logs/1747.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log header line */\n    fprintf(f, \"%s: sem_id=%lu return_code=%ld token_addr=%p\\n\",\n            tag, (unsigned long)sem_id, (long)return_code, (const void *)token);\n\n    if (token != NULL)\n    {\n        /* Safely capture the first N bytes of the token for inspection. The\n         * size of OS_object_token_t is known here because the original code\n         * instantiates a local variable of that type. Truncate if very large. */\n        const size_t MAX_BYTES = 64U;\n        unsigned char buf[MAX_BYTES];\n        size_t token_size = sizeof(*token);\n        size_t copy_len = token_size < MAX_BYTES ? token_size : MAX_BYTES;\n\n        memcpy(buf, token, copy_len);\n\n        fprintf(f, \" token_bytes(%zu):\", copy_len);\n        for (size_t i = 0; i < copy_len; ++i)\n        {\n            fprintf(f, \" %02x\", buf[i]);\n        }\n        if (token_size > copy_len)\n        {\n            fprintf(f, \" ... (truncated, total %zu bytes)\", token_size);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fclose(f);\n}\n\nint32 OS_MutSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Entry probe */\n    os_log_write_simple(\"OS_MutSemDelete: entry\", sem_id, 0, NULL);\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    /* Log after attempting to obtain the object token. This captures whether\n     * the token was populated and the return code from the lookup. */\n    os_log_token_bytes(\"OS_MutSemDelete: after OS_ObjectIdGetById\", sem_id, return_code, &token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log before calling the implementation delete routine. This will\n         * capture the token state as passed to the callee (address and bytes),\n         * which is useful to reproduce scenarios where a callee should have\n         * taken a const pointer instead of a non-const pointer. */\n        os_log_token_bytes(\"OS_MutSemDelete: before OS_MutSemDelete_Impl\", sem_id, return_code, &token);\n\n        return_code = OS_MutSemDelete_Impl(&token);\n\n        /* Log after the implementation call to record any change in return_code\n         * or (if applicable) token contents. */\n        os_log_token_bytes(\"OS_MutSemDelete: after OS_MutSemDelete_Impl\", sem_id, return_code, &token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Finalize logging for this successful path */\n        os_log_token_bytes(\"OS_MutSemDelete: after OS_ObjectIdFinalizeDelete\", sem_id, return_code, &token);\n    }\n    else\n    {\n        /* Log the failure path */\n        os_log_write_simple(\"OS_MutSemDelete: lookup failed\", sem_id, return_code, &token);\n    }\n\n    /* Exit probe */\n    os_log_write_simple(\"OS_MutSemDelete: exit\", sem_id, return_code, &token);\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nOS_MutSemDelete: entry: sem_id=0 return_code=0 token_addr=(nil)\nOS_MutSemDelete: after OS_ObjectIdGetById: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe00\n token_bytes(20): 00 00 00 00 00 00 00 00 05 00 00 00 ff ff ff ff 00 00 00 00\nOS_MutSemDelete: lookup failed: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe00\nOS_MutSemDelete: exit: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe00\nOS_MutSemDelete: entry: sem_id=0 return_code=0 token_addr=(nil)\nOS_MutSemDelete: after OS_ObjectIdGetById: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfde0\n token_bytes(20): 00 00 00 00 00 00 00 00 05 00 00 00 ff ff ff ff 00 00 00 00\nOS_MutSemDelete: lookup failed: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfde0\nOS_MutSemDelete: exit: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfde0\nOS_MutSemDelete: entry: sem_id=3735928559 return_code=0 token_addr=(nil)\nOS_MutSemDelete: after OS_ObjectIdGetById: sem_id=3735928559 return_code=-16 token_addr=0x7ffd34cdfe30\n token_bytes(20): 00 00 00 00 00 00 00 00 05 00 00 00 ff ff ff ff 00 00 00 00\nOS_MutSemDelete: lookup failed: sem_id=3735928559 return_code=-16 token_addr=0x7ffd34cdfe30\nOS_MutSemDelete: exit: sem_id=3735928559 return_code=-16 token_addr=0x7ffd34cdfe30\nOS_MutSemDelete: entry: sem_id=0 return_code=0 token_addr=(nil)\nOS_MutSemDelete: after OS_ObjectIdGetById: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe30\n token_bytes(20): 00 00 00 00 00 00 00 00 05 00 00 00 ff ff ff ff 00 00 00 00\nOS_MutSemDelete: lookup failed: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe30\nOS_MutSemDelete: exit: sem_id=0 return_code=-16 token_addr=0x7ffd34cdfe30\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The claimant\u2019s argument is speculative: the target code does not call an OS_WaitForStateChange function, and nothing in the provided code or logs shows that the token is only ever read. In fact the logs demonstrate that OS_ObjectIdGetById writes/populates the local token (you can see token bytes captured after the lookup), so the token is an output/modified object and cannot be const-qualified at the call site. MISRA Rule 8.13 requires pointers to be const-qualified when the pointed-to object is not modified; that determination depends on the callee(s). No evidence is provided that any callee here takes a non-const pointer but does not modify *token. Therefore the claim of a Rule 8.13 violation for OS_MutSemDelete is unsupported."
}