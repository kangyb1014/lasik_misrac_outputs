{
  "user_message": "An agent A claimed that the following OS_MutSemDelete code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_MutSemDelete.\n```c\nint32 OS_MutSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        return_code = OS_MutSemDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call OS_Unlock_Global(token) passes a non-const OS_object_token_t * even though the token is only used to identify which global to unlock and is not modified by the call. If OS_Unlock_Global does not (and need not) modify the token object, its prototype should be OS_Unlock_Global(const OS_object_token_t *token). Therefore the current use likely violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void append_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1747.txt\", \"a\");\n    if (f != NULL)\n    {\n        (void)fprintf(f, \"%s\", msg);\n        (void)fflush(f);\n        (void)fclose(f);\n    }\n}\nstatic void dump_token(const char *prefix, const OS_object_token_t *token)\n{\n    char buf[256];\n    if (token == NULL)\n    {\n        (void)snprintf(buf, sizeof(buf), \"%s: token=NULL\\n\", prefix);\n    }\n    else\n    {\n        (void)snprintf(buf, sizeof(buf), \"%s: token_addr=%p id=%u type=%u name=\\\"%s\\\"\\n\",\n                       prefix, (const void *)token, (unsigned)token->id, (unsigned)token->type, token->name);\n    }\n    append_log(buf);\n}\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t obj_type, osal_id_t id, OS_object_token_t *token)\n{\n    /* Produce a dummy token. This simulates a successful lookup. */\n    if (token == NULL)\n    {\n        return -1; /* error */\n    }\n\n    token->id = (uint32_t)id;\n    token->type = (uint32_t)obj_type;\n    (void)strncpy(token->name, \"mutsem0\", sizeof(token->name));\n    token->name[sizeof(token->name) - 1] = '\\0';\n\n    return OS_SUCCESS;\n}\nint32 OS_MutSemDelete_Impl(const OS_object_token_t *token)\n{\n    /* Intentionally do not modify the token to mirror the violation scenario. */\n    (void)token; /* suppress unused-parameter warnings */\n\n    /* Simulate successful deletion of the underlying resource */\n    append_log(\"OS_MutSemDelete_Impl: called (token not modified)\\n\");\n    return OS_SUCCESS;\n}\nint32 OS_ObjectIdFinalizeDelete(int32 operation_status, OS_object_token_t *token)\n{\n    /* Log that finalize was called and do not modify the token. */\n    (void)token;\n    if (operation_status == OS_SUCCESS)\n    {\n        append_log(\"OS_ObjectIdFinalizeDelete: finalize success\\n\");\n    }\n    else\n    {\n        append_log(\"OS_ObjectIdFinalizeDelete: finalize failure\\n\");\n    }\n\n    return operation_status;\n}\n\nint32 OS_MutSemDelete(osal_id_t sem_id)\n{\n    OS_object_token_t token;\n    int32             return_code;\n\n    /* Log entry and input id */\n    {\n        char buf[128];\n        (void)snprintf(buf, sizeof(buf), \"OS_MutSemDelete: entry sem_id=%u\\n\", (unsigned)sem_id);\n        append_log(buf);\n    }\n\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, sem_id, &token);\n\n    {\n        char buf[128];\n        (void)snprintf(buf, sizeof(buf), \"OS_MutSemDelete: after OS_ObjectIdGetById return_code=%d\\n\", (int)return_code);\n        append_log(buf);\n    }\n\n    if (return_code == OS_SUCCESS)\n    {\n        /* Log token state before calling implementation */\n        dump_token(\"OS_MutSemDelete: before OS_MutSemDelete_Impl\", &token);\n\n        /* Call the implementation (preserve original call signature) */\n        return_code = OS_MutSemDelete_Impl(&token);\n\n        /* Log token state after implementation to detect any unexpected modifications */\n        dump_token(\"OS_MutSemDelete: after  OS_MutSemDelete_Impl\", &token);\n\n        /* Complete the operation via the common routine */\n        {\n            char buf[128];\n            (void)snprintf(buf, sizeof(buf), \"OS_MutSemDelete: before OS_ObjectIdFinalizeDelete return_code=%d\\n\", (int)return_code);\n            append_log(buf);\n        }\n\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n\n        /* Log token state after finalize */\n        dump_token(\"OS_MutSemDelete: after  OS_ObjectIdFinalizeDelete\", &token);\n\n        {\n            char buf[128];\n            (void)snprintf(buf, sizeof(buf), \"OS_MutSemDelete: exit return_code=%d\\n\", (int)return_code);\n            append_log(buf);\n        }\n    }\n    else\n    {\n        append_log(\"OS_MutSemDelete: skipping delete due to ObjectIdGetById failure\\n\");\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 says a pointer should point to a const-qualified type whenever possible, but whether a violation exists depends on the declarations (prototypes) and the actual intent of the callees, not merely on the call site. In OS_MutSemDelete the local token is written by OS_ObjectIdGetById, so token cannot be declared const. Passing the address of a non-const object to a function that promises not to modify it (i.e., takes a const pointer) is allowed; conversely, if a callee legitimately needs to modify the token (e.g. OS_ObjectIdFinalizeDelete may update bookkeeping), its non-const parameter is appropriate. Agent A assumes OS_MutSemDelete_Impl and/or OS_ObjectIdFinalizeDelete do not modify the token and therefore their prototypes should use const, but that assumption is not proven by the snippet. The provided test binary did not compile, so no behavioral evidence was produced. To determine a real MISRA 8.13 violation you must inspect the function prototypes/definitions: if a function does not (and will not) modify the pointed-to object, its prototype should be changed to take a pointer to const; otherwise the current non-const usage is justified. Given the available information, the claim of a concrete MISRA 8.13 violation in OS_MutSemDelete is not supported."
}