{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "select",
    "clock_gettime",
    "memset",
    "errno",
    "EINTR",
    "EAGAIN",
    "CLOCK_MONOTONIC",
    "fd_set",
    "struct timeval",
    "struct timespec",
    "NULL",
    "int32",
    "OS_ERROR",
    "OS_ERROR_TIMEOUT",
    "OS_SUCCESS"
  ],
  "explanation": "Each listed symbol is referenced or implied by OS_DoSelect and is needed to determine whether the function relies on any language/compiler extensions (as opposed to standard C or standard library APIs). Brief reasons for including each:\n\n- select: Core OS/socket API used to wait for file descriptors. Must be checked whether this is provided by the standard library or by a platform-specific extension.\n- clock_gettime: Time API used to compute absolute deadlines. Needed to see if this function is a platform extension (POSIX) or otherwise relies on compiler/platform extensions.\n- memset: Standard library function used to clear ts_end. Needed to verify header usage and whether any nonstandard overloads/extensions are involved.\n- errno: Global error indicator used in the EINTR/EAGAIN loop. Determine whether errno access uses any extension (thread-local errno variants, macros, etc.).\n- EINTR, EAGAIN: Error macros compared against errno; must confirm they are provided by the platform headers and not as compiler-specific extensions.\n- CLOCK_MONOTONIC: Macro passed to clock_gettime; verify it is a standard/platform macro and not a compiler extension.\n- fd_set: Type of rd_set/wr_set passed to select; needed to confirm it is the standard fd_set and not a compiler-specific type or extension.\n- struct timeval: Used for select timeout (tv). Its member types and semantics affect integer sign/width assumptions in arithmetic; check if members are standard or platform-specific extensions.\n- struct timespec: Used for monotonic clock times; its layout and member types matter for arithmetic and potential extension usage.\n- NULL: Used as a pointer value (tvptr = NULL). Confirm standard macro semantics and no compiler-specific NULL redefinition.\n- int32: Typedef of the function return/parameter type; must be resolved to check whether it is a standard fixed-width typedef (e.g., int32_t) or a project/compiler extension.\n- OS_ERROR, OS_ERROR_TIMEOUT, OS_SUCCESS: Return-code macros/constants used by the function. Needed to resolve their definitions to ensure they are normal macros/enums and not implemented using compiler-specific extensions.\n\nProviding these symbols (their declarations/definitions and the headers that supply them) lets the next analyst determine whether any of them are implemented using language/compiler extensions (nonstandard keywords, builtins, nonportable attributes, or nonstandard calling conventions) and thus whether OS_DoSelect violates the MISRA rule against language extensions."
}