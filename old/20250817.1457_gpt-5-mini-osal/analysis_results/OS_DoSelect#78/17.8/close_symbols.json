{
  "user_message": "Target function code is:\n```c\nstatic int32 OS_DoSelect(int maxfd, fd_set *rd_set, fd_set *wr_set, int32 msecs)\n{\n    int             os_status;\n    int32           return_code;\n    struct timeval  tv;\n    struct timeval *tvptr;\n    struct timespec ts_now;\n    struct timespec ts_end;\n\n    if (msecs > 0)\n    {\n        clock_gettime(CLOCK_MONOTONIC, &ts_now);\n        ts_end.tv_sec  = ts_now.tv_sec + (msecs / 1000);\n        ts_end.tv_nsec = ts_now.tv_nsec + (1000000 * (msecs % 1000));\n        if (ts_end.tv_nsec >= 1000000000)\n        {\n            ++ts_end.tv_sec;\n            ts_end.tv_nsec -= 1000000000;\n        }\n    }\n    else\n    {\n        /* Zero for consistency and to avoid possible confusion if not cleared */\n        memset(&ts_end, 0, sizeof(ts_end));\n    }\n\n    do\n    {\n        if (msecs < 0)\n        {\n            tvptr = NULL;\n        }\n        else if (msecs == 0)\n        {\n            tvptr      = &tv;\n            tv.tv_sec  = 0;\n            tv.tv_usec = 0;\n        }\n        else\n        {\n            tvptr = &tv;\n\n            clock_gettime(CLOCK_MONOTONIC, &ts_now);\n\n            /* note that the tv_sec and tv_usec/tv_nsec values are all signed longs, so OK to subtract */\n            tv.tv_sec  = ts_end.tv_sec - ts_now.tv_sec;\n            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000;\n\n            if (tv.tv_sec < 0 || (tv.tv_sec == 0 && tv.tv_usec < 0))\n            {\n                os_status = 0;\n                break;\n            }\n\n            if (tv.tv_usec < 0)\n            {\n                tv.tv_usec += 1000000;\n                --tv.tv_sec;\n            }\n        }\n\n        os_status = select(maxfd + 1, rd_set, wr_set, NULL, tvptr);\n    } while (os_status < 0 && (errno == EINTR || errno == EAGAIN));\n\n    if (os_status < 0)\n    {\n        return_code = OS_ERROR;\n    }\n    else if (os_status == 0)\n    {\n        return_code = OS_ERROR_TIMEOUT;\n    }\n    else\n    {\n        return_code = OS_SUCCESS;\n    }\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_DoSelect': {'callees': [], 'callers': ['OS_SelectSingle_Impl', 'OS_SelectMultiple_Impl']}, 'OS_SelectSingle_Impl': {'callees': ['OS_ObjectIndexFromToken', 'OS_DoSelect'], 'callers': ['OS_GenericRead_Impl', 'OS_GenericWrite_Impl', 'OS_SocketConnect_Impl', 'OS_SocketAccept_Impl', 'OS_SocketRecvFrom_Impl', 'OS_SelectSingle']}, 'OS_SelectMultiple_Impl': {'callees': ['OS_FdSet_ConvertIn_Impl', 'OS_DoSelect', 'OS_FdSet_ConvertOut_Impl'], 'callers': ['OS_SelectMultiple']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "select (prototype in <sys/select.h>)",
    "fd_set (type definition)",
    "struct timeval (type definition)",
    "struct timespec (type definition)",
    "clock_gettime (prototype in <time.h>)",
    "memset (prototype in <string.h>)",
    "errno (lvalue), EINTR, EAGAIN (from <errno.h>)",
    "NULL (macro)"
  ],
  "explanation": "For assessing the MISRA rule that a function parameter shall not be modified, the analyzer must know whether any called library functions or data types used in OS_DoSelect can legally or actually change the parameter variables (maxfd, rd_set, wr_set, msecs) themselves rather than only the objects they point to. Each listed symbol is needed for that determination:\n\n- select (prototype): confirms parameter types (fd_set * for read/write sets) and semantics \u2014 select can modify the contents of the fd_set objects pointed to but cannot alter the caller\u2019s pointer variables (parameters) because C passes arguments by value.\n\n- fd_set (type definition): to verify that select operates on the object referenced by the pointer (allowed) and that there is no hidden mechanism (e.g., fd_set being a macro alias) that could cause modification of the pointer parameter itself.\n\n- struct timeval and struct timespec (type definitions): these are used to compute and pass the timeout; their definitions ensure that only local variables (tv, ts_now, ts_end) are modified and that no aliasing could cause modification of function parameters.\n\n- clock_gettime (prototype): to confirm its parameters and that it does not receive addresses of OS_DoSelect parameters (so it cannot modify them).\n\n- memset (prototype): to confirm it is called on the local ts_end object and not on any parameter (so it cannot modify parameters).\n\n- errno, EINTR, EAGAIN (from <errno.h>): to understand the retry condition and to ensure there is no indirect modification of parameters via signal/handler interactions in this code path.\n\n- NULL (macro): used when passing timeout pointer; verify it is a standard null pointer constant and not a macro that could expand to something altering parameters.\n\n(Other symbols in the function such as OS_ERROR/OS_ERROR_TIMEOUT/OS_SUCCESS are return constants and do not affect whether parameters are modified, so they are omitted.)"
}