{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of UT_Stub_CopyToReturnValue:\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function UT_Stub_CopyToReturnValue:\nstatic UT_StubTableEntry_t *UT_GetStubEntry(UT_EntryKey_t FuncKey, UT_EntryType_t TestMode)\n{\n    UT_StubTableEntry_t *StubPtr   = NULL;\n    uint32               Idx       = FuncKey % (UT_MAX_FUNC_STUBS - 1); /* hash the key to determine the start point */\n    uint32               SearchLen = 0;\n    uint32               SearchLimit;\n    UT_EntryKey_t        SearchKey;\n\n    /* If searching for an unused entry, look through the entire table.\n     * Otherwise bound the search */\n    if (TestMode == UT_ENTRYTYPE_UNUSED)\n    {\n        SearchLimit = UT_MAX_FUNC_STUBS;\n        SearchKey   = 0;\n    }\n    else\n    {\n        SearchLimit = UT_MaxStubSearchLen;\n        SearchKey   = FuncKey;\n    }\n\n    while (1)\n    {\n        if (SearchLen >= SearchLimit)\n        {\n            StubPtr = NULL;\n            break;\n        }\n        ++SearchLen;\n        StubPtr = &UT_StubTable[Idx];\n        if (StubPtr->EntryType == TestMode && StubPtr->FuncKey == SearchKey)\n        {\n            break;\n        }\n        ++Idx;\n        if (Idx >= UT_MAX_FUNC_STUBS)\n        {\n            Idx = 0;\n        }\n    }\n\n    /*\n     * Keep track of the longest search length since the last reset.\n     * This serves as the upper bound for future searches.\n     */\n    if (SearchLen > UT_MaxStubSearchLen)\n    {\n        UT_MaxStubSearchLen = SearchLen;\n    }\n\n    return StubPtr;\n}\n...\ntypedef struct\n{\n    UT_EntryType_t EntryType;\n    uint32         ModeFlags;\n    UT_EntryKey_t  FuncKey;\n    UT_EntryData_t Data;\n} UT_StubTableEntry_t\n...\ntypedef cpuaddr UT_EntryKey_t\n...\nvoid UtAssert_Abort(const char *Message)\n{\n    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT, Message);\n}\n...\nstatic void UT_GenericReadStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    void * buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", void *);\n    size_t nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t CopySize;\n    int32  status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyToLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyToLocal returns zero, this probably means no buffer was supplied,\n         * in which case just generate fill data and pretend it was read.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            memset(buffer, 0, nbytes);\n            status = nbytes;\n        }\n    }\n    else if (status > 0)\n    {\n        /* generate fill data for requested size */\n        memset(buffer, 0, status);\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nstatic void UT_GenericWriteStub(UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      nbytes = UT_Hook_GetArgValueByName(Context, \"nbytes\", size_t);\n    size_t      CopySize;\n    int32       status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(FuncKey, buffer, nbytes);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = nbytes;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nvoid UT_DefaultHandler_OS_lseek(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    int32 offset = UT_Hook_GetArgValueByName(Context, \"offset\", int32);\n    int32 Status;\n\n    if (UT_Stub_GetInt32StatusCode(Context, &Status))\n    {\n        /* Use the configured status code directly as the returned offset */\n        offset = Status;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, offset);\n}\n...\nvoid UT_DefaultHandler_OS_IdentifyObject(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    osal_id_t      object_id = UT_Hook_GetArgValueByName(Context, \"object_id\", osal_id_t);\n    osal_objtype_t ObjType;\n    uint32         checkindx;\n    int32          status;\n\n    if (UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        /* Use the \"status code\" as the object type if it was set */\n        ObjType = status;\n    }\n    else\n    {\n        /* output a type that will actually match the ID */\n        UT_ObjIdDecompose(object_id, &checkindx, &ObjType);\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, ObjType);\n}\n...\nvoid UT_DefaultHandler_OS_QueueGet(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    osal_id_t queue_id    = UT_Hook_GetArgValueByName(Context, \"queue_id\", osal_id_t);\n    void *    data        = UT_Hook_GetArgValueByName(Context, \"data\", void *);\n    size_t    size        = UT_Hook_GetArgValueByName(Context, \"size\", size_t);\n    size_t *  size_copied = UT_Hook_GetArgValueByName(Context, \"size_copied\", size_t *);\n    int32     status;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        *size_copied = UT_Stub_CopyToLocal((UT_EntryKey_t)OS_ObjectIdToInteger(queue_id), data, size);\n        if (*size_copied == 0)\n        {\n            status = OS_QUEUE_EMPTY;\n        }\n\n        UT_Stub_SetReturnValue(FuncKey, status);\n    }\n}\n...\nvoid UT_DefaultHandler_OS_SocketRecvFrom(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    void * buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", void *);\n    size_t buflen = UT_Hook_GetArgValueByName(Context, \"buflen\", size_t);\n    int32  status;\n    size_t CopySize;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyToLocal(UT_KEY(OS_SocketRecvFrom), buffer, buflen);\n\n        /* If CopyToLocal returns zero, this probably means no buffer was supplied,\n         * in which case just generate fill data and pretend it was read.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            memset(buffer, 0, buflen);\n            status = buflen;\n        }\n    }\n    else if (status > 0)\n    {\n        /* generate fill data for requested size */\n        memset(buffer, 0, status);\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nvoid UT_DefaultHandler_OS_SocketSendTo(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    const void *buffer = UT_Hook_GetArgValueByName(Context, \"buffer\", const void *);\n    size_t      buflen = UT_Hook_GetArgValueByName(Context, \"buflen\", size_t);\n    int32       status;\n    size_t      CopySize;\n\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        CopySize = UT_Stub_CopyFromLocal(UT_KEY(OS_SocketSendTo), buffer, buflen);\n\n        /* If CopyFromLocal returns zero, this probably means no buffer was supplied,\n         * in which case just throw out the data and pretend it was written.\n         */\n        if (CopySize > 0)\n        {\n            status = CopySize;\n        }\n        else\n        {\n            status = buflen;\n        }\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, status);\n}\n...\nvoid UT_DefaultHandler_OS_TaskGetId(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    osal_id_t TaskId;\n    int32     status;\n\n    /* Unless set otherwise this returns a task ID that correlates to table position 1.\n     * This is for historical reasons, many old test cases assume this is the default */\n    if (!UT_Stub_GetInt32StatusCode(Context, &status))\n    {\n        status = 1;\n    }\n    UT_ObjIdCompose(status, OS_OBJECT_TYPE_OS_TASK, &TaskId);\n\n    UT_Stub_SetReturnValue(FuncKey, TaskId);\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionString(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionString), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n...\nvoid UT_DefaultHandler_OS_GetVersionCodeName(void *UserObj, UT_EntryKey_t FuncKey, const UT_StubContext_t *Context)\n{\n    static const char DEFAULT[] = \"UT\";\n    void *            Buffer;\n    const char *      RetVal;\n\n    UT_GetDataBuffer(UT_KEY(OS_GetVersionCodeName), &Buffer, NULL, NULL);\n    if (Buffer == NULL)\n    {\n        RetVal = DEFAULT;\n    }\n    else\n    {\n        RetVal = Buffer;\n    }\n\n    UT_Stub_SetReturnValue(FuncKey, RetVal);\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I reviewed the provided code fragments for possible unreachable code (MISRA C 2023 Rule 2.1). None of the shown code contains obviously unreachable statements or blocks: \n\n- UT_Stub_CopyToReturnValue: The outer if (StubPtr != NULL) is conditional on the runtime result of UT_GetStubEntry; both branches are reachable depending on that function. The UtAssert_Abort call may not return, but there is no subsequent code in that branch that would be rendered unreachable by that fact. The else branch (memcpy + setting Position) is reachable when sizes match.\n\n- UT_GetStubEntry: The while(1) loop has two distinct, reachable exit paths (match found or SearchLen >= SearchLimit). The Idx wrap-around, incrementing and the SearchLimit logic are all driven by runtime values, so the body and the post-loop update of UT_MaxStubSearchLen are reachable depending on inputs.\n\n- UT_GenericReadStub / UT_GenericWriteStub / UT_DefaultHandler_OS_SocketRecvFrom / UT_DefaultHandler_OS_SocketSendTo / UT_DefaultHandler_OS_lseek / UT_DefaultHandler_OS_IdentifyObject / UT_DefaultHandler_OS_QueueGet / UT_DefaultHandler_OS_TaskGetId / UT_DefaultHandler_OS_GetVersionString / UT_DefaultHandler_OS_GetVersionCodeName: In each of these handlers, conditional branches depend on the runtime result of UT_Stub_GetInt32StatusCode, the contents returned by UT_Hook_GetArgValueByName, or UT_GetDataBuffer. All branches (including else/else-if blocks) are reachable for appropriate runtime inputs; there are no constant conditions or dead-code constructs present in the excerpts provided. For example, the else-if (status > 0) branches are taken when UT_Stub_GetInt32StatusCode yields a status > 0; the Buffer NULL check is meaningful depending on UT_GetDataBuffer runtime return. \n\nBecause every conditional and loop in the provided fragments depends on values only known at runtime, and there are no statements after unconditional returns/aborts or constant-false conditionals, I found no code that is demonstrably unreachable from the given excerpts. If you have additional code (e.g., definitions/implementations of UT_Stub_GetInt32StatusCode, UT_GetDataBuffer, UT_GetStubEntry callers, or constant macro values such as UT_MAX_FUNC_STUBS or UT_MaxStubSearchLen initialization) that would show some branches can never be taken, please provide them and I will re-evaluate those specific locations."
}