{
  "user_message": "Target function code is:\n```c\nvoid UT_Stub_CopyToReturnValue(UT_EntryKey_t FuncKey, const void *BufferPtr, size_t BufferSize)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n    if (StubPtr != NULL)\n    {\n        /* If the size does not match, there is a bug */\n        if (StubPtr->Data.Buff.TotalSize != BufferSize)\n        {\n            UtAssert_Abort(\"Size mismatch in setting return value\");\n        }\n        else\n        {\n            memcpy(StubPtr->Data.Buff.BasePtr, BufferPtr, BufferSize);\n            StubPtr->Data.Buff.Position = BufferSize;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_Stub_CopyToReturnValue': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_GenericReadStub', 'UT_GenericWriteStub', 'UT_DefaultHandler_OS_lseek', 'UT_DefaultHandler_OS_IdentifyObject', 'UT_DefaultHandler_OS_QueueGet', 'UT_DefaultHandler_OS_SocketRecvFrom', 'UT_DefaultHandler_OS_SocketSendTo', 'UT_DefaultHandler_OS_TaskGetId', 'UT_DefaultHandler_OS_GetVersionString', 'UT_DefaultHandler_OS_GetVersionCodeName']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_GenericReadStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_read', 'UT_DefaultHandler_OS_TimedRead']}, 'UT_GenericWriteStub': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': ['UT_DefaultHandler_OS_write', 'UT_DefaultHandler_OS_TimedWrite']}, 'UT_DefaultHandler_OS_lseek': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_IdentifyObject': {'callees': ['UT_Hook_GetArgPtr', 'UT_ObjIdDecompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_QueueGet': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'OS_ObjectIdToInteger', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketRecvFrom': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_SocketSendTo': {'callees': ['UT_Hook_GetArgPtr', 'UT_Stub_CopyFromLocal', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_TaskGetId': {'callees': ['UT_ObjIdCompose', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionString': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}, 'UT_DefaultHandler_OS_GetVersionCodeName': {'callees': ['UT_GetDataBuffer', 'UT_Stub_CopyToReturnValue'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_EntryKey_t",
    "UT_StubTableEntry_t",
    "(type/definition of StubPtr->Data and StubPtr->Data.Buff including members TotalSize, BasePtr, Position)",
    "UT_GetStubEntry (declaration/definition)",
    "UT_ENTRYTYPE_RETURN_BUFFER",
    "UtAssert_Abort (declaration/definition and implementation)",
    "memcpy (declaration)",
    "size_t (typedef)",
    "NULL (macro)"
  ],
  "explanation": "Why each symbol is required for checking the MISRA rule about language extensions:\n\n- UT_EntryKey_t: The typedef may be implemented with compiler-specific storage-class or keyword extensions (attributes, non-standard integer types). Need its definition to confirm it is standard C.\n\n- UT_StubTableEntry_t: The struct/typedef returned by UT_GetStubEntry is inspected in the function (members accessed). Its definition must be checked for language extensions (e.g., compiler attributes, anonymous/unnamed structs/unions as an extension, bit-field types, flexible array members, or other non-standard constructs).\n\n- (type/definition of StubPtr->Data and StubPtr->Data.Buff including members TotalSize, BasePtr, Position): The function relies on these nested types/members (TotalSize, BasePtr, Position). Their member types or the way they are declared could use language extensions (anonymous unions/structs, compiler attributes, nonstandard pointer types). The exact nested definitions are needed to rule out such extensions.\n\n- UT_GetStubEntry (declaration/definition): The prototype/implementation may use compiler-specific attributes (e.g., __attribute__, calling-convention keywords, inline asm) or return a type via an extension. We must inspect its signature and definition to ensure no extensions are used.\n\n- UT_ENTRYTYPE_RETURN_BUFFER: This macro/enum value could be defined using nonstandard constructs or macros that expand to compiler-specific code. Its definition is required to ensure it is a plain standard constant/enum.\n\n- UtAssert_Abort (declaration/definition and implementation): Called on error; its declaration/definition might use extensions (attributes, variadic macros with nonstandard tokens, inline asm, or other compiler-specific features). The implementation must be checked because the target function calls it.\n\n- memcpy (declaration): Although part of the standard library, the actual declaration included in the build environment could be replaced or wrapped with compiler-specific extensions. Checking the declaration ensures the use here is standard.\n\n- size_t (typedef): This standard typedef may be aliased or redefined in the project with nonstandard attributes or types. Its definition must be confirmed to be standard.\n\n- NULL (macro): The code compares to NULL; the project definition of NULL could use a nonstandard form. Verify NULL is defined in a standard-compliant way.\n\nCollectively, these symbols allow a reviewer to inspect all typedefs, struct/union definitions, function prototypes and macro definitions that the target function depends on; any of those could hide compiler-specific language extensions that would violate the MISRA prohibition on language extensions."
}