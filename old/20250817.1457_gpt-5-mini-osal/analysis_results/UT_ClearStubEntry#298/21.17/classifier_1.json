{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of UT_ClearStubEntry:\n```c\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        free(StubPtr->Data.Buff.BasePtr);\n    }\n    memset(StubPtr, 0, sizeof(*StubPtr));\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function UT_ClearStubEntry:\nconst char *BasePtr\n...\n#define UT_MODEFLAG_ALLOC_BUF 0x1U\n...\nUT_StubTableEntry_t *StubPtr\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset(StubPtr, 0, sizeof(*StubPtr));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The call memset(StubPtr, 0, sizeof(*StubPtr)) will violate MISRA C 2023 Rule 21.17 if StubPtr does not point to a valid object of type UT_StubTableEntry_t (or if StubPtr == NULL). In particular, passing a NULL pointer with a non\u2011zero size (or passing a pointer to a smaller object/subobject than sizeof(UT_StubTableEntry_t)) causes memset to access beyond the bounds of the referenced object. Although the function dereferences StubPtr earlier (implying a non\u2011NULL precondition), that precondition is not enforced in the shown fragment, so the call can be unsafe and thus violates the rule unless the caller guarantees StubPtr is valid and points to a full UT_StubTableEntry_t object."
}