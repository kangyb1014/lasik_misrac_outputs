{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Logging probe: capture control flow and relevant buffer state to help reproduce the zero-length-copy scenario. */\n    FILE *log = fopen(\"/tmp/logs/2386.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"UT_ClearStubEntry called: StubPtr=%p\\n\", (void *)StubPtr);\n        fprintf(log, \" EntryType=%d, ModeFlags=0x%X, BasePtr=%p\\n\",\n                (int)StubPtr->EntryType,\n                (unsigned int)StubPtr->ModeFlags,\n                (void *)StubPtr->Data.Buff.BasePtr);\n        /* Print numeric buffer fields (cast to unsigned long long for safety across possible integer widths) */\n        fprintf(log, \" Buff.Position=%llu, Buff.TotalSize=%llu, Buff.MaxSize=%llu\\n\",\n                (unsigned long long)StubPtr->Data.Buff.Position,\n                (unsigned long long)StubPtr->Data.Buff.TotalSize,\n                (unsigned long long)StubPtr->Data.Buff.MaxSize);\n        fflush(log);\n    }\n\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \" Condition for free() satisfied. Calling free() on %p\\n\", (void *)StubPtr->Data.Buff.BasePtr);\n            fflush(log);\n        }\n\n        free(StubPtr->Data.Buff.BasePtr);\n\n        if (log != NULL)\n        {\n            fprintf(log, \" free() completed\\n\");\n            fflush(log);\n        }\n    }\n    else\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \" free() not called (either EntryType mismatch, BasePtr==NULL, or not UT_MODEFLAG_ALLOC_BUF)\\n\");\n            fflush(log);\n        }\n    }\n\n    memset(StubPtr, 0, sizeof(*StubPtr));\n\n    if (log != NULL)\n    {\n        fprintf(log, \" StubPtr memory cleared with memset(%zu)\\n\\n\", sizeof(*StubPtr));\n        fclose(log);\n    }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpmy09u76r/src/ut_assert/src/utstubs.c: In function 'UT_ClearStubEntry':\n/tmp/tmpmy09u76r/src/ut_assert/src/utstubs.c:170:55: error: 'UT_BufferEntry_t' has no member named 'MaxSize'\n  170 |                 (unsigned long long)StubPtr->Data.Buff.MaxSize);\n      |                                                       ^\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:104: ut_assert/CMakeFiles/ut_assert.dir/src/utstubs.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UT_ClearStubEntry as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void UT_ClearStubEntry(UT_StubTableEntry_t *StubPtr)\n{\n    /* Logging probe: capture control flow and relevant buffer state to help reproduce the zero-length-copy scenario. */\n    FILE *log = fopen(\"/tmp/logs/2386.txt\", \"a\");\n    if (log != NULL)\n    {\n        fprintf(log, \"UT_ClearStubEntry called: StubPtr=%p\\n\", (void *)StubPtr);\n        fprintf(log, \" EntryType=%d, ModeFlags=0x%X, BasePtr=%p\\n\",\n                (int)StubPtr->EntryType,\n                (unsigned int)StubPtr->ModeFlags,\n                (void *)StubPtr->Data.Buff.BasePtr);\n        /* Print numeric buffer fields (cast to unsigned long long for safety across possible integer widths) */\n        /* Note: removed reference to Buff.MaxSize because UT_BufferEntry_t does not have that member. */\n        fprintf(log, \" Buff.Position=%llu, Buff.TotalSize=%llu\\n\",\n                (unsigned long long)StubPtr->Data.Buff.Position,\n                (unsigned long long)StubPtr->Data.Buff.TotalSize);\n        fflush(log);\n    }\n\n    /* Be sure to call free() on any malloc'ed buffers before clearing */\n    if ((StubPtr->EntryType == UT_ENTRYTYPE_DATA_BUFFER || StubPtr->EntryType == UT_ENTRYTYPE_RETURN_BUFFER) &&\n        StubPtr->Data.Buff.BasePtr != NULL && (StubPtr->ModeFlags & UT_MODEFLAG_ALLOC_BUF) != 0)\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \" Condition for free() satisfied. Calling free() on %p\\n\", (void *)StubPtr->Data.Buff.BasePtr);\n            fflush(log);\n        }\n\n        free(StubPtr->Data.Buff.BasePtr);\n\n        if (log != NULL)\n        {\n            fprintf(log, \" free() completed\\n\");\n            fflush(log);\n        }\n    }\n    else\n    {\n        if (log != NULL)\n        {\n            fprintf(log, \" free() not called (either EntryType mismatch, BasePtr==NULL, or not UT_MODEFLAG_ALLOC_BUF)\\n\");\n            fflush(log);\n        }\n    }\n\n    memset(StubPtr, 0, sizeof(*StubPtr));\n\n    if (log != NULL)\n    {\n        fprintf(log, \" StubPtr memory cleared with memset(%zu)\\n\\n\", sizeof(*StubPtr));\n        fclose(log);\n    }\n}\n",
  "explanation": "The build error was caused by accessing a non-existent member Buff.MaxSize of UT_BufferEntry_t. I removed that reference and the corresponding fprintf field so the code only prints fields that exist (Position and TotalSize). No other logic was changed: the logging, free() call, and memset() behavior are preserved. I also included standard headers (stdio.h, stdlib.h, string.h) to ensure the function compiles standalone."
}