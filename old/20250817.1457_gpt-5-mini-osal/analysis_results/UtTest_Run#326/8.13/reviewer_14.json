{
  "user_message": "An agent A claimed that the following UtTest_Run code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UtTest_Run.\n```c\nvoid UtTest_Run(void)\n{\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    UT_BSP_Lock();\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    UT_BSP_Unlock();\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                UtTestDataBaseEntry->Setup();\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                UtTestDataBaseEntry->Teardown();\n            }\n\n            UtAssert_EndTest();\n        }\n    }\n\n    UT_BSP_Lock();\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n    UT_BSP_Unlock();\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:UtList_GetObject returns a non-const void * (ListNode->Data). In callers such as UtTest_Run the returned object is only read (UtTestDataBaseEntry is used to read TestName and call functions) so the pointer could and should be const-qualified (e.g. const void *UtList_GetObject(const UtListNode_t *ListNode) or returning const UtTestDataBaseEntry_t *). Returning a non-const pointer when no modification is required violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic FILE *UtProbe_LogFile(void)\n{\n    static FILE *logf = NULL;\n    if (logf == NULL)\n    {\n        /* Ensure directory exists; ignore errors if it already exists */\n        (void)mkdir(\"/tmp/logs\", 0777);\n        logf = fopen(\"/tmp/logs/2611.txt\", \"a\");\n        if (logf != NULL)\n        {\n            (void)fprintf(logf, \"---- UtTest_Run probe start ----\\n\");\n            (void)fflush(logf);\n        }\n    }\n    return logf;\n}\nstatic void UtProbe_Log(const char *fmt, ...)\n{\n    FILE *f = UtProbe_LogFile();\n    if (f == NULL)\n    {\n        return; /* best-effort logging only */\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    (void)vfprintf(f, fmt, ap);\n    va_end(ap);\n    (void)fflush(f);\n}\nstatic void UtProbe_Close(void)\n{\n    FILE *f = UtProbe_LogFile();\n    if (f != NULL)\n    {\n        (void)fprintf(f, \"---- UtTest_Run probe end ----\\n\\n\");\n        (void)fclose(f);\n    }\n}\n\nvoid UtTest_Run(void)\n{\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    UT_BSP_Lock();\n\n    /* Log start state */\n    UtProbe_Log(\"UtTest_Run: begin. DataBasePtr=%p\\n\", (void *)UtAssert_Global.DataBasePtr);\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtProbe_Log(\"UtListMain (after default) = %p\\n\", (void *)UtListMain);\n\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtProbe_Log(\"Merged SETUP into UtListMain\\n\");\n\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtProbe_Log(\"Merged TEST into UtListMain\\n\");\n\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n    UtProbe_Log(\"Merged TEARDOWN into UtListMain\\n\");\n\n    UT_BSP_Unlock();\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        /* Capture the raw returned object pointer to log it for analysis */\n        void *rawObj = UtList_GetObject(UtListNode);\n        UtProbe_Log(\"Iteration: UtListNode=%p, rawObj=%p\\n\", (void *)UtListNode, rawObj);\n\n        UtTestDataBaseEntry = (UtTestDataBaseEntry_t *)rawObj;\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            /* Log the important fields used in this function to show they are only read */\n            UtProbe_Log(\"  TestEntry @%p: TestName=%p\\n\", (void *)UtTestDataBaseEntry, (void *)UtTestDataBaseEntry->TestName);\n            if (UtTestDataBaseEntry->TestName != NULL)\n            {\n                /* Print a limited prefix to avoid long writes or invalid memory access */\n                char buf[128] = {0};\n                size_t i;\n                for (i = 0; i < sizeof(buf) - 1 && UtTestDataBaseEntry->TestName[i] != '\\0'; ++i)\n                {\n                    buf[i] = UtTestDataBaseEntry->TestName[i];\n                }\n                buf[i] = '\\0';\n                UtProbe_Log(\"    TestName (prefix)='%s'\\n\", buf);\n            }\n            UtProbe_Log(\"    Setup=%p, Test=%p, Teardown=%p\\n\",\n                        (void *)UtTestDataBaseEntry->Setup,\n                        (void *)UtTestDataBaseEntry->Test,\n                        (void *)UtTestDataBaseEntry->Teardown);\n\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                UtProbe_Log(\"    Calling Setup()\\n\");\n                UtTestDataBaseEntry->Setup();\n                UtProbe_Log(\"    Setup() returned\\n\");\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                UtProbe_Log(\"    Calling Test() [ExecutedCount before=%u]\\n\", (unsigned int)UtAssert_Global.ExecutedCount);\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n                UtProbe_Log(\"    Test() returned [ExecutedCount after=%u]\\n\", (unsigned int)UtAssert_Global.ExecutedCount);\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                UtProbe_Log(\"    Calling Teardown()\\n\");\n                UtTestDataBaseEntry->Teardown();\n                UtProbe_Log(\"    Teardown() returned\\n\");\n            }\n\n            UtAssert_EndTest();\n        }\n        else\n        {\n            UtProbe_Log(\"  UtTestDataBaseEntry is NULL for node %p\\n\", (void *)UtListNode);\n        }\n    }\n\n    UT_BSP_Lock();\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n    UtProbe_Log(\"Destroyed DataBasePtr=%p\\n\", (void *)UtAssert_Global.DataBasePtr);\n    UT_BSP_Unlock();\n\n    UtProbe_Log(\"Calling UT_BSP_EndTest with counters=%u\\n\", (unsigned int)UtAssert_GetCounters());\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n\n    UtProbe_Close();\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n---- UtTest_Run probe start ----\nUtTest_Run: begin. DataBasePtr=0x55b4cb24a890\nUtListMain (after default) = 0x55b4cb24a8a0\nMerged SETUP into UtListMain\nMerged TEST into UtListMain\nMerged TEARDOWN into UtListMain\nIteration: UtListNode=0x55b4cb24a8c0, rawObj=(nil)\n  UtTestDataBaseEntry is NULL for node 0x55b4cb24a8c0\nIteration: UtListNode=0x55b4cb24a8e0, rawObj=(nil)\n  UtTestDataBaseEntry is NULL for node 0x55b4cb24a8e0\nIteration: UtListNode=0x55b4cb24a930, rawObj=0x55b4cb24a950\n  TestEntry @0x55b4cb24a950: TestName=0x55b4cb24a968\n    TestName (prefix)='OS_VxWorks_BinSemAPI_Impl_Init'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00879, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=0]\n    Test() returned [ExecutedCount after=1]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24a9a0, rawObj=0x55b4cb24a9c0\n  TestEntry @0x55b4cb24a9c0: TestName=0x55b4cb24a9d8\n    TestName (prefix)='OS_BinSemCreate_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00941, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=1]\n    Test() returned [ExecutedCount after=2]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24aa10, rawObj=0x55b4cb24aa30\n  TestEntry @0x55b4cb24aa30: TestName=0x55b4cb24aa48\n    TestName (prefix)='OS_BinSemDelete_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00b31, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=2]\n    Test() returned [ExecutedCount after=3]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24aa80, rawObj=0x55b4cb24aaa0\n  TestEntry @0x55b4cb24aaa0: TestName=0x55b4cb24aab8\n    TestName (prefix)='OS_BinSemGive_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00c41, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=3]\n    Test() returned [ExecutedCount after=4]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24aaf0, rawObj=0x55b4cb24ab10\n  TestEntry @0x55b4cb24ab10: TestName=0x55b4cb24ab28\n    TestName (prefix)='OS_BinSemFlush_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00e1d, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=4]\n    Test() returned [ExecutedCount after=5]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24ab60, rawObj=0x55b4cb24ab80\n  TestEntry @0x55b4cb24ab80: TestName=0x55b4cb24ab98\n    TestName (prefix)='OS_BinSemTake_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e00ff9, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=5]\n    Test() returned [ExecutedCount after=6]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24abd0, rawObj=0x55b4cb24abf0\n  TestEntry @0x55b4cb24abf0: TestName=0x55b4cb24ac08\n    TestName (prefix)='OS_BinSemTimedWait_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e01109, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=6]\n    Test() returned [ExecutedCount after=7]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24ac40, rawObj=0x55b4cb24ac60\n  TestEntry @0x55b4cb24ac60: TestName=0x55b4cb24ac78\n    TestName (prefix)='OS_BinSemGetInfo_Impl'\n    Setup=0x55b4b4e014ed, Test=0x55b4b4e013c0, Teardown=0x55b4b4e01573\n    Calling Setup()\n    Setup() returned\n    Calling Test() [ExecutedCount before=7]\n    Test() returned [ExecutedCount after=8]\n    Calling Teardown()\n    Teardown() returned\nIteration: UtListNode=0x55b4cb24a900, rawObj=(nil)\n  UtTestDataBaseEntry is NULL for node 0x55b4cb24a900\nDestroyed DataBasePtr=0x55b4cb24a890\nCalling UT_BSP_EndTest with counters=3034679296\n---- UtTest_Run probe end ----\n\n---- UtTest_Run probe start ----\nUtTest_Run: begin. DataBasePtr=0x55753a39e890\nUtListMain (after default) = 0x55753a39e8a0\nMerged SETUP into UtListMain\nMerged TEST into UtListMain\nMerged TEARDOWN into Ut\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In UtTest_Run the object returned by UtList_GetObject is only read (fields TestName and function pointers are inspected/called) and never modified; the probe output confirms all accesses are read-only (no writes to the pointed-to object). Under MISRA C:2023 Rule 8.13, such pointers should be const-qualified whenever possible. Here both the local variable (UtTestDataBaseEntry_t *UtTestDataBaseEntry) and the underlying list API return type (void * from UtList_GetObject) are non-const even though a const qualification would be appropriate and safe. To comply with the rule the API should return a const-qualified pointer (e.g. const void *UtList_GetObject(const UtListNode_t *)) and/or the local variable should be declared const (const UtTestDataBaseEntry_t *UtTestDataBaseEntry). Therefore the agent A's violation report is correct."
}