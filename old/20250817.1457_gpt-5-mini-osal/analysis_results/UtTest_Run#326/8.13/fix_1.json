{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nvoid UtTest_Run(void)\n{\n    FILE *log = fopen(\"/tmp/logs/2611.txt\", \"a\");\n\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: start\\n\");\n        fflush(log);\n    }\n\n    UT_BSP_Lock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Lock acquired\\n\");\n        fflush(log);\n    }\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: merged list head=%p\\n\", (void *)UtListMain);\n        fflush(log);\n    }\n\n    UT_BSP_Unlock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Unlock called\\n\");\n        fflush(log);\n    }\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        if (log)\n        {\n            fprintf(log, \"UtTest_Run: UtList_GetObject returned ptr=%p for node=%p\\n\", (void *)UtTestDataBaseEntry,\n                    (void *)UtListNode);\n            fflush(log);\n        }\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            /* Log the test name and function pointer availability for traceability */\n            if (log)\n            {\n                const char *name = UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\";\n                fprintf(log, \"UtTest_Run: Begin test '%s' entry=%p\\n\", name, (void *)UtTestDataBaseEntry);\n                fprintf(log, \"  Setup ptr=%p, Test ptr=%p, Teardown ptr=%p\\n\",\n                        (void *)UtTestDataBaseEntry->Setup,\n                        (void *)UtTestDataBaseEntry->Test,\n                        (void *)UtTestDataBaseEntry->Teardown);\n                fflush(log);\n            }\n\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Setup for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Setup();\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Setup for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Test for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Test for '%s', ExecutedCount=%u\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\",\n                            (unsigned)UtAssert_Global.ExecutedCount);\n                    fflush(log);\n                }\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Teardown for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Teardown();\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Teardown for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n            }\n\n            UtAssert_EndTest();\n\n            if (log)\n            {\n                fprintf(log, \"UtTest_Run: End test '%s'\\n\\n\",\n                        UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                fflush(log);\n            }\n        }\n        else\n        {\n            if (log)\n            {\n                fprintf(log, \"UtTest_Run: Skipping NULL entry for node=%p\\n\", (void *)UtListNode);\n                fflush(log);\n            }\n        }\n    }\n\n    UT_BSP_Lock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Lock acquired for cleanup\\n\");\n        fflush(log);\n    }\n\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n\n    UT_BSP_Unlock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Unlock called after cleanup\\n\");\n        fprintf(log, \"UtTest_Run: calling UT_BSP_EndTest with counters: Passed=%u, Failed=%u, Executed=%u\\n\",\n                (unsigned)UtAssert_Global.PassCount,\n                (unsigned)UtAssert_Global.FailCount,\n                (unsigned)UtAssert_Global.ExecutedCount);\n        fflush(log);\n        fclose(log);\n    }\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpd18umo9q/src/ut_assert/src/uttest.c: In function 'UtTest_Run':\n/tmp/tmpd18umo9q/src/ut_assert/src/uttest.c:305:42: error: 'UtAssert_Global_t' has no member named 'PassCount'\n  305 |                 (unsigned)UtAssert_Global.PassCount,\n      |                                          ^\n/tmp/tmpd18umo9q/src/ut_assert/src/uttest.c:306:42: error: 'UtAssert_Global_t' has no member named 'FailCount'\n  306 |                 (unsigned)UtAssert_Global.FailCount,\n      |                                          ^\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:118: ut_assert/CMakeFiles/ut_assert.dir/src/uttest.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UtTest_Run as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "void UtTest_Run(void)\n{\n    FILE *log = fopen(\"/tmp/logs/2611.txt\", \"a\");\n\n    UtListNode_t *         UtListMain;\n    UtListNode_t *         UtListNode;\n    UtTestDataBaseEntry_t *UtTestDataBaseEntry;\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: start\\n\");\n        fflush(log);\n    }\n\n    UT_BSP_Lock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Lock acquired\\n\");\n        fflush(log);\n    }\n\n    /*\n     * The overall test sequence goes SETUP->TEST->TEARDOWN\n     *\n     * Combine all registered test groups into a merged group for execution.\n     *\n     * This could also (theoretically) randomize the order of the \"TEST\" group\n     * while assembling this list, if there was a portable source of entropy.\n     */\n    UtListMain = UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_DEFAULT);\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_SETUP));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEST));\n    UtList_Merge(UtListMain, UtList_GetHead(UtAssert_Global.DataBasePtr, UTASSERT_GROUP_TEARDOWN));\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: merged list head=%p\\n\", (void *)UtListMain);\n        fflush(log);\n    }\n\n    UT_BSP_Unlock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Unlock called\\n\");\n        fflush(log);\n    }\n\n    /*\n     * Run through the merged list in order\n     */\n    for (UtListNode = UtList_GetNext(UtListMain); !UtList_IsEnd(UtListMain, UtListNode);\n         UtListNode = UtList_GetNext(UtListNode))\n    {\n        UtTestDataBaseEntry = UtList_GetObject(UtListNode);\n\n        if (log)\n        {\n            fprintf(log, \"UtTest_Run: UtList_GetObject returned ptr=%p for node=%p\\n\", (void *)UtTestDataBaseEntry,\n                    (void *)UtListNode);\n            fflush(log);\n        }\n\n        if (UtTestDataBaseEntry != NULL)\n        {\n            /* Log the test name and function pointer availability for traceability */\n            if (log)\n            {\n                const char *name = UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\";\n                fprintf(log, \"UtTest_Run: Begin test '%s' entry=%p\\n\", name, (void *)UtTestDataBaseEntry);\n                fprintf(log, \"  Setup ptr=%p, Test ptr=%p, Teardown ptr=%p\\n\",\n                        (void *)UtTestDataBaseEntry->Setup,\n                        (void *)UtTestDataBaseEntry->Test,\n                        (void *)UtTestDataBaseEntry->Teardown);\n                fflush(log);\n            }\n\n            UtAssert_BeginTest(UtTestDataBaseEntry->TestName);\n\n            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);\n            if (UtTestDataBaseEntry->Setup)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Setup for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Setup();\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Setup for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);\n            if (UtTestDataBaseEntry->Test)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Test for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Test();\n                UtAssert_Global.ExecutedCount++;\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Test for '%s', ExecutedCount=%u\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\",\n                            (unsigned)UtAssert_Global.ExecutedCount);\n                    fflush(log);\n                }\n            }\n            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);\n            if (UtTestDataBaseEntry->Teardown)\n            {\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: calling Teardown for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n                UtTestDataBaseEntry->Teardown();\n                if (log)\n                {\n                    fprintf(log, \"UtTest_Run: returned from Teardown for '%s'\\n\",\n                            UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                    fflush(log);\n                }\n            }\n\n            UtAssert_EndTest();\n\n            if (log)\n            {\n                fprintf(log, \"UtTest_Run: End test '%s'\\n\\n\",\n                        UtTestDataBaseEntry->TestName ? UtTestDataBaseEntry->TestName : \"(null)\");\n                fflush(log);\n            }\n        }\n        else\n        {\n            if (log)\n            {\n                fprintf(log, \"UtTest_Run: Skipping NULL entry for node=%p\\n\", (void *)UtListNode);\n                fflush(log);\n            }\n        }\n    }\n\n    UT_BSP_Lock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Lock acquired for cleanup\\n\");\n        fflush(log);\n    }\n\n    UtList_Destroy(UtAssert_Global.DataBasePtr);\n\n    UT_BSP_Unlock();\n\n    if (log)\n    {\n        fprintf(log, \"UtTest_Run: UT_BSP_Unlock called after cleanup\\n\");\n        /* Only print the ExecutedCount here; do not reference members that may not exist on UtAssert_Global */\n        fprintf(log, \"UtTest_Run: calling UT_BSP_EndTest with counters: Executed=%u\\n\",\n                (unsigned)UtAssert_Global.ExecutedCount);\n        fflush(log);\n        fclose(log);\n    }\n\n    UT_BSP_EndTest(UtAssert_GetCounters());\n}\n",
  "explanation": "The build error was due to references to UtAssert_Global.PassCount and UtAssert_Global.FailCount, which do not exist on the UtAssert_Global_t type in this codebase. To fix this without changing external APIs, I removed those invalid member accesses and adjusted the log to only print the ExecutedCount (which is present). The rest of the function logic is preserved, and the final call to UT_BSP_EndTest still passes the counters via UtAssert_GetCounters(). This avoids referencing unknown struct members while keeping the original flow intact."
}