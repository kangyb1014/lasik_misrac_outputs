{
  "user_message": "An agent A claimed that the following UT_Stub_RegisterReturnType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_Stub_RegisterReturnType.\n```c\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            if (StubPtr == NULL)\n            {\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position       = 0;\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n        }\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs if StubPtr->Data.Buff.ContentTypeStr is declared without const (e.g. as 'char *ContentTypeStr'). Assigning the parameter 'const char *TypeName' to a non-const pointer discards the const qualifier and therefore violates MISRA C 2023 Rule 8.13. If ContentTypeStr is already declared as 'const char *', there is no violation. Recommend declaring the member as 'const char *ContentTypeStr' to comply.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_ProbeLog(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/2587.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    va_end(args);\n\n    fflush(fp);\n    fclose(fp);\n}\n\nvoid UT_Stub_RegisterReturnType(UT_EntryKey_t FuncKey, size_t ReturnSize, const char *TypeName)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    UT_ProbeLog(\"Enter UT_Stub_RegisterReturnType: FuncKey=%lu, ReturnSize=%zu, TypeName=%p, TypeName_str=%s\\n\",\n                (unsigned long)FuncKey,\n                ReturnSize,\n                (const void *)TypeName,\n                (TypeName != NULL) ? TypeName : \"(null)\");\n\n    if (ReturnSize > 0)\n    {\n        /* Check for existing buffer and re-use if same size (should be!) */\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);\n        UT_ProbeLog(\"UT_GetStubEntry(RETURN_BUFFER) returned %p\\n\", (const void *)StubPtr);\n\n        if (StubPtr != NULL && StubPtr->Data.Buff.TotalSize != ReturnSize)\n        {\n            UT_ProbeLog(\"Existing buffer size mismatch: existing=%zu, requested=%zu - clearing stub %p\\n\",\n                        StubPtr->Data.Buff.TotalSize, ReturnSize, (const void *)StubPtr);\n            UT_ClearStubEntry(StubPtr);\n            StubPtr = NULL;\n            UT_ProbeLog(\"Stub cleared, continuing to allocate new stub.\\n\");\n        }\n\n        if (StubPtr == NULL)\n        {\n            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n            UT_ProbeLog(\"UT_GetStubEntry(UNUSED) returned %p\\n\", (const void *)StubPtr);\n            if (StubPtr == NULL)\n            {\n                UT_ProbeLog(\"Abort condition reached: no unused stub available for FuncKey=%lu\\n\", (unsigned long)FuncKey);\n                UtAssert_Abort(\"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\");\n            }\n            else\n            {\n                UT_ProbeLog(\"Initializing new stub at %p for FuncKey=%lu\\n\", (const void *)StubPtr, (unsigned long)FuncKey);\n\n                StubPtr->FuncKey           = FuncKey;\n                StubPtr->EntryType         = UT_ENTRYTYPE_RETURN_BUFFER;\n                UT_ProbeLog(\"Attempting malloc of size %zu for stub %p\\n\", ReturnSize, (const void *)StubPtr);\n                StubPtr->Data.Buff.BasePtr = malloc(ReturnSize);\n                UT_ProbeLog(\"malloc returned %p for stub %p\\n\", (const void *)StubPtr->Data.Buff.BasePtr, (const void *)StubPtr);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UT_ProbeLog(\"malloc failed for size %zu\\n\", ReturnSize);\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memset(StubPtr->Data.Buff.BasePtr, 0, ReturnSize);\n                    UT_ProbeLog(\"memset done for buffer %p size %zu\\n\", (const void *)StubPtr->Data.Buff.BasePtr, ReturnSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                    UT_ProbeLog(\"ModeFlags updated to 0x%08x for stub %p\\n\", StubPtr->ModeFlags, (const void *)StubPtr);\n                }\n\n                StubPtr->Data.Buff.TotalSize = ReturnSize;\n                UT_ProbeLog(\"Set TotalSize=%zu for stub %p\\n\", StubPtr->Data.Buff.TotalSize, (const void *)StubPtr);\n            }\n        }\n\n        if (StubPtr != NULL)\n        {\n            StubPtr->Data.Buff.Position = 0;\n            UT_ProbeLog(\"Set Position=0 for stub %p\\n\", (const void *)StubPtr);\n\n            /* Log the assignment operation explicitly so that the pointer value and\n             * the source TypeName are captured in the log. This helps reproduce\n             * cases where a const-qualified source is assigned to a potentially\n             * non-const member in the struct at runtime. */\n            UT_ProbeLog(\"Assigning ContentTypeStr member at address %p of stub %p <- TypeName %p (%s)\\n\",\n                        (const void *)&(StubPtr->Data.Buff.ContentTypeStr), (const void *)StubPtr,\n                        (const void *)TypeName, (TypeName != NULL) ? TypeName : \"(null)\");\n\n            StubPtr->Data.Buff.ContentTypeStr = TypeName;\n\n            UT_ProbeLog(\"After assignment: ContentTypeStr=%p, ContentTypeStr_str=%s for stub %p\\n\",\n                        (const void *)StubPtr->Data.Buff.ContentTypeStr,\n                        (StubPtr->Data.Buff.ContentTypeStr != NULL) ? StubPtr->Data.Buff.ContentTypeStr : \"(null)\",\n                        (const void *)StubPtr);\n        }\n    }\n\n    UT_ProbeLog(\"Exit UT_Stub_RegisterReturnType for FuncKey=%lu\\n\", (unsigned long)FuncKey);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEnter UT_Stub_RegisterReturnType: FuncKey=94127219965472, ReturnSize=4, TypeName=0x559bb38334d8, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned (nil)\nUT_GetStubEntry(UNUSED) returned 0x559bb38409e0\nInitializing new stub at 0x559bb38409e0 for FuncKey=94127219965472\nAttempting malloc of size 4 for stub 0x559bb38409e0\nmalloc returned 0x559be8355cb0 for stub 0x559bb38409e0\nmemset done for buffer 0x559be8355cb0 size 4\nModeFlags updated to 0x00000001 for stub 0x559bb38409e0\nSet TotalSize=4 for stub 0x559bb38409e0\nSet Position=0 for stub 0x559bb38409e0\nAssigning ContentTypeStr member at address 0x559bb3840a08 of stub 0x559bb38409e0 <- TypeName 0x559bb38334d8 (int32)\nAfter assignment: ContentTypeStr=0x559bb38334d8, ContentTypeStr_str=int32 for stub 0x559bb38409e0\nExit UT_Stub_RegisterReturnType for FuncKey=94127219965472\nEnter UT_Stub_RegisterReturnType: FuncKey=94127219965472, ReturnSize=4, TypeName=0x559bb38334d8, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned 0x559bb38409e0\nSet Position=0 for stub 0x559bb38409e0\nAssigning ContentTypeStr member at address 0x559bb3840a08 of stub 0x559bb38409e0 <- TypeName 0x559bb38334d8 (int32)\nAfter assignment: ContentTypeStr=0x559bb38334d8, ContentTypeStr_str=int32 for stub 0x559bb38409e0\nExit UT_Stub_RegisterReturnType for FuncKey=94127219965472\nEnter UT_Stub_RegisterReturnType: FuncKey=94127219965472, ReturnSize=4, TypeName=0x559bb38334d8, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned 0x559bb38409e0\nSet Position=0 for stub 0x559bb38409e0\nAssigning ContentTypeStr member at address 0x559bb3840a08 of stub 0x559bb38409e0 <- TypeName 0x559bb38334d8 (int32)\nAfter assignment: ContentTypeStr=0x559bb38334d8, ContentTypeStr_str=int32 for stub 0x559bb38409e0\nExit UT_Stub_RegisterReturnType for FuncKey=94127219965472\nEnter UT_Stub_RegisterReturnType: FuncKey=93887043458399, ReturnSize=4, TypeName=0x5563c7e0a425, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned (nil)\nUT_GetStubEntry(UNUSED) returned 0x5563c7e17720\nInitializing new stub at 0x5563c7e17720 for FuncKey=93887043458399\nAttempting malloc of size 4 for stub 0x5563c7e17720\nmalloc returned 0x5563fbacfa80 for stub 0x5563c7e17720\nmemset done for buffer 0x5563fbacfa80 size 4\nModeFlags updated to 0x00000001 for stub 0x5563c7e17720\nSet TotalSize=4 for stub 0x5563c7e17720\nSet Position=0 for stub 0x5563c7e17720\nAssigning ContentTypeStr member at address 0x5563c7e17748 of stub 0x5563c7e17720 <- TypeName 0x5563c7e0a425 (int32)\nAfter assignment: ContentTypeStr=0x5563c7e0a425, ContentTypeStr_str=int32 for stub 0x5563c7e17720\nExit UT_Stub_RegisterReturnType for FuncKey=93887043458399\nEnter UT_Stub_RegisterReturnType: FuncKey=93887043458399, ReturnSize=4, TypeName=0x5563c7e0a425, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned 0x5563c7e17720\nSet Position=0 for stub 0x5563c7e17720\nAssigning ContentTypeStr member at address 0x5563c7e17748 of stub 0x5563c7e17720 <- TypeName 0x5563c7e0a425 (int32)\nAfter assignment: ContentTypeStr=0x5563c7e0a425, ContentTypeStr_str=int32 for stub 0x5563c7e17720\nExit UT_Stub_RegisterReturnType for FuncKey=93887043458399\nEnter UT_Stub_RegisterReturnType: FuncKey=93887043458399, ReturnSize=4, TypeName=0x5563c7e0a425, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned 0x5563c7e17720\nSet Position=0 for stub 0x5563c7e17720\nAssigning ContentTypeStr member at address 0x5563c7e17748 of stub 0x5563c7e17720 <- TypeName 0x5563c7e0a425 (int32)\nAfter assignment: ContentTypeStr=0x5563c7e0a425, ContentTypeStr_str=int32 for stub 0x5563c7e17720\nExit UT_Stub_RegisterReturnType for FuncKey=93887043458399\nEnter UT_Stub_RegisterReturnType: FuncKey=94475143883201, ReturnSize=4, TypeName=0x55ecb564d4c0, TypeName_str=int32\nUT_GetStubEntry(RETURN_BUFFER) returned (nil)\nUT_GetStubEntry(UNUSED) returned 0x55ecb5663400\nInitializing new stub at 0x55ecb5663400 for FuncKey=94475143883201\nAttempting malloc of size 4 for stub 0x55ecb5663400\nmalloc returned 0x55ecd9917c40 for stub 0x55ecb5663400\nmemset done for buffer 0x55ecd9917c40 size 4\nModeFlags updated to 0x00000001 for stub 0x55ecb5663400\nSet T\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 8.13 requires pointers to point to const-qualified types when possible. In the function the parameter is const char *TypeName and it is assigned to StubPtr->Data.Buff.ContentTypeStr. If ContentTypeStr is declared as a non-const pointer (e.g. char *ContentTypeStr) that assignment discards the const qualifier and therefore violates the rule. If the struct member is declared as const char *ContentTypeStr there is no violation. The proper remedy is to declare the struct member as const char * (or otherwise avoid assigning a const-qualified pointer to a non-const pointer)."
}