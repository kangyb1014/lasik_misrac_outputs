{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable 'task' is declared as a non-const pointer (OS_task_internal_record_t *task;) but it is only used to read fields (task->delete_hook_pointer) and not to modify the record. It therefore could and should be declared as a pointer to const (const OS_task_internal_record_t *task), so Rule 8.13 is violated.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_TaskDelete code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2035.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_TaskDelete as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_TaskDelete:\n```c\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task;\n    osal_task_entry            delete_hook;\n\n    delete_hook = NULL;\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_EXCLUSIVE, LOCAL_OBJID_TYPE, task_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        task = OS_OBJECT_TABLE_GET(OS_task_table, token);\n\n        /* Save the delete hook, as we do not want to call it while locked */\n        delete_hook = task->delete_hook_pointer;\n\n        return_code = OS_TaskDelete_Impl(&token);\n\n        /* Complete the operation via the common routine */\n        return_code = OS_ObjectIdFinalizeDelete(return_code, &token);\n    }\n\n    /*\n    ** Call the thread Delete hook if there is one.\n    */\n    if (return_code == OS_SUCCESS && delete_hook != NULL)\n    {\n        delete_hook();\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_TaskDelete code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <string.h>\n\n/* Minimal stub types and constants to make this test file compilable and runnable. */\ntypedef int32_t int32;\ntypedef uint32_t osal_id_t;\n\ntypedef struct\n{\n    int id;\n} OS_object_token_t;\n\n/* The internal task record: only the delete_hook_pointer field is used in OS_TaskDelete. */\ntypedef void (*osal_task_entry)(void);\n\ntypedef struct\n{\n    osal_task_entry delete_hook_pointer;\n    int some_other_field;\n} OS_task_internal_record_t;\n\n/* A small task table with one entry for testing. */\nstatic OS_task_internal_record_t OS_task_table[1] = { { NULL, 0 } };\n\n/* Return codes used in the real system (minimal subset). */\nenum\n{\n    OS_SUCCESS = 0,\n    OS_ERROR = -1\n};\n\n/* Minimal constants to match the signature in the target code. */\nstatic const int OS_LOCK_MODE_EXCLUSIVE = 1;\nstatic const int LOCAL_OBJID_TYPE = 1;\n\n/* Stubs for OSAL functions used by OS_TaskDelete. These are simplified and return success. */\nstatic int32 OS_ObjectIdGetById(int lock_mode, int objtype, osal_id_t id, OS_object_token_t *token)\n{\n    (void)lock_mode;\n    (void)objtype;\n    if (token == NULL)\n    {\n        return OS_ERROR;\n    }\n    token->id = (int)(id % 1); /* map any id to the single table entry */\n    return OS_SUCCESS;\n}\n\n/* Replace the macro-like access with a function to keep the test file self-contained. */\nstatic OS_task_internal_record_t *OS_OBJECT_TABLE_GET(OS_task_internal_record_t *table, OS_object_token_t token)\n{\n    (void)table;\n    /* token.id indexes into our one-element table */\n    return &OS_task_table[token.id];\n}\n\nstatic int32 OS_TaskDelete_Impl(OS_object_token_t *token)\n{\n    (void)token;\n    /* In the real implementation some deletion happens. Return success for testing. */\n    return OS_SUCCESS;\n}\n\nstatic int32 OS_ObjectIdFinalizeDelete(int32 return_code, OS_object_token_t *token)\n{\n    (void)token;\n    /* Finalization step; just return whatever code was provided. */\n    return return_code;\n}\n\n/* Logging helpers: write human-readable probes to /tmp/logs/2035.txt */\nstatic void ensure_log_dir(void)\n{\n    /* Create /tmp/logs if it does not exist. Ignore errors if it already exists. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n}\n\nstatic void probe_log(const char *fmt, ...)\n{\n    ensure_log_dir();\n    FILE *f = fopen(\"/tmp/logs/2035.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* The target function with inserted probes for control flow and state. */\nint32 OS_TaskDelete(osal_id_t task_id)\n{\n    int32                      return_code;\n    OS_object_token_t          token;\n    OS_task_internal_record_t *task; /* NOTE: intentionally non-const in original code */\n    osal_task_entry            delete_hook;\n\n    /* Probe: function entry and parameter */\n    probe_log(\"OS_TaskDelete ENTER: task_id=%"
}