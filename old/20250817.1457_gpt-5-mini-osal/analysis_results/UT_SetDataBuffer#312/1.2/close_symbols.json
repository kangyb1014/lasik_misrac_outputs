{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "UT_StubTableEntry_t.Data / .Buff / BasePtr / TotalSize / Position / ModeFlags members",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF",
    "size_t",
    "bool",
    "malloc",
    "memcpy"
  ],
  "explanation": "For checking whether the target function uses any compiler language extensions you must inspect the definitions referenced by the function (typedefs, structs, macros and external APIs) because extensions can be hidden there. Specific needs: \n\n- UT_StubTableEntry_t\n  - The full struct/typedef must be inspected for any compiler extensions (e.g. __attribute__ annotations, bit-field widths using implementation-specific behavior, flexible array members, anonymous unions/structs, packed/aligned pragmas, or other non-standard constructs).\n\n- UT_EntryKey_t\n  - The underlying typedef could use an extension (compiler-specific integer types, attributes, or non-standard keywords). Verify its declaration.\n\n- UT_StubTableEntry_t.Data / .Buff / BasePtr / TotalSize / Position / ModeFlags members\n  - The types of these members (pointer types, unions, nested anonymous structs, bitfields, or attributes on members) can introduce extensions. Need the exact member declarations to be sure none use non-standard language features.\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER\n  - Macros or enum definitions may use compiler extensions (e.g. non-standard enum sizes, extension macros, or gcc-specific token-pasting tricks). Inspect their definitions.\n\n- UT_MODEFLAG_ALLOC_BUF\n  - A macro/constant that could be defined with extension syntax; check its definition.\n\n- size_t\n  - Confirmed from standard headers, but its underlying typedef could be platform-specific; check that no extension keyword is used in its definition on this platform.\n\n- bool\n  - Verify whether this comes from stdbool.h or is a custom typedef/extension; custom implementations or macros could use extensions.\n\n- malloc\n  - The declaration in the platform headers may carry attributes (e.g. __malloc__ or __attribute__((malloc))) or non-standard prototypes; inspect to ensure no compiler-specific extension is relied upon.\n\n- memcpy\n  - Same reasoning as malloc: library prototype or macros could use extensions or builtin intrinsics; check its declaration/implementation if relevant.\n\n(UT_GetStubEntry and UtAssert_Abort are already in the static call graph; they must be examined too but were not requested as \"additional\" symbols here.)"
}