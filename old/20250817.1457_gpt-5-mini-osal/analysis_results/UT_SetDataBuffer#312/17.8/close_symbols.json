{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UT_StubTableEntry_t",
    "UT_EntryKey_t",
    "malloc",
    "memcpy",
    "UtAssert_Abort"
  ],
  "explanation": "Why each symbol is required to check the MISRA rule (a parameter shall not be modified):\n\n- UT_GetStubEntry\n  - Must examine its definition (function vs macro and its body/expansion). If it is a macro it could expand to code that assigns to its first argument token (the expression passed is the local parameter FuncKey), which would violate the MISRA rule if the macro writes to that argument. If it is a function, confirm it does not take the address of FuncKey or otherwise cause FuncKey to be modified via side effects.\n\n- UT_StubTableEntry_t\n  - Need the struct/union layout (fields: FuncKey, EntryType, Data.Buff.BasePtr, ModeFlags, Data.Buff.TotalSize, Data.Buff.Position, etc.) to reason about whether writes such as StubPtr->FuncKey = FuncKey or StubPtr->Data.Buff.BasePtr = DataBuffer could in fact alias the function parameters (e.g. if FuncKey or DataBuffer somehow refer to the same storage) or otherwise create an indirect write-through to a parameter. Also to confirm that assignments target stub storage and not the parameter object itself.\n\n- UT_EntryKey_t\n  - The typedef of FuncKey is needed to know its underlying type (scalar, pointer, struct, array). If it is a reference type (pointer) or an alias to some special storage, an assignment or pass-by-reference could effectively modify the caller's object; verify that the code does not modify the FuncKey parameter variable itself.\n\n- malloc\n  - Confirm malloc is the standard function (not a macro wrapper) and does not expand to code that could assign to any of the UT_SetDataBuffer parameters. Also confirm its prototype so any casts/assignments are well understood (ensures that assigning its return to StubPtr->Data.Buff.BasePtr cannot modify the DataBuffer parameter).\n\n- memcpy\n  - Confirm memcpy is the standard library function (or wrapper) and does not modify the DataBuffer pointer parameter itself (it copies to the destination buffer; ensure there is no macro that could assign to the source pointer token). This rules out hidden macro side-effects that could modify DataBuffer or BufferSize.\n\n- UtAssert_Abort\n  - Need its definition (function or macro). If it is a macro, its expansion could reference identifiers in the caller and potentially perform assignments; ensure the call site cannot cause modification of any of UT_SetDataBuffer's parameters (even though it is called with a string literal, a pathological macro could capture other identifiers)."
}