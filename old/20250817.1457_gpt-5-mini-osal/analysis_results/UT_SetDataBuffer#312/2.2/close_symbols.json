{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_GetStubEntry",
    "UtAssert_Abort",
    "UT_StubTableEntry_t",
    "UT_ENTRYTYPE_UNUSED",
    "UT_ENTRYTYPE_DATA_BUFFER",
    "UT_MODEFLAG_ALLOC_BUF",
    "UT stub table (pool) / UT_MAX_FUNC_STUBS",
    "malloc",
    "memcpy",
    "UT_DefaultHandler_OS_QueuePut",
    "UT_Hook_GetArgPtr",
    "size_t",
    "bool"
  ],
  "explanation": "For determining whether any statements in UT_SetDataBuffer are dead code you must know which branches and side-effects are actually reachable and which calls never return or never occur.  Each symbol is required for the following reasons:\n\n- UT_GetStubEntry: Determines whether the StubPtr==NULL branch can occur. If this function never returns NULL for the given FuncKey/entry type then the UtAssert_Abort() branch (and its surrounding code path) would be dead; if it can return NULL then that branch is live.\n\n- UtAssert_Abort: You must know its behavior (noreturn vs returns) and side effects. If it does not return, statements after the call in that branch are irrelevant; if it returns, the branch has different reachability implications.\n\n- UT_StubTableEntry_t: The concrete structure definition (fields FuncKey, EntryType, ModeFlags, Data.Buff.BasePtr, Data.Buff.TotalSize, Data.Buff.Position) is needed to see whether assigned fields are ever read elsewhere. Assignments that do not affect program behaviour are candidates for dead code.\n\n- UT_ENTRYTYPE_UNUSED and UT_ENTRYTYPE_DATA_BUFFER: The meaning/values of these constants determine UT_GetStubEntry semantics and whether the EntryType assignment is meaningful or redundant for later logic.\n\n- UT_MODEFLAG_ALLOC_BUF: Needed to interpret the bitwise update (ModeFlags |= UT_MODEFLAG_ALLOC_BUF) to determine whether that write has observable effect elsewhere (i.e., whether that flag is ever tested), otherwise it could be dead.\n\n- UT stub table (pool) / UT_MAX_FUNC_STUBS: The global storage and size limit used by UT_GetStubEntry determine whether StubPtr can be NULL in normal configuration. If the table capacity guarantees a non-NULL return for the FuncKey set of callers, the NULL-check and abort-path may be dead.\n\n- malloc: To decide if the AllocateCopy branch is live and has effects, you need malloc behaviour and whether it can fail in the target environment (affects whether the UtAssert_Abort on malloc failure is reachable).\n\n- memcpy: The copy operation is a side effect; you must know whether callers ever rely on the copied buffer (if not, the copy could be dead). Also, its presence affects whether the AllocateCopy branch has observable effects.\n\n- UT_DefaultHandler_OS_QueuePut: This is the known (static) caller of UT_SetDataBuffer \u2014 examine its callsite to determine the ranges/values of DataBuffer, BufferSize and AllocateCopy that reach UT_SetDataBuffer. If the caller always passes DataBuffer==NULL or BufferSize==0 (or a constant AllocateCopy), parts of UT_SetDataBuffer may be unreachable/unused and therefore dead.\n\n- UT_Hook_GetArgPtr: This helper is used by the caller to obtain buffer arguments; its semantics determine whether DataBuffer passed into UT_SetDataBuffer can ever be non-NULL and whether BufferSize can be >0.\n\n- size_t and bool: The effective ranges and representation (e.g., zero vs non-zero, signedness) are needed to reason about the BufferSize>0 test and AllocateCopy boolean test in the context of caller-provided values.\n\nIn short: to decide whether any assignment, branch or call inside UT_SetDataBuffer is dead you must inspect: how callers invoke it (UT_DefaultHandler_OS_QueuePut and helpers), whether UT_GetStubEntry can return NULL (and why), whether UtAssert_Abort stops execution, and whether writes/allocations/copies to the UT_StubTableEntry_t fields are observable elsewhere (structure layout, flags, and global stub-table capacity)."
}