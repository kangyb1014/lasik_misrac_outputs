{
  "user_message": "Target function code is:\n```c\nvoid UT_SetDataBuffer(UT_EntryKey_t FuncKey, void *DataBuffer, size_t BufferSize, bool AllocateCopy)\n{\n    UT_StubTableEntry_t *StubPtr;\n\n    if (DataBuffer != NULL && BufferSize > 0)\n    {\n        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);\n\n        if (StubPtr == NULL)\n        {\n            UtAssert_Abort(\"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\");\n        }\n        else\n        {\n            StubPtr->FuncKey   = FuncKey;\n            StubPtr->EntryType = UT_ENTRYTYPE_DATA_BUFFER;\n            if (AllocateCopy)\n            {\n                StubPtr->Data.Buff.BasePtr = malloc(BufferSize);\n                if (StubPtr->Data.Buff.BasePtr == NULL)\n                {\n                    UtAssert_Abort(\"Cannot allocate data buffer - malloc() failed!\");\n                }\n                else\n                {\n                    memcpy(StubPtr->Data.Buff.BasePtr, DataBuffer, BufferSize);\n                    StubPtr->ModeFlags |= UT_MODEFLAG_ALLOC_BUF;\n                }\n            }\n            else\n            {\n                /* Use buffer directly */\n                StubPtr->Data.Buff.BasePtr = DataBuffer;\n            }\n            StubPtr->Data.Buff.TotalSize = BufferSize;\n            StubPtr->Data.Buff.Position  = 0;\n        }\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'UT_SetDataBuffer': {'callees': ['UT_GetStubEntry', 'UtAssert_Abort'], 'callers': ['UT_DefaultHandler_OS_QueuePut']}, 'UT_GetStubEntry': {'callees': [], 'callers': ['UT_ConfigureGenericStubReturnValue', 'UT_ClearDeferredRetcode', 'UT_ClearDefaultReturnValue', 'UT_GetStubRetcodeAndCount', 'UT_GetStubCount', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_GetDataBuffer', 'UT_Stub_CopyToLocal', 'UT_Stub_CopyFromLocal', 'UT_DoSetHookFunction', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_Stub_FindRetvalConfig', 'UT_DefaultStubImplWithArgs', 'UT_ExecuteBasicHandler', 'UT_ExecuteVaHandler']}, 'UtAssert_Abort': {'callees': ['UT_BSP_DoText'], 'callers': ['UT_Stub_CallOnce', 'UT_ConfigureGenericStubReturnValue', 'UT_Stub_RegisterReturnType', 'UT_Stub_GetReturnValuePtr', 'UT_SetDataBuffer', 'UT_DoSetHookFunction', 'UT_Hook_GetArgPtr', 'UT_Stub_RegisterContextWithMetaData', 'UT_Stub_CopyToReturnValue', 'UT_DefaultStubImplWithArgs', 'UT_AllocStubObjId']}, 'UT_DefaultHandler_OS_QueuePut': {'callees': ['UT_Hook_GetArgPtr', 'UT_SetDataBuffer', 'OS_ObjectIdToInteger'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UT_StubTableEntry_t",
    "UT_GetStubEntry",
    "UT_GetDataBuffer",
    "UT_Stub_CopyFromLocal",
    "UT_Stub_CopyToLocal",
    "UT_Stub_CopyToReturnValue",
    "UT_EntryKey_t",
    "memcpy",
    "malloc"
  ],
  "explanation": "Brief rationale for each symbol (why it is needed to judge the MISRA rule about pointer-to-const):\n\n- UT_StubTableEntry_t: The struct definition (particularly the nested .Data.Buff.BasePtr field type) is essential to know whether BasePtr is declared as void * or const void * (or another qualified pointer). If BasePtr is non-const and other code writes through it, that prevents making DataBuffer const in UT_SetDataBuffer.\n\n- UT_GetStubEntry: Prototype/definition is needed to verify the exact return type (UT_StubTableEntry_t * vs const-qualified) and any expectations about mutability of the returned stub entry. It also helps determine whether callers expect to mutate the entry or its buffer.\n\n- UT_GetDataBuffer: This function (whose implementation/usage of the stub buffer must be inspected) may read from or write to the buffer stored in StubPtr->Data.Buff.BasePtr. If it writes into the buffer, DataBuffer cannot safely be const.\n\n- UT_Stub_CopyFromLocal: The name implies copying data from a local source into the stub buffer; its implementation must be checked to see whether it writes into BasePtr. If it writes, BasePtr cannot be const and therefore UT_SetDataBuffer cannot accept a const pointer.\n\n- UT_Stub_CopyToLocal: Similarly, this may read from the stub buffer and/or write to a destination; knowing whether it mutates BasePtr contents is required to decide if BasePtr (and DataBuffer) can be const-qualified.\n\n- UT_Stub_CopyToReturnValue: This function commonly reads from the stub buffer to supply return values; its behavior clarifies whether the buffer is treated read-only or writable by other framework code.\n\n- UT_EntryKey_t: The type of FuncKey is not directly the pointer under question, but its definition is needed for full type-context of the API and to ensure no conversions/overloads affect pointer qualification decisions.\n\n- memcpy: The prototype shows that memcpy takes a const void *src; knowing that memcpy expects a const source confirms that passing a const DataBuffer to memcpy is permitted. This supports changing DataBuffer to const if no other usage prevents it.\n\n- malloc: Prototype/semantics are needed to confirm malloc returns void * and that assigning malloc(BufferSize) to BasePtr is valid; if BasePtr were const-qualified this assignment would be incompatible. This influences whether BasePtr (and thus DataBuffer) can be const.\n\nIn short: the struct field type for BasePtr and all other functions that access or mutate that buffer are required to determine whether the buffer is ever modified elsewhere; if it is never modified, DataBuffer should be const (per MISRA), otherwise it must remain non-const."
}