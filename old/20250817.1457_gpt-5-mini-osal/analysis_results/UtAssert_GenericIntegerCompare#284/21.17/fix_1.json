{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void UtAssert_LogProbe(const char *stage, const char *File, uint32_t Line, const char *ActualText,\n                              const char *RefText, size_t PrefixLen, int CmpResult)\n{\n    FILE *fp = fopen(\"/tmp/logs/2279.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Do not dereference ActualText or RefText here to avoid introducing new undefined behavior.\n     * Only log pointer values and context so an external observer can reproduce the conditions.\n     */\n    fprintf(fp, \"Stage: %s\\n\", stage);\n    fprintf(fp, \"  Source: %s:%u\\n\", (File != NULL) ? File : \"(null)\", (unsigned int)Line);\n    fprintf(fp, \"  ActualText ptr: %p\\n\", (const void *)ActualText);\n    fprintf(fp, \"  RefText    ptr: %p\\n\", (const void *)RefText);\n    fprintf(fp, \"  PrefixLen: %zu\\n\", PrefixLen);\n\n    if (CmpResult != INT_MAX)\n    {\n        fprintf(fp, \"  strncmp result: %d\\n\", CmpResult);\n    }\n    fprintf(fp, \"----\\n\");\n    fclose(fp);\n}\n\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* Probe: log state before attempting to strip UTASSERT_ prefix from texts.\n     * We only log pointer values and contextual information so we don't introduce new dereferences.\n     */\n    UtAssert_LogProbe(\"before_prefix_strip\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, INT_MAX);\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    {\n        int cmp;\n\n        cmp = strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1);\n        UtAssert_LogProbe(\"after_actual_strncmp\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, cmp);\n        if (cmp == 0)\n        {\n            ActualText += sizeof(UTASSERT_PREFIX) - 1;\n        }\n    }\n\n    {\n        int cmp;\n\n        cmp = strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1);\n        UtAssert_LogProbe(\"after_ref_strncmp\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, cmp);\n        if (cmp == 0)\n        {\n            RefText += sizeof(UTASSERT_PREFIX) - 1;\n        }\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c: In function 'UtAssert_LogProbe':\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c:530:22: error: 'INT_MAX' undeclared (first use in this function)\n  530 |     if (CmpResult != INT_MAX)\n      |                      ^~~~~~~\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c:45:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n   44 | #include \"utbsp.h\"\n  +++ |+#include <limits.h>\n   45 | \n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c:530:22: note: each undeclared identifier is reported only once for each function it appears in\n  530 |     if (CmpResult != INT_MAX)\n      |                      ^~~~~~~\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c: In function 'UtAssert_GenericIntegerCompare':\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c:595:108: error: 'INT_MAX' undeclared (first use in this function)\n  595 |     UtAssert_LogProbe(\"before_prefix_strip\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, INT_MAX);\n      |                                                                                                            ^~~~~~~\n/tmp/tmpg5y_bgvh/src/ut_assert/src/utassert.c:595:108: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\ngmake[2]: *** [ut_assert/CMakeFiles/ut_assert.dir/build.make:76: ut_assert/CMakeFiles/ut_assert.dir/src/utassert.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:788: ut_assert/CMakeFiles/ut_assert.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of UtAssert_GenericIntegerCompare as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <limits.h>\n\nstatic void UtAssert_LogProbe(const char *stage, const char *File, uint32_t Line, const char *ActualText,\n                              const char *RefText, size_t PrefixLen, int CmpResult)\n{\n    FILE *fp = fopen(\"/tmp/logs/2279.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    /* Do not dereference ActualText or RefText here to avoid introducing new undefined behavior.\n     * Only log pointer values and context so an external observer can reproduce the conditions.\n     */\n    fprintf(fp, \"Stage: %s\\n\", stage);\n    fprintf(fp, \"  Source: %s:%u\\n\", (File != NULL) ? File : \"(null)\", (unsigned int)Line);\n    fprintf(fp, \"  ActualText ptr: %p\\n\", (const void *)ActualText);\n    fprintf(fp, \"  RefText    ptr: %p\\n\", (const void *)RefText);\n    fprintf(fp, \"  PrefixLen: %zu\\n\", PrefixLen);\n\n    if (CmpResult != INT_MAX)\n    {\n        fprintf(fp, \"  strncmp result: %d\\n\", CmpResult);\n    }\n    fprintf(fp, \"----\\n\");\n    fclose(fp);\n}\n\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* Probe: log state before attempting to strip UTASSERT_ prefix from texts.\n     * We only log pointer values and contextual information so we don't introduce new dereferences.\n     */\n    UtAssert_LogProbe(\"before_prefix_strip\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, INT_MAX);\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    {\n        int cmp;\n\n        cmp = strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1);\n        UtAssert_LogProbe(\"after_actual_strncmp\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, cmp);\n        if (cmp == 0)\n        {\n            ActualText += sizeof(UTASSERT_PREFIX) - 1;\n        }\n    }\n\n    {\n        int cmp;\n\n        cmp = strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1);\n        UtAssert_LogProbe(\"after_ref_strncmp\", File, Line, ActualText, RefText, sizeof(UTASSERT_PREFIX) - 1, cmp);\n        if (cmp == 0)\n        {\n            RefText += sizeof(UTASSERT_PREFIX) - 1;\n        }\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n",
  "explanation": "The build error was caused by use of INT_MAX without including <limits.h>. I added #include <limits.h> at the top of the file so INT_MAX is defined. No other logic or identifiers were changed."
}