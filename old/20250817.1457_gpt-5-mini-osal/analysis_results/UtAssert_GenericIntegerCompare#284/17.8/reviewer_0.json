{
  "user_message": "An agent A claimed that the following UtAssert_GenericIntegerCompare code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of UtAssert_GenericIntegerCompare.\n```c\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* If the radix type was not specified, then check if the typename appears to be a pointer -\n     * That is, it contains an asterisk.  This is far from foolproof due to typedefs etc but\n     * it should catch most of them (note that \"hiding\" a pointer via typedef is discouraged by\n     * GSFC coding standards, so this shouldn't be too likely)\n     */\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            RadixType = UtAssert_Radix_HEX;\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    if (strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        ActualText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n    if (strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        RefText += sizeof(UTASSERT_PREFIX) - 1;\n    }\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned), UTASSERT_CASETYPE_FAILURE,\n                      File, Line, \"%s%s (%s) %s %s (%s)\", TagStr, ActualText,\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), RefText,\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code assigns to the parameter RadixType (RadixType = UtAssert_Radix_HEX;) when RadixType == UtAssert_Radix_DEFAULT and Typename contains '*'. This modifies a non-pointer function parameter inside the function, which violates MISRA C 2023 Rule 17.8 (parameters shall not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef unsigned int uint32;\ntypedef ptrdiff_t UT_IntCheck_t;\ntypedef enum {\n    UtAssert_Radix_DEFAULT = 0,\n    UtAssert_Radix_HEX = 16 /* match header choice: HEX is base 16 */\n} UtAssert_Radix_t;\ntypedef enum {\n    UtAssert_Compare_EQ = 0\n} UtAssert_Compare_t;\nstatic const int UTASSERT_CASETYPE_FAILURE = 1;\nstatic void UtAssert_Logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/2277.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(f, fmt, args);\n    va_end(args);\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nbool UtAssert_GenericIntegerCompare(bool IsUnsigned, UT_IntCheck_t ActualValue, UtAssert_Compare_t CompareType,\n                                    UT_IntCheck_t RefValue, const char *File, uint32 Line, UtAssert_Radix_t RadixType,\n                                    const char *Typename, const char *ActualText, const char *RefText)\n{\n    static const char UTASSERT_PREFIX[] = \"UTASSERT_\";\n\n    char ActualStr[32];\n    char RefStr[32];\n    char TagStr[32];\n    int  TagLen;\n\n    /* Log entry state */\n    UtAssert_Logf(\"ENTER: IsUnsigned=%d, ActualValue=%td, CompareType=%d, RefValue=%td, File=%s, Line=%u, RadixType=%d, Typename=%s, ActualText=%s, RefText=%s\",\n                  (int)IsUnsigned, (ptrdiff_t)ActualValue, (int)CompareType, (ptrdiff_t)RefValue,\n                  (File != NULL ? File : \"(null)\"), (unsigned)Line, (int)RadixType,\n                  (Typename != NULL ? Typename : \"(null)\"), (ActualText != NULL ? ActualText : \"(null)\"), (RefText != NULL ? RefText : \"(null)\"));\n\n    if (Typename != NULL && *Typename != 0)\n    {\n        TagLen = snprintf(TagStr, sizeof(TagStr), \"%s\", Typename);\n        if (TagLen < 0)\n        {\n            TagLen = 0;\n        }\n        else if (TagLen > (sizeof(TagStr) - 3))\n        {\n            TagLen = sizeof(TagStr) - 3;\n        }\n\n        while (TagLen > 0 && (isspace((unsigned char)TagStr[TagLen - 1]) || TagStr[TagLen - 1] == ':'))\n        {\n            --TagLen;\n        }\n\n        if (TagLen > 0)\n        {\n            TagStr[TagLen] = ':';\n            ++TagLen;\n            TagStr[TagLen] = ' ';\n            ++TagLen;\n        }\n\n        TagStr[TagLen] = 0;\n\n        /* Log TagStr and TagLen after trimming */\n        UtAssert_Logf(\"TAG_STATE: TagStr=\\\"%s\\\", TagLen=%d\", TagStr, TagLen);\n\n        if (RadixType == UtAssert_Radix_DEFAULT && strchr(Typename, '*') != NULL)\n        {\n            /* looks like a pointer type */\n            UtAssert_Logf(\"RADIX_DECISION: Typename contains '*', RadixType before=%d\", (int)RadixType);\n            RadixType = UtAssert_Radix_HEX;\n            UtAssert_Logf(\"RADIX_DECISION: RadixType after=%d\", (int)RadixType);\n        }\n    }\n    else\n    {\n        TagStr[0] = 0;\n    }\n\n    /* If either the actual text or the ref text starts with the \"UTASSERT_\" prefix, then strip it */\n    if (ActualText != NULL && strncmp(ActualText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        ActualText += sizeof(UTASSERT_PREFIX) - 1;\n        UtAssert_Logf(\"STRIP_PREFIX: ActualText now=\\\"%s\\\"\", ActualText);\n    }\n    if (RefText != NULL && strncmp(RefText, UTASSERT_PREFIX, sizeof(UTASSERT_PREFIX) - 1) == 0)\n    {\n        RefText += sizeof(UTASSERT_PREFIX) - 1;\n        UtAssert_Logf(\"STRIP_PREFIX: RefText now=\\\"%s\\\"\", RefText);\n    }\n\n    /* Log final values used for printing */\n    UtAssert_Logf(\"FINAL: Using RadixType=%d, TagStr=\\\"%s\\\", ActualText=\\\"%s\\\", RefText=\\\"%s\\\"\",\n                  (int)RadixType, TagStr, (ActualText != NULL ? ActualText : \"(null)\"), (RefText != NULL ? RefText : \"(null)\"));\n\n    return UtAssertEx(UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned),\n                      UTASSERT_CASETYPE_FAILURE,\n                      File, Line,\n                      \"%s%s (%s) %s %s (%s)\", TagStr, (ActualText != NULL ? ActualText : \"(null)\"),\n                      UtAssert_GetValueText(ActualStr, sizeof(ActualStr), ActualValue, IsUnsigned, RadixType),\n                      UtAssert_GetOpText(CompareType), (RefText != NULL ? RefText : \"(null)\"),\n                      UtAssert_GetValueText(RefStr, sizeof(RefStr), RefValue, IsUnsigned, RadixType));\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters (the pointer object pointed-to may be modified, but the pointer itself shall not be). In the original code RadixType (a non-pointer parameter) is assigned to: RadixType = UtAssert_Radix_HEX; which modifies a parameter and thus violates 17.8. Additionally, the code also modifies pointer parameters by adjusting them: ActualText += sizeof(UTASSERT_PREFIX) - 1; and RefText += sizeof(UTASSERT_PREFIX) - 1; \u2014 these reassignments change the pointer parameters themselves and likewise contravene Rule 17.8. To conform, the function should use local copies (e.g. a local Radix variable and local pointer variables for ActualText/RefText) and leave the incoming parameters unmodified."
}