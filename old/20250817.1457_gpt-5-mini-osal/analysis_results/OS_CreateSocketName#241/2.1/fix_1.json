{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void os_log_append(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s\", msg);\n        fclose(f);\n    }\n}\nextern int OS_SocketAddrToString_Impl(char *str, size_t size, const void *Addr);\nextern int OS_SocketAddrGetPort_Impl(uint16_t *port, const void *Addr);\nstatic int probe_OS_SocketAddrToString_Impl(char *str, size_t size, const void *Addr)\n{\n    int rv = OS_SocketAddrToString_Impl(str, size, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrToString_Impl called: Addr=%p, size=%zu -> return=%d\\n\",\n                (void *)Addr, size, rv);\n        if (str && size > 0)\n        {\n            /* Limit the printed string length to avoid overly large logs. */\n            char buf[256];\n            size_t copy_len = (size_t) (sizeof(buf) - 1);\n            if (strnlen(str, copy_len) < copy_len)\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            else\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            fprintf(f, \"[probe]   result string (truncated) = '%s'\\n\", buf);\n        }\n        if (rv == /* OS_ERR_BAD_ADDRESS */ -1) /* placeholder check if constant not available */\n        {\n            /* If the real symbol OS_ERR_BAD_ADDRESS is available at link time, the\n             * constant will be used below by the duplicated check. We still keep\n             * a generic message here. */\n            fprintf(f, \"[probe]   Detected error return value (possible bad address).\\n\");\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\nstatic int probe_OS_SocketAddrGetPort_Impl(uint16_t *port, const void *Addr)\n{\n    int rv = OS_SocketAddrGetPort_Impl(port, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrGetPort_Impl called: Addr=%p -> return=%d\", (void *)Addr, rv);\n        if (rv == 0) /* assume OS_SUCCESS == 0 if symbol not available */\n        {\n            fprintf(f, \", port=%u\", (unsigned int)(port ? *port : 0));\n        }\n        else\n        {\n            fprintf(f, \" (non-success return)\");\n        }\n        fprintf(f, \"\\n\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\n\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    /* Log entry with token and address pointer */\n    {\n        char tmp[256];\n        snprintf(tmp, sizeof(tmp), \"[probe] Enter OS_CreateSocketName: token=%p, Addr=%p, parent_name=%p\\n\",\n                 (const void *)token, (const void *)Addr, (const void *)parent_name);\n        os_log_append(tmp);\n    }\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (probe_OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n        os_log_append(\"[probe] OS_SocketAddrToString_Impl failed -> cleared stream_name[0]\\n\");\n    }\n    if (probe_OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n        /* Log appended port and resulting name so callers can see the path taken. */\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended port :%u -> stream_name='%s'\\n\", (unsigned int)port, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended parent name '-%s' -> stream_name='%s'\\n\", parent_name, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    /* Final state log */\n    {\n        char tmp[512];\n        snprintf(tmp, sizeof(tmp), \"[probe] Exit OS_CreateSocketName: final stream_name='%s'\\n\\n\", sock->stream_name);\n        os_log_append(tmp);\n    }\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp7b8573kv/src/src/os/shared/src/osapi-sockets.c:105:12: error: conflicting types for 'OS_SocketAddrToString_Impl'; have 'int(char *, size_t,  const void *)' {aka 'int(char *, long unsigned int,  const void *)'}\n  105 | extern int OS_SocketAddrToString_Impl(char *str, size_t size, const void *Addr);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmp7b8573kv/src/src/os/shared/src/osapi-sockets.c:51:\n/tmp/tmp7b8573kv/src/src/os/shared/inc/os-shared-sockets.h:144:7: note: previous declaration of 'OS_SocketAddrToString_Impl' with type 'int32(char *, size_t,  const OS_SockAddr_t *)' {aka 'int(char *, long unsigned int,  const OS_SockAddr_t *)'}\n  144 | int32 OS_SocketAddrToString_Impl(char *buffer, size_t buflen, const OS_SockAddr_t *Addr);\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7b8573kv/src/src/os/shared/src/osapi-sockets.c:106:12: error: conflicting types for 'OS_SocketAddrGetPort_Impl'; have 'int(uint16_t *, const void *)' {aka 'int(short unsigned int *, const void *)'}\n  106 | extern int OS_SocketAddrGetPort_Impl(uint16_t *port, const void *Addr);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /tmp/tmp7b8573kv/src/src/os/shared/src/osapi-sockets.c:51:\n/tmp/tmp7b8573kv/src/src/os/shared/inc/os-shared-sockets.h:164:7: note: previous declaration of 'OS_SocketAddrGetPort_Impl' with type 'int32(uint16 *, const OS_SockAddr_t *)' {aka 'int(short unsigned int *, const OS_SockAddr_t *)'}\n  164 | int32 OS_SocketAddrGetPort_Impl(uint16 *PortNum, const OS_SockAddr_t *Addr);\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:328: CMakeFiles/osal.dir/src/os/shared/src/osapi-sockets.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CreateSocketName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void os_log_append(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s\", msg);\n        fclose(f);\n    }\n}\n\nstatic int probe_OS_SocketAddrToString_Impl(char *str, size_t size, const OS_SockAddr_t *Addr)\n{\n    int rv = OS_SocketAddrToString_Impl(str, size, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrToString_Impl called: Addr=%p, size=%zu -> return=%d\\n\",\n                (void *)Addr, size, rv);\n        if (str && size > 0)\n        {\n            /* Limit the printed string length to avoid overly large logs. */\n            char buf[256];\n            size_t copy_len = (size_t) (sizeof(buf) - 1);\n            if (strnlen(str, copy_len) < copy_len)\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            else\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            fprintf(f, \"[probe]   result string (truncated) = '%s'\\n\", buf);\n        }\n        if (rv == /* OS_ERR_BAD_ADDRESS */ -1) /* placeholder check if constant not available */\n        {\n            /* If the real symbol OS_ERR_BAD_ADDRESS is available at link time, the\n             * constant will be used below by the duplicated check. We still keep\n             * a generic message here. */\n            fprintf(f, \"[probe]   Detected error return value (possible bad address).\\n\");\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\nstatic int probe_OS_SocketAddrGetPort_Impl(uint16 *port, const OS_SockAddr_t *Addr)\n{\n    int rv = OS_SocketAddrGetPort_Impl(port, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrGetPort_Impl called: Addr=%p -> return=%d\", (void *)Addr, rv);\n        if (rv == 0) /* assume OS_SUCCESS == 0 if symbol not available */\n        {\n            fprintf(f, \", port=%u\", (unsigned int)(port ? *port : 0));\n        }\n        else\n        {\n            fprintf(f, \" (non-success return)\");\n        }\n        fprintf(f, \"\\n\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\n\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    /* Log entry with token and address pointer */\n    {\n        char tmp[256];\n        snprintf(tmp, sizeof(tmp), \"[probe] Enter OS_CreateSocketName: token=%p, Addr=%p, parent_name=%p\\n\",\n                 (const void *)token, (const void *)Addr, (const void *)parent_name);\n        os_log_append(tmp);\n    }\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (probe_OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n        os_log_append(\"[probe] OS_SocketAddrToString_Impl failed -> cleared stream_name[0]\\n\");\n    }\n    if (probe_OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n        /* Log appended port and resulting name so callers can see the path taken. */\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended port :%u -> stream_name='%s'\\n\", (unsigned int)port, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended parent name '-%s' -> stream_name='%s'\\n\", parent_name, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    /* Final state log */\n    {\n        char tmp[512];\n        snprintf(tmp, sizeof(tmp), \"[probe] Exit OS_CreateSocketName: final stream_name='%s'\\n\\n\", sock->stream_name);\n        os_log_append(tmp);\n    }\n}\n",
  "explanation": "I removed the duplicate extern declarations that conflicted with the project's header declarations and adjusted the probe function parameter types to match the already-declared signatures in the included header (using const OS_SockAddr_t * for the address and uint16 for the port). This avoids the conflicting prototype errors while preserving the original logic of OS_CreateSocketName and the probing/logging behavior."
}