{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nIn the switch statement default case (in both OS_SocketAddrToString_Impl and OS_SocketAddrGetPort_Impl) the code has 'return OS_ERR_BAD_ADDRESS;' followed by 'break;'. The 'break;' is unreachable because control returns before it, which constitutes unreachable code.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CreateSocketName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1929.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CreateSocketName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CreateSocketName:\n```c\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n    }\n    if (OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n    }\n}\n```\n</target_code>\nPlease provide the modified OS_CreateSocketName code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Probe wrappers and logging helpers for capturing control flow/state\n * related to socket address conversion and port extraction.\n * These wrappers preserve the original logic by calling the existing\n * implementation functions, but log inputs/outputs to /tmp/logs/1929.txt\n * so other agents can reproduce evidence for the reported violation.\n */\n\nstatic void os_log_append(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s\", msg);\n        fclose(f);\n    }\n}\n\n/* Forward declarations of existing symbols (provided by the build).\n * We do not define these functions here; we merely call them.\n */\nextern int OS_SocketAddrToString_Impl(char *str, size_t size, const void *Addr);\nextern int OS_SocketAddrGetPort_Impl(uint16_t *port, const void *Addr);\n\n/* Probe wrappers that call the real implementations and log the\n * control flow and state to /tmp/logs/1929.txt. They return the\n * exact return values from the real implementations so original\n * logic is preserved.\n */\nstatic int probe_OS_SocketAddrToString_Impl(char *str, size_t size, const void *Addr)\n{\n    int rv = OS_SocketAddrToString_Impl(str, size, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrToString_Impl called: Addr=%p, size=%zu -> return=%d\\n\",\n                (void *)Addr, size, rv);\n        if (str && size > 0)\n        {\n            /* Limit the printed string length to avoid overly large logs. */\n            char buf[256];\n            size_t copy_len = (size_t) (sizeof(buf) - 1);\n            if (strnlen(str, copy_len) < copy_len)\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            else\n            {\n                strncpy(buf, str, copy_len);\n                buf[copy_len] = '\\0';\n            }\n            fprintf(f, \"[probe]   result string (truncated) = '%s'\\n\", buf);\n        }\n        if (rv == /* OS_ERR_BAD_ADDRESS */ -1) /* placeholder check if constant not available */\n        {\n            /* If the real symbol OS_ERR_BAD_ADDRESS is available at link time, the\n             * constant will be used below by the duplicated check. We still keep\n             * a generic message here. */\n            fprintf(f, \"[probe]   Detected error return value (possible bad address).\\n\");\n        }\n        fprintf(f, \"\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\n\nstatic int probe_OS_SocketAddrGetPort_Impl(uint16_t *port, const void *Addr)\n{\n    int rv = OS_SocketAddrGetPort_Impl(port, Addr);\n\n    FILE *f = fopen(\"/tmp/logs/1929.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"[probe] OS_SocketAddrGetPort_Impl called: Addr=%p -> return=%d\", (void *)Addr, rv);\n        if (rv == 0) /* assume OS_SUCCESS == 0 if symbol not available */\n        {\n            fprintf(f, \", port=%u\", (unsigned int)(port ? *port : 0));\n        }\n        else\n        {\n            fprintf(f, \" (non-success return)\");\n        }\n        fprintf(f, \"\\n\\n\");\n        fclose(f);\n    }\n\n    return rv;\n}\n\n/* The original function with minimal changes: calls probe wrappers instead\n * of the raw implementations so behavior is unchanged but logging is produced.\n * Note: keep the original types used in the project. Here we use void * for\n * address parameter types in probes to avoid depending on project-specific\n * typedefs in this standalone snippet.\n */\nvoid OS_CreateSocketName(const OS_object_token_t *token, const OS_SockAddr_t *Addr, const char *parent_name)\n{\n    size_t                       len;\n    uint16                       port;\n    OS_stream_internal_record_t *sock;\n\n    /* Log entry with token and address pointer */\n    {\n        char tmp[256];\n        snprintf(tmp, sizeof(tmp), \"[probe] Enter OS_CreateSocketName: token=%p, Addr=%p, parent_name=%p\\n\",\n                 (const void *)token, (const void *)Addr, (const void *)parent_name);\n        os_log_append(tmp);\n    }\n\n    sock = OS_OBJECT_TABLE_GET(OS_stream_table, *token);\n\n    if (probe_OS_SocketAddrToString_Impl(sock->stream_name, sizeof(sock->stream_name), Addr) != OS_SUCCESS)\n    {\n        sock->stream_name[0] = 0;\n        os_log_append(\"[probe] OS_SocketAddrToString_Impl failed -> cleared stream_name[0]\\n\");\n    }\n    if (probe_OS_SocketAddrGetPort_Impl(&port, Addr) == OS_SUCCESS)\n    {\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \":%u\", (unsigned int)port);\n        /* Log appended port and resulting name so callers can see the path taken. */\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended port :%u -> stream_name='%s'\\n\", (unsigned int)port, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    if (parent_name)\n    {\n        /* Append the name from the parent socket. */\n        len = OS_strnlen(sock->stream_name, sizeof(sock->stream_name));\n        snprintf(&sock->stream_name[len], sizeof(sock->stream_name) - len, \"-%s\", parent_name);\n\n        {\n            char tmp[512];\n            snprintf(tmp, sizeof(tmp), \"[probe] Appended parent name '-%s' -> stream_name='%s'\\n\", parent_name, sock->stream_name);\n            os_log_append(tmp);\n        }\n    }\n\n    /* Final state log */\n    {\n        char tmp[512];\n        snprintf(tmp, sizeof(tmp), \"[probe] Exit OS_CreateSocketName: final stream_name='%s'\\n\\n\", sock->stream_name);\n        os_log_append(tmp);\n    }\n}\n"
}