{
  "user_message": "An agent A claimed that the following OS_SocketGetInfo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_SocketGetInfo.\n```c\nint32 OS_SocketGetInfo(osal_id_t sock_id, OS_socket_prop_t *sock_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sock_prop);\n\n    memset(sock_prop, 0, sizeof(OS_socket_prop_t));\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        strncpy(sock_prop->name, record->name_entry, sizeof(sock_prop->name) - 1);\n        sock_prop->creator = record->creator;\n        return_code        = OS_SocketGetInfo_Impl(&token, sock_prop);\n\n        OS_ObjectIdRelease(&token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:strncpy(sock_prop->name, record->name_entry, sizeof(sock_prop->name) - 1) can read up to 19 bytes from record->name_entry. If record->name_entry does not refer to an object at least 19 bytes long (for example it is a pointer to a 10-byte buffer) or is not NUL-terminated within the first 19 bytes, strncpy will read beyond the bounds of the source object and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void os_socket_log_probe(const char *stage,\n                                     unsigned long long sock_id,\n                                     const void *sock_prop_ptr,\n                                     size_t dest_size,\n                                     size_t copy_len,\n                                     const void *record_ptr,\n                                     const void *name_entry_ptr,\n                                     int return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1983.txt\", \"a\");\n    if (!f)\n    {\n        return;\n    }\n\n    /* Log a single-line record with the key control/state values. Do not dereference\n       the source pointer (name_entry_ptr) to avoid reading memory that might be\n       out-of-bounds. */\n    fprintf(f, \"%s: sock_id=%llu sock_prop=%p dest_size=%zu copy_len=%zu record=%p name_entry=%p return_code=%d\\n\",\n            stage,\n            sock_id,\n            sock_prop_ptr,\n            dest_size,\n            copy_len,\n            record_ptr,\n            name_entry_ptr,\n            return_code);\n\n    fclose(f);\n}\n\nint32 OS_SocketGetInfo(osal_id_t sock_id, OS_socket_prop_t *sock_prop)\n{\n    OS_common_record_t *record;\n    OS_object_token_t   token;\n    int32               return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(sock_prop);\n\n    /* Log entry into function */\n    os_socket_log_probe(\"ENTER\", (unsigned long long)sock_id, (const void *)sock_prop, 0u, 0u, NULL, NULL, 0);\n\n    memset(sock_prop, 0, sizeof(OS_socket_prop_t));\n\n    /* Log after clearing destination structure; compute destination buffer size\n       and planned copy length but do not inspect the source buffer here. */\n    {\n        size_t dest_size = sizeof(sock_prop->name);\n        size_t copy_len  = (dest_size > 0u) ? (dest_size - 1u) : 0u;\n        os_socket_log_probe(\"AFTER_MEMSET\", (unsigned long long)sock_id, (const void *)sock_prop, dest_size, copy_len, NULL, NULL, 0);\n    }\n\n    /* Check Parameters */\n    return_code = OS_ObjectIdGetById(OS_LOCK_MODE_GLOBAL, LOCAL_OBJID_TYPE, sock_id, &token);\n    if (return_code == OS_SUCCESS)\n    {\n        record = OS_OBJECT_TABLE_GET(OS_global_stream_table, token);\n\n        /* Log the record pointer and the name_entry pointer (pointer values only).\n           Do not dereference name_entry_ptr to avoid extra out-of-bounds accesses. */\n        {\n            size_t dest_size = sizeof(sock_prop->name);\n            size_t copy_len  = (dest_size > 0u) ? (dest_size - 1u) : 0u;\n            const void *name_entry_ptr = NULL;\n\n            /* record->name_entry is a pointer field; reading the pointer value is safe\n               as long as 'record' is valid. This does not read the pointed-to bytes. */\n            name_entry_ptr = (const void *)record->name_entry;\n\n            os_socket_log_probe(\"BEFORE_STRNCPY\", (unsigned long long)sock_id, (const void *)sock_prop, dest_size, copy_len, (const void *)record, name_entry_ptr, return_code);\n        }\n\n        /* Original copy operation retained exactly as in the target code. */\n        strncpy(sock_prop->name, record->name_entry, sizeof(sock_prop->name) - 1);\n\n        /* Log immediately after strncpy completes. This documents that the copy was\n           performed (but does not attempt to validate whether the source was large\n           enough, to avoid additional reads). */\n        {\n            size_t dest_size = sizeof(sock_prop->name);\n            size_t copy_len  = (dest_size > 0u) ? (dest_size - 1u) : 0u;\n            os_socket_log_probe(\"AFTER_STRNCPY\", (unsigned long long)sock_id, (const void *)sock_prop, dest_size, copy_len, (const void *)record, (const void *)record->name_entry, return_code);\n        }\n\n        sock_prop->creator = record->creator;\n        return_code        = OS_SocketGetInfo_Impl(&token, sock_prop);\n\n        os_socket_log_probe(\"AFTER_IMPL\", (unsigned long long)sock_id, (const void *)sock_prop, sizeof(sock_prop->name), (sizeof(sock_prop->name) > 0u) ? (sizeof(sock_prop->name) - 1u) : 0u, (const void *)record, (const void *)record->name_entry, return_code);\n\n        OS_ObjectIdRelease(&token);\n    }\n    else\n    {\n        /* Log failure to obtain object id */\n        os_socket_log_probe(\"OBJID_FAILED\", (unsigned long long)sock_id, (const void *)sock_prop, 0u, 0u, NULL, NULL, return_code);\n    }\n\n    /* Final return value logged by caller if needed, but return here as before. */\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_SocketGetInfo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent\u2019s report is correct as stated: strncpy(sock_prop->name, record->name_entry, sizeof(sock_prop->name) - 1) can read up to (sizeof(sock_prop->name)-1) bytes from record->name_entry. MISRA C 2023 Rule 21.17 forbids uses of string.h functions that may access beyond the bounds of the object pointed to by their pointer parameters unless there is an independent, provable guarantee about the size/termination of the source object. The snippet provided contains no local proof that record->name_entry refers to an object at least that large or is NUL-terminated within that length, so the call is potentially out-of-bounds and thus nonconforming. The empty test log does not refute the issue \u2014 it only shows the test did not exercise or record evidence \u2014 and does not eliminate the need for a guarantee or a safe copy pattern (for example, ensuring record->name_entry is an array of sufficient size, or using a bounded-length check such as strnlen(record->name_entry, limit) to compute a safe copy length)."
}