{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe conditional block 'if (ret != 0) { OS_DEBUG(\"pthread_mutex_unlock(&impl->mutex): %s\", strerror(ret)); }' is dead code because OS_DEBUG is defined as an empty macro. The if-body produces no side effects (the logging and strerror() call are not present after macro expansion), so removing the entire if-statement would not change program behaviour. This constitutes dead code and thus violates MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_Unlock_Global_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/362.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_Unlock_Global_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_Unlock_Global_Impl:\n```c\nvoid OS_Unlock_Global_Impl(osal_objtype_t idtype)\n{\n    OS_impl_objtype_lock_t *impl;\n    int                     ret;\n\n    impl = OS_impl_objtype_lock_table[idtype];\n\n    if (impl != NULL)\n    {\n        /* Notify any waiting threads that the state _may_ have changed */\n        ret = pthread_cond_broadcast(&impl->cond);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_cond_broadcast(&impl->cond): %s\", strerror(ret));\n            /* unexpected but keep going (not critical) */\n        }\n\n        ret = pthread_mutex_unlock(&impl->mutex);\n        if (ret != 0)\n        {\n            OS_DEBUG(\"pthread_mutex_unlock(&impl->mutex): %s\", strerror(ret));\n        }\n    }\n}\n```\n</target_code>\nPlease provide the modified OS_Unlock_Global_Impl code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <pthread.h>\n#include <errno.h>\n\n/* Minimal stand-in type definitions so this translation unit is compilable\n   when built alone. In the real project these will be provided elsewhere. */\ntypedef int osal_objtype_t;\n\ntypedef struct\n{\n    pthread_mutex_t mutex;\n    pthread_cond_t  cond;\n} OS_impl_objtype_lock_t;\n\n/* Small fixed-size table to emulate the real OS_impl_objtype_lock_table.\n   Initialized to NULL pointers. */\nstatic const int OS_IMPL_TABLE_SIZE = 16;\nstatic OS_impl_objtype_lock_t *OS_impl_objtype_lock_table_STATIC[16] = { 0 };\n/* Provide a symbol with the expected name used by the real code. */\nOS_impl_objtype_lock_t *OS_impl_objtype_lock_table[] = {\n    /* Expose the same underlying storage for simplicity. */\n    OS_impl_objtype_lock_table_STATIC[0], OS_impl_objtype_lock_table_STATIC[1],\n    OS_impl_objtype_lock_table_STATIC[2], OS_impl_objtype_lock_table_STATIC[3],\n    OS_impl_objtype_lock_table_STATIC[4], OS_impl_objtype_lock_table_STATIC[5],\n    OS_impl_objtype_lock_table_STATIC[6], OS_impl_objtype_lock_table_STATIC[7],\n    OS_impl_objtype_lock_table_STATIC[8], OS_impl_objtype_lock_table_STATIC[9],\n    OS_impl_objtype_lock_table_STATIC[10], OS_impl_objtype_lock_table_STATIC[11],\n    OS_impl_objtype_lock_table_STATIC[12], OS_impl_objtype_lock_table_STATIC[13],\n    OS_impl_objtype_lock_table_STATIC[14], OS_impl_objtype_lock_table_STATIC[15]\n};\n\n/* Probe logging helper: append messages to /tmp/logs/362.txt. This captures\n   control flow and state for reproducing the reported violation scenario. */\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* Best-effort: if logging can't open the file, silently return to not\n           affect the original behavior of the function under test. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n/* The real project may define OS_DEBUG as a macro that expands to nothing.\n   Do not redefine it here; call it if present. */\n\nvoid OS_Unlock_Global_Impl(osal_objtype_t idtype)\n{\n    OS_impl_objtype_lock_t *impl;\n    int                     ret;\n\n    probe_log(\"OS_Unlock_Global_Impl: entry idtype=%d\", (int)idtype);\n\n    impl = OS_impl_objtype_lock_table[idtype];\n\n    if (impl != NULL)\n    {\n        /* Notify any waiting threads that the state _may_ have changed */\n        probe_log(\"calling pthread_cond_broadcast on impl->cond\");\n        ret = pthread_cond_broadcast(&impl->cond);\n        probe_log(\"pthread_cond_broadcast returned %d\", ret);\n        if (ret != 0)\n        {\n            /* Record the error text as evidence even if OS_DEBUG is a no-op. */\n            probe_log(\"pthread_cond_broadcast(&impl->cond) error: %s\", strerror(ret));\n            /* Preserve original call to OS_DEBUG for parity with the original code */\n            OS_DEBUG(\"pthread_cond_broadcast(&impl->cond): %s\", strerror(ret));\n            /* unexpected but keep going (not critical) */\n        }\n\n        probe_log(\"calling pthread_mutex_unlock on impl->mutex\");\n        ret = pthread_mutex_unlock(&impl->mutex);\n        probe_log(\"pthread_mutex_unlock returned %d\", ret);\n        if (ret != 0)\n        {\n            /* This is the branch reported as dead when OS_DEBUG expands to nothing.\n               We log here explicitly to /tmp/logs/362.txt so the control-flow and\n               state leading to this branch can be reproduced and inspected. */\n            probe_log(\"pthread_mutex_unlock(&impl->mutex) error: %s\", strerror(ret));\n            /* Preserve original call to OS_DEBUG for parity with the original code */\n            OS_DEBUG(\"pthread_mutex_unlock(&impl->mutex): %s\", strerror(ret));\n        }\n    }\n    else\n    {\n        probe_log(\"impl is NULL for idtype=%d, nothing to do\", (int)idtype);\n    }\n\n    probe_log(\"OS_Unlock_Global_Impl: exit idtype=%d\", (int)idtype);\n}\n"
}