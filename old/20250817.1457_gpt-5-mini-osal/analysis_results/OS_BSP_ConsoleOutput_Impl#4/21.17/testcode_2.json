{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nYes. The call to strlen(OutputMessage) assumes OutputMessage points to a NUL-terminated string, but there is no guarantee in the shown code that the caller always provides a NUL-terminated buffer. If OutputMessage points at a buffer that is not NUL-terminated (for example a substring extracted with memcpy, a region of a ring buffer, or binary data whose terminator was not appended), strlen will scan past the valid object bounds looking for '\\0' and thus can access beyond the referenced object \u2014 violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_BSP_ConsoleOutput_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/39.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_BSP_ConsoleOutput_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_BSP_ConsoleOutput_Impl:\n```c\nvoid OS_BSP_ConsoleOutput_Impl(const char *Str, size_t DataLen)\n{\n    ssize_t WriteLen;\n\n    while (DataLen > 0)\n    {\n        /* writes the raw data directly to STDOUT_FILENO (unbuffered) */\n        WriteLen = write(STDOUT_FILENO, Str, DataLen);\n        if (WriteLen <= 0)\n        {\n            /* no recourse if this fails, just stop. */\n            break;\n        }\n        Str += WriteLen;\n        DataLen -= WriteLen;\n    }\n}\n```\n</target_code>\nPlease provide the modified OS_BSP_ConsoleOutput_Impl code.\n",
  "test_code": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <string.h>\n#include <stdint.h>\n#include <ctype.h>\n\n/*\n * Probe/logging helpers that append information to /tmp/logs/39.txt.\n * These helpers avoid reading beyond the provided DataLen for any buffer\n * inspection to ensure we do not introduce new out-of-bounds accesses.\n */\nstatic void log_append_formatted(const char *fmt, ...)\n{\n    char buf[512];\n    va_list ap;\n    va_start(ap, fmt);\n    int n = vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n\n    if (n <= 0) {\n        return;\n    }\n\n    /* n might be larger than sizeof(buf); clamp to buffer size */\n    size_t to_write = (size_t)n;\n    if (to_write > sizeof(buf)) {\n        to_write = sizeof(buf);\n    }\n\n    int fd = open(\"/tmp/logs/39.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (fd >= 0) {\n        ssize_t w = write(fd, buf, to_write);\n        (void)w; /* best-effort logging; ignore write errors */\n        close(fd);\n    }\n}\n\nstatic void log_hex_ascii(const char *prefix, const void *data, size_t len)\n{\n    const unsigned char *d = (const unsigned char *)data;\n    const size_t max_display = 64; /* limit log size */\n    size_t show = (len < max_display) ? len : max_display;\n    char buf[256];\n    size_t pos = 0;\n\n    pos += snprintf(buf + pos, sizeof(buf) - pos, \"%s (len=%zu): \", prefix, len);\n    for (size_t i = 0; i < show && pos + 4 < sizeof(buf); i++) {\n        unsigned int v = d[i];\n        pos += snprintf(buf + pos, sizeof(buf) - pos, \"%02X \", v);\n    }\n    if (show < len && pos + 16 < sizeof(buf)) {\n        pos += snprintf(buf + pos, sizeof(buf) - pos, \"... (truncated)\");\n    }\n    pos += snprintf(buf + pos, sizeof(buf) - pos, \"\\n\");\n\n    /* write the hex line */\n    int fd = open(\"/tmp/logs/39.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (fd >= 0) {\n        (void)write(fd, buf, strlen(buf));\n        close(fd);\n    }\n\n    /* also write an ASCII representation */\n    pos = 0;\n    pos += snprintf(buf + pos, sizeof(buf) - pos, \"%s ASCII: \", prefix);\n    for (size_t i = 0; i < show && pos + 2 < sizeof(buf); i++) {\n        char c = (char)d[i];\n        buf[pos++] = (isprint((unsigned char)c) ? c : '.');\n    }\n    if (show < len && pos + 16 < sizeof(buf)) {\n        pos += snprintf(buf + pos, sizeof(buf) - pos, \"... (truncated)\");\n    }\n    pos += snprintf(buf + pos, sizeof(buf) - pos, \"\\n\");\n\n    fd = open(\"/tmp/logs/39.txt\", O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (fd >= 0) {\n        (void)write(fd, buf, strlen(buf));\n        close(fd);\n    }\n}\n\nvoid OS_BSP_ConsoleOutput_Impl(const char *Str, size_t DataLen)\n{\n    ssize_t WriteLen;\n\n    /* Entry log: pointer and length */\n    log_append_formatted(\"OS_BSP_ConsoleOutput_Impl entry: Str=%p, DataLen=%zu\\n\", (const void *)Str, DataLen);\n\n    /* Defensive inspection: do not read beyond DataLen. If Str is NULL, avoid dereference. */\n    if (Str == NULL) {\n        log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: Str is NULL, nothing to write.\\n\");\n        return;\n    }\n\n    if (DataLen > 0) {\n        /* Scan within DataLen for an embedded NUL. If none is found this is a useful\n         * indicator that callers who used strlen(Str) when constructing DataLen would\n         * have caused a potential out-of-bounds read. We only examine bytes up to\n         * DataLen-1 to avoid accessing beyond the referenced object.\n         */\n        size_t nul_pos = (size_t)-1;\n        for (size_t i = 0; i < DataLen; ++i) {\n            if (Str[i] == '\\0') {\n                nul_pos = i;\n                break;\n            }\n        }\n        if (nul_pos == (size_t)-1) {\n            log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: No NUL terminator found within DataLen=%zu.\\n\", DataLen);\n            /* Log a hex/ASCII snapshot of the first bytes for diagnostics (bounded by DataLen). */\n            log_hex_ascii(\"OS_BSP_ConsoleOutput_Impl buffer snapshot\", Str, DataLen);\n        } else {\n            log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: NUL terminator found at offset %zu within DataLen=%zu.\\n\", nul_pos, DataLen);\n            /* Log up to the NUL position for context */\n            log_hex_ascii(\"OS_BSP_ConsoleOutput_Impl buffer (up to NUL)\", Str, nul_pos + 1);\n        }\n    } else {\n        log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: DataLen is zero, nothing to write.\\n\");\n        return;\n    }\n\n    while (DataLen > 0)\n    {\n        /* Log intended write size and pointer before the write */\n        log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: about to write Str=%p, DataLen=%zu\\n\", (const void *)Str, DataLen);\n\n        /* writes the raw data directly to STDOUT_FILENO (unbuffered) */\n        WriteLen = write(STDOUT_FILENO, Str, DataLen);\n        if (WriteLen <= 0)\n        {\n            /* Log the failure with errno for diagnostics, then stop. */\n            int saved_errno = errno;\n            log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: write returned %zd, errno=%d (%s)\\n\", WriteLen, saved_errno, strerror(saved_errno));\n            /* no recourse if this fails, just stop. */\n            break;\n        }\n\n        log_append_formatted(\"OS_BSP_ConsoleOutput_Impl: wrote %zd bytes\\n\", WriteLen);\n\n        Str += WriteLen;\n        DataLen -= WriteLen;\n    }\n\n    log_append_formatted(\"OS_BSP_ConsoleOutput_Impl exit: remaining DataLen=%zu, final Str=%p\\n\", DataLen, (const void *)Str);\n}\n"
}