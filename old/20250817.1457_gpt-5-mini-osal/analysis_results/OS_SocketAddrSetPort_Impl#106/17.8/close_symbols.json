{
  "user_message": "Target function code is:\n```c\nint32 OS_SocketAddrSetPort_Impl(OS_SockAddr_t *Addr, uint16 PortNum)\n{\n    in_port_t               sa_port;\n    OS_SockAddr_Accessor_t *Accessor;\n\n    sa_port  = htons(PortNum);\n    Accessor = (OS_SockAddr_Accessor_t *)&Addr->AddrData;\n\n    switch (Accessor->sa.sa_family)\n    {\n        case AF_INET:\n            Accessor->sa_in.sin_port = sa_port;\n            break;\n#ifdef OS_NETWORK_SUPPORTS_IPV6\n        case AF_INET6:\n            Accessor->sa_in6.sin6_port = sa_port;\n            break;\n#endif\n        default:\n            return OS_ERR_BAD_ADDRESS;\n    }\n\n    return OS_SUCCESS;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_SocketAddrSetPort_Impl': {'callees': [], 'callers': ['OS_SocketAddrSetPort']}, 'OS_SocketAddrSetPort': {'callees': ['OS_printf', 'OS_SocketAddrSetPort_Impl', 'UT_Stub_RegisterReturnType', 'UT_Stub_RegisterContextWithMetaData', 'UT_ExecuteBasicHandler', 'UT_Stub_GetReturnValuePtr'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SockAddr_t",
    "OS_SockAddr_Accessor_t",
    "OS_SockAddr_t::AddrData (member)",
    "OS_SockAddr_Accessor_t::sa (and sa.sa_family)",
    "OS_SockAddr_Accessor_t::sa_in (and sa_in.sin_port)",
    "OS_SockAddr_Accessor_t::sa_in6 (and sa_in6.sin6_port)",
    "AF_INET",
    "AF_INET6",
    "in_port_t",
    "htons",
    "uint16",
    "int32"
  ],
  "explanation": "To determine compliance with the MISRA rule \"A function parameter should not be modified\" we must be able to tell whether the function modifies the parameter variable Addr itself or only the object it points to. The following symbols are required for that analysis:\n\n- OS_SockAddr_t: definition of the parameter type Addr to see whether Addr is a pointer to non-const data and to locate the AddrData member (to confirm the expression &Addr->AddrData is a pointer into the pointed-at object, not an alias of the parameter variable).\n- OS_SockAddr_Accessor_t: definition of the accessor type used in the cast; needed to determine what fields Accessor->... refers to and whether those fields reside within the pointed-to object (allowed) or would imply modification of the local pointer variable (disallowed).\n- OS_SockAddr_t::AddrData (member): the actual member being addressed by &Addr->AddrData \u2013 needed to confirm the cast target is inside the object pointed to by Addr, not the Addr parameter itself.\n- OS_SockAddr_Accessor_t::sa (and sa.sa_family): to understand the switch selector and ensure only fields of the pointed-to object are read (not writing to Addr variable).\n- OS_SockAddr_Accessor_t::sa_in (and sa_in.sin_port): to confirm the assignment Accessor->sa_in.sin_port = sa_port writes into the pointed-to object (permitted) and not to any entity that would modify the Addr parameter variable.\n- OS_SockAddr_Accessor_t::sa_in6 (and sa_in6.sin6_port): same reason as sa_in but for the IPv6 branch.\n- AF_INET and AF_INET6: constants used in the switch; needed to ensure control flow and which member is written (verifies writes target pointed-to object fields only).\n- in_port_t: type of sa_port and sin_port/sin6_port to ensure the assignment is a normal field store and does not involve modifying the Addr parameter itself.\n- htons: to confirm this call only produces a value (no side-effect on Addr) and the result is stored in a local variable sa_port before assignment.\n- uint16 and int32: typedefs for PortNum and return type to ensure PortNum is passed by value (cannot be modified) and to confirm no implicit modification of parameter by aliasing or special semantics.\n\nWith definitions of the above symbols one can verify that the function does not assign to the parameter variable Addr itself (no code like Addr = ...), and only writes into the object pointed to by Addr (which MISRA allows)."
}