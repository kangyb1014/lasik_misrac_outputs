{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe local variable 'return_code' in OS_ObjectIdConvertToken is initialized to OS_ERROR at declaration (int32 return_code = OS_ERROR;). Every control path that reaches the later use of return_code (the checks after the while loop) assigns a definite value to it inside the loop (OS_SUCCESS, OS_ERR_INVALID_ID, or OS_ERR_OBJECT_IN_USE), and the only early return bypassing that code returns a concrete error directly. Therefore the initial assignment to OS_ERROR is executed but has no effect on program behaviour and can be removed \u2014 this constitutes dead code under MISRA C 2023 Rule 2.2.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_ObjectIdGetById code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1586.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_ObjectIdGetById as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_ObjectIdGetById:\n```c\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    if (return_code != OS_SUCCESS)\n    {\n        return return_code;\n    }\n\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n\n        /*\n         * The \"ConvertToken\" routine will return with the global lock\n         * in a state appropriate for returning to the caller, as indicated\n         * by the \"check_mode\" parameter.\n         *\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE.\n         */\n        return_code = OS_ObjectIdConvertToken(token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        OS_ObjectIdTransactionCancel(token);\n    }\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_ObjectIdGetById code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n\n/* Probe helper: append a concise log entry to /tmp/logs/1586.txt\n * Keep this as a simple side-effect only; it does not change program logic. */\nstatic void os_objectid_log(const char *event, int32 return_code, OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, const OS_object_token_t *token)\n{\n    FILE *f = fopen(\"/tmp/logs/1586.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    fprintf(f, \"[OS_ObjectIdGetById] %s: rc=%d lock_mode=%d idtype=%d id=%d token=%p\",\n            event, (int)return_code, (int)lock_mode, (int)idtype, (int)id, (const void *)token);\n\n    if (token != NULL)\n    {\n        /* Print token internals if available. Cast to int for safe printing of enum/integer-like fields. */\n        fprintf(f, \" obj_idx=%d obj_id=%d\", (int)token->obj_idx, (int)token->obj_id);\n    }\n\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nint32 OS_ObjectIdGetById(OS_lock_mode_t lock_mode, osal_objtype_t idtype, osal_id_t id, OS_object_token_t *token)\n{\n    int32 return_code;\n\n    /* Log entry and parameters */\n    os_objectid_log(\"entry\", 0, lock_mode, idtype, id, token);\n\n    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);\n    os_objectid_log(\"after TransactionInit\", return_code, lock_mode, idtype, id, token);\n    if (return_code != OS_SUCCESS)\n    {\n        os_objectid_log(\"early return (TransactionInit failed)\", return_code, lock_mode, idtype, id, token);\n        return return_code;\n    }\n\n    os_objectid_log(\"before ToArrayIndex\", return_code, lock_mode, idtype, id, token);\n    return_code = OS_ObjectIdToArrayIndex(idtype, id, &token->obj_idx);\n    os_objectid_log(\"after ToArrayIndex\", return_code, lock_mode, idtype, id, token);\n\n    if (return_code == OS_SUCCESS)\n    {\n        token->obj_id = id;\n        os_objectid_log(\"before ConvertToken (success path)\", return_code, lock_mode, idtype, id, token);\n\n        /* The ConvertToken routine will return with the global lock in a state appropriate\n         * for returning to the caller, as indicated by the check_mode parameter.\n         * Note If this operation fails, then it always unlocks the global for\n         * all check_mode's other than NONE. */\n        return_code = OS_ObjectIdConvertToken(token);\n        os_objectid_log(\"after ConvertToken\", return_code, lock_mode, idtype, id, token);\n    }\n    else\n    {\n        os_objectid_log(\"ToArrayIndex failed (skip ConvertToken)\", return_code, lock_mode, idtype, id, token);\n    }\n\n    if (return_code != OS_SUCCESS)\n    {\n        os_objectid_log(\"about to cancel transaction (failure path)\", return_code, lock_mode, idtype, id, token);\n        OS_ObjectIdTransactionCancel(token);\n        os_objectid_log(\"after cancel\", return_code, lock_mode, idtype, id, token);\n    }\n\n    os_objectid_log(\"return\", return_code, lock_mode, idtype, id, token);\n    return return_code;\n}\n"
}