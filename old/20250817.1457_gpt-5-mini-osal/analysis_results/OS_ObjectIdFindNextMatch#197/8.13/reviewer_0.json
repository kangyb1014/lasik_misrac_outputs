{
  "user_message": "An agent A claimed that the following OS_ObjectIdFindNextMatch code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFindNextMatch.\n```c\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'record' is declared as OS_common_record_t * (non-const) but is only used for read-only access and passed to MatchFunc which takes a const OS_common_record_t *. Per MISRA C 2023 Rule 8.13 the pointer should be const-qualified (e.g. const OS_common_record_t *record). Similarly, 'base' could be const as it points into a global table that is not modified here. The assignment 'record = OS_OBJECT_TABLE_GET(base, *token);' therefore violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic FILE *probe_open_log(void)\n{\n    FILE *f = fopen(\"/tmp/logs/1579.txt\", \"a\");\n    return f;\n}\nstatic void probe_log(FILE *f, const char *fmt, ...)\n{\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fflush(f);\n}\n\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n    FILE               *logf;\n    bool                defined;\n    bool                matched;\n\n    /* Open log for this invocation */\n    logf = probe_open_log();\n    probe_log(logf, \"ENTRY OS_ObjectIdFindNextMatch: token=%p obj_type=%lu obj_idx=%lu obj_id=%lu\\n\",\n              (void *)token,\n              (unsigned long)token->obj_type,\n              (unsigned long)token->obj_idx,\n              (unsigned long)token->obj_id);\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    probe_log(logf, \"base=%p obj_count=%lu\\n\", (void *)base, (unsigned long)obj_count);\n\n    while (true)\n    {\n        probe_log(logf, \"loop top: current obj_idx=%lu\\n\", (unsigned long)token->obj_idx);\n\n        ++token->obj_idx;\n\n        probe_log(logf, \"incremented obj_idx=%lu\\n\", (unsigned long)token->obj_idx);\n\n        if (token->obj_idx >= obj_count)\n        {\n            probe_log(logf, \"obj_idx >= obj_count (%lu >= %lu), breaking\\n\",\n                      (unsigned long)token->obj_idx, (unsigned long)obj_count);\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        probe_log(logf, \"fetched record=%p for obj_idx=%lu\\n\", (void *)record, (unsigned long)token->obj_idx);\n\n        /* Determine defined-ness and match result separately so we can log both */\n        defined = false;\n        matched = false;\n\n        if (record != NULL)\n        {\n            probe_log(logf, \"record->active_id=%lu\\n\", (unsigned long)record->active_id);\n            defined = OS_ObjectIdDefined(record->active_id) ? true : false;\n            probe_log(logf, \"OS_ObjectIdDefined=%d\\n\", defined ? 1 : 0);\n\n            if (defined)\n            {\n                matched = MatchFunc(arg, token, record) ? true : false;\n                probe_log(logf, \"MatchFunc returned=%d\\n\", matched ? 1 : 0);\n            }\n            else\n            {\n                probe_log(logf, \"Skipping MatchFunc because record is not defined\\n\");\n            }\n        }\n        else\n        {\n            probe_log(logf, \"record is NULL, skipping check\\n\");\n        }\n\n        if (defined && matched)\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            probe_log(logf, \"MATCH FOUND: token->obj_id set to %lu, returning success\\n\", (unsigned long)token->obj_id);\n            break;\n        }\n    }\n\n    probe_log(logf, \"EXIT OS_ObjectIdFindNextMatch: return_code=%ld token->obj_idx=%lu token->obj_id=%lu\\n\",\n              (long)return_code,\n              (unsigned long)token->obj_idx,\n              (unsigned long)token->obj_id);\n\n    if (logf != NULL)\n    {\n        fclose(logf);\n    }\n\n    return return_code;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb55a0 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb55a0 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb55a0 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb55a0 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb5610 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb5520 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb5550 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb5610 obj_type=0 obj_idx=0 obj_id=0\nbase=0x55e0c8c2d340 obj_count=0\nloop top: current obj_idx=0\nincremented obj_idx=1\nobj_idx >= obj_count (1 >= 0), breaking\nEXIT OS_ObjectIdFindNextMatch: return_code=-17 token->obj_idx=1 token->obj_id=0\nENTRY OS_ObjectIdFindNextMatch: token=0x7ffe2ebb5610 obj_type=11 obj_idx=4294967295 obj_id=0\nbase=0x55e0c8c2ed38 obj_count=14\nloop top: current obj_idx=4294967295\nincremented obj_idx=0\nfetched record=0x55e0c8c2ed38 for obj_idx=0\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=0\nincremented obj_idx=1\nfetched record=0x55e0c8c2ed50 for obj_idx=1\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=1\nincremented obj_idx=2\nfetched record=0x55e0c8c2ed68 for obj_idx=2\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=2\nincremented obj_idx=3\nfetched record=0x55e0c8c2ed80 for obj_idx=3\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=3\nincremented obj_idx=4\nfetched record=0x55e0c8c2ed98 for obj_idx=4\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=4\nincremented obj_idx=5\nfetched record=0x55e0c8c2edb0 for obj_idx=5\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=5\nincremented obj_idx=6\nfetched record=0x55e0c8c2edc8 for obj_idx=6\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=6\nincremented obj_idx=7\nfetched record=0x55e0c8c2ede0 for obj_idx=7\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx=7\nincremented obj_idx=8\nfetched record=0x55e0c8c2edf8 for obj_idx=8\nrecord->active_id=0\nOS_ObjectIdDefined=0\nSkipping MatchFunc because record is not defined\nloop top: current obj_idx\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. In the shown function both 'base' and 'record' are used only for read-only access: the code never modifies the objects through those pointers and they are passed to a matcher that (per the scenario) expects a const-qualified record pointer. Per MISRA C 2023 Rule 8.13 a pointer should be qualified to point to const whenever possible, so declaring them as const OS_common_record_t *base and const OS_common_record_t *record (or otherwise making the pointed-to type const) would satisfy the rule. Assigning the result of OS_OBJECT_TABLE_GET (which returns a non-const pointer) to a pointer-to-const is allowed and does not violate type safety, so the current non-const declarations are a violation of 8.13."
}