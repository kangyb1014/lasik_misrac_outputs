{
  "user_message": "An agent A claimed that the following OS_ObjectIdFindNextMatch code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ObjectIdFindNextMatch.\n```c\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    return_code   = OS_ERR_NAME_NOT_FOUND;\n    base          = &OS_common_table[OS_GetBaseForObjectType(token->obj_type)];\n    obj_count     = OS_GetMaxForObjectType(token->obj_type);\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (true)\n    {\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, *token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n    }\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer 'record' is declared as OS_common_record_t *record but is only used for read access and is passed to MatchFunc which expects a const OS_common_record_t *obj. According to Rule 8.13, such pointers should be declared to point to a const-qualified type (e.g. const OS_common_record_t *record). 'token' cannot be const because it is modified, but 'record' should be const-qualified.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int32_t int32;\ntypedef uint32_t uint32;\nstruct OS_common_record\n{\n    uint32 active_id;\n};\ntypedef struct OS_common_record\n{\n    uint32 active_id;\n} OS_common_record_t;\nstruct OS_object_token\n{\n    uint32 obj_type;\n    uint32 obj_idx;\n    uint32 obj_id;\n};\ntypedef struct OS_object_token\n{\n    uint32 obj_type;\n    uint32 obj_idx;\n    uint32 obj_id;\n} OS_object_token_t;\ntypedef int32 (*OS_ObjectMatchFunc_t)(void *arg, OS_object_token_t *token, const OS_common_record_t *obj);\nstatic size_t OS_common_table_count = 0;\nstatic inline int32 OS_ObjectIdDefined(uint32 id)\n{\n    return (id != OS_OBJECT_ID_UNDEFINED) ? 1 : 0;\n}\nstatic inline OS_common_record_t *OS_OBJECT_TABLE_GET(OS_common_record_t *base, OS_object_token_t *token)\n{\n    return base + token->obj_idx;\n}\n\nint32 OS_ObjectIdFindNextMatch(OS_ObjectMatchFunc_t MatchFunc, void *arg, OS_object_token_t *token)\n{\n    int32               return_code;\n    uint32              obj_count;\n    OS_common_record_t *base;\n    OS_common_record_t *record;\n\n    /* Default to not found */\n    return_code = OS_ERR_NAME_NOT_FOUND;\n\n    /* Use the global table as the base; if not set, treat as empty */\n    base = OS_common_table;\n    obj_count = (uint32)OS_common_table_count;\n\n    /* Reset the id in the token to undefined at start of search */\n    token->obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    while (1)\n    {\n        /* Advance to the next index to probe */\n        ++token->obj_idx;\n\n        if (token->obj_idx >= obj_count)\n        {\n            /* No more objects to search */\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(base, token);\n\n        if (OS_ObjectIdDefined(record->active_id) && MatchFunc(arg, token, record))\n        {\n            /* Found a match: set return code and fill token->obj_id */\n            return_code   = OS_SUCCESS;\n            token->obj_id = record->active_id;\n            break;\n        }\n\n        /* Otherwise continue searching */\n    }\n\n    return return_code;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in the given scenario. MISRA C 2023 Rule 8.13 requires that a pointer should point to a const-qualified type whenever possible. In the shown function the local 'record' pointer is only used for read access (reading record->active_id) and is passed to MatchFunc which \u2014 per the scenario/test-code \u2014 expects a const OS_common_record_t * parameter. Although C allows passing a non-const pointer to a function taking a pointer-to-const (the conversion is permitted), that implicit conversion does not satisfy MISRA 8.13: the local pointer should itself be declared as pointing to const when the object is not modified through it. Declaring 'record' as const OS_common_record_t *record (and, where possible, making 'base' const as well) would resolve the violation.\n\nNote: if in the real codebase MatchFunc actually takes a non-const OS_common_record_t * then there is no violation; the correctness of the report hinges on the MatchFunc prototype being the const-qualified form as assumed in the scenario."
}