{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.1.\nHere is the comment from the agent.\n<violation scenario>\nWhen OS_FileSysStartVolume_Impl returns OS_SUCCESS and the code enters the shown fragment (e.g. during OS_mkfs where should_format is true), OS_FileSysFormatVolume_Impl is implemented to unconditionally return OS_SUCCESS. Thus return_code is always OS_SUCCESS at the subsequent if (return_code == OS_SUCCESS) check, making the else branch (which calls OS_FileSysStopVolume_Impl(&token)) unreachable. In this project configuration that else block can never be executed, so the project contains unreachable code.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_FileSysFormatVolume_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/297.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_FileSysFormatVolume_Impl as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_FileSysFormatVolume_Impl:\n```c\nint32 OS_FileSysFormatVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * In theory, this should wipe any existing files in the ramdisk,\n     * but since ramdisks here are implemented using a directory within a tmpfs,\n     * removal of such files could be risky if something goes wrong,\n     * because it might remove files that were important.\n     *\n     * So the safest option is just a no-op.\n     * (this is also backward compatible since POSIX mkfs was always a no-op)\n     */\n    return OS_SUCCESS;\n}\n```\n</target_code>\nPlease provide the modified OS_FileSysFormatVolume_Impl code.\n",
  "test_code": "int32 OS_FileSysFormatVolume_Impl(const OS_object_token_t *token)\n{\n    /*\n     * In theory, this should wipe any existing files in the ramdisk,\n     * but since ramdisks here are implemented using a directory within a tmpfs,\n     * removal of such files could be risky if something goes wrong,\n     * because it might remove files that were important.\n     *\n     * So the safest option is just a no-op.\n     * (this is also backward compatible since POSIX mkfs was always a no-op)\n     *\n     * Insert probes to log control flow/state for debugging the reported\n     * unreachable-code scenario. The probes preserve the original logic\n     * (function remains a no-op returning OS_SUCCESS) while logging useful\n     * information to /tmp/logs/297.txt.\n     */\n\n    /* Forward declarations to avoid requiring stdio.h in this snippet. */\n    struct FILE;\n    extern struct FILE *fopen(const char *filename, const char *mode);\n    extern int fprintf(struct FILE *stream, const char *format, ...);\n    extern int fclose(struct FILE *stream);\n    extern int mkdir(const char *pathname, unsigned int mode);\n\n    /* Ensure the log directory exists; ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777U);\n\n    /* Open log file for append. If this fails, continue silently. */\n    struct FILE *logf = fopen(\"/tmp/logs/297.txt\", \"a\");\n    if (logf != (struct FILE *)0)\n    {\n        /* Log entry with the token pointer value so callers can correlate events. */\n        (void)fprintf(logf, \"OS_FileSysFormatVolume_Impl: entered; token=%p\\n\", (const void *)token);\n\n        /* Log the intended behavior and the final return value to provide evidence\n         * that this implementation is a no-op and always returns OS_SUCCESS. */\n        (void)fprintf(logf, \"OS_FileSysFormatVolume_Impl: performing no-op format; returning OS_SUCCESS\\n\");\n\n        (void)fclose(logf);\n    }\n\n    /* Preserve original behavior: always report success. */\n    return OS_SUCCESS;\n}\n"
}