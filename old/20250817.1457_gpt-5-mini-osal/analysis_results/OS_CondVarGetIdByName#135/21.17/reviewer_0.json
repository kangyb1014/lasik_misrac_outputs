{
  "user_message": "An agent A claimed that the following OS_CondVarGetIdByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_CondVarGetIdByName.\n```c\nint32 OS_CondVarGetIdByName(osal_id_t *var_id, const char *var_name)\n{\n    int32 return_code;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(var_id);\n    OS_CHECK_POINTER(var_name);\n\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_CONDVAR, var_name, var_id);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:OS_CondVarGetIdByName performs only a NULL check on 'var_name' and then forwards it to OS_ObjectIdGetByName/OS_ObjectIdGetBySearch. The called code (via ARGCHECK/LENGTHCHECK and the name-matching function) is likely to use string.h functions such as strlen/strcmp. If the caller provides a non-NULL pointer to a char object that is not NUL-terminated within its actual object bounds (for example a 5-byte buffer {'A','B','C','D','E'} with no '\\0'), those string functions can read past the object\u2019s bounds and cause out-of-bounds accesses. Therefore the code as shown can violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_CondVar_GetName_Probe_Enter(const char *func, const char *var_name, const void *var_id)\n{\n    FILE *f = fopen(\"/tmp/logs/1087.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t t = time(NULL);\n        fprintf(f, \"[%ld] %s: ENTER\\n\", (long)t, func);\n        fprintf(f, \"    var_name ptr = %p\\n\", (const void *)var_name);\n        fprintf(f, \"    var_id   ptr = %p\\n\", var_id);\n        fprintf(f, \"    var_name NULL check = %s\\n\", (var_name != NULL) ? \"non-NULL\" : \"NULL\");\n        fprintf(f, \"    NOTE: No NUL-termination check performed here; forwarding pointer as-is.\\n\");\n        fclose(f);\n    }\n}\nstatic void OS_CondVar_GetName_Probe_Exit(const char *func, int32 return_code)\n{\n    FILE *f = fopen(\"/tmp/logs/1087.txt\", \"a\");\n    if (f != NULL)\n    {\n        time_t t = time(NULL);\n        fprintf(f, \"[%ld] %s: EXIT return_code=%ld\\n\", (long)t, func, (long)return_code);\n        fprintf(f, \"------------------------------------------------------------\\n\");\n        fclose(f);\n    }\n}\n\nint32 OS_CondVarGetIdByName(osal_id_t *var_id, const char *var_name)\n{\n    int32 return_code;\n\n    /* Log entry and pointer-state BEFORE parameter macros so we capture the raw pointers\n       even if the macros cause an early return. This does not change original logic. */\n    OS_CondVar_GetName_Probe_Enter(\"OS_CondVarGetIdByName\", var_name, (const void *)var_id);\n\n    /* Check parameters (original logic preserved) */\n    OS_CHECK_POINTER(var_id);\n    OS_CHECK_POINTER(var_name);\n\n    /* Forward to object-id finder (original logic preserved) */\n    return_code = OS_ObjectIdFindByName(OS_OBJECT_TYPE_OS_CONDVAR, var_name, var_id);\n\n    /* Log exit with return code and control flow evidence */\n    OS_CondVar_GetName_Probe_Exit(\"OS_CondVarGetIdByName\", return_code);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_CondVarGetIdByName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C:2023 Rule 21.17 concerns the use of functions from <string.h> and forbids their use in a way that can read past the bounds of the objects referenced by their pointer parameters. The shown OS_CondVarGetIdByName implementation does not itself call any <string.h> functions \u2014 it merely NULL-checks the pointer (via OS_CHECK_POINTER) and forwards the var_name pointer to OS_ObjectIdFindByName. A potential out\u2011of\u2011bounds read would be caused by the callee (or other downstream code) if that code uses strlen/strcmp/etc. on a non\u2011NUL\u2011terminated buffer. That downstream code, not OS_CondVarGetIdByName, would be the locus of a Rule 21.17 violation. In other words, the report confuses a possible runtime misuse (caller passing a non\u2011NUL\u2011terminated buffer) with a direct violation by this function. If the project requires defense-in-depth, either the callee must enforce/document the requirement for NUL\u2011terminated strings or bounded string routines / explicit length parameters should be used; but as written, OS_CondVarGetIdByName itself does not violate Rule 21.17."
}