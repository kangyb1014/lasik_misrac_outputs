{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf CurrentSegment is not an array but a pointer (e.g. declared as \"char *CurrentSegment\"), sizeof(CurrentSegment) yields the pointer size (4 or 8), so Local_SegmentName is too small. Then strcpy(Local_SegmentName, CurrentSegment) can write beyond Local_SegmentName (and may read beyond the source if it is not null-terminated), causing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified UtAssert_EndTest code that contains useful probe functions that print useful logs to a file \"/tmp/logs/2271.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of UtAssert_EndTest as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of UtAssert_EndTest:\n```c\nvoid UtAssert_EndTest(void)\n{\n    uint32                 Ct;\n    bool                   SegmentValid;\n    UtAssert_TestCounter_t Local_SegmentCounters;\n    char                   Local_SegmentName[sizeof(CurrentSegment)];\n\n    UT_BSP_Lock();\n\n    SegmentValid = (UT_SegmentCounters.TotalTestCases > 0);\n    if (SegmentValid)\n    {\n        ++UT_TotalCounters.TestSegmentCount;\n        UT_SegmentCounters.TestSegmentCount = UT_TotalCounters.TestSegmentCount;\n        UT_TotalCounters.TotalTestCases += UT_SegmentCounters.TotalTestCases;\n        for (Ct = 0; Ct < UTASSERT_CASETYPE_MAX; ++Ct)\n        {\n            UT_TotalCounters.CaseCount[Ct] += UT_SegmentCounters.CaseCount[Ct];\n        }\n        memcpy(&Local_SegmentCounters, &UT_SegmentCounters, sizeof(Local_SegmentCounters));\n\n        /*\n         * note, strcpy is OK because both are fixed size buffers of the same size,\n         * and the null termination on CurrentSegment was locally enforced already\n         */\n        strcpy(Local_SegmentName, CurrentSegment);\n    }\n\n    memset(&UT_SegmentCounters, 0, sizeof(UT_SegmentCounters));\n\n    UT_BSP_Unlock();\n\n    if (SegmentValid)\n    {\n        UtAssert_DoTestSegmentReport(Local_SegmentName, &Local_SegmentCounters);\n    }\n    else\n    {\n        UT_BSP_DoText(UTASSERT_CASETYPE_END, \"No test cases\\n\");\n    }\n}\n```\n</target_code>\nPlease provide the modified UtAssert_EndTest code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n\n/* Probe helper to log state to a file for reproducing the scenario */\nstatic void UtAssert_LogProbe(const char *stage, bool SegmentValid)\n{\n    FILE *f = fopen(\"/tmp/logs/2271.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Log the control stage and key runtime state that can show the violation scenario */\n    fprintf(f, \"Stage: %s\\n\", stage);\n    fprintf(f, \"SegmentValid: %d\\n\", SegmentValid ? 1 : 0);\n\n    /* sizeof(CurrentSegment) is evaluated at compile time here; it reveals if CurrentSegment\n     * was declared as an array (size = array length) or as a pointer (size = pointer size)\n     */\n    fprintf(f, \"sizeof(CurrentSegment) = %zu\\n\", sizeof(CurrentSegment));\n\n    /* Address of CurrentSegment (works for both array and pointer cases) */\n    fprintf(f, \"Address of CurrentSegment = %p\\n\", (void *)CurrentSegment);\n\n    /* Log some segment counters that participate in the control flow */\n    fprintf(f, \"UT_SegmentCounters.TotalTestCases = %llu\\n\", (unsigned long long)UT_SegmentCounters.TotalTestCases);\n    fprintf(f, \"UT_SegmentCounters.TestSegmentCount = %llu\\n\", (unsigned long long)UT_SegmentCounters.TestSegmentCount);\n    fprintf(f, \"UT_TotalCounters.TotalTestCases = %llu\\n\", (unsigned long long)UT_TotalCounters.TotalTestCases);\n    fprintf(f, \"UT_TotalCounters.TestSegmentCount = %llu\\n\", (unsigned long long)UT_TotalCounters.TestSegmentCount);\n\n    fprintf(f, \"---\\n\");\n    fclose(f);\n}\n\nvoid UtAssert_EndTest(void)\n{\n    uint32                 Ct;\n    bool                   SegmentValid;\n    UtAssert_TestCounter_t Local_SegmentCounters;\n    char                   Local_SegmentName[sizeof(CurrentSegment)];\n\n    UT_BSP_Lock();\n\n    /* Log state immediately after obtaining the lock */\n    UtAssert_LogProbe(\"after_lock\", false);\n\n    SegmentValid = (UT_SegmentCounters.TotalTestCases > 0);\n    if (SegmentValid)\n    {\n        /* Log state upon entering the SegmentValid path before updates */\n        UtAssert_LogProbe(\"segment_valid_before_updates\", SegmentValid);\n\n        ++UT_TotalCounters.TestSegmentCount;\n        UT_SegmentCounters.TestSegmentCount = UT_TotalCounters.TestSegmentCount;\n        UT_TotalCounters.TotalTestCases += UT_SegmentCounters.TotalTestCases;\n        for (Ct = 0; Ct < UTASSERT_CASETYPE_MAX; ++Ct)\n        {\n            UT_TotalCounters.CaseCount[Ct] += UT_SegmentCounters.CaseCount[Ct];\n        }\n        memcpy(&Local_SegmentCounters, &UT_SegmentCounters, sizeof(Local_SegmentCounters));\n\n        /*\n         * note, strcpy is OK because both are fixed size buffers of the same size,\n         * and the null termination on CurrentSegment was locally enforced already\n         */\n\n        /* Log details just before performing the strcpy that is implicated in the violation */\n        {\n            FILE *f = fopen(\"/tmp/logs/2271.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"About to strcpy into Local_SegmentName\\n\");\n                fprintf(f, \"sizeof(Local_SegmentName) = %zu\\n\", sizeof(Local_SegmentName));\n                /* sizeof(CurrentSegment) already logged by UtAssert_LogProbe, but repeat here for locality */\n                fprintf(f, \"sizeof(CurrentSegment) = %zu\\n\", sizeof(CurrentSegment));\n                fprintf(f, \"Address of CurrentSegment = %p\\n\", (void *)CurrentSegment);\n                fprintf(f, \"---\\n\");\n                fclose(f);\n            }\n        }\n\n        strcpy(Local_SegmentName, CurrentSegment);\n\n        /* Log after strcpy to capture the result and whether copy completed */\n        {\n            FILE *f = fopen(\"/tmp/logs/2271.txt\", \"a\");\n            if (f != NULL)\n            {\n                fprintf(f, \"After strcpy\\n\");\n                /* Print Local_SegmentName contents up to its compiled size to show what was copied. */\n                /* Use precision specifier to avoid reading beyond the array bounds when printing. */\n                fprintf(f, \"Local_SegmentName (up to %zu bytes): %.*s\\n\", sizeof(Local_SegmentName), (int)sizeof(Local_SegmentName), Local_SegmentName);\n                fprintf(f, \"---\\n\");\n                fclose(f);\n            }\n        }\n    }\n\n    memset(&UT_SegmentCounters, 0, sizeof(UT_SegmentCounters));\n\n    UT_BSP_Unlock();\n\n    /* Log final control decision (whether a segment report will be produced) */\n    if (SegmentValid)\n    {\n        UtAssert_LogProbe(\"before_report_call\", SegmentValid);\n        UtAssert_DoTestSegmentReport(Local_SegmentName, &Local_SegmentCounters);\n    }\n    else\n    {\n        UtAssert_LogProbe(\"no_segment_to_report\", SegmentValid);\n        UT_BSP_DoText(UTASSERT_CASETYPE_END, \"No test cases\\n\");\n    }\n}\n"
}