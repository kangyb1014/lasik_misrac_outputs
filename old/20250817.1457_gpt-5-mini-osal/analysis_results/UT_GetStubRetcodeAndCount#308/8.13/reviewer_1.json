{
  "user_message": "An agent A claimed that the following UT_GetStubRetcodeAndCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubRetcodeAndCount.\n```c\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n        Result   = true;\n    }\n    else\n    {\n        Result = false;\n    }\n\n    return Result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:UT_GetStubRetcodeAndCount declares StubPtr as UT_StubTableEntry_t * but only reads the pointed-to data (Count and Value). The pointer can be const-qualified (const UT_StubTableEntry_t *StubPtr) since the function does not modify the structure. Therefore Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    /* Log entry with the function key */\n    {\n        FILE *log = fopen(\"/tmp/logs/2467.txt\", \"a\");\n        if (log != NULL)\n        {\n            /* FuncKey is printed as an unsigned long long to capture its numeric value for debugging. */\n            fprintf(log, \"UT_GetStubRetcodeAndCount: Enter FuncKey=%llu\\n\", (unsigned long long)FuncKey);\n            fclose(log);\n        }\n    }\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n\n    /* Log the returned pointer value to show whether it is NULL or points to a table entry */\n    {\n        FILE *log = fopen(\"/tmp/logs/2467.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"  UT_GetStubEntry returned StubPtr=%p\\n\", (const void *)StubPtr);\n            fclose(log);\n        }\n    }\n\n    if (StubPtr != NULL)\n    {\n        /* Preserve original logic: read fields from the stub entry. */\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n        Result   = true;\n\n        /* Log the values that were read so others can reproduce the violation scenario evidence. */\n        {\n            FILE *log = fopen(\"/tmp/logs/2467.txt\", \"a\");\n            if (log != NULL)\n            {\n                fprintf(log, \"  Read Count=%d, Retcode=%d from StubPtr=%p\\n\", (int)*Count, (int)*Retcode, (const void *)StubPtr);\n                fprintf(log, \"  Returning Result=true\\n\");\n                fclose(log);\n            }\n        }\n    }\n    else\n    {\n        Result = false;\n\n        /* Log the NULL case so control flow is captured. */\n        FILE *log = fopen(\"/tmp/logs/2467.txt\", \"a\");\n        if (log != NULL)\n        {\n            fprintf(log, \"  StubPtr is NULL. Returning Result=false\\n\");\n            fclose(log);\n        }\n    }\n\n    return Result;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for UT_GetStubRetcodeAndCount. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In UT_GetStubRetcodeAndCount the local pointer StubPtr is only used for read-only access to the pointed-to structure (fields are read but never written), so per MISRA C:2023 Rule 8.13 it should point to a const-qualified type (e.g. const UT_StubTableEntry_t *StubPtr). Assigning the (non-const) return value of UT_GetStubEntry to a pointer-to-const is allowed in C without a cast, and there is no evidence in the shown function that the object is modified via StubPtr or needs to be passed to APIs that require a non-const pointer. The added logging in the test code does not change this assessment. Therefore the reported violation is valid; the simple remediation is to declare StubPtr as const UT_StubTableEntry_t *StubPtr (or otherwise justify why const cannot be used)."
}