{
  "user_message": "An agent A claimed that the following UT_GetStubRetcodeAndCount code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of UT_GetStubRetcodeAndCount.\n```c\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n    if (StubPtr != NULL)\n    {\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n        Result   = true;\n    }\n    else\n    {\n        Result = false;\n    }\n\n    return Result;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local pointer StubPtr is declared as UT_StubTableEntry_t * but is only used to read members (Data.Rc.Count and Data.Rc.Value). It should be declared as a pointer-to-const (const UT_StubTableEntry_t *StubPtr) to indicate no modification of the pointed-to object. Therefore the code fragment 'StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);' with a non-const target pointer violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void UT_LogProbe(UT_EntryKey_t FuncKey,\n                        const UT_StubTableEntry_t *StubPtr,\n                        int32 RetcodeVal,\n                        int32 CountVal,\n                        const char *note)\n{\n    FILE *f = fopen(\"/tmp/logs/2467.txt\", \"a\");\n    if (f != NULL)\n    {\n        /* Print a simple record of the control point and observed state. */\n        (void)fprintf(f, \"UT_GetStubRetcodeAndCount: %s\\n\", note);\n        (void)fprintf(f, \"  FuncKey (repr) = %llu\\n\", (unsigned long long)(uintptr_t)FuncKey);\n        (void)fprintf(f, \"  StubPtr = %p\\n\", (void *)StubPtr);\n        if (StubPtr != NULL)\n        {\n            (void)fprintf(f, \"  Observed Data.Rc.Value = %ld\\n\", (long)RetcodeVal);\n            (void)fprintf(f, \"  Observed Data.Rc.Count = %ld\\n\", (long)CountVal);\n        }\n        (void)fprintf(f, \"\\n\");\n        (void)fclose(f);\n    }\n}\n\nbool UT_GetStubRetcodeAndCount(UT_EntryKey_t FuncKey, int32 *Retcode, int32 *Count)\n{\n    UT_StubTableEntry_t *StubPtr;\n    bool                 Result;\n\n    /* Log entry into the function with the function key. */\n    UT_LogProbe(FuncKey, NULL, 0, 0, \"entering\");\n\n    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);\n\n    /* Log result of lookup (pointer value). */\n    UT_LogProbe(FuncKey, StubPtr, 0, 0, \"after UT_GetStubEntry\");\n\n    if (StubPtr != NULL)\n    {\n        /* Read-only access to the stub table entry members (original logic preserved). */\n        *Count   = StubPtr->Data.Rc.Count;\n        *Retcode = StubPtr->Data.Rc.Value;\n\n        /* Log the values that were read to provide evidence of the read-only usage. */\n        UT_LogProbe(FuncKey, StubPtr, *Retcode, *Count, \"read values\");\n\n        Result   = true;\n    }\n    else\n    {\n        UT_LogProbe(FuncKey, StubPtr, 0, 0, \"stub not found\");\n\n        Result = false;\n    }\n\n    /* Final log record summarizing the exit state. */\n    if (Result != false)\n    {\n        UT_LogProbe(FuncKey, StubPtr, *Retcode, *Count, \"exiting (true)\");\n    }\n    else\n    {\n        UT_LogProbe(FuncKey, StubPtr, 0, 0, \"exiting (false)\");\n    }\n\n    return Result;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for UT_GetStubRetcodeAndCount. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's assessment is correct. In the provided UT_GetStubRetcodeAndCount implementation the local pointer StubPtr is only used to read members (StubPtr->Data.Rc.Count and StubPtr->Data.Rc.Value) and is never used to modify the pointed-to object. MISRA C 2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever possible; therefore StubPtr should be declared as const UT_StubTableEntry_t *StubPtr. Assigning the result of UT_GetStubEntry (which likely returns a non-const UT_StubTableEntry_t *) to a const-qualified pointer is allowed in C and would preserve intent and satisfy the rule. If there is a deliberate need to modify through StubPtr or to pass it to APIs that require a non-const pointer, a documented deviation would be required, but none of that is evident in the snippet. Hence the report of a Rule 8.13 violation is valid."
}