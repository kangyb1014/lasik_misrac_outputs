{
  "user_message": "Target function code is:\n```c\nvoid OS_IdleLoop()\n{\n    /*\n     * Wait until the shutdown value is set to the shutdown number\n     * In most \"real\" embedded systems, this will never happen.\n     * However it will happen in debugging situations (CTRL+C, etc).\n     */\n    while (OS_SharedGlobalVars.GlobalState != OS_SHUTDOWN_MAGIC_NUMBER)\n    {\n        OS_IdleLoop_Impl();\n    }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_IdleLoop': {'callees': ['OS_IdleLoop_Impl', 'UT_ExecuteBasicHandler'], 'callers': ['OS_Application_Run']}, 'OS_IdleLoop_Impl': {'callees': [], 'callers': ['OS_IdleLoop']}, 'UT_ExecuteBasicHandler': {'callees': ['UT_GetStubEntry', 'UT_SetHandlerFunction', 'UT_DefaultStubImpl'], 'callers': ['OS_BinSemCreate', 'OS_BinSemDelete', 'OS_BinSemFlush', 'OS_BinSemGetIdByName', 'OS_BinSemGetInfo', 'OS_BinSemGive', 'OS_BinSemTake', 'OS_BinSemTimedWait', 'OS_GetLocalTime', 'OS_SetLocalTime', 'OS_API_Init', 'OS_API_Teardown', 'OS_ApplicationExit', 'OS_ApplicationShutdown', 'OS_DeleteAllObjects', 'OS_IdleLoop', 'OS_RegisterEventHandler', 'OS_CondVarBroadcast', 'OS_CondVarCreate', 'OS_CondVarDelete', 'OS_CondVarGetIdByName', 'OS_CondVarGetInfo', 'OS_CondVarLock', 'OS_CondVarSignal', 'OS_CondVarTimedWait', 'OS_CondVarUnlock', 'OS_CondVarWait', 'OS_CountSemCreate', 'OS_CountSemDelete', 'OS_CountSemGetIdByName', 'OS_CountSemGetInfo', 'OS_CountSemGive', 'OS_CountSemTake', 'OS_CountSemTimedWait', 'OS_DirectoryClose', 'OS_DirectoryOpen', 'OS_DirectoryRead', 'OS_DirectoryRewind', 'OS_mkdir', 'OS_rmdir', 'OS_GetErrorName', 'OS_StatusToString', 'OS_CloseAllFiles', 'OS_CloseFileByName', 'OS_FDGetInfo', 'OS_FileOpenCheck', 'OS_OpenCreate', 'OS_TimedRead', 'OS_TimedWrite', 'OS_chmod', 'OS_close', 'OS_cp', 'OS_lseek', 'OS_mv', 'OS_read', 'OS_remove', 'OS_rename', 'OS_stat', 'OS_write', 'OS_FS_GetPhysDriveName', 'OS_FileSysAddFixedMap', 'OS_FileSysStatVolume', 'OS_GetFsInfo', 'OS_TranslatePath', 'OS_chkfs', 'OS_initfs', 'OS_mkfs', 'OS_mount', 'OS_rmfs', 'OS_unmount', 'OS_HeapGetInfo', 'OS_ConvertToArrayIndex', 'OS_ForEachObject', 'OS_ForEachObjectOfType', 'OS_GetResourceName', 'OS_IdentifyObject', 'OS_ObjectIdToArrayIndex', 'OS_ModuleInfo', 'OS_ModuleLoad', 'OS_ModuleSymbolLookup', 'OS_ModuleUnload', 'OS_SymbolLookup', 'OS_SymbolTableDump', 'OS_MutSemCreate', 'OS_MutSemDelete', 'OS_MutSemGetIdByName', 'OS_MutSemGetInfo', 'OS_MutSemGive', 'OS_MutSemTake', 'OS_NetworkGetHostName', 'OS_NetworkGetID', 'OS_printf_disable', 'OS_printf_enable', 'OS_QueueCreate', 'OS_QueueDelete', 'OS_QueueGet', 'OS_QueueGetIdByName', 'OS_QueueGetInfo', 'OS_QueuePut', 'OS_SelectFdAdd', 'OS_SelectFdClear', 'OS_SelectFdIsSet', 'OS_SelectFdZero', 'OS_SelectMultiple', 'OS_SelectSingle', 'OS_ShellOutputToFile', 'OS_SocketAccept', 'OS_SocketAddrFromString', 'OS_SocketAddrGetPort', 'OS_SocketAddrInit', 'OS_SocketAddrSetPort', 'OS_SocketAddrToString', 'OS_SocketBind', 'OS_SocketBindAddress', 'OS_SocketConnect', 'OS_SocketGetIdByName', 'OS_SocketGetInfo', 'OS_SocketListen', 'OS_SocketOpen', 'OS_SocketRecvFrom', 'OS_SocketSendTo', 'OS_SocketShutdown', 'OS_TaskCreate', 'OS_TaskDelay', 'OS_TaskDelete', 'OS_TaskExit', 'OS_TaskFindIdBySystemData', 'OS_TaskGetId', 'OS_TaskGetIdByName', 'OS_TaskGetInfo', 'OS_TaskInstallDeleteHandler', 'OS_TaskSetPriority', 'OS_TimerAdd', 'OS_TimerCreate', 'OS_TimerDelete', 'OS_TimerGetIdByName', 'OS_TimerGetInfo', 'OS_TimerSet', 'OS_TimeBaseCreate', 'OS_TimeBaseDelete', 'OS_TimeBaseGetFreeRun', 'OS_TimeBaseGetIdByName', 'OS_TimeBaseGetInfo', 'OS_TimeBaseSet', 'OS_GetBuildNumber', 'OS_GetVersionCodeName', 'OS_GetVersionNumber', 'OS_GetVersionString']}, 'OS_Application_Run': {'callees': ['OS_IdleLoop', 'UtTest_Run'], 'callers': ['main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_SharedGlobalVars (definition and its struct/union/type declarations)",
    "type of OS_SharedGlobalVars.GlobalState (the typedef/enum/underlying type)",
    "OS_SHUTDOWN_MAGIC_NUMBER (macro/constant definition and any macro expansion)",
    "OS_IdleLoop_Impl (prototype and definition)",
    "Any macros used in the above declarations/definitions (e.g. attribute/section/packing macros such as OS_API, PACKED, __attribute__, asm labels, etc.)"
  ],
  "explanation": "- OS_SharedGlobalVars (definition and its struct/union/type declarations): The target function accesses OS_SharedGlobalVars.GlobalState. The variable's declaration or the struct/union that defines it may use compiler extensions (anonymous/unnamed structs or unions, nonstandard bit-field behavior, __attribute__ annotations, asm labels, packed/align directives, etc.). Inspecting the full definition is required to detect such extensions.\n- type of OS_SharedGlobalVars.GlobalState (the typedef/enum/underlying type): The comparison in the while() uses GlobalState; its type could be an enum, typedef, or a nonstandard type that relies on extensions (e.g., typeof, bitfield-only types). The exact type/definition must be checked for extension use.\n- OS_SHUTDOWN_MAGIC_NUMBER (macro/constant definition and any macro expansion): This symbol is used in the comparison and may be defined via macros that use language extensions (statement-expressions, typeof, gcc-specific constant expressions, asm, or attribute-bearing macros). The macro expansion must be inspected.\n- OS_IdleLoop_Impl (prototype and definition): The function is called in the loop body. Its declaration/definition might use language extensions in its prototype (gcc attributes, nested functions, K&R style, variadic nonstandard forms) or inlined body constructs; those must be checked to determine whether the target function (via its call) depends on extensions.\n- Any macros used in the above declarations/definitions (e.g. attribute/section/packing macros such as OS_API, PACKED, __attribute__, asm labels, etc.): Many projects hide compiler-specific extensions behind macros. To be sure the target function does not use language extensions (directly or indirectly via referenced symbols), the definitions of such macros referenced by the above symbols must be examined."
}