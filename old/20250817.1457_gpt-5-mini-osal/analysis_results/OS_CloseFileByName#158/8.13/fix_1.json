{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Open log file to capture control flow and state for debugging the pointer usage */\n    FILE *log_fp = fopen(\"/tmp/logs/1267.txt\", \"a\");\n    if (log_fp)\n    {\n        fprintf(log_fp, \"OS_CloseFileByName called with Filename=\\\"%s\\\"\\n\", (Filename != NULL) ? Filename : \"(null)\");\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log the iterator token and the stream pointer and fields used in this function. */\n        if (log_fp)\n        {\n            fprintf(log_fp, \"Iterator token=%u, stream_ptr=%p\\n\", (unsigned int)iter.token, (void *)stream);\n            if (stream != NULL)\n            {\n                fprintf(log_fp, \"  socket_domain=%d, stream_name=\\\"%s\\\"\\n\",\n                        (int)stream->socket_domain,\n                        (stream->stream_name != NULL) ? stream->stream_name : \"(null)\");\n            }\n            else\n            {\n                fprintf(log_fp, \"  stream is NULL\\n\");\n            }\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            if (log_fp)\n            {\n                fprintf(log_fp, \"  match found for token=%u (stream_name matches Filename)\\n\", (unsigned int)iter.token);\n            }\n\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (log_fp)\n            {\n                fprintf(log_fp, \"  close_code=%d, return_code(before)=%d\\n\", (int)close_code, (int)return_code);\n            }\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n                if (log_fp)\n                {\n                    fprintf(log_fp, \"  return_code(updated)=%d\\n\", (int)return_code);\n                }\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log_fp)\n    {\n        fprintf(log_fp, \"OS_CloseFileByName returning %d\\n\\n\", (int)return_code);\n        fclose(log_fp);\n    }\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp0ckr3wlt/src/src/os/shared/src/osapi-file.c: In function 'OS_CloseFileByName':\n/tmp/tmp0ckr3wlt/src/src/os/shared/src/osapi-file.c:586:13: error: aggregate value used where an integer was expected\n  586 |             fprintf(log_fp, \"Iterator token=%u, stream_ptr=%p\\n\", (unsigned int)iter.token, (void *)stream);\n      |             ^~~~~~~\n/tmp/tmp0ckr3wlt/src/src/os/shared/src/osapi-file.c:603:17: error: aggregate value used where an integer was expected\n  603 |                 fprintf(log_fp, \"  match found for token=%u (stream_name matches Filename)\\n\", (unsigned int)iter.token);\n      |                 ^~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "int32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Open log file to capture control flow and state for debugging the pointer usage */\n    FILE *log_fp = fopen(\"/tmp/logs/1267.txt\", \"a\");\n    if (log_fp)\n    {\n        fprintf(log_fp, \"OS_CloseFileByName called with Filename=\\\"%s\\\"\\n\", (Filename != NULL) ? Filename : \"(null)\");\n    }\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Log the iterator token and the stream pointer and fields used in this function. */\n        if (log_fp)\n        {\n            /* iter.token is an aggregate type in some builds/configurations; print its address instead of trying to\n             * cast it to an integer (which is not allowed for aggregates). */\n            fprintf(log_fp, \"Iterator token=%p, stream_ptr=%p\\n\", (void *)&iter.token, (void *)stream);\n            if (stream != NULL)\n            {\n                fprintf(log_fp, \"  socket_domain=%d, stream_name=\\\"%s\\\"\\n\",\n                        (int)stream->socket_domain,\n                        (stream->stream_name != NULL) ? stream->stream_name : \"(null)\");\n            }\n            else\n            {\n                fprintf(log_fp, \"  stream is NULL\\n\");\n            }\n        }\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            if (log_fp)\n            {\n                /* See note above about iter.token being an aggregate; print its address. */\n                fprintf(log_fp, \"  match found for token=%p (stream_name matches Filename)\\n\", (void *)&iter.token);\n            }\n\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (log_fp)\n            {\n                fprintf(log_fp, \"  close_code=%d, return_code(before)=%d\\n\", (int)close_code, (int)return_code);\n            }\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n                if (log_fp)\n                {\n                    fprintf(log_fp, \"  return_code(updated)=%d\\n\", (int)return_code);\n                }\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    if (log_fp)\n    {\n        fprintf(log_fp, \"OS_CloseFileByName returning %d\\n\\n\", (int)return_code);\n        fclose(log_fp);\n    }\n\n    return return_code;\n}\n",
  "explanation": "The build errors were caused by attempts to cast/print iter.token as an unsigned int even though iter.token is an aggregate type in some builds/configurations. Casting an aggregate to an integer is invalid. To avoid interpreting the aggregate as an integer, I changed the logging to print the address of iter.token using the %p format and (void *)&iter.token. This preserves the original logic while fixing the invalid cast/formatting that caused the compile errors."
}