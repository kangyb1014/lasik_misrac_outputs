{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of OS_CloseFileByName:\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CloseFileByName:\n#define OS_CHECK_POINTER(ptr) BUGCHECK((ptr)!=NULL,OS_INVALID_POINTER)\n...\n#define OS_FS_ERR_PATH_INVALID (-108)\n...\nint32 OS_ObjectIdIterateActive(osal_objtype_t objtype, OS_object_iter_t *iter)\n{\n    return OS_ObjectIdIteratorInit(OS_ObjectFilterActive, NULL, objtype, iter);\n}\n...\ntypedef struct\n{\n    OS_common_record_t * base;\n    OS_ObjectMatchFunc_t match;\n    void *               arg;\n    osal_index_t         limit;\n    OS_object_token_t    token;\n} OS_object_iter_t\n...\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    OS_common_record_t *record;\n    bool                got_next;\n\n    got_next           = false;\n    iter->token.obj_id = OS_OBJECT_ID_UNDEFINED;\n\n    do\n    {\n        ++iter->token.obj_idx;\n        if (iter->token.obj_idx >= iter->limit)\n        {\n            break;\n        }\n\n        record = OS_OBJECT_TABLE_GET(iter->base, iter->token);\n        if (iter->match == NULL || iter->match(iter->arg, &iter->token, record))\n        {\n            iter->token.obj_id = record->active_id;\n            got_next           = true;\n        }\n    } while (!got_next);\n\n    return got_next;\n}\n...\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_stream_internal_record_t OS_stream_table[OS_MAX_NUM_OPEN_FILES]\n...\ntypedef struct\n{\n    char   stream_name[OS_MAX_PATH_LEN];\n    uint8  socket_domain;\n    uint8  socket_type;\n    uint16 stream_state;\n} OS_stream_internal_record_t\n...\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, int32 (*func)(osal_id_t, void *))\n{\n    int32 status;\n\n    /*\n     * This needs to temporarily unlock the global,\n     * call the handler function, then re-lock.\n     */\n    OS_Unlock_Global(&iter->token);\n    status = func(OS_ObjectIdFromToken(&iter->token), iter->arg);\n    OS_Lock_Global(&iter->token);\n\n    return status;\n}\n...\nint32 OS_FileIteratorClose(osal_id_t filedes, void *arg)\n{\n    return OS_close(filedes);\n}\n...\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    OS_ObjectIdTransactionCancel(&iter->token);\n}\n...\n#define OS_SUCCESS (0)\n...\nstatic inline osal_id_t OS_ObjectIdFromToken(const OS_object_token_t *token)\n{\n    return token->obj_id;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation can be determined from the fragment alone. The socket_domain test is used to distinguish sockets from regular file streams and is needed unless there is a project-wide invariant making it redundant. A specific violation scenario would be: if, by design or initialization, every entry iterated under LOCAL_OBJID_TYPE always has stream->socket_domain == OS_SocketDomain_INVALID (i.e. the field is fixed and never set to any other value), then the comparison is executed but redundant \u2014 removing it would not change behavior, which would constitute dead code (Rule 2.2)."
}