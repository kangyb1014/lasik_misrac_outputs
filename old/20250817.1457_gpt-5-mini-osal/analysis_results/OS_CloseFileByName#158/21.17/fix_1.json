{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void OS_CloseFileByName_ProbeLog(const void *stream_ptr, const char *stream_name, const char *filename, int32_t iter_token, int socket_domain)\n{\n    FILE *f = fopen(\"/tmp/logs/1271.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Try to use OS_MAX_PATH_LEN as the bounded maximum length. This symbol\n     * is expected to be defined in the build environment where the original\n     * function lives. If it's not available, compilation will fail which\n     * surfaces the dependency. */\n#ifdef OS_MAX_PATH_LEN\n    size_t bound = (size_t)OS_MAX_PATH_LEN;\n#else\n    size_t bound = 256U; /* Fallback conservative bound if OS_MAX_PATH_LEN not defined */\n#endif\n\n    size_t s_len = 0;\n    size_t f_len = 0;\n\n    /* Use strnlen to compute bounded lengths (avoids scanning unboundedly).\n     * This assumes stream_name buffer has at least 'bound' bytes allocated\n     * (typical for fixed-size filename buffers in the system). */\n    if (stream_name != NULL)\n    {\n        s_len = strnlen(stream_name, bound);\n    }\n    if (filename != NULL)\n    {\n        f_len = strnlen(filename, bound);\n    }\n\n    fprintf(f, \"--- OS_CloseFileByName probe ---\\n\");\n    fprintf(f, \"iterator token: %d\\n\", (int)iter_token);\n    fprintf(f, \"stream object ptr: %p\\n\", stream_ptr);\n    fprintf(f, \"stream->socket_domain: %d\\n\", socket_domain);\n    fprintf(f, \"stream_name ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)stream_name, bound, s_len);\n    fprintf(f, \"Filename ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)filename, bound, f_len);\n\n    /* Dump up to the bounded length bytes in hex for both strings to show\n     * whether a NUL was observed within the bound. */\n    fprintf(f, \"stream_name bytes (hex, up to %zu):\", s_len);\n    for (size_t i = 0; i < s_len; ++i)\n    {\n        unsigned char c = (unsigned char)stream_name[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (s_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"Filename bytes (hex, up to %zu):\", f_len);\n    for (size_t i = 0; i < f_len; ++i)\n    {\n        unsigned char c = (unsigned char)filename[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (f_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"--- end probe ---\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Insert probe logging just before the strcmp that can read beyond\n         * the bounds. The probe logs bounded lengths and the first bytes of\n         * each string so other agents can reproduce and gather evidence. */\n        OS_CloseFileByName_ProbeLog((const void *)stream, stream ? stream->stream_name : NULL, Filename, iter.token, stream ? stream->socket_domain : -1);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp7kjkdtb7/src/src/os/shared/src/osapi-file.c: In function 'OS_CloseFileByName':\n/tmp/tmp7kjkdtb7/src/src/os/shared/src/osapi-file.c:643:110: error: incompatible type for argument 4 of 'OS_CloseFileByName_ProbeLog'\n  643 |         OS_CloseFileByName_ProbeLog((const void *)stream, stream ? stream->stream_name : NULL, Filename, iter.token, stream ? stream->socket_domain : -1);\n      |                                                                                                          ~~~~^~~~~~\n      |                                                                                                              |\n      |                                                                                                              OS_object_token_t {aka struct OS_object_token}\n/tmp/tmp7kjkdtb7/src/src/os/shared/src/osapi-file.c:558:120: note: expected 'int32_t' {aka 'int'} but argument is of type 'OS_object_token_t' {aka 'struct OS_object_token'}\n  558 | static void OS_CloseFileByName_ProbeLog(const void *stream_ptr, const char *stream_name, const char *filename, int32_t iter_token, int socket_domain)\n      |                                                                                                                ~~~~~~~~^~~~~~~~~~\ngmake[2]: *** [CMakeFiles/osal.dir/build.make:174: CMakeFiles/osal.dir/src/os/shared/src/osapi-file.c.o] Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:762: CMakeFiles/osal.dir/all] Error 2\ngmake: *** [Makefile:146: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void OS_CloseFileByName_ProbeLog(const void *stream_ptr, const char *stream_name, const char *filename, OS_object_token_t iter_token, int socket_domain)\n{\n    FILE *f = fopen(\"/tmp/logs/1271.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Try to use OS_MAX_PATH_LEN as the bounded maximum length. This symbol\n     * is expected to be defined in the build environment where the original\n     * function lives. If it's not available, compilation will fail which\n     * surfaces the dependency. */\n#ifdef OS_MAX_PATH_LEN\n    size_t bound = (size_t)OS_MAX_PATH_LEN;\n#else\n    size_t bound = 256U; /* Fallback conservative bound if OS_MAX_PATH_LEN not defined */\n#endif\n\n    size_t s_len = 0;\n    size_t f_len = 0;\n\n    /* Use strnlen to compute bounded lengths (avoids scanning unboundedly).\n     * This assumes stream_name buffer has at least 'bound' bytes allocated\n     * (typical for fixed-size filename buffers in the system). */\n    if (stream_name != NULL)\n    {\n        s_len = strnlen(stream_name, bound);\n    }\n    if (filename != NULL)\n    {\n        f_len = strnlen(filename, bound);\n    }\n\n    fprintf(f, \"--- OS_CloseFileByName probe ---\\n\");\n    /* iter_token is a struct; print its address to avoid making assumptions\n     * about its internal representation. */\n    fprintf(f, \"iterator token (addr): %p\\n\", (const void *)&iter_token);\n    fprintf(f, \"stream object ptr: %p\\n\", stream_ptr);\n    fprintf(f, \"stream->socket_domain: %d\\n\", socket_domain);\n    fprintf(f, \"stream_name ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)stream_name, bound, s_len);\n    fprintf(f, \"Filename ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)filename, bound, f_len);\n\n    /* Dump up to the bounded length bytes in hex for both strings to show\n     * whether a NUL was observed within the bound. */\n    fprintf(f, \"stream_name bytes (hex, up to %zu):\", s_len);\n    for (size_t i = 0; i < s_len; ++i)\n    {\n        unsigned char c = (unsigned char)stream_name[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (s_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"Filename bytes (hex, up to %zu):\", f_len);\n    for (size_t i = 0; i < f_len; ++i)\n    {\n        unsigned char c = (unsigned char)filename[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (f_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"--- end probe ---\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Insert probe logging just before the strcmp that can read beyond\n         * the bounds. The probe logs bounded lengths and the first bytes of\n         * each string so other agents can reproduce and gather evidence. */\n        OS_CloseFileByName_ProbeLog((const void *)stream, stream ? stream->stream_name : NULL, Filename, iter.token, stream ? stream->socket_domain : -1);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n",
  "explanation": "The compile error was because iter.token is of type OS_object_token_t (a struct) while OS_CloseFileByName_ProbeLog expected an int32_t. I changed the probe function's 4th parameter to OS_object_token_t so the types match. Inside the probe I replaced the integer-format print of the token with printing the token's address (using %p and &iter_token) to avoid making assumptions about the struct's internal fields. No other logic was altered."
}