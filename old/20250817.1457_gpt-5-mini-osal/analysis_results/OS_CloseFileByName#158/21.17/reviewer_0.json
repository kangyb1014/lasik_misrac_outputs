{
  "user_message": "An agent A claimed that the following OS_CloseFileByName code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of OS_CloseFileByName.\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential violation: the call strcmp(stream->stream_name, Filename) can read past the bounds of the referenced objects if either string is not NUL-terminated within its allocated buffer. For example, if stream->stream_name contains OS_MAX_PATH_LEN characters with no terminating '\\0' (e.g. a previous write filled the buffer without appending a terminator) or if Filename points to a non-terminated/overlong buffer, strcmp will scan beyond the array bounds and cause an out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void OS_CloseFileByName_ProbeLog(const void *stream_ptr, const char *stream_name, const char *filename, OS_object_token_t iter_token, int socket_domain)\n{\n    FILE *f = fopen(\"/tmp/logs/1271.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Try to use OS_MAX_PATH_LEN as the bounded maximum length. This symbol\n     * is expected to be defined in the build environment where the original\n     * function lives. If it's not available, compilation will fail which\n     * surfaces the dependency. */\n#ifdef OS_MAX_PATH_LEN\n    size_t bound = (size_t)OS_MAX_PATH_LEN;\n#else\n    size_t bound = 256U; /* Fallback conservative bound if OS_MAX_PATH_LEN not defined */\n#endif\n\n    size_t s_len = 0;\n    size_t f_len = 0;\n\n    /* Use strnlen to compute bounded lengths (avoids scanning unboundedly).\n     * This assumes stream_name buffer has at least 'bound' bytes allocated\n     * (typical for fixed-size filename buffers in the system). */\n    if (stream_name != NULL)\n    {\n        s_len = strnlen(stream_name, bound);\n    }\n    if (filename != NULL)\n    {\n        f_len = strnlen(filename, bound);\n    }\n\n    fprintf(f, \"--- OS_CloseFileByName probe ---\\n\");\n    /* iter_token is a struct; print its address to avoid making assumptions\n     * about its internal representation. */\n    fprintf(f, \"iterator token (addr): %p\\n\", (const void *)&iter_token);\n    fprintf(f, \"stream object ptr: %p\\n\", stream_ptr);\n    fprintf(f, \"stream->socket_domain: %d\\n\", socket_domain);\n    fprintf(f, \"stream_name ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)stream_name, bound, s_len);\n    fprintf(f, \"Filename ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)filename, bound, f_len);\n\n    /* Dump up to the bounded length bytes in hex for both strings to show\n     * whether a NUL was observed within the bound. */\n    fprintf(f, \"stream_name bytes (hex, up to %zu):\", s_len);\n    for (size_t i = 0; i < s_len; ++i)\n    {\n        unsigned char c = (unsigned char)stream_name[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (s_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"Filename bytes (hex, up to %zu):\", f_len);\n    for (size_t i = 0; i < f_len; ++i)\n    {\n        unsigned char c = (unsigned char)filename[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (f_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"--- end probe ---\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Insert probe logging just before the strcmp that can read beyond\n         * the bounds. The probe logs bounded lengths and the first bytes of\n         * each string so other agents can reproduce and gather evidence. */\n        OS_CloseFileByName_ProbeLog((const void *)stream, stream ? stream->stream_name : NULL, Filename, iter.token, stream ? stream->socket_domain : -1);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for OS_CloseFileByName. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. strcmp scans each argument until a NUL byte and therefore can read past the end of the referenced object if either operand is not NUL-terminated within its allocated storage. In the shown code there is only a null-pointer check for Filename (OS_CHECK_POINTER) and no explicit guarantee or check in this function that stream->stream_name or Filename are NUL-terminated or that strlen will be bounded. MISRA C 2023 Rule 21.17 requires that use of string.h functions must not result in accesses beyond object bounds unless there is a documented, provable guarantee that the objects contain a NUL within their allocated size. Since no such guarantee or bounded check is present here, the call strcmp(stream->stream_name, Filename) is a potential violation of Rule 21.17. To fix, the code must either (a) use a bounded comparison (e.g. strncmp with a known maximum length and ensure buffers contain a terminator or handle exact-length records safely), or (b) provide and document a provable invariant that both strings are NUL-terminated within their allocated bounds (and show evidence or static analysis that enforces this)."
}