{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nPotential violation: the call strcmp(stream->stream_name, Filename) can read past the bounds of the referenced objects if either string is not NUL-terminated within its allocated buffer. For example, if stream->stream_name contains OS_MAX_PATH_LEN characters with no terminating '\\0' (e.g. a previous write filled the buffer without appending a terminator) or if Filename points to a non-terminated/overlong buffer, strcmp will scan beyond the array bounds and cause an out-of-bounds access.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified OS_CloseFileByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/1271.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of OS_CloseFileByName:\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nPlease provide the modified OS_CloseFileByName code.\n",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n/* Probe helper: append diagnostic information to /tmp/logs/1271.txt\n * This helper attempts to avoid reading beyond the known stream name buffer\n * by using OS_MAX_PATH_LEN as the bounded length for both strings. It logs\n * addresses, bounded lengths, and the first bytes (in hex) of each string\n * to help reproduce the out-of-bounds scan scenario without changing the\n * original control flow. */\nstatic void OS_CloseFileByName_ProbeLog(const void *stream_ptr, const char *stream_name, const char *filename, int32_t iter_token, int socket_domain)\n{\n    FILE *f = fopen(\"/tmp/logs/1271.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    /* Try to use OS_MAX_PATH_LEN as the bounded maximum length. This symbol\n     * is expected to be defined in the build environment where the original\n     * function lives. If it's not available, compilation will fail which\n     * surfaces the dependency. */\n#ifdef OS_MAX_PATH_LEN\n    size_t bound = (size_t)OS_MAX_PATH_LEN;\n#else\n    size_t bound = 256U; /* Fallback conservative bound if OS_MAX_PATH_LEN not defined */\n#endif\n\n    size_t s_len = 0;\n    size_t f_len = 0;\n\n    /* Use strnlen to compute bounded lengths (avoids scanning unboundedly).\n     * This assumes stream_name buffer has at least 'bound' bytes allocated\n     * (typical for fixed-size filename buffers in the system). */\n    if (stream_name != NULL)\n    {\n        s_len = strnlen(stream_name, bound);\n    }\n    if (filename != NULL)\n    {\n        f_len = strnlen(filename, bound);\n    }\n\n    fprintf(f, \"--- OS_CloseFileByName probe ---\\n\");\n    fprintf(f, \"iterator token: %d\\n\", (int)iter_token);\n    fprintf(f, \"stream object ptr: %p\\n\", stream_ptr);\n    fprintf(f, \"stream->socket_domain: %d\\n\", socket_domain);\n    fprintf(f, \"stream_name ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)stream_name, bound, s_len);\n    fprintf(f, \"Filename ptr: %p, bounded_length(strnlen, %zu): %zu\\n\", (const void *)filename, bound, f_len);\n\n    /* Dump up to the bounded length bytes in hex for both strings to show\n     * whether a NUL was observed within the bound. */\n    fprintf(f, \"stream_name bytes (hex, up to %zu):\", s_len);\n    for (size_t i = 0; i < s_len; ++i)\n    {\n        unsigned char c = (unsigned char)stream_name[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (s_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"Filename bytes (hex, up to %zu):\", f_len);\n    for (size_t i = 0; i < f_len; ++i)\n    {\n        unsigned char c = (unsigned char)filename[i];\n        fprintf(f, \" %02x\", c);\n    }\n    if (f_len == bound) fprintf(f, \" (no NUL within bound)\");\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"--- end probe ---\\n\\n\");\n    fclose(f);\n}\n\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        /* Insert probe logging just before the strcmp that can read beyond\n         * the bounds. The probe logs bounded lengths and the first bytes of\n         * each string so other agents can reproduce and gather evidence. */\n        OS_CloseFileByName_ProbeLog((const void *)stream, stream ? stream->stream_name : NULL, Filename, iter.token, stream ? stream->socket_domain : -1);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n"
}