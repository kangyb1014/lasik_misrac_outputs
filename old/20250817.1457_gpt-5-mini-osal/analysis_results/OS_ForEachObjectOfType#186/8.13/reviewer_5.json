{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code passes &filter (type OS_creator_filter_t *) to OS_ObjectIdIteratorInit which accepts a plain void *matcharg, and the callback OS_ForEachFilterCreator (void *ref) and the handler OS_ForEachDoCallback (void *ref) also take non-const pointers even though they only read from the pointed-to filter. According to MISRA C 2023 Rule 8.13 these pointers should be to const-qualified types (e.g. const void *matcharg, bool OS_ForEachFilterCreator(const void *ref, ...), int32 OS_ForEachDoCallback(osal_id_t, const void *)) whenever possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/1491.txt\", \"a\");\n    if (f)\n    {\n        fputs(msg, f);\n        fputc('\\n', f);\n        fclose(f);\n    }\n}\n\nstatic bool OS_ForEachFilterCreator(void *arg, const OS_object_token_t *token, const OS_common_record_t *record)\n{\n    char buf[200];\n\n    (void)token;\n    (void)record;\n\n    if (arg == NULL)\n    {\n        probe_log(\"OS_ForEachFilterCreator: arg == NULL\");\n        return true; /* accept by default */\n    }\n\n    /* Cast to the actual filter type and log field values and addresses */\n    OS_creator_filter_t *flt = (OS_creator_filter_t *)arg;\n\n    snprintf(buf, sizeof(buf), \"OS_ForEachFilterCreator: arg=%p, creator_id=%u, user_callback=%p, user_arg=%p\",\n             (void *)arg, (unsigned)flt->creator_id, (void *)flt->user_callback, flt->user_arg);\n    probe_log(buf);\n\n    /* Only read fields to mimic the real filter's behavior */\n    (void)flt->creator_id;\n    (void)flt->user_callback;\n    (void)flt->user_arg;\n\n    /* Return true to include entries in this simplified test harness */\n    return true;\n}\nstatic int32_t OS_ForEachDoCallback(osal_id_t id, void *ref)\n{\n    char buf[200];\n\n    if (ref == NULL)\n    {\n        snprintf(buf, sizeof(buf), \"OS_ForEachDoCallback: id=%u, ref==NULL\", (unsigned)id);\n        probe_log(buf);\n        return 0;\n    }\n\n    OS_creator_filter_t *flt = (OS_creator_filter_t *)ref;\n    snprintf(buf, sizeof(buf), \"OS_ForEachDoCallback: id=%u, ref=%p, creator_id=%u, user_arg=%p\",\n             (unsigned)id, (void *)ref, (unsigned)flt->creator_id, flt->user_arg);\n    probe_log(buf);\n\n    /* Only read, do not modify flt */\n    (void)flt->user_callback;\n\n    return 0; /* return value unused by caller in this simplified harness */\n}\nint32 OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t idtype, OS_object_iter_t *iter)\n{\n    char buf[200];\n\n    if (iter == NULL)\n    {\n        probe_log(\"OS_ObjectIdIteratorInit: iter == NULL\");\n        return -1;\n    }\n\n    /* Save the matcharg so we can pass it to the do-callback later */\n    iter->matcharg = matcharg;\n\n    /* Log the incoming matcharg pointer and the idtype for evidence */\n    snprintf(buf, sizeof(buf), \"OS_ObjectIdIteratorInit: matcharg=%p, idtype=%u\", matcharg, (unsigned)idtype);\n    probe_log(buf);\n\n    /* Call the provided matchfunc (if any) to demonstrate the original usage; pass NULLs for token/record */\n    if (matchfunc != NULL)\n    {\n        bool keep = matchfunc(matcharg, NULL, NULL);\n        snprintf(buf, sizeof(buf), \"OS_ObjectIdIteratorInit: matchfunc returned %d\", keep ? 1 : 0);\n        probe_log(buf);\n    }\n\n    /* Populate a small fixed set of ids to iterate over in this test harness */\n    iter->entries[0] = (osal_id_t)100;\n    iter->entries[1] = (osal_id_t)101;\n    iter->entries[2] = (osal_id_t)102;\n    iter->entries[3] = (osal_id_t)0; /* unused */\n    iter->count = 3;\n    iter->index = 0;\n\n    probe_log(\"OS_ObjectIdIteratorInit: iterator initialized\");\n\n    return OS_SUCCESS;\n}\nbool OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    char buf[120];\n\n    if (iter == NULL)\n    {\n        probe_log(\"OS_ObjectIdIteratorGetNext: iter == NULL\");\n        return false;\n    }\n\n    if (iter->index < iter->count)\n    {\n        snprintf(buf, sizeof(buf), \"OS_ObjectIdIteratorGetNext: next index=%zu, id=%u\", iter->index, (unsigned)iter->entries[iter->index]);\n        probe_log(buf);\n        return true;\n    }\n\n    probe_log(\"OS_ObjectIdIteratorGetNext: no more entries\");\n    return false;\n}\nint32 OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, OS_ObjectIdIteratorProcessFunc_t func)\n{\n    char buf[120];\n\n    if (iter == NULL)\n    {\n        probe_log(\"OS_ObjectIdIteratorProcessEntry: iter == NULL\");\n        return -1;\n    }\n\n    if (iter->index >= iter->count)\n    {\n        probe_log(\"OS_ObjectIdIteratorProcessEntry: index out of range\");\n        return -1;\n    }\n\n    osal_id_t id = iter->entries[iter->index];\n    snprintf(buf, sizeof(buf), \"OS_ObjectIdIteratorProcessEntry: processing id=%u at index=%zu with matcharg=%p\",\n             (unsigned)id, iter->index, iter->matcharg);\n    probe_log(buf);\n\n    if (func != NULL)\n    {\n        (void)func(id, iter->matcharg);\n    }\n\n    /* Move to next entry */\n    iter->index++;\n\n    return 0;\n}\nvoid OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    (void)iter; /* nothing to do in this simplified harness */\n    probe_log(\"OS_ObjectIdIteratorDestroy: iterator destroyed\");\n}\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n    char buf[200];\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    /* Log the construction of the filter and the address that will be passed (evidence for the violation) */\n    snprintf(buf, sizeof(buf), \"OS_ForEachObjectOfType: prepared filter at %p -> creator_id=%u, user_callback=%p, user_arg=%p\",\n             (void *)&filter, (unsigned)filter.creator_id, (void *)filter.user_callback, filter.user_arg);\n    probe_log(buf);\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        probe_log(\"OS_ForEachObjectOfType: iterator init succeeded\");\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            /* Use the project's process-entry API; pass an adapter that matches the expected callback type */\n            OS_ObjectIdIteratorProcessEntry(&iter, (OS_ObjectIdIteratorProcessFunc_t)OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n    else\n    {\n        probe_log(\"OS_ForEachObjectOfType: iterator init failed\");\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct. MISRA C 2023 Rule 8.13 requires that a pointer should point to a const\u2011qualified type whenever the pointed\u2011to object is not modified through that pointer. In the code shown: \u2022 OS_ForEachObjectOfType constructs a local OS_creator_filter_t and passes &filter to OS_ObjectIdIteratorInit which is declared to take a plain void *matcharg. \u2022 The iterator stores that matcharg and later passes it to two callbacks (the match function and the per\u2011entry process function) whose prototypes also take non\u2011const void * parameters, although the callbacks only read the pointed fields. Because the pointed\u2011to object is not modified, the appropriate declarations would be const void *matcharg and callback parameters taking pointers to const (or specific const OS_creator_filter_t *), and the iterator\u2019s matcharg storage would likewise be const\u2011qualified. As written, the API and callbacks use non\u2011const pointer types even though const would be sufficient, which violates Rule 8.13. (The failing compilation of the test harness does not change the conceptual MISRA violation; the problem is in the non\u2011const declarations in the API/callback types rather than in the single call site.)"
}