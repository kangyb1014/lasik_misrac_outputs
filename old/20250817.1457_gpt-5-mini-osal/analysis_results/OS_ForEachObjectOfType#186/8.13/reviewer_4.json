{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The iterator argument ('matcharg') and the iterator storage ('iter->arg') are plain void* but are only used as read\u2011only context in the match callback (e.g. OS_ForEachFilterCreator casts the ref to OS_creator_filter_t* and only reads its fields). Specifically the assignment iter->arg = matcharg stores a pointer that should be const-qualified (and the match function type OS_ObjectMatchFunc_t should take a const void * for the context). Because these pointers are not const-qualified though they are used only for reading, Rule 8.13 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef uint32_t osal_objtype_t;\ntypedef uint32_t osal_id_t;\ntypedef void (*OS_ArgCallback_t)(void *arg);\ntypedef struct\n{\n    int idx;\n    int max;\n    void *arg; /* the iterator stores a context pointer (non-const) */\n} OS_object_iter_t;\ntypedef int (*OS_ObjectMatchFunc_t)(void *matcharg, osal_objtype_t type, OS_object_iter_t *iter);\nstatic const int OS_SUCCESS = 0;\nstatic void probe_log(const char *fmt, ...)\n{\n    struct stat st;\n    (void)stat(\"/tmp/logs\", &st); /* attempt to detect directory */\n    /* Attempt to create directory if it doesn't exist; ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0755);\n\n    FILE *f = fopen(\"/tmp/logs/1491.txt\", \"a\");\n    if (f == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nstatic int OS_ObjectIdIteratorInit(OS_ObjectMatchFunc_t matchfunc, void *matcharg, osal_objtype_t type, OS_object_iter_t *iter)\n{\n    if (iter == NULL)\n    {\n        probe_log(\"OS_ObjectIdIteratorInit: iter == NULL\");\n        return -1;\n    }\n\n    iter->idx = 0;\n    iter->max = 2; /* simulate two matching entries */\n\n    /* Simulate the real iterator storing the matcharg pointer into\n       iter->arg (non-const). This is the assignment that the violation\n       report references (iter->arg = matcharg). Log both addresses. */\n    iter->arg = matcharg;\n\n    probe_log(\"OS_ObjectIdIteratorInit: matchfunc=%p, matcharg=%p, type=%llu, iter=%p\", (void *)matchfunc, matcharg, (unsigned long long)type, (void *)iter);\n    probe_log(\"OS_ObjectIdIteratorInit: iter->arg set to %p (matcharg)\", iter->arg);\n\n    /* Optionally invoke the match function to simulate any side-effects */\n    if (matchfunc != NULL)\n    {\n        int rc = matchfunc(matcharg, type, iter);\n        probe_log(\"OS_ObjectMatchFunc returned %d\", rc);\n    }\n\n    return OS_SUCCESS;\n}\nstatic int OS_ObjectIdIteratorGetNext(OS_object_iter_t *iter)\n{\n    if (iter == NULL)\n    {\n        probe_log(\"OS_ObjectIdIteratorGetNext: iter == NULL\");\n        return 0;\n    }\n\n    if (iter->idx < iter->max)\n    {\n        iter->idx++;\n        probe_log(\"OS_ObjectIdIteratorGetNext: returning true (idx=%d of max=%d)\", iter->idx, iter->max);\n        return 1;\n    }\n\n    probe_log(\"OS_ObjectIdIteratorGetNext: returning false (idx=%d of max=%d)\", iter->idx, iter->max);\n    return 0;\n}\nstatic void OS_ObjectIdIteratorProcessEntry(OS_object_iter_t *iter, void (*process)(OS_object_iter_t *))\n{\n    probe_log(\"OS_ObjectIdIteratorProcessEntry: iter=%p, process=%p, iter->arg=%p\", (void *)iter, (void *)process, iter ? iter->arg : NULL);\n    if (process != NULL)\n    {\n        process(iter);\n    }\n}\nstatic void OS_ObjectIdIteratorDestroy(OS_object_iter_t *iter)\n{\n    probe_log(\"OS_ObjectIdIteratorDestroy: iter=%p\", (void *)iter);\n    /* nothing to do in stub */\n}\nstatic int OS_ForEachFilterCreator(void *matcharg, osal_objtype_t type, OS_object_iter_t *iter)\n{\n    probe_log(\"OS_ForEachFilterCreator: called with matcharg=%p, type=%llu, iter=%p\", matcharg, (unsigned long long)type, (void *)iter);\n    /* We do not modify matcharg; treat it as read-only context. */\n    return 1;\n}\nstatic void OS_ForEachDoCallback(OS_object_iter_t *iter)\n{\n    probe_log(\"OS_ForEachDoCallback: entered with iter=%p, iter->arg=%p\", (void *)iter, iter ? iter->arg : NULL);\n\n    if (iter == NULL || iter->arg == NULL)\n    {\n        probe_log(\"OS_ForEachDoCallback: nothing to do (null)\");\n        return;\n    }\n\n    /* Cast iter->arg to the filter type to access the user callback and arg. */\n    OS_creator_filter_t *filter = (OS_creator_filter_t *)iter->arg;\n\n    probe_log(\"OS_ForEachDoCallback: interpreted iter->arg as OS_creator_filter_t*=%p; creator_id=%u, user_callback=%p, user_arg=%p\",\n              (void *)filter, (unsigned)filter->creator_id, (void *)filter->user_callback, filter->user_arg);\n\n    /* Invoke the user's callback (if present). */\n    if (filter->user_callback != NULL)\n    {\n        probe_log(\"OS_ForEachDoCallback: invoking user_callback with user_arg=%p\", filter->user_arg);\n        filter->user_callback(filter->user_arg);\n    }\n}\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    /* Log entry state: arguments and addresses */\n    probe_log(\"OS_ForEachObjectOfType: entry idtype=%llu, creator_id=%u, callback_ptr=%p, callback_arg=%p, &filter=%p, &iter=%p\",\n              (unsigned long long)idtype, (unsigned)creator_id, (void *)callback_ptr, callback_arg, (void *)&filter, (void *)&iter);\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        probe_log(\"OS_ForEachObjectOfType: iterator initialized successfully; iter->arg=%p (should equal matcharg=&filter)\", iter.arg);\n\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            probe_log(\"OS_ForEachObjectOfType: processing next entry (iter=%p, iter->arg=%p)\", (void *)&iter, iter.arg);\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n        probe_log(\"OS_ForEachObjectOfType: iterator destroyed\");\n    }\n    else\n    {\n        probe_log(\"OS_ForEachObjectOfType: OS_ObjectIdIteratorInit failed\");\n    }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 R8.13 recommends that a pointer should point to a const-qualified type when that pointer is only used to read the pointee. However, you cannot declare things const in isolation if the pointer types are part of an API (function pointer typedefs, iterator struct fields, and iterator callbacks) that is used across translation units or must remain compatible with existing callers. In the snippet the iterator field iter->arg and the match callback parameter are declared as plain void* by the API. From the provided local implementation the pointed-to data is indeed only read, so making these particular local variables const would be possible; but changing the typedefs/struct fields in the public API (OS_ObjectMatchFunc_t, iter->arg, OS_ObjectIdIteratorInit etc.) is a cross-API change and cannot be assumed possible without broader context. MISRA\u2019s wording is \u201cwhenever possible\u201d; here it may not be possible because the pointer types form part of the API and might be used by other code that expects non-const. Also the supplied test stub failed to compile (missing OS_creator_filter_t and other headers), so no build evidence was produced. If, in your project, the API is private and you can safely make the callback and iterator context pointers const (i.e. change OS_ObjectMatchFunc_t to take const void * and iter->arg to const void *), then that would satisfy R8.13. As written, however, given the API-level types, the claim that the shown code violates R8.13 is not justified."
}