{
  "user_message": "An agent A claimed that the following OS_ForEachObjectOfType code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of OS_ForEachObjectOfType.\n```c\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    if (OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter) == OS_SUCCESS)\n    {\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n        }\n\n        OS_ObjectIdIteratorDestroy(&iter);\n    }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function OS_ForEachFilterCreator accepts a non-const void *ref and immediately assigns it to a non-const OS_creator_filter_t *filter, but the function only reads from the filter (filter->creator_id) and does not modify it. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Here the parameter and the local pointer could be const (e.g. change the parameter to const void *ref or the local pointer to const OS_creator_filter_t *filter = ref), so the current code violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_logf(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/1491.txt\", \"a\");\n    if (fp == NULL)\n    {\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n\n    fputc('\\n', fp);\n    fclose(fp);\n}\n\nvoid OS_ForEachObjectOfType(osal_objtype_t idtype, osal_id_t creator_id, OS_ArgCallback_t callback_ptr,\n                            void *callback_arg)\n{\n    OS_object_iter_t    iter;\n    OS_creator_filter_t filter;\n\n    /* Log entry and incoming parameter values (addresses/values) */\n    probe_logf(\"OS_ForEachObjectOfType ENTRY: idtype=%llu, creator_id=%llu, callback_ptr_addr=%p, callback_arg=%p\",\n               (unsigned long long)(uintptr_t)idtype,\n               (unsigned long long)(uintptr_t)creator_id,\n               (const void *)&callback_ptr,\n               callback_arg);\n\n    filter.creator_id    = creator_id;\n    filter.user_callback = callback_ptr;\n    filter.user_arg      = callback_arg;\n\n    /* Log the constructed filter state and its address before passing to iterator init */\n    probe_logf(\"Filter constructed: &filter=%p, filter.creator_id=%llu, filter.user_callback_addr=%p, filter.user_arg=%p\",\n               (const void *)&filter,\n               (unsigned long long)(uintptr_t)filter.creator_id,\n               (const void *)&filter.user_callback,\n               filter.user_arg);\n\n    /* Preserve original logic while capturing the return code for logging */\n    int init_status = OS_ObjectIdIteratorInit(OS_ForEachFilterCreator, &filter, idtype, &iter);\n    probe_logf(\"OS_ObjectIdIteratorInit returned: %d\", init_status);\n\n    if (init_status == OS_SUCCESS)\n    {\n        probe_logf(\"Iterator initialized successfully. Entering iteration loop. iterator_addr=%p\", (const void *)&iter);\n\n        unsigned long long iter_count = 0ULL;\n        while (OS_ObjectIdIteratorGetNext(&iter))\n        {\n            iter_count++;\n            probe_logf(\"Iterator got next (iteration #%llu). iterator_addr=%p\", iter_count, (const void *)&iter);\n\n            /* Log just before processing each entry */\n            probe_logf(\"Processing entry #%llu with OS_ObjectIdIteratorProcessEntry (iterator_addr=%p)\", iter_count, (const void *)&iter);\n            OS_ObjectIdIteratorProcessEntry(&iter, OS_ForEachDoCallback);\n\n            /* Optionally log after processing this entry */\n            probe_logf(\"Processed entry #%llu\", iter_count);\n        }\n\n        probe_logf(\"Iteration loop complete. total_iterations=%llu\", iter_count);\n\n        OS_ObjectIdIteratorDestroy(&iter);\n        probe_logf(\"Iterator destroyed. iterator_addr=%p\", (const void *)&iter);\n    }\n    else\n    {\n        probe_logf(\"Iterator initialization failed (status=%d). Skipping iteration.\", init_status);\n    }\n\n    probe_logf(\"OS_ForEachObjectOfType EXIT: idtype=%llu, creator_id=%llu\", (unsigned long long)(uintptr_t)idtype, (unsigned long long)(uintptr_t)creator_id);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nOS_ForEachObjectOfType ENTRY: idtype=9, creator_id=0, callback_ptr_addr=0x7fff0de23ea0, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23ec0, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23ec8, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=9, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=8, creator_id=0, callback_ptr_addr=0x7fff0de23ea0, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23ec0, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23ec8, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=8, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=1, creator_id=0, callback_ptr_addr=0x7fff0de23ea0, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23ec0, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23ec8, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=1, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=0, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=0, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=1, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=1, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=2, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=2, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=3, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=3, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=4, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=4, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=5, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=5, creator_id=0\nOS_ForEachObjectOfType ENTRY: idtype=6, creator_id=0, callback_ptr_addr=0x7fff0de23e60, callback_arg=0x7fff0de23f30\nFilter constructed: &filter=0x7fff0de23e80, filter.creator_id=0, filter.user_callback_addr=0x7fff0de23e88, filter.user_arg=0x7fff0de23f30\nOS_ObjectIdIteratorInit returned: -35\nIterator initialization failed (status=-35). Skipping iteration.\nOS_ForEachObjectOfType EXIT: idtype=6, creator_id=0\nOS_For\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The reported issue is a genuine application of MISRA C 2023 Rule 8.13: if a function receives a pointer to data that it only reads, the pointer parameter (and any local pointer bound to it) should be const-qualified. In the described scenario OS_ForEachFilterCreator is declared to take a non-const void *ref and immediately binds it to a non-const OS_creator_filter_t *filter but only reads fields from that filter. That means the parameter and the local pointer could and should be const (for example const void *ref or const OS_creator_filter_t *filter = ref). Making the pointer const would satisfy Rule 8.13 and is permitted because a non-const object may be passed to a function expecting a pointer-to-const without a cast. Therefore the report is correct."
}