{
  "user_message": "Target function code is:\n```c\nint32 OS_Posix_TimeBaseAPI_Impl_Init(void)\n{\n    int                 status;\n    osal_index_t        idx;\n    pthread_mutexattr_t mutex_attr;\n    struct timespec     clock_resolution;\n    int32               return_code;\n\n    return_code = OS_SUCCESS;\n\n    do\n    {\n        /*\n        ** Mark all timers as available\n        */\n        memset(OS_impl_timebase_table, 0, sizeof(OS_impl_timebase_table));\n\n        /*\n        ** get the resolution of the selected clock\n        */\n        status = clock_getres(OS_PREFERRED_CLOCK, &clock_resolution);\n        if (status != 0)\n        {\n            OS_DEBUG(\"failed in clock_getres: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Convert to microseconds\n        ** Note that the resolution MUST be in the sub-second range, if not then\n        ** it looks like the POSIX timer API in the C library is broken.\n        ** Note for any flavor of RTOS we would expect <= 1ms.  Even a \"desktop\"\n        ** linux or development system should be <= 100ms absolute worst-case.\n        */\n        if (clock_resolution.tv_sec > 0)\n        {\n            return_code = OS_TIMER_ERR_INTERNAL;\n            break;\n        }\n\n        /* Round to the nearest microsecond */\n        POSIX_GlobalVars.ClockAccuracyNsec = (uint32)(clock_resolution.tv_nsec);\n\n        /*\n        ** initialize the attribute with default values\n        */\n        status = pthread_mutexattr_init(&mutex_attr);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_init failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n        ** Allow the mutex to use priority inheritance\n        */\n        status = pthread_mutexattr_setprotocol(&mutex_attr, PTHREAD_PRIO_INHERIT);\n        if (status != 0)\n        {\n            OS_DEBUG(\"Error: pthread_mutexattr_setprotocol failed: %s\\n\", strerror(status));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        for (idx = 0; idx < OS_MAX_TIMEBASES; ++idx)\n        {\n            /*\n            ** create the timebase sync mutex\n            ** This gives a mechanism to synchronize updates to the timer chain with the\n            ** expiration of the timer and processing the chain.\n            */\n            status = pthread_mutex_init(&OS_impl_timebase_table[idx].handler_mutex, &mutex_attr);\n            if (status != 0)\n            {\n                OS_DEBUG(\"Error: Mutex could not be created: %s\\n\", strerror(status));\n                return_code = OS_ERROR;\n                break;\n            }\n        }\n\n        /*\n         * Pre-calculate the clock tick to microsecond conversion factor.\n         */\n        OS_SharedGlobalVars.TicksPerSecond = sysconf(_SC_CLK_TCK);\n        if (OS_SharedGlobalVars.TicksPerSecond <= 0)\n        {\n            OS_DEBUG(\"Error: Unable to determine OS ticks per second: %s\\n\", strerror(errno));\n            return_code = OS_ERROR;\n            break;\n        }\n\n        /*\n         * Calculate microseconds per tick\n         *  - If the ratio is not an integer, this will round to the nearest integer value\n         *  - This is used internally for reporting accuracy,\n         *  - TicksPerSecond values over 2M will return zero\n         */\n        OS_SharedGlobalVars.MicroSecPerTick =\n            (1000000 + (OS_SharedGlobalVars.TicksPerSecond / 2)) / OS_SharedGlobalVars.TicksPerSecond;\n    } while (0);\n\n    return return_code;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'OS_Posix_TimeBaseAPI_Impl_Init': {'callees': [], 'callers': ['OS_API_Impl_Init']}, 'OS_API_Impl_Init': {'callees': ['OS_Posix_TableMutex_Init', 'OS_Posix_TaskAPI_Impl_Init', 'OS_Posix_QueueAPI_Impl_Init', 'OS_Posix_BinSemAPI_Impl_Init', 'OS_Posix_CountSemAPI_Impl_Init', 'OS_Posix_MutexAPI_Impl_Init', 'OS_Posix_ModuleAPI_Impl_Init', 'OS_Posix_TimeBaseAPI_Impl_Init', 'OS_Posix_StreamAPI_Impl_Init', 'OS_Posix_DirAPI_Impl_Init', 'OS_Posix_FileSysAPI_Impl_Init', 'OS_Posix_CondVarAPI_Impl_Init'], 'callers': ['OS_API_Init']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "OS_DEBUG",
    "OS_impl_timebase_table",
    "OS_MAX_TIMEBASES",
    "OS_PREFERRED_CLOCK",
    "POSIX_GlobalVars",
    "POSIX_GlobalVars.ClockAccuracyNsec",
    "OS_SharedGlobalVars",
    "OS_SharedGlobalVars.TicksPerSecond",
    "OS_SharedGlobalVars.MicroSecPerTick",
    "osal_index_t",
    "int32",
    "uint32",
    "OS_SUCCESS",
    "OS_ERROR",
    "OS_TIMER_ERR_INTERNAL",
    "pthread_mutexattr_t",
    "pthread_mutexattr_init",
    "pthread_mutexattr_setprotocol",
    "PTHREAD_PRIO_INHERIT",
    "pthread_mutex_init",
    "OS_impl_timebase_table[].handler_mutex",
    "errno",
    "strerror",
    "clock_getres",
    "sysconf",
    "_SC_CLK_TCK",
    "memset"
  ],
  "explanation": "For checking the MISRA rule about language extensions, inspect the definitions of any macros, typedefs, globals or members used by the function because compiler extensions (e.g. __attribute__, __extension__, typeof, __asm__, __thread, builtins, statement-expressions, etc.) are typically introduced there. The listed symbols are the places to inspect and why:\n\n- OS_DEBUG: macro/function that may expand to compiler-specific constructs (attributes, variadic/extention macros, statement-expressions).\n- OS_impl_timebase_table: its type/initializer could use extensions (section attributes, packed/aligned, or compiler-specific declarations).\n- OS_MAX_TIMEBASES: macro could be computed with extensions or use nonstandard token pasting/exprs.\n- OS_PREFERRED_CLOCK: macro/constant may be defined via compiler-specific expressions or enums.\n- POSIX_GlobalVars: structure/variable definition may include compiler-specific attributes or storage-class extensions.\n- POSIX_GlobalVars.ClockAccuracyNsec: member type (and its typedef) could use nonstandard integer types or attributes.\n- OS_SharedGlobalVars: structure/variable definition may include compiler-specific attributes or storage-class extensions.\n- OS_SharedGlobalVars.TicksPerSecond and OS_SharedGlobalVars.MicroSecPerTick: members whose types/initializers may hide extensions.\n- osal_index_t: typedef may use compiler-specific type keywords or attributes (e.g. __attribute__, extended integer types).\n- int32 and uint32: typedefs/defines for these integer types may use compiler-specific builtins or attributes.\n- OS_SUCCESS, OS_ERROR, OS_TIMER_ERR_INTERNAL: constant macros may expand to compiler-specific expressions or use extension tokens.\n- pthread_mutexattr_t, pthread_mutexattr_init, pthread_mutexattr_setprotocol, pthread_mutex_init, PTHREAD_PRIO_INHERIT: POSIX names\u2014inspect definitions/macros/headers on the target build because some implementations wrap these in macros or use compiler extensions for thread-local storage or attributes.\n- OS_impl_timebase_table[].handler_mutex: the mutex member type could be a typedef or macro that hides extensions (e.g. inline initializers or attributes).\n- errno: often a macro that may expand to a call like __errno_location() or use thread-local storage keywords (which can be implementation-specific extensions); inspect its definition.\n- strerror, clock_getres, sysconf, _SC_CLK_TCK, memset: standard library functions/macros\u2014check their declarations in the target platform headers in case they use compiler-specific attributes or macros (e.g. __attribute__((...)), builtin wrappers).\n\nInspecting these symbols' definitions (macros, typedefs, struct definitions and header declarations) is sufficient to determine whether any language/compiler extensions are used in the code paths exercised by OS_Posix_TimeBaseAPI_Impl_Init."
}