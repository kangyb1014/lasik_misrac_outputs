{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call uses auth_info->password which is (likely) declared as a non-const pointer (e.g. char *password) but is only read (memcmp) and therefore should be const-qualified. Passing a non-const pointer to a function that only inspects the data indicates the pointer in the structure should be declared as pointing to const data. (Also the string literal \"open sesame\" is effectively const and should be treated as const char[]).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void ahc_log_probe_pre(const char *method, void **req_cls, struct MHD_BasicAuthInfo *auth_info)\n{\n  FILE *f = fopen(\"/tmp/logs/531.txt\", \"a\");\n  if (!f)\n    return;\n\n  time_t t = time(NULL);\n  fprintf(f, \"---- ahc_echo probe (pre) %ld ----\\n\", (long)t);\n  fprintf(f, \"method=%s req_cls_ptr=%p req_cls_value=%p\\n\", method, (void *)&req_cls, *req_cls);\n  fprintf(f, \"auth_info_ptr=%p\\n\", (void *) auth_info);\n  if (NULL == auth_info)\n  {\n    fprintf(f, \"auth_info: NULL\\n\");\n    fclose(f);\n    return;\n  }\n\n  fprintf(f, \"username_ptr=%p username_len=%zu\\n\",\n          (void *) auth_info->username, (size_t) auth_info->username_len);\n  /* print username safely (may not be NUL-terminated) */\n  if (auth_info->username && auth_info->username_len > 0)\n  {\n    size_t n = auth_info->username_len > 64 ? 64 : auth_info->username_len;\n    fprintf(f, \"username_sample=\\\"\");\n    fwrite(auth_info->username, 1, n, f);\n    if (auth_info->username_len > n)\n      fprintf(f, \"...\\\"\");\n    else\n      fprintf(f, \"\\\"\");\n    fprintf(f, \" (len=%zu)\\n\", (size_t) auth_info->username_len);\n  }\n  else\n  {\n    fprintf(f, \"username_sample=(none)\\n\");\n  }\n\n  fprintf(f, \"password_ptr=%p password_len=%zu\\n\",\n          (void *) auth_info->password, (size_t) auth_info->password_len);\n  if (auth_info->password && auth_info->password_len > 0)\n  {\n    size_t n = auth_info->password_len > 64 ? 64 : auth_info->password_len;\n    fprintf(f, \"password_sample=\\\"\");\n    fwrite(auth_info->password, 1, n, f);\n    if (auth_info->password_len > n)\n      fprintf(f, \"...\\\"\");\n    else\n      fprintf(f, \"\\\"\");\n    fprintf(f, \" (len=%zu)\\n\", (size_t) auth_info->password_len);\n  }\n  else\n  {\n    fprintf(f, \"password_sample=(none)\\n\");\n  }\n\n  /* Perform the same comparisons used by ahc_echo for logging only. */\n  if (NULL != auth_info && NULL != auth_info->username)\n  {\n    int cmp_user = memcmp(auth_info->username, \"Aladdin\", auth_info->username_len);\n    fprintf(f, \"memcmp(username, \\\"Aladdin\\\", username_len) => %d\\n\", cmp_user);\n  }\n  else\n  {\n    fprintf(f, \"memcmp(username, ...) => not performed (NULL)\\n\");\n  }\n\n  if (NULL != auth_info && NULL != auth_info->password)\n  {\n    int cmp_pw = memcmp(auth_info->password, \"open sesame\", auth_info->password_len);\n    fprintf(f, \"memcmp(password, \\\"open sesame\\\", password_len) => %d\\n\", cmp_pw);\n  }\n  else\n  {\n    fprintf(f, \"memcmp(password, ...) => not performed (NULL)\\n\");\n  }\n\n  fclose(f);\n}\nstatic void ahc_log_probe_post(int fail, enum MHD_Result ret, struct MHD_BasicAuthInfo *auth_info)\n{\n  FILE *f = fopen(\"/tmp/logs/531.txt\", \"a\");\n  if (!f)\n    return;\n  time_t t = time(NULL);\n  fprintf(f, \"---- ahc_echo probe (post) %ld ----\\n\", (long)t);\n  fprintf(f, \"auth_info_ptr=%p fail=%d ret=%d\\n\",\n          (void *) auth_info, fail, (int) ret);\n  if (NULL != auth_info)\n    fprintf(f, \"freeing auth_info at %p\\n\", (void *) auth_info);\n  fprintf(f, \"-------------------------------\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  /* Insert probes to log control flow and state relevant to the auth check. */\n  ahc_log_probe_pre(method, req_cls, auth_info);\n\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n\n  ahc_log_probe_post(fail, ret, auth_info);\n\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 recommends that pointers should be qualified const where possible, but that does not automatically mean the shown code violates the rule. In this code auth_info is obtained from an external API (MHD_basic_auth_get_username_password3) that returns a pointer to a non-const struct (the library declares the structure members as non-const). The handler only reads the username/password, but it also calls MHD_free(auth_info) to release the object. Declaring auth_info as a pointer-to-const would force a cast to call the library free function (or a change to the library API), which means it is not practically possible here to use a const-qualified pointer without breaking/forcing an unsafe cast or changing the external API. Passing non-const char * members to functions that take const parameters (memcmp, strlen, fwrite with a const void * parameter) is allowed \u2014 these functions accept const \u2014 so there is no actual misuse. Therefore the reported violation is not justified for this code as written (the limitation arises from the external API), so the report is incorrect."
}