{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  fail = ( (NULL == auth_info) ||\n           (strlen (\"Aladdin\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"Aladdin\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"open sesame\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"open sesame\",\n                         auth_info->password_len)) );\n  if (fail)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls memcmp(auth_info->password, \"open sesame\", auth_info->password_len) after ensuring password is non-NULL and zero-terminated by MHD_basic_auth_get_username_password3. Both operands are null-terminated strings (the password buffer is NUL-terminated and the literal is NUL-terminated), so memcmp is being used to compare null-terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/534.txt\", \"a\");\n  if (NULL == f)\n    return; /* best-effort logging only */\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fputc('\\n', f);\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct MHD_BasicAuthInfo *auth_info;\n  int fail;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry and request state */\n  probe_log(\"ahc_echo: entry: connection=%p, method=%s, req_cls_ptr=%p, *req_cls=%p\",\n            (void *) connection, (method ? method : \"(null)\"), (void *) &aptr, (req_cls ? *req_cls : NULL));\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    probe_log(\"ahc_echo: unexpected method: %s\", method ? method : \"(null)\");\n    return MHD_NO;              /* unexpected method */\n  }\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    probe_log(\"ahc_echo: first call, setting req_cls and returning MHD_YES\");\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  probe_log(\"ahc_echo: auth_info pointer=%p\", (void *) auth_info);\n  if (NULL != auth_info)\n  {\n    probe_log(\"ahc_echo: auth_info->username=%p, username_len=%zu, auth_info->password=%p, password_len=%zu\",\n              (void *) auth_info->username, (size_t) auth_info->username_len,\n              (void *) auth_info->password, (size_t) auth_info->password_len);\n    /* Log terminating bytes for evidence of NUL-termination when available. */\n    if (auth_info->username != NULL)\n    {\n      /* Safe access: the underlying library documents returned buffers are NUL-terminated. */\n      probe_log(\"ahc_echo: username[%zu] (terminator) = 0x%02X\",\n                (size_t) auth_info->username_len,\n                (unsigned char) auth_info->username[auth_info->username_len]);\n    }\n    if (auth_info->password != NULL)\n    {\n      probe_log(\"ahc_echo: password[%zu] (terminator) = 0x%02X\",\n                (size_t) auth_info->password_len,\n                (unsigned char) auth_info->password[auth_info->password_len]);\n    }\n  }\n  else\n  {\n    probe_log(\"ahc_echo: auth_info is NULL\");\n  }\n\n  /* Reproduce the original short-circuited check while adding probes that\n     record each decision step and the state that led to it.  The evaluation\n     order is preserved. */\n  {\n    int step_fail = 0;\n\n    /* Step 1: auth_info presence */\n    if (NULL == auth_info)\n    {\n      probe_log(\"ahc_echo: check1: auth_info == NULL -> true\");\n      step_fail = 1;\n    }\n    else\n    {\n      probe_log(\"ahc_echo: check1: auth_info == NULL -> false\");\n\n      /* Step 2: username length match */\n      {\n        size_t lit_len = strlen(\"Aladdin\");\n        if (lit_len != auth_info->username_len)\n        {\n          probe_log(\"ahc_echo: check2: strlen(\\\"Aladdin\\\")=%zu != username_len=%zu -> true\",\n                    lit_len, (size_t) auth_info->username_len);\n          step_fail = 1;\n        }\n        else\n        {\n          probe_log(\"ahc_echo: check2: strlen(\\\"Aladdin\\\")=%zu == username_len=%zu -> false\",\n                    lit_len, (size_t) auth_info->username_len);\n\n          /* Step 3: username content compare using memcmp as in original code. */\n          {\n            int cmp_user = memcmp (auth_info->username, \"Aladdin\",\n                                   auth_info->username_len);\n            probe_log(\"ahc_echo: check3: memcmp(username, \\\"Aladdin\\\", %zu) -> %d\",\n                      (size_t) auth_info->username_len, cmp_user);\n            if (0 != cmp_user)\n            {\n              probe_log(\"ahc_echo: check3 result -> mismatch -> true\");\n              step_fail = 1;\n            }\n            else\n            {\n              probe_log(\"ahc_echo: check3 result -> match -> false\");\n\n              /* Step 4: optional NULL password check */\n              if (NULL == auth_info->password)\n              {\n                probe_log(\"ahc_echo: check4: password == NULL -> true\");\n                step_fail = 1;\n              }\n              else\n              {\n                probe_log(\"ahc_echo: check4: password == NULL -> false\");\n\n                /* Step 5: password length match */\n                {\n                  size_t pass_lit_len = strlen(\"open sesame\");\n                  if (pass_lit_len != auth_info->password_len)\n                  {\n                    probe_log(\"ahc_echo: check5: strlen(\\\"open sesame\\\")=%zu != password_len=%zu -> true\",\n                              pass_lit_len, (size_t) auth_info->password_len);\n                    step_fail = 1;\n                  }\n                  else\n                  {\n                    probe_log(\"ahc_echo: check5: strlen(\\\"open sesame\\\")=%zu == password_len=%zu -> false\",\n                              pass_lit_len, (size_t) auth_info->password_len);\n\n                    /* Step 6: password content compare using memcmp as in original code. */\n                    {\n                      int cmp_pass = memcmp (auth_info->password, \"open sesame\",\n                                              auth_info->password_len);\n                      probe_log(\"ahc_echo: check6: memcmp(password, \\\"open sesame\\\", %zu) -> %d\",\n                                (size_t) auth_info->password_len, cmp_pass);\n                      if (0 != cmp_pass)\n                      {\n                        probe_log(\"ahc_echo: check6 result -> mismatch -> true\");\n                        step_fail = 1;\n                      }\n                      else\n                      {\n                        probe_log(\"ahc_echo: check6 result -> match -> false\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    fail = step_fail;\n    probe_log(\"ahc_echo: final 'fail' decision = %d\", fail);\n  }\n\n  if (fail)\n  {\n    probe_log(\"ahc_echo: authentication failed -> sending DENIED response\");\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              (const void *) DENIED);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"TestRealm\",\n                                                   MHD_NO,\n                                                   response);\n  }\n  else\n  {\n    probe_log(\"ahc_echo: authentication succeeded -> sending PAGE response\");\n    response =\n      MHD_create_response_from_buffer_static (strlen (PAGE),\n                                              (const void *) PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n\n  probe_log(\"ahc_echo: exit returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memcmp(auth_info->username, \"Aladdin\", auth_info->username_len) and memcmp(auth_info->password, \"open sesame\", auth_info->password_len). The right-hand operands are string literals (always NUL-terminated) and the library routine MHD_basic_auth_get_username_password3 is documented to return NUL-terminated username/password buffers, so both arguments are null-terminated strings. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null-terminated strings regardless of using an explicit length equal to the string length. Therefore these memcmp uses violate Rule 21.14. A compliant fix is to use the appropriate string comparison functions (e.g. strcmp/strncmp) or otherwise ensure non-string, length-only binary comparison semantics where memcmp is permitted."
}