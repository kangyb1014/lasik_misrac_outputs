{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp to compare a header value against the string literal \"close\": (0 == memcmp(hdr->value, \"close\", 5)). hdr->value is a null-terminated header string and \"close\" is a null-terminated string literal; using memcmp for string comparison (even with length 5) violates MISRA C 2023 Rule 21.14 which forbids using memcmp to compare null-terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_print_bytes(FILE *f, const char *label, const char *s, size_t n)\n{\n  size_t i;\n  size_t cap = (n > 256U) ? 256U : n; /* limit bytes printed */\n  fprintf(f, \"%s (len=%zu): '\", label, n);\n  for (i = 0U; i < cap; ++i)\n  {\n    unsigned char c = (unsigned char)s[i];\n    if (isprint(c))\n      fputc(c, f);\n    else\n      fprintf(f, \"\\\\x%02x\", c);\n  }\n  if (n > cap)\n    fprintf(f, \"... (truncated)\");\n  fprintf(f, \"'\\n\");\n}\nstatic void mhd_log_iteration(const char *stage,\n                              const struct MHD_Response *response,\n                              const struct MHD_HTTP_Res_Header *pos,\n                              enum MHD_ValueKind kind,\n                              const char *key,\n                              size_t key_len,\n                              int header_size_equal,\n                              int kind_equal,\n                              int name_equal,\n                              int iter)\n{\n  FILE *f = fopen(\"/tmp/logs/686.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"-- MHD_get_response_element_n_ %s (iter=%d) --\\n\", stage, iter);\n  fprintf(f, \" response=%p\\n\", (const void *)response);\n  fprintf(f, \" pos=%p\\n\", (const void *)pos);\n  fprintf(f, \" kind=%d key_len=%zu\\n\", (int)kind, key_len);\n\n  if (key != NULL)\n    mhd_log_print_bytes(f, \" key\", key, key_len);\n  else\n    fprintf(f, \" key=(null)\\n\");\n\n  if (pos != NULL)\n  {\n    fprintf(f, \" pos->header_size=%zu pos->kind=%d pos->next=%p\\n\",\n            pos->header_size, (int)pos->kind, (const void *)pos->next);\n    if (pos->header != NULL)\n      mhd_log_print_bytes(f, \" pos->header\", pos->header, pos->header_size);\n    else\n      fprintf(f, \" pos->header=(null)\\n\");\n  }\n\n  fprintf(f, \" checks: header_size_equal=%d kind_equal=%d name_equal=%d\\n\",\n          header_size_equal, kind_equal, name_equal);\n  fprintf(f, \"-- end --\\n\\n\");\n  fclose(f);\n}\n\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  int iter = 0;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  /* Log entry to the function */\n  {\n    FILE *f = fopen(\"/tmp/logs/686.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"ENTER MHD_get_response_element_n_: response=%p kind=%d key_len=%zu key_ptr=%p\\n\",\n              (const void *)response, (int)kind, key_len, (const void *)key);\n      if (key)\n        mhd_log_print_bytes(f, \" key\", key, key_len);\n      fclose(f);\n    }\n  }\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    /* Preserve original short-circuiting semantics: only call the\n     * string-comparison helper when the first two checks succeed. */\n    int header_size_equal = (pos->header_size == key_len);\n    int kind_equal = (kind == pos->kind);\n    int name_equal = 0; /* only set if we actually compare */\n\n    if (header_size_equal && kind_equal)\n    {\n      /* Perform the actual comparison (this is part of original logic)\n       * and capture its result for logging. */\n      name_equal = MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size);\n\n      mhd_log_iteration(\"after-compare\", response, pos, kind, key, key_len,\n                        header_size_equal, kind_equal, name_equal, iter);\n\n      if (name_equal)\n        return pos;\n    }\n    else\n    {\n      /* Log the failed checks for this iteration. */\n      mhd_log_iteration(\"checks-failed\", response, pos, kind, key, key_len,\n                        header_size_equal, kind_equal, name_equal, iter);\n    }\n\n    ++iter;\n  }\n\n  /* Log that nothing matched */\n  {\n    FILE *f = fopen(\"/tmp/logs/686.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"EXIT MHD_get_response_element_n_: no match found (response=%p)\\n\\n\",\n              (const void *)response);\n      fclose(f);\n    }\n  }\n\n  return NULL;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf34024a0\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf34026f0\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ after-compare (iter=0) --\n response=0x55abf34022a0\n pos=0x55abf3402730\n kind=1 key_len=10\n key (len=10): 'Connection'\n pos->header_size=10 pos->kind=1 pos->next=0x55abf3402420\n pos->header (len=10): 'Connection'\n checks: header_size_equal=1 kind_equal=1 name_equal=1\n-- end --\n\nENTER MHD_get_response_element_n_: response=0x55abf34022a0 kind=1 key_len=10 key_ptr=0x7f9eac803159\n key (len=10): 'Connection'\n-- MHD_get_response_element_n_ afte\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the supplied code or logs. MHD_get_response_element_n_ does not call memcmp to compare null-terminated strings; it performs a length check (pos->header_size == key_len) and then calls MHD_str_equal_caseless_bin_n_ to compare the buffers with an explicit length. The provided logs show comparisons of the header \"Connection\" using the length-prefixed helper (name_equal=1) and no use of memcmp on null-terminated strings. Therefore Agent A's claim that this function uses memcmp to compare null-terminated strings (e.g. against \"close\") is not correct for the shown code and test output."
}