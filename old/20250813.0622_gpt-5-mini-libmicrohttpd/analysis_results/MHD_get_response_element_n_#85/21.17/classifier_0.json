{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_response_element_n_:\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (0 != key_len);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The assertion mhd_assert(0 != key_len) itself does not call any <string.h> functions and therefore does not by itself violate MISRA C 2023 Rule 21.17. However, a violation can occur later if key_len is greater than the actual size of the buffer pointed to by key and a string/library function is subsequently invoked with that length. For example, if key points to a 4\u2011byte buffer (e.g. \"abc\\0\") but key_len == 10, a later call that compares or copies key_len bytes (e.g. memcmp/memcpy or the MHD_str_equal_caseless_bin_n_ implementation that uses such functions) would read beyond the bounds of key, violating Rule 21.17."
}