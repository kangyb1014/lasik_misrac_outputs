{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If mhd_assert is the usual debug-only assertion macro (i.e. compiles to a no-op in production, such as when NDEBUG is defined) then the statement becomes an operation that has no effect at runtime; removing it would not change program behaviour, so it is dead code and thus violates MISRA C 2023 Rule 2.2. (If, conversely, mhd_assert performs runtime actions such as logging or termination on failure, then it is not dead code.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *msg, const void *response, const void *ptr, size_t len, int cond)\n{\n  FILE *f = fopen(\"/tmp/logs/682.txt\", \"a\");\n  if (f != NULL)\n  {\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] %s response=%p ptr=%p len=%zu cond=%d\\n\",\n            (long)t, msg, response, ptr, len, cond);\n    fclose(f);\n  }\n}\nstatic void mhd_probe_log_msg(const char *msg, const void *response)\n{\n  FILE *f = fopen(\"/tmp/logs/682.txt\", \"a\");\n  if (f != NULL)\n  {\n    time_t t = time(NULL);\n    fprintf(f, \"[%ld] %s response=%p\\n\", (long)t, msg, response);\n    fclose(f);\n  }\n}\n\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  /* Preserve original evaluation order of assertions while logging the\n     evaluated boolean result to provide evidence whether the assertions\n     are active (stop/abort) or effectively no-ops in the build used. */\n  int _cond0 = (NULL != key);\n  mhd_probe_log(\"assert-eval: NULL != key\", response, key, key_len, _cond0);\n  mhd_assert (_cond0);\n\n  int _cond1 = (0 != key[0]);\n  mhd_probe_log(\"assert-eval: 0 != key[0]\", response, key, key_len, _cond1);\n  mhd_assert (_cond1);\n\n  int _cond2 = (0 != key_len);\n  mhd_probe_log(\"assert-eval: 0 != key_len\", response, key, key_len, _cond2);\n  mhd_assert (_cond2);\n\n  mhd_probe_log_msg(\"entering-loop\", response);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    /* Log inspected header state for each iteration; do not dereference\n       header contents beyond the pointer (avoid changing behaviour). */\n    mhd_probe_log(\"loop-iter: inspect header\", response, pos->header, pos->header_size, (int)pos->kind);\n\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n    {\n      mhd_probe_log(\"match-found\", response, pos->header, pos->header_size, (int)pos->kind);\n      return pos;\n    }\n  }\n\n  mhd_probe_log_msg(\"no-match-found\", response);\n  return NULL;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] assert-eval: NULL != key response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key[0] response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] assert-eval: 0 != key_len response=0x55968045d2a0 ptr=0x7fbe86745159 len=10 cond=1\n[1755067859] entering-loop response=0x55968045d2a0\n[1755067859] loop-iter: inspect header response=0x55968045d2a0 ptr=0x55968045d380 len=10 cond=1\n[1755067859] match-found response=0x55968045d2a0 ptr=0x559\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A report is not correct. MISRA C 2023 Rule 2.2 defines dead code as an operation that is executed but whose removal would not affect program behaviour. Debug-only assertions that are compiled out (i.e. do not produce any executed operation in the production build) are not \"dead code\" by that definition because they are not executed in that build. The test output shows the added probe logging and the evaluated boolean variables (_cond0, _cond1, _cond2) from the instrumented test, but those logging/evaluation statements were introduced by the tester \u2014 they are not present in the original function. The mere fact that an assertion macro may be a no-op in some builds does not make the original source an executed-but-useless operation under the rule. Therefore the claim that MHD_get_response_element_n_ violates MISRA C 2023 Rule 2.2 is incorrect."
}