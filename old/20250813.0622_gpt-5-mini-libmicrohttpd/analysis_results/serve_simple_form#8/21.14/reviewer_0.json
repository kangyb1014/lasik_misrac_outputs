{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp to compare hdr->value with the string literal \"close\": mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); Both operands are null-terminated strings (the literal and hdr->value are NUL-terminated in this code path), so using memcmp to compare them violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_state(const char *stage,\n                const void *cls,\n                const char *mime,\n                const struct Session *session,\n                const struct MHD_Connection *connection,\n                const char *form_preview)\n{\n  FILE *f = fopen(\"/tmp/logs/70.txt\", \"a\");\n  int use_stderr = 0;\n  if (NULL == f)\n  {\n    f = stderr;\n    use_stderr = 1;\n  }\n\n  /* Log stage and pointers to help trace control flow and state */\n  fprintf(f, \"[serve_simple_form] stage=%s\\n\", stage);\n  fprintf(f, \"  cls(ptr)=%p mime(ptr)=%p session(ptr)=%p connection(ptr)=%p\\n\",\n          cls, (const void *) mime, (const void *) session, (const void *) connection);\n  if (form_preview != NULL)\n  {\n    /* Print a safe preview of the form content (limited length) */\n    fprintf(f, \"  form_preview=\\\"%s\\\"\\n\", form_preview);\n  }\n  else\n  {\n    fprintf(f, \"  form_preview=(null)\\n\");\n  }\n\n  if (!use_stderr)\n    fclose(f);\n  else\n    fflush(stderr);\n}\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* Probe: entry state */\n  if (form != NULL)\n  {\n    /* produce a short, bounded preview to avoid excessive logging */\n    char preview[256];\n    size_t plen = strlen(form);\n    if (plen >= sizeof(preview))\n      plen = sizeof(preview) - 1;\n    memcpy(preview, form, plen);\n    preview[plen] = '\\0';\n    probe_log_state(\"entry\", cls, mime, session, connection, preview);\n  }\n  else\n  {\n    probe_log_state(\"entry\", cls, mime, session, connection, NULL);\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n  {\n    probe_log_state(\"create_response_failed\", cls, mime, session, connection, form);\n    return MHD_NO;\n  }\n\n  probe_log_state(\"response_created\", cls, mime, session, connection, form);\n\n  add_session_cookie (session, response);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    probe_log_state(\"add_header_failed\", cls, mime, session, connection, form);\n  }\n  else\n  {\n    probe_log_state(\"header_added\", cls, mime, session, connection, form);\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n\n  probe_log_state(\"before_destroy\", cls, mime, session, connection, form);\n\n  MHD_destroy_response (response);\n\n  probe_log_state(\"exit\", cls, mime, session, connection, form);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is incorrect. The provided serve_simple_form implementation contains no use of memcmp (nor any comparison of hdr->value with the literal \"close\"). The line mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); cited by agent A does not appear in the serve_simple_form code shown, so Rule 21.14 is not violated by this function as given. (If such a memcmp were present elsewhere and used to compare NUL-terminated strings, that would indeed contravene MISRA C 2023 Rule 21.14; the correct remedy there would be to use the appropriate string comparison function such as strcmp/strncmp with proper bounds checking.)"
}