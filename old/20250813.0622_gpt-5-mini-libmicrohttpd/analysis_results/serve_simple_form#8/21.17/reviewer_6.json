{
  "user_message": "An agent A claimed that the following serve_simple_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of serve_simple_form.\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memcmp call uses a fixed length of 5: memcmp(hdr->value, \"close\", 5). There is no prior check that hdr->value actually has at least 5 bytes (hdr->value_size >= 5). If hdr->value points to a shorter buffer (for example the Connection header value is \"clo\" or \"\"), memcmp will read beyond the bounds of that object and thus violate MISRA C 2023 Rule 21.17. (In short: calling memcmp with n=5 on a potentially shorter hdr->value can access out-of-bounds memory.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* Probe logging: record entry and parameter/state info to /tmp/logs/71.txt */\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"serve_simple_form ENTRY: cls=%p mime=%p session=%p connection=%p\\n\",\n              cls, (void *) mime, (void *) session, (void *) connection);\n      if (form == NULL)\n      {\n        fprintf(log, \"  form == NULL\\n\");\n      }\n      else\n      {\n        /* Safely measure and print a prefix of the form to avoid large outputs */\n        size_t form_len = strlen(form);\n        fprintf(log, \"  form_len=%zu\\n\", form_len);\n        size_t print_len = (form_len < 256U) ? form_len : 256U;\n        fprintf(log, \"  form_prefix_len=%zu form_prefix='\", print_len);\n        if (print_len > 0U)\n        {\n          fwrite(form, 1, print_len, log);\n        }\n        if (print_len < form_len)\n          fprintf(log, \"'... (truncated)\\n\");\n        else\n          fprintf(log, \"'\\n\");\n      }\n      fflush(log);\n      fclose(log);\n    }\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"serve_simple_form: MHD_create_response_from_buffer_static returned NULL\\n\");\n      fflush(log);\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  add_session_cookie (session, response);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    /* Log this event with the mime value (safe-guard null) */\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"serve_simple_form: MHD_add_response_header failed for mime='%s'\\n\", mime ? mime : \"(null)\");\n      fflush(log);\n      fclose(log);\n    }\n  }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  /* Log exit and return code */\n  {\n    FILE *log = fopen(\"/tmp/logs/71.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"serve_simple_form EXIT: ret=%d\\n\", (int) ret);\n      fflush(log);\n      fclose(log);\n    }\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for serve_simple_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A's scenario is not applicable to the provided serve_simple_form code. The reported problematic call memcmp(hdr->value, \"close\", 5) does not appear in the shown function; serve_simple_form only calls strlen(form) and library functions to build and queue a response. MISRA C:2023 Rule 21.17 concerns string.h functions accessing beyond object bounds. strlen(form) will only be a violation if form is NULL or not a null-terminated object within its bounds. There is no evidence in the snippet that memcmp is used or that form is definitively non-terminated, so the specific memcmp-out-of-bounds scenario is not present here. (Note: unrelatedly, calling strlen on a NULL pointer would be undefined and could violate Rule 21.17, but that is a different issue and not the scenario agent A described.) Therefore the report is incorrect for this function as shown."
}