{
  "user_message": "An agent A claimed that the following MHD_queue_response code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_response.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violated when header or value are not NUL-terminated but are used with functions that assume C strings. The struct stores header_size/value_size (lengths) but the code calls MHD_str_equal_caseless_ and MHD_str_has_s_token_caseless_ which iterate on '\\0' termination. If a header->header or header->value buffer is not terminated (only length fields are valid), these functions will read past header_size/value_size and potentially access out-of-bounds memory. Note mhd_assert is a no-op here, so the apparent checks do not prevent runtime use. To comply, either ensure the buffers are NUL-terminated whenever passed to string functions, or use length-aware routines (e.g. memcmp with known lengths) to avoid overruns.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct ThreadId { int id; };\ntypedef struct ThreadId { int id; } ThreadId;\nstruct MHD_RP {\n    struct MHD_Response *response;\n    unsigned int responseCode;\n    bool responseIcy;\n    size_t rsp_write_position;\n    void (*resp_sender)(void);\n};\nconst unsigned int MHD_ICY_FLAG = 0x80000000u;\nconst unsigned int MHD_HTTP_SWITCHING_PROTOCOLS = 101;\nconst unsigned int MHD_HTTP_VER_1_0 = 0x0100;\nconst unsigned int MHD_HTTP_OK = 200;\nconst unsigned int MHD_HTTP_NO_CONTENT = 204;\nconst unsigned int MHD_HTTP_NOT_MODIFIED = 304;\nconst unsigned int MHD_HTTP_MTHD_CONNECT = 0x10;\nconst unsigned int MHD_RF_HEAD_ONLY_RESPONSE = 0x1;\nconst unsigned int MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 0x2;\nconst unsigned int MHD_RF_HTTP_1_0_SERVER = 0x4;\nconst unsigned int MHD_RAF_HAS_CONTENT_LENGTH = 0x1;\nconst unsigned int MHD_RF_INSANITY_HEADER_CONTENT_LENGTH = 0x8;\nconst char *MHD_HTTP_HEADER_CONNECTION = \"Connection\";\nextern bool MHD_D_IS_USING_THREADS_(struct MHD_Daemon *);\nextern bool MHD_thread_handle_ID_is_current_thread_(ThreadId);\nextern bool MHD_str_has_s_token_caseless_(const char *, const char *);\nextern bool MHD_IS_HTTP_VER_1_1_COMPAT(unsigned int);\nextern void MHD_resp_sender_std(void);\nextern void MHD_resp_sender_sendfile(void);\nextern void mhd_assert(int cond);\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/383.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  /* Log entry and immediate parameters */\n  mhd_probe_log(\"MHD_queue_response ENTRY: connection=%p response=%p status_code=%u\",\n                (void *) connection, (void *) response, status_code);\n\n  if ((NULL == connection) || (NULL == response)) {\n    mhd_probe_log(\"MHD_queue_response: NULL parameter(s) - connection=%p response=%p\",\n                  (void *) connection, (void *) response);\n    return MHD_NO;\n  }\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    /* Fix: connection->tid may be an aggregate type; print its address rather than\n       attempting to cast its value to an integer type. */\n    mhd_probe_log(\"MHD_queue_response: attempted to queue on wrong thread: connection=%p tid=%p\",\n                  (void *) connection, (void *) &connection->tid);\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      mhd_probe_log(\"MHD_queue_response: upgrade requested but MHD_ALLOW_UPGRADE not set on daemon=%p\",\n                    (void *) daemon);\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      mhd_probe_log(\"MHD_queue_response: upgrade response but status_code=%u on connection=%p\",\n                    status_code, (void *) connection);\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      mhd_probe_log(\"MHD_queue_response: upgrade response lacks Connection header flag: response=%p flags_auto=0x%lx\",\n                    (void *) response, (unsigned long) response->flags_auto);\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n\n    /* Log header pointers and state to help reproduce potential non-NUL-terminated buffers\n       Do not dereference the header/value buffers beyond obtaining their pointer values,\n       to avoid introducing additional out-of-bounds accesses. */\n    mhd_probe_log(\"MHD_queue_response: upgrade path: response=%p first_header=%p\",\n                  (void *) response, (void *) conn_header);\n    if (NULL == conn_header) {\n      mhd_probe_log(\"MHD_queue_response: first_header is NULL despite flags_auto indicating Connection header present\");\n    } else {\n      /* print only pointer/address information; avoid reading contents which may be unterminated */\n      mhd_probe_log(\"MHD_queue_response: conn_header->header=%p conn_header->value=%p\",\n                    (void *) conn_header->header, (void *) conn_header->value);\n      mhd_probe_log(\"MHD_queue_response: about to assert MHD_str_equal_caseless_ on header (this may be a no-op in release builds)\");\n    }\n\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n\n    /* Before calling the token-checking function, log the pointers & state so\n       testers can observe what pointers/flags were present at the time the\n       original (potentially unsafe) string function is invoked. We intentionally\n       avoid calling any string routines here to prevent introducing further\n       out-of-bounds reads; the original code calls MHD_str_has_s_token_caseless_\n       below and that call is preserved as-is. */\n    mhd_probe_log(\"MHD_queue_response: about to call MHD_str_has_s_token_caseless_ with value=%p; connection=%p response=%p\",\n                  (void *) (conn_header ? conn_header->value : NULL), (void *) connection, (void *) response);\n\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      mhd_probe_log(\"MHD_queue_response: MHD_str_has_s_token_caseless_ returned false for value=%p; response=%p\",\n                    (void *) (conn_header ? conn_header->value : NULL), (void *) response);\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      mhd_probe_log(\"MHD_queue_response: Upgrade used on non-HTTP/1.1 connection: http_ver=%u connection=%p\",\n                    (unsigned) connection->rq.http_ver, (void *) connection);\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      mhd_probe_log(\"MHD_queue_response: 101 used without upgrade_handler: response=%p\",\n                    (void *) response);\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"MHD_queue_response: 101 used but UPGRADE_SUPPORT not compiled in\");\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    mhd_probe_log(\"MHD_queue_response: refused wrong status code %u for response=%p\",\n                  status_code, (void *) response);\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      mhd_probe_log(\"MHD_queue_response: 1xx status code %u refused for HTTP/1.0 connection=%p\",\n                    status_code, (void *) connection);\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      mhd_probe_log(\"MHD_queue_response: 1xx status %u refused due to response flags for response=%p\",\n                    status_code, (void *) response);\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    mhd_probe_log(\"MHD_queue_response: CONNECT request cannot have 2xx response: connection=%p status_code=%u\",\n                  (void *) connection, status_code);\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    mhd_probe_log(\"MHD_queue_response: HEAD-only response incompatible with request: response=%p connection=%p\",\n                  (void *) response, (void *) connection);\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n    mhd_probe_log(\"MHD_queue_response: response has application-defined Content-Length: response=%p flags=0x%lx flags_auto=0x%lx\",\n                  (void *) response, (unsigned long) response->flags, (unsigned long) response->flags_auto);\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n    mhd_probe_log(\"MHD_queue_response: early response queued; connection state moved to START_REPLY connection=%p\",\n                  (void *) connection);\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n\n  mhd_probe_log(\"MHD_queue_response EXIT: queued response=%p for connection=%p status_code=%u\",\n                (void *) response, (void *) connection, status_code);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report by agent A is correct in substance. In the shown code MHD_queue_response the library calls MHD_str_equal_caseless_(conn_header->header, MHD_HTTP_HEADER_CONNECTION) and MHD_str_has_s_token_caseless_(conn_header->value, \"upgrade\") while there is no check or guarantee in this function that conn_header->header or conn_header->value are NUL-terminated. The MHD_HTTP_Res_Header structure typically stores separate length fields for header/value, so buffers may be provided as non\u2011terminated slices. Because mhd_assert is a no-op in non-debug builds, the presence of assertions does not prevent execution in release builds. If the two called routines (or the stdlib functions they call) iterate until a '\\0' (or call strlen/strcmp/strstr/strspn/etc.) they can read past the end of the provided buffers and thus perform out\u2011of\u2011bounds accesses, which is exactly what MISRA C:2023 Rule 21.17 forbids for uses of the <string.h> string handling functions.\n\nA caveat: the rule text explicitly targets the Standard Library functions in <string.h>. The snippet calls internal helpers (MHD_str_equal_caseless_, MHD_str_has_s_token_caseless_); if those helpers are implemented in a length\u2011aware manner (accepting length or otherwise avoiding reads past the provided size) and do not call the unsafe <string.h> functions, then there would be no direct Rule 21.17 violation. However, given their names and common implementations, it is reasonable and likely that they expect NUL\u2011terminated C strings or call standard string functions internally. The code as shown does not guarantee NUL termination or otherwise protect those calls, so it is non\u2011compliant / at least presents a realistic MISRA 21.17 violation risk.\n\nRecommended fixes: ensure header/value buffers are NUL\u2011terminated before passing them to string routines; or replace these calls with length\u2011aware checks (e.g. compare with known lengths using memcmp or implement token search that takes the length), or change the API so header/value are always guaranteed NUL\u2011terminated C strings.\n\nConclusion: the report is correct (the code as shown can lead to out\u2011of\u2011bounds string accesses and thus violates MISRA C 2023 Rule 21.17 unless the internal helpers are already implemented in a length\u2011safe way)."
}