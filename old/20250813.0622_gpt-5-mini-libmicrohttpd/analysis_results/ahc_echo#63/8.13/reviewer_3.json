{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    *req_cls = &already_called_marker;\n    /* Wait for complete request */\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The callback parameter 'void *cls' is not const-qualified but the function does not modify or use it; it should be declared as 'const void *cls' to indicate non-modification. This violates MISRA C 2023 Rule 8.13 unless the non-const signature is mandated by the external library callback prototype (in which case a documented deviation is required).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nahc_echo_log_probe(const char *event, void *cls, void **req_cls, const char *url, const char *method, int numeric_state)\n{\n  FILE *fp = NULL;\n  time_t t = time(NULL);\n  /* Ensure log directory exists (ignore errors if it already exists) */\n  (void) mkdir(\"/tmp/logs\", 0777);\n  fp = fopen(\"/tmp/logs/507.txt\", \"a\");\n  if (NULL == fp)\n  {\n    /* If logging cannot be performed, do not affect program flow. */\n    return;\n  }\n\n  (void) fprintf(fp, \"[%ld] ahc_echo: event=%s\\n\", (long) t, event);\n  (void) fprintf(fp, \"[%ld]   cls pointer=%p\\n\", (long) t, cls);\n  if (req_cls != NULL)\n  {\n    (void) fprintf(fp, \"[%ld]   req_cls pointer=%p, *req_cls=%p\\n\", (long) t, (void *) req_cls, (void *) *req_cls);\n  }\n  else\n  {\n    (void) fprintf(fp, \"[%ld]   req_cls pointer=NULL\\n\", (long) t);\n  }\n  if (url != NULL)\n  {\n    /* Log small portion of url and method to avoid heavy output */\n    (void) fprintf(fp, \"[%ld]   url='%s'\\n\", (long) t, url);\n  }\n  if (method != NULL)\n  {\n    (void) fprintf(fp, \"[%ld]   method='%s'\\n\", (long) t, method);\n  }\n  (void) fprintf(fp, \"[%ld]   numeric_state=%d\\n\", (long) t, numeric_state);\n  (void) fprintf(fp, \"[%ld] ---\\n\", (long) t);\n  (void) fclose(fp);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n\n  /* Log entry into function with initial state. The cls parameter is logged\n   * as evidence that it is passed in non-const form but not modified by\n   * this function (the violation scenario). */\n  ahc_echo_log_probe(\"entry\", cls, req_cls, url, method, 0);\n\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    /* Log that we are in first-call path and what we set *req_cls to. */\n    ahc_echo_log_probe(\"first_call_before_set\", cls, req_cls, url, method, 1);\n    *req_cls = &already_called_marker;\n    ahc_echo_log_probe(\"first_call_after_set\", cls, req_cls, url, method, 2);\n    /* Wait for complete request */\n    ahc_echo_log_probe(\"returning_MHD_YES\", cls, req_cls, url, method, (int) MHD_YES);\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n\n  /* Log result of digest auth check to capture the control path */\n  ahc_echo_log_probe(\"after_digest_auth_check\", cls, req_cls, url, method, (int) res_e);\n\n  if (res_e != MHD_DAUTH_OK)\n  {\n    ahc_echo_log_probe(\"auth_failed_creating_denied_response\", cls, req_cls, url, method, (int) res_e);\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    MHD_destroy_response (response);\n\n    ahc_echo_log_probe(\"returning_auth_required_ret\", cls, req_cls, url, method, (int) ret);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  ahc_echo_log_probe(\"returning_final_ret\", cls, req_cls, url, method, (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_echo. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A correctly identified that making pointers const when they are not modified is what MISRA C:2023 Rule 8.13 encourages. However, ahc_echo is an implementation of the libmicrohttpd access-handling callback whose prototype is defined by the external library as\n\n  enum MHD_Result (*access_handler)(void *cls, struct MHD_Connection *..., void **con_cls);\n\nand thus the parameter must use the non-const void *cls (and void **req_cls) to match the required prototype. Because the signature is mandated by an external API you cannot change it to const void *cls; the appropriate MISRA treatment is to document a justified deviation from Rule 8.13 for this callback. If such a documented deviation is absent in the project, then a strict MISRA audit could report a violation; but from the code alone this is a false positive \u2014 the non-const form is required by the library API. Therefore the report as an unconditional violation is not correct (it is only a violation if the non-const prototype is not a justified external requirement and no deviation has been recorded)."
}