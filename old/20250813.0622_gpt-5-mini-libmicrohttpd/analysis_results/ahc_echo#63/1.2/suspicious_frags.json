{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  /* Only one user has access to the page */\n  static const char *username = \"testuser\";\n  static const char *password = \"testpass\";\n  static const char *realm = \"test@example.com\";\n  enum MHD_DigestAuthResult res_e;\n  enum MHD_Result ret;\n  static int already_called_marker;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (&already_called_marker != *req_cls)\n  { /* Called for the first time, request not fully read yet */\n    *req_cls = &already_called_marker;\n    /* Wait for complete request */\n    return MHD_YES;\n  }\n\n  /* No need to call MHD_digest_auth_get_username3() as the only\n   * one user has an access. The username match is checked by\n   * MHD_digest_auth_check3() function. */\n  res_e = MHD_digest_auth_check3 (\n    connection,\n    realm,\n    username,\n    password,\n    0, 0,\n    MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n    MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION);\n  if (res_e != MHD_DAUTH_OK)\n  {\n    response =\n      MHD_create_response_from_buffer_static (strlen (DENIED),\n                                              DENIED);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_auth_required_response3 (\n      connection,\n      realm,\n      MY_OPAQUE_STR,\n      NULL,\n      response,\n      (res_e == MHD_DAUTH_NONCE_STALE) ? MHD_YES : MHD_NO,\n      MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT,\n      MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION,\n      MHD_NO,\n      MHD_YES);\n\n    MHD_destroy_response (response);\n    return ret;\n  }\n  response = MHD_create_response_from_buffer_static (strlen (PAGE), PAGE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function ahc_echo:\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\nenum MHD_DigestAuthResult\n{\n  /**\n   * Authentication OK.\n   */\n  MHD_DAUTH_OK = 1,\n\n  /**\n   * General error, like \"out of memory\".\n   */\n  MHD_DAUTH_ERROR = 0,\n\n  /**\n   * No \"Authorization\" header or wrong format of the header.\n   * Also may be returned if required parameters in client Authorisation header\n   * are missing or broken (in invalid format).\n   */\n  MHD_DAUTH_WRONG_HEADER = -1,\n\n  /**\n   * Wrong 'username'.\n   */\n  MHD_DAUTH_WRONG_USERNAME = -2,\n\n  /**\n   * Wrong 'realm'.\n   */\n  MHD_DAUTH_WRONG_REALM = -3,\n\n  /**\n   * Wrong 'URI' (or URI parameters).\n   */\n  MHD_DAUTH_WRONG_URI = -4,\n\n  /**\n   * Wrong 'qop'.\n   */\n  MHD_DAUTH_WRONG_QOP = -5,\n\n  /**\n   * Wrong 'algorithm'.\n   */\n  MHD_DAUTH_WRONG_ALGO = -6,\n\n  /**\n   * Too large (>64 KiB) Authorization parameter value.\n   */\n  MHD_DAUTH_TOO_LARGE = -15,\n\n  /* The different form of naming is intentionally used for the results below,\n   * as they are more important */\n\n  /**\n   * The 'nonce' is too old. Suggest the client to retry with the same\n   * username and password to get the fresh 'nonce'.\n   * The validity of the 'nonce' may be not checked.\n   */\n  MHD_DAUTH_NONCE_STALE = -17,\n\n  /**\n   * The 'nonce' was generated by MHD for other conditions.\n   * This value is only returned if #MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE\n   * is set to anything other than #MHD_DAUTH_BIND_NONCE_NONE.\n   * The interpretation of this code could be different. For example, if\n   * #MHD_DAUTH_BIND_NONCE_URI is set and client just used the same 'nonce' for\n   * another URI, the code could be handled as #MHD_DAUTH_NONCE_STALE as\n   * RFCs allow nonces re-using for other URIs in the same \"protection\n   * space\". However, if only #MHD_DAUTH_BIND_NONCE_CLIENT_IP bit is set and\n   * it is know that clients have fixed IP addresses, this return code could\n   * be handled like #MHD_DAUTH_NONCE_WRONG.\n   */\n  MHD_DAUTH_NONCE_OTHER_COND = -18,\n\n  /**\n   * The 'nonce' is wrong. May indicate an attack attempt.\n   */\n  MHD_DAUTH_NONCE_WRONG = -33,\n\n  /**\n   * The 'response' is wrong. Typically it means that wrong password used.\n   * May indicate an attack attempt.\n   */\n  MHD_DAUTH_RESPONSE_WRONG = -34\n}\n...\n#define MHD_HTTP_OK 200\n...\n#define DENIED \"<html><head><title>libmicrohttpd demo</title></head>\"\"<body>Access denied</body></html>\"\n...\n#define PAGE \"<html><head><title>libmicrohttpd demo</title></head>\"\"<body>Access granted</body></html>\"\n...\n#define MY_OPAQUE_STR \"11733b200778ce33060f31c9af70a870ba96ddd4\"\n...\n_MHD_EXTERN enum MHD_DigestAuthResult\nMHD_digest_auth_check3 (struct MHD_Connection *connection,\n                        const char *realm,\n                        const char *username,\n                        const char *password,\n                        unsigned int nonce_timeout,\n                        uint32_t max_nc,\n                        enum MHD_DigestAuthMultiQOP mqop,\n                        enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  mhd_assert (NULL != password);\n\n  return digest_auth_check_all (connection,\n                                realm,\n                                username,\n                                password,\n                                NULL,\n                                nonce_timeout,\n                                max_nc,\n                                mqop,\n                                malgo3);\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_required_response3 (struct MHD_Connection *connection,\n                                   const char *realm,\n                                   const char *opaque,\n                                   const char *domain,\n                                   struct MHD_Response *response,\n                                   int signal_stale,\n                                   enum MHD_DigestAuthMultiQOP mqop,\n                                   enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                   int userhash_support,\n                                   int prefer_utf8)\n{\n  struct DigestAlgorithm da;\n  char *buf_ptr;\n  enum MHD_Result ret;\n\n  buf_ptr = NULL;\n  digest_setup_zero (&da);\n  ret = queue_auth_required_response3_inner (connection,\n                                             realm,\n                                             opaque,\n                                             domain,\n                                             response,\n                                             signal_stale,\n                                             mqop,\n                                             malgo3,\n                                             userhash_support,\n                                             prefer_utf8,\n                                             &buf_ptr,\n                                             &da);\n  digest_deinit (&da);\n  if (NULL != buf_ptr)\n    free (buf_ptr);\n  return ret;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\nstruct MHD_Response\n...\nstruct MHD_Connection\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no uses of compiler-specific language extensions in the provided code. The following constructs might look unusual to a reviewer but are standard C and therefore not MISRA Rule 1.2 language-extension issues:\n\n- static local variables (e.g. static const char *username, static int already_called_marker): standard storage-duration specifiers.\n- (void) parameter casts to silence unused-parameter warnings: standard idiom in C.\n- Comparison of &already_called_marker with *req_cls (pointer comparison): pointer comparisons are standard C (no compiler extension is used here). Whether this comparison is semantically correct or compliant with other MISRA rules is a different matter, but it is not a compiler language extension.\n- String literal adjacency/concatenation in macros (e.g. DENIED and PAGE macros split across two quoted literals): standard C behavior.\n- Use of enums as types and enum values: standard C.\n- Preprocessor conditionals and macros (#if defined(...), #define, etc.): standard C preprocessor features.\n- Use of identifiers like _MHD_EXTERN in the additional code: the code shows the macro name but not its definition. Without the macro definition, we cannot assume it expands to a compiler-specific extension (for example, __attribute__ or __declspec). Since no explicit extension syntax (GCC __attribute__, MSVC __declspec, inline assembly, statement-expressions, nested functions, typeof, etc.) appears in the supplied code, there is nothing to report under Rule 1.2.\n\nTherefore no code fragment requires investigation for use of language/compiler extensions as defined by MISRA C 2023 Rule 1.2."
}