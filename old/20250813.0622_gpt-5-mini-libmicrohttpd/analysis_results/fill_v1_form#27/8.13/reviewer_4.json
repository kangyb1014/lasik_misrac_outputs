{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function add_session_cookie is declared as static void add_session_cookie (struct Session *session, struct MHD_Response *response) but only reads session->sid (it does not modify the Session). According to MISRA C 2023 Rule 8.13, the pointer parameter should be const-qualified when possible. Therefore add_session_cookie should accept a const struct Session * (and the call add_session_cookie(session, response); should pass a const-qualified pointer).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void probe_session_state(const char *stage,\n                                const struct Session *session,\n                                struct MHD_Response *response)\n{\n  /* Log pointer and (if non-null) the value_1 string. This mirrors what\n     fill_v1_form uses (session->value_1) so it helps show whether\n     add_session_cookie modifies that value. */\n  FILE *f = fopen(\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[%s] session=%p\", stage, (void *) session);\n  if (session != NULL)\n  {\n    /* Attempt to print value_1 as a string if non-NULL. This assumes\n       the original code's use of session->value_1 in snprintf implies\n       it is a C-string pointer. If it's NULL, indicate that. */\n    if (session->value_1 != NULL)\n    {\n      fprintf(f, \" value_1_ptr=%p value_1=\\\"%s\\\"\", (void *) session->value_1, session->value_1);\n    }\n    else\n    {\n      fprintf(f, \" value_1=(null)\");\n    }\n  }\n  if (response != NULL)\n    fprintf(f, \" response=%p\", (void *) response);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    /* Probes: log state before calling add_session_cookie */\n    probe_session_state(\"before_add_session_cookie\", session, response);\n\n    /* Capture the pre-call pointer value to detect modifications */\n    const char *pre_value = session->value_1;\n\n    add_session_cookie (session, response);\n\n    /* Capture post-call state and log differences */\n    const char *post_value = session->value_1;\n    probe_session_state(\"after_add_session_cookie\", session, response);\n\n    /* Record whether add_session_cookie changed session->value_1\n       (pointer equality is a safe check; if both non-NULL try string\n       comparison too). */\n    {\n      FILE *f = fopen(\"/tmp/logs/219.txt\", \"a\");\n      if (NULL != f)\n      {\n        if (pre_value == post_value)\n        {\n          fprintf(f, \"[check] session->value_1 pointer unchanged (pre==post)\\n\");\n        }\n        else\n        {\n          fprintf(f, \"[check] session->value_1 pointer changed (pre=%p post=%p)\\n\",\n                  (const void *) pre_value, (const void *) post_value);\n          if (pre_value && post_value)\n          {\n            /* Attempt string compare only when both pointers non-NULL. */\n            if (0 == strcmp(pre_value, post_value))\n              fprintf(f, \"[check] strings equal despite pointer change\\n\");\n            else\n              fprintf(f, \"[check] strings differ after call\\n\");\n          }\n        }\n        fclose(f);\n      }\n    }\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is plausible but not verifiable from the code you supplied. MISRA C:2023 Rule 8.13 indeed requires that pointer types be const-qualified when the pointee is not modified. In the snippet shown, fill_v1_form itself only reads session->value_1 and does not modify *session. That means fill_v1_form\u2019s parameter could be declared const struct Session *session if no callers or callees require a mutable pointer.\n\nAgent A\u2019s concrete accusation is about add_session_cookie having the prototype\n  static void add_session_cookie(struct Session *session, struct MHD_Response *response)\nand only reading session->sid. If that is true (i.e. add_session_cookie does not modify the Session object), then add_session_cookie should be declared to take const struct Session * and the code would indeed violate Rule 8.13 as reported. Conversely, if add_session_cookie or some other code reachable from here does modify the Session object, then the non-const parameter is justified and there is no violation.\n\nYou did not provide the add_session_cookie definition (only a probe harness that produced no logs), so there is no conclusive evidence in the materials that add_session_cookie is read-only. Therefore the report cannot be confirmed from the supplied code. To settle this concretely: inspect the implementation of add_session_cookie (and any functions it calls) \u2014 if they do not modify the Session object, change the parameter to const struct Session * and update callers. Avoid casting away const or using an explicit cast to call a non-const prototype, as that would defeat the intent of Rule 8.13 and may introduce other MISRA violations."
}