{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'session' is not modified in add_session_cookie (only read: session->sid is used in snprintf), so it should be declared as pointing to a const-qualified type (const struct Session *session). Leaving it as struct Session * violates MISRA C 2023 Rule 8.13. Change the prototype to: static void add_session_cookie (const struct Session *session, struct MHD_Response *response).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_session_state (const char *stage, const struct Session *session)\n{\n  FILE *f = fopen (\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"[fill_v1_form] %s\\n\", stage);\n  fprintf (f, \"  session_ptr=%p\\n\", (const void *) session);\n  if (NULL != session)\n  {\n    /* Log the field we know is used in this function. */\n    if (NULL != session->value_1)\n      fprintf (f, \"  session->value_1=\\\"%s\\\"\\n\", session->value_1);\n    else\n      fprintf (f, \"  session->value_1=NULL\\n\");\n  }\n  else\n  {\n    fprintf (f, \"  session is NULL\\n\");\n  }\n  fclose (f);\n}\nstatic void\nprobe_log_msg (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen (\"/tmp/logs/219.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry and initial session state */\n  probe_log_session_state (\"entry\", session);\n  probe_log_msg (\"mime=%p, connection=%p\", (const void *) mime, (const void *) connection);\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  probe_log_msg (\"snprintf computed reply_len=%d\", reply_len);\n  if (0 > reply_len)\n  {\n    probe_log_msg (\"error: snprintf returned negative (%d)\", reply_len);\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n  {\n    probe_log_msg (\"error: malloc failed for size %zu\", (size_t) ((size_t) reply_len + 1));\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    probe_log_msg (\"error: snprintf wrote unexpected number of bytes\");\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    /* Log state immediately before calling add_session_cookie to capture pre-state */\n    probe_log_session_state (\"before_add_session_cookie\", session);\n\n    add_session_cookie (session, response);\n\n    /* Log state immediately after calling add_session_cookie to capture post-state */\n    probe_log_session_state (\"after_add_session_cookie\", session);\n\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      probe_log_msg (\"warning: failed to set content type header\");\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log_msg (\"MHD_queue_response returned %d\", (int) ret);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    probe_log_msg (\"error: MHD_create_response_from_buffer_with_free_callback returned NULL\");\n    free (reply);\n    ret = MHD_NO;\n  }\n\n  probe_log_msg (\"exit returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Conclusion: The report is not proven correct. Analysis: fill_v1_form itself does not modify the object pointed to by session, so in isolation the parameter could be declared const struct Session *session. However MISRA C:2023 Rule 8.13 applies to the program-wide use of the pointer: a pointer should point to a const-qualified type whenever possible given all uses (including calls made from this function). In fill_v1_form the session pointer is passed to add_session_cookie (and possibly other APIs). Unless the definition and all called functions that receive that pointer are known to be non-mutating (and their prototypes accept const), you cannot conclude that the current non-const declaration is a definite MISRA violation. Agent A\u2019s suggested change (make add_session_cookie take const struct Session *) is valid only if add_session_cookie and all other callees truly do not modify the session object. Recommendation: inspect the definition and prototypes of add_session_cookie and any other callees; if they do not modify session, change their prototypes and then mark session const in fill_v1_form to satisfy Rule 8.13. As presented, the claim that fill_v1_form violates 8.13 is not proven, so the report is not correct."
}