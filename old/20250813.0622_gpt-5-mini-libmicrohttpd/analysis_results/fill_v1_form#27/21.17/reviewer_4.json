{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. The memmove()/memcpy() can write past the end of buf because buf_size is computed from an initial \u2018norm_len\u2019 estimate but the code then reduces norm_len and later unconditionally (only guarded by an mhd_assert) assumes there is extra space for inserting \"close, \". In the branch value_has_close && !already_has_close the memmove copies norm_len+1 bytes to buf + old_value_len + MHD_STATICSTR_LEN_(\"close, \") and memcpy writes the \"close\" token at buf. If the initially allocated buf_size (old_value_len + initial norm_len) is smaller than old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1 (the code only asserts this, does not enforce it), the memmove/memcpy will access beyond the allocated buffer. Therefore MISRA C 2023 Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_fill_v1_form_state(const char *phase,\n                       int reply_len,\n                       size_t alloc_size,\n                       const char *reply_ptr,\n                       int snprintf_ret,\n                       const char *value1_ptr,\n                       size_t value1_len,\n                       const void *session_ptr,\n                       const void *connection_ptr)\n{\n  FILE *f = fopen(\"/tmp/logs/223.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[fill_v1_form] phase=%s\\n\", phase);\n  fprintf(f, \"  session=%p, connection=%p\\n\", session_ptr, connection_ptr);\n  fprintf(f, \"  reply_len=%d, alloc_size=%zu, snprintf_ret=%d\\n\",\n          reply_len, alloc_size, snprintf_ret);\n  fprintf(f, \"  reply_ptr=%p\\n\", (const void *) reply_ptr);\n  if (value1_ptr != NULL)\n    fprintf(f, \"  value1_ptr=%p, value1_len=%zu\\n\", (const void *) value1_ptr, value1_len);\n  else\n    fprintf(f, \"  value1_ptr=(null)\\n\");\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry */\n  log_fill_v1_form_state(\"entry\", -1, 0, NULL, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  log_fill_v1_form_state(\"after_snprintf_len\", reply_len, 0, NULL, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  if (0 > reply_len)\n  {\n    log_fill_v1_form_state(\"error_snprintf_len_negative\", reply_len, 0, NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  log_fill_v1_form_state(\"after_malloc\", reply_len, (size_t) ((size_t) reply_len + 1), reply, -1,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  if (NULL == reply)\n  {\n    log_fill_v1_form_state(\"error_malloc_failed\", reply_len, (size_t) ((size_t) reply_len + 1), NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    log_fill_v1_form_state(\"error_snprintf_mismatch\", reply_len, (size_t) ((size_t) reply_len + 1), reply, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* Log after successful formatting */\n  log_fill_v1_form_state(\"after_successful_format\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                         session ? session->value_1 : NULL,\n                         (session && session->value_1) ? strlen(session->value_1) : 0,\n                         (const void *) session,\n                         (const void *) connection);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n      log_fill_v1_form_state(\"warning_no_content_type\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                             session ? session->value_1 : NULL,\n                             (session && session->value_1) ? strlen(session->value_1) : 0,\n                             (const void *) session,\n                             (const void *) connection);\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    log_fill_v1_form_state(\"after_queue_response\", reply_len, (size_t) ((size_t) reply_len + 1), reply, reply_len,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    log_fill_v1_form_state(\"error_create_response_failed\", reply_len, (size_t) ((size_t) reply_len + 1), NULL, -1,\n                           session ? session->value_1 : NULL,\n                           (session && session->value_1) ? strlen(session->value_1) : 0,\n                           (const void *) session,\n                           (const void *) connection);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's scenario refers to memmove/memcpy and inserting a \"close, \" token, but the provided fill_v1_form implementation does not call any <string.h> functions (memcpy, memmove, strlen, etc.). It uses snprintf to compute the required length, allocates reply_len+1 bytes, and then calls snprintf with that same size and checks the return value. That sequence correctly ensures the formatted content fits the allocated buffer and does not cause writes past the allocation. Therefore MISRA C:2023 Rule 21.17 (which specifically governs use of functions from <string.h>) is not violated by this code. (Note: if session->value_1 were NULL, passing it to %s would be undefined behaviour, but that is unrelated to Rule 21.17 and to the memmove/memcpy scenario described by the agent.)"
}