{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call to strlen(value) can read beyond the object when add_response_header_connection() is invoked with a pointer that is NULL or not NUL-terminated. MHD_add_response_header() does not check content for NULL before dispatching to add_response_header_connection(), so a caller that passes NULL (or a buffer without a terminating '\\0', e.g. char buf[4] = {'a','b','c','d'}; MHD_add_response_header(resp, \"Connection\", buf)) will cause strlen(value) (and the prior strchr calls) to read beyond the bounds of the provided object, violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified fill_v1_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/223.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of fill_v1_form as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of fill_v1_form:\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified fill_v1_form code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/* Probe logging helper. Writes debug information to /tmp/logs/223.txt. */\nstatic void\nwrite_log_entry(const char *event_label,\n                const void *cls,\n                const struct Session *session,\n                const struct MHD_Connection *connection,\n                struct MHD_Response *response,\n                const char *mime,\n                int reply_len,\n                const char *reply)\n{\n  FILE *f = fopen(\"/tmp/logs/223.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  time_t t = time(NULL);\n  (void) cls; /* preserve original unused parameter behavior */\n\n  fprintf(f, \"===============================\\n\");\n  fprintf(f, \"timestamp: %ld\\n\", (long)t);\n  fprintf(f, \"event: %s\\n\", event_label);\n  fprintf(f, \"session ptr: %p\\n\", (const void *) session);\n  /* Do NOT dereference session->value_1 here: that could read user data and\n     potentially go out-of-bounds. We only log the pointer value. */\n  if (session != NULL)\n  {\n    fprintf(f, \"session->value_1 ptr: %p\\n\", (const void *) session->value_1);\n  }\n  fprintf(f, \"connection ptr: %p\\n\", (const void *) connection);\n  fprintf(f, \"response ptr: %p\\n\", (void *) response);\n  fprintf(f, \"mime ptr: %p\\n\", (const void *) mime);\n  fprintf(f, \"mime_is_null: %s\\n\", (mime == NULL) ? \"YES\" : \"NO\");\n  fprintf(f, \"reply_len: %d\\n\", reply_len);\n  fprintf(f, \"reply ptr: %p\\n\", (const void *) reply);\n  /* reply was constructed using snprintf above and is NUL-terminated; log a\n     short preview to aid debugging. Limit to 200 chars to avoid overly\n     large logs. */\n  if (reply != NULL)\n  {\n    size_t to_print = 200U;\n    fprintf(f, \"reply_preview: \\\"\");\n    for (size_t i = 0U; i < to_print && reply[i] != '\\0'; ++i)\n      putc((int) reply[i], f);\n    fprintf(f, \"\\\"\\n\");\n  }\n\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n\n    /* Log relevant state before attempting to add the header. This records\n       pointer values and other state that can be used to reproduce a crash\n       or out-of-bounds read that may occur inside MHD_add_response_header.\n       Note: we deliberately do NOT dereference 'mime' or other user-supplied\n       pointers here to avoid introducing new out-of-bounds reads. */\n    write_log_entry(\"before_add_response_header\", cls, session, connection, response, mime, reply_len, reply);\n\n    /* Call and capture the return value so we can log it afterwards. If the\n       call crashes due to misuse of mime (e.g. NULL or non NUL-terminated\n       buffer), the log above will contain the pointer that was passed. */\n    int header_result = MHD_add_response_header (response,\n                                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                                 mime);\n\n    /* Log after the call as well (this will only be reached if the call\n       returned without crashing). */\n    write_log_entry(\"after_add_response_header\", cls, session, connection, response, mime, reply_len, reply);\n\n    if (MHD_YES != header_result)\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n"
}