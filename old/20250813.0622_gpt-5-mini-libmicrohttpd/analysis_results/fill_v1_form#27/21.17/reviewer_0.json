{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When MHD_add_response_header is called with header == MHD_HTTP_HEADER_CONNECTION and the content pointer is invalid for use with C string APIs (for example, NULL or a non-NUL-terminated buffer). add_response_header_connection immediately calls strchr(value, '\\r')/strchr(value, '\\n') without checking value for NULL or ensuring it points to a NUL-terminated object. If content == NULL or not NUL-terminated, strchr will access memory beyond the bounds of the referenced object, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nwrite_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/223.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic int\nprobe_MHD_add_response_header (struct MHD_Response *response,\n                               const char *header,\n                               const char *value)\n{\n  /* Log call site, pointers and header string (header is expected to be a constant).\n     Do not dereference 'value' (which may be NULL or non-NUL-terminated) to avoid\n     introducing additional undefined behaviour. */\n  write_probe_log (\"probe_MHD_add_response_header: response=%p header=%s value_ptr=%p\",\n                   (void *) response,\n                   (header != NULL) ? header : \"(null)\",\n                   (void *) value);\n\n  if (NULL == value)\n    write_probe_log (\"probe_MHD_add_response_header: value is NULL\");\n\n  int res = MHD_add_response_header (response, header, value);\n\n  write_probe_log (\"probe_MHD_add_response_header: underlying returned=%d\", res);\n  return res;\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Entry log */\n  write_probe_log (\"fill_v1_form: entry: session=%p mime=%p connection=%p\",\n                   (void *) session, (void *) mime, (void *) connection);\n\n  /* Log session->value_1 pointer without dereferencing it (safe) */\n  if (NULL != session)\n    write_probe_log (\"fill_v1_form: session->value_1 pointer=%p\", (void *) session->value_1);\n  else\n    write_probe_log (\"fill_v1_form: session is NULL\");\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  write_probe_log (\"fill_v1_form: snprintf(NULL,0) returned reply_len=%d\", reply_len);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  write_probe_log (\"fill_v1_form: malloc(%zu) returned reply=%p\",\n                   (size_t) ((size_t) reply_len + 1), (void *) reply);\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    write_probe_log (\"fill_v1_form: snprintf to reply failed (reply=%p)\", (void *) reply);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* Log a small safe portion of the reply pointer (pointer only; do not assume contents)\n     We avoid printing the string contents directly to prevent reading beyond bounds if the\n     buffer were somehow not NUL-terminated. */\n  write_probe_log (\"fill_v1_form: prepared reply buffer=%p length=%d\", (void *) reply, reply_len);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  write_probe_log (\"fill_v1_form: MHD_create_response returned response=%p\", (void *) response);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n\n    /* Use probe wrapper to log header call parameters and result. */\n    if (MHD_YES !=\n        probe_MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      write_probe_log (\"fill_v1_form: setting content-type header failed (mime_ptr=%p)\", (void *) mime);\n      /* return response without content type anyway ... */\n    }\n    else\n    {\n      write_probe_log (\"fill_v1_form: content-type header set successfully (mime_ptr=%p)\", (void *) mime);\n    }\n\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    write_probe_log (\"fill_v1_form: MHD_queue_response returned %d\", ret);\n    MHD_destroy_response (response);\n    write_probe_log (\"fill_v1_form: response destroyed\");\n  }\n  else\n  {\n    free (reply);\n    write_probe_log (\"fill_v1_form: response creation failed, freed reply and returning MHD_NO\");\n    ret = MHD_NO;\n  }\n  write_probe_log (\"fill_v1_form: exit ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct as applied to fill_v1_form. The function itself does not call any of the <string.h> functions listed by MISRA 21.17; the only suspect operations (strchr etc.) are said to occur inside MHD_add_response_header (a library function). If MHD_add_response_header indeed calls strchr(value, ...) without validating value, then the implementation of MHD_add_response_header would be the locus of a Rule 21.17 violation \u2014 not fill_v1_form. Moreover the scenario described by agent A refers to the CONNECTION header handling, but fill_v1_form calls MHD_add_response_header with MHD_HTTP_HEADER_CONTENT_TYPE, so the exact asserted trigger does not occur in the shown code. That said, callers should ensure they pass a valid NUL\u2011terminated non\u2011NULL string if the callee expects one; if the MHD API accepts NULL or non\u2011NUL buffers then its implementation must guard against that. But as written, the claim that fill_v1_form violates MISRA C 2023 Rule 21.17 is not supported."
}