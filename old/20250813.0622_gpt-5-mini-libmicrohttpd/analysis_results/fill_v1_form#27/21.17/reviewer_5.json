{
  "user_message": "An agent A claimed that the following fill_v1_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_form.\n```c\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  if (0 > reply_len)\n    return MHD_NO; /* Internal error */\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  if (NULL == reply)\n    return MHD_NO; /* Out-of-memory error */\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL != response)\n  {\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    free (reply);\n    ret = MHD_NO;\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. The call memcmp(hdr->value, \"close\", 5) unconditionally reads 5 bytes from hdr->value. hdr may be NULL (the subsequent mhd_assert(NULL != hdr) is evaluated after the memcmp) or hdr->value_size may be < 5, so memcmp can read beyond the buffer\u2019s bounds. This can cause out-of-bounds access and thus violates MISRA C 2023 Rule 21.17. A safe fix is to ensure hdr is non-NULL and hdr->value_size >= 5 before calling memcmp (or use a bounded compare that checks length first).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/223.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fflush (f);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  int reply_len;\n  (void) cls; /* Unused */\n\n  /* Log entry and parameter state. Do not dereference session->value_1 here\n     except to log its pointer; other reads follow original code flow. */\n  probe_log (\"enter fill_v1_form: cls=%p mime=%p session=%p connection=%p\",\n             cls, (const void *) mime, (const void *) session,\n             (const void *) connection);\n  if (session == NULL)\n    probe_log (\"session is NULL\");\n  else\n    probe_log (\"session->value_1 pointer=%p\", (const void *) session->value_1);\n\n  /* Emulate 'asprintf' */\n  reply_len = snprintf (NULL, 0, FORM_V1, session->value_1);\n  probe_log (\"snprintf(NULL,0,FORM_V1, session->value_1) returned reply_len=%d\",\n             reply_len);\n\n  if (0 > reply_len)\n  {\n    probe_log (\"reply_len < 0 -> returning MHD_NO\");\n    return MHD_NO; /* Internal error */\n  }\n\n  reply = (char *) malloc ((size_t) ((size_t) reply_len + 1));\n  probe_log (\"malloc requested bytes=%zu returned pointer=%p\",\n             (size_t) ((size_t) reply_len + 1), (const void *) reply);\n  if (NULL == reply)\n  {\n    probe_log (\"malloc returned NULL -> returning MHD_NO\");\n    return MHD_NO; /* Out-of-memory error */\n  }\n\n  if (reply_len != snprintf (reply,\n                             (size_t) (((size_t) reply_len) + 1),\n                             FORM_V1,\n                             session->value_1))\n  {\n    probe_log (\"second snprintf mismatch (expected %d) -> freeing reply and returning MHD_NO\",\n               reply_len);\n    free (reply);\n    return MHD_NO; /* printf error */\n  }\n  probe_log (\"formatted reply: pointer=%p length=%d\", (const void *) reply, reply_len);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback ((size_t) reply_len,\n                                                        (void *) reply,\n                                                        &free);\n  probe_log (\"MHD_create_response_from_buffer_with_free_callback returned response=%p\",\n             (const void *) response);\n  if (NULL != response)\n  {\n    probe_log (\"calling add_session_cookie(session=%p, response=%p)\",\n               (const void *) session, (const void *) response);\n    add_session_cookie (session, response);\n    if (MHD_YES !=\n        MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_CONTENT_TYPE,\n                                 mime))\n    {\n      probe_log (\"MHD_add_response_header failed to set content type header (response=%p, mime=%p)\",\n                 (const void *) response, (const void *) mime);\n      fprintf (stderr,\n               \"Failed to set content type header!\\n\");\n      /* return response without content type anyway ... */\n    }\n    else\n    {\n      probe_log (\"MHD_add_response_header succeeded (response=%p, mime=%p)\",\n                 (const void *) response, (const void *) mime);\n    }\n\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log (\"MHD_queue_response returned ret=%d (connection=%p, response=%p)\",\n               (int) ret, (const void *) connection, (const void *) response);\n    MHD_destroy_response (response);\n    probe_log (\"Destroyed response=%p\", (const void *) response);\n  }\n  else\n  {\n    probe_log (\"response creation failed -> freeing reply and returning MHD_NO\");\n    free (reply);\n    ret = MHD_NO;\n  }\n\n  probe_log (\"exit fill_v1_form returning ret=%d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Agent A\u2019s scenario discusses a memcmp(hdr->value, \"close\", 5) access and hdr possibly being NULL or too short, but the submitted fill_v1_form contains no memcmp and no reference to an hdr object. Rule 21.17 in MISRA C 2023 is explicitly about the string.h functions (memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, strspn, etc.). The code shown uses snprintf (from <stdio.h>), not a <string.h> function, so the specific Rule 21.17 claim as stated does not apply to this function.\n\nThat said, the code can still exhibit undefined behaviour if session or session->value_1 is NULL (snprintf with a %s argument will cause a read of the pointed string), or if the pointed buffer is not properly NUL-terminated; those are potential bugs but are not the memcmp/<string.h> violation described by Agent A. A correct fix for the actual code would be to validate session and session->value_1 (and ensure the string is well-formed) before calling snprintf, but this is a different issue than the claimed Rule 21.17 memcmp violation."
}