{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nIn parse_http_std_method the code uses memcmp to compare the method buffer (m), which is a NUL-terminated request method string, with a static literal (MHD_HTTP_METHOD_CONNECT) which is also NUL-terminated: (0 == memcmp (m, MHD_HTTP_METHOD_CONNECT, len)). This uses memcmp to compare null-terminated strings and therefore violates MISRA C 2023 Rule 21.14.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified get_request_line_inner code that contains useful probe functions that print useful logs to a file \"/tmp/logs/214.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of get_request_line_inner as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of get_request_line_inner:\n```c\nstatic bool\nget_request_line_inner (struct MHD_Connection *c)\n{\n  size_t p; /**< The current processing position */\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Allow to skip one or more empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_empty_lines = (1 >= discp_lvl);\n  /* Allow to skip more then one empty line before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_several_empty_lines = (skip_empty_lines && (0 >= discp_lvl));\n  /* Allow to skip number of unlimited empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_unlimited_empty_lines =\n    (skip_empty_lines && (-3 >= discp_lvl));\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2 */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Treat tab as whitespace delimiter.\n     RFC 9112, section 3 */\n  const bool tab_as_wsp = (0 >= discp_lvl);\n  /* Treat VT (vertical tab) and FF (form feed) as whitespace delimiters.\n     RFC 9112, section 3 */\n  const bool other_wsp_as_wsp = (-1 >= discp_lvl);\n  /* Treat continuous whitespace block as a single space.\n     RFC 9112, section 3 */\n  const bool wsp_blocks = (-1 >= discp_lvl);\n  /* Parse whitespace in URI, special parsing of the request line.\n     RFC 9112, section 3.2 */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI.\n     Violates RFC 9112, section 3.2 */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2 */\n  const bool bare_cr_keep = (wsp_in_uri_keep && (-3 >= discp_lvl));\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n\n  mhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n\n  if (0 == c->read_buffer_offset)\n  {\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    return false; /* No data to process */\n  }\n  p = c->rq.hdrs.rq_line.proc_pos;\n  mhd_assert (p <= c->read_buffer_offset);\n\n  /* Skip empty lines, if any (and if allowed) */\n  /* See RFC 9112, section 2.2 */\n  if ((0 == p)\n      && (skip_empty_lines))\n  {\n    /* Skip empty lines before the request line.\n       See RFC 9112, section 2.2 */\n    bool is_empty_line;\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_assert (NULL == c->rq.method);\n    mhd_assert (NULL == c->rq.url);\n    mhd_assert (0 == c->rq.url_len);\n    mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n    mhd_assert (0 == c->rq.req_target_len);\n    mhd_assert (NULL == c->rq.version);\n    do\n    {\n      is_empty_line = false;\n      if ('\\r' == c->read_buffer[0])\n      {\n        if (1 == c->read_buffer_offset)\n          return false; /* Not enough data yet */\n        if ('\\n' == c->read_buffer[1])\n        {\n          is_empty_line = true;\n          c->read_buffer += 2;\n          c->read_buffer_size -= 2;\n          c->read_buffer_offset -= 2;\n          c->rq.hdrs.rq_line.skipped_empty_lines++;\n        }\n      }\n      else if (('\\n' == c->read_buffer[0]) &&\n               (bare_lf_as_crlf))\n      {\n        is_empty_line = true;\n        c->read_buffer += 1;\n        c->read_buffer_size -= 1;\n        c->read_buffer_offset -= 1;\n        c->rq.hdrs.rq_line.skipped_empty_lines++;\n      }\n      if (is_empty_line)\n      {\n        if ((! skip_unlimited_empty_lines) &&\n            (((unsigned int) ((skip_several_empty_lines) ?\n                              MHD_MAX_EMPTY_LINES_SKIP : 1)) <\n             c->rq.hdrs.rq_line.skipped_empty_lines))\n        {\n          connection_close_error (c,\n                                  _ (\"Too many meaningless extra empty lines \" \\\n                                     \"received before the request\"));\n          return true; /* Process connection closure */\n        }\n        if (0 == c->read_buffer_offset)\n          return false;  /* No more data to process */\n      }\n    } while (is_empty_line);\n  }\n  /* All empty lines are skipped */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVING;\n  /* Read and parse the request line */\n  mhd_assert (1 <= c->read_buffer_offset);\n\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n    /*\n       The processing logic is different depending on the configured strictness:\n\n       When whitespace BLOCKS are NOT ALLOWED, the end of the whitespace is\n       processed BEFORE processing of the current character.\n       When whitespace BLOCKS are ALLOWED, the end of the whitespace is\n       processed AFTER processing of the current character.\n\n       When space char in the URI is ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed only at the END of the line.\n       When space in the URI is NOT ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed as soon as the FIRST whitespace is\n       found after URI start.\n     */\n\n    end_of_line = false;\n\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                (c->rq.hdrs.rq_line.last_ws_end > \\\n                 c->rq.hdrs.rq_line.last_ws_start));\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_start) || \\\n                (0 != c->rq.hdrs.rq_line.last_ws_end));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (p + 1 == c->read_buffer_offset)\n      {\n        c->rq.hdrs.rq_line.proc_pos = p;\n        return false; /* Not enough data yet */\n      }\n      else if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          /* A quick simple check whether this line looks like an HTTP request */\n          if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n              (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n          {\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          }\n          else\n            connection_close_error (c,\n                                    _ (\"Bare CR characters are not allowed \" \\\n                                       \"in the request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2 */\n      if (bare_lf_as_crlf)\n        end_of_line = true;\n      else\n      {\n        /* While RFC does not enforce error for bare LF character,\n           if this char is not treated as a line delimiter, it should be\n           rejected to avoid any security weakness due to request smuggling. */\n        /* A quick simple check whether this line looks like an HTTP request */\n        if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n            (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n        {\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        }\n        else\n          connection_close_error (c,\n                                  _ (\"Bare LF characters are not allowed \" \\\n                                     \"in the request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    if (end_of_line)\n    {\n      /* Handle the end of the request line */\n\n      if (NULL != c->rq.method)\n      {\n        if (wsp_in_uri)\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be determined now. */\n          mhd_assert (NULL == c->rq.version);\n          mhd_assert (0 == c->rq.req_target_len);\n          if (0 != c->rq.hdrs.rq_line.last_ws_end)\n          {\n            /* Determine the end and the length of the URI */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->read_buffer [c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.req_target_len =\n                c->rq.hdrs.rq_line.last_ws_start\n                - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else if ((c->rq.hdrs.rq_line.last_ws_start + 1 <\n                      c->rq.hdrs.rq_line.last_ws_end) &&\n                     (HTTP_VER_LEN == (p - c->rq.hdrs.rq_line.last_ws_end)))\n            {\n              /* Found only HTTP method and HTTP version and more than one\n                 whitespace between them. Assume zero-length URI. */\n              mhd_assert (wsp_blocks);\n              c->rq.hdrs.rq_line.last_ws_start++;\n              c->read_buffer[c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.hdrs.rq_line.rq_tgt =\n                c->read_buffer + c->rq.hdrs.rq_line.last_ws_start;\n              c->rq.req_target_len = 0;\n              c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n              c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n            }\n            /* Determine the start of the HTTP version string */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->rq.version = c->read_buffer + c->rq.hdrs.rq_line.last_ws_end;\n            }\n          }\n        }\n        else\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be already known. */\n          if ((NULL == c->rq.version)\n              && (NULL != c->rq.hdrs.rq_line.rq_tgt)\n              && (HTTP_VER_LEN == p - (size_t) (c->rq.hdrs.rq_line.rq_tgt\n                                                - c->read_buffer))\n              && (0 != c->read_buffer[(size_t)\n                                      (c->rq.hdrs.rq_line.rq_tgt\n                                       - c->read_buffer) - 1]))\n          {\n            /* Found only HTTP method and HTTP version and more than one\n               whitespace between them. Assume zero-length URI. */\n            size_t uri_pos;\n            mhd_assert (wsp_blocks);\n            mhd_assert (0 == c->rq.req_target_len);\n            uri_pos = (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer) - 1;\n            mhd_assert (uri_pos < p);\n            c->rq.version = c->rq.hdrs.rq_line.rq_tgt;\n            c->read_buffer[uri_pos] = 0;  /* Zero terminate the URI */\n            c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + uri_pos;\n            c->rq.req_target_len = 0;\n            c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n            c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n          }\n        }\n\n        if (NULL != c->rq.version)\n        {\n          mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n          if (! parse_http_version (c, c->rq.version,\n                                    p\n                                    - (size_t) (c->rq.version\n                                                - c->read_buffer)))\n          {\n            mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state);\n            return true; /* Unsupported / broken HTTP version */\n          }\n          c->read_buffer[p] = 0; /* Zero terminate the HTTP version strings */\n          if ('\\r' == chr)\n          {\n            p++; /* Consume CR */\n            mhd_assert (p < c->read_buffer_offset); /* The next character has been already checked */\n          }\n          p++; /* Consume LF */\n          c->read_buffer += p;\n          c->read_buffer_size -= p;\n          c->read_buffer_offset -= p;\n          mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n                      c->rq.req_target_len);\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (0 != c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      ((size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                                 - c->rq.hdrs.rq_line.rq_tgt) < \\\n                       c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt_qmark >= \\\n                       c->rq.hdrs.rq_line.rq_tgt));\n          return true; /* The request line is successfully parsed */\n        }\n      }\n      /* Error in the request line */\n\n      /* A quick simple check whether this line looks like an HTTP request */\n      if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n          (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n      {\n        transmit_error_response_static (c,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_MALFORMED);\n      }\n      else\n        connection_close_error (c,\n                                _ (\"The request line is malformed.\\n\"));\n\n      return true;\n    }\n\n    /* Process possible end of the previously found whitespace delimiter */\n    if ((! wsp_blocks) &&\n        (p == c->rq.hdrs.rq_line.last_ws_end) &&\n        (0 != c->rq.hdrs.rq_line.last_ws_end))\n    {\n      /* Previous character was a whitespace char and whitespace blocks\n         are not allowed. */\n      /* The current position is the next character after\n         a whitespace delimiter */\n      if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n      {\n        /* The current position is the start of the URI */\n        mhd_assert (0 == c->rq.req_target_len);\n        mhd_assert (NULL == c->rq.version);\n        c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n        /* Reset the whitespace marker */\n        c->rq.hdrs.rq_line.last_ws_start = 0;\n        c->rq.hdrs.rq_line.last_ws_end = 0;\n      }\n      else\n      {\n        /* It was a whitespace after the start of the URI */\n        if (! wsp_in_uri)\n        {\n          mhd_assert ((0 != c->rq.req_target_len) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n          mhd_assert (NULL == c->rq.version); /* Too many whitespaces? This error is handled at whitespace start */\n          c->rq.version = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n      }\n    }\n\n    /* Process the current character.\n       Is it not the end of the line.  */\n    if ((' ' == chr)\n        || (('\\t' == chr) && (tab_as_wsp))\n        || ((other_wsp_as_wsp) && ((0xb == chr) || (0xc == chr))))\n    {\n      /* A whitespace character */\n      if ((0 == c->rq.hdrs.rq_line.last_ws_end) ||\n          (p != c->rq.hdrs.rq_line.last_ws_end) ||\n          (! wsp_blocks))\n      {\n        /* Found first whitespace char of the new whitespace block */\n        if (NULL == c->rq.method)\n        {\n          /* Found the end of the HTTP method string */\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_start);\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_end);\n          mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          if (0 == p)\n          {\n            connection_close_error (c,\n                                    _ (\"The request line starts with \"\n                                       \"a whitespace.\\n\"));\n            return true; /* Error in the request */\n          }\n          c->read_buffer[p] = 0; /* Zero-terminate the request method string */\n          c->rq.method = c->read_buffer;\n          parse_http_std_method (c, c->rq.method, p);\n        }\n        else\n        {\n          /* A whitespace after the start of the URI */\n          if (! wsp_in_uri)\n          {\n            /* Whitespace in URI is not allowed to be parsed */\n            if (NULL == c->rq.version)\n            {\n              mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n              /* This is a delimiter between URI and HTTP version string */\n              c->read_buffer[p] = 0; /* Zero-terminate request URI string */\n              mhd_assert (((size_t) (c->rq.hdrs.rq_line.rq_tgt   \\\n                                     - c->read_buffer)) <= p);\n              c->rq.req_target_len =\n                p - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else\n            {\n              /* This is a delimiter AFTER version string */\n\n              /* A quick simple check whether this line looks like an HTTP request */\n              if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n                  (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n              {\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                RQ_LINE_TOO_MANY_WSP);\n              }\n              else\n                connection_close_error (c,\n                                        _ (\"The request line has more than \"\n                                           \"two whitespaces.\\n\"));\n              return true; /* Error in the request */\n            }\n          }\n          else\n          {\n            /* Whitespace in URI is allowed to be parsed */\n            if (0 != c->rq.hdrs.rq_line.last_ws_end)\n            {\n              /* The whitespace after the start of the URI has been found already */\n              c->rq.hdrs.rq_line.num_ws_in_uri +=\n                c->rq.hdrs.rq_line.last_ws_end\n                - c->rq.hdrs.rq_line.last_ws_start;\n            }\n          }\n        }\n        c->rq.hdrs.rq_line.last_ws_start = p;\n        c->rq.hdrs.rq_line.last_ws_end = p + 1; /* Will be updated on the next char parsing */\n      }\n      else\n      {\n        /* Continuation of the whitespace block */\n        mhd_assert (0 != c->rq.hdrs.rq_line.last_ws_end);\n        mhd_assert (0 != p);\n        c->rq.hdrs.rq_line.last_ws_end = p + 1;\n      }\n    }\n    else\n    {\n      /* Non-whitespace char, not the end of the line */\n      mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                  (c->rq.hdrs.rq_line.last_ws_end == p) || \\\n                  wsp_in_uri);\n\n      if ((p == c->rq.hdrs.rq_line.last_ws_end) &&\n          (0 != c->rq.hdrs.rq_line.last_ws_end) &&\n          (wsp_blocks))\n      {\n        /* The end of the whitespace block */\n        if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n        {\n          /* This is the first character of the URI */\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n        else\n        {\n          if (! wsp_in_uri)\n          {\n            /* This is the first character of the HTTP version */\n            mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n            mhd_assert ((0 != c->rq.req_target_len) || \\\n                        (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n            mhd_assert (NULL == c->rq.version); /* Handled at whitespace start */\n            c->rq.version = c->read_buffer + p;\n            /* Reset the whitespace marker */\n            c->rq.hdrs.rq_line.last_ws_start = 0;\n            c->rq.hdrs.rq_line.last_ws_end = 0;\n          }\n        }\n      }\n\n      /* Handle other special characters */\n      if ('?' == chr)\n      {\n        if ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) &&\n            (NULL != c->rq.hdrs.rq_line.rq_tgt))\n        {\n          c->rq.hdrs.rq_line.rq_tgt_qmark = c->read_buffer + p;\n        }\n      }\n      else if ((0xb == chr) || (0xc == chr))\n      {\n        /* VT or LF characters */\n        mhd_assert (! other_wsp_as_wsp);\n        if ((NULL != c->rq.hdrs.rq_line.rq_tgt) &&\n            (NULL == c->rq.version) &&\n            (wsp_in_uri))\n        {\n          c->rq.hdrs.rq_line.num_ws_in_uri++;\n        }\n        else\n        {\n          connection_close_error (c,\n                                  _ (\"Invalid character is in the \"\n                                     \"request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n      else if (0 == chr)\n      {\n        /* NUL character */\n        connection_close_error (c,\n                                _ (\"The NUL character is in the \"\n                                   \"request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    p++;\n  }\n\n  c->rq.hdrs.rq_line.proc_pos = p;\n  return false; /* Not enough data yet */\n}\n```\n</target_code>\nPlease provide the modified get_request_line_inner code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n/* Probe logging helper: append messages to /tmp/logs/214.txt */\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/214.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic void\nprobe_log_state_entry (struct MHD_Connection *c)\n{\n  if (NULL == c)\n  {\n    probe_log (\"get_request_line_inner: c == NULL\");\n    return;\n  }\n  probe_log (\"get_request_line_inner ENTER: c=%p, state=%d, read_buffer_offset=%zu, rq.http_mthd=%d, rq.method=%p\",\n             (void *) c, c->state, c->read_buffer_offset, c->rq.http_mthd, (void *) c->rq.method);\n}\n\nstatic void\nprobe_log_method_found (struct MHD_Connection *c, const char *method, size_t len)\n{\n  /* method is NUL-terminated at this point in original logic */\n  if (NULL == method)\n  {\n    probe_log (\"Method found: NULL, len=%zu\", len);\n    return;\n  }\n  /* Truncate long methods in the log to avoid huge outputs */\n  size_t dump_len = len;\n  if (dump_len > 256u)\n    dump_len = 256u;\n  /* Write method content as a string (it is zero-terminated by original code) */\n  probe_log (\"Method found: method_ptr=%p, len=%zu, method_str='%.*s'\",\n             (void *) method, len, (int) dump_len, method);\n}\n\nstatic bool\nget_request_line_inner (struct MHD_Connection *c)\n{\n  size_t p; /**< The current processing position */\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Allow to skip one or more empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_empty_lines = (1 >= discp_lvl);\n  /* Allow to skip more then one empty line before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_several_empty_lines = (skip_empty_lines && (0 >= discp_lvl));\n  /* Allow to skip number of unlimited empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_unlimited_empty_lines =\n    (skip_empty_lines && (-3 >= discp_lvl));\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2 */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Treat tab as whitespace delimiter.\n     RFC 9112, section 3 */\n  const bool tab_as_wsp = (0 >= discp_lvl);\n  /* Treat VT (vertical tab) and FF (form feed) as whitespace delimiters.\n     RFC 9112, section 3 */\n  const bool other_wsp_as_wsp = (-1 >= discp_lvl);\n  /* Treat continuous whitespace block as a single space.\n     RFC 9112, section 3 */\n  const bool wsp_blocks = (-1 >= discp_lvl);\n  /* Parse whitespace in URI, special parsing of the request line.\n     RFC 9112, section 3.2 */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI.\n     Violates RFC 9112, section 3.2 */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2 */\n  const bool bare_cr_keep = (wsp_in_uri_keep && (-3 >= discp_lvl));\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n\n  probe_log_state_entry (c);\n\n  mhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n\n  if (0 == c->read_buffer_offset)\n  {\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    probe_log (\"get_request_line_inner: no data to process (read_buffer_offset==0)\");\n    return false; /* No data to process */\n  }\n  p = c->rq.hdrs.rq_line.proc_pos;\n  mhd_assert (p <= c->read_buffer_offset);\n\n  /* Skip empty lines, if any (and if allowed) */\n  /* See RFC 9112, section 2.2 */\n  if ((0 == p)\n      && (skip_empty_lines))\n  {\n    /* Skip empty lines before the request line.\n       See RFC 9112, section 2.2 */\n    bool is_empty_line;\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_assert (NULL == c->rq.method);\n    mhd_assert (NULL == c->rq.url);\n    mhd_assert (0 == c->rq.url_len);\n    mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n    mhd_assert (0 == c->rq.req_target_len);\n    mhd_assert (NULL == c->rq.version);\n    do\n    {\n      is_empty_line = false;\n      if ('\\r' == c->read_buffer[0])\n      {\n        if (1 == c->read_buffer_offset)\n          return false; /* Not enough data yet */\n        if ('\\n' == c->read_buffer[1])\n        {\n          is_empty_line = true;\n          c->read_buffer += 2;\n          c->read_buffer_size -= 2;\n          c->read_buffer_offset -= 2;\n          c->rq.hdrs.rq_line.skipped_empty_lines++;\n          probe_log (\"Skipped CRLF empty line, total_skipped=%u\", c->rq.hdrs.rq_line.skipped_empty_lines);\n        }\n      }\n      else if (('\\n' == c->read_buffer[0]) &&\n               (bare_lf_as_crlf))\n      {\n        is_empty_line = true;\n        c->read_buffer += 1;\n        c->read_buffer_size -= 1;\n        c->read_buffer_offset -= 1;\n        c->rq.hdrs.rq_line.skipped_empty_lines++;\n        probe_log (\"Skipped LF empty line (bare_lf_as_crlf), total_skipped=%u\", c->rq.hdrs.rq_line.skipped_empty_lines);\n      }\n      if (is_empty_line)\n      {\n        if ((! skip_unlimited_empty_lines) &&\n            (((unsigned int) ((skip_several_empty_lines) ?\n                              MHD_MAX_EMPTY_LINES_SKIP : 1)) <\n             c->rq.hdrs.rq_line.skipped_empty_lines))\n        {\n          connection_close_error (c,\n                                  _ (\"Too many meaningless extra empty lines \" \\\n                                     \"received before the request\"));\n          probe_log (\"Too many skipped empty lines -> closing connection\");\n          return true; /* Process connection closure */\n        }\n        if (0 == c->read_buffer_offset)\n          return false;  /* No more data to process */\n      }\n    } while (is_empty_line);\n  }\n  /* All empty lines are skipped */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVING;\n  /* Read and parse the request line */\n  mhd_assert (1 <= c->read_buffer_offset);\n\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    end_of_line = false;\n\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                (c->rq.hdrs.rq_line.last_ws_end > \\\n                 c->rq.hdrs.rq_line.last_ws_start));\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_start) || \\\n                (0 != c->rq.hdrs.rq_line.last_ws_end));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (p + 1 == c->read_buffer_offset)\n      {\n        c->rq.hdrs.rq_line.proc_pos = p;\n        probe_log (\"Encountered CR at buffer end, proc_pos=%zu\", p);\n        return false; /* Not enough data yet */\n      }\n      else if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          probe_log (\"Replaced bare CR with space at pos=%zu, total_replaced=%u\", p, c->rq.num_cr_sp_replaced);\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          /* A quick simple check whether this line looks like an HTTP request */\n          if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n              (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n          {\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n            probe_log (\"Bare CR in header -> transmitted BAD_REQUEST\");\n          }\n          else\n            connection_close_error (c,\n                                    _ (\"Bare CR characters are not allowed \" \\\n                                       \"in the request line.\\n\"));\n          probe_log (\"Bare CR not allowed -> closing/response\");\n          return true; /* Error in the request */\n        }\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2 */\n      if (bare_lf_as_crlf)\n        end_of_line = true;\n      else\n      {\n        /* While RFC does not enforce error for bare LF character,\n           if this char is not treated as a line delimiter, it should be\n           rejected to avoid any security weakness due to request smuggling. */\n        /* A quick simple check whether this line looks like an HTTP request */\n        if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n            (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n        {\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n          probe_log (\"Bare LF in header -> transmitted BAD_REQUEST\");\n        }\n        else\n          connection_close_error (c,\n                                  _ (\"Bare LF characters are not allowed \" \\\n                                     \"in the request line.\\n\"));\n        probe_log (\"Bare LF not allowed -> closing/response\");\n        return true; /* Error in the request */\n      }\n    }\n\n    if (end_of_line)\n    {\n      /* Handle the end of the request line */\n\n      if (NULL != c->rq.method)\n      {\n        if (wsp_in_uri)\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be determined now. */\n          mhd_assert (NULL == c->rq.version);\n          mhd_assert (0 == c->rq.req_target_len);\n          if (0 != c->rq.hdrs.rq_line.last_ws_end)\n          {\n            /* Determine the end and the length of the URI */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->read_buffer [c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.req_target_len =\n                c->rq.hdrs.rq_line.last_ws_start\n                - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else if ((c->rq.hdrs.rq_line.last_ws_start + 1 <\n                      c->rq.hdrs.rq_line.last_ws_end) &&\n                     (HTTP_VER_LEN == (p - c->rq.hdrs.rq_line.last_ws_end)))\n            {\n              /* Found only HTTP method and HTTP version and more than one\n                 whitespace between them. Assume zero-length URI. */\n              mhd_assert (wsp_blocks);\n              c->rq.hdrs.rq_line.last_ws_start++;\n              c->read_buffer[c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.hdrs.rq_line.rq_tgt =\n                c->read_buffer + c->rq.hdrs.rq_line.last_ws_start;\n              c->rq.req_target_len = 0;\n              c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n              c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n            }\n            /* Determine the start of the HTTP version string */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->rq.version = c->read_buffer + c->rq.hdrs.rq_line.last_ws_end;\n            }\n          }\n        }\n        else\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be already known. */\n          if ((NULL == c->rq.version)\n              && (NULL != c->rq.hdrs.rq_line.rq_tgt)\n              && (HTTP_VER_LEN == p - (size_t) (c->rq.hdrs.rq_line.rq_tgt\n                                                - c->read_buffer))\n              && (0 != c->read_buffer[(size_t)\n                                      (c->rq.hdrs.rq_line.rq_tgt\n                                       - c->read_buffer) - 1]))\n          {\n            /* Found only HTTP method and HTTP version and more than one\n               whitespace between them. Assume zero-length URI. */\n            size_t uri_pos;\n            mhd_assert (wsp_blocks);\n            mhd_assert (0 == c->rq.req_target_len);\n            uri_pos = (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer) - 1;\n            mhd_assert (uri_pos < p);\n            c->rq.version = c->rq.hdrs.rq_line.rq_tgt;\n            c->read_buffer[uri_pos] = 0;  /* Zero terminate the URI */\n            c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + uri_pos;\n            c->rq.req_target_len = 0;\n            c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n            c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n          }\n        }\n\n        if (NULL != c->rq.version)\n        {\n          mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n          if (! parse_http_version (c, c->rq.version,\n                                    p\n                                    - (size_t) (c->rq.version\n                                                - c->read_buffer)))\n          {\n            mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state);\n            probe_log (\"parse_http_version failed: closing or unsupported version\");\n            return true; /* Unsupported / broken HTTP version */\n          }\n          c->read_buffer[p] = 0; /* Zero terminate the HTTP version strings */\n          if ('\\r' == chr)\n          {\n            p++; /* Consume CR */\n            mhd_assert (p < c->read_buffer_offset); /* The next character has been already checked */\n          }\n          p++; /* Consume LF */\n          c->read_buffer += p;\n          c->read_buffer_size -= p;\n          c->read_buffer_offset -= p;\n          mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n                      c->rq.req_target_len);\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (0 != c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      ((size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                                 - c->rq.hdrs.rq_line.rq_tgt) < \\\n                       c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt_qmark >= \\\n                       c->rq.hdrs.rq_line.rq_tgt));\n          probe_log (\"Request line parsed successfully: method=%p, rq_tgt=%p, version=%p, consumed=%zu\",\n                     (void *) c->rq.method, (void *) c->rq.hdrs.rq_line.rq_tgt, (void *) c->rq.version, p);\n          return true; /* The request line is successfully parsed */\n        }\n      }\n      /* Error in the request line */\n\n      /* A quick simple check whether this line looks like an HTTP request */\n      if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n          (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n      {\n        transmit_error_response_static (c,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_MALFORMED);\n        probe_log (\"Request malformed -> transmitted BAD_REQUEST\");\n      }\n      else\n        connection_close_error (c,\n                                _ (\"The request line is malformed.\\n\"));\n\n      probe_log (\"Request line malformed -> closing/response\");\n      return true;\n    }\n\n    /* Process possible end of the previously found whitespace delimiter */\n    if ((! wsp_blocks) &&\n        (p == c->rq.hdrs.rq_line.last_ws_end) &&\n        (0 != c->rq.hdrs.rq_line.last_ws_end))\n    {\n      /* Previous character was a whitespace char and whitespace blocks\n         are not allowed. */\n      /* The current position is the next character after\n         a whitespace delimiter */\n      if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n      {\n        /* The current position is the start of the URI */\n        mhd_assert (0 == c->rq.req_target_len);\n        mhd_assert (NULL == c->rq.version);\n        c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n        /* Reset the whitespace marker */\n        c->rq.hdrs.rq_line.last_ws_start = 0;\n        c->rq.hdrs.rq_line.last_ws_end = 0;\n      }\n      else\n      {\n        /* It was a whitespace after the start of the URI */\n        if (! wsp_in_uri)\n        {\n          mhd_assert ((0 != c->rq.req_target_len) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n          mhd_assert (NULL == c->rq.version); /* Too many whitespaces? This error is handled at whitespace start */\n          c->rq.version = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n      }\n    }\n\n    /* Process the current character.\n       Is it not the end of the line.  */\n    if ((' ' == chr)\n        || (('\\t' == chr) && (tab_as_wsp))\n        || ((other_wsp_as_wsp) && ((0xb == chr) || (0xc == chr))))\n    {\n      /* A whitespace character */\n      if ((0 == c->rq.hdrs.rq_line.last_ws_end) ||\n          (p != c->rq.hdrs.rq_line.last_ws_end) ||\n          (! wsp_blocks))\n      {\n        /* Found first whitespace char of the new whitespace block */\n        if (NULL == c->rq.method)\n        {\n          /* Found the end of the HTTP method string */\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_start);\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_end);\n          mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          if (0 == p)\n          {\n            connection_close_error (c,\n                                    _ (\"The request line starts with \"\n                                       \"a whitespace.\\n\"));\n            probe_log (\"Request line starts with whitespace -> closing\");\n            return true; /* Error in the request */\n          }\n          c->read_buffer[p] = 0; /* Zero-terminate the request method string */\n          c->rq.method = c->read_buffer;\n          /* Probe: log the method string and length before calling parse_http_std_method\n             This is important for reproducing the MISRA Rule 21.14 violation, since\n             parse_http_std_method uses memcmp to compare NUL-terminated strings. */\n          probe_log_method_found (c, c->rq.method, p);\n          probe_log (\"Calling parse_http_std_method: c=%p, method=%p, len=%zu\",\n                     (void *) c, (void *) c->rq.method, p);\n          parse_http_std_method (c, c->rq.method, p);\n        }\n        else\n        {\n          /* A whitespace after the start of the URI */\n          if (! wsp_in_uri)\n          {\n            /* Whitespace in URI is not allowed to be parsed */\n            if (NULL == c->rq.version)\n            {\n              mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n              /* This is a delimiter between URI and HTTP version string */\n              c->read_buffer[p] = 0; /* Zero-terminate request URI string */\n              mhd_assert (((size_t) (c->rq.hdrs.rq_line.rq_tgt   \\\n                                     - c->read_buffer)) <= p);\n              c->rq.req_target_len =\n                p - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else\n            {\n              /* This is a delimiter AFTER version string */\n\n              /* A quick simple check whether this line looks like an HTTP request */\n              if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n                  (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n              {\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                RQ_LINE_TOO_MANY_WSP);\n                probe_log (\"Too many whitespaces in request line -> transmitted BAD_REQUEST\");\n              }\n              else\n                connection_close_error (c,\n                                        _ (\"The request line has more than \"\n                                           \"two whitespaces.\\n\"));\n              probe_log (\"Too many whitespaces -> closing/response\");\n              return true; /* Error in the request */\n            }\n          }\n          else\n          {\n            /* Whitespace in URI is allowed to be parsed */\n            if (0 != c->rq.hdrs.rq_line.last_ws_end)\n            {\n              /* The whitespace after the start of the URI has been found already */\n              c->rq.hdrs.rq_line.num_ws_in_uri +=\n                c->rq.hdrs.rq_line.last_ws_end\n                - c->rq.hdrs.rq_line.last_ws_start;\n            }\n          }\n        }\n        c->rq.hdrs.rq_line.last_ws_start = p;\n        c->rq.hdrs.rq_line.last_ws_end = p + 1; /* Will be updated on the next char parsing */\n      }\n      else\n      {\n        /* Continuation of the whitespace block */\n        mhd_assert (0 != c->rq.hdrs.rq_line.last_ws_end);\n        mhd_assert (0 != p);\n        c->rq.hdrs.rq_line.last_ws_end = p + 1;\n      }\n    }\n    else\n    {\n      /* Non-whitespace char, not the end of the line */\n      mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                  (c->rq.hdrs.rq_line.last_ws_end == p) || \\\n                  wsp_in_uri);\n\n      if ((p == c->rq.hdrs.rq_line.last_ws_end) &&\n          (0 != c->rq.hdrs.rq_line.last_ws_end) &&\n          (wsp_blocks))\n      {\n        /* The end of the whitespace block */\n        if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n        {\n          /* This is the first character of the URI */\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n        else\n        {\n          if (! wsp_in_uri)\n          {\n            /* This is the first character of the HTTP version */\n            mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n            mhd_assert ((0 != c->rq.req_target_len) || \\\n                        (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n            mhd_assert (NULL == c->rq.version); /* Handled at whitespace start */\n            c->rq.version = c->read_buffer + p;\n            /* Reset the whitespace marker */\n            c->rq.hdrs.rq_line.last_ws_start = 0;\n            c->rq.hdrs.rq_line.last_ws_end = 0;\n          }\n        }\n      }\n\n      /* Handle other special characters */\n      if ('?' == chr)\n      {\n        if ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) &&\n            (NULL != c->rq.hdrs.rq_line.rq_tgt))\n        {\n          c->rq.hdrs.rq_line.rq_tgt_qmark = c->read_buffer + p;\n        }\n      }\n      else if ((0xb == chr) || (0xc == chr))\n      {\n        /* VT or LF characters */\n        mhd_assert (! other_wsp_as_wsp);\n        if ((NULL != c->rq.hdrs.rq_line.rq_tgt) &&\n            (NULL == c->rq.version) &&\n            (wsp_in_uri))\n        {\n          c->rq.hdrs.rq_line.num_ws_in_uri++;\n        }\n        else\n        {\n          connection_close_error (c,\n                                  _ (\"Invalid character is in the \"\n                                     \"request line.\\n\"));\n          probe_log (\"Invalid VT/FF in request line -> closing\");\n          return true; /* Error in the request */\n        }\n      }\n      else if (0 == chr)\n      {\n        /* NUL character */\n        connection_close_error (c,\n                                _ (\"The NUL character is in the \"\n                                   \"request line.\\n\"));\n        probe_log (\"NUL in request line -> closing\");\n        return true; /* Error in the request */\n      }\n    }\n\n    p++;\n  }\n\n  c->rq.hdrs.rq_line.proc_pos = p;\n  probe_log (\"get_request_line_inner: not enough data yet, updated proc_pos=%zu\", p);\n  return false; /* Not enough data yet */\n}\n"
}