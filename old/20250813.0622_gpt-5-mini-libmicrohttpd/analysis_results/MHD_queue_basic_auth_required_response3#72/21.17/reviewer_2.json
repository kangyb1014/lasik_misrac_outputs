{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strlen(realm) is performed without validating that 'realm' is non-NULL and NUL-terminated. If callers pass NULL or a char buffer that is not terminated, strlen will read past the object bounds (or dereference NULL), violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *stage,\n                              const struct MHD_Connection *connection,\n                              const char *realm,\n                              int prefer_utf8,\n                              struct MHD_Response *response,\n                              size_t realm_len,\n                              size_t h_maxlen,\n                              size_t pos)\n{\n  FILE *f = fopen(\"/tmp/logs/583.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Print a compact snapshot of relevant pointers and sizes. Do not\n     dereference 'realm' here to avoid changing the original behavior or\n     introducing additional out-of-bounds accesses. */\n  fprintf(f, \"stage=%s conn=%p realm=%p prefer_utf8=%d response=%p realm_len=%zu h_maxlen=%zu pos=%zu\\n\",\n          stage,\n          (void *) connection,\n          (void *) realm,\n          prefer_utf8,\n          (void *) response,\n          realm_len,\n          h_maxlen,\n          pos);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  /* Log entry state (do not change behavior). realm pointer is logged but not\n     dereferenced here. This allows reproducing the scenario where realm is\n     NULL or invalid: if realm is NULL, the subsequent strlen(realm) will fail\n     as in the original code and the log will contain the realm pointer value. */\n  mhd_probe_log(\"entry\", connection, realm, prefer_utf8, response, 0, 0, 0);\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n\n  /* Log just before calling strlen to capture the pointer value prior to the\n     potentially unsafe call. Do not attempt to access *realm here. */\n  mhd_probe_log(\"before_strlen\", connection, realm, prefer_utf8, response, 0, 0, 0);\n\n  realm_len = strlen (realm);\n\n  /* Log immediately after strlen to capture the length computed by strlen.\n     If strlen crashes (e.g., realm == NULL or not NUL-terminated), the log\n     file will contain the \"before_strlen\" entry but not this \"after_strlen\"\n     entry, which serves as evidence of the failure point. */\n  mhd_probe_log(\"after_strlen\", connection, realm, prefer_utf8, response, realm_len, 0, 0);\n\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  /* Log computed h_maxlen before allocation */\n  mhd_probe_log(\"before_malloc\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, 0);\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    /* Log malloc failure */\n    mhd_probe_log(\"malloc_failed\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, 0);\n    return MHD_NO;\n  }\n\n  /* Log successful allocation and pointer to buffer */\n  mhd_probe_log(\"malloc_ok\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, (size_t) (uintptr_t) h_str);\n\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n\n  pos += realm_quoted_len;\n\n  /* Log after quoting the realm */\n  mhd_probe_log(\"after_str_quote\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, pos);\n\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  /* Log right before adding the response header */\n  mhd_probe_log(\"before_add_response_header\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, pos);\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n\n  /* Log result of adding header */\n  mhd_probe_log(\"after_add_response_header\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, (size_t) ret);\n\n  free (h_str);\n\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    /* Log after queuing response */\n    mhd_probe_log(\"after_queue_response\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, (size_t) ret);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n    /* Log failure branch */\n    mhd_probe_log(\"add_response_header_failed\", connection, realm, prefer_utf8, response, realm_len, h_maxlen, 0);\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_queue_basic_auth_required_response3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function calls strlen(realm) (and then passes the computed realm_len and realm to MHD_str_quote) without checking that realm is non-NULL or otherwise guaranteed to be NUL-terminated. Under the text of MISRA C 2023 Rule 21.17, use of string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. If a caller were to pass realm == NULL or a non-NUL-terminated buffer, strlen would dereference out-of-bounds (or NULL), and subsequent operations using realm_len and realm could read past object bounds \u2014 precisely the behaviour the rule forbids. Note: if there is an external, documented and enforced API precondition that realm is non-NULL and NUL-terminated, the use may be acceptable; however, nothing in the presented code enforces or documents such a precondition, so as presented this is a violation. Recommended fixes: validate realm != NULL before calling strlen (or document and enforce the non-NULL/NUL-terminated precondition), and if possible use APIs that accept a length or otherwise bound reads."
}