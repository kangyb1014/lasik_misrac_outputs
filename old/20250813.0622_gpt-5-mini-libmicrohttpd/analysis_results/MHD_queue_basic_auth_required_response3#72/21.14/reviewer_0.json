{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls memcmp(hdr->value, \"close\", 5) where hdr->value is stored/managed as a null-terminated C string (buf[pos] = 0 is used when headers are built). Using memcmp here effectively compares a null-terminated string against a literal \u2014 which is exactly what MISRA C 2023 Rule 21.14 forbids. A string comparison function such as strcmp/strncmp should be used instead.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nMHD_probe_log_basic_auth_state (const char *stage,\n                               struct MHD_Connection *connection,\n                               const char *realm,\n                               int prefer_utf8,\n                               size_t prefix_len,\n                               size_t realm_len,\n                               size_t realm_quoted_len,\n                               size_t suffix_len,\n                               size_t h_maxlen,\n                               size_t pos,\n                               const char *h_str,\n                               int result_code)\n{\n  FILE *f = fopen (\"/tmp/logs/582.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log control path and key state information useful for reproducing\n     the reported memcmp-vs-string scenario. We do not alter program state. */\n  fprintf (f, \"[MHD_probe] stage=%s connection=%p realm=%p prefer_utf8=%d\\n\",\n           stage, (void *) connection, (const void *) realm, prefer_utf8);\n  fprintf (f, \"[MHD_probe] prefix_len=%zu realm_len=%zu realm_quoted_len=%zu suffix_len=%zu h_maxlen=%zu pos=%zu result=%d\\n\",\n           prefix_len, realm_len, realm_quoted_len, suffix_len, h_maxlen, pos, result_code);\n  if (realm != NULL)\n    fprintf (f, \"[MHD_probe] realm (quoted length=%zu) = '%s'\\n\",\n             realm_len, realm);\n  if (h_str != NULL)\n  {\n    /* Print the header buffer content. Use %s to show the NUL-terminated\n       string passed to MHD_add_response_header. In the non-UTF8 branch the\n       header is explicitly 0-terminated early; this log will show that. */\n    fprintf (f, \"[MHD_probe] h_str (as string) = '%s'\\n\", h_str);\n    /* Also print bytes up to h_maxlen (hex) to capture any embedded NULs */\n    fprintf (f, \"[MHD_probe] h_str (hex up to h_maxlen) =\");\n    for (size_t i = 0; i < h_maxlen + 1 && h_str[i] != '\\0'; ++i)\n      fprintf (f, \" %02X\", (unsigned char) h_str[i]);\n    /* If we stopped because of NUL, indicate that */\n    if (h_str[0] != '\\0')\n      fprintf (f, \" 00\");\n    fprintf (f, \"\\n\");\n  }\n  fflush (f);\n  fclose (f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  /* Entry probe */\n  MHD_probe_log_basic_auth_state (\"entry\", connection, realm, prefer_utf8,\n                                  prefix_len, 0U, 0U, 0U, 0U, 0U, NULL, -1);\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    /* Log malloc failure */\n    MHD_probe_log_basic_auth_state (\"malloc_fail\", connection, realm, prefer_utf8,\n                                    prefix_len, realm_len, 0U, suffix_len,\n                                    h_maxlen, 0U, NULL, -1);\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  /* Log constructed header buffer before adding it to the response */\n  MHD_probe_log_basic_auth_state (\"before_add_header\", connection, realm,\n                                  prefer_utf8, prefix_len, realm_len,\n                                  realm_quoted_len, suffix_len, h_maxlen,\n                                  pos, h_str, -1);\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n\n  /* Log result of adding header */\n  MHD_probe_log_basic_auth_state (\"after_add_header\", connection, realm,\n                                  prefer_utf8, prefix_len, realm_len,\n                                  realm_quoted_len, suffix_len, h_maxlen,\n                                  pos, h_str, (int) ret);\n\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    /* Log result of queuing response */\n    MHD_probe_log_basic_auth_state (\"after_queue_response\", connection, realm,\n                                    prefer_utf8, prefix_len, realm_len,\n                                    realm_quoted_len, suffix_len, h_maxlen,\n                                    pos, NULL, (int) ret);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_queue_basic_auth_required_response3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the provided MHD_queue_basic_auth_required_response3 source: that function does not call memcmp anywhere \u2014 it uses memcpy, strlen and MHD_str_quote and builds a NUL-terminated header string, but no memcmp-based comparison is present. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null-terminated strings; if there is a memcmp(hdr->value, \"close\", 5) call elsewhere in the codebase (or inside MHD_add_response_header or another function not shown) then that specific call would indeed violate 21.14 because hdr->value is a null-terminated C string. However, based on the code you supplied, the claim that MHD_queue_basic_auth_required_response3 itself violates Rule 21.14 is incorrect. Recommendation: search the codebase for memcmp usages that compare C strings (e.g. memcmp(..., \"...\", n)) and replace those with strcmp/strncmp as appropriate, or ensure the compared objects are non-string binary buffers so the use of memcmp is justified and not a MISRA violation."
}