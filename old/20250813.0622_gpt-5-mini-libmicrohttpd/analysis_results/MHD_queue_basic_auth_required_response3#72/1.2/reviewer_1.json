{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro defines _MHD_EXTERN as __attribute__((visibility(\"default\"))) extern. The use of GCC/Clang\u2019s __attribute__((...)) syntax is a compiler-specific language extension (documented as a GCC/Clang extension) and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log_enter(const char *stage, struct MHD_Connection *connection,\n                                   const char *realm, int prefer_utf8,\n                                   struct MHD_Response *response,\n                                   size_t h_maxlen, size_t realm_len,\n                                   size_t realm_quoted_len, size_t pos,\n                                   enum MHD_Result ret)\n{\n  FILE *f = fopen(\"/tmp/logs/576.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"[%s] func=%s stage=%s conn=%p realm=%p prefer_utf8=%d response=%p h_maxlen=%zu realm_len=%zu realm_quoted_len=%zu pos=%zu ret=%d\\n\",\n          __TIME__, __func__, stage, (void *) connection, (void *) realm, prefer_utf8,\n          (void *) response, h_maxlen, realm_len, realm_quoted_len, pos,\n          (int) ret);\n  fflush(f);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  /* Log entry */\n  mhd_probe_log_enter(\"enter\", connection, realm, prefer_utf8, response,\n                      0, 0, 0, 0, 0);\n\n  if (NULL == response)\n  {\n    mhd_probe_log_enter(\"null_response\", connection, realm, prefer_utf8,\n                        response, 0, 0, 0, 0, MHD_NO);\n    return MHD_NO;\n  }\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  /* Log computed sizes */\n  mhd_probe_log_enter(\"computed_sizes\", connection, realm, prefer_utf8,\n                      response, h_maxlen, realm_len, 0, 0, 0);\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log_enter(\"malloc_failed\", connection, realm, prefer_utf8,\n                        response, h_maxlen, realm_len, 0, 0, MHD_NO);\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n\n  /* Log after quoting the realm */\n  mhd_probe_log_enter(\"after_quote\", connection, realm, prefer_utf8,\n                      response, h_maxlen, realm_len, realm_quoted_len, pos, 0);\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  /* Log the header string about to be added (if sensible) */\n  {\n    FILE *f = fopen(\"/tmp/logs/576.txt\", \"a\");\n    if (f != NULL)\n    {\n      /* limit output length to avoid huge logs */\n      size_t outlen = strlen(h_str);\n      if (outlen > 1024)\n        outlen = 1024;\n      fprintf(f, \"[%s] func=%s stage=before_add_header header_preview=\\\"\");\n      fwrite(h_str, 1, outlen, f);\n      if (outlen < strlen(h_str))\n        fprintf(f, \"...\" );\n      fprintf(f, \"\\\" pos=%zu h_maxlen=%zu\\n\", pos, h_maxlen);\n      fflush(f);\n      fclose(f);\n    }\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n\n  /* Log result of adding header */\n  mhd_probe_log_enter(\"after_add_header\", connection, realm, prefer_utf8,\n                      response, h_maxlen, realm_len, realm_quoted_len, pos, ret);\n\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    /* Log after queue response */\n    mhd_probe_log_enter(\"after_queue_response\", connection, realm, prefer_utf8,\n                        response, h_maxlen, realm_len, realm_quoted_len, pos, ret);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log_enter(\"add_header_failed\", connection, realm, prefer_utf8,\n                        response, h_maxlen, realm_len, realm_quoted_len, pos, ret);\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_queue_basic_auth_required_response3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct provided the macro actually expands to a GCC/Clang attribute. MISRA C:2023 Rule 1.2 forbids use of compiler-specific language extensions. The code as posted uses the identifier _MHD_EXTERN rather than showing its definition; by itself that does not prove a violation. However, the scenario states that _MHD_EXTERN is defined as __attribute__((visibility(\"default\"))) extern. GCC/Clang\u2019s __attribute__((...)) syntax is a documented compiler extension (not standard C), so using it (even via a macro) is a use of a language extension and thus would violate Rule 1.2. The added test logging and successful compilation do not negate the presence of the extension. If, alternatively, _MHD_EXTERN is defined as empty or in a strictly standard-compliant way on the target toolchain, then no violation would occur for that build; the correctness of the report depends on the actual macro definition in the build environment. Given the stated macro definition, the report is correct."
}