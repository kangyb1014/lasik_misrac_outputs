{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function declaration uses the macro _MHD_EXTERN which is defined as __attribute__((visibility(\"default\"))) extern. The use of GCC-style __attribute__ is a compiler-specific language extension (documented as such), so Rule 1.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const char *MHD_HTTP_HEADER_WWW_AUTHENTICATE = \"WWW-Authenticate\";\nstatic const int MHD_HTTP_UNAUTHORIZED = 401;\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/576.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  const size_t prefix_len = sizeof (prefix) - 1;\n  const size_t suff_simple_len = 1; /* '\"' */\n  const size_t suff_charset_len = sizeof (suff_charset) - 1;\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  mhd_probe_log (\"ENTER: MHD_queue_basic_auth_required_response3 - connection=%p, realm=%s, prefer_utf8=%d, response=%p\",\n                 (void *) connection, (realm ? realm : \"(null)\"), prefer_utf8, (void *) response);\n\n  if (NULL == response)\n  {\n    mhd_probe_log (\"EARLY RETURN: response is NULL\");\n    return MHD_NO;\n  }\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  mhd_probe_log (\"CALC: prefix_len=%zu, realm_len=%zu, suffix_len=%zu, h_maxlen=%zu\",\n                 prefix_len, realm_len, suffix_len, h_maxlen);\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n    mhd_probe_log (\"ALLOC FAIL: malloc returned NULL for size %zu\", h_maxlen + 1);\n    return MHD_NO;\n  }\n  mhd_probe_log (\"ALLOC OK: h_str=%p\", (void *) h_str);\n\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  assert (pos + suffix_len <= h_maxlen);\n\n  mhd_probe_log (\"AFTER QUOTE: realm_quoted_len=%zu, pos=%zu\", realm_quoted_len, pos);\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    assert (pos <= h_maxlen + 1);\n    mhd_probe_log (\"PREFER NOT UTF8: added '\\\\\"' and terminating NUL, pos=%zu\", pos);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    assert (0 == h_str[pos + suff_charset_len]);\n    mhd_probe_log (\"PREFER UTF8: copied suff_charset at pos=%zu, suff_charset_len=%zu, terminator=%d\",\n                   pos, suff_charset_len, (int) (h_str[pos + suff_charset_len] == 0));\n  }\n\n  mhd_probe_log (\"HEADER READY: h_str='%s'\", h_str);\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  mhd_probe_log (\"MHD_add_response_header returned %d\", (int) ret);\n\n  free (h_str);\n  mhd_probe_log (\"FREED: h_str freed\");\n\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n    mhd_probe_log (\"MHD_queue_response returned %d\", (int) ret);\n  }\n  else\n  {\n    mhd_probe_log (\"ERROR: Failed to add Basic Authentication header (ret=%d)\", (int) ret);\n  }\n  mhd_probe_log (\"EXIT: MHD_queue_basic_auth_required_response3 returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function declaration uses the macro _MHD_EXTERN which (per the scenario) expands to __attribute__((visibility(\"default\"))) extern. The GCC-style __attribute__ syntax is a compiler-specific language extension (documented as such by GCC) and therefore falls within the scope of MISRA C 2023 Rule 1.2 (language extensions should not be used). The inability to compile the supplied test harness does not change the fact that the original code employs a documented compiler extension, so the reported violation is valid."
}