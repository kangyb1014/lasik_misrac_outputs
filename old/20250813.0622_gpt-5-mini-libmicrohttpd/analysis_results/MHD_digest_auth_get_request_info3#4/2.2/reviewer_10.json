{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement \"mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\" is a dead operation because the macro mhd_assert is defined as ((void)0). After macro expansion the statement becomes a no-op; removing it would not change program behaviour, so it is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log_uname(const char *tag,\n                                     enum MHD_DigestAuthUsernameType uname_type,\n                                     size_t unif_buf_size,\n                                     size_t unif_buf_used)\n{\n  FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Log control point tag, uname_type and buffer sizing state. */\n  fprintf(f, \"%s: uname_type=%d unif_buf_size=%zu unif_buf_used=%zu\\n\",\n          tag, (int) uname_type, unif_buf_size, unif_buf_used);\n  fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n  {\n    /* Log early return due to missing params */\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf(f, \"MHD_digest_auth_get_request_info3: params == NULL -> returning NULL\\n\");\n      fclose(f);\n    }\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  /* Log uname_type immediately after it's determined */\n  mhd_probe_log_uname(\"after_get_rq_uname_type\", uname_type, unif_buf_size, 0);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  /* Log the buffer state immediately before the assertion location. This\n     will help demonstrate that the assert call expands to a no-op in the\n     build where mhd_assert is defined as ((void)0). */\n  mhd_probe_log_uname(\"before_assert\", uname_type, unif_buf_size, unif_buf_used);\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  /* Log again after the assertion to show control passed through the\n     assertion statement (which may be a no-op after macro expansion). */\n  mhd_probe_log_uname(\"after_assert\", uname_type, unif_buf_size, unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  /* Final state log before returning. */\n  {\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf(f, \"returning info=%p uname_type=%d unif_buf_size=%zu unif_buf_used=%zu qop=%u nc=%u\\n\",\n              (void *) info, (int) uname_type, unif_buf_size, unif_buf_used,\n              (unsigned) info->qop, (unsigned) info->nc);\n      fclose(f);\n    }\n  }\n\n  return info;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_get_request_info3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s underlying reasoning is correct in principle: if mhd_assert is defined as ((void)0) in the project, the assertion statement becomes a no-op expression statement whose removal would not change program behaviour \u2014 that meets the definition of dead code in MISRA C:2023 Rule 2.2. Note: the provided source actually contains mhd_assert(unif_buf_size >= unif_buf_used); (the agent quoted a different asserted expression), but that difference is incidental to the argument. If the project\u2019s mhd_assert is compiled out to ((void)0), the statement is effectively dead and thus would violate Rule 2.2. If, however, mhd_assert is defined to perform a runtime action in the project\u2019s configuration, then it is not dead. To conform, either ensure the assert performs a required action in all project builds, guard it explicitly with conditional compilation that is visible to the project reviewers, or document an accepted deviation."
}