{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as ((void)0) in the project, so the statement mhd_assert(get_rq_uname_type(params) == uname_type); has no effect at runtime and can be removed without changing program behaviour. This is dead code (an executed/no-op assertion used only for diagnostics and compiled out), violating MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/34.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  mhd_probe_log(\"ENTER: MHD_digest_auth_get_request_info3(connection=%p)\", (void *)connection);\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  mhd_probe_log(\"params pointer: %p\", (void *)params);\n  if (NULL == params)\n  {\n    mhd_probe_log(\"EXIT: params == NULL -> returning NULL\");\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n  mhd_probe_log(\"uname_type (after get_rq_uname_type): %d\", (int)uname_type);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n  mhd_probe_log(\"unif_buf_size (after get_rq_unames_size): %zu\", unif_buf_size);\n\n  if (NULL != params->opaque.value.str)\n  {\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n    mhd_probe_log(\"opaque present, adding %zu -> unif_buf_size=%zu\", (size_t)(params->opaque.value.len + 1), unif_buf_size);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n    mhd_probe_log(\"realm present, adding %zu -> unif_buf_size=%zu\", (size_t)(params->realm.value.len + 1), unif_buf_size);\n  }\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  mhd_probe_log(\"allocated info=%p (requested bytes=%zu)\", (void *)info, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n  mhd_probe_log(\"info->algo3 set to %d\", (int)info->algo3);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  mhd_probe_log(\"after uname handling: info=%p uname_type=%d unif_buf_used=%zu unif_buf_size=%zu\",\n                (void *)info, (int)info->uname_type, unif_buf_used, unif_buf_size);\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n    mhd_probe_log(\"copied opaque -> info->opaque=%p opaque_len=%zu unif_buf_used=%zu\",\n                  (void *)info->opaque, info->opaque_len, unif_buf_used);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n    mhd_probe_log(\"copied realm -> info->realm=%p realm_len=%zu unif_buf_used=%zu\",\n                  (void *)info->realm, info->realm_len, unif_buf_used);\n  }\n\n  /* Probe around the original assertion location to capture the condition. */\n  mhd_probe_log(\"ASSERTION_POINT: unif_buf_size=%zu unif_buf_used=%zu (expect unif_buf_size >= unif_buf_used)\",\n                unif_buf_size, unif_buf_used);\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  /* Log that control reached past the mhd_assert. If mhd_assert is compiled out,\n     this line demonstrates the assertion did not affect control flow. */\n  mhd_probe_log(\"POST_ASSERTION: reached after mhd_assert (no runtime effect observed)\");\n\n  info->qop = params->qop;\n  mhd_probe_log(\"info->qop set to %d\", (int)info->qop);\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n  mhd_probe_log(\"info->cnonce_len=%zu\", info->cnonce_len);\n\n  nc_res = get_rq_nc (params, &info->nc);\n  mhd_probe_log(\"get_rq_nc returned %d, info->nc=%u\", (int)nc_res, (unsigned)info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  mhd_probe_log(\"EXIT: returning info=%p\", (void *)info);\n  return info;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_get_request_info3. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Agent A\u2019s reasoning is flawed in two ways: (1) the concrete assertion cited in the scenario (mhd_assert(get_rq_uname_type(params) == uname_type);) does not appear in the supplied function \u2014 the actual assertion in the target code is mhd_assert(unif_buf_size >= unif_buf_used); (2) MISRA\u2011C\u20112023 Rule 2.2 speaks of dead code as \u201cAny operation that is executed but whose removal would not affect program behaviour.\u201d If mhd_assert is defined to expand to ((void)0) then there is no runtime operation produced by that source assertion (no code is executed) \u2014 it is not an \u201cexecuted\u201d operation and therefore does not meet the rule\u2019s definition of dead code. If the assertion macro were implemented so that the argument were still evaluated (i.e. it produces side effects) or emitted code even when \u201cdisabled\u201d, removing it could change behavior and would need to be considered; conversely, if the macro expands to a no\u2011op and the argument has no side effects, removal would not change behavior but also there is no executed operation to classify as dead by the rule. In short: the agent\u2019s claim that this function violates MISRA Rule 2.2 because of a compiled\u2011out mhd_assert is not correct. A proper check would be to (a) inspect the actual mhd_assert macro in the project, and (b) verify whether any assertion arguments have side effects. Tools may still warn about disabled assertions as a style/maintenance issue, but that is not the same as a straightforward Rule 2.2 violation as argued by Agent A."
}