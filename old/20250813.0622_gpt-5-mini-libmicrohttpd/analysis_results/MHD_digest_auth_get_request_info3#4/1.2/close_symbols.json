{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_get_request_info3': {'callees': ['MHD_get_rq_dauth_params_', 'get_rq_uname_type', 'get_rq_unames_size', 'get_rq_uname', 'get_rq_param_unquoted_copy_z', 'get_rq_nc'], 'callers': []}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}, 'get_rq_uname_type': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_unames_size': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_param_unquoted_copy_z': {'callees': ['MHD_str_unquote'], 'callers': ['get_rq_uname', 'MHD_digest_auth_get_request_info3']}, 'get_rq_nc': {'callees': ['MHD_str_unquote', 'MHD_strx_to_uint64_n_'], 'callers': ['MHD_digest_auth_get_request_info3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN (macro/definition)",
    "struct MHD_DigestAuthInfo (full definition)",
    "struct MHD_RqDAuth (full definition)",
    "enum MHD_DigestAuthUsernameType (definition)",
    "MHD_calloc_ (macro or function definition)",
    "mhd_assert (macro/definition)",
    "MHD_DIGEST_AUTH_UNAME_TYPE_MISSING (enum/macro)",
    "MHD_DIGEST_AUTH_UNAME_TYPE_INVALID (enum/macro)",
    "MHD_GET_RQ_NC_VALID (enum/macro)",
    "MHD_DIGEST_AUTH_INVALID_NC_VALUE (macro/enum)",
    "MHD_get_rq_dauth_params_ (declaration/definition)",
    "get_rq_uname_type (definition)",
    "get_rq_unames_size (definition)",
    "get_rq_uname (definition)",
    "get_rq_param_unquoted_copy_z (definition)",
    "get_rq_nc (definition)"
  ],
  "explanation": "For checking use of compiler language extensions you must inspect any macros, type definitions and helper routines that the target function depends on because extensions often appear there rather than in the small wrapper itself. Brief reasons: \n\n- _MHD_EXTERN (macro/definition): may expand to compiler-specific storage-class/attribute syntax (e.g. __attribute__, __declspec) \u2014 these are explicit language extensions.\n- struct MHD_DigestAuthInfo (full definition): the function allocates extra bytes and then uses (info + 1). If the struct uses a zero-length array (GCC extension) or other non\u2011standard member (anonymous/extension fields), that is an explicit extension to detect.\n- struct MHD_RqDAuth (full definition): the code indexes nested fields (params->opaque.value.str, realm, qop, cnonce, nc); those nested types may contain extensions (anonymous structs/unions, bitfields with implementation-defined layout, zero-length arrays) that must be checked.\n- enum MHD_DigestAuthUsernameType (definition): to verify the enum declaration does not use compiler extensions or non\u2011portable attributes.\n- MHD_calloc_ (macro or function definition): allocation helper may be a macro that uses typeof, statement-expressions, or attributes (GCC/clang extensions); inspect its definition.\n- mhd_assert (macro/definition): assert macro can hide compiler builtins or extensions (__builtin_expect, statement-expression, asm) \u2014 check its expansion.\n- MHD_DIGEST_AUTH_UNAME_TYPE_MISSING / MHD_DIGEST_AUTH_UNAME_TYPE_INVALID / MHD_GET_RQ_NC_VALID / MHD_DIGEST_AUTH_INVALID_NC_VALUE (enum/constants): need their definitions to ensure they are plain enum/constants and not declared via extension mechanisms (e.g. macros producing complex expressions or attributes).\n- MHD_get_rq_dauth_params_ (declaration/definition): although called, it might be a macro or inline that uses extensions; its header/definition should be checked for extensions used in the call site (e.g. statement-expression returning pointer).\n- get_rq_uname_type, get_rq_unames_size, get_rq_uname, get_rq_param_unquoted_copy_z, get_rq_nc (definitions): these helpers are invoked or their return values are used inside the function. They might be implemented as macros, inlines or use compiler-specific builtins/attributes; their definitions must be inspected to ensure no language extensions are used that affect the semantics of the target function.\n\nCollecting these symbols (their declarations/definitions and macro expansions) lets the next analyzer determine whether any language/compiler extensions are present in code used directly by the target function."
}