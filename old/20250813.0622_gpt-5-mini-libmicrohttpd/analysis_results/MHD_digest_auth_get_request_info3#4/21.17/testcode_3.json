{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nViolation possible: get_rq_param_unquoted_copy_z performs memcpy(buf, param->value.str, param->value.len) without receiving or checking buf size. Although callers (e.g. MHD_digest_auth_get_request_info3) normally compute and allocate space (param->value.len + 1), there is no overflow/limit check when accumulating unif_buf_size (size_t additions can wrap) and no formal contract enforced that buf is large enough. If an attacker-supplied header yields very large param->value.len (or causes unif_buf_size to wrap) the allocated buffer may be too small and memcpy will write past buf, violating Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_digest_auth_get_request_info3 code that contains useful probe functions that print useful logs to a file \"/tmp/logs/39.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_digest_auth_get_request_info3 as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_get_request_info3:\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\nPlease provide the modified MHD_digest_auth_get_request_info3 code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stddef.h>\n\nstatic void mhd_log39(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/39.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  mhd_log39(\"MHD_digest_auth_get_request_info3: connection=%p, params=%p\", (void *)connection, (void *)params);\n  if (NULL == params)\n  {\n    mhd_log39(\"MHD_digest_auth_get_request_info3: params is NULL, returning NULL\");\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n  mhd_log39(\"initial unif_buf_size=%zu\", unif_buf_size);\n\n  uname_type = get_rq_uname_type (params);\n  mhd_log39(\"uname_type=%d\", (int)uname_type);\n\n  /* get_rq_unames_size may be non-trivial; call it once and log the effect */\n  {\n    size_t add = get_rq_unames_size (params, uname_type);\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding unames_size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"after adding unames_size: add=%zu unif_buf_size=%zu\", add, unif_buf_size);\n  }\n\n  if (NULL != params->opaque.value.str)\n  {\n    size_t add = params->opaque.value.len + 1; /* Add one for zero-termination */\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding opaque size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"opaque present: value.str=%p value.len=%zu add=%zu unif_buf_size=%zu\", (void *)params->opaque.value.str, params->opaque.value.len, add, unif_buf_size);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    size_t add = params->realm.value.len + 1;  /* Add one for zero-termination */\n    size_t before = unif_buf_size;\n    size_t after = before + add;\n    if (after < before)\n      mhd_log39(\"WARNING: size_t wrap detected when adding realm size: before=%zu add=%zu after=%zu\", before, add, after);\n    unif_buf_size = after;\n    mhd_log39(\"realm present: value.str=%p value.len=%zu add=%zu unif_buf_size=%zu\", (void *)params->realm.value.str, params->realm.value.len, add, unif_buf_size);\n  }\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  mhd_log39(\"after calloc: info=%p (requested bytes=%zu, struct_size=%zu)\", (void *)info, unif_buf_size + (size_t)sizeof(struct MHD_DigestAuthInfo), (size_t)sizeof(struct MHD_DigestAuthInfo));\n\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  mhd_log39(\"unif_buf_ptr=%p\", (void *)unif_buf_ptr);\n\n  unif_buf_used = 0;\n  mhd_log39(\"unif_buf_used initialized to %zu\", unif_buf_used);\n\n  info->algo3 = params->algo3;\n  mhd_log39(\"info->algo3 set to %d\", (int)info->algo3);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n  {\n    size_t used_before = unif_buf_used;\n    size_t used_add = get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n    unif_buf_used += used_add;\n    mhd_log39(\"get_rq_uname: used_add=%zu unif_buf_used from %zu to %zu (remaining_space=%zu)\", used_add, used_before, unif_buf_used, (unif_buf_size > used_before) ? (unif_buf_size - used_before) : 0);\n  }\n  else\n  {\n    info->uname_type = uname_type;\n    mhd_log39(\"uname_type was missing/invalid, set info->uname_type=%d\", (int)info->uname_type);\n  }\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    mhd_log39(\"about to copy opaque: dest=%p unif_buf_used=%zu unif_buf_size=%zu param.len=%zu param.str=%p\", (void *)info->opaque, unif_buf_used, unif_buf_size, params->opaque.value.len, (void *)params->opaque.value.str);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    mhd_log39(\"get_rq_param_unquoted_copy_z returned opaque_len=%zu\", info->opaque_len);\n    unif_buf_used += info->opaque_len + 1;\n    mhd_log39(\"after opaque copy unif_buf_used=%zu (opaque_len+1=%zu)\", unif_buf_used, info->opaque_len + 1);\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    mhd_log39(\"about to copy realm: dest=%p unif_buf_used=%zu unif_buf_size=%zu param.len=%zu param.str=%p\", (void *)info->realm, unif_buf_used, unif_buf_size, params->realm.value.len, (void *)params->realm.value.str);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    mhd_log39(\"get_rq_param_unquoted_copy_z returned realm_len=%zu\", info->realm_len);\n    unif_buf_used += info->realm_len + 1;\n    mhd_log39(\"after realm copy unif_buf_used=%zu (realm_len+1=%zu)\", unif_buf_used, info->realm_len + 1);\n  }\n\n  mhd_log39(\"final sizes: unif_buf_size=%zu unif_buf_used=%zu\", unif_buf_size, unif_buf_used);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n  mhd_log39(\"info->qop set to %d\", (int)info->qop);\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n  mhd_log39(\"info->cnonce_len=%zu\", info->cnonce_len);\n\n  nc_res = get_rq_nc (params, &info->nc);\n  mhd_log39(\"get_rq_nc returned %d info->nc=%u\", (int)nc_res, (unsigned)info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  mhd_log39(\"returning info=%p\", (void *)info);\n  return info;\n}\n"
}