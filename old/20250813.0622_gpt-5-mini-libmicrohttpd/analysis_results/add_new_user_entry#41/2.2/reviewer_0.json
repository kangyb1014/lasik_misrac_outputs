{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'res' is assigned MHD_YES immediately prior to testing 'if (MHD_NO != res)'. That condition is therefore always true, so the conditional test (and its evaluation) is executed but redundant \u2014 removing the 'if' (or the test) would not affect program behaviour. This constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n  FILE *logf = fopen(\"/tmp/logs/330.txt\", \"a\");\n\n  if (logf)\n  {\n    fprintf(logf, \"ENTER add_new_user_entry: username=%p realm=%p password=%p allow_area_1=%d allow_area_2=%d\\n\",\n            (const void *)username, (const void *)realm, (const void *)password,\n            allow_area_1, allow_area_2);\n    fflush(logf);\n  }\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"EARLY RETURN: no space (user_ids_used=%lu)\\n\", (unsigned long)user_ids_used);\n      fclose(logf);\n    }\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  if (logf)\n  {\n    fprintf(logf, \"allocated entry at index=%lu entry=%p\\n\", (unsigned long)user_ids_used, (void *)entry);\n    fprintf(logf, \"storing username=%p realm=%p\\n\", (const void *)username, (const void *)realm);\n    fflush(logf);\n  }\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (logf)\n  {\n    fprintf(logf, \"initial res set to MHD_YES (res=%d)\\n\", (int)res);\n    fflush(logf);\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST1: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userhash MD5\\n\");\n      fflush(logf);\n    }\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST1: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST1: (MHD_NO != res) false -- skipped MD5 userhash\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST2: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userdigest MD5\\n\");\n      fflush(logf);\n    }\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST2: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST2: (MHD_NO != res) false -- skipped MD5 userdigest\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST3: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userhash SHA256\\n\");\n      fflush(logf);\n    }\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST3: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST3: (MHD_NO != res) false -- skipped SHA256 userhash\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST4: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userdigest SHA256\\n\");\n      fflush(logf);\n    }\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST4: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST4: (MHD_NO != res) false -- skipped SHA256 userdigest\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST5: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userhash SHA512_256\\n\");\n      fflush(logf);\n    }\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST5: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST5: (MHD_NO != res) false -- skipped SHA512_256 userhash\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO != res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST6: (MHD_NO != res) true -- calling MHD_digest_auth_calc_userdigest SHA512_256\\n\");\n      fflush(logf);\n    }\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n    if (logf)\n    {\n      fprintf(logf, \"AFTER TEST6: res=%d\\n\", (int)res);\n      fflush(logf);\n    }\n  }\n  else\n  {\n    if (logf)\n    {\n      fprintf(logf, \"TEST6: (MHD_NO != res) false -- skipped SHA512_256 userdigest\\n\");\n      fflush(logf);\n    }\n  }\n\n  if (MHD_NO == res)\n  {\n    if (logf)\n    {\n      fprintf(logf, \"FINAL: Failure detected (res==MHD_NO) -- returning 0\\n\");\n      fclose(logf);\n    }\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  if (logf)\n  {\n    fprintf(logf, \"SUCCESS: entry added at new index=%lu -- returning 1\\n\", (unsigned long)(user_ids_used - 1));\n    fclose(logf);\n  }\n\n  return ! 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for add_new_user_entry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s observation is correct in the narrow sense required by MISRA C 2023 Rule 2.2. In the original function res is unconditionally set to MHD_YES immediately before the very first test if (MHD_NO != res). Given that res is a local, non-volatile variable and nothing can change it between the assignment and the test, that boolean comparison is always true. The evaluation of that condition (the operation being executed) is therefore redundant \u2014 removing the test would not change program behaviour \u2014 which matches the rule\u2019s definition of dead code (an executed operation whose removal would not affect behaviour).\n\nClarifications and caveats:\n- The code guarded by that if is not dead (it is executed); what is dead is the conditional test/evaluation itself (the redundant comparison). MISRA 2.2\u2019s definition covers this case.\n- If there were external factors (volatile, concurrency, or macros that could change semantics) then the conclusion might differ, but none appear here: res is a local enum and is assigned directly.\n\nTherefore the report that this code violates MISRA C 2023 Rule 2.2 is correct (the redundant test/evaluation is dead code)."
}