{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes username and realm directly to strlen() without any runtime validation. If the caller supplies a NULL pointer or a char buffer that is not NUL-terminated, strlen(username) or strlen(realm) will read past the object bounds (or dereference NULL), causing undefined behavior. The function does not perform checks (and any mhd_assert in helper code is a debug-only check), so this use can violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe(const char *stage,\n          const char *const username,\n          const char *const password,\n          const char *const realm,\n          int allow_area_1,\n          int allow_area_2,\n          int local_user_ids_used,\n          int res_val)\n{\n  FILE *f = fopen(\"/tmp/logs/335.txt\", \"a\");\n  if (f == NULL)\n    return; /* best-effort logging, do not change program behavior */\n\n  /* Log the stage and basic pointers/state. Do NOT dereference pointers here\n     except to check for NULL. This keeps the probe from introducing extra\n     out-of-bounds accesses. */\n  fprintf(f, \"[add_new_user_entry] stage=%s\\n\", stage);\n  fprintf(f, \"  user_ids_used=%d allow_area_1=%d allow_area_2=%d\\n\",\n          local_user_ids_used, allow_area_1, allow_area_2);\n  fprintf(f, \"  username_ptr=%p realm_ptr=%p password_ptr=%p\\n\",\n          (const void *) username, (const void *) realm, (const void *) password);\n\n  if (username == NULL)\n    fprintf(f, \"  username: NULL\\n\");\n  else\n    fprintf(f, \"  username: non-NULL (content not inspected by probe)\\n\");\n\n  if (realm == NULL)\n    fprintf(f, \"  realm: NULL\\n\");\n  else\n    fprintf(f, \"  realm: non-NULL (content not inspected by probe)\\n\");\n\n  if (password == NULL)\n    fprintf(f, \"  password: NULL\\n\");\n  else\n    fprintf(f, \"  password: non-NULL (content not inspected by probe)\\n\");\n\n  /* Log the numeric result code if available (use -1 when unknown). */\n  fprintf(f, \"  res=%d\\n\", res_val);\n  fprintf(f, \"---\\n\");\n  fclose(f);\n}\n\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  /* Log entry to function with initial state. Use -1 for res (not set yet). */\n  log_probe(\"entry\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, -1);\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    log_probe(\"no_space\", username, password, realm,\n              allow_area_1, allow_area_2, (int) user_ids_used, -1);\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  /* Before invoking digest calculation, record the fact that the code is\n     about to call into functions that will consume username/realm/password.\n     The probe deliberately does not attempt to read the strings themselves\n     (only logs pointer presence) to avoid causing additional out-of-bounds\n     behavior. */\n  log_probe(\"before_MD5_userhash\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n\n  log_probe(\"after_MD5_userhash\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  log_probe(\"after_MD5_userdigest\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n\n  log_probe(\"after_SHA256_userhash\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  log_probe(\"after_SHA256_userdigest\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n\n  log_probe(\"after_SHA512_256_userhash\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  log_probe(\"after_SHA512_256_userdigest\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  if (MHD_NO == res) {\n    log_probe(\"failure_return\", username, password, realm,\n              allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  log_probe(\"success_return\", username, password, realm,\n            allow_area_1, allow_area_2, (int) user_ids_used, (int) res);\n\n  return ! 0;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for add_new_user_entry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct as a potential MISRA 21.17 violation. The function add_new_user_entry does not itself call any <string.h> functions, but it forwards the raw pointers username, realm and password directly to helper functions (MHD_digest_auth_calc_userhash / MHD_digest_auth_calc_userdigest) without validating that those pointers are non-NULL and reference NUL-terminated arrays. If any of those helper functions use standard string.h routines (e.g. strlen, strcpy, memcpy on the string buffers), then passing NULL or a non-terminated buffer can cause reads/writes beyond object bounds and so would violate MISRA C 2023 Rule 21.17. \n\nWhether this is an actual violation in the code-base depends on the contract of the helper functions: if those helpers document and require that username/realm/password are non-NULL and properly NUL-terminated (and all callers satisfy that), the design can be compliant (the precondition must be enforced/documented). If no such guaranteed precondition exists or is not enforced, then the call chain is unsafe and the report stands. The test probe and empty logs do not invalidate the concern \u2014 they only show the probe did not exercise the paths or record calls, not that the pointers are safe.\n\nRecommendation: either (a) add explicit runtime checks for non-NULL and well-formed (NUL-terminated, bounded) strings before passing them to routines that use <string.h>, or (b) document and enforce (via static analysis or call-site audits) that callers always provide valid strings and that the helper functions do not operate on raw pointers unsafely."
}