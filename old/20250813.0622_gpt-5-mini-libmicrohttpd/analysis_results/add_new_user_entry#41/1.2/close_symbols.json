{
  "user_message": "Target function code is:\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_new_user_entry': {'callees': ['MHD_digest_auth_calc_userhash', 'MHD_digest_auth_calc_userdigest'], 'callers': ['add_new_users']}, 'MHD_digest_auth_calc_userhash': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userhash'], 'callers': ['MHD_digest_auth_calc_userhash_hex', 'add_new_user_entry']}, 'MHD_digest_auth_calc_userdigest': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userdigest'], 'callers': ['add_new_user_entry']}, 'add_new_users': {'callees': ['add_new_user_entry'], 'callers': ['main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct UserEntry (full definition)",
    "user_ids (declaration/definition)",
    "user_ids_used (declaration/definition)",
    "enum MHD_Result (definition)",
    "MHD_YES (macro/constant)",
    "MHD_NO (macro/constant)",
    "MHD_DIGEST_AUTH_ALGO3_MD5 (macro/constant)",
    "MHD_DIGEST_AUTH_ALGO3_SHA256 (macro/constant)",
    "MHD_DIGEST_AUTH_ALGO3_SHA512_256 (macro/constant)",
    "MHD_digest_auth_calc_userhash (prototype/definition)",
    "MHD_digest_auth_calc_userdigest (prototype/definition)"
  ],
  "explanation": "To decide whether add_new_user_entry uses any compiler language extensions you must inspect the definitions that the function depends on (not just their names). For each listed symbol you need the actual declaration/definition so you can detect possible extensions (GCC/clang attributes, calling-convention specifiers, inline asm, statement-expressions, typeof, anonymous/unnamed structs/unions, flexible array members, bitfields with non-standard widths, non-standard storage-class keywords, __extension__ markers, compiler-specific macros, etc.).\n\n- struct UserEntry (full definition): the code indexes entry->userhash_* and userdigest_* and uses sizeof on those members. The struct definition can contain language extensions (anonymous/unnamed structs or unions, flexible array members, attribute((packed/aligned)), bitfields or compiler-specific type qualifiers) that would violate the MISRA rule.\n- user_ids (declaration/definition): you must confirm its type is a plain array of struct UserEntry and that its definition uses no extensions (e.g. section attributes, packed/aliasing attributes, non-standard linkage). The array size expression might be an extension as well.\n- user_ids_used (declaration/definition): its type (signed/unsigned, bitfield, volatile with attributes) and definition could use extensions or nonstandard qualifiers that change behaviour of the <= comparison.\n- enum MHD_Result (definition): the enum type could be defined with compiler extensions (explicit underlying type extensions, attributes) or macros that alias nonstandard constructs; MHD_YES / MHD_NO might be macros rather than enum constants.\n- MHD_YES / MHD_NO (macro/constant): these macros/constants control flow in the function. They might be defined using extension constructs (statement-expressions, typeof, casts to non-standard types, or compiler-specific keywords). You must inspect their definitions for extensions.\n- MHD_DIGEST_AUTH_ALGO3_* macros: these macro values are passed to functions; their definitions could use compiler extensions or be alias macros that expand to extension constructs. Confirm they are simple integer macros or enums.\n- MHD_digest_auth_calc_userhash, MHD_digest_auth_calc_userdigest (prototypes/definitions): function declarations may include compiler-specific attributes (e.g. __attribute__((...)), calling-convention keywords, inline asm, or be defined as nested functions, variadic in a nonstandard way, or use compiler-specific parameter annotations. The definitions may also use inline/function attributes that are language extensions; these must be checked to determine whether the target function relies on extensions via its callees or their prototypes.\n\nProviding these symbols (declarations/definitions) lets the next analyst examine whether any of the used types, macros or function declarations incorporate compiler-documented language extensions that would cause a MISRA violation."
}