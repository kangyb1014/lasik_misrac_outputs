{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the build configuration where HAVE_MESSAGES is not defined, the only use of saved_tail is the statement \u201c(void) saved_tail;\u201d. This is an expression statement with no side effects; removing it does not change program behaviour, so it is an executed no\u2011op and thus constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log_event (const char *event,\n                     struct MHD_Connection *connection,\n                     size_t hdr_len,\n                     int parse_res,\n                     int allow_partially)\n{\n  /* Append human-readable probe information to the evidence file. */\n  FILE *f = fopen (\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f,\n           \"EVENT=%s conn=%p headers_received_tail=%p hdr_len=%zu parse_res=%d allow_partially=%d\\n\",\n           event,\n           (void *) connection,\n           /* Note: do not reference the local variable `saved_tail` here to avoid\n              changing the usage profile of that local in the build without\n              HAVE_MESSAGES. Log the connection field instead. */\n           (void *) connection->rq.headers_received_tail,\n           hdr_len,\n           parse_res,\n           allow_partially);\n  fclose (f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  /* Probe: entry state */\n  mhd_probe_log_event (\"enter_parse_cookie_header\",\n                       connection,\n                       0u, /* hdr_len unknown at entry */\n                       -1, /* parse_res unknown */\n                       allow_partially_correct_cookie ? 1 : 0);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n  {\n    /* Probe: no Cookie header found */\n    mhd_probe_log_event (\"no_cookie_header\",\n                         connection,\n                         0u,\n                         (int) MHD_PARSE_COOKIE_OK,\n                         allow_partially_correct_cookie ? 1 : 0);\n    return MHD_PARSE_COOKIE_OK;\n  }\n  if (0 == hdr_len)\n  {\n    /* Probe: empty Cookie header */\n    mhd_probe_log_event (\"empty_cookie_header\",\n                         connection,\n                         0u,\n                         (int) MHD_PARSE_COOKIE_OK,\n                         allow_partially_correct_cookie ? 1 : 0);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    /* Probe: before parsing cookies string */\n    mhd_probe_log_event (\"before_parse_cookies_string\",\n                         connection,\n                         hdr_len - i,\n                         -1,\n                         allow_partially_correct_cookie ? 1 : 0);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n\n  /* Probe: exit state. Note: avoid referencing the local `saved_tail` here in\n     the build without HAVE_MESSAGES, to keep the original usage profile of\n     that local unchanged. Instead log the connection field. */\n  mhd_probe_log_event (\"exit_parse_cookie_header\",\n                       connection,\n                       hdr_len,\n                       (int) parse_res,\n                       allow_partially_correct_cookie ? 1 : 0);\n\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=-1 allow_partially=1\nEVENT=no_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len=0 parse_res=1 allow_partially=1\nEVENT=enter_parse_cookie_header conn=0x55b0045dfcf0 headers_received_tail=0x55b0045e7e40 hdr_len\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The agent's claim rests on the assumption that, when HAVE_MESSAGES is not defined, the only reference to the local saved_tail is the redundant \u201c(void) saved_tail;\u201d statement. That assumption is false in the posted source: saved_tail is referenced outside of any HAVE_MESSAGES blocks (for example the unconditional test in the MHD_PARSE_COOKIE_MALFORMED case: if (saved_tail != connection->rq.headers_received_tail) and the subsequent possible assignments connection->rq.headers_received_tail = saved_tail; saved_tail->next = NULL;). Thus the cast-to-void is not the sole use of the variable in the HAVE_MESSAGES\u2011absent build. Because saved_tail is actually used by the logic above, the presence of \u201c(void) saved_tail;\u201d is only to silence a compiler warning in some configurations and does not by itself demonstrate an executed, removable no\u2011op that would constitute dead code under MISRA Rule 2.2. Therefore Agent A\u2019s reported violation is incorrect."
}