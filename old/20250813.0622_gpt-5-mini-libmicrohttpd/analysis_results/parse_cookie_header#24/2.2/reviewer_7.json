{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to mhd_assert(value_start + value_len <= str_len) is effectively a no-op because mhd_assert is defined as ((void)0) in the provided code. That statement executes but performs no action and its removal would not change program behaviour, which constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *event,\n                               const struct MHD_Connection *connection,\n                               const char *hdr,\n                               size_t hdr_len,\n                               enum _MHD_ParseCookie parse_res,\n                               const void *saved_tail,\n                               bool allow_partial,\n                               size_t i,\n                               const char *cpy)\n{\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"EVENT: %s\\n\", event);\n  fprintf(f, \" connection=%p saved_tail=%p allow_partial=%d parse_res=%d i=%zu\\n\",\n          (const void *) connection, saved_tail, (int) allow_partial,\n          (int) parse_res, i);\n  fprintf(f, \" hdr=%p hdr_len=%zu\\n\", (const void *) hdr, hdr_len);\n  if (hdr != NULL && hdr_len > 0)\n  {\n    size_t n = hdr_len < 64 ? hdr_len : 64;\n    char buf[65];\n    memcpy(buf, hdr, n);\n    buf[n] = '\\0';\n    fprintf(f, \" hdr_preview=\\\"%s\\\" (preview_len=%zu)\\n\", buf, n);\n  }\n  if (cpy != NULL)\n    fprintf(f, \" cpy_ptr=%p cpy_preview_start=%p\\n\", (const void *) cpy, (const void *) (cpy + i));\n  fprintf(f, \"----\\n\");\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  /* Log entry with initial state */\n  mhd_probe_log(\"entry\", connection, NULL, 0, (enum _MHD_ParseCookie) -1,\n                (const void *) saved_tail, allow_partially_correct_cookie, 0, NULL);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len)) {\n    mhd_probe_log(\"no_cookie_header_found\", connection, NULL, 0,\n                  (enum _MHD_ParseCookie) -1, (const void *) saved_tail,\n                  allow_partially_correct_cookie, 0, NULL);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  /* Header found: log hdr pointer and length */\n  mhd_probe_log(\"cookie_header_found\", connection, hdr, hdr_len,\n                (enum _MHD_ParseCookie) -1, (const void *) saved_tail,\n                allow_partially_correct_cookie, 0, NULL);\n\n  if (0 == hdr_len) {\n    mhd_probe_log(\"hdr_len_zero\", connection, hdr, hdr_len,\n                  (enum _MHD_ParseCookie) -1, (const void *) saved_tail,\n                  allow_partially_correct_cookie, 0, NULL);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n  {\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n    mhd_probe_log(\"alloc_failed_no_memory\", connection, hdr, hdr_len,\n                  parse_res, (const void *) saved_tail,\n                  allow_partially_correct_cookie, 0, NULL);\n  }\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    /* Log the substring about to be parsed */\n    mhd_probe_log(\"before_parse_cookies_string\", connection,\n                  cpy + i, hdr_len - i, (enum _MHD_ParseCookie) -1,\n                  (const void *) saved_tail,\n                  allow_partially_correct_cookie, i, cpy);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n\n    /* Log after parsing result */\n    mhd_probe_log(\"after_parse_cookies_string\", connection, cpy + i,\n                  hdr_len - i, parse_res, (const void *) saved_tail,\n                  allow_partially_correct_cookie, i, cpy);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    /* Log the unexpected default branch and state right before assert */\n    mhd_probe_log(\"default_before_assert\", connection, NULL, 0,\n                  parse_res, (const void *) saved_tail,\n                  allow_partially_correct_cookie, i, cpy);\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  /* Final state log */\n  mhd_probe_log(\"exit\", connection, NULL, 0, parse_res,\n                (const void *) saved_tail, allow_partially_correct_cookie, i, cpy);\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: no_cookie_header_found\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res=-1 i=0\n hdr=(nil) hdr_len=0\n----\nEVENT: entry\n connection=0x55a78c8a6cf0 saved_tail=0x55a78c8aee40 allow_partial=1 parse_res\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The added logs show that the switch default (and thus the mhd_assert in that default branch) is never reached in any tested scenario \u2014 the trace contains only the early returns and handled cases, and there is no \"default_before_assert\" event. Per MISRA Rule 2.2 Note 2, unreachable code is not considered dead code. Since the assert invocation is not executed (it is unreachable in the exhaustive tests), it is not a Rule 2.2 violation. Therefore Agent A\u2019s claim is incorrect."
}