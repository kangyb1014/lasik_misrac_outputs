{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as a no-op (#define mhd_assert(ignore) ((void)0)). All calls like mhd_assert(0 != name_len); expand to an executed no-op expression statement whose removal would not change program behaviour. Those assertion statements therefore constitute dead code, violating MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  mhd_probe_log(\"parse_cookie_header: entry connection=%p saved_tail=%p daemon=%p client_discipline=%d\",\n                (void *)connection,\n                (void *)saved_tail,\n                (void *)connection->daemon,\n                connection->daemon ? connection->daemon->client_discipline : -1);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n  {\n    mhd_probe_log(\"parse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  mhd_probe_log(\"parse_cookie_header: got Cookie header at %p len=%zu\", (void *)hdr, hdr_len);\n\n  if (0 == hdr_len)\n  {\n    mhd_probe_log(\"parse_cookie_header: hdr_len == 0 -> returning MHD_PARSE_COOKIE_OK\");\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n  {\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n    mhd_probe_log(\"parse_cookie_header: allocation failed for len=%zu -> parse_res=MHD_PARSE_COOKIE_NO_MEMORY\", hdr_len);\n  }\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    mhd_probe_log(\"parse_cookie_header: calling parse_cookies_string with offset=%zu remaining=%zu\", i, hdr_len - i);\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n    mhd_probe_log(\"parse_cookie_header: parse_cookies_string returned %d saved_tail=%p new_tail=%p\",\n                  (int) parse_res,\n                  (void *) saved_tail,\n                  (void *) connection->rq.headers_received_tail);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    mhd_probe_log(\"parse_cookie_header: parse_res == MHD_PARSE_COOKIE_OK\");\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: parse_res == MHD_PARSE_COOKIE_OK_LAX saved_tail=%p new_tail=%p\",\n                  (void *) saved_tail,\n                  (void *) connection->rq.headers_received_tail);\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    mhd_probe_log(\"parse_cookie_header: parse_res == MHD_PARSE_COOKIE_MALFORMED saved_tail=%p new_tail=%p allow_partially_correct_cookie=%d\",\n                  (void *) saved_tail,\n                  (void *) connection->rq.headers_received_tail,\n                  allow_partially_correct_cookie);\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n        mhd_probe_log(\"parse_cookie_header: malformed cookie -> extracted values removed; restored saved_tail=%p\", (void *) saved_tail);\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    mhd_probe_log(\"parse_cookie_header: parse_res == MHD_PARSE_COOKIE_NO_MEMORY\");\n    break;\n  default:\n    /* Log the unexpected parse_res so tools/agents can observe this path.\n       Keep the original assertion call to preserve original code. */\n    mhd_probe_log(\"parse_cookie_header: default: unexpected parse_res=%d -> invoking mhd_assert(0)\", (int) parse_res);\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  mhd_probe_log(\"parse_cookie_header: exit parse_res=%d\", (int) parse_res);\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56475cc89cf0 saved_tail=0x56475cc91e40 daemon=0x56475cc87350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56038b131cf0 saved_tail=0x56038b139e40 daemon=0x56038b12f350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56038b131cf0 saved_tail=0x56038b139e40 daemon=0x56038b12f350 client_discipline=0\nparse_cookie_header: no Cookie header present -> returning MHD_PARSE_COOKIE_OK\nparse_cookie_header: entry connection=0x56038b131cf0 saved_tail=0x56038b139e40 daemon=0x56038b12\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent's claim hinges on two linked assertions: (a) the mhd_assert macro is defined as a no-op and therefore expands to an executed no-op expression-statement, and (b) those no-op assertion calls are executed in parse_cookie_header so their removal would not change behaviour. The provided test output shows that parse_cookie_header always takes early return paths (no Cookie header present) and never reaches the switch default where mhd_assert(0) is located. The probe logs that would indicate the default branch / mhd_assert invocation are not present. Under the given (and mandated to be trusted) exhaustive test suite, the mhd_assert in parse_cookie_header was not executed, so it cannot be classified as dead code per MISRA Rule 2.2 (which defines dead code as an operation that is executed but removable without behavior change). Moreover, even if mhd_assert expands to a no-op in a particular build configuration, in other builds it may have observable behaviour (e.g. logging/abort), so its presence in source is not intrinsically dead. Therefore the report that parse_cookie_header violates MISRA C 2023 Rule 2.2 is not supported by the provided evidence and is incorrect."
}