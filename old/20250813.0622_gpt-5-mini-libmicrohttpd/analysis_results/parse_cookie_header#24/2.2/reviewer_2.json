{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as a no-op (#define mhd_assert(ignore) ((void)0)). Thus the statement mhd_assert(c->write_buffer_send_offset <= new_buf_size); becomes an executed no-op whose removal would not affect program behaviour. That is dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log_state(const void *connection_ptr,\n                                const char *event,\n                                int parse_res_int,\n                                const char *hdr_snippet,\n                                size_t hdr_len,\n                                const void *saved_tail_ptr)\n{\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  char snippet[65] = \"\";\n  if (hdr_snippet != NULL && hdr_len > 0)\n  {\n    /* copy up to 64 bytes to keep log lines reasonable */\n    size_t copy_len = hdr_len < (sizeof(snippet) - 1) ? hdr_len : (sizeof(snippet) - 1);\n    memcpy(snippet, hdr_snippet, copy_len);\n    snippet[copy_len] = '\\0';\n  }\n  else if (hdr_snippet == NULL)\n  {\n    strcpy(snippet, \"(null)\");\n  }\n\n  fprintf(f, \"event=%s conn=%p saved_tail=%p parse_res=%d hdr_len=%zu hdr_snippet=\\\"%s\\\"\\n\",\n          event, connection_ptr, saved_tail_ptr, parse_res_int, hdr_len, snippet);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n  {\n    /* Log that no Cookie header was present */\n    mhd_probe_log_state((const void *)connection,\n                        \"no_cookie_header\",\n                        (int)MHD_PARSE_COOKIE_OK,\n                        NULL,\n                        0,\n                        (const void *)saved_tail);\n    return MHD_PARSE_COOKIE_OK;\n  }\n  if (0 == hdr_len)\n  {\n    /* Log that Cookie header was empty */\n    mhd_probe_log_state((const void *)connection,\n                        \"empty_cookie_header\",\n                        (int)MHD_PARSE_COOKIE_OK,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n  {\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n    /* Log allocation failure and state */\n    mhd_probe_log_state((const void *)connection,\n                        \"alloc_failed\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n  }\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    /* Log the trimmed header snippet before parsing */\n    mhd_probe_log_state((const void *)connection,\n                        \"before_parse_cookies_string\",\n                        -1,\n                        cpy + i,\n                        hdr_len - i,\n                        (const void *)saved_tail);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n\n    /* Log the result of parse_cookies_string and relevant state */\n    mhd_probe_log_state((const void *)connection,\n                        \"after_parse_cookies_string\",\n                        (int)parse_res,\n                        cpy + i,\n                        hdr_len - i,\n                        (const void *)saved_tail);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    /* Log OK path */\n    mhd_probe_log_state((const void *)connection,\n                        \"case_OK\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    /* Log OK_LAX path */\n    mhd_probe_log_state((const void *)connection,\n                        \"case_OK_LAX\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    /* Log MALFORMED path and whether we trimmed back to saved_tail */\n    mhd_probe_log_state((const void *)connection,\n                        \"case_MALFORMED\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    /* Log NO_MEMORY path */\n    mhd_probe_log_state((const void *)connection,\n                        \"case_NO_MEMORY\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    break;\n  default:\n    /* Log that default branch is taken and record the unexpected value. */\n    mhd_probe_log_state((const void *)connection,\n                        \"case_default_before_assert\",\n                        (int)parse_res,\n                        hdr,\n                        hdr_len,\n                        (const void *)saved_tail);\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55ca26463cf0 saved_tail=0x55ca2646be40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55dac16dbcf0 saved_tail=0x55dac16e3e40 parse_res=1 hdr_len=0 hdr_snippet=\"(null)\"\nevent=no_cookie_header conn=0x55f10a9bbcf0 saved_tail=0x55f10a9c\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA Rule 2.2 prohibits dead code defined as \u201cany operation that is executed but whose removal would not affect program behaviour.\u201d In the parse_cookie_header code the only mhd_assert present is inside the switch default (mhd_assert(0)); that path is intended for an impossible/unexpected enum value. Under the supplied assumptions (the test suite is exhaustive and no missing scenarios), the default branch is never reached, so the assertion call is unreachable. MISRA Note 2 explicitly states that unreachable code is not dead code. Consequently the no-op expansion of mhd_assert does not constitute dead code here. Also the agent\u2019s example refers to a different assertion (about write_buffer_send_offset) not shown in the parse_cookie_header snippet, so the claim does not correctly apply to this function. Therefore the reported violation of Rule 2.2 is incorrect."
}