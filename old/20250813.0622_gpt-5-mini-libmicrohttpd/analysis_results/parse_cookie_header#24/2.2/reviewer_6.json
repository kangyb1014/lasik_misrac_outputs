{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro mhd_assert is defined as '#define mhd_assert(ignore) ((void)0)'. The statement 'mhd_assert (c->read_buffer == buf);' therefore expands to a no-op ((void)0) and has no effect at runtime; removing that statement would not change program behaviour. This is an executed operation whose removal would not affect behaviour, i.e. dead code, so Rule 2.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log_cookie (const char *stage,\n                      struct MHD_Connection *connection,\n                      const char *hdr,\n                      size_t hdr_len,\n                      const char *cpy,\n                      size_t i,\n                      enum _MHD_ParseCookie parse_res,\n                      struct MHD_HTTP_Req_Header *saved_tail)\n{\n  FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Print basic context and a small sample of the header */\n  fprintf (f, \"STAGE=%s parse_res=%d hdr=%p hdr_len=%zu cpy=%p i=%zu saved_tail=%p headers_received_tail=%p daemon_client_discipline=%d\\n\",\n           stage,\n           (int) parse_res,\n           (const void *) hdr,\n           hdr_len,\n           (const void *) cpy,\n           i,\n           (const void *) saved_tail,\n           (const void *) connection->rq.headers_received_tail,\n           (int) connection->daemon->client_discipline);\n\n  if (hdr && hdr_len > 0)\n  {\n    size_t sample = hdr_len > 64 ? 64 : hdr_len;\n    fprintf (f, \"HDR_SAMPLE=\\\"\");\n    fwrite (hdr, 1, sample, f);\n    if (sample < hdr_len)\n      fprintf (f, \"...\\n\");\n    else\n      fprintf (f, \"\\n\");\n  }\n\n  if (cpy)\n  {\n    /* cpy is NUL-terminated in the original flow */\n    fprintf (f, \"CPY=\\\"%s\\\"\\n\", cpy);\n  }\n\n  fclose (f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  /* Log that we have a Cookie header and its basic info */\n  mhd_probe_log_cookie (\"header_found\", connection, hdr, hdr_len, NULL, 0, (enum _MHD_ParseCookie) -1, saved_tail);\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  /* Log parse result and relevant pointers prior to switch */\n  mhd_probe_log_cookie (\"before_switch\", connection, hdr, hdr_len, cpy, i, parse_res, saved_tail);\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    /* Log the unexpected parse_res that causes the default branch */\n    mhd_probe_log_cookie (\"default_case_hit\", connection, hdr, hdr_len, cpy, i, parse_res, saved_tail);\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for parse_cookie_header. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's argument is incomplete. MISRA Rule 2.2 forbids dead code: operations that are executed but whose removal would not affect program behaviour. The mhd_assert(...) in the posted code expands to ((void)0) in the scenario A describes, so that single statement would indeed be a no-op if executed. However, two conditions must be met to conclude a Rule 2.2 violation: (1) the statement must actually be executed in some feasible program run, and (2) its removal must not change behaviour for the project as built.\n\nIn the provided function the mhd_assert call appears only in the switch default branch. If that branch is never reachable in any feasible execution, the code is unreachable (MISRA note 2) rather than dead, and Rule 2.2 does not apply. Agent A supplied no evidence that the default branch can be reached at runtime. Their added test instrumentation also did not observe the default being hit. Without demonstrating that the default branch can execute, you cannot claim the no-op is an executed operation and therefore dead code.\n\nEven if the default branch can be reached, whether the assertion is dead depends on the project-wide definition of mhd_assert. If the project build defines mhd_assert as a no-op (as A assumed) for the project, and the default can be reached, then the statement would be an executed no-op and its removal would not change behaviour \u2014 that would be a Rule 2.2 violation. But if mhd_assert can be defined differently in the project (for example to abort or log in some configurations), then the statement cannot be considered dead across the project, and there is no violation.\n\nConclusion: the report as presented is not proven. Agent A's scenario could produce dead code only if both (a) the default branch is reachable and (b) mhd_assert is defined as a permanent no-op in the project configuration. Those facts were not established. Therefore the report is not correct as given."
}