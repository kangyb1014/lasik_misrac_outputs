{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Potential out-of-bounds write when hdr_len is not validated: if hdr_len is SIZE_MAX (or otherwise so large that hdr_len + 1 overflows size_t), the call MHD_connection_alloc_memory_(connection, hdr_len + 1) may allocate a buffer smaller than hdr_len+1 (wrap-around), then memcpy(cpy, hdr, hdr_len) and the subsequent cpy[hdr_len] = '\\0' will write beyond the allocated buffer. Thus, unless hdr_len is guaranteed and checked to avoid size_t overflow/too-large allocations, the sequence can result in accesses beyond object bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *phase,\n               struct MHD_Connection *connection,\n               const char *hdr,\n               size_t hdr_len,\n               size_t req_size,\n               const void *alloc_ptr,\n               enum _MHD_ParseCookie parse_res)\n{\n  FILE *f = fopen(\"/tmp/logs/199.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Detect potential wrap-around: request size should be > hdr_len */\n  int wrapped = (req_size <= hdr_len) ? 1 : 0;\n\n  /* Print a compact snapshot of relevant state */\n  fprintf (f,\n           \"phase=%s conn=%p hdr=%p hdr_len=%zu req_size=%zu wrapped=%d alloc_ptr=%p \"\n           \"saved_tail=%p daemon=%p parse_res=%d\\n\",\n           phase,\n           (void *) connection,\n           (void *) hdr,\n           hdr_len,\n           req_size,\n           wrapped,\n           alloc_ptr,\n           (void *) (connection ? connection->rq.headers_received_tail : NULL),\n           (void *) (connection ? connection->daemon : NULL),\n           (int) parse_res);\n\n  fclose (f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n  {\n    /* No Cookie header present: log and return */\n    mhd_probe_log (\"no_header\", connection, NULL, 0, 0, NULL,\n                   MHD_PARSE_COOKIE_OK);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  /* Log the header pointer and length we received from lookup */\n  mhd_probe_log (\"after_lookup\", connection, hdr, hdr_len, hdr_len + 1, NULL,\n                 MHD_PARSE_COOKIE_OK);\n\n  if (0 == hdr_len)\n  {\n    mhd_probe_log (\"empty_header\", connection, hdr, hdr_len, hdr_len + 1, NULL,\n                   MHD_PARSE_COOKIE_OK);\n    return MHD_PARSE_COOKIE_OK;\n  }\n\n  /* Record requested allocation size and detect possible wrap */\n  size_t requested = hdr_len + 1; /* potential to wrap if hdr_len == SIZE_MAX */\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      requested);\n\n  /* Log allocation attempt and the result pointer */\n  mhd_probe_log (\"after_alloc\", connection, hdr, hdr_len, requested, (void *) cpy,\n                 MHD_PARSE_COOKIE_OK);\n\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    /* Log just before copying to capture hdr and sizes */\n    mhd_probe_log (\"before_memcpy\", connection, hdr, hdr_len, requested, (void *) cpy,\n                   MHD_PARSE_COOKIE_OK);\n\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    /* Log prior to parsing to capture trimmed offset */\n    mhd_probe_log (\"before_parse_cookies_string\", connection, cpy + i, hdr_len - i,\n                   requested, (void *) cpy, MHD_PARSE_COOKIE_OK);\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n\n    /* Log the parse result and final state */\n    mhd_probe_log (\"after_parse_cookies_string\", connection, cpy + i, hdr_len - i,\n                   requested, (void *) cpy, parse_res);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x557be8ea0cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x557be8ea8e40 daemon=0x557be8e9e350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40 daemon=0x5633795b6350 parse_res=1\nphase=no_header conn=0x5633795b8cf0 hdr=(nil) hdr_len=0 req_size=0 wrapped=1 alloc_ptr=(nil) saved_tail=0x5633795c0e40\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes hdr_len + 1 for the allocation without validating hdr_len for overflow or excessively large values. If hdr_len == SIZE_MAX (or otherwise large so that hdr_len + 1 wraps), the requested allocation size can wrap (or be smaller than intended). The subsequent memcpy(cpy, hdr, hdr_len) and the write cpy[hdr_len] = '\\0' would then access/write beyond the bounds of the actual allocated object, which is a direct violation of MISRA C 2023 Rule 21.17 (string functions and other string/byte accesses must not access beyond object bounds). No guard is present to prevent hdr_len + 1 from overflowing or to ensure the allocation succeeded with at least hdr_len+1 bytes, so the potential out-of-bounds access exists."
}