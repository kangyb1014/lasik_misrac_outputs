{
  "user_message": "An agent A claimed that the following MHD_set_response_options code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_response_options.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n        return MHD_NO;\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n    return MHD_NO;\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      break;\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The struct member 'void *upgrade_handler_cls' is an opaque closure pointer passed to an upgrade handler and (per its documentation) used as a closure; it is not const-qualified even though it is apparently not meant to be modified via this pointer. It should be declared 'const void *upgrade_handler_cls' to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *tag,\n                              struct MHD_Response *response,\n                              enum MHD_ResponseFlags flags,\n                              const char *detail)\n{\n  FILE *f = fopen(\"/tmp/logs/307.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"[%s] tag=%s response=%p flags_req=0x%lx response->flags=0x%lx response->flags_auto=0x%lx response->total_size=%lu detail=%s\\n\",\n          \"MHD_set_response_options\", tag,\n          (void *)response,\n          (unsigned long)flags,\n          (unsigned long)response->flags,\n          (unsigned long)response->flags_auto,\n          (unsigned long)response->total_size,\n          detail ? detail : \"(null)\");\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  /* Log entry and incoming state */\n  mhd_log_probe(\"entry\", response, flags, \"entered MHD_set_response_options\");\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    mhd_log_probe(\"check_has_content_length\", response, flags, \"response has custom Content-Length\");\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      mhd_log_probe(\"reject_remove_insanity_header\", response, flags, \"attempt to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH -> returning MHD_NO\");\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      mhd_log_probe(\"check_head_only\", response, flags, \"response had HEAD_ONLY and request attempts to remove it\");\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n      {\n        mhd_log_probe(\"reject_remove_head_only\", response, flags, \"attempt to remove MHD_RF_HEAD_ONLY_RESPONSE without insanity flag -> returning MHD_NO\");\n        return MHD_NO;\n      }\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n  {\n    mhd_log_probe(\"reject_head_only_with_total_size\", response, flags, \"MHD_RF_HEAD_ONLY_RESPONSE requested but response->total_size != 0 -> returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  ret = MHD_YES;\n  response->flags = flags;\n  mhd_log_probe(\"after_set_flags\", response, flags, \"flags set on response, proceeding to varargs processing\");\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    /* Log each response option value encountered */\n    {\n      char detailbuf[128];\n      /* Describe the option value numerically for reproducible evidence */\n      snprintf(detailbuf, sizeof(detailbuf), \"vararg option ro=%ld (0x%lx)\", (long)ro, (unsigned long)ro);\n      mhd_log_probe(\"vararg_option\", response, flags, detailbuf);\n    }\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      mhd_log_probe(\"case_ro_end\", response, flags, \"encountered MHD_RO_END inside loop (unexpected)\");\n      break;\n    default:\n      mhd_log_probe(\"case_default\", response, flags, \"unrecognized response option -> will set ret=MHD_NO\");\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n\n  {\n    if (ret == MHD_YES)\n      mhd_log_probe(\"exit_ok\", response, flags, \"returning MHD_YES\");\n    else\n      mhd_log_probe(\"exit_no\", response, flags, \"returning MHD_NO due to unrecognized option or earlier check\");\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_set_response_options. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 concerns pointer declarations and advises const-qualifying pointer targets when the object is not modified through the pointer. The submitted MHD_set_response_options implementation contains no declaration named upgrade_handler_cls and does not perform any operations that would demonstrate a violation of Rule 8.13. Agent A\u2019s scenario refers to a struct member (void *upgrade_handler_cls) that is not shown, and no evidence is provided that the member is only used for read access (i.e. could safely be const-qualified). Without the actual declaration and usage sites, you cannot conclude a Rule 8.13 violation: making the member const could also break the public API or be incorrect if the pointed-to object is legitimately modified via that pointer or passed to APIs that expect a non-const void *. Therefore the claim is unsupported by the provided code and test output."
}