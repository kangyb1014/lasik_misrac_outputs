{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 con_header is obtained via MHD_lookup_connection_value (which does not provide a length) but the underlying storage in pos->value may be stored with an explicit length (pos->value_size) rather than guaranteed NUL termination. Calling strstr(con_header, \"Upgrade\") requires a NUL-terminated C string; if pos->value is not NUL-terminated this will read past the object bounds and cause undefined behaviour. Therefore the use of strstr here can violate Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nis_ws_probe_log(const char *label, const char *upg_header, const char *con_header,\n                int upg_cmp_result, const char *strstr_result)\n{\n  /* Best-effort create log directory; ignore errors if it already exists. */\n  (void)mkdir(\"/tmp/logs\", 0777);\n\n  FILE *f = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (!f)\n    return; /* If logging isn't available, keep original behavior silently. */\n\n  time_t t = time(NULL);\n  /* Log: timestamp, label, pointer values, NULL flags, comparison results. */\n  fprintf(f, \"%ld: %s: upg_header=%p con_header=%p upg_header_is_null=%d con_header_is_null=%d upg_cmp_result=%d strstr_result=%p\\n\",\n          (long)t,\n          label,\n          (void *)upg_header,\n          (void *)con_header,\n          (int)(upg_header == NULL),\n          (int)(con_header == NULL),\n          upg_cmp_result,\n          (void *)strstr_result);\n\n  fclose(f);\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  /* Preserve original logic: only call strcmp and strstr when their inputs\n     are non-NULL. Capture their results so we can log them without changing\n     control flow. */\n  int upg_cmp = 1; /* non-zero means not equal (default) */\n  const char *strstr_res = NULL;\n\n  if (upg_header != NULL)\n    {\n      /* original comparison: 0 == strcmp(upg_header, WS_UPGRADE_VALUE) */\n      upg_cmp = strcmp (upg_header, WS_UPGRADE_VALUE);\n    }\n\n  if (con_header != NULL)\n    {\n      /* original check: NULL != strstr(con_header, \"Upgrade\") */\n      strstr_res = strstr (con_header, \"Upgrade\");\n    }\n\n  /* Log the control path and state so other agents can reproduce the\n     violation scenario. We log pointer addresses and results but we do not\n     read or print the pointed-to string contents (to avoid adding further\n     potentially out-of-bounds reads). */\n  is_ws_probe_log(\"is_websocket_request_check\", upg_header, con_header, upg_cmp, strstr_res);\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == upg_cmp)\n          && (NULL != strstr_res))\n         ? MHD_YES\n         : MHD_NO;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for is_websocket_request. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A is correct in their assessment: calling strstr(con_header, \"Upgrade\") requires con_header to point to a NUL-terminated C string, and the code only checks con_header != NULL. If the caller (for example MHD_lookup_connection_value) can supply a pointer to a buffer with an explicit length but without a terminating '\\0', then strstr will read past the object's bounds and cause undefined behaviour. That situation would violate MISRA C 2023 Rule 21.17. \n\nWhether a real violation occurs in practice depends on the contract of the API that provides con_header: if that API guarantees a terminating NUL for returned header values, the code is safe; if it does not, the code is non-compliant. The presented test/logging not producing evidence does not refute the conceptual defect. To comply unconditionally, either (a) ensure the provider guarantees NUL-termination, or (b) use APIs that accept an explicit length (or implement a bounded substring search) so no read beyond the buffer can occur."
}