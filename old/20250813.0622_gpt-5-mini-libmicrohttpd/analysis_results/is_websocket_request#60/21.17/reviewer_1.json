{
  "user_message": "An agent A claimed that the following is_websocket_request code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of is_websocket_request.\n```c\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  return ((upg_header != NULL) && (con_header != NULL)\n          && (0 == strcmp (upg_header, WS_UPGRADE_VALUE))\n          && (NULL != strstr (con_header, \"Upgrade\")))\n         ? MHD_YES\n         : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:MHD_lookup_connection_value_n returns ws_key_header and key_size (checked to be WS_KEY_LEN) but does not guarantee that the returned value is NUL-terminated. The call ret = ws_get_accept_value(ws_key_header, &ws_ac_value) passes only the pointer (no length). If ws_get_accept_value uses any <string.h> functions that expect a NUL-terminated C string (e.g. strlen, strcmp, strcpy, strcat, strchr, etc.) or otherwise reads until a NUL, those calls can read beyond the WS_KEY_LEN bytes and thus access out-of-bounds memory. Therefore Rule 21.17 can be violated in this scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\n__ensure_log_dir(void)\n{\n  /* best-effort create directory; ignore errors if it already exists */\n  (void) mkdir(\"/tmp/logs\", 0700);\n}\nstatic void\n__write_log_line(const char *line)\n{\n  FILE *f = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (f == NULL)\n    return; /* if logging is not possible, silently continue to preserve behavior */\n  fprintf(f, \"%s\\n\", line);\n  fclose(f);\n}\nstatic void\n__log_state(const char *stage, const char *upg_header, const char *con_header,\n            int has_upg, int has_con, int cmp_eq, int strstr_found, int final_result)\n{\n  char buf[512];\n  /* Prepare a single-line log entry describing pointers and intermediate results. */\n  snprintf(buf, sizeof(buf),\n           \"[%s] upg_header=%p con_header=%p has_upg=%d has_con=%d cmp_eq=%d strstr_found=%d result=%d\",\n           stage, (const void *) upg_header, (const void *) con_header,\n           has_upg, has_con, cmp_eq, strstr_found, final_result);\n  __write_log_line(buf);\n}\n\nstatic enum MHD_Result\nis_websocket_request (struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  /* preserve original unused parameter suppression */\n  (void) con;  /* Unused. Silent compiler warning. */\n\n  /* Ensure log directory exists (best-effort) */\n  __ensure_log_dir();\n\n  /* Log entry: function start and pointer values */\n  __log_state(\"enter\", upg_header, con_header, (upg_header != NULL), (con_header != NULL), -1, -1, -1);\n\n  /* Reproduce original short-circuit evaluation exactly to avoid changing control flow. */\n  int has_upg = (upg_header != NULL);\n  int has_con = (con_header != NULL);\n\n  /* strcmp is only called when both headers are non-NULL (as in the original expression). */\n  int cmp_eq = 0;\n  if (has_upg && has_con)\n    {\n      /* This mirrors the original use of strcmp; if upg_header is not NUL-terminated\n         and strcmp reads beyond the provided buffer, that behavior will occur here\n         just as in the original code. We log that we are about to call strcmp. */\n      __log_state(\"before_strcmp\", upg_header, con_header, has_upg, has_con, -1, -1, -1);\n      cmp_eq = (0 == strcmp (upg_header, WS_UPGRADE_VALUE));\n      __log_state(\"after_strcmp\", upg_header, con_header, has_upg, has_con, cmp_eq, -1, -1);\n    }\n\n  /* strstr is only called when both headers are non-NULL and the upgrade value matched. */\n  int strstr_found = 0;\n  if (has_upg && has_con && cmp_eq)\n    {\n      __log_state(\"before_strstr\", upg_header, con_header, has_upg, has_con, cmp_eq, -1, -1);\n      strstr_found = (NULL != strstr (con_header, \"Upgrade\"));\n      __log_state(\"after_strstr\", upg_header, con_header, has_upg, has_con, cmp_eq, strstr_found, -1);\n    }\n\n  int final = (has_upg && has_con && cmp_eq && strstr_found) ? (int) MHD_YES : (int) MHD_NO;\n\n  __log_state(\"exit\", upg_header, con_header, has_upg, has_con, cmp_eq, strstr_found, final);\n\n  return final ? MHD_YES : MHD_NO;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for is_websocket_request. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls strcmp(upg_header, WS_UPGRADE_VALUE) and strstr(con_header, \"Upgrade\") without any check that the pointer arguments refer to NUL-terminated buffers. MISRA C 2023 Rule 21.17 requires that uses of <string.h> functions shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. If a caller supplies a buffer and a length (as in the described MHD_lookup_connection_value_n scenario) where the buffer is not NUL-terminated, these calls can read past the provided length and thus access out-of-bounds memory. The code contains no contract or local checks that guarantee NUL-termination, so the usage can violate Rule 21.17 unless there is an external, provable guarantee that upg_header and con_header are always NUL-terminated. Absent such a guarantee, the reported violation is valid."
}