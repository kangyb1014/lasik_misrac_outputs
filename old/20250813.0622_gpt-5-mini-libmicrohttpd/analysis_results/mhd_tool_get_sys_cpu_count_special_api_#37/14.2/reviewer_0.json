{
  "user_message": "An agent A claimed that the following mhd_tool_get_sys_cpu_count_special_api_ code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. .\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_sys_cpu_count_special_api_.\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The for loop for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1) ++ret; violates Rule 14.2. ret is the loop counter (initialized in the first clause) but it is modified in the loop body (++ret) which contravenes the requirement that the loop counter shall not be modified in the body. The third clause modifies enb_set (not the loop counter) which breaches the requirement that the third clause shall modify only the loop counter. Also the second clause uses enb_set while that object is modified by the loop (third clause), violating the restriction that the second clause shall not use objects that are modified in the loop body.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_tool_log_vx_cpu_state (const char *stage, const void *enb_ptr, size_t enb_size, int ret_val)\n{\n  FILE *fp = fopen(\"/tmp/logs/300.txt\", \"a\");\n  if (NULL == fp)\n  {\n    /* If cannot open the log file, do nothing to preserve original behaviour. */\n    return;\n  }\n\n  fprintf (fp, \"Stage: %s, ret=%d, enb_set_size=%zu, enb_set_bytes=0x\",\n           (stage != NULL) ? stage : \"(null)\", ret_val, enb_size);\n  if ((NULL != enb_ptr) && (enb_size > 0U))\n  {\n    const unsigned char *p = (const unsigned char *) enb_ptr;\n    size_t i;\n    for (i = 0U; i < enb_size; ++i)\n      fprintf (fp, \"%02x\", (unsigned) p[i]);\n  }\n  fprintf (fp, \"\\n\");\n  fclose (fp);\n}\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n\n    /* Capture entry into VxWorks branch */\n    mhd_tool_log_vx_cpu_state (\"vx_branch_entry\", (const void *) &enb_set, sizeof (enb_set), ret);\n\n    enb_set = vxCpuEnabledGet ();\n\n    /* Log state after obtaining enabled CPU set */\n    mhd_tool_log_vx_cpu_state (\"after_vxCpuEnabledGet\", (const void *) &enb_set, sizeof (enb_set), ret);\n\n    /* Count set bits\n       Note: original logic preserved: first clause initializes ret, second clause\n       checks enb_set, third clause clears lowest set bit. We add logging inside\n       the loop body to capture per-iteration state without changing semantics. */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n    {\n      /* Log state at start of iteration (before increment) */\n      mhd_tool_log_vx_cpu_state (\"loop_iter_before_increment\", (const void *) &enb_set, sizeof (enb_set), ret);\n\n      ++ret;\n\n      /* Log state after increment (enb_set will be modified by third clause when\n         this iteration completes) */\n      mhd_tool_log_vx_cpu_state (\"loop_iter_after_increment\", (const void *) &enb_set, sizeof (enb_set), ret);\n    }\n\n    /* Log exit from VxWorks branch with final values */\n    mhd_tool_log_vx_cpu_state (\"vx_branch_exit\", (const void *) &enb_set, sizeof (enb_set), ret);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_sys_cpu_count_special_api_. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Mapping the code to the Rule 14.2 clauses shows concrete violations:\n\n- First clause: for (ret = 0; ...) establishes ret as the loop counter (OK for clause 1).\n\n- Clause 4 / clause 1 intent: the loop counter (ret) shall not be modified in the for-loop body. The body contains ++ret; that directly modifies the loop counter in the body and therefore breaches the rule.\n\n- Clause 3: the third clause shall modify only the loop counter. The third clause here (enb_set &= enb_set - 1) modifies enb_set, not the loop counter, so this also violates clause 3.\n\n- Clause 2 nuance: the second clause (0 != enb_set) uses enb_set. Clause 2 permits use of the loop counter and optionally a loop-control flag; however enb_set is neither the loop counter nor a benign loop-control flag here because the third clause modifies enb_set (and clause 3 forbids third-clause modifications of objects other than the loop counter). Agent A stated the second clause uses an object modified by the loop body; strictly speaking enb_set is modified by the third clause, not the body, but because clause 3 is violated the overall for-statement is non-conforming. \n\nIn short: ret is defined as the loop counter but is incremented inside the body (forbidden), and the third clause mutates enb_set (not the loop counter) (also forbidden). Therefore the agent A report that this for loop violates MISRA C 2023 Rule 14.2 is correct."
}