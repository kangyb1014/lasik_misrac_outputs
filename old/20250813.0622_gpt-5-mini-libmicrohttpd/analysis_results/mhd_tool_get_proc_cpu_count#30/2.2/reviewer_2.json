{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The 'if (1)' conditional is a constant-true condition that is evaluated at runtime but has no effect on program behaviour; removing the 'if (1)' (or replacing it with a plain block) would not change the program. Thus the executed evaluation of the constant condition constitutes dead code. Suggest removing 'if (1)' and using a simple block '{ ... }' if a scope is needed.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/242.txt\", \"a\");\n    if (f == NULL)\n    {\n        /* If logging fails, do not change behavior of the function. */\n        return;\n    }\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n  probe_log(\"mhd_tool_get_proc_cpu_count: enter\");\n\n#if defined(__linux__) || defined(__GLIBC__)\n  probe_log(\"Platform branch: __linux__ || __GLIBC__\");\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_sched_getaffinity_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (sched_getaffinity)\", res);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_cpuset_getaffinity_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (cpuset_getaffinity)\", res);\n    return res;\n  }\n#else  /* ! __linux__ && ! __GLIBC__ */\n  probe_log(\"Platform branch: !__linux__ && !__GLIBC__\");\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_cpuset_getaffinity_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (cpuset_getaffinity)\", res);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_sched_getaffinity_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (sched_getaffinity)\", res);\n    return res;\n  }\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_sched_getaffinity_np_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (sched_getaffinity_np)\", res);\n    return res;\n  }\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  probe_log(\"Called mhd_tool_get_proc_cpu_count_w32_(), res=%d\", res);\n  if (0 < res)\n  {\n    probe_log(\"Early return with res=%d (w32)\", res);\n    return res;\n  }\n\n  probe_log(\"No method succeeded, returning -1\");\n  return -1;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_proc_cpu_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The claimed 'if (1)' constant-true conditional does not appear in the provided mhd_tool_get_proc_cpu_count implementation \u2014 agent A's scenario is mismatched to the target code. The target uses preprocessor conditionals (#if defined(...)) to select different call orderings depending on build-time macros; that is conditional compilation, not an executed constant runtime conditional. Under MISRA C 2023 Rule 2.2 (no dead code), code that can be selected and executed in some build configuration is not dead: removing either #if branch would change behavior for the configurations that rely on it. The added logging test producing no output only shows the function was not exercised at runtime in the test, it does not demonstrate the presence of dead code in the source. Therefore the agent's claim of a Rule 2.2 violation is incorrect."
}