{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The typedef uses the WINAPI macro in the function-pointer declaration: typedef BOOL (WINAPI *GPDCSM_PTR)(...); WINAPI typically expands to a Microsoft-specific calling convention (e.g. __stdcall), which is a compiler language extension documented by MS compilers. This use of a non\u2011standard calling convention macro violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_tool_log_probe(const char *stage, const char *fname, int res, const void *addr)\n{\n  FILE *f = fopen(\"/tmp/logs/240.txt\", \"a\");\n  if (f == NULL)\n    return; /* don't disturb normal control flow if logging fails */\n\n  /* Log a compact record: stage, function name, address (if available), result */\n  fprintf(f, \"stage=%s func=%s addr=%p res=%d\\n\", stage, fname, addr, res);\n  fclose(f);\n}\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n  /* Log entry into the function */\n  mhd_tool_log_probe(\"entry\", \"mhd_tool_get_proc_cpu_count\", 0, (const void *)&mhd_tool_get_proc_cpu_count);\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"cpuset_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n    return res;\n  }\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  mhd_tool_log_probe(\"before_call\", \"cpuset_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"cpuset_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_cpuset_getaffinity_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_);\n    return res;\n  }\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  mhd_tool_log_probe(\"before_call\", \"sched_getaffinity_np\", 0, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  mhd_tool_log_probe(\"after_call\", \"sched_getaffinity_np\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"sched_getaffinity_np\", res, (const void *)&mhd_tool_get_proc_cpu_count_sched_getaffinity_np_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"before_call\", \"w32\", 0, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  /* The w32 path is the most relevant for detecting Windows-specific\n     calling-convention macros (e.g. WINAPI). Log the function address and\n     returned value so external analysis can correlate the path taken with\n     any Windows-specific symbols or typedefs in the codebase. */\n  mhd_tool_log_probe(\"after_call\", \"w32\", res, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n  if (0 < res)\n  {\n    mhd_tool_log_probe(\"return\", \"w32\", res, (const void *)&mhd_tool_get_proc_cpu_count_w32_);\n    return res;\n  }\n\n  mhd_tool_log_probe(\"return\", \"final\", -1, NULL);\n  return -1;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_proc_cpu_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The supplied mhd_tool_get_proc_cpu_count implementation contains no use of WINAPI or any other compiler-specific calling-convention macro or typedef; it only uses standard preprocessor checks (e.g. __linux__, __GLIBC__) and ordinary function calls. Agent A\u2019s scenario refers to a typedef using WINAPI (e.g. typedef BOOL (WINAPI *GPDCSM_PTR)(...)), but that typedef is not present in the provided target code, so there is no evidence that this function uses a documented compiler language extension. (As an aside: if a WINAPI-style calling-convention macro were actually present in the analysed code and the compiler documentation explicitly classed it as a language extension, that would be within the scope of MISRA C 2023 Rule 1.2 \u2014 but that hypothetical does not apply to the code shown.) The test/logging code and empty log do not change this conclusion."
}