{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count.\n```c\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The typedef declares a function-pointer using the WINAPI calling-convention macro: 'typedef BOOL (WINAPI *GPGA_PTR)(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray);'. On Windows headers WINAPI typically expands to a compiler-specific calling-convention keyword (e.g. __stdcall), which is a non\u2011standard compiler extension per compiler documentation. Using such calling-convention specifiers is a language extension and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/240.txt\", \"a\");\n    if (!f)\n        return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  const char *platform = \"__linux__ or __GLIBC__\";\n#else\n  const char *platform = \"non-linux/non-glibc\";\n#endif\n\n  mhd_probe_log(\"ENTER mhd_tool_get_proc_cpu_count; platform=%s\", platform);\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_sched_getaffinity_()\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_sched_getaffinity_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via sched_getaffinity)\", res);\n    return res;\n  }\n\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_cpuset_getaffinity_()\");\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_cpuset_getaffinity_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via cpuset_getaffinity)\", res);\n    return res;\n  }\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_cpuset_getaffinity_()\");\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_cpuset_getaffinity_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via cpuset_getaffinity)\", res);\n    return res;\n  }\n\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_sched_getaffinity_()\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_sched_getaffinity_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via sched_getaffinity)\", res);\n    return res;\n  }\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_sched_getaffinity_np_()\");\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_sched_getaffinity_np_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via sched_getaffinity_np)\", res);\n    return res;\n  }\n\n  mhd_probe_log(\"calling mhd_tool_get_proc_cpu_count_w32_()\");\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  mhd_probe_log(\"returned %d from mhd_tool_get_proc_cpu_count_w32_()\", res);\n  if (0 < res)\n  {\n    mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> %d (via w32)\", res);\n    return res;\n  }\n\n  mhd_probe_log(\"EXIT mhd_tool_get_proc_cpu_count -> -1 (no method succeeded)\");\n  return -1;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for mhd_tool_get_proc_cpu_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the supplied code. The function mhd_tool_get_proc_cpu_count as shown contains no use of calling\u2011convention macros (e.g. WINAPI or __stdcall) or other compiler\u2011specific language extensions; it only uses standard C constructs and preprocessor tests for predefined macros (__linux__, __GLIBC__) which are compiler\u2011provided macros, not language extensions introduced in the source. The scenario cited a typedef using WINAPI, but that typedef is not present in the target code supplied \u2014 the presence of such a typedef in external Windows headers was not demonstrated to be part of the analyzed code. To justify a Rule 1.2 violation you must show the actual source that uses a documented compiler extension (for example a declaration with __stdcall, __fastcall, or a compiler-specific attribute) in the codebase being reviewed. Based on the provided function and evidence, the report is incorrect."
}