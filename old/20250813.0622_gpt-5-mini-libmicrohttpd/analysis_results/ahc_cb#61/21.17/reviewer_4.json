{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. MHD_lookup_connection_value_n returns pos->value and pos->value_size but does not guarantee the returned value is NUL-terminated. If ws_version_header points to a header value stored as exactly two bytes ('1','3') with no terminating '\\0' (pos->value_size == 2), calling strcmp(ws_version_header, WS_SEC_WEBSOCKET_VERSION) causes strcmp to read beyond the bounds of the value object while searching for the terminator. This is an out\u2011of\u2011bounds access and violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nahc_log_ws_header (struct MHD_Connection *con, const char *ws_version_header,\n                   const char *method, const char *version)\n{\n  FILE *fp = fopen(\"/tmp/logs/495.txt\", \"a\");\n  if (NULL == fp)\n  {\n    return; /* best-effort logging only */\n  }\n\n  fprintf (fp, \"ahc_cb: probe start\\n\");\n  fprintf (fp, \"  method ptr=%p, version ptr=%p\\n\",\n           (void *) method, (void *) version);\n  fprintf (fp, \"  method str=%s, version str=%s\\n\",\n           (method != NULL) ? method : \"(null)\",\n           (version != NULL) ? version : \"(null)\");\n  fprintf (fp, \"  ws_version_header ptr=%p\\n\", (void *) ws_version_header);\n\n  if (NULL == ws_version_header)\n  {\n    fprintf (fp, \"  ws_version_header is NULL\\n\");\n    fprintf (fp, \"ahc_cb: probe end\\n\\n\");\n    fclose (fp);\n    return;\n  }\n\n  /* Use the _n lookup to learn the exact stored size without assuming\n     NUL-termination. We pass the header name length using strlen of the\n     literal macro (safe) and then log the returned byte sequence using\n     fwrite with the provided size. */\n  const char *ws_version_ptr_n = NULL;\n  size_t ws_version_size_n = 0;\n  enum MHD_Result r = MHD_lookup_connection_value_n (\n    con, MHD_HEADER_KIND, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION,\n    strlen (MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION), &ws_version_ptr_n,\n    &ws_version_size_n);\n\n  fprintf (fp, \"  MHD_lookup_connection_value_n returned=%d ptr=%p size=%zu\\n\",\n           (int) r, (void *) ws_version_ptr_n, ws_version_size_n);\n\n  if (ws_version_ptr_n != NULL && ws_version_size_n > 0)\n  {\n    fprintf (fp, \"  ws_version bytes (raw, size=%zu): \", ws_version_size_n);\n    /* fwrite is used rather than fprintf(\"%s\") to avoid relying on a\n       terminating '\\0'. */\n    (void) fwrite (ws_version_ptr_n, 1, ws_version_size_n, fp);\n    fprintf (fp, \"\\n\");\n  }\n  else\n  {\n    fprintf (fp, \"  ws_version not present via _n lookup or size==0\\n\");\n  }\n\n  fprintf (fp, \"  About to call strcmp(ws_version_header, WS_SEC_WEBSOCKET_VERSION)\\n\");\n  fprintf (fp, \"ahc_cb: probe end\\n\\n\");\n\n  fclose (fp);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n\n  /* Insert probe logging right before the original strcmp check so that\n     the exact bytes and size of the header (if available via the _n\n     variant) are captured to help reproduce out-of-bounds reads. */\n  ahc_log_ws_header (con, ws_version_header, method, version);\n\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_cb. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The agent A\u2019s scenario hinges on ws_version_header coming from MHD_lookup_connection_value_n (or otherwise being a non-terminated byte sequence) so that strcmp reads past the buffer. In the original ahc_cb code the version header is obtained via MHD_lookup_connection_value (the non-_n variant):\n\n  ws_version_header = MHD_lookup_connection_value(... MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n\nThe libmicrohttpd API provides two forms: the _n variant returns a pointer+size for raw header bytes (not necessarily NUL-terminated), while the non-_n variant returns a pointer to a NUL-terminated C string suitable for string.h functions. Thus calling strcmp(ws_version_header, ...) on the value returned by MHD_lookup_connection_value is valid and does not cause a bounds overread under the documented API.\n\nAgent A confused the two APIs (they used MHD_lookup_connection_value_n in their probe code to print raw bytes, but the production code uses the non-_n lookup). The code also uses the _n variant correctly for the key (it checks key_size == WS_KEY_LEN before treating the bytes), so there is no unsafe use of string.h on an unterminated buffer in the shown code path.\n\nIf, contrary to the documented API, a particular build of the library did not guarantee NUL-termination from MHD_lookup_connection_value, then strcmp could indeed read out of bounds and that would be a real MISRA 21.17 violation. However, based on the intended/standard behavior of the two API variants, the reported violation is incorrect."
}