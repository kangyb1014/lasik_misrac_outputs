{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the fragment mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); memcmp is being used to check whether the header string hdr->value equals the string token \"close\". This is effectively comparing null\u2011terminated string content (the literal \"close\" and hdr->value) with memcmp, which violates MISRA C 2023 Rule 21.14 (the standard memcmp function shall not be used to compare null\u2011terminated strings).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nahc_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/494.txt\", \"a\");\n  if (NULL == f)\n  {\n    return;\n  }\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  ahc_log (\"ahc_cb: entry req_cls_ptr=%p req_cls_val=%p\", (void *) req_cls,\n           (NULL != req_cls) ? *req_cls : NULL);\n\n  if (NULL == *req_cls)\n  {\n    ahc_log (\"ahc_cb: initial request stage, setting req_cls to (void*)1 and returning MHD_YES\");\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  ahc_log (\"ahc_cb: second request stage, clearing req_cls and continuing\");\n  *req_cls = NULL;\n\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n\n  ahc_log (\"ahc_cb: headers: Upgrade=%s Connection=%s\",\n           upg_header ? upg_header : \"<NULL>\",\n           con_header ? con_header : \"<NULL>\");\n\n  /* Log whether the Connection header equals the token \"close\" using strcmp */\n  if (con_header != NULL)\n  {\n    int already_has_close = (0 == strcmp (con_header, \"close\"));\n    ahc_log (\"ahc_cb: Connection header equals \\\"close\\\"? %s\",\n             already_has_close ? \"YES\" : \"NO\");\n  }\n  else\n  {\n    ahc_log (\"ahc_cb: Connection header is NULL\");\n  }\n\n  ahc_log (\"ahc_cb: calling is_websocket_request\");\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    ahc_log (\"ahc_cb: is_websocket_request returned MHD_NO -> send_chat_page called\");\n    return send_chat_page (con);\n  }\n  ahc_log (\"ahc_cb: is_websocket_request returned MHD_YES (websocket request)\");\n\n  ahc_log (\"ahc_cb: method=%s version=%s\", method ? method : \"<NULL>\",\n           version ? version : \"<NULL>\");\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    ahc_log (\"ahc_cb: method/version mismatch -> send_bad_request called\");\n    return send_bad_request (con);\n  }\n\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  ahc_log (\"ahc_cb: Sec-WebSocket-Version header=%s\",\n           ws_version_header ? ws_version_header : \"<NULL>\");\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    ahc_log (\"ahc_cb: websocket version missing or unsupported -> send_upgrade_required called\");\n    return send_upgrade_required (con);\n  }\n\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  ahc_log (\"ahc_cb: lookup sec-websocket-key returned ret=%d key_size=%zu key_header=%s\",\n           (int) ret, key_size,\n           ws_key_header ? ws_key_header : \"<NULL>\");\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    ahc_log (\"ahc_cb: websocket key missing or incorrect length -> send_bad_request called\");\n    return send_bad_request (con);\n  }\n\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  ahc_log (\"ahc_cb: ws_get_accept_value returned ret=%d ws_ac_value=%p\",\n           (int) ret, (void *) ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    ahc_log (\"ahc_cb: ws_get_accept_value failed -> returning MHD_NO\");\n    return ret;\n  }\n  ahc_log (\"ahc_cb: ws_ac_value=%s\", ws_ac_value ? ws_ac_value : \"<NULL>\");\n\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    ahc_log (\"ahc_cb: failed to add Sec-WebSocket-Accept header -> cleaning up and returning MHD_NO\");\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    ahc_log (\"ahc_cb: failed to add Upgrade header -> destroying response and returning MHD_NO\");\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  ahc_log (\"ahc_cb: MHD_queue_response returned ret=%d\", (int) ret);\n  MHD_destroy_response (res);\n  ahc_log (\"ahc_cb: exit ret=%d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ahc_cb. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The provided ahc_cb implementation contains no use of memcmp to compare null\u2011terminated strings. It uses strcmp for string comparisons (e.g. method/version and ws_version_header checks), which is the appropriate standard function for NUL\u2011terminated C strings. The scenario\u2019s memcmp example (mhd_assert(... memcmp(hdr->value, \"close\", 5))) does not appear in the shown ahc_cb code; if such a memcmp exists elsewhere (e.g. in another function) it could be a separate violation, but it is not part of the target ahc_cb source shown. Therefore the claim that this ahc_cb code violates MISRA C 2023 Rule 21.14 is not correct."
}