{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The variable 'msg' is declared as 'unsigned char *' but in this call it is only read (used as a %s argument to snprintf). It should be a pointer to a const-qualified type (for example 'const unsigned char *' or 'const char *') when possible. Passing a non-const pointer where the pointee is not modified violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n  FILE *log = fopen(\"/tmp/logs/203.txt\", \"a\");\n\n  if (log != NULL)\n  {\n    fprintf(log, \"ENTER run_usock: ws=%p sock=%d urh=%p\\n\", (void *)ws, (int)ws->sock, (void *)urh);\n    fflush(log);\n  }\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (log != NULL)\n    {\n      fprintf(log, \"recv returned: got=%zd\\n\", got);\n      fflush(log);\n    }\n    if (0 >= got)\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"breaking: recv <= 0 (got=%zd)\\n\", got);\n        fflush(log);\n      }\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (log != NULL)\n    {\n      fprintf(log, \"ws_receive_frame returned: msg=%p got=%zd type=%d\\n\", (void *)msg, got, type);\n      if (msg != NULL)\n      {\n        /* Log a safe preview of the message: print as string and as hex of first bytes */\n        fprintf(log, \"msg preview (as string): %s\\n\", (char *) msg);\n        /* print up to 16 bytes in hex to avoid overruns */\n        {\n          size_t j;\n          size_t limit = (got > 16) ? 16U : (size_t)got;\n          fprintf(log, \"msg preview (hex) up to %zu bytes:\", limit);\n          for (j = 0U; j < limit; ++j)\n            fprintf(log, \" %02x\", (unsigned int) msg[j]);\n          fprintf(log, \"\\n\");\n        }\n        fflush(log);\n      }\n    }\n    if (NULL == msg)\n    {\n      if (log != NULL)\n      {\n        fprintf(log, \"breaking: msg == NULL\\n\");\n        fflush(log);\n      }\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      /* Log that msg will be used as input to snprintf (read-only usage) */\n      if (log != NULL)\n      {\n        fprintf(log, \"type is TEXT_FRAME: about to measure needed buffer for formatting using msg=%p\\n\", (void *)msg);\n        fflush(log);\n      }\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (log != NULL)\n      {\n        fprintf(log, \"snprintf length measurement returned buf_size=%d\\n\", buf_size);\n        fflush(log);\n      }\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (log != NULL)\n          {\n            fprintf(log, \"allocated text buffer at %p size=%zu, now formatting with msg=%p\\n\", (void *)text, (size_t)buf_size + 1U, (void *)msg);\n            fflush(log);\n          }\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          if (log != NULL)\n          {\n            fprintf(log, \"after formatting: sent=%zd\\n\", sent);\n            fflush(log);\n          }\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (log != NULL)\n      {\n        fprintf(log, \"freed msg=%p, sent=%zd\\n\", (void *)msg, sent);\n        fflush(log);\n      }\n      if (-1 == sent)\n      {\n        if (log != NULL)\n        {\n          fprintf(log, \"breaking: sent == -1\\n\");\n          fflush(log);\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        if (log != NULL)\n        {\n          fprintf(log, \"received CLOSE_FRAME, freeing msg=%p and breaking\\n\", (void *)msg);\n          fflush(log);\n        }\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (log != NULL)\n  {\n    fprintf(log, \"exiting receive loop, cleaning up client socket %d\\n\", (int)ws->sock);\n    fflush(log);\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n\n  if (log != NULL)\n  {\n    fprintf(log, \"finalized cleanup for sock=%d, closing log file and returning\\n\", (int)ws->sock);\n    fclose(log);\n  }\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C:2023 Rule 8.13 recommends that where possible pointers should point to const-qualified types. In this function msg is used read\u2011only for formatting, but it is also deallocated with free(msg). Declaring msg as pointer-to-const would prevent calling free without a cast (free expects a void *), which would either require a cast (introducing another issue) or prevent deallocation. Therefore it is not appropriate to change msg to a const\u2011qualified pointer in this context, and Rule 8.13 does not mandate such a change when doing so would be impractical (e.g. when deallocation is required). (If desired for clarity, a separate const-qualified view variable could be used for read\u2011only APIs, or an explicit cast to the expected type used at the call site \u2014 but that is a design choice and not a mandatory violation of 8.13.)"
}