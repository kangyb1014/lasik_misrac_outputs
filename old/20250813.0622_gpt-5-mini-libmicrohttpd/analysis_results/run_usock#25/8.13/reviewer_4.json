{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The variable msg is declared as unsigned char * and is only read (not modified) before being freed. Per Rule 8.13 it should be a pointer to a const-qualified type (for example const unsigned char *msg) whenever possible. The free(msg) call therefore uses a non-const pointer where a const-qualified pointer could have been used, so this is a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nlog_buf_preview (const unsigned char *buf, size_t len)\n{\n  size_t i, limit = (len < 64u) ? len : 64u;\n  FILE *f = fopen (\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"  preview (as string): \\\"\");\n  for (i = 0; i < limit; ++i)\n  {\n    unsigned char c = buf[i];\n    if (c >= 0x20 && c < 0x7f)\n      fputc ((int) c, f);\n    else\n      fputc ('.', f);\n  }\n  if (limit < len)\n    fprintf (f, \"... (total %zu bytes)\", len);\n  fprintf (f, \"\\\"\\n  preview (hex):\");\n  for (i = 0; i < limit; ++i)\n    fprintf (f, \" %02X\", (unsigned int) buf[i]);\n  if (limit < len)\n    fprintf (f, \" ...\");\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  log_probe (\"run_usock: start - ws=%p sock=%d urh=%p\", (void *) ws,\n             (int) ws->sock, (void *) urh);\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    log_probe (\"recv returned: got=%zd for sock=%d\", got, (int) ws->sock);\n    if (0 >= got)\n    {\n      log_probe (\"recv <= 0, breaking loop (sock=%d)\", (int) ws->sock);\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    log_probe (\"ws_receive_frame returned: msg=%p got=%zd type=%d\",\n               (void *) msg, got, type);\n    if (NULL != msg)\n    {\n      /* Log a preview of the message received. Cast is only for printing. */\n      log_buf_preview (msg, (size_t) got);\n    }\n    else\n    {\n      log_probe (\"ws_receive_frame returned NULL, breaking (sock=%d)\",\n                 (int) ws->sock);\n      break;\n    }\n\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      log_probe (\"handling TEXT_FRAME (sock=%d) msg=%p\", (int) ws->sock,\n                 (void *) msg);\n\n      /* Preserve original logic: compute required buffer size. */\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock,\n                           (const char *) msg);\n      log_probe (\"snprintf sizing returned buf_size=%d\", buf_size);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock,\n                        (const char *) msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          log_probe (\"ws_send_frame returned sent=%zd for sock=%d\",\n                     sent, (int) ws->sock);\n          free (text);\n        }\n        else\n        {\n          sent = -1;\n          log_probe (\"malloc for text failed (size=%zu)\", (size_t) buf_size + 1);\n        }\n      }\n      else\n      {\n        sent = -1;\n        log_probe (\"invalid buf_size=%d (sock=%d)\", buf_size, (int) ws->sock);\n      }\n\n      /* Log msg pointer and a preview just before freeing to provide\n         evidence that msg was not modified and is freed. */\n      log_probe (\"about to free msg=%p (sock=%d)\", (void *) msg,\n                 (int) ws->sock);\n      log_buf_preview (msg, (size_t) got);\n      free (msg);\n\n      if (-1 == sent)\n      {\n        log_probe (\"sent == -1, breaking main loop (sock=%d)\",\n                   (int) ws->sock);\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        log_probe (\"received CON_CLOSE_FRAME, freeing msg=%p and breaking (sock=%d)\",\n                   (void *) msg, (int) ws->sock);\n        log_buf_preview (msg, (size_t) got);\n        free (msg);\n        break;\n      }\n      else\n      {\n        log_probe (\"received non-text non-close frame type=%d (sock=%d), freeing msg=%p\",\n                   type, (int) ws->sock, (void *) msg);\n        log_buf_preview (msg, (size_t) got);\n        free (msg);\n      }\n    }\n  }\n\n  log_probe (\"main loop exited for sock=%d, acquiring MUTEX\", (int) ws->sock);\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  log_probe (\"MUTEX acquired for sock=%d\", (int) ws->sock);\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      log_probe (\"clearing CLIENT_SOCKS[%d] (was %d)\", i, (int) CLIENT_SOCKS[i]);\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  log_probe (\"MUTEX released for sock=%d\", (int) ws->sock);\n  log_probe (\"freeing WsData at %p for sock=%d\", (void *) ws, (int) ws->sock);\n  free (ws);\n  log_probe (\"calling MHD_upgrade_action to close urh=%p (sock=%d)\",\n             (void *) urh, (int) ws->sock);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  log_probe (\"run_usock: exit for sock=%d\", (int) ws->sock);\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. Rule 8.13 encourages using a pointer-to-const when the pointed-to object will never be modified through that pointer, but it must be applied taking account of how the pointer is used. In this function msg is obtained from ws_receive_frame and later passed to free(msg). The C free API expects a void * (a non-const pointer); making msg a pointer-to-const would force casts when calling free (and possibly other APIs that expect a non-const pointer), which is neither safe nor consistent with normal ownership semantics. Because the object pointed to is owned and must be freed by this code, declaring msg as const unsigned char * would be inappropriate (it would require casting away const to free it). Therefore the current declaration unsigned char *msg is reasonable and the assertion that this source violates MISRA C:2023 Rule 8.13 is incorrect."
}