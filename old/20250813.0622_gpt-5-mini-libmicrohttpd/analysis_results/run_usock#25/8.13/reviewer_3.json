{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local variable 'urh' is declared as a non-const pointer: 'struct MHD_UpgradeResponseHandle *urh = ws->urh;' and is then passed to MHD_upgrade_action. If MHD_upgrade_action does not modify the pointed-to object (i.e. its parameter could be declared as 'const struct MHD_UpgradeResponseHandle *'), then 'urh' should be declared const and the current code violates MISRA C 2023 Rule 8.13. If the API requires modification of the handle (the function prototype requires a non-const pointer), then there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log(const char *event, struct WsData *ws, struct MHD_UpgradeResponseHandle *urh, const char *fmt, ...)\n{\n  FILE *fp = fopen(\"/tmp/logs/203.txt\", \"a\");\n  if (NULL == fp)\n  {\n    /* If the log file cannot be opened, best-effort fallback to stderr. */\n    fp = stderr;\n  }\n\n  /* Timestamp */\n  {\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    if (NULL != localtime_r(&t, &tm_buf))\n    {\n      char ts[32];\n      if (0 < strftime(ts, (size_t) sizeof(ts), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n      {\n        fprintf(fp, \"%s - \", ts);\n      }\n    }\n  }\n\n  /* Basic context */\n  if (NULL != ws)\n  {\n    fprintf(fp, \"event=%s sock=%d urh=%p pid=%ld: \", event, (int) ws->sock, (void *) urh, (long) pthread_self());\n  }\n  else\n  {\n    fprintf(fp, \"event=%s ws=NULL urh=%p pid=%ld: \", event, (void *) urh, (long) pthread_self());\n  }\n\n  /* Formatted message */\n  {\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n  }\n\n  fprintf(fp, \"\\n\");\n\n  if (fp != stderr)\n  {\n    fclose(fp);\n  }\n}\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  /* Log entry and initial state: ws pointer and urh pointer */\n  probe_log(\"enter\", ws, urh, \"run_usock start, ws=%p urh=%p\", (void *) ws, (void *) urh);\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    probe_log(\"recv\", ws, urh, \"recv returned %zd bytes\", got);\n    if (0 >= got)\n    {\n      probe_log(\"recv_break\", ws, urh, \"recv <= 0 -> breaking out (got=%zd)\", got);\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    probe_log(\"ws_receive_frame\", ws, urh, \"ws_receive_frame returned msg=%p got=%zd type=%d\", (void *) msg, got, type);\n    if (NULL == msg)\n    {\n      probe_log(\"msg_null\", ws, urh, \"msg is NULL -> breaking out\");\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      probe_log(\"text_frame_build\", ws, urh, \"calculated buf_size=%d\", buf_size);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          probe_log(\"ws_send_frame\", ws, urh, \"ws_send_frame attempted text=%p sent=%zd\", (void *) text, sent);\n          free (text);\n        }\n        else\n        {\n          probe_log(\"malloc_fail\", ws, urh, \"malloc returned NULL for buf_size=%d\", buf_size);\n          sent = -1;\n        }\n      }\n      else\n      {\n        probe_log(\"buf_size_nonpos\", ws, urh, \"buf_size <= 0 (%d)\", buf_size);\n        sent = -1;\n      }\n      free (msg);\n      if (-1 == sent)\n      {\n        probe_log(\"send_fail_break\", ws, urh, \"send failed (sent=%zd) -> breaking out\", sent);\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        probe_log(\"close_frame\", ws, urh, \"received close frame, msg=%p -> freeing msg and breaking\", (void *) msg);\n        free (msg);\n        break;\n      }\n      else\n      {\n        probe_log(\"other_frame\", ws, urh, \"received non-text non-close frame type=%d, msg=%p -> freeing msg\", type, (void *) msg);\n        free (msg);\n      }\n    }\n  }\n\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      probe_log(\"client_removed\", ws, urh, \"removed client at index=%d sock=%d\", i, (int) ws->sock);\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n\n  /* Log just before calling MHD_upgrade_action so the state of 'urh' is captured. */\n  probe_log(\"before_upgrade_action\", NULL, urh, \"about to call MHD_upgrade_action with urh=%p\", (void *) urh);\n\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n\n  probe_log(\"after_upgrade_action\", NULL, urh, \"called MHD_upgrade_action with urh=%p\", (void *) urh);\n  return NULL;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for run_usock. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A\u2019s reasoning is plausible but incomplete. MISRA C:2023 Rule 8.13 indeed encourages that pointers should point to const-qualified types whenever possible. In run_usock the local variable is declared as\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\nand the function only uses urh for logging and to call MHD_upgrade_action. If the MHD_upgrade_action prototype and any other uses in the translation unit do not require a modifiable (non-const) MHD_UpgradeResponseHandle, then urh could/should be declared as pointing to a const-qualified type (for example const struct MHD_UpgradeResponseHandle *urh) and the current code would be a violation of Rule 8.13.\n\nHowever, you cannot determine a definite MISRA violation from the snippet alone. Whether a change to const is possible depends on the declarations in scope: specifically the type of ws->urh and the prototype of MHD_upgrade_action. If MHD_upgrade_action takes a non-const pointer (i.e. it intends to modify the object), or if ws->urh is declared as a non-const pointer and other code expects to pass it to modifiers, then declaring urh const would be incompatible and the current code would not violate Rule 8.13 because the pointer must remain non-const to satisfy the API.\n\nRecommendation: inspect the declaration of ws->urh and the prototype of MHD_upgrade_action in the included headers. If neither requires a non-const pointer and the function does not modify the pointed-to object, change the local declaration to const struct MHD_UpgradeResponseHandle *urh; that will satisfy Rule 8.13. If the API requires a non-const pointer, no violation exists in this context."
}