{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "struct WsData"
  ],
  "explanation": "Needed symbols and why:\n\n1) ws_receive_frame\n   - run_usock calls ws_receive_frame(buf, &got, &type) and then treats the returned msg as a C string (passes it to snprintf(\"%s\") and later frees it). To judge any out\u2011of\u2011bounds string accesses you must know ws_receive_frame\u2019s contract/implementation: does it return a separately allocated buffer (ownership), does it NUL\u2011terminate payloads for WS_OPCODE_TEXT_FRAME, what is the allocated size, and how it computes/exports length (via got). If ws_receive_frame does not ensure NUL termination or returns a shorter allocation than the caller assumes, snprintf(\"%s\") (and any string.h users downstream) could read out of bounds.\n\n2) ws_send_frame\n   - run_usock constructs a text buffer and calls ws_send_frame(ws->sock, text, (size_t) buf_size). To verify no string.h violations you must know how ws_send_frame uses the text pointer and the passed length: does it rely on the provided length, or does it call strlen/strcpy/strcat/memcpy etc. incorrectly (e.g., using strlen instead of the supplied length, or copying more bytes than supplied). Any use of string.h functions inside ws_send_frame must be examined for buffer bounds relative to the buffer allocated in run_usock.\n\n3) send_all\n   - Static call graph shows ws_send_frame calls send_all (and send_all may call string functions or perform memory copies). If send_all is used to assemble or copy message bytes it may contain memcpy/memmove/strlen/strncpy usage. You need its implementation to determine whether any string.h calls can read/write beyond buffers passed in by ws_send_frame/run_usock.\n\n4) struct WsData\n   - run_usock accesses ws->urh and ws->sock and passes ws to the above functions. The struct definition is needed to confirm types (e.g., socket type) and any guarantees about lifetime/ownership of pointers returned by ws_receive_frame (if ws_receive_frame can return pointers into WsData-owned storage). In particular, ensure ws_receive_frame does not return a pointer into a buffer of limited lifetime or to a stack buffer inside ws_receive_frame that would be invalid when used by snprintf.\n\nSummary: to determine compliance with the MISRA rule about string.h functions you must inspect the implementations/contracts of ws_receive_frame, ws_send_frame and send_all (and struct WsData to understand ownership and lifetimes) because those are the places where string.h functions may be used and where buffer lengths, null\u2011termination and copying semantics are established."
}