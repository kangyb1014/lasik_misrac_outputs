{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "MHD_UpgradeResponseHandle",
    "MUTEX",
    "CLIENT_SOCKS",
    "MAX_CLIENTS",
    "MHD_INVALID_SOCKET",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "MHD_UPGRADE_ACTION_CLOSE",
    "make_blocking",
    "recv",
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "MHD_upgrade_action",
    "MHD_upgraded_connection_mark_app_closed_",
    "ssize_t",
    "snprintf",
    "malloc",
    "free",
    "pthread_mutex_lock",
    "pthread_mutex_unlock",
    "abort"
  ],
  "explanation": "Each listed symbol can hide or introduce compiler-specific language extensions in its declaration/definition; the MISRA rule requires checking for use of such extensions. To decide whether run_usock itself uses a language extension you must inspect the definitions/prototypes or macros for:\n\n- struct WsData: its definition may use compiler extensions (packed/aligned attributes, anonymous/zero-length arrays, typeof, __extension__, etc.).\n- MHD_UpgradeResponseHandle: typedef/struct could use non\u2011standard attributes or compiler-specific types.\n- MUTEX: likely a macro/identifier for a mutex object; its definition could expand to compiler/OS-specific constructs or attributes (e.g. __attribute__).\n- CLIENT_SOCKS: global array definition might use extensions (variable\u2011length arrays, section attributes, visibility attributes).\n- MAX_CLIENTS: macro or enum value; macro expansion could use statement expressions or other extensions.\n- MHD_INVALID_SOCKET: macro/constant; may be defined using compiler-specific constructs or types.\n- WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME: macros or enums whose definitions could hide extensions.\n- MHD_UPGRADE_ACTION_CLOSE: macro/enum used in call; its definition might use extensions.\n- make_blocking, recv, ws_receive_frame, ws_send_frame, send_all, MHD_upgrade_action, MHD_upgraded_connection_mark_app_closed_: function prototypes or inline definitions may include compiler extensions (GCC/Clang __attribute__ annotations, inline asm, builtins, statement expressions, inline functions with extensions). In particular MHD_* symbols come from an external library (libmicrohttpd) whose headers may use non\u2011standard attributes or extension keywords.\n- ssize_t: typedef from system headers; could be an implementation typedef that uses compiler extensions or non\u2011standard types.\n- snprintf, malloc, free, abort: standard library functions \u2014 their prototypes are normally standard but headers sometimes include compiler attributes (e.g. __attribute__((format(...))), __nothrow__)) which are compiler extensions; include them to verify no extension use affects this function.\n- pthread_mutex_lock, pthread_mutex_unlock: pthread prototypes or the MUTEX type may include extension annotations (visibility, attributes) or macros that map to extensions.\n\nInspecting these definitions/prototypes/macros is necessary to determine whether any language extensions (as documented by the compiler) are used by run_usock either directly (via constructs in the function) or indirectly (via macros/types/functions it uses)."
}