{
  "user_message": "An agent A claimed that the following MHD_pool_create code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_create.\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement '(void) 0; /* Mute possible compiler warning */' is an executed no-op in new_connection_process_ (hit on the error paths after pool creation failure and connection-limit/thread-create failures). Removing that statement does not change program behaviour, so it is dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/626.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fflush (f);\n  fclose (f);\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_probe_log(\"ENTER MHD_pool_create: max=%zu\\n\", max);\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  mhd_probe_log(\"malloc(sizeof(struct MemoryPool)) => pool=%p\\n\", (void *) pool);\n  if (NULL == pool)\n  {\n    mhd_probe_log(\"pool allocation failed, returning NULL\\n\");\n    return NULL;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    mhd_probe_log(\"branch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\\n\");\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    mhd_probe_log(\"rounded alloc_size for mmap/VirtualAlloc = %zu\\n\", alloc_size);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    mhd_probe_log(\"mmap attempted, returned %p\\n\", pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    mhd_probe_log(\"VirtualAlloc attempted, returned %p\\n\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  mhd_probe_log(\"no mmap support, set pool->memory = MAP_FAILED\\n\");\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    mhd_probe_log(\"pool->memory == MAP_FAILED, falling back to malloc\\n\");\n    alloc_size = ROUND_TO_ALIGN (max);\n    mhd_probe_log(\"ROUND_TO_ALIGN(max) => alloc_size=%zu\\n\", alloc_size);\n    pool->memory = malloc (alloc_size);\n    mhd_probe_log(\"malloc(%zu) for pool->memory => %p\\n\", alloc_size, pool->memory);\n    if (NULL == pool->memory)\n    {\n      mhd_probe_log(\"pool->memory malloc failed, freeing pool=%p and returning NULL\\n\", (void *) pool);\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n    mhd_probe_log(\"used malloc fallback, pool->is_mmap=false\\n\");\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n    mhd_probe_log(\"mmap/VirtualAlloc succeeded, pool->is_mmap=true, pool->memory=%p, alloc_size=%zu\\n\", pool->memory, alloc_size);\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_probe_log(\"pool final state: pos=%zu, end=%zu, size=%zu, memory=%p\\n\", pool->pos, pool->end, pool->size, pool->memory);\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  mhd_probe_log(\"EXIT MHD_pool_create returning pool=%p\\n\", (void *) pool);\n  return pool;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722f90e0\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722f90e0\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fa340\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722fa340\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fa590\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722fa590\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fa7e0\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722fa7e0\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722faa30\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722faa30\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fac80\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722fac80\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722faed0\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722faed0\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fb120\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, memory=0x558d722fb120\nEXIT MHD_pool_create returning pool=0x558d722f90b0\nENTER MHD_pool_create: max=32768\nmalloc(sizeof(struct MemoryPool)) => pool=0x558d722f90b0\nbranch: small allocation or < 4/3 page, set pool->memory = MAP_FAILED\npool->memory == MAP_FAILED, falling back to malloc\nROUND_TO_ALIGN(max) => alloc_size=32768\nmalloc(32768) for pool->memory => 0x558d722fb120\nused malloc fallback, pool->is_mmap=false\npool final state: pos=0, end=32768, size=32768, me\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported. The reported no-op '(void)0; /* Mute possible compiler warning */' does not appear in the provided MHD_pool_create implementation, and the supplied test logs exercise MHD_pool_create showing meaningful allocations and returns. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not affect program behaviour, but no such executed no-op is present in the target function as given. (Additionally, a lone '(void)0' is often used in macro expansions to preserve syntactic form; removing it can change how the macro parses in call sites, so such occurrences are not automatically dead code.) Therefore the report that MHD_pool_create violates Rule 2.2 is incorrect."
}