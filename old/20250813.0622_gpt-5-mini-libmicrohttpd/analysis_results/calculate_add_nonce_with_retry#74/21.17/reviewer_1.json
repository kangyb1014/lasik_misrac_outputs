{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strlen(realm) can read past the object if the caller passes a non-NULL pointer that does not point to a NUL-terminated char array or if realm is NULL. In those cases strlen will continue scanning memory beyond the object bounds (or dereference NULL), violating Rule 21.17. Ensure realm is non-NULL and NUL-terminated (or use a bounded alternative like strnlen with a known maximum) before calling strlen.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n    va_list ap;\n    FILE *f = fopen (\"/tmp/logs/599.txt\", \"a\");\n    if (!f)\n        return;\n    va_start (ap, fmt);\n    vfprintf (f, fmt, ap);\n    va_end (ap);\n    fprintf (f, \"\\n\");\n    fclose (f);\n}\n\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n    /* Log entry to mark function invocation and input pointer values. */\n    probe_log (\"calculate_add_nonce_with_retry: entry: connection=%p, realm=%p, da=%p, nonce=%p\",\n               (void *) connection, (const void *) realm, (void *) da, (void *) nonce);\n\n    const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n    probe_log (\"timestamp1=%llu\", (unsigned long long) timestamp1);\n\n    /* Placeholder for the algorithm's logic. Preserve intent: compute another\n       timestamp and log elapsed time; ultimately decide whether a nonce was\n       added (return true) or not (return false). */\n    const uint64_t timestamp2 = MHD_monotonic_msec_counter ();\n    probe_log (\"timestamp2=%llu\", (unsigned long long) timestamp2);\n\n    uint64_t elapsed = (timestamp2 >= timestamp1) ? (timestamp2 - timestamp1) : 0;\n    probe_log (\"elapsed_ms=%llu\", (unsigned long long) elapsed);\n\n    /* In the real implementation this would perform nonce computation and\n       possibly retry logic. Here we keep behavior simple and return true to\n       indicate success while preserving the logging behavior. */\n    return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for calculate_add_nonce_with_retry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The function calls strlen(realm) without checking that realm is non-NULL and NUL-terminated; strlen scans memory until it finds a NUL byte and will read out-of-bounds (or dereference NULL) if the caller passes an invalid pointer or a non-terminated buffer. Under MISRA C 2023 Rule 21.17 such uses are not permitted unless the code can guarantee the pointer parameter refers to an object containing a terminating NUL within bounds (e.g. via an explicit precondition that is enforced/documented). As presented, no such guarantee or check is visible, so the call constitutes a potential violation. (Also note other string.h uses in the function\u2014e.g. memcpy\u2014should similarly be checked to ensure both source and destination buffers are large enough; those would need analogous justification or bounds checks.) The test harness provided by A does not exercise the original strlen call, so the empty log does not invalidate the correctness of the reported issue. Recommended fixes: validate realm != NULL and/or use a bounded alternative (strnlen with a known maximum), or document and enforce a caller precondition that realm is a properly NUL-terminated, non-NULL string."
}