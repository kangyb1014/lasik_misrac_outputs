{
  "user_message": "Target function code is:\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'calculate_add_nonce': {'callees': ['MHD_get_master', 'digest_get_size', 'calculate_nonce', 'get_nonce_nc_idx', '__builtin_unreachable', 'is_slot_available'], 'callers': ['calculate_add_nonce_with_retry']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, '__builtin_rotateleft32': {'callees': [], 'callers': ['fast_simple_hash', 'calculate_add_nonce_with_retry', 'md5_transform']}, 'digest_reset': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'queue_auth_required_response3_inner': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'digest_init_one_time', 'get_base_digest_algo', 'MHD_get_master', 'digest_get_size', 'MHD_str_quote', 'calculate_add_nonce_with_retry', 'MHD_queue_response'], 'callers': ['MHD_queue_auth_required_response3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_get_master",
    "struct MHD_Daemon (digest_auth_rand_size, nonce_nc_size)",
    "MHD_DLOG",
    "MHD_monotonic_msec_counter",
    "calculate_add_nonce",
    "digest_get_size",
    "digest_ext_error",
    "digest_reset",
    "memcpy",
    "NONCE_STD_LEN",
    "MAX_DIGEST",
    "DAUTH_JUMPBACK_MAX",
    "_MHD_ROTR32",
    "_MHD_ROTL32",
    "random",
    "rand"
  ],
  "explanation": "To determine whether calculate_add_nonce_with_retry violates the MISRA rule \"A function parameter should not be modified\" we must be sure that none of the function's parameter identifiers (connection, realm, da, nonce) are assigned to inside this function \u2014 and also understand whether operations here legitimately modify the objects pointed to (which is permitted). The listed symbols are required because:\n\n- mhd_assert: Often a macro; we must inspect its definition to ensure it does not expand to code that assigns to any of the parameter identifiers (e.g. by hiding an assignment inside a macro).\n\n- MHD_get_master: Could be a function or macro. If it is a macro it might expand to expressions that modify its argument or the parameter variable; we must see its definition. Also the return value is queried for fields below.\n\n- struct MHD_Daemon (digest_auth_rand_size, nonce_nc_size): The code reads daemon->digest_auth_rand_size and ->nonce_nc_size; we need the structure/field definitions to confirm these are ordinary fields (no weird macro side effects) and to understand that accessing those fields does not modify the parameter pointer itself.\n\n- MHD_DLOG: Typically a logging macro; must check its expansion so it cannot perform assignments to function parameters (e.g. via comma-operator tricks) when invoked with connection->daemon.\n\n- MHD_monotonic_msec_counter: Called twice; must confirm it is a normal function (no macros that could assign to local parameter names) and to understand its return semantics used for timestamp comparisons (affects control flow that leads to other writes, but not pointer modification directly).\n\n- calculate_add_nonce: Called with several parameters including nonce. We need its prototype/definition to determine whether it could change the caller's parameter variable (it cannot change the caller's local parameter variable itself, but if it is implemented as a macro it might). Also we must know whether it modifies the object pointed to by nonce (which is allowed) and whether it could change other pointed-to objects (da, connection->daemon) in a way relevant to rule interpretation.\n\n- digest_get_size: Used to compute sizes for NONCE_STD_LEN and memcpy; we need its result to determine the size of memory writes (ensuring only the pointed-to object is modified, not the pointer variable itself). If digest_get_size is a macro, verify it does not assign to parameters.\n\n- digest_ext_error: Conditional call (under MHD_DIGEST_HAS_EXT_ERROR). If it's a macro rather than a pure query function it might have side effects; check it to ensure it does not assign to any parameter identifiers.\n\n- digest_reset: Called before re-trying; must confirm it operates on the digest object (da) pointed-to (allowed) and does not alter the local parameter variable da itself (e.g. via macro expansion that assigns to da).\n\n- memcpy: Standard library function used to write into the buffer pointed to by nonce. We need to verify it is used to modify the pointee (allowed) and not the pointer variable. Also check the size argument (NONCE_STD_LEN(digest_size)) to ensure the write stays within the pointee.\n\n- NONCE_STD_LEN and MAX_DIGEST: Macros used to size nonce2 and the final memcpy. Must inspect definitions to ensure they expand to constants/expressions (not to code that assigns to parameters) and to confirm the amount of pointee modification.\n\n- DAUTH_JUMPBACK_MAX: Macro masking amount subtracted from timestamp2; include to confirm it is a constant macro and not a construct that could modify parameters when expanded.\n\n- _MHD_ROTR32 and _MHD_ROTL32: These bit-rotation macros/functions are used in computing base2/base3/base4 and may be macros; examine their definitions to ensure they don't contain hidden assignments to parameter identifiers.\n\n- random and rand: Called (conditionally) to generate randomness. Check whether these are normal library functions and that their use cannot result in modification of parameter identifiers via strange macro definitions.\n\nIn short, the above symbols cover macros/functions and structure fields that either (a) could hide assignments to the formal parameter identifiers if they are implemented as macros with side effects, or (b) are used to perform allowed modifications to the objects pointed to (e.g. memcpy, digest_reset). Inspecting their definitions ensures the function does not modify the parameter variables themselves (which would violate MISRA), and that only the pointed-to objects are modified where permitted."
}