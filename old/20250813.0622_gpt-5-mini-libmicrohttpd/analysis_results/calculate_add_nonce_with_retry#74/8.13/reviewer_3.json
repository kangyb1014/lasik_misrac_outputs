{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If MHD_get_master is declared to return a non-const pointer (e.g. struct MHD_Daemon *), then the expression MHD_get_master(connection->daemon)->digest_auth_rand_size performs only read access and therefore the pointer should be to a const-qualified type. In that case Rule 8.13 is violated. (If, however, MHD_get_master already returns a pointer to a const-qualified type, there is no violation.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_Master {\n    size_t digest_auth_rand_size;\n    size_t nonce_nc_size;\n};\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/595.txt\", \"a\");\n    if (!f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\nstatic void my_mhd_assert(int cond)\n{\n    if (!cond)\n    {\n        probe_log(\"mhd_assert failed\");\n        abort();\n    }\n}\nstatic const char *underscore_fn(const char *s) { return s; }\nstatic inline size_t nonce_std_len(size_t x)\n{\n    (void)x;\n    return 128;\n}\nstatic const size_t MAX_DIGEST_CONST = 64;\n\nstatic size_t digest_get_size(struct DigestAlgorithm *da)\n{\n    (void)da;\n    return 32; /* arbitrary */\n}\nstatic void digest_reset(struct DigestAlgorithm *da)\n{\n    (void)da;\n}\nstatic bool calculate_add_nonce(struct MHD_Connection *const connection,\n                                uint64_t timestamp,\n                                const char *realm,\n                                size_t realm_len,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n    static int call_count = 0;\n    (void)connection; (void)timestamp; (void)realm; (void)realm_len; (void)da;\n    ++call_count;\n    if (call_count == 1)\n    {\n        probe_log(\"calculate_add_nonce: simulated failure on first call\");\n        return false;\n    }\n    /* On success, populate nonce with a visible pattern. */\n    strncpy(nonce, \"NONCE_OK\", nonce_std_len(MAX_DIGEST_CONST));\n    probe_log(\"calculate_add_nonce: simulated success on call %d\", call_count);\n    return true;\n}\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  my_mhd_assert (! da->hashing);\n\n  probe_log(\"enter: connection=%p daemon=%p realm=\\\"%s\\\" realm_len=%zu timestamp1=%llu\",\n            (void *)connection, (void *)(connection ? connection->daemon : NULL), realm, realm_len,\n            (unsigned long long) timestamp1);\n\n#ifdef HAVE_MESSAGES\n  /* Probe: record that we are about to read digest_auth_rand_size. */\n  {\n    struct MHD_Master *master = MHD_get_master (connection->daemon);\n    probe_log(\"HAVE_MESSAGES: MHD_get_master returned %p; digest_auth_rand_size=%zu\",\n              (void *)master, master->digest_auth_rand_size);\n    if (0 == master->digest_auth_rand_size)\n      ; /* Omit logging macro MHD_DLOG in this test scaffold. */\n  }\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    probe_log(\"first calculate_add_nonce failed; entering retry logic\");\n\n    const size_t digest_size = digest_get_size (da);\n    probe_log(\"digest_size=%zu\", digest_size);\n    char nonce2[/*nonce_std_len(MAX_DIGEST_CONST) + 1*/ 128 + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    {\n      struct MHD_Master *master = MHD_get_master (connection->daemon);\n      probe_log(\"checking nonce_nc_size via MHD_get_master(%p): nonce_nc_size=%zu\",\n                (void *)master, master->nonce_nc_size);\n      if (0 == master->nonce_nc_size)\n      {\n        probe_log(\"nonce_nc_size == 0 -> no retry, returning false\");\n        return false; /* No need to re-try */\n      }\n    }\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    probe_log(\"timestamp1=%llu timestamp2=%llu\",\n              (unsigned long long) timestamp1,\n              (unsigned long long) timestamp2);\n\n    if (timestamp1 == timestamp2)\n    {\n      probe_log(\"timestamps equal, generating arbitrary difference for nonce\");\n      uint64_t base1;\n      uint32_t base2 = 0;\n      uint16_t base3 = 0;\n      uint8_t base4 = 0;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = ((base2 >> 4) | (base2 << (32 - 4))); /* _MHD_ROTR32 simulated */\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = ((base2 << (((base4 >> 4) ^ base4) % 32)) | (base2 >> (32 - (((base4 >> 4) ^ base4) % 32)))); /* _MHD_ROTL32 simulated */\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      probe_log(\"generated bases: base1=%llu base2=%u base3=%u base4=%u\",\n                (unsigned long long) base1, base2, (unsigned)base3, (unsigned)base4);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & 127U);\n      if (timestamp1 == timestamp2)\n      {\n        timestamp2 -= 2; /* Fallback value */\n        probe_log(\"timestamp still equal after jumpback; using fallback timestamp2=%llu\",\n                  (unsigned long long) timestamp2);\n      }\n      else\n      {\n        probe_log(\"timestamp2 adjusted to %llu\", (unsigned long long) timestamp2);\n      }\n    }\n    digest_reset (da);\n    probe_log(\"calling calculate_add_nonce for retry with timestamp2=%llu\",\n              (unsigned long long) timestamp2);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      probe_log(\"retry calculate_add_nonce failed; no free slot found -> returning false\");\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, nonce_std_len(digest_size));\n    probe_log(\"retry succeeded; copied nonce2 to nonce (first bytes): %.32s\", nonce);\n  }\n  probe_log(\"exit: returning true (nonce first bytes): %.32s\", nonce);\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the provided snippet. MISRA C:2023 Rule 8.13 concerns pointer declarations: a pointer type should be to a const-qualified object when the object is not modified through that pointer. The call MHD_get_master(connection->daemon)->digest_auth_rand_size is just an expression; whether it violates Rule 8.13 depends on the declaration of MHD_get_master (its return type) and the global use of that return value across the project. Agent A\u2019s scenario assumes MHD_get_master is declared to return a non-const pointer and that the returned object is never modified anywhere, therefore it \u2018\u2018should\u2019\u2019 return a pointer to const. That might be true in some projects, but it is only provable by inspecting the function prototype and all uses of the returned pointer. From the code fragment alone we cannot conclude a violation: (a) the prototype may already return a pointer-to-const (no violation), or (b) the function may legitimately return a non-const pointer because callers may need to modify the object elsewhere (again no violation). The test scaffold failed to compile and produced no evidence. In short, the claim is speculative \u2014 it could be a real violation of Rule 8.13 if the function genuinely should return const and never modifies the object, but the provided code does not prove that. Therefore the report as given is not correct."
}