{
  "user_message": "An agent A claimed that the following post_process_multipart code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of post_process_multipart.\n```c\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the member pp->content_type is declared as a non-const pointer (e.g. 'char *content_type') but only read (as in this comparison), then Rule 8.13 is violated \u2014 the pointer should be declared 'const char *content_type' because the code only uses it for read-only operations (comparison against a string literal). If, however, pp->content_type is already declared 'const char *', there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const struct MHD_PostProcessor *pp, const char *event, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/451.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* try to print some useful state without modifying anything */\n  (void) fprintf (f, \"[post_process_multipart] %s: pp=%p\", event, (const void *) pp);\n  if (NULL != pp)\n  {\n    (void) fprintf (f, \" buffer_pos=%zu\", pp->buffer_pos);\n    (void) fprintf (f, \" content_type=%p\", (const void *) pp->content_type);\n    if (NULL != pp->content_type)\n    {\n      size_t _len = strnlen (pp->content_type, (size_t)128);\n      (void) fprintf (f, \" content_type_str=\\\"\");\n      (void) fwrite (pp->content_type, 1, _len, f);\n      if (_len == 128)\n        (void) fprintf (f, \"...\");\n      (void) fprintf (f, \"\\\"\");\n    }\n    else\n    {\n      (void) fprintf (f, \" content_type_str=NULL\");\n    }\n  }\n  if (NULL != extra)\n    (void) fprintf (f, \" extra=%s\", extra);\n  (void) fprintf (f, \"\\n\");\n  (void) fclose (f);\n}\n\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  probe_log (pp, \"ENTRY\", NULL);\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      probe_log (pp, \"OUT_OF_MEMORY\", \"max==0 && state_not_changed\");\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      probe_log (pp, \"ERROR_NO_RN\", \"no '\\\\r\\\\n'\");\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      probe_log (pp, \"RETURN_ERROR_STATE\", NULL);\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      probe_log (pp, \"RETURN_DONE_GOT_MORE\", NULL);\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * * to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      /* Log state before checking content type */\n      probe_log (pp, \"PP_PerformCheckMultipart_BEFORE_CHECK\", NULL);\n\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        probe_log (pp, \"PP_PerformCheckMultipart_MATCHED\", \"content_type is multipart/mixed\");\n\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        probe_log (pp, \"PP_PerformCheckMultipart_FOUND_BOUNDARY_CANDIDATE\", pp->nested_boundary ? pp->nested_boundary : \"NULL\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          probe_log (pp, \"PP_PerformCheckMultipart_BOUNDARY_MISSING\", NULL);\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        probe_log (pp, \"PP_PerformCheckMultipart_STRDUPED_NESTED_BOUNDARY\", pp->nested_boundary ? pp->nested_boundary : \"NULL\");\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          probe_log (pp, \"PP_PerformCheckMultipart_OUT_OF_MEMORY_STRDUP\", NULL);\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        probe_log (pp, \"PP_PerformCheckMultipart_FREE_CONTENT_TYPE_BEFORE\", NULL);\n        free (pp->content_type);\n        pp->content_type = NULL;\n        probe_log (pp, \"PP_PerformCheckMultipart_FREED_CONTENT_TYPE_AFTER\", NULL);\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n\n      probe_log (pp, \"PP_PerformCheckMultipart_NOT_MATCHED\", pp->content_type ? pp->content_type : \"NULL\");\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        probe_log (pp, \"PP_NESTED_INIT_NO_NESTED_BOUNDARY\", NULL);\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n\n      /* Log what was observed for headers including content_type */\n      probe_log (pp, \"PP_Nested_PerformMarking\", NULL);\n\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    probe_log (pp, \"SERIOUS_ERROR_LEFTOVER_DATA\", NULL);\n    return MHD_NO;              /* serious error */\n  }\n  probe_log (pp, \"RETURN_SUCCESS\", NULL);\n  return MHD_YES;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=0 content_type=(nil) content_type_str=NULL\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=1 content_type=(nil) content_type_str=NULL\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=1 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL extra=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\" extra=text/plain\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=0 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=0 content_type=(nil) content_type_str=NULL\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=2 content_type=(nil) content_type_str=NULL\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=2 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL extra=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\" extra=text/plain\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=0 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=0 content_type=(nil) content_type_str=NULL\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=3 content_type=(nil) content_type_str=NULL\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=3 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL extra=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\" extra=text/plain\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=0 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=0 content_type=(nil) content_type_str=NULL\n[post_process_multipart] RETURN_SUCCESS: pp=0x55d74d8792a0 buffer_pos=4 content_type=(nil) content_type_str=NULL\n[post_process_multipart] ENTRY: pp=0x55d74d8792a0 buffer_pos=4 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=172 content_type=(nil) content_type_str=NULL extra=NULL\n[post_process_multipart] PP_PerformCheckMultipart_BEFORE_CHECK: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n[post_process_multipart] PP_PerformCheckMultipart_NOT_MATCHED: pp=0x55d74d8792a0 buffer_pos=22 content_type=0x55d74d879970 content_type_str=\"text/plain\"\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's scenario is not a correct violation for this code. Rule 8.13 recommends that pointers should point to const-qualified types when the pointed-to data is only read. The reporter's claim depends on pp->content_type being purely read-only. In the real code, pp->content_type is later freed (free(pp->content_type); pp->content_type = NULL) when a nested multipart boundary is detected. Because the code performs ownership/deallocation operations on that pointer (not merely read-only comparisons), it is not appropriate to declare it as const char * without additional casts, and the rule does not mandate changing it to const in this usage. Therefore the reported violation is not correct for the actual post_process_multipart implementation shown."
}