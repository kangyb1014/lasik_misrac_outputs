{
  "user_message": "An agent A claimed that the following MHD_select code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_select.\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'fd_setsize' (type int) is modified inside internal_run_from_select by the assignment 'fd_setsize = FD_SETSIZE;'. This changes the value of a non\u2011pointer parameter, violating MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void MHD_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/133.txt\", \"a\");\n  if (f == NULL)\n    return;\n  /* timestamp */\n  time_t t = time(NULL);\n  struct tm tm_buf;\n  if (0 == localtime_r(&t, &tm_buf))\n  {\n    /* fallback: don't print time if conversion fails */\n  }\n  else\n  {\n    char timestr[64];\n    if (0 < strftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", &tm_buf))\n      fprintf(f, \"%s: \", timestr);\n  }\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  /* Log entry and initial state */\n  MHD_probe_log(\"ENTER MHD_select: daemon=%p, millisec=%d, shutdown=%d\",\n                (void *) daemon,\n                (int) millisec,\n                (daemon != NULL) ? (int) daemon->shutdown : -1);\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n  {\n    MHD_probe_log(\"EXIT MHD_select: daemon->shutdown true -> return MHD_NO\");\n    return MHD_NO;\n  }\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  MHD_probe_log(\"after suspend/resume check: millisec=%d, options=0x%08x\",\n                (int) millisec,\n                (unsigned) daemon->options);\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    MHD_probe_log(\"single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=%d\",\n                  (int) FD_SETSIZE);\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      MHD_probe_log(\"internal_get_fdset2 failed: err_state set to MHD_YES\");\n      err_state = MHD_YES;\n    }\n    else\n    {\n      MHD_probe_log(\"internal_get_fdset2 succeeded: maxsock=%ld\",\n                    (long) maxsock);\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      MHD_probe_log(\"thread-per-conn path: adding ITC fd=%ld with FD_SETSIZE=%d\",\n                    (long) MHD_itc_r_fd_ (daemon->itc),\n                    (int) FD_SETSIZE);\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        MHD_probe_log(\"MHD_add_to_fd_set_ for ITC failed: err_state set to MHD_YES\");\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        MHD_probe_log(\"consider adding listen fd=%ld to fdset (itc_added=%d, connections=%u, limit=%u, at_limit=%d)\",\n                      (long) ls,\n                      (int) itc_added,\n                      (unsigned) daemon->connections,\n                      (unsigned) daemon->connection_limit,\n                      (int) daemon->at_limit);\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          MHD_probe_log(\"MHD_add_to_fd_set_ for listen fd failed: err_state set to MHD_YES\");\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  MHD_probe_log(\"about to call MHD_SYS_select_: maxsock=%ld, tv=%p\",\n                (long) maxsock,\n                (void *) tv);\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  MHD_probe_log(\"MHD_SYS_select_ returned num_ready=%d\", num_ready);\n  if (daemon->shutdown)\n  {\n    MHD_probe_log(\"EXIT MHD_select: daemon->shutdown true after select -> return MHD_NO\");\n    return MHD_NO;\n  }\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    MHD_probe_log(\"select error: errno=%d\", err);\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      MHD_probe_log(\"select interrupted by signal (EINTR): returning %s\",\n                    (MHD_NO == err_state) ? \"MHD_YES\" : \"MHD_NO\");\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n    }\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    MHD_probe_log(\"select failed: %s (logged via MHD_socket_strerr_)\", MHD_socket_strerr_(err));\n    return MHD_NO;\n  }\n\n  /* Log the fact that we are about to call internal_run_from_select\n     and record the fd_setsize argument that is passed. This helps\n     reproduce the scenario where that function modifies its\n     non-pointer parameter (fd_setsize). */\n  MHD_probe_log(\"about to call internal_run_from_select: maxsock=%ld, num_ready=%d, fd_setsize=%d\",\n                (long) maxsock,\n                num_ready,\n                (int) FD_SETSIZE);\n\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n  {\n    MHD_probe_log(\"internal_run_from_select returned non-MHD_NO -> returning %s\",\n                  (MHD_NO == err_state) ? \"MHD_YES\" : \"MHD_NO\");\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  }\n\n  MHD_probe_log(\"internal_run_from_select returned MHD_NO -> continuing and returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling internal_get_fdset2 with FD_SETSIZE=1024\n2025-08-13 06:36:27: internal_get_fdset2 succeeded: maxsock=3\n2025-08-13 06:36:27: about to call MHD_SYS_select_: maxsock=3, tv=0x7ffdfaf641a0\n2025-08-13 06:36:27: MHD_SYS_select_ returned num_ready=0\n2025-08-13 06:36:27: about to call internal_run_from_select: maxsock=3, num_ready=0, fd_setsize=1024\n2025-08-13 06:36:27: internal_run_from_select returned non-MHD_NO -> returning MHD_YES\n2025-08-13 06:36:27: ENTER MHD_select: daemon=0x55717c956860, millisec=0, shutdown=0\n2025-08-13 06:36:27: after suspend/resume check: millisec=0, options=0x00000001\n2025-08-13 06:36:27: single-threaded path: calling inte\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s specific claim is incorrect. The logs show FD_SETSIZE (fd_setsize argument value) is passed as 1024 and there is no evidence it is altered by the call; modifying a parameter inside the callee would be a violation in that callee (internal_run_from_select), not in MHD_select. Moreover, MHD_select itself modifies its own parameter millisec (assigns millisec = 0 in several places), which would be a direct violation of MISRA C 2023 Rule 17.8. Therefore the report that MHD_select violates Rule 17.8 because internal_run_from_select assigns to its fd_setsize parameter is not correct."
}