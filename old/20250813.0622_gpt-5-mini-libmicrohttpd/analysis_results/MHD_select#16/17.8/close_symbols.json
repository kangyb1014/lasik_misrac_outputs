{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon (definition)",
    "MHD_D_IS_USING_THREAD_PER_CONN_ (macro or inline)",
    "resume_suspended_connections",
    "internal_get_fdset2",
    "MHD_ITC_IS_VALID_ (macro)",
    "MHD_itc_r_fd_ (macro/function)",
    "MHD_add_to_fd_set_",
    "daemon->listen_fd (field type) / MHD_INVALID_SOCKET",
    "daemon->shutdown, daemon->options, daemon->connections, daemon->connection_limit, daemon->at_limit, daemon->was_quiesced (field definitions)",
    "MHD_get_timeout64",
    "TIMEVAL/TIMEVAL_TV_SEC_MAX/_MHD_TIMEVAL_TV_SEC_TYPE and related SIZEOF_* macros",
    "MHD_SYS_select_ (wrapper for select)",
    "internal_run_from_select",
    "MHD_NO and MHD_YES (return/result constants) and enum MHD_Result",
    "FD_SETSIZE, FD_ZERO and FD_SET (fd_set macros)",
    "MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_ (socket error helpers)"
  ],
  "explanation": "To decide whether MHD_select violates the MISRA rule \u201ca function parameter shall not be modified\u201d we must be able to tell whether assignments in the body change the parameter objects (the pointer parameter 'daemon' or the scalar parameter 'millisec') or only objects they point to, and whether any invoked macro or callee implicitly rebinds or writes to those parameter variables. The required symbols and why:\n\n- struct MHD_Daemon (definition): needed to confirm the parameter type (is the pointer declared non-const?) and to inspect the fields referenced (shutdown, options, itc, listen_fd, connections, connection_limit, at_limit, was_quiesced) so we can distinguish writes to the daemon pointer itself (forbidden) from allowed modifications of the pointed-to object.\n\n- MHD_D_IS_USING_THREAD_PER_CONN_ (macro or inline): used in conditionals with the 'daemon' parameter; must inspect its expansion to ensure it does not contain assignments that would modify the 'daemon' parameter variable.\n\n- resume_suspended_connections: called and its result used to decide to set millisec = 0; include to ensure it has no unusual macro form or side-effect that rebinds the caller's parameters.\n\n- internal_get_fdset2: consulted because its presence alters control flow (and errno state), include to ensure it is a normal function and does not employ macros that could modify the caller parameters.\n\n- MHD_ITC_IS_VALID_ (macro): used with daemon->itc; inspect to ensure it doesn't modify the 'daemon' parameter.\n\n- MHD_itc_r_fd_ (macro/function): used to retrieve an FD from daemon->itc; include to confirm it does not reassign the daemon parameter variable.\n\n- MHD_add_to_fd_set_: called repeatedly; include to confirm it is a normal function (or macro) and that it does not rebind caller parameters.\n\n- daemon->listen_fd (field type) / MHD_INVALID_SOCKET: include to understand the type of listen_fd and the special invalid-socket value used in comparisons (affects control flow around assignments to millisec).\n\n- daemon->shutdown, daemon->options, daemon->connections, daemon->connection_limit, daemon->at_limit, daemon->was_quiesced (field definitions): to know whether accesses are reads or writes and whether any of the callees/macros might be implemented as macros that assign to the daemon parameter itself.\n\n- MHD_get_timeout64: affects control flow that leads to assignments to tv/select timeout; include to ensure it is not a macro that could modify the 'millisec' parameter variable.\n\n- TIMEVAL/TIMEVAL_TV_SEC_MAX/_MHD_TIMEVAL_TV_SEC_TYPE and SIZEOF_* macros: used to compute timeout.tv_sec/tv_usec; include to ensure none are defined in a way that aliases or modifies the 'millisec' identifier.\n\n- MHD_SYS_select_ (wrapper for select): include to see whether it is a macro or inline function that could have side-effects on caller parameters (very unlikely, but must be confirmed).\n\n- internal_run_from_select: included because it is called with the fd_sets and daemon; ensure it does not use macros that rebind caller parameters.\n\n- MHD_NO and MHD_YES (result constants) and enum MHD_Result: to interpret return-value logic (the function assigns to err_state and uses these constants) and to confirm there are no macro naming collisions with parameter names.\n\n- FD_SETSIZE, FD_ZERO and FD_SET (fd_set macros): included to ensure they are standard macros/functions and do not shadow or reassign parameter identifiers.\n\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_ (socket error helpers): included to rule out any macro-based definitions that might modify local parameter variables.\n\nIn short: include the definition of the daemon struct and the expansions/signatures of all macros and callees used in conditionals/assignments so we can be certain every occurrence of 'millisec' and 'daemon' in MHD_select is a plain parameter/local modification (which would be a MISRA violation for the parameter 'millisec' and for reassigning the pointer variable 'daemon' if that were done) rather than being an innocuous use of a macro or indirect side-effect. Only with those symbols can the next analyzer unambiguously determine whether the function modifies its formal parameters themselves."
}