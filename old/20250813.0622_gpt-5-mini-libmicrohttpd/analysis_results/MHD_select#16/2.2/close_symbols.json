{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "resume_suspended_connections",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "internal_get_fdset2",
    "MHD_DLOG",
    "MHD_add_to_fd_set_",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_INVALID_SOCKET",
    "FD_SETSIZE",
    "MHD_SYS_select_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "internal_run_from_select",
    "MHD_get_timeout64",
    "TIMEVAL_TV_SEC_MAX",
    "SIZEOF_UINT64_T",
    "SIZEOF_STRUCT_TIMEVAL_TV_SEC",
    "_MHD_TIMEVAL_TV_SEC_TYPE"
  ],
  "explanation": "For MISRA dead-code analysis we must know which executed operations have observable side effects or affect control flow. The following symbols are required and why:\n\n- struct MHD_Daemon\n  Needed to know the semantics and mutability of fields read in the function (shutdown, options, itc, listen_fd, was_quiesced, connections, connection_limit, at_limit). Those fields determine control-flow and whether code is removable without changing behavior.\n\n- MHD_TEST_ALLOW_SUSPEND_RESUME\n  The options bit tested in daemon->options. Knowing its meaning/usage is required to determine whether the branch that forces millisec=0 can ever be taken (and whether removing it would change behavior).\n\n- resume_suspended_connections\n  Called and its return value is tested; it likely has side effects (resuming connections). To decide whether that call (and the branch that depends on its return) is dead, we must know its possible return values and side effects.\n\n- MHD_D_IS_USING_THREAD_PER_CONN_\n  Macro/function controlling the two very different code paths (single-threaded vs per-connection threads). Its value determines reachability of large code blocks; essential to determine if either branch is dead.\n\n- internal_get_fdset2\n  Populates fdsets and can set err_state; its return value controls error handling and later behavior. Must know whether it can ever fail or has side effects making its call non-removable.\n\n- MHD_DLOG\n  Logging function used in many error branches. To treat logging statements as dead (removable) we must know whether MHD_DLOG has no program-state side effects; if it affects state/timing, removing it changes behaviour.\n\n- MHD_add_to_fd_set_\n  Adds sockets to fdsets and returns a success flag. Its side effects (mutating fdsets/maxsock) are central to program behavior; necessary to determine whether calls to it are removable.\n\n- MHD_ITC_IS_VALID_\n  Macro/function that tests the inter-thread control (ITC) presence. Determines whether ITC-related code is executed; required to know reachability.\n\n- MHD_itc_r_fd_\n  Returns the ITC read descriptor passed to MHD_add_to_fd_set_. If it can be invalid or have side effects, that affects whether ITC code is meaningful.\n\n- MHD_INVALID_SOCKET\n  Constant compared against listen_fd; used to decide whether listen_fd handling code is reachable.\n\n- FD_SETSIZE\n  Passed to fd-set helpers; may constrain calls or affect whether MHD_add_to_fd_set_ can add FDs. Knowledge may affect whether certain additions are no-ops.\n\n- MHD_SYS_select_\n  The select wrapper \u2014 central observable effect (blocking/selecting). Must know its semantics, side effects, and return values to decide if surrounding code is removable.\n\n- MHD_socket_get_error_\n  Used when select fails; needed to determine whether the error-handling branch can be executed and whether it has side effects.\n\n- MHD_SCKT_ERR_IS_EINTR_\n  Macro that identifies EINTR; affects whether the function returns MHD_YES or MHD_NO on interruption. Necessary to reason about the value returned and whether code is dead.\n\n- MHD_socket_strerr_\n  Used only in logging of select failures; need to know if it has side effects beyond formatting (e.g., global state), to decide if that logging call is removable.\n\n- internal_run_from_select\n  Processes the fdsets after select and returns a value that determines the function's final return. It almost certainly has state-changing side effects (handling connections); essential to determine if the call (and preceding select) is removable.\n\n- MHD_get_timeout64\n  Used to compute select timeout; may have side effects or return different values that change timing/behaviour. Needed to decide if timeout-related branches (including setting tv=NULL) are removable.\n\n- TIMEVAL_TV_SEC_MAX\n  Compile-time cap on timeout.tv_sec; needed to understand the effect of timeout saturation logic (could change timing behavior if removed).\n\n- SIZEOF_UINT64_T and SIZEOF_STRUCT_TIMEVAL_TV_SEC\n  Used in the preprocessor conditional that selects whether the saturation check is compiled in. Must know their values to determine whether that code is present/active.\n\n- _MHD_TIMEVAL_TV_SEC_TYPE\n  The type-cast target for timeout.tv_sec; needed to see if the assignment changes behavior (e.g., truncation) and thus whether the related code is removeable.\n\nNotes: The list focuses on symbols that (a) affect control flow reachability of branches, (b) have potential side effects (state changes, timing), or (c) are involved in observable behaviour (I/O, logging, blocking). To decide if any executed statement is dead you must know whether removing it would alter program state, timing, or external observables; the symbols above supply that information."
}