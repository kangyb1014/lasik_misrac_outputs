{
  "user_message": "An agent A claimed that the following try_ready_chunked_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_chunked_body.\n```c\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    if (128 > size)\n    {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n    mhd_assert ((NULL == connection->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (connection->pool, \\\n                                               connection->write_buffer, \\\n                                               connection->write_buffer_size));\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  if (0 == left_to_send)\n    /* nothing to send, don't bother calling crc */\n    ret = MHD_CONTENT_READER_END_OF_STREAM;\n  else if ( (response->data_start <=\n             connection->rp.rsp_write_position) &&\n            (response->data_start + response->data_size >\n             connection->rp.rsp_write_position) )\n  {\n    /* difference between rsp_write_position and data_start is less\n       than data_size which is size_t type, no need to check for overflow */\n    const size_t data_write_offset\n      = (size_t) (connection->rp.rsp_write_position\n                  - response->data_start);\n    /* buffer already ready, use what is there for the chunk */\n    mhd_assert (SSIZE_MAX >= (response->data_size - data_write_offset));\n    mhd_assert (response->data_size >= data_write_offset);\n    ret = (ssize_t) (response->data_size - data_write_offset);\n    if ( ((size_t) ret) > size_to_fill)\n      ret = (ssize_t) size_to_fill;\n    memcpy (&connection->write_buffer[max_chunk_hdr_len],\n            &response->data[data_write_offset],\n            (size_t) ret);\n  }\n  else\n  {\n    if (NULL == response->crc)\n    { /* There is no way to reach this code */\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"No callback for the chunked data.\"));\n      return MHD_NO;\n    }\n    ret = response->crc (response->crc_cls,\n                         connection->rp.rsp_write_position,\n                         &connection->write_buffer[max_chunk_hdr_len],\n                         size_to_fill);\n  }\n  if (MHD_CONTENT_READER_END_WITH_ERROR == ret)\n  {\n    /* error, close socket! */\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application error \" \\\n                               \"generating response).\"));\n    return MHD_NO;\n  }\n  if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n  {\n    *p_finished = true;\n    /* TODO: remove update of the response size */\n    response->total_size = connection->rp.rsp_write_position;\n    return MHD_YES;\n  }\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  if (size_to_fill < (size_t) ret)\n  {\n#if defined(MHD_USE_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection (application returned \" \\\n                               \"more data than requested).\"));\n    return MHD_NO;\n  }\n  chunk_hdr_len = MHD_uint32_to_strx ((uint32_t) ret, chunk_hdr,\n                                      sizeof(chunk_hdr));\n  mhd_assert (chunk_hdr_len != 0);\n  mhd_assert (chunk_hdr_len < sizeof(chunk_hdr));\n  *p_finished = false;\n  connection->write_buffer_send_offset =\n    (max_chunk_hdr_len - (chunk_hdr_len + 2));\n  memcpy (connection->write_buffer + connection->write_buffer_send_offset,\n          chunk_hdr,\n          chunk_hdr_len);\n  connection->write_buffer[max_chunk_hdr_len - 2] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len - 1] = '\\n';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret] = '\\r';\n  connection->write_buffer[max_chunk_hdr_len + (size_t) ret + 1] = '\\n';\n  connection->rp.rsp_write_position += (size_t) ret;\n  connection->write_buffer_append_offset = max_chunk_hdr_len + (size_t) ret + 2;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call to MHD_pool_is_resizable_inplace passes connection->write_buffer to a function whose block parameter is declared as void *block even though the implementation only examines the pointer and does not modify the pointed-to memory. The block parameter (and the corresponding connection->write_buffer pointer type if it represents immutable data) could and should be const-qualified (e.g. const void *block). Therefore Rule 8.13 is violated: a pointer should point to a const-qualified type whenever possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct connection_rp {\n  struct MHD_Response *response;\n  size_t rsp_write_position;\n};\nstatic const uint64_t MHD_SIZE_UNKNOWN = (uint64_t)-1;\nstatic void mhd_assert (int cond) { (void) cond; }\nstatic void CONNECTION_CLOSE_ERROR (struct MHD_Connection *c, const char *msg)\n{ (void) c; (void) msg; }\nstatic const char * _ (const char *s) { return s; }\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/715.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  fflush (f);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\ntry_ready_chunked_body (struct MHD_Connection *connection,\n                        bool *p_finished)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n  static const size_t max_chunk = 0xFFFFFF;\n  char chunk_hdr[6];            /* 6: max strlen of \"FFFFFF\" */\n  /* \"FFFFFF\" + \"\\r\\n\" */\n  static const size_t max_chunk_hdr_len = sizeof(chunk_hdr) + 2;\n  /* \"FFFFFF\" + \"\\r\\n\" + \"\\r\\n\" (chunk termination) */\n  static const size_t max_chunk_overhead = sizeof(chunk_hdr) + 2 + 2;\n  size_t chunk_hdr_len;\n  uint64_t left_to_send;\n  size_t size_to_fill;\n\n  response = connection->rp.response;\n  mhd_assert (NULL != response->crc || NULL != response->data);\n\n  mhd_assert (0 == connection->write_buffer_append_offset);\n\n  /* Log entry state */\n  log_probe (\"try_ready_chunked_body ENTER: connection=%p, response=%p, write_buffer=%p, write_buffer_size=%zu, pool=%p, rsp_write_pos=%zu\",\n             (void *)connection,\n             (void *)response,\n             (void *)connection->write_buffer,\n             connection->write_buffer_size,\n             (void *)connection->pool,\n             connection->rp.rsp_write_position);\n\n  /* The buffer must be reasonably large enough */\n  if (128 > connection->write_buffer_size)\n  {\n    size_t size;\n\n    size = connection->write_buffer_size + MHD_pool_get_free (connection->pool);\n    log_probe (\"computed new candidate size=%zu (old=%zu, pool_free=%zu)\",\n               size, connection->write_buffer_size,\n               (size_t) MHD_pool_get_free (connection->pool));\n    if (128 > size)\n    {\n      /* not enough memory */\n      log_probe (\"not enough memory: closing connection\");\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    /* Limit the buffer size to the largest usable size for chunks */\n    if ( (max_chunk + max_chunk_overhead) < size)\n      size = max_chunk + max_chunk_overhead;\n\n    /* Probe the resizable-inplace property and log it (no behavior change) */\n    {\n      int resizable = 0;\n      /* Call the function to capture its runtime behavior; this duplicates\n         the assertion but is side-effect free for typical implementations. */\n      resizable = MHD_pool_is_resizable_inplace (connection->pool,\n                                                 connection->write_buffer,\n                                                 connection->write_buffer_size);\n      log_probe (\"MHD_pool_is_resizable_inplace called: pool=%p, block=%p, block_size=%zu -> %d\",\n                 (void *)connection->pool,\n                 (void *)connection->write_buffer,\n                 connection->write_buffer_size,\n                 resizable);\n    }\n\n    connection->write_buffer =\n      MHD_pool_reallocate (connection->pool,\n                           connection->write_buffer,\n                           connection->write_buffer_size,\n                           size);\n    log_probe (\"MHD_pool_reallocate returned: new_write_buffer=%p (requested_size=%zu)\",\n               (void *)connection->write_buffer,\n               size);\n    mhd_assert (NULL != connection->write_buffer);\n    connection->write_buffer_size = size;\n  }\n  mhd_assert (max_chunk_overhead < connection->write_buffer_size);\n\n  if (MHD_SIZE_UNKNOWN == response->total_size)\n    left_to_send = MHD_SIZE_UNKNOWN;\n  else\n    left_to_send = response->total_size\n                   - connection->rp.rsp_write_position;\n\n  size_to_fill = connection->write_buffer_size - max_chunk_overhead;\n  /* Limit size for the callback to the max usable size */\n  if (max_chunk < size_to_fill)\n    size_to_fill = max_chunk;\n  if (left_to_send < size_to_fill)\n    size_to_fill = (size_t) left_to_send;\n\n  /* Fixed the broken format string and completed the logging call */\n  log_probe (\"left_to_send=%llu, size_to_fill=%zu\",\n             (unsigned long long) left_to_send,\n             size_to_fill);\n\n  /* The original implementation would invoke application callbacks to fill\n     the buffer. Here we keep the logic minimal: indicate whether we're\n     finished based on left_to_send. */\n  if (p_finished)\n    *p_finished = (left_to_send == 0);\n\n  /* No actual write performed in this compilation-only stub; return success */\n  (void) ret; (void) chunk_hdr_len; (void) chunk_hdr;\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C:2023 Rule 8.13 concerns how pointers are declared in the code under review: a pointer type should be const-qualified when the pointed-to object is not modified through that pointer. In try_ready_chunked_body the connection->write_buffer is treated as a modifiable buffer (it is the destination of memcpy, elements of it are assigned, and it is reallocated and then written into). Therefore connection->write_buffer must be a pointer to a non-const object, and the local use in this function does not violate Rule 8.13.\n\nAgent A\u2019s argument rests on the signature of MHD_pool_is_resizable_inplace taking a void *block and on an assumption that the implementation only examines the pointer and does not modify the memory. Whether that library function could have been declared to accept a const void * is a property of the library API, not of this caller. A mismatch (callee declares non-const) does not create a Rule 8.13 violation in this caller when the object is legitimately modifiable here. Also the agent did not show a pointer in this translation unit that is declared non-const yet never used to modify the pointed-to object; the code shows the buffer is modified later, so const would be inappropriate.\n\nIn short: the buffer is modified by this code, so it must be non-const; the possible improvement of the callee\u2019s prototype is a separate API-design issue and does not demonstrate a MISRA 8.13 violation in try_ready_chunked_body."
}