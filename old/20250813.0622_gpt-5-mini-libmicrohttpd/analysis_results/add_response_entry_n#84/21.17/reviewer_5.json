{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen(content) after only checking content != NULL. If a caller passes a non-NULL pointer to a character buffer that is not NUL-terminated (for example a binary buffer or a buffer allocated/filled with explicit lengths via memcpy without a terminating '\\0'), strlen will read past the buffer boundary searching for a NUL and thus perform out-of-bounds accesses. This use of strlen can therefore violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe(const char *tag,\n          struct MHD_Response *response,\n          enum MHD_ValueKind kind,\n          const char *header,\n          size_t header_len,\n          const char *content,\n          size_t content_len)\n{\n  FILE *f = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Basic context */\n  fprintf(f, \"[%s] response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu\\n\",\n          tag, (void *) response, (int) kind,\n          (void *) header, header_len, (void *) content, content_len);\n\n  /* Safe probes: only call memchr when pointer is non-NULL */\n  fprintf(f, \"[%s] header_has_tab=%d header_has_space=%d header_has_CR=%d header_has_LF=%d\\n\",\n          tag,\n          header ? (NULL != memchr(header, '\\t', header_len)) : 0,\n          header ? (NULL != memchr(header, ' ', header_len)) : 0,\n          header ? (NULL != memchr(header, '\\r', header_len)) : 0,\n          header ? (NULL != memchr(header, '\\n', header_len)) : 0);\n\n  fprintf(f, \"[%s] content_has_CR=%d content_has_LF=%d content_has_NUL_within_len=%d\\n\",\n          tag,\n          content ? (NULL != memchr(content, '\\r', content_len)) : 0,\n          content ? (NULL != memchr(content, '\\n', content_len)) : 0,\n          content ? (NULL != memchr(content, '\\0', content_len)) : 0);\n\n  fclose(f);\n}\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  /* Log entry */\n  log_probe(\"entry\", response, kind, header, header_len, content, content_len);\n\n  if (NULL == response)\n  {\n    log_probe(\"fail_null_response\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (0 == header_len)\n  {\n    log_probe(\"fail_zero_header_len\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (0 == content_len)\n  {\n    log_probe(\"fail_zero_content_len\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (header, '\\t', header_len))\n  {\n    log_probe(\"fail_header_tab\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (header, ' ', header_len))\n  {\n    log_probe(\"fail_header_space\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (header, '\\r', header_len))\n  {\n    log_probe(\"fail_header_CR\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (header, '\\n', header_len))\n  {\n    log_probe(\"fail_header_LF\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (content, '\\r', content_len))\n  {\n    log_probe(\"fail_content_CR\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (NULL != memchr (content, '\\n', content_len))\n  {\n    log_probe(\"fail_content_LF\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  /* Before calling the underlying function, log the state. We do not call strlen() here\n     (which would be unsafe for non-NUL-terminated buffers). Instead we record whether a NUL\n     byte exists within the provided content_len using memchr above inside log_probe. */\n  log_probe(\"before_MHD_add\", response, kind, header, header_len, content, content_len);\n\n  bool result = MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                                   content, content_len);\n\n  /* Log the result of the final call */\n  {\n    FILE *f = fopen(\"/tmp/logs/679.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf(f, \"[after_MHD_add] result=%d response=%p\\n\", (int) result, (void *) response);\n      fclose(f);\n    }\n  }\n\n  return result;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f0b0 content_len=8\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f0b0 content_len=8\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f0de content_len=8\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f0de content_len=8\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f118 content_len=8\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312f0b9 header_len=13 content=0x55e1d312f118 content_len=8\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fb9b header_len=4 content=0x55e1d312fb7d content_len=29\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fb9b header_len=4 content=0x55e1d312fb7d content_len=29\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fb9b header_len=4 content=0x55e1d312fbe0 content_len=29\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fb9b header_len=4 content=0x55e1d312fbe0 content_len=29\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fc66 header_len=17 content=0x55e1d312fc5e content_len=7\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55e203f1f2a0 kind=1 header=0x55e1d312fc66 header_len=17 content=0x55e1d312fc5e content_len=7\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[after_MHD_add] result=1 response=0x55e203f1f2a0\n[entry] response=0x55d610a17b40 kind=1 header=0x55d5e0b1c7be header_len=7 content=0x55d5e0b1c7a9 content_len=20\n[entry] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[entry] content_has_CR=0 content_has_LF=0 content_has_NUL_within_len=0\n[before_MHD_add] response=0x55d610a17b40 kind=1 header=0x55d5e0b1c7be header_len=7 content=0x55d5e0b1c7a9 content_len=20\n[before_MHD_add] header_has_tab=0 header_has_space=0 header_has_CR=0 header_has_LF=0\n[before_MHD_add] content_has_CR=0 content_has_LF=0 content_has_NUL_\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The add_response_entry_n implementation shown does not call strlen() anywhere \u2014 it uses memchr() with explicit header_len/content_len bounds. memchr(ptr, ..., len) will not read beyond the passed length, so the code as shown does not perform out-of-bounds accesses via strlen. The provided test logs confirm that content had no NUL within content_len yet MHD_add_response_entry_no_check_ returned successfully, showing no evidence of a strlen() invocation in this call path that would scan past the buffer. Therefore the claimed MISRA C 2023 Rule 21.17 violation (due to a strlen reading past the buffer) is not supported by the code or the test output."
}