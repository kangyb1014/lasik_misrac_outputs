{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If 'header' is NULL while 'header_len' > 0 (caller-supplied), the call memchr(header, '\\n', header_len) will attempt to read up to header_len bytes via the NULL pointer, causing an out-of-bounds (undefined) access. The memchr usage is only safe if the caller guarantees that 'header' points to an object at least 'header_len' bytes long; that guarantee is not enforced in add_response_entry_n before this call.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe(const char *label,\n          const struct MHD_Response *response,\n          enum MHD_ValueKind kind,\n          const char *header, size_t header_len,\n          const char *content, size_t content_len)\n{\n  FILE *f = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf(f, \"[add_response_entry_n] %s\\n\", label);\n  fprintf(f, \"  response=%p\\n\", (void *) response);\n  fprintf(f, \"  kind=%d\\n\", (int) kind);\n  fprintf(f, \"  header=%p, header_len=%zu\\n\", (void *) header, header_len);\n  fprintf(f, \"  content=%p, content_len=%zu\\n\", (void *) content, content_len);\n  fprintf(f, \"  header_is_null=%d, content_is_null=%d\\n\",\n          (header == NULL) ? 1 : 0, (content == NULL) ? 1 : 0);\n\n  /* If header is non-NULL and small, optionally print a hexdump of up to 32 bytes. */\n  if (header != NULL && header_len > 0) {\n    size_t dump_len = header_len < 32 ? header_len : 32;\n    fprintf(f, \"  header_bytes(hexdump up to %zu bytes):\", dump_len);\n    for (size_t i = 0; i < dump_len; ++i)\n      fprintf(f, \" %02x\", (unsigned char) header[i]);\n    fprintf(f, \"\\n\");\n  }\n\n  /* If content is non-NULL and small, optionally print a hexdump of up to 32 bytes. */\n  if (content != NULL && content_len > 0) {\n    size_t dump_len = content_len < 32 ? content_len : 32;\n    fprintf(f, \"  content_bytes(hexdump up to %zu bytes):\", dump_len);\n    for (size_t i = 0; i < dump_len; ++i)\n      fprintf(f, \" %02x\", (unsigned char) content[i]);\n    fprintf(f, \"\\n\");\n  }\n\n  fflush(f);\n  fclose(f);\n}\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  /* Log entry state */\n  log_probe(\"entry\", response, kind, header, header_len, content, content_len);\n\n  if (NULL == response) {\n    log_probe(\"early_return: response is NULL\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (0 == header_len) {\n    log_probe(\"early_return: header_len == 0\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n  if (0 == content_len) {\n    log_probe(\"early_return: content_len == 0\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  /* Before each memchr call we log the parameters so the case where header==NULL and\n     header_len>0 (which would cause memchr to read via a NULL pointer) is recorded.\n     We preserve the original control flow and behavior by performing the same checks\n     as in the original function. */\n  log_probe(\"before_memchr_tab\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (header, '\\t', header_len)) {\n    log_probe(\"reject: header contains tab\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"before_memchr_space\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (header, ' ', header_len)) {\n    log_probe(\"reject: header contains space\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"before_memchr_cr\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (header, '\\r', header_len)) {\n    log_probe(\"reject: header contains CR\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"before_memchr_lf\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (header, '\\n', header_len)) {\n    log_probe(\"reject: header contains LF\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"before_memchr_content_cr\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (content, '\\r', content_len)) {\n    log_probe(\"reject: content contains CR\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"before_memchr_content_lf\", response, kind, header, header_len, content, content_len);\n  if (NULL != memchr (content, '\\n', content_len)) {\n    log_probe(\"reject: content contains LF\", response, kind, header, header_len, content, content_len);\n    return false;\n  }\n\n  log_probe(\"calling_MHD_add_response_entry_no_check_\", response, kind, header, header_len, content, content_len);\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[add_response_entry_n] entry\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_tab\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_space\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_cr\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_lf\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_content_cr\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] before_memchr_content_lf\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] calling_MHD_add_response_entry_no_check_\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0b0, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 31\n[add_response_entry_n] entry\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0de, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 32\n[add_response_entry_n] before_memchr_tab\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0de, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 32\n[add_response_entry_n] before_memchr_space\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0de, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 32\n[add_response_entry_n] before_memchr_cr\n  response=0x55728a5e72a0\n  kind=1\n  header=0x55724fbcc0b9, header_len=13\n  content=0x55724fbcc0de, content_len=8\n  header_is_null=0, content_is_null=0\n  header_bytes(hexdump up to 13 bytes): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n  content_bytes(hexdump up to 8 bytes): 76 61 6c 75 65 2d 61 32\n[add_response_entry_n] before_memchr_lf\n  response\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function calls memchr(header, ..., header_len) and memchr(content, ..., content_len) without first ensuring that the pointer parameters are non-NULL when their corresponding lengths are > 0. memchr may read up to N bytes from the object referenced by its pointer argument, so calling memchr with a NULL pointer and a non-zero length can result in an out-of-bounds/undefined access. To satisfy MISRA C 2023 Rule 21.17 the function must ensure the pointers are valid for the requested lengths (e.g. check header != NULL when header_len > 0 and content != NULL when content_len > 0), or otherwise enforce and document a caller contract that guarantees the pointers are non-NULL when the lengths are non-zero. As written, the code can violate Rule 21.17."
}