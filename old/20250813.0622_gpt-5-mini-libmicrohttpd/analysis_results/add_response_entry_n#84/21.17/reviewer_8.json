{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strlen(header) in add_response_entry without validating that header is non-NULL and NUL-terminated. If a caller (for example MHD_add_response_header) passes header == NULL or passes a char buffer that is not NUL-terminated (i.e. only a pointer + length is known), strlen will read past the object bounds causing a violation (out-of-bounds access).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  /* Probe logging: capture control path and state to /tmp/logs/679.txt. */\n  FILE *fp = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (fp)\n    {\n      fprintf(fp, \"add_response_entry_n called: response=%p, kind=%d, header=%p, header_len=%zu, content=%p, content_len=%zu\\n\",\n              (void *) response, (int) kind, (const void *) header, header_len, (const void *) content, content_len);\n\n      if (NULL == response)\n        fprintf(fp, \"-> early check: response is NULL\\n\");\n\n      if (NULL == header)\n        {\n          fprintf(fp, \"-> header is NULL (will cause memchr on NULL if header_len > 0)\\n\");\n        }\n      else\n        {\n          /* Safe inspection: only examine header contents if header != NULL and within header_len. */\n          const void *nul = memchr(header, '\\0', header_len);\n          fprintf(fp, \"-> header contains NUL within header_len? %s\\n\", nul ? \"yes\" : \"no\");\n\n          /* Dump up to a limited number of bytes from header to help reproduce non-terminated buffers. */\n          size_t dump_len = header_len < 128 ? header_len : 128;\n          fprintf(fp, \"-> header bytes (hex, first %zu):\", dump_len);\n          for (size_t i = 0; i < dump_len; ++i)\n            fprintf(fp, \" %02x\", (unsigned char) header[i]);\n          fprintf(fp, \"\\n\");\n        }\n\n      if (NULL == content)\n        fprintf(fp, \"-> content is NULL\\n\");\n      else\n        {\n          const void *nulc = memchr(content, '\\0', content_len);\n          fprintf(fp, \"-> content contains NUL within content_len? %s\\n\", nulc ? \"yes\" : \"no\");\n\n          size_t cd = content_len < 128 ? content_len : 128;\n          fprintf(fp, \"-> content bytes (hex, first %zu):\", cd);\n          for (size_t i = 0; i < cd; ++i)\n            fprintf(fp, \" %02x\", (unsigned char) content[i]);\n          fprintf(fp, \"\\n\");\n        }\n\n      fclose(fp);\n    }\n\n  /* Preserve original logic exactly. */\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3a0b9, header_len=13, content=0x55b273c3a0b0, content_len=8\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 13): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 8): 76 61 6c 75 65 2d 61 31\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3a0b9, header_len=13, content=0x55b273c3a0de, content_len=8\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 13): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 8): 76 61 6c 75 65 2d 61 32\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3a0b9, header_len=13, content=0x55b273c3a118, content_len=8\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 13): 48 65 61 64 65 72 2d 54 79 70 65 2d 41\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 8): 76 61 6c 75 65 2d 61 33\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3ab9b, header_len=4, content=0x55b273c3ab7d, content_len=29\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 4): 44 61 74 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 29): 57 65 64 2c 20 30 31 20 41 70 72 20 32 30 31 35 20 30 30 3a 30 30 3a 30 30 20 47 4d 54\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3ab9b, header_len=4, content=0x55b273c3abe0, content_len=29\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 4): 44 61 74 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 29): 54 68 75 2c 20 30 31 20 41 70 72 20 32 30 32 31 20 30 30 3a 30 30 3a 30 30 20 47 4d 54\nadd_response_entry_n called: response=0x55b28a0b02a0, kind=1, header=0x55b273c3ac66, header_len=17, content=0x55b273c3ac5e, content_len=7\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 17): 54 72 61 6e 73 66 65 72 2d 45 6e 63 6f 64 69 6e 67\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 7): 63 68 75 6e 6b 65 64\nadd_response_entry_n called: response=0x56441255db40, kind=1, header=0x5643e3cd57be, header_len=7, content=0x5643e3cd57a9, content_len=20\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 7): 55 70 67 72 61 64 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 20): 48 65 6c 6c 6f 20 57 6f 72 6c 64 20 50 72 6f 74 6f 63 6f 6c\nadd_response_entry_n called: response=0x56441255e750, kind=1, header=0x5643e3cd57be, header_len=7, content=0x5643e3cd57a9, content_len=20\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 7): 55 70 67 72 61 64 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 20): 48 65 6c 6c 6f 20 57 6f 72 6c 64 20 50 72 6f 74 6f 63 6f 6c\nadd_response_entry_n called: response=0x56441255ed10, kind=1, header=0x5643e3cd57be, header_len=7, content=0x5643e3cd57a9, content_len=20\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 7): 55 70 67 72 61 64 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 20): 48 65 6c 6c 6f 20 57 6f 72 6c 64 20 50 72 6f 74 6f 63 6f 6c\nadd_response_entry_n called: response=0x7f44dc000b90, kind=1, header=0x5643e3cd57be, header_len=7, content=0x5643e3cd57a9, content_len=20\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 7): 55 70 67 72 61 64 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 20): 48 65 6c 6c 6f 20 57 6f 72 6c 64 20 50 72 6f 74 6f 63 6f 6c\nadd_response_entry_n called: response=0x7f44d8000b90, kind=1, header=0x5643e3cd57be, header_len=7, content=0x5643e3cd57a9, content_len=20\n-> header contains NUL within header_len? no\n-> header bytes (hex, first 7): 55 70 67 72 61 64 65\n-> content contains NUL within content_len? no\n-> content bytes (hex, first 20): 48 65 6c 6c 6f 20 57 6f 72 6c 64 20 \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The posted add_response_entry_n implementation does not call strlen; it uses memchr(header, ..., header_len) and memchr(content, ..., content_len). Under MISRA Rule 21.17 the string.h functions are allowed provided they do not access beyond the bounds of the objects pointed to. memchr is being used with explicit lengths, so it only accesses the header/content bytes up to the supplied lengths \u2014 which is compliant if the pointer/length pairs are valid. The agent's scenario complains about a strlen reading past the object bounds; that does not occur in the shown function. The provided test log shows header and content pointers are non-NULL and that no NUL was found within the given lengths, so the memchr calls operate within the supplied bounds. Therefore the claimed violation (due to strlen) is not supported by the shown code and test output."
}