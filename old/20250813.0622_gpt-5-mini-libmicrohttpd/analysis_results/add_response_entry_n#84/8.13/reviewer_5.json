{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The member is declared as a pointer to mutable MHD_iovec_ (\"MHD_iovec_ *data_iov;\"). If the iovec entries are intended to be read-only (buffers supplied by the caller that the implementation does not modify), the pointer should point to a const-qualified type (e.g. \"const MHD_iovec_ *data_iov\"). Because the declaration lacks the const qualification when it could/should be const, this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/675.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\nstatic void\nlog_dump_buffer (const char *label, const char *buf, size_t len)\n{\n  size_t i;\n  size_t to_print = (len < 64u) ? len : 64u; /* limit output */\n  if (buf == NULL)\n    {\n      log_probe (\"%s: NULL (len=%zu)\", label, len);\n      return;\n    }\n  log_probe (\"%s: address=%p len=%zu (first %zu bytes)\", label, (void *)buf, len, to_print);\n  {\n    char hex[3 * 64 + 1];\n    char asc[64 + 1];\n    size_t posh = 0;\n    for (i = 0; i < to_print; ++i)\n      {\n        unsigned char c = (unsigned char) buf[i];\n        if (posh + 3 < sizeof (hex))\n          {\n            int rc = snprintf (&hex[posh], sizeof (hex) - posh, \"%02x \", c);\n            if (rc > 0)\n              posh += (size_t) rc;\n          }\n        asc[i] = (c >= 32 && c <= 126) ? (char) c : '.';\n      }\n    hex[posh] = '\\0';\n    asc[to_print] = '\\0';\n    log_probe (\"%s HEX: %s\", label, hex);\n    log_probe (\"%s ASCII: %s\", label, asc);\n  }\n}\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  /* Log entry and parameter state */\n  log_probe (\"enter add_response_entry_n: response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu\",\n             (void *) response, (int) kind, (void *) header, header_len, (void *) content, content_len);\n\n  if (NULL == response)\n    {\n      log_probe (\"reject: response is NULL\");\n      return false;\n    }\n  if (0 == header_len)\n    {\n      log_probe (\"reject: header_len is 0\");\n      return false;\n    }\n  if (0 == content_len)\n    {\n      log_probe (\"reject: content_len is 0\");\n      return false;\n    }\n\n  /* Log a small portion of buffers to help reproduce caller state. */\n  log_dump_buffer (\"header\", header, header_len);\n  log_dump_buffer (\"content\", content, content_len);\n\n  const void *p_check = NULL;\n\n  p_check = memchr (header, '\\t', header_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: header contains tab at offset %td\", (const char *) p_check - header);\n      return false;\n    }\n  p_check = memchr (header, ' ', header_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: header contains space at offset %td\", (const char *) p_check - header);\n      return false;\n    }\n  p_check = memchr (header, '\\r', header_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: header contains CR at offset %td\", (const char *) p_check - header);\n      return false;\n    }\n  p_check = memchr (header, '\\n', header_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: header contains LF at offset %td\", (const char *) p_check - header);\n      return false;\n    }\n  p_check = memchr (content, '\\r', content_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: content contains CR at offset %td\", (const char *) p_check - content);\n      return false;\n    }\n  p_check = memchr (content, '\\n', content_len);\n  if (NULL != p_check)\n    {\n      log_probe (\"reject: content contains LF at offset %td\", (const char *) p_check - content);\n      return false;\n    }\n\n  log_probe (\"passing validation checks, invoking MHD_add_response_entry_no_check_\\n  response=%p kind=%d header=%p header_len=%zu content=%p content_len=%zu\",\n             (void *) response, (int) kind, (void *) header, header_len, (void *) content, content_len);\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a2130b0 content_len=8\nheader: address=0x559a1a2130b9 len=13 (first 13 bytes)\nheader HEX: 48 65 61 64 65 72 2d 54 79 70 65 2d 41 \nheader ASCII: Header-Type-A\ncontent: address=0x559a1a2130b0 len=8 (first 8 bytes)\ncontent HEX: 76 61 6c 75 65 2d 61 31 \ncontent ASCII: value-a1\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a2130b0 content_len=8\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a2130de content_len=8\nheader: address=0x559a1a2130b9 len=13 (first 13 bytes)\nheader HEX: 48 65 61 64 65 72 2d 54 79 70 65 2d 41 \nheader ASCII: Header-Type-A\ncontent: address=0x559a1a2130de len=8 (first 8 bytes)\ncontent HEX: 76 61 6c 75 65 2d 61 32 \ncontent ASCII: value-a2\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a2130de content_len=8\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a213118 content_len=8\nheader: address=0x559a1a2130b9 len=13 (first 13 bytes)\nheader HEX: 48 65 61 64 65 72 2d 54 79 70 65 2d 41 \nheader ASCII: Header-Type-A\ncontent: address=0x559a1a213118 len=8 (first 8 bytes)\ncontent HEX: 76 61 6c 75 65 2d 61 33 \ncontent ASCII: value-a3\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a2130b9 header_len=13 content=0x559a1a213118 content_len=8\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a213b9b header_len=4 content=0x559a1a213b7d content_len=29\nheader: address=0x559a1a213b9b len=4 (first 4 bytes)\nheader HEX: 44 61 74 65 \nheader ASCII: Date\ncontent: address=0x559a1a213b7d len=29 (first 29 bytes)\ncontent HEX: 57 65 64 2c 20 30 31 20 41 70 72 20 32 30 31 35 20 30 30 3a 30 30 3a 30 30 20 47 4d 54 \ncontent ASCII: Wed, 01 Apr 2015 00:00:00 GMT\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a213b9b header_len=4 content=0x559a1a213b7d content_len=29\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a213b9b header_len=4 content=0x559a1a213be0 content_len=29\nheader: address=0x559a1a213b9b len=4 (first 4 bytes)\nheader HEX: 44 61 74 65 \nheader ASCII: Date\ncontent: address=0x559a1a213be0 len=29 (first 29 bytes)\ncontent HEX: 54 68 75 2c 20 30 31 20 41 70 72 20 32 30 32 31 20 30 30 3a 30 30 3a 30 30 20 47 4d 54 \ncontent ASCII: Thu, 01 Apr 2021 00:00:00 GMT\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a213b9b header_len=4 content=0x559a1a213be0 content_len=29\nenter add_response_entry_n: response=0x559a52e8c2a0 kind=1 header=0x559a1a213c66 header_len=17 content=0x559a1a213c5e content_len=7\nheader: address=0x559a1a213c66 len=17 (first 17 bytes)\nheader HEX: 54 72 61 6e 73 66 65 72 2d 45 6e 63 6f 64 69 6e 67 \nheader ASCII: Transfer-Encoding\ncontent: address=0x559a1a213c5e len=7 (first 7 bytes)\ncontent HEX: 63 68 75 6e 6b 65 64 \ncontent ASCII: chunked\npassing validation checks, invoking MHD_add_response_entry_no_check_\n  response=0x559a52e8c2a0 kind=1 header=0x559a1a213c66 header_len=17 content=0x559a1a213c5e content_len=7\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The add_response_entry_n function already uses const-qualified pointer parameters for the buffers (const char *header, const char *content) and all local uses preserve const (p_check is declared const void * and memchr is used only to inspect the buffers). The agent's scenario refers to a separate member (MHD_iovec_ *data_iov) that does not appear in the shown function; nothing in the provided code demonstrates a pointer that should be const but is not. Therefore the claimed violation of MISRA C 2023 Rule 8.13 is not supported by the provided evidence."
}