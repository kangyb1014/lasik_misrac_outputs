{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_DLOG",
    "mhd_assert",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_EBADF_",
    "HAVE_SENDMSG",
    "HAVE_WRITEV",
    "MHD_WINSOCK_SOCKETS",
    "MHD_USE_MSG_MORE",
    "MSG_NOSIGNAL_OR_ZERO",
    "_MHD_IOV_MAX",
    "EPOLL_SUPPORT",
    "enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY",
    "struct MHD_Connection (definition of fields used: daemon, socket_fd, state, epoll_state)",
    "definition of daemon->options (type and constants such as MHD_USE_TLS)",
    "struct MHD_iovec_track_ (fields: cnt, sent, iov and type of iov elements)",
    "definition of iov element type (struct iovec or WSABUF / LPWSABUF)",
    "ssize_t",
    "size_t",
    "uint8_t",
    "MHD_iov_size_",
    "DWORD",
    "LPWSABUF",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "MHD_ERR_* return-code macros (e.g. MHD_ERR_NOTCONN_, MHD_ERR_AGAIN_, ...)"
  ],
  "explanation": "To decide whether send_iov_nontls uses any compiler language extensions (MISRA rule check) you must inspect any identifiers that might be macros, inline functions, typedefs or definitions that could hide extensions (GCC/Clang/MSVC-specific attributes, statement-expressions, typeof, __declspec, asm, variadic extensions, nonstandard builtins, etc.). The listed symbols are required because:\n\n- pre_send_setopt, post_send_setopt, MHD_DLOG, mhd_assert: these may be implemented as macros, inline functions or wrappers that commonly use compiler extensions (e.g. __attribute__, GNU statement-expr ({ ... }), variadic macro tricks). Their definitions are needed to see whether they use nonstandard language features.\n\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_*, and related MHD_SCKT_E* constants: these are macros/functions used in error checking. Macro implementations often use compiler extensions (statement expressions, typeof, builtin functions). Their expansions must be checked.\n\n- HAVE_SENDMSG, HAVE_WRITEV, MHD_WINSOCK_SOCKETS, MHD_USE_MSG_MORE, MSG_NOSIGNAL_OR_ZERO, _MHD_IOV_MAX, EPOLL_SUPPORT, _WIN64: these conditional macros control different code paths. Some may be predefined by compilers or build systems and might enable use of platform-specific constructs or compiler-specific flags. You need to know their definitions to determine whether selected branches introduce extensions.\n\n- enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY: the enum/bitfield definitions must be inspected in case they use implementation-defined or compiler-specific attributes or bitfield-width extensions.\n\n- struct MHD_Connection and daemon->options: the connection and daemon field types (and any attributes on them) must be known because the code uses these fields and they might be declared with compiler-specific extensions (packed, aligned, __attribute__ or __declspec) or use nonstandard types.\n\n- struct MHD_iovec_track_, the iov element type (struct iovec or WSABUF/LPWSABUF) and MHD_iov_size_: iov-related types/definitions control pointer arithmetic and casts in the function. Their definitions may use platform-specific types or macros that are compiler extensions (e.g. Windows WSABUF differs from POSIX iovec, or the project may define iov as a nonstandard type).\n\n- ssize_t, size_t, uint8_t, DWORD, LPWSABUF: these typedefs must be verified to be standard typedefs and not compiler-provided nonstandard aliases or macros that hide extensions.\n\n- MHD_INVALID_SOCKET, MHD_CONNECTION_CLOSED and the MHD_ERR_* return-code macros: these constants/macros could be implemented in a way that uses compiler extensions; also the exact values can affect which branches are compiled.\n\nIn short, any identifier that might be a macro, typedef or inline function must be inspected to ensure its definition does not rely on compiler-specific language extensions. The above list includes the minimal set of symbols referenced directly in send_iov_nontls whose definitions could hide such extensions."
}