{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the branch when _MHD_IOV_MAX < items_to_send the code executes `push_data = false;`. push_data is a function parameter (a value parameter) and assigning to it modifies the parameter; therefore this violates MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/645.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  /* Log entry and initial state */\n  mhd_probe_log (\"enter send_iov_nontls: connection=%p, r_iov=%p, push_data=%d\", (void *) connection, (void *) r_iov, (int) push_data);\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    mhd_probe_log (\"early return: invalid socket or connection closed: socket_fd=%ld, state=%d\", (long) connection->socket_fd, (int) connection->state);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  mhd_probe_log (\"computed items_to_send=%zu (cnt=%zu, sent=%zu)\", items_to_send, r_iov->cnt, r_iov->sent);\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n    {\n      mhd_probe_log (\"_MHD_IOV_MAX == 0, unexpected - returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    mhd_probe_log (\"_MHD_IOV_MAX (%d) < items_to_send (%zu): will limit items_to_send to _MHD_IOV_MAX and set push_data=false\", _MHD_IOV_MAX, items_to_send);\n    items_to_send = _MHD_IOV_MAX;\n\n    /* Capture the moment push_data (a function parameter) is modified: this is the reported violation scenario. */\n    mhd_probe_log (\"before modifying push_data: push_data=%d\", (int) push_data);\n    push_data = false; /* Incomplete response */\n    mhd_probe_log (\"after modifying push_data: push_data=%d\", (int) push_data);\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    /* Log the adjustment and record the parameter change */\n    mhd_probe_log (\"items_to_send (%zu) > UINT32_MAX: set cnt_w=UINT32_MAX and push_data=false\", items_to_send);\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    mhd_probe_log (\"send result negative: res=%zd, err=%d\", res, err);\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      mhd_probe_log (\"all iov entries sent: cnt=%zu, sent=%zu; calling post_send_setopt with push_data=%d\", r_iov->cnt, r_iov->sent, (int) push_data);\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        mhd_probe_log (\"partial send: updated iov[%zu].iov_base and iov_len=%zu\", r_iov->sent, (size_t) r_iov->iov[r_iov->sent].iov_len);\n      }\n    }\n  }\n\n  mhd_probe_log (\"exit send_iov_nontls: res=%zd, final sent=%zu, push_data=%d\", res, r_iov->sent, (int) push_data);\n  return res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for send_iov_nontls. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters; only the objects referred to by pointer parameters may be modified, not value parameters themselves. In the provided send_iov_nontls implementation the parameter push_data (a value parameter of type bool) is assigned to in at least two places (the _MHD_IOV_MAX branch: push_data = false; and the _WIN64 branch: push_data = false;). Those assignments modify the function parameter and therefore violate Rule 17.8. The fact the code compiles or that runtime logs are empty does not change that this is a static rule violation. A common remediation is to copy the parameter to a local variable (e.g. bool local_push = push_data;) and modify the local variable instead."
}