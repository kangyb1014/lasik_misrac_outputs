{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Two instances of dead code are present in the fragment. 1) The construct \"if (1) { ... }\" is a constant-true conditional: the condition evaluation is executed but has no effect \u2014 removing the if (1) (i.e. making the block unconditional) does not change program behaviour, so the conditional test is dead code. 2) The mhd_assert(...) calls expand (per the provided macros) to ((void)0) and therefore are executed as no-ops; these statements can be removed without changing behaviour and thus constitute dead code. Both cases meet the Rule 2.2 definition (operations that are executed but whose removal would not affect program behaviour).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/642.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fflush(f);\n  fclose(f);\n}\n\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  /* Log entry and some visible state */\n  probe_log(\"ENTER send_iov_nontls: connection=%p socket_fd=%d state=%d r_iov=%p cnt=%zu sent=%zu push=%d\",\n            (void *) connection,\n            (int) connection->socket_fd,\n            (int) connection->state,\n            (void *) r_iov,\n            (size_t) r_iov->cnt,\n            (size_t) r_iov->sent,\n            (int) push_data);\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n  probe_log(\"mhd_assert(top): evaluated (may be a no-op if compiled out)\");\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    probe_log(\"early return: invalid socket or closed: socket_fd=%d state=%d\",\n              (int) connection->socket_fd,\n              (int) connection->state);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  probe_log(\"computed items_to_send=%zu (cnt=%zu - sent=%zu)\",\n            items_to_send, (size_t) r_iov->cnt, (size_t) r_iov->sent);\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    probe_log(\"_MHD_IOV_MAX triggered: _MHD_IOV_MAX=%d items_to_send=%zu\",\n              (int) _MHD_IOV_MAX, items_to_send);\n    mhd_assert (0 < _MHD_IOV_MAX);\n    probe_log(\"mhd_assert(_MHD_IOV_MAX): evaluated (may be a no-op if compiled out)\");\n    if (0 == _MHD_IOV_MAX)\n    {\n      probe_log(\"_MHD_IOV_MAX == 0: returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n    probe_log(\"adjusted items_to_send=%zu push_data=%d\",\n              items_to_send, (int) push_data);\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling sendmsg: socket_fd=%d iovlen=%zu push_data=%d\",\n            (int) connection->socket_fd, (size_t) msg.msg_iovlen, (int) push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling writev: socket_fd=%d items_to_send=%zu push_data=%d\",\n            (int) connection->socket_fd, items_to_send, (int) push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling WSASend: socket_fd=%d cnt_w=%u push_data=%d\",\n            (int) connection->socket_fd, (unsigned) cnt_w, (int) push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  probe_log(\"send result res=%zd\", res);\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n    probe_log(\"send returned negative, socket error=%d\", err);\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      probe_log(\"EAGAIN -> returning MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      probe_log(\"EINTR -> returning MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      probe_log(\"REMOTE_DISCONNECT -> returning MHD_ERR_CONNRESET_\");\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      probe_log(\"EPIPE -> returning MHD_ERR_PIPE_\");\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      probe_log(\"EOPNOTSUPP -> returning MHD_ERR_OPNOTSUPP_\");\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      probe_log(\"ENOTCONN -> returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      probe_log(\"EINVAL -> returning MHD_ERR_INVAL_\");\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      probe_log(\"LOW_RESOURCES -> returning MHD_ERR_NOMEM_\");\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      probe_log(\"EBADF -> returning MHD_ERR_BADF_\");\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    probe_log(\"Other socket error -> returning MHD_ERR_NOTCONN_\");\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  /* The following if is a constant-true conditional in the original code. */\n  probe_log(\"about to evaluate constant-true conditional: if (1) - entering block\");\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    probe_log(\"track_sent initial=%zu\", track_sent);\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      probe_log(\"while loop: before iteration sent_index=%zu iov_len=%zu track_sent=%zu\",\n                (size_t) r_iov->sent,\n                (size_t) r_iov->iov[r_iov->sent].iov_len,\n                track_sent);\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      probe_log(\"while loop: after iteration sent_index=%zu track_sent=%zu\",\n                (size_t) r_iov->sent, track_sent);\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n      probe_log(\"mhd_assert(in-loop): evaluated (may be a no-op if compiled out)\");\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      probe_log(\"all iov elements sent: cnt=%zu sent=%zu -> calling post_send_setopt\",\n                (size_t) r_iov->cnt, (size_t) r_iov->sent);\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        probe_log(\"partial send: remaining track_sent=%zu sent_index=%zu\",\n                  track_sent, (size_t) r_iov->sent);\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        probe_log(\"mhd_assert(partial-send): evaluated (may be a no-op if compiled out)\");\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        probe_log(\"adjusted current iov: new_iov_base=%p new_iov_len=%zu\",\n                  r_iov->iov[r_iov->sent].iov_base,\n                  (size_t) r_iov->iov[r_iov->sent].iov_len);\n      }\n    }\n  }\n\n  probe_log(\"EXIT send_iov_nontls: returning res=%zd\", res);\n  return res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for send_iov_nontls. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Summary judgement: the report is not correct. Reasoning:\n\n1) The if (1) construct\n- MISRA C 2023 Rule 2.2 targets operations that are executed but whose removal would not affect program behaviour. In the source the if (1) is a constant conditional; the body of the if is reachable and executed at runtime (so the body is not dead). The boolean constant '1' itself is a compile-time constant expression; a conforming compiler will not generate a runtime test for it. In other words there is no executed operation (a runtime test) whose removal would leave behaviour unchanged \u2014 the statements inside the block are executed and are not dead. Removing the if wrapper (making the block unconditional) does not change program behaviour at the source level either, but MISRA\u2019s notion of dead code is about executed operations that could be removed without affecting behaviour; the constant conditional expression does not constitute an executed operation in the produced executable and is a redundant compile-time construct rather than \u201cdead code\u201d as intended by Rule 2.2.\n\n2) The mhd_assert(...) calls that expand to ((void)0)\n- These expand to a no-op expression statement in some build configurations. They are commonly used as a diagnostic macro that is active in some builds and inactive (expands to (void)0) in others. While an expression-statement of the form ((void)0) has no effect, MISRA 2.2 is concerned with code that is executed and could be removed without affecting behaviour; a no-op macro expansion is not the kind of substantive dead code the rule is intended to prevent. Moreover, many projects rely on assertion macros that are defined away in production builds; MISRA guidance is normally applied with awareness of configuration-dependent macros. If a particular project configuration leaves a large number of no-op statements and a static tool flags them as \u201credundant\u201d, that is a different (style/redundancy) issue, not the Rule 2.2 semantic dead-code problem.\n\nPractical note: static-analysis tools may still report the constant-true conditional or no-op assertion expansions as warnings (redundant code / unreachable branch / constant condition). If you want to silence such warnings or make the intent clearer for reviewers, remove the artificial if (1) or document it (or avoid leaving assertions compiled out in builds that are being checked). But strictly speaking under MISRA C 2023 Rule 2.2 as worded, the two items cited by agent A do not constitute Rule 2.2 violations.\n"
}