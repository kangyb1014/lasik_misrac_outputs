{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nTwo instances of dead code are present in the fragment. 1) The construct \"if (1) { ... }\" is a constant-true conditional: the condition evaluation is executed but has no effect \u2014 removing the if (1) (i.e. making the block unconditional) does not change program behaviour, so the conditional test is dead code. 2) The mhd_assert(...) calls expand (per the provided macros) to ((void)0) and therefore are executed as no-ops; these statements can be removed without changing behaviour and thus constitute dead code. Both cases meet the Rule 2.2 definition (operations that are executed but whose removal would not affect program behaviour).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified send_iov_nontls code that contains useful probe functions that print useful logs to a file \"/tmp/logs/642.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of send_iov_nontls as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of send_iov_nontls:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\nPlease provide the modified send_iov_nontls code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe logging helper -- append-only so it doesn't alter control flow */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/642.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fflush(f);\n  fclose(f);\n}\n\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  /* Log entry and some visible state */\n  probe_log(\"ENTER send_iov_nontls: connection=%p socket_fd=%d state=%d r_iov=%p cnt=%zu sent=%zu push=%d\",\n            (void *) connection,\n            (int) connection->socket_fd,\n            (int) connection->state,\n            (void *) r_iov,\n            (size_t) r_iov->cnt,\n            (size_t) r_iov->sent,\n            (int) push_data);\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n  probe_log(\"mhd_assert(top): evaluated (may be a no-op if compiled out)\");\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    probe_log(\"early return: invalid socket or closed: socket_fd=%d state=%d\",\n              (int) connection->socket_fd,\n              (int) connection->state);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  probe_log(\"computed items_to_send=%zu (cnt=%zu - sent=%zu)\",\n            items_to_send, (size_t) r_iov->cnt, (size_t) r_iov->sent);\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    probe_log(\"_MHD_IOV_MAX triggered: _MHD_IOV_MAX=%d items_to_send=%zu\",\n              (int) _MHD_IOV_MAX, items_to_send);\n    mhd_assert (0 < _MHD_IOV_MAX);\n    probe_log(\"mhd_assert(_MHD_IOV_MAX): evaluated (may be a no-op if compiled out)\");\n    if (0 == _MHD_IOV_MAX)\n    {\n      probe_log(\"_MHD_IOV_MAX == 0: returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n    probe_log(\"adjusted items_to_send=%zu push_data=%d\",\n              items_to_send, (int) push_data);\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling sendmsg: socket_fd=%d iovlen=%zu push_data=%d\",\n            (int) connection->socket_fd, (size_t) msg.msg_iovlen, (int) push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling writev: socket_fd=%d items_to_send=%zu push_data=%d\",\n            (int) connection->socket_fd, items_to_send, (int) push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  probe_log(\"calling WSASend: socket_fd=%d cnt_w=%u push_data=%d\",\n            (int) connection->socket_fd, (unsigned) cnt_w, (int) push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  probe_log(\"send result res=%zd\", res);\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n    probe_log(\"send returned negative, socket error=%d\", err);\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      probe_log(\"EAGAIN -> returning MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      probe_log(\"EINTR -> returning MHD_ERR_AGAIN_\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      probe_log(\"REMOTE_DISCONNECT -> returning MHD_ERR_CONNRESET_\");\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      probe_log(\"EPIPE -> returning MHD_ERR_PIPE_\");\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      probe_log(\"EOPNOTSUPP -> returning MHD_ERR_OPNOTSUPP_\");\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      probe_log(\"ENOTCONN -> returning MHD_ERR_NOTCONN_\");\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      probe_log(\"EINVAL -> returning MHD_ERR_INVAL_\");\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      probe_log(\"LOW_RESOURCES -> returning MHD_ERR_NOMEM_\");\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      probe_log(\"EBADF -> returning MHD_ERR_BADF_\");\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    probe_log(\"Other socket error -> returning MHD_ERR_NOTCONN_\");\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  /* The following if is a constant-true conditional in the original code. */\n  probe_log(\"about to evaluate constant-true conditional: if (1) - entering block\");\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    probe_log(\"track_sent initial=%zu\", track_sent);\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      probe_log(\"while loop: before iteration sent_index=%zu iov_len=%zu track_sent=%zu\",\n                (size_t) r_iov->sent,\n                (size_t) r_iov->iov[r_iov->sent].iov_len,\n                track_sent);\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      probe_log(\"while loop: after iteration sent_index=%zu track_sent=%zu\",\n                (size_t) r_iov->sent, track_sent);\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n      probe_log(\"mhd_assert(in-loop): evaluated (may be a no-op if compiled out)\");\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      probe_log(\"all iov elements sent: cnt=%zu sent=%zu -> calling post_send_setopt\",\n                (size_t) r_iov->cnt, (size_t) r_iov->sent);\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        probe_log(\"partial send: remaining track_sent=%zu sent_index=%zu\",\n                  track_sent, (size_t) r_iov->sent);\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        probe_log(\"mhd_assert(partial-send): evaluated (may be a no-op if compiled out)\");\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        probe_log(\"adjusted current iov: new_iov_base=%p new_iov_len=%zu\",\n                  r_iov->iov[r_iov->sent].iov_base,\n                  (size_t) r_iov->iov[r_iov->sent].iov_len);\n      }\n    }\n  }\n\n  probe_log(\"EXIT send_iov_nontls: returning res=%zd\", res);\n  return res;\n}\n"
}