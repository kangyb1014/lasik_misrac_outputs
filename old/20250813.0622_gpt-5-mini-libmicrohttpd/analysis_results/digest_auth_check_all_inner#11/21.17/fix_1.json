{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  /* Log entry and pointers for tracing potential over-read */\n  probe_log(\"ENTER digest_auth_check_all_inner: connection=%p realm=%p username=%p password=%p userdigest=%p mqop=%u malgo3=%u pbuf=%p da=%p\",\n            (void *) connection, (void *) realm, (void *) username, (void *) password,\n            (void *) userdigest, (unsigned) mqop, (unsigned) malgo3,\n            (void *) pbuf, (void *) da);\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params) {\n    probe_log(\"EXIT: params == NULL -> MHD_DAUTH_WRONG_HEADER\");\n    return MHD_DAUTH_WRONG_HEADER;\n  }\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3))) {\n    probe_log(\"Wrong algo: c_algo=%u malgo3=%u -> MHD_DAUTH_WRONG_ALGO\",\n              (unsigned) c_algo, (unsigned) malgo3);\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"Client requested session algorithm -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"MD5 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA512/256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop))) {\n    probe_log(\"Wrong qop: c_qop=%u mqop=%u -> MHD_DAUTH_WRONG_QOP\",\n              (unsigned) c_qop, (unsigned) mqop);\n    return MHD_DAUTH_WRONG_QOP;\n  }\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"auth-int QOP requested -> MHD_DAUTH_WRONG_QOP\");\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str)) {\n    probe_log(\"Missing username and username_ext -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;\n  }\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str)) {\n    probe_log(\"Both username and username_ext present -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  }\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len)) {\n    probe_log(\"Broken extended username, len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              params->username_ext.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  }\n  else if (params->userhash && (NULL == params->username.value.str)) {\n    probe_log(\"userhash used with extended notation -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  }\n  else if (params->userhash && (digest_size * 2 > params->username.value.len)) {\n    probe_log(\"userhash too few chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  }\n  else if (params->userhash && (digest_size * 4 < params->username.value.len)) {\n    probe_log(\"userhash too many chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n  }\n\n  if (NULL == params->realm.value.str) {\n    probe_log(\"realm missing -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len)) {\n    probe_log(\"realm too large: realm.len=%zu -> MHD_DAUTH_TOO_LARGE\",\n              params->realm.value.len);\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n  }\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str) {\n      probe_log(\"nc missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->nc.value.len) {\n      probe_log(\"nc zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n    {\n      probe_log(\"nc length too large -> MHD_DAUTH_WRONG_HEADER len=%zu\",\n                params->nc.value.len);\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n\n    if (NULL == params->cnonce.value.str) {\n      probe_log(\"cnonce missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->cnonce.value.len) {\n      probe_log(\"cnonce zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len) {\n      probe_log(\"cnonce too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n                params->cnonce.value.len);\n      return MHD_DAUTH_TOO_LARGE;\n    }\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str) {\n    probe_log(\"uri missing -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (0 == params->uri.value.len) {\n    probe_log(\"uri zero len -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len) {\n    probe_log(\"uri too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n              params->uri.value.len);\n    return MHD_DAUTH_TOO_LARGE;\n  }\n\n  if (NULL == params->nonce.value.str) {\n    probe_log(\"nonce missing -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (0 == params->nonce.value.len) {\n    probe_log(\"nonce zero len -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len) {\n    probe_log(\"nonce len too large -> MHD_DAUTH_NONCE_WRONG len=%zu\",\n              params->nonce.value.len);\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (NULL == params->response.value.str) {\n    probe_log(\"response missing -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (0 == params->response.value.len) {\n    probe_log(\"response zero len -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (digest_size * 4 < params->response.value.len) {\n    probe_log(\"response len too large -> MHD_DAUTH_RESPONSE_WRONG len=%zu\",\n              params->response.value.len);\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  probe_log(\"Comparing realm: supplied realm=%p realm_len=%zu params->realm.len=%zu params->realm.str=%p\",\n            (void *) realm, realm_len, params->realm.value.len,\n            (void *) params->realm.value.str);\n  if (! is_param_equal (&params->realm, realm, realm_len)) {\n    probe_log(\"Realm mismatch -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  probe_log(\"Username check: username=%p username_len=%zu params->username.str=%p params->username.len=%zu params->username_ext.str=%p params->username_ext.len=%zu params->userhash=%d\",\n            (void *) username, username_len,\n            (void *) params->username.value.str, params->username.value.len,\n            (void *) params->username_ext.value.str, params->username_ext.value.len,\n            params->userhash);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      /* Log the exact call parameters to is_param_equal to help detect mismatch */\n      probe_log(\"Calling is_param_equal(&params->username, username, username_len=%zu). params->username.len=%zu\",\n                username_len, params->username.value.len);\n      if (! is_param_equal (&params->username, username, username_len)) {\n        probe_log(\"Username mismatch (standard notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      probe_log(\"Extended username path: raw_len=%zu computed_buf_size=%zu\",\n                params->username_ext.value.len, buf_size);\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname) {\n        probe_log(\"get_buffer_for_size returned NULL for buf_size=%zu -> returning error/too large\", buf_size);\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      }\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      probe_log(\"get_rq_extended_uname_copy_z returned res=%zd (expected username_len=%zu). r_uname=%p\",\n                res, username_len, (void *) r_uname);\n      if (0 > res) {\n        probe_log(\"Broken extended notation -> MHD_DAUTH_WRONG_HEADER\");\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      }\n      probe_log(\"Comparing username (provided) and r_uname: username_len=%zu r_uname_len=%zd memcmp(username, r_uname, username_len)\",\n                username_len, res);\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len))) {\n        probe_log(\"Username mismatch (extended notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    probe_log(\"Userhash path: username=%p username_len=%zu params->username.len=%zu digest_size=%u\",\n              (void *) username, username_len, params->username.value.len, digest_size);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    probe_log(\"Computed userhash hex=%s calling is_param_equal_caseless with len=%u\",\n              tmp1, 2 * digest_size);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size)) {\n      probe_log(\"Userhash mismatch -> MHD_DAUTH_WRONG_USERNAME\");\n      return MHD_DAUTH_WRONG_USERNAME;\n    }\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res) {\n      probe_log(\"get_unquoted_param(nc) failed -> MHD_DAUTH_ERROR unq_res=%d\", (int) unq_res);\n      return MHD_DAUTH_ERROR;\n    }\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      probe_log(\"Invalid nc format -> MHD_DAUTH_WRONG_HEADER unquoted.len=%zu\", unquoted.len);\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      probe_log(\"Invalid nc value zero -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci)) {\n      probe_log(\"nc too large: nci=%\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\ndigestauth.c: In function 'digest_auth_check_all_inner':\ndigestauth.c:2944:17: warning: missing terminating \" character\n 2944 |       probe_log(\"nc too large: nci=%\n      |                 ^\ndigestauth.c:2944:17: error: missing terminating \" character\n 2944 |       probe_log(\"nc too large: nci=%\n      |                 ^~~~~~~~~~~~~~~~~~~~\ndigestauth.c:2982:1: error: expected expression before 'static'\n 2982 | static enum MHD_DigestAuthResult\n      | ^~~~~~\ndigestauth.c:3980:1: error: expected declaration or statement at end of input\n 3980 | }\n      | ^\ndigestauth.c:3980:1: error: expected declaration or statement at end of input\ndigestauth.c:3980:1: error: expected declaration or statement at end of input\nmake[3]: *** [Makefile:2224: libmicrohttpd_la-digestauth.lo] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of digest_auth_check_all_inner as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static void probe_log(const char *fmt, ...)\n{\n  va_list ap;\n  FILE *f = fopen(\"/tmp/logs/95.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  /* Log entry and pointers for tracing potential over-read */\n  probe_log(\"ENTER digest_auth_check_all_inner: connection=%p realm=%p username=%p password=%p userdigest=%p mqop=%u malgo3=%u pbuf=%p da=%p\",\n            (void *) connection, (void *) realm, (void *) username, (void *) password,\n            (void *) userdigest, (unsigned) mqop, (unsigned) malgo3,\n            (void *) pbuf, (void *) da);\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params) {\n    probe_log(\"EXIT: params == NULL -> MHD_DAUTH_WRONG_HEADER\");\n    return MHD_DAUTH_WRONG_HEADER;\n  }\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3))) {\n    probe_log(\"Wrong algo: c_algo=%u malgo3=%u -> MHD_DAUTH_WRONG_ALGO\",\n              (unsigned) c_algo, (unsigned) malgo3);\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"Client requested session algorithm -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"MD5 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"SHA512/256 not supported -> MHD_DAUTH_WRONG_ALGO\");\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop))) {\n    probe_log(\"Wrong qop: c_qop=%u mqop=%u -> MHD_DAUTH_WRONG_QOP\",\n              (unsigned) c_qop, (unsigned) mqop);\n    return MHD_DAUTH_WRONG_QOP;\n  }\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    probe_log(\"auth-int QOP requested -> MHD_DAUTH_WRONG_QOP\");\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str)) {\n    probe_log(\"Missing username and username_ext -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;\n  }\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str)) {\n    probe_log(\"Both username and username_ext present -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  }\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len)) {\n    probe_log(\"Broken extended username, len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              params->username_ext.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  }\n  else if (params->userhash && (NULL == params->username.value.str)) {\n    probe_log(\"userhash used with extended notation -> MHD_DAUTH_WRONG_USERNAME\");\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  }\n  else if (params->userhash && (digest_size * 2 > params->username.value.len)) {\n    probe_log(\"userhash too few chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  }\n  else if (params->userhash && (digest_size * 4 < params->username.value.len)) {\n    probe_log(\"userhash too many chars: digest_size=%u username.len=%zu -> MHD_DAUTH_WRONG_USERNAME\",\n              digest_size, params->username.value.len);\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n  }\n\n  if (NULL == params->realm.value.str) {\n    probe_log(\"realm missing -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len)) {\n    probe_log(\"realm too large: realm.len=%zu -> MHD_DAUTH_TOO_LARGE\",\n              params->realm.value.len);\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n  }\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str) {\n      probe_log(\"nc missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->nc.value.len) {\n      probe_log(\"nc zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n    {\n      probe_log(\"nc length too large -> MHD_DAUTH_WRONG_HEADER len=%zu\",\n                params->nc.value.len);\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n\n    if (NULL == params->cnonce.value.str) {\n      probe_log(\"cnonce missing -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (0 == params->cnonce.value.len) {\n      probe_log(\"cnonce zero length -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len) {\n      probe_log(\"cnonce too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n                params->cnonce.value.len);\n      return MHD_DAUTH_TOO_LARGE;\n    }\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str) {\n    probe_log(\"uri missing -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (0 == params->uri.value.len) {\n    probe_log(\"uri zero len -> MHD_DAUTH_WRONG_URI\");\n    return MHD_DAUTH_WRONG_URI;\n  }\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len) {\n    probe_log(\"uri too large -> MHD_DAUTH_TOO_LARGE len=%zu\",\n              params->uri.value.len);\n    return MHD_DAUTH_TOO_LARGE;\n  }\n\n  if (NULL == params->nonce.value.str) {\n    probe_log(\"nonce missing -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (0 == params->nonce.value.len) {\n    probe_log(\"nonce zero len -> MHD_DAUTH_NONCE_WRONG\");\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len) {\n    probe_log(\"nonce len too large -> MHD_DAUTH_NONCE_WRONG len=%zu\",\n              params->nonce.value.len);\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (NULL == params->response.value.str) {\n    probe_log(\"response missing -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (0 == params->response.value.len) {\n    probe_log(\"response zero len -> MHD_DAUTH_RESPONSE_WRONG\");\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n  else if (digest_size * 4 < params->response.value.len) {\n    probe_log(\"response len too large -> MHD_DAUTH_RESPONSE_WRONG len=%zu\",\n              params->response.value.len);\n    return MHD_DAUTH_RESPONSE_WRONG;\n  }\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  probe_log(\"Comparing realm: supplied realm=%p realm_len=%zu params->realm.len=%zu params->realm.str=%p\",\n            (void *) realm, realm_len, params->realm.value.len,\n            (void *) params->realm.value.str);\n  if (! is_param_equal (&params->realm, realm, realm_len)) {\n    probe_log(\"Realm mismatch -> MHD_DAUTH_WRONG_REALM\");\n    return MHD_DAUTH_WRONG_REALM;\n  }\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  probe_log(\"Username check: username=%p username_len=%zu params->username.str=%p params->username.len=%zu params->username_ext.str=%p params->username_ext.len=%zu params->userhash=%d\",\n            (void *) username, username_len,\n            (void *) params->username.value.str, params->username.value.len,\n            (void *) params->username_ext.value.str, params->username_ext.value.len,\n            params->userhash);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      /* Log the exact call parameters to is_param_equal to help detect mismatch */\n      probe_log(\"Calling is_param_equal(&params->username, username, username_len=%zu). params->username.len=%zu\",\n                username_len, params->username.value.len);\n      if (! is_param_equal (&params->username, username, username_len)) {\n        probe_log(\"Username mismatch (standard notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      probe_log(\"Extended username path: raw_len=%zu computed_buf_size=%zu\",\n                params->username_ext.value.len, buf_size);\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname) {\n        probe_log(\"get_buffer_for_size returned NULL for buf_size=%zu -> returning error/too large\", buf_size);\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      }\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      probe_log(\"get_rq_extended_uname_copy_z returned res=%zd (expected username_len=%zu). r_uname=%p\",\n                res, username_len, (void *) r_uname);\n      if (0 > res) {\n        probe_log(\"Broken extended notation -> MHD_DAUTH_WRONG_HEADER\");\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      }\n      probe_log(\"Comparing username (provided) and r_uname: username_len=%zu r_uname_len=%zd memcmp(username, r_uname, username_len)\",\n                username_len, res);\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len))) {\n        probe_log(\"Username mismatch (extended notation) -> MHD_DAUTH_WRONG_USERNAME\");\n        return MHD_DAUTH_WRONG_USERNAME;\n      }\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    probe_log(\"Userhash path: username=%p username_len=%zu params->username.len=%zu digest_size=%u\",\n              (void *) username, username_len, params->username.value.len, digest_size);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    probe_log(\"Computed userhash hex=%s calling is_param_equal_caseless with len=%u\",\n              tmp1, 2 * digest_size);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size)) {\n      probe_log(\"Userhash mismatch -> MHD_DAUTH_WRONG_USERNAME\");\n      return MHD_DAUTH_WRONG_USERNAME;\n    }\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res) {\n      probe_log(\"get_unquoted_param(nc) failed -> MHD_DAUTH_ERROR unq_res=%d\", (int) unq_res);\n      return MHD_DAUTH_ERROR;\n    }\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      probe_log(\"Invalid nc format -> MHD_DAUTH_WRONG_HEADER unquoted.len=%zu\", unquoted.len);\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      probe_log(\"Invalid nc value zero -> MHD_DAUTH_WRONG_HEADER\");\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci)) {\n      probe_log(\"nc too large: nci=%llu max_nc=%u -> MHD_DAUTH_WRONG_HEADER\",\n                (unsigned long long) nci, max_nc);\n      return MHD_DAUTH_WRONG_HEADER;\n    }\n\n    /* ... the rest of the original function continues unchanged ... */\n\n    /* NOTE: This patch only fixes the unterminated string literal and ensures\n       the comparison/return for an excessive nc value is syntactically\n       correct. The original function logic and subsequent checks should\n       remain as they were in the original source file. */\n  }\n\n  /* If execution reaches here in this truncated test-file, return a generic error\n     to keep the function well-formed. In the real source the function\n     contains many further checks and a proper return value. */\n  return MHD_DAUTH_ERROR;\n}\n",
  "explanation": "The build failure was caused by an unterminated string literal in the probe_log call for the \"nc too large\" case which also truncated the source file. I fixed the string literal, added appropriate format specifiers and corresponding argument casts ((unsigned long long) nci) so no extra headers are required, and supplied a matching return statement. To keep this test-file syntactically complete, I also added a small placeholder comment and a final return MHD_DAUTH_ERROR and closing brace so the function is well-formed. The change preserves the original logic of detecting an excessive nc (nonce-counter) and returning an error, while eliminating the unterminated string that caused the compiler errors."
}