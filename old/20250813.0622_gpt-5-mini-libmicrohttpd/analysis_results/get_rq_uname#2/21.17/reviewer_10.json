{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. The assignment uname_info->userhash_bin = (uint8_t *)(buf + buf_used) can lead to out\u2011of\u2011bounds accesses because there is no check that the remaining buffer (buf_size - buf_used) is large enough for the binary data that MHD_hex_to_bin will write. Example: after copying the hex string the code increments buf_used by userhash_hex_len + 1; if buf_size == userhash_hex_len + 1 (i.e. no room left for binary data) and the hex string decodes to at least one byte, uname_info->userhash_bin points at the buffer end and MHD_hex_to_bin will write into buf beyond buf_size, causing a buffer overflow. Therefore Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/23.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  mhd_log_probe(\"ENTER get_rq_uname: uname_type=%d buf_size=%zu\\n\",\n                (int) uname_type, buf_size);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    mhd_log_probe(\"STANDARD branch: username_len=%zu buf_used(before)=%zu\\n\",\n                  uname_info->username_len, buf_used);\n    buf_used += uname_info->username_len + 1;\n    mhd_log_probe(\"STANDARD branch: buf_used(after)=%zu\\n\", buf_used);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    mhd_log_probe(\"USERHASH branch: userhash_hex_len=%zu buf_used(before)=%zu buf_size=%zu\\n\",\n                  uname_info->userhash_hex_len, buf_used, buf_size);\n\n    buf_used += uname_info->userhash_hex_len + 1;\n\n    /* Log remaining space before assigning bin pointer */\n    mhd_log_probe(\"USERHASH branch: buf_used(after hex copy)=%zu remaining=%zu\\n\",\n                  buf_used,\n                  (buf_size > buf_used) ? (buf_size - buf_used) : 0);\n\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    mhd_log_probe(\"USERHASH branch: assigned userhash_bin at offset=%zu (ptr=%p)\\n\",\n                  buf_used, (void *) uname_info->userhash_bin);\n\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n\n    mhd_log_probe(\"USERHASH branch: MHD_hex_to_bin returned res=%zu expected=%zu\\n\",\n                  res, uname_info->userhash_hex_len / 2);\n\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      mhd_log_probe(\"USERHASH branch: hex decode length mismatch; marking invalid\\n\");\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n      {\n        mhd_log_probe(\"USERHASH branch: decoded size is zero; pointing userhash_bin to username ptr=%p\\n\",\n                      (void *) uname_info->username);\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      }\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      mhd_log_probe(\"USERHASH branch: buf_used(after adding bin)=%zu\\n\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    mhd_log_probe(\"EXTENDED branch: buf_used(before)=%zu buf_size=%zu\\n\",\n                  buf_used, buf_size);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n    {\n      mhd_log_probe(\"EXTENDED branch: get_rq_extended_uname_copy_z failed res=%zd\\n\", res);\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      mhd_log_probe(\"EXTENDED branch: username_len=%zu buf_used(after)=%zu\\n\",\n                    uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_log_probe(\"EXIT get_rq_uname: final buf_used=%zu buf_size=%zu uname_type=%d\\n\",\n                buf_used, buf_size, (int) uname_info->uname_type);\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A scenario correctly identifies a real out\u2011of\u2011bounds write risk in the code: after copying the hex string the function assigns uname_info->userhash_bin = buf + buf_used and then calls MHD_hex_to_bin without checking that (buf_size - buf_used) is large enough to hold the decoded binary (expected userhash_hex_len/2). Example: if buf_size == userhash_hex_len + 1 then buf_used becomes buf_size and there is no room for at least one decoded byte; MHD_hex_to_bin will then write past buf, causing a buffer overflow.\n\nHowever the MISRA rule quoted (21.17) specifically addresses the use of the standard string handling functions from <string.h> and requires that their use must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the snippet shown there is no direct use of any <string.h> function (memcpy/strcpy/strlen/etc.). The problematic call is to MHD_hex_to_bin (and the pointer arithmetic/assignment around it), which is an internal helper and not a standard <string.h> call. Therefore the concrete defect shown is a bounds/overflow bug, but it is not a direct violation of MISRA C 2023 Rule 21.17 as written (which targets standard <string.h> functions).\n\nConclusion: the report correctly finds a buffer-overflow risk in the code, but it misattributes that risk specifically to MISRA Rule 21.17. The code should be fixed (for example, check that buf_size - buf_used >= (uname_info->userhash_hex_len / 2) before assigning userhash_bin and calling MHD_hex_to_bin, or ensure MHD_hex_to_bin cannot write past the provided capacity)."
}