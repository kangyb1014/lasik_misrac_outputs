{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. In this translation unit mhd_assert is defined as #define mhd_assert(ignore) ((void)0). Thus the statement mhd_assert(buf_size >= used); is a no-op \u2014 it performs no action and has no side effects. Removing that statement would not change program behaviour, so it constitutes dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_logf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/18.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  /* Entry log */\n  mhd_logf (\"get_rq_uname ENTER: uname_type=%d, buf_size=%zu, params=%p, uname_info=%p, buf=%p\",\n            (int) uname_type, buf_size, (const void *) params,\n            (void *) uname_info, (void *) buf);\n\n  buf_used = 0;\n\n  /* Evaluate and log the assert conditions separately so callers can see\n     whether the conditions hold at runtime even if mhd_assert is a no-op. */\n  {\n    enum MHD_DigestAuthUsernameType actual_type = get_rq_uname_type (params);\n    int cond1 = (actual_type == uname_type) ? 1 : 0;\n    mhd_logf (\"assert-check: get_rq_uname_type(params)=%d, expected=%d, match=%d\",\n              (int) actual_type, (int) uname_type, cond1);\n    mhd_assert (get_rq_uname_type (params) == uname_type);\n  }\n  {\n    int cond2 = (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) ? 1 : 0;\n    mhd_logf (\"assert-check: uname_type != MHD_DIGEST_AUTH_UNAME_TYPE_INVALID -> %d\",\n              cond2);\n    mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  }\n  {\n    int cond3 = (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) ? 1 : 0;\n    mhd_logf (\"assert-check: uname_type != MHD_DIGEST_AUTH_UNAME_TYPE_MISSING -> %d\",\n              cond3);\n    mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n  }\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    mhd_logf (\"branch: STANDARD taken\");\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    mhd_logf (\"STANDARD: username_len=%zu\", uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    mhd_logf (\"STANDARD: buf_used=%zu\", buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    mhd_logf (\"branch: USERHASH taken\");\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    mhd_logf (\"USERHASH: userhash_hex_len=%zu\", uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    mhd_logf (\"USERHASH: MHD_hex_to_bin returned res=%zu\", res);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      mhd_logf (\"USERHASH: invalid hex length -> uname_type set to INVALID\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      mhd_logf (\"USERHASH: success -> buf_used=%zu, uname_type=USERHASH\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    mhd_logf (\"branch: EXTENDED taken\");\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    mhd_logf (\"EXTENDED: get_rq_extended_uname_copy_z returned res=%zd\", res);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      mhd_logf (\"EXTENDED: username_len=%zu, buf_used=%zu\",\n                uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    mhd_logf (\"branch: UNKNOWN uname_type=%d -> asserting(0)\", (int) uname_type);\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  /* Log buffer usage and the final assert condition before invoking the assert */\n  {\n    int cond_buf = (buf_size >= buf_used) ? 1 : 0;\n    mhd_logf (\"final-check: buf_size=%zu, buf_used=%zu, buf_size>=buf_used=%d\",\n              buf_size, buf_used, cond_buf);\n    mhd_assert (buf_size >= buf_used);\n    mhd_logf (\"after-final-assert: continuing to return buf_used=%zu\", buf_used);\n  }\n\n  mhd_logf (\"get_rq_uname EXIT: returning %zu\", buf_used);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s conclusion is correct given the stated facts. MISRA C 2023 Rule 2.2 defines dead code as any operation that is executed but whose removal would not affect program behaviour. With mhd_assert defined in that translation unit as\n  #define mhd_assert(ignore) ((void)0)\neach call such as mhd_assert(buf_size >= buf_used); expands to a no-op expression statement that has no side effects; removing that statement would not change the program\u2019s behaviour, so it meets the definition of dead code.\n\nA caveat: Rule 2.2 is a project-level rule. If mhd_assert is a no-op in this translation unit but is defined to have observable effects in other build configurations (or elsewhere in the project), then the assertion invocations may not be dead code at the project level. If, however, the macro is a no-op across the project (or in the configuration being analyzed), the calls are dead code and should be addressed (e.g. remove them, condition them consistently, or ensure the assertion macro produces an observable effect in the project configuration)."
}