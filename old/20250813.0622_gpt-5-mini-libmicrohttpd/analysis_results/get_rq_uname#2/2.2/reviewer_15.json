{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement mhd_assert (unif_buf_size >= unif_buf_used); expands to ((void)0) (mhd_assert is defined as a no-op). As written in the provided project, this produces no observable operation and its removal would not affect program behaviour, so it is dead code and violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_logf(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/18.txt\", \"a\");\n    if (f == NULL)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  /* Entry probe: do not evaluate assertions' expressions to avoid changing\n     program behaviour (mhd_assert is a no-op in the provided build). */\n  probe_logf(\"ENTER get_rq_uname: params=%p uname_type=%d buf_size=%zu buf=%p\",\n             (const void *) params, (int) uname_type, buf_size, (const void *) buf);\n  probe_logf(\"NOTE: mhd_assert(...) occurrences are present but NOT evaluated here to preserve behaviour.\");\n\n  buf_used = 0;\n  /* Original asserts are no-ops in the reported build; do not evaluate their expressions. */\n  probe_logf(\"ASSERT_PRESENT: get_rq_uname_type(params) == uname_type (not evaluated)\");\n  probe_logf(\"ASSERT_PRESENT: MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type (not evaluated)\");\n  probe_logf(\"ASSERT_PRESENT: MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type (not evaluated)\");\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    probe_logf(\"BRANCH: STANDARD (uname_type=%d)\", (int) uname_type);\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    probe_logf(\"AFTER get_rq_param_unquoted_copy_z: username_len=%zu\",\n               uname_info->username_len);\n    buf_used += uname_info->username_len + 1;\n    probe_logf(\"buf_used updated to %zu\", buf_used);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    probe_logf(\"BRANCH: USERHASH (uname_type=%d)\", (int) uname_type);\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    probe_logf(\"AFTER get_rq_param_unquoted_copy_z: userhash_hex_len=%zu\",\n               uname_info->userhash_hex_len);\n    buf_used += uname_info->userhash_hex_len + 1;\n    probe_logf(\"buf_used updated to %zu (after hex copy)\", buf_used);\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    probe_logf(\"MHD_hex_to_bin returned res=%zu (expected hex_len/2=%zu)\",\n               res, uname_info->userhash_hex_len / 2);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      probe_logf(\"USERHASH parse failed: setting userhash_bin=NULL and uname_type=INVALID\");\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n      {\n        probe_logf(\"USERHASH res==0: pointing userhash_bin to username to avoid OOB\");\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      }\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      probe_logf(\"USERHASH success: buf_used updated to %zu, uname_type=USERHASH\", buf_used);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    probe_logf(\"BRANCH: EXTENDED (uname_type=%d)\", (int) uname_type);\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    probe_logf(\"get_rq_extended_uname_copy_z returned res=%zd\", res);\n    if (0 > res)\n    {\n      probe_logf(\"EXTENDED parse failed: setting uname_type=INVALID\");\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      probe_logf(\"EXTENDED success: username_len=%zu buf_used=%zu\",\n                 uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    probe_logf(\"BRANCH: ELSE - unexpected uname_type=%d, asserting and marking INVALID (assert not evaluated)\",\n               (int) uname_type);\n    /* Original code had mhd_assert(0); but mhd_assert is a no-op; avoid evaluating it. */\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  probe_logf(\"FINAL_ASSERT_PRESENT: buf_size >= buf_used (not evaluated)\");\n  probe_logf(\"EXIT get_rq_uname: buf_used=%zu final_uname_type=%d username=%p username_len=%zu userhash_hex=%p userhash_hex_len=%zu userhash_bin=%p\",\n             buf_used,\n             (int) uname_info->uname_type,\n             (const void *) uname_info->username,\n             uname_info->username_len,\n             (const void *) uname_info->userhash_hex,\n             uname_info->userhash_hex_len,\n             (const void *) uname_info->userhash_bin);\n  return buf_used;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_uname. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. In the provided build mhd_assert is a no-op (expands to ((void)0)). Each mhd_assert(...) in the function therefore becomes an expression statement that does nothing when executed; removing those statements would not change the program's observable behaviour. According to MISRA C 2023 Rule 2.2 (\u201cA project shall not contain dead code\u201d), an executed operation whose removal would not affect program behaviour is dead code. The assertions as compiled in the reported configuration are reachable (not unreachable) and have no observable effect, so they meet the definition of dead code and violate Rule 2.2. (If mhd_assert were defined to perform checks or logging in the active build, or were entirely removed by the preprocessor so no expression statements remain, the situation would be different.)"
}