{
  "user_message": "An agent A claimed that the following get_rq_uname code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname.\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as ((void)0), so the statement mhd_assert (uname_type == uname_info->uname_type); expands to a no-op expression statement. That operation is executed (present in source) but its removal would not affect program behaviour, therefore it constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct MHD_String\n{\n  const char *str;\n  size_t len;\n};\nextern void mhd_assert (int condition);\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/18.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  /* Probing: record that the following assertion exists in source. Do not\n     attempt to call get_rq_uname_type(params) here because the reported\n     violation stems from mhd_assert being defined as a no-op; calling the\n     function during logging would introduce behavior that does not occur in\n     the original compiled binary when the macro expands to ((void)0). */\n  log_probe (\"ASSERT_PRESENT: get_rq_uname_type(params) == uname_type; (uname_type=%d)\", (int) uname_type);\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n\n  log_probe (\"ASSERT_PRESENT: MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type; (uname_type=%d)\", (int) uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n\n  log_probe (\"ASSERT_PRESENT: MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type; (uname_type=%d)\", (int) uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    log_probe (\"BRANCH: STANDARD; buf=%p buf_used=%zu buf_size=%zu params->username.len=%zu\",\n               (void *) buf, buf_used, buf_size, params ? params->username.value.len : 0);\n\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n\n    log_probe (\"RESULT: STANDARD: username_len=%zu buf_used=%zu\",\n               uname_info->username_len, buf_used);\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    log_probe (\"BRANCH: USERHASH; buf=%p buf_used=%zu params->username.len=%zu\",\n               (void *) buf, buf_used, params ? params->username.value.len : 0);\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    log_probe (\"USERHASH: userhash_hex_len=%zu res=%zu\",\n               uname_info->userhash_hex_len, res);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n      log_probe (\"USERHASH: invalid hex length; marked INVALID\");\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n      log_probe (\"USERHASH: valid; buf_used=%zu uname_type=%d\",\n                 buf_used, (int) uname_info->uname_type);\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    log_probe (\"BRANCH: EXTENDED; buf=%p buf_used=%zu buf_size=%zu ext_len=%zu\",\n               (void *) buf, buf_used, buf_size, params ? params->username_ext.value.len : 0);\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n      log_probe (\"EXTENDED: username_len=%zu buf_used=%zu\",\n                 uname_info->username_len, buf_used);\n    }\n  }\n  else\n  {\n    /* The original source contains mhd_assert (0); keep it, but also log its\n       presence and the value that caused fall-through into the default. */\n    log_probe (\"ASSERT_PRESENT: mhd_assert(0); reached default branch with uname_type=%d\", (int) uname_type);\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  log_probe (\"ASSERT_PRESENT: buf_size >= buf_used; buf_size=%zu buf_used=%zu\", buf_size, buf_used);\n  mhd_assert (buf_size >= buf_used);\n  log_probe (\"RETURN: buf_used=%zu uname_type=%d username_len=%zu userhash_hex_len=%zu\",\n             buf_used, (int) uname_info->uname_type, uname_info->username_len, uname_info->userhash_hex_len);\n  return buf_used;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct under the stated assumption. MISRA C 2023 Rule 2.2 forbids executed operations whose removal would not affect program behaviour. If mhd_assert is defined as ((void)0) then each mhd_assert(...) in get_rq_uname expands to a no-op expression statement that is executed (reachable) but has no effect; removing those statements would not change behaviour, so they constitute dead code and violate Rule 2.2. If, however, mhd_assert is defined to perform an action (log, abort, etc.), then the assertions are not dead and there is no violation. The correctness of the report therefore depends on the actual project definition of mhd_assert; given the agent's premise that it expands to ((void)0), the report is correct."
}