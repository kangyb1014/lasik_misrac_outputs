{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'keepalive_possible': {'callees': ['MHD_lookup_header_token_ci'], 'callers': ['setup_reply_properties']}, 'MHD_lookup_header_token_ci': {'callees': [], 'callers': ['keepalive_possible']}, 'setup_reply_properties': {'callees': ['keepalive_possible', 'is_reply_body_needed'], 'callers': ['build_header_response']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (definition)",
    "struct MHD_Response (definition)",
    "enum MHD_ConnKeepAlive and enumerators (MHD_CONN_MUST_CLOSE, MHD_CONN_MUST_UPGRADE, MHD_CONN_USE_KEEPALIVE)",
    "prototype/definition of MHD_lookup_header_s_token_ci (and the similarly named MHD_lookup_header_token_ci)",
    "mhd_assert macro/definition",
    "UPGRADE_SUPPORT preprocessor symbol/definition",
    "MHD_IS_HTTP_VER_SUPPORTED macro/inline/function",
    "MHD_IS_HTTP_VER_1_1_COMPAT macro/inline/function",
    "MHD_HTTP_VER_1_0 symbol/definition",
    "MHD_HTTP_HEADER_CONNECTION symbol/definition",
    "MHD_RF_HTTP_1_0_COMPATIBLE_STRICT flag definition",
    "MHD_RAF_HAS_CONNECTION_CLOSE flag definition",
    "MHD_RF_HTTP_1_0_SERVER flag definition",
    "type/definition of r->upgrade_handler (its function-pointer type)",
    "declarations/definitions of the above symbols including any attached attributes/annotations (e.g. __attribute__, __declspec, pragma)"
  ],
  "explanation": "For MISRA rule checking about language extensions you must inspect not only the target function text but also the definitions/expansions of the identifiers it uses, because extensions often appear in type declarations, macros or function prototypes. Why each symbol is needed:\n\n- struct MHD_Connection (definition): the function accesses many members (rp.response, keepalive, stop_with_error, discard_request, read_closed, rq.http_ver). The struct definition may use compiler extensions (bitfields with implementation-defined widths, packed/aligned attributes, anonymous structs/unions, flexible array members, or other non\u2011standard extensions) that would violate the rule.\n\n- struct MHD_Response (definition): members flags, flags_auto, upgrade_handler are read. Their types or declarations might include extensions (attributes, anonymous unions, nonstandard types or macros) or nonstandard storage-class/specifiers.\n\n- enum MHD_ConnKeepAlive and enumerators: need to verify these are standard enum constants (not implemented via nonstandard macros or extensions) and to check whether any unusual attributes are attached to the enum or its values.\n\n- prototype/definition of MHD_lookup_header_s_token_ci (and the similarly named MHD_lookup_header_token_ci): the call graph and code refer to this helper. Its declaration may use nonstandard function attributes (GNU attributes, asm labels), varargs, typeof in parameters, inline asm or other extensions that MISRA forbids.\n\n- mhd_assert macro/definition: assert macros often expand to compiler builtin functions, statement-expressions ({ ... }), or __extension__ usage. The expansion must be inspected for extensions.\n\n- UPGRADE_SUPPORT preprocessor symbol/definition: whether this macro is defined changes compiled code. Also its definition location may reveal use of nonstandard preprocessor extensions or conditional pragmas affecting use of extensions.\n\n- MHD_IS_HTTP_VER_SUPPORTED and MHD_IS_HTTP_VER_1_1_COMPAT (macros/inline functions): these are used as predicates. Their implementations may use extension constructs (statement-expression GCC ({ ... }), typeof, __builtin_expect, or other nonstandard constructs) or nonportable inline semantics.\n\n- MHD_HTTP_VER_1_0: the token compared against rq.http_ver; its definition may be an enum, macro, or other construct \u2014 may hide compiler extensions.\n\n- MHD_HTTP_HEADER_CONNECTION: used as a header name argument: its definition may use token-pasting, stringizing or other macros that rely on extensions.\n\n- MHD_RF_HTTP_1_0_COMPATIBLE_STRICT, MHD_RAF_HAS_CONNECTION_CLOSE, MHD_RF_HTTP_1_0_SERVER (flag definitions): flag macros may be defined via nonstandard constructs (e.g. complex computed expressions, typeof usage) or use attributes on bitfield declarations.\n\n- type/definition of r->upgrade_handler (function-pointer type): the handler's type declaration may use nonstandard calling-convention attributes (__stdcall, __attribute__((ms_abi)) etc.) or other extensions.\n\n- declarations/definitions of the above symbols including any attached attributes/annotations (e.g. __attribute__, __declspec, pragma): MISRA forbids use of language/compiler extensions such as __attribute__, pragmas that change language semantics, inline asm, nonstandard storage specifiers etc. To determine compliance you must inspect whether any of the used declarations carry such attributes or pragmas.\n\nIn short: the analysis must examine the concrete definitions/expansions of the structs, enums, macros and called functions used by keepalive_possible to detect any use of compiler or language extensions. The listed symbols are the minimal set whose definitions/expansions can hide such extensions."
}