{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The alias 'c' is declared as a constant pointer to a non-const object (struct MHD_Connection *const c). In keepalive_possible the code only reads fields via 'c' (accesses like c->rp.response, c->keepalive, c->rq.http_ver, c->stop_with_error, c->discard_request) and never modifies the pointee. Therefore the pointed-to type could and should be const-qualified (e.g. const struct MHD_Connection * const c). Declaring 'c' as non-const pointee violates MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', f);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n\n  /* Log initial relevant state (after the NULL check on r). */\n  mhd_log_probe (\"keepalive_possible: entry: connection=%p, c=%p, r=%p, c->keepalive=%u, r->flags=0x%08x, r->flags_auto=0x%08x, r->upgrade_handler=%p, rq.http_ver=%d, stop_with_error=%d, discard_request=%d, read_closed=%d\",\n                 (void *)connection,\n                 (void *)c,\n                 (void *)r,\n                 (unsigned)c->keepalive,\n                 (unsigned)r->flags,\n                 (unsigned)r->flags_auto,\n                 (void *)r->upgrade_handler,\n                 (int)c->rq.http_ver,\n                 (int)c->stop_with_error,\n                 (int)c->discard_request,\n                 (int)c->read_closed);\n\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_log_probe (\"keepalive_possible: early MUST_CLOSE because c->keepalive == MHD_CONN_MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    mhd_log_probe (\"keepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=%p)\", (void *)r->upgrade_handler);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE because read_closed=%d or discard_request=%d\", (int)c->read_closed, (int)c->discard_request);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE because r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT (flags=0x%08x)\", (unsigned)r->flags);\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE because r->flags_auto has CONNECTION_CLOSE (flags_auto=0x%08x)\", (unsigned)r->flags_auto);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE because !MHD_IS_HTTP_VER_SUPPORTED(rq.http_ver=%d)\", (int)c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE because Connection: close header present\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_log_probe (\"keepalive_possible: USE_KEEPALIVE for HTTP/1.0 because Keep-Alive header present\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_log_probe (\"keepalive_possible: MUST_CLOSE for HTTP/1.0 path (no Keep-Alive header)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_log_probe (\"keepalive_possible: USE_KEEPALIVE because HTTP/1.1 compatible (rq.http_ver=%d)\", (int)c->rq.http_ver);\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_log_probe (\"keepalive_possible: final MUST_CLOSE default\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nkeepalive_possible: entry: connection=0x5595189a2870, c=0x5595189a2870, r=0x5595189aab40, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x5595189ab500, c=0x5595189ab500, r=0x5595189ab750, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x5595189a2b10, c=0x5595189a2b10, r=0x5595189abd10, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4af4000b90, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4af4000b90, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4aec000b90, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4afc008f40, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4afc008f40, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4af8000b90, c=0x7f4af8000b90, r=0x7f4af8008e20, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4af8000b90, c=0x7f4af8000b90, r=0x7f4af8008e20, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4afc008f40, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd15cdc2, rq.http_ver=3, stop_with_error=0, discard_request=1, read_closed=0\nkeepalive_possible: MUST_UPGRADE because r->upgrade_handler != NULL (upgrade_handler=0x5594fd15cdc2)\nkeepalive_possible: entry: connection=0x7f4afc000b90, c=0x7f4afc000b90, r=0x7f4afc008f60, c->keepalive=0, r->flags=0x00000000, r->flags_auto=0x00000001, r->upgrade_handler=0x5594fd\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported. MISRA R8.13 encourages pointers to point to const-qualified types when that is feasible, but you must consider the declared types and the functions that consume those pointers. In this function the incoming parameter is declared as struct MHD_Connection *connection (a non-const pointer to a non-const object). The local alias struct MHD_Connection *const c merely makes the pointer itself const (it does not make the pointee const). Although this function only reads fields from the connection/r objects, you cannot unilaterally change the local alias to point to const (e.g. const struct MHD_Connection * const c) unless every use and every function called with that pointer accepts a pointer-to-const. Several calls in the function (for example MHD_lookup_header_s_token_ci) take the connection pointer; if their prototypes expect struct MHD_Connection * (non-const) then changing c to point-to-const would be incompatible. The provided runtime logs show only read accesses and outcomes but do not demonstrate a static-type violation of the rule. Therefore the agent A report (that this code violates MISRA C 2023 Rule 8.13) is not correct in this context."
}