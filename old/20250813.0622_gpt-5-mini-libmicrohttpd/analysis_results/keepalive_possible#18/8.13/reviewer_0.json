{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The local alias 'r' is declared as 'struct MHD_Response *const r = c->rp.response;' (a const pointer to a non-const object) but in the function it is only read (checks of r->upgrade_handler, r->flags_auto, r->flags). Because the pointed-to object is not modified via 'r', the pointer should be to a const-qualified type (e.g. 'const struct MHD_Response *const r') to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/147.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  /* Log entry and key state relevant to keepalive decision / violation scenario */\n  mhd_probe_log(\"keepalive_possible: enter connection=%p c=%p r=%p keepalive=%d read_closed=%d discard_request=%d rq.http_ver=%d rp.response.flags=0x%08lx rp.response.flags_auto=0x%08lx rp.response.upgrade_handler=%p stop_with_error=%d\",\n                (void *)connection,\n                (void *)c,\n                (void *)r,\n                (int)c->keepalive,\n                (int)c->read_closed,\n                (int)c->discard_request,\n                (int)c->rq.http_ver,\n                (unsigned long)r->flags,\n                (unsigned long)r->flags_auto,\n                (void *)r->upgrade_handler,\n                (int)c->stop_with_error);\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (c->keepalive)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* Log branch when upgrade handler is present */\n    mhd_probe_log(\"keepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=%p)\", (void *)r->upgrade_handler);\n\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    mhd_probe_log(\"keepalive_possible: decision=MUST_UPGRADE\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (read_closed=%d discard_request=%d)\", (int)c->read_closed, (int)c->discard_request);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT != 0)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (r->flags_auto has CONNECTION_CLOSE)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (HTTP version unsupported: rq.http_ver=%d)\", (int)c->rq.http_ver);\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  mhd_probe_log(\"keepalive_possible: checking header Connection: close\");\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (Connection: close header present)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    mhd_probe_log(\"keepalive_possible: HTTP/1.0 path (rq.http_ver=%d response->flags=0x%08lx)\", (int)connection->rq.http_ver, (unsigned long)connection->rp.response->flags);\n    mhd_probe_log(\"keepalive_possible: checking header Connection: Keep-Alive\");\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_probe_log(\"keepalive_possible: decision=USE_KEEPALIVE (Connection: Keep-Alive header present)\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (HTTP/1.0 and no Keep-Alive header)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_probe_log(\"keepalive_possible: decision=USE_KEEPALIVE (HTTP/1.1 compatible)\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_probe_log(\"keepalive_possible: decision=MUST_CLOSE (default)\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nkeepalive_possible: enter connection=0x5615454de870 c=0x5615454de870 r=0x5615454e6b40 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x5615454e7500 c=0x5615454e7500 r=0x5615454e7750 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x5615454deb10 c=0x5615454deb10 r=0x5615454e7d10 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b10000b90 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b0c000b90 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b0c000b90 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b08008f40 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b10001070 c=0x7f2b10001070 r=0x7f2b10000bc0 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b08008f40 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b0c000d90 c=0x7f2b0c000d90 r=0x7f2b0c000b70 keepalive=0 read_closed=0 discard_request=1 rq.http_ver=3 rp.response.flags=0x00000000 rp.response.flags_auto=0x00000001 rp.response.upgrade_handler=0x561520b17dc2 stop_with_error=0\nkeepalive_possible: upgrade_handler present -> upgrade (r->upgrade_handler=0x561520b17dc2)\nkeepalive_possible: decision=MUST_UPGRADE\nkeepalive_possible: enter connection=0x7f2b08000b90 c=0x7f2b08000b90 r=0x7f2b08008f40 \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In keepalive_possible the local alias r is only used for reads (accessing r->upgrade_handler, r->flags_auto, r->flags) and never used to modify the pointed-to MHD_Response object or passed to an API requiring a non-const pointer. According to MISRA C 2023 Rule 8.13, the pointer should point to a const-qualified type whenever possible. Therefore declaring r as const struct MHD_Response *const r = c->rp.response; would be the compliant form. The report that the original code violates Rule 8.13 is valid."
}