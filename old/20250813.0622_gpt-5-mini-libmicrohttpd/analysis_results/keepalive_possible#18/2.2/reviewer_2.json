{
  "user_message": "An agent A claimed that the following keepalive_possible code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of keepalive_possible.\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement mhd_assert(buf_size > pos); expands to ((void)0) via the provided macro definition, so it is a no-op at build time. Because the operation is executed but has no effect and removing it would not change the program behaviour, this constitutes dead code.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void keepalive_log_probe(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/146.txt\", \"a\");\n  if (!f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void keepalive_log_state(struct MHD_Connection *c,\n                                struct MHD_Response *r,\n                                const char *stage)\n{\n  keepalive_log_probe(\"[keepalive] %s: connection=%p response=%p\",\n                      stage, (void *)c, (void *)r);\n  if (c) {\n    keepalive_log_probe(\"  keepalive=%d read_closed=%d discard_request=%d stop_with_error=%d\",\n                        (int)c->keepalive,\n                        (int)c->read_closed,\n                        (int)c->discard_request,\n                        (int)c->stop_with_error);\n    /* rq and rp are expected to be present in the environment where this\n     * function is used; we log some commonly used fields (cast to int for\n     * safe printing). */\n    keepalive_log_probe(\"  rq.http_ver=%d\", (int)c->rq.http_ver);\n    if (c->rp.response)\n      keepalive_log_probe(\"  rp.response.flags=0x%08x flags_auto=0x%08x\",\n                          (unsigned int)c->rp.response->flags,\n                          (unsigned int)c->rp.response->flags_auto);\n    else\n      keepalive_log_probe(\"  rp.response=NULL\");\n  }\n}\nstatic void keepalive_log_decision(const char *decision)\n{\n  keepalive_log_probe(\"[keepalive] decision: %s\", decision);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  /* Log initial state and the value of the assertion expression so that\n   * other agents can determine whether the mhd_assert would have fired (in\n   * builds where it is active) or whether it is effectively a no-op. */\n  keepalive_log_state(c, r, \"entry\");\n  keepalive_log_probe(\"[keepalive] assert(NULL != r) -> %d\", (int)(NULL != r));\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive) {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (keepalive flag)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    keepalive_log_probe(\"[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> %d\",\n                        (int)(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)));\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    keepalive_log_probe(\"[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> %d\",\n                        (int)MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    keepalive_log_probe(\"[keepalive] assert(! c->stop_with_error) -> %d\",\n                        (int)(! c->stop_with_error));\n    mhd_assert (! c->stop_with_error);\n    keepalive_log_decision(\"MHD_CONN_MUST_UPGRADE (upgrade_handler present)\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  keepalive_log_probe(\"[keepalive] assert((! c->stop_with_error) || (c->discard_request)) -> %d\",\n                      (int)((! c->stop_with_error) || (c->discard_request)));\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (read_closed || discard_request)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (HTTP 1.0 strict flag)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (has Connection: close header auto-flag)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (HTTP version not supported)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (Connection: close header present)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      keepalive_log_decision(\"MHD_CONN_USE_KEEPALIVE (HTTP/1.0 + Keep-Alive header)\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (HTTP/1.0 without Keep-Alive)\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    keepalive_log_decision(\"MHD_CONN_USE_KEEPALIVE (HTTP/1.1 compatible)\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  keepalive_log_decision(\"MHD_CONN_MUST_CLOSE (default)\");\n  return MHD_CONN_MUST_CLOSE;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[keepalive] entry: connection=0x5584f3a2b870 response=0x5584f3a33b40\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x5584f3a34500 response=0x5584f3a34750\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x5584f3a2bb10 response=0x5584f3a34d10\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab0c000b90\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab0c000b90\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab0c000b90\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab04008f40\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab04008f40\n  keepalive=0 read_closed=0 discard_request=1 stop_with_error=0\n  rq.http_ver=3\n  rp.response.flags=0x00000000 flags_auto=0x00000001\n[keepalive] assert(NULL != r) -> 1\n[keepalive] assert(0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE)) -> 1\n[keepalive] assert(MHD_IS_HTTP_VER_SUPPORTED(c->rq.http_ver)) -> 1\n[keepalive] assert(! c->stop_with_error) -> 1\n[keepalive] decision: MHD_CONN_MUST_UPGRADE (upgrade_handler present)\n[keepalive] entry: connection=0x7fab04000b90 response=0x7fab04008f40\n  keepalive=0 read_closed=0 discard_request=1 stop_\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In the provided project configuration mhd_assert expands to a no-op (e.g. ((void)0)), so the assertion statement instances in keepalive_possible are executed but have no effect; removing them would not change program behaviour. Per MISRA C 2023 Rule 2.2 (\u201cAny operation that is executed but whose removal would not affect program behaviour constitutes dead code\u201d), those assertion statements are dead code and therefore violate the rule."
}