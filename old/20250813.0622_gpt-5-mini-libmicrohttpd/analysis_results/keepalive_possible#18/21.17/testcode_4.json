{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nIf MHD_STATICSTR_LEN_ is implemented as something like (sizeof(s)-1) (the common pattern for static string macros), the macro MHD_lookup_header_s_token_ci(c,h,tkn) will pass those computed lengths to MHD_lookup_header_token_ci. When used correctly with compile-time string literals (e.g. MHD_HTTP_HEADER_CONNECTION and \"close\") this is safe. However, if a caller mistakenly passes non\u2011literal pointers (runtime char * variables) the sizeof(s) in the macro yields the size of the pointer (not the string length) and the resulting header_len/token_len will be incorrect. That incorrect length can cause the downstream functions (e.g. MHD_str_has_token_caseless_ or other string/comparison helpers that use the provided lengths) to read or compare more bytes than actually allocated for the pointed\u2011to token/header, leading to out\u2011of\u2011bounds accesses of the objects referenced by their pointer parameters and thus violating MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified keepalive_possible code that contains useful probe functions that print useful logs to a file \"/tmp/logs/151.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of keepalive_possible as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of keepalive_possible:\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n</target_code>\nPlease provide the modified keepalive_possible code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n\n/* Probe helper: log state relevant to keepalive decision to a file. */\nstatic void\nmhd_probe_keepalive_state (const char *stage,\n                           struct MHD_Connection *c,\n                           struct MHD_Response *r,\n                           const char *header,\n                           const char *token)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Print key pointers and a few fields that help reproduce the scenario.\n   * We do not dereference header/token contents to avoid any out-of-bounds\n   * reads; we only log the pointer values and connection/response state.\n   */\n  fprintf (f, \"[keepalive_probe] stage=%s\\n\", stage);\n  fprintf (f, \"  conn=%p rp.response=%p\\n\", (void *)c, (void *)r);\n  if (NULL != c)\n  {\n    /* print some connection/request fields */\n    fprintf (f, \"  conn->keepalive=%d conn->read_closed=%d conn->discard_request=%d conn->stop_with_error=%d\\n\",\n             (int)c->keepalive,\n             (int)c->read_closed,\n             (int)c->discard_request,\n             (int)c->stop_with_error);\n    fprintf (f, \"  conn->rq.http_ver=%u\\n\", (unsigned)c->rq.http_ver);\n  }\n  if (NULL != r)\n  {\n    fprintf (f, \"  response flags=0x%08x flags_auto=0x%08x upgrade_handler=%p\\n\",\n             (unsigned)r->flags,\n             (unsigned)r->flags_auto,\n             (void *)r->upgrade_handler);\n  }\n\n  /* Log the header and token pointer values. This is important evidence\n   * for the sizeof-macro misuse: if a caller passed a runtime pointer, its\n   * address will usually differ from addresses of static literals.\n   */\n  fprintf (f, \"  header_ptr=%p token_ptr=%p\\n\", (const void *)header, (const void *)token);\n\n  fclose (f);\n}\n\nstatic void\nmhd_probe_keepalive_result (struct MHD_Connection *c,\n                             enum MHD_ConnKeepAlive result,\n                             const char *reason)\n{\n  FILE *f = fopen(\"/tmp/logs/151.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"[keepalive_result] conn=%p result=%d reason=%s\\n\", (void *)c, (int)result, reason);\n  fclose (f);\n}\n\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    mhd_probe_keepalive_state (\"early_must_close_keepalive_flag\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"keepalive flag == MUST_CLOSE\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    mhd_probe_keepalive_state (\"upgrade_handler_present\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_UPGRADE, \"upgrade_handler present\");\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n  {\n    mhd_probe_keepalive_state (\"read_closed_or_discard_request\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"read_closed or discard_request\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n  {\n    mhd_probe_keepalive_state (\"response_flag_http_1_0_compatible_strict\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"response flag HTTP/1.0 compatible strict\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n  {\n    mhd_probe_keepalive_state (\"response_has_connection_close\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"response has connection: close\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n  {\n    mhd_probe_keepalive_state (\"http_version_not_supported\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"http version not supported\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  /* Probe before calling the header/token lookup that is implicated in the\n   * MISRA 21.17 violation scenario. We log pointer values for header and\n   * token so that downstream analysis can detect misuse of sizeof-based\n   * static-string macros when callers supply runtime pointers.\n   */\n  mhd_probe_keepalive_state (\"before_lookup_close\", c, r, MHD_HTTP_HEADER_CONNECTION, \"close\");\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n  {\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"request header contains close token\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    mhd_probe_keepalive_state (\"http_1_0_path_before_keepalive_lookup\", c, r, MHD_HTTP_HEADER_CONNECTION, \"Keep-Alive\");\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n    {\n      mhd_probe_keepalive_result (c, MHD_CONN_USE_KEEPALIVE, \"1.0 request with Keep-Alive header\");\n      return MHD_CONN_USE_KEEPALIVE;\n    }\n\n    mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"1.0 request without Keep-Alive header\");\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n  {\n    mhd_probe_keepalive_state (\"http_1_1_compatible\", c, r, NULL, NULL);\n    mhd_probe_keepalive_result (c, MHD_CONN_USE_KEEPALIVE, \"HTTP/1.1 compatible\");\n    return MHD_CONN_USE_KEEPALIVE;\n  }\n\n  mhd_probe_keepalive_state (\"default_must_close\", c, r, NULL, NULL);\n  mhd_probe_keepalive_result (c, MHD_CONN_MUST_CLOSE, \"default case\");\n  return MHD_CONN_MUST_CLOSE;\n}\n"
}