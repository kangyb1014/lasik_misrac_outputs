{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool (definition)",
    "ROUND_TO_ALIGN (macro)",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE (macro)",
    "_MHD_RED_ZONE_SIZE (macro/constant)",
    "mp_ptr_diff_ (function/macro)",
    "mp_ptr_le_ (function/macro)",
    "_MHD_POISON_MEMORY (macro/function)",
    "_MHD_UNPOISON_MEMORY (macro/function)",
    "mhd_assert (macro)",
    "__asan_region_is_poisoned (function)",
    "memset (library function)",
    "memcpy (library function)"
  ],
  "explanation": "For checking the MISRA rule \"A function parameter should not be modified\" you must be certain that neither the parameter variables (pool, old, old_size, new_size) are assigned to inside the function or inside any macro/function used. The listed symbols are those used by MHD_pool_reallocate that could potentially contain side effects that assign to parameters or to objects reachable from parameters; each is needed for the reasons below:\n\n- struct MemoryPool (definition): required to determine whether accesses like pool->pos or pool->end modify the object pointed to by the pointer parameter (allowed by MISRA) versus accidentally modifying the parameter variable itself. Also needed to confirm types and whether any macro might expand to write to 'pool' instead of its members.\n\n- ROUND_TO_ALIGN (macro): used with pool->pos. Macros can contain assignments; the exact expansion is needed to ensure it does not assign to the parameter variable (pool) itself or otherwise perform unexpected writes to parameter variables.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE (macro): used repeatedly with expressions involving old_offset, old_size, new_size and pool->pos. Must inspect its expansion to ensure it does not perform assignment to a parameter variable or produce side effects that alter parameter variables.\n\n- _MHD_RED_ZONE_SIZE (macro/constant): used by the rounding macros and assertions; included so the rounding macros and arithmetic can be fully evaluated and checked for side effects or wrap-around behavior that might lead to assignment to parameters.\n\n- mp_ptr_diff_ (function/macro): computes old_offset from old and pool->memory. If implemented as a macro it might evaluate or modify its arguments; its definition is needed to ensure it does not write to the parameter variables (old, pool) or their members.\n\n- mp_ptr_le_ (function/macro): used inside assertions with pool->memory and old. Must confirm it has no side effects that write to the parameters.\n\n- _MHD_POISON_MEMORY (macro/function): called with pointer arguments (old, new pointer arithmetic). Although poisoning is intended to modify memory pointed to (permitted), its implementation must be checked to ensure it does not assign to the pointer parameter variables themselves.\n\n- _MHD_UNPOISON_MEMORY (macro/function): same rationale as _MHD_POISON_MEMORY \u2014 it may modify memory but must be verified not to assign to parameter variables.\n\n- mhd_assert (macro): wraps expressions that include functions/macros (e.g., __asan_region_is_poisoned). Because assert macros can be implemented with side effects, its definition is required to ensure it does not modify parameters when used with the given expressions.\n\n- __asan_region_is_poisoned (function): conditionally used in an assert with (old, old_size). Its definition is needed to ensure it does not modify the parameter variables (it should only inspect memory).\n\n- memset (library function): used to write to memory pointed to by 'old' \u2014 writing pointed-to objects is allowed by MISRA for pointer parameters, but include memset to confirm it is not a wrapper that might reassign the pointer parameter variable.\n\n- memcpy (library function): used to move data from old to new block. Include to confirm its implementation does not reassign the pointer parameter variables.\n\nThese symbols together let an analyst determine whether any assignment or side-effect updates the parameter variables themselves (pool, old, old_size, new_size). In particular, focus on macro expansions and any non-trivial wrapper implementations that might perform assignments; standard library functions (memset/memcpy) and poisoning helpers are normally allowed to modify pointed-to memory but must be checked to ensure they do not rebind the parameter variables."
}