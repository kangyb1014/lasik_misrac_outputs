{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "mhd_assert",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "MHD_ASAN_POISON_ACTIVE",
    "HAVE___ASAN_REGION_IS_POISONED",
    "__asan_region_is_poisoned",
    "memcpy",
    "memset"
  ],
  "explanation": "Provide the minimal set of external definitions and macros whose semantics or conditional presence affect control flow, side-effects, or whether operations in MHD_pool_reallocate are functionally necessary (i.e. whether their removal would change program behaviour). For each symbol:\n\n- struct MemoryPool: Definition (types and semantics of fields memory, pos, end, size) is required to determine whether assignments to pool->pos, pointer computations (pool->memory + pool->pos) and bounds checks are meaningful or redundant; it also determines whether some code can never execute (dead).\n\n- mhd_assert: Often implemented as a macro that can be compiled out (e.g. NDEBUG). Knowing its expansion (side-effects or no-op) is essential to decide whether the assert statements constitute executable code that affects behaviour or are dead in production builds.\n\n- ROUND_TO_ALIGN: Used to test/compute alignment of pool->pos and in ROUND_TO_ALIGN_PLUS_RED_ZONE. Its exact arithmetic determines branch outcomes (e.g. whether pool->pos == ROUND_TO_ALIGN(pool->pos)) and thus whether some code is reachable or has no effect.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE: Used repeatedly to compute asize/new_apos; its definition (how it rounds and adds the red-zone) directly affects branch decisions (in-place resize vs allocate new), so it is needed to know if parts of the function are ever executed.\n\n- _MHD_RED_ZONE_SIZE: The red-zone size is used in several comparisons and in asize computation; its value can change whether checks succeed and whether code (especially red-zone related checks and adjustments) is necessary.\n\n- mp_ptr_diff_: Computes old_offset from old and pool->memory. Its precise semantics (units returned, overflow behaviour) determine branch decisions and whether pointer/offset checks are meaningful.\n\n- mp_ptr_le_: Pointer comparison used in asserts to constrain old. If this macro/function has side-effects or different semantics, it affects whether related assertions/code are relevant or dead.\n\n- _MHD_POISON_MEMORY and _MHD_UNPOISON_MEMORY: These macros/functions may be no-ops in production builds or active only under sanitizers. If they are no-ops, calls that only poison/unpoison memory may be dead (removal would not affect program behaviour); if they have side-effects, removal would change behaviour. Their definitions are therefore required.\n\n- MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED: These compile-time macros control the presence of the ASAN-related assert block. Knowing whether they are defined is required to determine if that code is compiled (executable) or dead.\n\n- __asan_region_is_poisoned: If the ASAN-related assert is compiled in, this function is invoked and affects control-flow (assert). Its semantics (return value meaning, side-effects) are required.\n\n- memcpy and memset: Standard library calls that perform observable memory writes/reads. To decide whether zeroing or copying steps are behaviourally necessary (and thus not dead), their presence and guaranteed side-effects must be assumed; if replaced by no-ops, behaviour would change. Their inclusion ensures correct reasoning about whether removing those calls would alter program behaviour.\n\nCollectively, these symbols determine which branches are reachable, which memory operations are required for correct behaviour, and which calls can be considered instrumentation (and potentially dead) versus essential functionality."
}