{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro _MHD_UNPOISON_MEMORY(pointer, size) expands to the no-op expression (void)0. Calls to this macro in MHD_pool_reallocate (and elsewhere) are executed but perform no action \u2014 removing them would not change program behaviour. Those executed no-op operations therefore constitute dead code and violate MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log(const char *stage,\n              struct MemoryPool *pool,\n              void *old,\n              size_t old_size,\n              size_t new_size,\n              size_t old_offset,\n              bool shrinking)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Log relevant pointers and sizes. Use %p for pointers and %zu for size_t. */\n  fprintf(f, \"MHD_POOL_REALLOCATE: stage=%s pool=%p pos=%zu end=%zu pool_size=%zu old=%p old_size=%zu new_size=%zu old_offset=%zu shrinking=%d\\n\",\n          stage,\n          (void *)pool,\n          (size_t)pool->pos,\n          (size_t)pool->end,\n          (size_t)pool->size,\n          old,\n          old_size,\n          new_size,\n          old_offset,\n          shrinking ? 1 : 0);\n  fclose(f);\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  /* Entry probe */\n  mhd_probe_log(\"entry\", pool, old, old_size, new_size, (size_t)0, false);\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    /* Probe after computing offset and shrinking flag */\n    mhd_probe_log(\"have_old_computed\", pool, old, old_size, new_size, old_offset, shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n\n      /* Probe after shrinking in-place */\n      mhd_probe_log(\"shrinking_zeroed\", pool, old, old_size, new_size, old_offset, shrinking);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n\n      /* Probe immediately before the call to _MHD_UNPOISON_MEMORY so logs\n         show that the unpoison operation is reached in control flow. */\n      mhd_probe_log(\"about_to_unpoison_inplace\", pool, old, old_size, new_size, old_offset, shrinking);\n\n      _MHD_UNPOISON_MEMORY (old, new_size);\n\n      /* Probe immediately after the call as well to capture completion. */\n      mhd_probe_log(\"after_unpoison_inplace\", pool, old, old_size, new_size, old_offset, shrinking);\n\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  /* Probe before unpoisoning the newly allocated block */\n  mhd_probe_log(\"about_to_unpoison_new\", pool, new_blc, 0, new_size, (size_t)0, false);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n\n  /* Probe after unpoisoning the newly allocated block */\n  mhd_probe_log(\"after_unpoison_new\", pool, new_blc, 0, new_size, (size_t)0, false);\n\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n\n    /* Probe after moving and poisoning old */\n    mhd_probe_log(\"moved_and_poisoned_old\", pool, old, old_size, new_size, (size_t)0, false);\n  }\n  return new_blc;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_POOL_REALLOCATE: stage=entry pool=0x55587e3dcae0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3dcb50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3dcb50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x55587e3dcae0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3dcb50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3dcb50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x55587e3dcae0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3e5f70 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x55587e3dcae0 pos=32640 end=32640 pool_size=32768 old=0x55587e3e5f70 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29d8000de0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29d8000de0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29d8000de0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29d8000de0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x7f29d8000de0 pos=32640 end=32640 pool_size=32768 old=0x7f29d8000e50 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29dc000b90 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=about_to_unpoison_new pool=0x7f29dc000b90 pos=32640 end=32640 pool_size=32768 old=0x7f29dc0011e0 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=after_unpoison_new pool=0x7f29dc000b90 pos=32640 end=32640 pool_size=32768 old=0x7f29dc0011e0 old_size=0 new_size=32576 old_offset=0 shrinking=0\nMHD_POOL_REALLOCATE: stage=entry pool=0x7f29d8000de0 pos=64 end=32640 pool_size=32768 old=(nil) old_size=0 new_size=32576 old_offset=0 shrinking\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 2.2 forbids dead code: operations that are executed but whose removal would not affect program behaviour. In the provided scenario _MHD_UNPOISON_MEMORY expands to the no-op expression (void)0 in the project build used for testing. The probe logs prove the call sites are reached during execution, but the macro performs no action. Removing those no-op macro calls would not change program behaviour in this project configuration, so they are dead code and constitute a violation of Rule 2.2. Therefore agent A's report is correct."
}