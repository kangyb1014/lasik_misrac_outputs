{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement mhd_assert(pool->size >= pool->end - pool->pos); expands to ((void)0) (mhd_assert is defined as ((void)0)) so it is a no-op in the provided build. Removing this statement would not affect program behaviour, therefore it constitutes dead code. (If mhd_assert can be defined to perform checks in other build configurations then it would not be dead in those configurations; but given the supplied definition it is dead in this project configuration.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_logf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/10.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fclose (f);\n}\nstatic int\nmhd_assert_active_check (void)\n{\n  int probe = 0;\n  /* If mhd_assert executes its argument, probe will become 1. */\n  mhd_assert (probe = 1);\n  return probe;\n}\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  /* Log entry and initial pool state for later inspection. */\n  mhd_logf (\"MHD_pool_reallocate ENTRY: pool=%p old=%p old_size=%zu new_size=%zu\\n\",\n            (void *) pool, old, old_size, new_size);\n  if (pool)\n    mhd_logf (\" pool->memory=%p pos=%zu end=%zu size=%zu\\n\",\n              (void *) pool->memory, pool->pos, pool->end, pool->size);\n\n  /* Detect whether mhd_assert is active in this build. This provides\n     direct evidence for the reported violation scenario when it is a no-op. */\n  {\n    int assert_active = mhd_assert_active_check ();\n    mhd_logf (\" mhd_assert active? %d\\n\", assert_active);\n    if (!assert_active)\n      mhd_logf (\" NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\\n\");\n  }\n\n  /* Evaluate and log the assertion conditions (their boolean values) so\n     that the control path and state that the assertions would have\n     checked are captured even if the assertions themselves are no-ops. */\n  if (pool)\n  {\n    int c1 = (pool->end >= pool->pos);\n    int c2 = (pool->size >= pool->end - pool->pos);\n    int c3 = (old != NULL || old_size == 0);\n    int c4 = (pool->size >= old_size);\n    int c5 = (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n    mhd_logf (\" assertions (evaluated): end>=pos=%d size>=(end-pos)=%d old!=NULL||old_size==0=%d size>=old_size=%d pos==ROUND_TO_ALIGN(pos)=%d\\n\",\n              c1, c2, c3, c4, c5);\n  }\n\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_logf (\" branch: old!=NULL old_offset=%zu shrinking=%d\\n\",\n              old_offset, (int) shrinking);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    /* Log evaluations of the above assertions */\n    {\n      int a1 = mp_ptr_le_ (pool->memory, old);\n      int a2 = ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n      int a3 = ((old_size == 0) || (pool->pos > old_offset));\n      int a4 = ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n      mhd_logf (\" assertions (branch old): mp_ptr_le=%d size-redzone>=(old_offset+old_size)=%d pos>old_offset_or_zero=%d end-redzone>=(old_offset+old_size)=%d\\n\",\n                a1, a2, a3, a4);\n    }\n\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      mhd_logf (\" action: shrinking in-place, zeroing from %p length %zu\\n\",\n                (uint8_t *) old + new_size, old_size - new_size);\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      mhd_logf (\" condition: old is last allocated block; new_apos=%zu\\n\", new_apos);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n        {\n          mhd_logf (\" result: grow in-place failed: new_apos=%zu pool->end=%zu pool->pos=%zu -> returning NULL\\n\",\n                    new_apos, pool->end, pool->pos);\n          return NULL;                /* No space */\n        }\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      mhd_logf (\" result: resized in-place, return old=%p new_pos=%zu\\n\", old, pool->pos);\n      return old;\n    }\n    if (shrinking)\n    {\n      mhd_logf (\" result: shrinking but not last block -> resized in-place, return old=%p\\n\", old);\n      return old;   /* Resized in-place, freed part remains allocated */\n    }\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  mhd_logf (\" allocate path: asize=%zu pool->pos=%zu pool->end=%zu\\n\",\n            asize, pool->pos, pool->end);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n  {\n    mhd_logf (\" result: allocation failed (wrap or not enough space) -> returning NULL\\n\");\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  mhd_logf (\" allocated new_blc=%p new_pos=%zu\\n\", (void *) new_blc, pool->pos);\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n    mhd_logf (\" moved data from old=%p to new=%p old_size=%zu\\n\", old, new_blc, old_size);\n  }\n  mhd_logf (\" result: return new_blc=%p\\n\", (void *) new_blc);\n  return new_blc;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_pool_reallocate ENTRY: pool=0x55bd1628cae0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x55bd1628cb10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x55bd1628cb50 new_pos=32640\n result: return new_blc=0x55bd1628cb50\nMHD_pool_reallocate ENTRY: pool=0x55bd1628cae0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x55bd1628cb10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x55bd1628cb50 new_pos=32640\n result: return new_blc=0x55bd1628cb50\nMHD_pool_reallocate ENTRY: pool=0x55bd1628cae0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x55bd16295f30 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x55bd16295f70 new_pos=32640\n result: return new_blc=0x55bd16295f70\nMHD_pool_reallocate ENTRY: pool=0x7fe2c4000de0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x7fe2c4000e10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x7fe2c4000e50 new_pos=32640\n result: return new_blc=0x7fe2c4000e50\nMHD_pool_reallocate ENTRY: pool=0x7fe2c4000de0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x7fe2c4000e10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x7fe2c4000e50 new_pos=32640\n result: return new_blc=0x7fe2c4000e50\nMHD_pool_reallocate ENTRY: pool=0x7fe2c4000de0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x7fe2c4000e10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x7fe2c4000e50 new_pos=32640\n result: return new_blc=0x7fe2c4000e50\nMHD_pool_reallocate ENTRY: pool=0x7fe2c4000de0 old=(nil) old_size=0 new_size=32576\n pool->memory=0x7fe2c4000e10 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x7fe2c4000e50 new_pos=32640\n result: return new_blc=0x7fe2c4000e50\nMHD_pool_reallocate ENTRY: pool=0x7fe2c0000b90 old=(nil) old_size=0 new_size=32576\n pool->memory=0x7fe2c00011a0 pos=64 end=32640 size=32768\n mhd_assert active? 0\n NOTE: mhd_assert appears to be a no-op in this build (e.g. expands to ((void)0)).\n assertions (evaluated): end>=pos=1 size>=(end-pos)=1 old!=NULL||old_size==0=1 size>=old_size=1 pos==ROUND_TO_ALIGN(pos)=1\n allocate path: asize=32576 pool->pos=64 pool->end=32640\n allocated new_blc=0x7fe2c00011e0 new_pos=32640\n result: return new_blc=0x7fe2c00011e0\n\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The test demonstrates that in this project build mhd_assert is a no-op (mhd_assert_active? 0, i.e. expands to ((void)0)). The statement mhd_assert(pool->size >= pool->end - pool->pos); (and the other mhd_assert invocations) therefore execute as no-ops; removing them would not affect program behaviour in this configuration. Under MISRA C 2023 Rule 2.2 (dead code: any operation executed whose removal would not affect program behaviour), those assertion statements are dead code and thus constitute a violation in the supplied project configuration."
}