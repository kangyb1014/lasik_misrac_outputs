{
  "user_message": "An agent A claimed that the following post_iterator code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of post_iterator.\n```c\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    if (off >= sizeof(session->value_1) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_1))\n      size = (size_t) (sizeof (session->value_1) - off - 1); /* crop extra data */\n    memcpy (&session->value_1[off],\n            data,\n            size);\n    session->value_1[size + off] = '\\0';\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    if (off >= sizeof(session->value_2) - 1)\n      return MHD_YES; /* Discard extra data */\n    if (size + off >= sizeof(session->value_2))\n      size = (size_t) (sizeof (session->value_2) - off - 1); /* crop extra data */\n    memcpy (&session->value_2[off],\n            data,\n            size);\n    session->value_2[size + off] = '\\0';\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes \u2014 if size + off overflows the unsigned integer range the bounds check can be bypassed. Example: let N = sizeof(session->value_1) (e.g. 256), off = 10, and size = UINT64_MAX - 5. The expression (size + off) is evaluated in an unsigned type and wraps to 4, so the test if (size + off >= N) is false and size is not reduced. The subsequent memcpy(&session->value_1[off], data, size) and the write session->value_1[size + off] = '\\0' then write far beyond the buffer, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void post_iterator_log(const char *tag,\n                                  struct Session *session,\n                                  const char *key,\n                                  uint64_t off,\n                                  size_t size,\n                                  size_t buf_size,\n                                  unsigned long long sum_wrapped,\n                                  size_t adjusted_size,\n                                  const char *note)\n{\n  FILE *f = fopen(\"/tmp/logs/391.txt\", \"a\");\n  if (!f)\n    return;\n  /* Print a compact record of the important state. Use casts to avoid\n     dependencies on PRIu64. */\n  fprintf(f,\n          \"%s: tag=%s key=%s sid=%s off=%llu size=%zu buf_size=%zu sum_wrapped=%llu adjusted_size=%zu note=%s dest_ptr=%p data_ptr=%p\\n\",\n          \"POST_ITER\", tag,\n          key ? key : \"(null)\",\n          session && session->sid ? session->sid : \"(null)\",\n          (unsigned long long) off,\n          size,\n          buf_size,\n          (unsigned long long) sum_wrapped,\n          adjusted_size,\n          note ? note : \"\",\n          (void *) (session ? &session->value_1[0] : NULL), /* generic pointer to value_1 start */\n          (void *) NULL);\n  fclose(f);\n}\n\nstatic enum MHD_Result\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) filename;          /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n\n  /* Log entry into function */\n  post_iterator_log(\"ENTER\", session, key, off, size, 0,\n                    (unsigned long long) (off + (uint64_t) size), 0,\n                    \"entry\");\n\n  if (0 == strcmp (\"DONE\", key))\n  {\n    /* Log DONE path and values of the two buffers (addresses/sid only) */\n    post_iterator_log(\"DONE\", session, key, off, size, 0,\n                      (unsigned long long) (off + (uint64_t) size), 0,\n                      \"DONE branch\");\n    fprintf (stdout,\n             \"Session `%s' submitted `%s', `%s'\\n\",\n             session->sid,\n             session->value_1,\n             session->value_2);\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v1\", key))\n  {\n    size_t buf_size = sizeof(session->value_1);\n    /* Compute the same wrapped-sum expression used in the original code. */\n    unsigned long long sum_wrapped = (unsigned long long) off + (unsigned long long) size;\n\n    /* Log state before any bounds checks. This will show if sum \"wraps\" to a\n       small value so that the subsequent check can be bypassed. */\n    post_iterator_log(\"V1_BEFORE_CHECK\", session, key, off, size, buf_size,\n                      sum_wrapped, size, \"before bounds checks\");\n\n    if (off >= buf_size - 1)\n    {\n      post_iterator_log(\"V1_EARLY_RETURN_OFF\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"off >= buf_size-1, discarding\");\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= buf_size)\n    {\n      /* Log that cropping will be performed and the amount. */\n      size_t new_size = (size_t) (buf_size - off - 1);\n      post_iterator_log(\"V1_CROPPING\", session, key, off, size, buf_size,\n                        sum_wrapped, new_size, \"cropping to fit buffer\");\n      size = new_size; /* crop extra data */\n    }\n    else\n    {\n      /* Log that no cropping was done. This is key for reproducing the\n         overflow scenario: large size that, due to wrapping of (size+off),\n         appears small and bypasses cropping. */\n      post_iterator_log(\"V1_NO_CROP\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"no cropping performed\");\n    }\n\n    /* Log parameters immediately before memcpy (dest pointer and length). */\n    {\n      void *dest = (void *)&session->value_1[off];\n      post_iterator_log(\"V1_BEFORE_MEMCPY\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"about to memcpy\");\n      /* Keep original logic intact. */\n      memcpy (dest, data, size);\n    }\n\n    /* Log intent to write terminating null and the computed index (may be\n       wrapped) without accessing that index here. We log the computed index\n       as the same wrapped expression to provide evidence if it is small. */\n    unsigned long long final_index = (unsigned long long) off + (unsigned long long) size;\n    post_iterator_log(\"V1_BEFORE_NULL\", session, key, off, size, buf_size,\n                      final_index, size, \"about to write terminating null at index\");\n\n    /* Original terminating write. This may be out-of-bounds in the violation\n       scenario; we do not change the behavior. */\n    session->value_1[size + off] = '\\0';\n\n    /* Confirm completion of branch */\n    post_iterator_log(\"V1_DONE\", session, key, off, size, buf_size,\n                      final_index, size, \"v1 completed\");\n    return MHD_YES;\n  }\n  if (0 == strcmp (\"v2\", key))\n  {\n    size_t buf_size = sizeof(session->value_2);\n    unsigned long long sum_wrapped = (unsigned long long) off + (unsigned long long) size;\n\n    post_iterator_log(\"V2_BEFORE_CHECK\", session, key, off, size, buf_size,\n                      sum_wrapped, size, \"before bounds checks\");\n\n    if (off >= buf_size - 1)\n    {\n      post_iterator_log(\"V2_EARLY_RETURN_OFF\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"off >= buf_size-1, discarding\");\n      return MHD_YES; /* Discard extra data */\n    }\n    if (size + off >= buf_size)\n    {\n      size_t new_size = (size_t) (buf_size - off - 1);\n      post_iterator_log(\"V2_CROPPING\", session, key, off, size, buf_size,\n                        sum_wrapped, new_size, \"cropping to fit buffer\");\n      size = new_size; /* crop extra data */\n    }\n    else\n    {\n      post_iterator_log(\"V2_NO_CROP\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"no cropping performed\");\n    }\n\n    {\n      void *dest = (void *)&session->value_2[off];\n      post_iterator_log(\"V2_BEFORE_MEMCPY\", session, key, off, size, buf_size,\n                        sum_wrapped, size, \"about to memcpy\");\n      memcpy (dest, data, size);\n    }\n\n    unsigned long long final_index = (unsigned long long) off + (unsigned long long) size;\n    post_iterator_log(\"V2_BEFORE_NULL\", session, key, off, size, buf_size,\n                      final_index, size, \"about to write terminating null at index\");\n\n    session->value_2[size + off] = '\\0';\n\n    post_iterator_log(\"V2_DONE\", session, key, off, size, buf_size,\n                      final_index, size, \"v2 completed\");\n    return MHD_YES;\n  }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n\n  post_iterator_log(\"UNSUPPORTED\", session, key, off, size, 0,\n                    (unsigned long long) (off + (uint64_t) size), 0,\n                    \"unsupported key\");\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for post_iterator. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes (size + off) using unsigned arithmetic and does not guard against wrap-around. If size and/or off are large enough the addition can wrap to a small value, causing the test if (size + off >= sizeof(session->value_X)) to succeed incorrectly (i.e. be false when the true mathematical sum would be >= buffer size). That allows the subsequent memcpy(&session->value_X[off], data, size) and the terminating write session->value_X[size + off] = '\\0' to write well beyond the buffer bounds, violating MISRA C 2023 Rule 21.17.\n\nWhether an exploit is possible at runtime depends on the platform's integer widths and the values provided for off and size, but the code is unsafely written: it relies on unsigned addition that can wrap. The absence of log output in the supplied test code does not invalidate the logical overflow scenario \u2014 it only means the test harness did not exercise the offending path. A safe fix is to perform checks that cannot be bypassed by wrap-around (for example: first ensure off < buf_size, then compute remaining = buf_size - 1 - (size_t)off and clip size using a comparison that uses a sufficiently wide type or checks for SIZE_MAX - (size_t)off < size)."
}