{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 1.2.\nHere is the comment from the agent.\n<violation scenario>\nThe macro defines _MHD_EXTERN using GCC/Clang attribute syntax: '__attribute__((visibility(\"default\")))extern'. The use of '__attribute__((...))' is a compiler-specific language extension (documented in GCC/Clang), so this violates MISRA C 2023 Rule 1.2 (language extensions should not be used).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_add_response_header code that contains useful probe functions that print useful logs to a file \"/tmp/logs/48.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_add_response_header as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_add_response_header:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\nPlease provide the modified MHD_add_response_header code.\n",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  FILE *log = fopen(\"/tmp/logs/48.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"ENTER: MHD_add_response_header header='%s' content='%s' header_ptr=%p content_ptr=%p response_ptr=%p\\n\",\n            header ? header : \"(null)\", content ? content : \"(null)\", (void *)header, (void *)content, (void *)response);\n    if (response)\n      fprintf(log, \"  initial flags_auto=0x%08x flags=0x%08x\\n\",\n              (unsigned int)response->flags_auto, (unsigned int)response->flags);\n    fflush(log);\n  }\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    if (log) fprintf(log, \"BRANCH: CONNECTION header matched\\n\"), fflush(log);\n    enum MHD_Result _res = add_response_header_connection (response, content);\n    if (log) fprintf(log, \"RETURN (connection): %d\\n\", (int)_res), fclose(log);\n    return _res;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (log) fprintf(log, \"BRANCH: TRANSFER-ENCODING header matched\\n\"), fflush(log);\n\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      if (log) fprintf(log, \"  content != 'chunked' -> reject\\n\"), fclose(log);\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      if (log) fprintf(log, \"  already has chunked encoding flag -> YES\\n\"), fclose(log);\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      if (log) fprintf(log, \"  has Content-Length and no Insanity flag -> reject\\n\"), fclose(log);\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n\n    if (log) fprintf(log, \"  attempting add_response_entry for chunked\\n\"), fflush(log);\n    enum MHD_Result _add_ret = add_response_entry (response,\n                                                   MHD_HEADER_KIND,\n                                                   header,\n                                                   content);\n    if (log) fprintf(log, \"  add_response_entry returned %d\\n\", (int)_add_ret), fflush(log);\n    if (MHD_NO != _add_ret)\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      if (log) fprintf(log, \"  set RAF_HAS_TRANS_ENC_CHUNKED flag -> RETURN YES\\n\"), fclose(log);\n      return MHD_YES;\n    }\n    if (log) fprintf(log, \"  add_response_entry failed -> RETURN NO\\n\"), fclose(log);\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (log) fprintf(log, \"BRANCH: DATE header matched\\n\"), fflush(log);\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      if (log) fprintf(log, \"  existing date header present -> locating and removing\\n\"), fflush(log);\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      if (log) fprintf(log, \"  located existing date header at %p (value=%p)\\n\", (void *)hdr, (void *)hdr->value), fflush(log);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n      {\n        if (log) fprintf(log, \"  freeing hdr->value %p\\n\", (void *)hdr->value), fflush(log);\n        free (hdr->value);\n      }\n      if (log) fprintf(log, \"  freeing hdr->header %p and hdr %p\\n\", (void *)hdr->header, (void *)hdr), fflush(log);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (log) fprintf(log, \"  attempting add_response_entry for DATE\\n\"), fflush(log);\n    enum MHD_Result _add_ret2 = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n    if (log) fprintf(log, \"  add_response_entry returned %d\\n\", (int)_add_ret2), fflush(log);\n    if (MHD_NO != _add_ret2)\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      if (log) fprintf(log, \"  set RAF_HAS_DATE_HDR flag -> RETURN YES\\n\"), fclose(log);\n      return MHD_YES;\n    }\n    if (log) fprintf(log, \"  add_response_entry failed for DATE -> RETURN NO\\n\"), fclose(log);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    if (log) fprintf(log, \"BRANCH: CONTENT-LENGTH header matched\\n\"), fflush(log);\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (log) fprintf(log, \"  special-case allowed -> attempting add_response_entry for Content-Length\\n\"), fflush(log);\n      enum MHD_Result _add_ret3 = add_response_entry (response,\n                                                      MHD_HEADER_KIND,\n                                                      header,\n                                                      content);\n      if (log) fprintf(log, \"  add_response_entry returned %d\\n\", (int)_add_ret3), fflush(log);\n      if (MHD_NO != _add_ret3)\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        if (log) fprintf(log, \"  set RAF_HAS_CONTENT_LENGTH flag -> RETURN YES\\n\"), fclose(log);\n        return MHD_YES;\n      }\n    }\n    if (log) fprintf(log, \"  not allowed or add_response_entry failed -> RETURN NO\\n\"), fclose(log);\n    return MHD_NO;\n  }\n\n  if (log) fprintf(log, \"FALLTHROUGH: calling add_response_entry for general header\\n\"), fflush(log);\n  enum MHD_Result _final_ret = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n  if (log) fprintf(log, \"RETURN (final): %d\\n\", (int)_final_ret), fclose(log);\n  return _final_ret;\n}\n"
}