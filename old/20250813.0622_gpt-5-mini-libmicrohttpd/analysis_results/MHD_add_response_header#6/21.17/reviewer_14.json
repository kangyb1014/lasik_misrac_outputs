{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls strchr(value, '\\r') / strchr(value, '\\n') without proving that 'value' is a valid, null\u2011terminated string (or non\u2011NULL). In MHD_add_response_header the 'content' pointer comes from the caller and is passed directly to add_response_header_connection, so if the caller supplies a non\u2011NULL pointer that is not NUL\u2011terminated (or supplies NULL), strchr will read beyond the object bounds (or dereference NULL). This can result in out\u2011of\u2011bounds accesses, so Rule 21.17 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  /* Logging helper: append textual information to /tmp/logs/55.txt. */\n  /* Keep minimal and safe: do not dereference content/header pointers. */\n  {\n    FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL != ___mhd_log_f)\n    {\n      fprintf (___mhd_log_f,\n               \"MHD_add_response_header ENTRY: response=%p header=%p content=%p flags=%llu flags_auto=%llu\\n\",\n               (void *) response,\n               (void *) header,\n               (void *) content,\n               (unsigned long long) response->flags,\n               (unsigned long long) response->flags_auto);\n      fclose (___mhd_log_f);\n    }\n  }\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    /* Log the decision to take the CONNECTION branch. */\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"BRANCH: CONNECTION chosen. content_ptr=%p content_is_null=%d\\n\",\n                 (void *) content,\n                 (content == NULL));\n        fclose (___mhd_log_f);\n      }\n    }\n\n    /* Preserve original behavior: forward to add_response_header_connection. */\n    return add_response_header_connection (response, content);\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    /* Log entering TRANSFER_ENCODING branch and relevant flags */\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"BRANCH: TRANSFER_ENCODING. content_ptr=%p content_is_null=%d flags=0x%llx flags_auto=0x%llx\\n\",\n                 (void *) content,\n                 (content == NULL),\n                 (unsigned long long) response->flags,\n                 (unsigned long long) response->flags_auto);\n        fclose (___mhd_log_f);\n      }\n    }\n\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"DECISION: TRANSFER_ENCODING denied: content != 'chunked' (content_ptr=%p)\\n\",\n                 (void *) content);\n        fclose (___mhd_log_f);\n      }\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"DECISION: Already has chunked encoding header.\\n\");\n        fclose (___mhd_log_f);\n      }\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"DECISION: Has Content-Length and no Insanity flag: deny TRANSFER_ENCODING. flags=0x%llx flags_auto=0x%llx\\n\",\n                 (unsigned long long) response->flags,\n                 (unsigned long long) response->flags_auto);\n        fclose (___mhd_log_f);\n      }\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"ACTION: Added TRANSFER_ENCODING 'chunked'. flags_auto now=0x%llx\\n\",\n                 (unsigned long long) response->flags_auto);\n        fclose (___mhd_log_f);\n      }\n      return MHD_YES;\n    }\n    FILE *___mhd_log_f2 = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL != ___mhd_log_f2)\n    {\n      fprintf (___mhd_log_f2,\n               \"ACTION: Failed to add TRANSFER_ENCODING header (add_response_entry returned MHD_NO).\\n\");\n      fclose (___mhd_log_f2);\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n\n      /* Log that we are removing an existing DATE header and pointer values */\n      {\n        FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n        if (NULL != ___mhd_log_f)\n        {\n          fprintf (___mhd_log_f,\n                   \"ACTION: Removing existing DATE header: hdr=%p hdr->header=%p hdr->value=%p\\n\",\n                   (void *) hdr,\n                   (void *) hdr->header,\n                   (void *) hdr->value);\n          fclose (___mhd_log_f);\n        }\n      }\n\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n\n      /* Log completion of removal */\n      {\n        FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n        if (NULL != ___mhd_log_f)\n        {\n          fprintf (___mhd_log_f,\n                   \"ACTION: DATE header removed. flags_auto=%llu\\n\",\n                   (unsigned long long) response->flags_auto);\n          fclose (___mhd_log_f);\n        }\n      }\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"ACTION: Added DATE header. flags_auto now=0x%llx\\n\",\n                 (unsigned long long) response->flags_auto);\n        fclose (___mhd_log_f);\n      }\n      return MHD_YES;\n    }\n    FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL != ___mhd_log_f)\n    {\n      fprintf (___mhd_log_f,\n               \"ACTION: Failed to add DATE header (add_response_entry returned MHD_NO).\\n\");\n      fclose (___mhd_log_f);\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Log entering CONTENT_LENGTH branch with flags */\n    {\n      FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n      if (NULL != ___mhd_log_f)\n      {\n        fprintf (___mhd_log_f,\n                 \"BRANCH: CONTENT_LENGTH. content_ptr=%p content_is_null=%d flags=0x%llx flags_auto=0x%llx\\n\",\n                 (void *) content,\n                 (content == NULL),\n                 (unsigned long long) response->flags,\n                 (unsigned long long) response->flags_auto);\n        fclose (___mhd_log_f);\n      }\n    }\n\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n\n        FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n        if (NULL != ___mhd_log_f)\n        {\n          fprintf (___mhd_log_f,\n                   \"ACTION: Added CONTENT_LENGTH header. flags_auto now=0x%llx\\n\",\n                   (unsigned long long) response->flags_auto);\n          fclose (___mhd_log_f);\n        }\n        return MHD_YES;\n      }\n    }\n    FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL != ___mhd_log_f)\n    {\n      fprintf (___mhd_log_f,\n               \"ACTION: CONTENT_LENGTH branch exiting with MHD_NO.\\n\");\n      fclose (___mhd_log_f);\n    }\n    return MHD_NO;\n  }\n\n  /* Default case: log the fall-through and call add_response_entry as normal */\n  {\n    FILE *___mhd_log_f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (NULL != ___mhd_log_f)\n    {\n      fprintf (___mhd_log_f,\n               \"FALLTHROUGH: calling add_response_entry for header=%p content=%p\\n\",\n               (void *) header,\n               (void *) content);\n      fclose (___mhd_log_f);\n    }\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d90b9 content=0x5643285d90b0 flags=0 flags_auto=0\nFALLTHROUGH: calling add_response_entry for header=0x5643285d90b9 content=0x5643285d90b0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d90b9 content=0x5643285d90de flags=0 flags_auto=0\nFALLTHROUGH: calling add_response_entry for header=0x5643285d90b9 content=0x5643285d90de\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d90b9 content=0x5643285d9118 flags=0 flags_auto=0\nFALLTHROUGH: calling add_response_entry for header=0x5643285d90b9 content=0x5643285d9118\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d918c flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d918c content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d922f flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d922f content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d92eb flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d92eb content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d931a flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d931a content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d93f1 flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d93f1 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=1\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d9649 flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d9649 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d966e flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d966e content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d96d5 flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d96d5 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d9700 flags=0 flags_auto=3\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d9700 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d972f flags=0 flags_auto=0\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d972f content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d9750 flags=0 flags_auto=1\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d9750 content_is_null=0\nMHD_add_response_header ENTRY: response=0x564339bf62a0 header=0x5643285d9196 content=0x5643285d94b3 flags=0 flags_auto=1\nBRANCH: CONNECTION chosen. content_ptr=0x5643285d94b3 content_is\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the supplied evidence. MHD_add_response_header itself does not call any of the <string.h> functions (e.g. strchr); it simply forwards the caller-supplied content pointer to helper functions (for example add_response_header_connection or add_response_entry). Whether a <string.h> function can access beyond bounds depends on the implementation of those helper functions, which are not shown. The test log (claimed exhaustive) shows many invocations entering the CONNECTION branch and always printing content_is_null=0 \u2014 i.e. content was not NULL in those tests \u2014 and no indication of an out-of-bounds string access. Thus the provided output does not demonstrate a call to strchr on a NULL or non-NUL-terminated pointer, and does not corroborate the claimed Rule 21.17 violation. Therefore the report is incorrect."
}