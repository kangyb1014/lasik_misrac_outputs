{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call content_len = strlen(content); only checks content != NULL (in add_response_entry) but does not ensure the pointed object is NUL\u2011terminated or that strlen will not scan past the valid storage. If a caller provides a non\u2011terminated buffer (or a pointer into a buffer where no '\\0' occurs within the object bounds), strlen will read beyond the object and thus violate MISRA C 2023 Rule 21.17. For example, if content points to a char array of known length that is not NUL-terminated (or to a slice inside a larger buffer without a terminating '\\0'), strlen(content) can overrun the buffer.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *stage,\n                          struct MHD_Response *response,\n                          const char *header,\n                          const char *content)\n{\n  FILE *fp = fopen(\"/tmp/logs/55.txt\", \"a\");\n  if (NULL == fp)\n    return;\n  fprintf(fp, \"STAGE: %s\\n\", stage);\n  fprintf(fp, \"  response=%p\\n\", (void *) response);\n  fprintf(fp, \"  header_ptr=%p\\n\", (void *) header);\n  fprintf(fp, \"  header_str=%s\\n\", (header != NULL) ? header : \"(null)\");\n  fprintf(fp, \"  content_ptr=%p\\n\", (void *) content);\n  if (NULL != response)\n  {\n    fprintf(fp, \"  flags=0x%llx\\n\", (unsigned long long) response->flags);\n    fprintf(fp, \"  flags_auto=0x%llx\\n\", (unsigned long long) response->flags_auto);\n  }\n  fprintf(fp, \"\\n\");\n  fclose(fp);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  mhd_log_probe(\"entry\", response, header, content);\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    mhd_log_probe(\"branch_connection\", response, header, content);\n    return add_response_header_connection (response, content);\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    mhd_log_probe(\"branch_transfer_encoding_enter\", response, header, content);\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      mhd_log_probe(\"transfer_encoding_not_chunked\", response, header, content);\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      mhd_log_probe(\"transfer_encoding_already_has_chunked\", response, header, content);\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      mhd_log_probe(\"transfer_encoding_conflict_with_content_length\", response, header, content);\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n    {\n      enum MHD_Result _rv;\n      mhd_log_probe(\"transfer_encoding_before_add_entry\", response, header, content);\n      _rv = add_response_entry (response,\n                                MHD_HEADER_KIND,\n                                header,\n                                content);\n      mhd_log_probe(\"transfer_encoding_after_add_entry\", response, header, content);\n      if (MHD_NO != _rv)\n      {\n        response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n        mhd_log_probe(\"transfer_encoding_added_chunked\", response, header, content);\n        return MHD_YES;\n      }\n      mhd_log_probe(\"transfer_encoding_failed_add_entry\", response, header, content);\n      return MHD_NO;\n    }\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    mhd_log_probe(\"branch_date_enter\", response, header, content);\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n      mhd_log_probe(\"branch_date_removed_existing\", response, header, content);\n    }\n    {\n      enum MHD_Result _rv;\n      mhd_log_probe(\"date_before_add_entry\", response, header, content);\n      _rv = add_response_entry (response,\n                                MHD_HEADER_KIND,\n                                header,\n                                content);\n      mhd_log_probe(\"date_after_add_entry\", response, header, content);\n      if (MHD_NO != _rv)\n      {\n        response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n        mhd_log_probe(\"date_added\", response, header, content);\n        return MHD_YES;\n      }\n      mhd_log_probe(\"date_failed_add_entry\", response, header, content);\n      return MHD_NO;\n    }\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    mhd_log_probe(\"branch_content_length_enter\", response, header, content);\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      enum MHD_Result _rv;\n      mhd_log_probe(\"content_length_before_add_entry\", response, header, content);\n      _rv = add_response_entry (response,\n                                MHD_HEADER_KIND,\n                                header,\n                                content);\n      mhd_log_probe(\"content_length_after_add_entry\", response, header, content);\n      if (MHD_NO != _rv)\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        mhd_log_probe(\"content_length_added\", response, header, content);\n        return MHD_YES;\n      }\n    }\n    mhd_log_probe(\"content_length_not_allowed_or_failed\", response, header, content);\n    return MHD_NO;\n  }\n\n  /* Default path */\n  {\n    enum MHD_Result _rv;\n    mhd_log_probe(\"default_before_add_entry\", response, header, content);\n    _rv = add_response_entry (response,\n                              MHD_HEADER_KIND,\n                              header,\n                              content);\n    mhd_log_probe(\"default_after_add_entry\", response, header, content);\n    return _rv;\n  }\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60b0\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_before_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60b0\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_after_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60b0\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60de\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_before_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60de\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_after_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b60de\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b6118\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_before_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b6118\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: default_after_add_entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b60b9\n  header_str=Header-Type-A\n  content_ptr=0x5626c64b6118\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b618c\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b618c\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b622f\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b622f\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b62eb\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b62eb\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b631a\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b631a\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b63f1\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b63f1\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x1\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x1\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x3\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: branch_connection\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c64b64b3\n  flags=0x0\n  flags_auto=0x0\n\nSTAGE: entry\n  response=0x5626fa5892a0\n  header_ptr=0x5626c64b6196\n  header_str=Connection\n  content_ptr=0x5626c\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MHD_add_response_header forwards the content pointer to routines (e.g. add_response_entry and the case-insensitive string comparisons) that rely on C string semantics and, per the scenario, use strlen/other <string.h> functions without establishing that the pointed-to object contains a terminating '\\0' within its bounds. The reviewed code does not perform any bounds/length checks or otherwise guarantee NUL-termination before those calls, so a caller-provided non-terminated buffer (or a pointer into an object with no '\\0' in-range) can cause strlen to read out of bounds and thus violate MISRA C 2023 Rule 21.17."
}