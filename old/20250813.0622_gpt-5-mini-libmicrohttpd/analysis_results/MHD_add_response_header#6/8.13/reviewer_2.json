{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call passes 'const char *header' and 'const char *content' to add_response_entry. If add_response_entry is declared to take non-const pointer parameters (e.g. char *header, char *content), then the call discards the const qualifier and thus violates MISRA C 2023 Rule 8.13. To fix: declare add_response_entry to accept const char * for these parameters (or otherwise avoid passing const data to non-const pointers).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *stage,\n                          const struct MHD_Response *response,\n                          const char *header,\n                          const char *content,\n                          long extra)\n{\n  FILE *f = fopen(\"/tmp/logs/51.txt\", \"a\");\n  if (f != NULL)\n  {\n    fprintf(f, \"%s: response=%p header=%p(%s) content=%p(%s) extra=%ld flags_auto=0x%lx flags=0x%lx\\n\",\n            stage,\n            (const void *)response,\n            (const void *)header, (header != NULL) ? header : \"(null)\",\n            (const void *)content, (content != NULL) ? content : \"(null)\",\n            extra,\n            (unsigned long)((response != NULL) ? response->flags_auto : 0UL),\n            (unsigned long)((response != NULL) ? response->flags : 0UL));\n    fclose(f);\n  }\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  /* Log entry */\n  mhd_log_probe(\"ENTRY\", response, header, content, 0);\n\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n  {\n    mhd_log_probe(\"BRANCH: CONNECTION\", response, header, content, 0);\n    return add_response_header_connection (response, content);\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    mhd_log_probe(\"BRANCH: TRANSFER_ENCODING_ENTER\", response, header, content, 0);\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n    {\n      mhd_log_probe(\"REJECT: TRANSFER_ENCODING_NOT_CHUNKED\", response, header, content, 0);\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    }\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    {\n      mhd_log_probe(\"ALREADY_HAS_CHUNKED\", response, header, content, 0);\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    }\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n    {\n      mhd_log_probe(\"REJECT: HAS_CONTENT_LENGTH_NO_INSANITY\", response, header, content, 0);\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    }\n\n    /* Probe before calling add_response_entry: record pointers and flags. */\n    mhd_log_probe(\"CALL: add_response_entry (TRANSFER_ENCODING)\", response, header, content, 0);\n    enum MHD_Result _res_te = add_response_entry (response,\n                                                  MHD_HEADER_KIND,\n                                                  header,\n                                                  content);\n    mhd_log_probe(\"RET: add_response_entry (TRANSFER_ENCODING)\", response, header, content, (long)_res_te);\n    if (MHD_NO != _res_te)\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      mhd_log_probe(\"SUCCESS: TRANSFER_ENCODING_ADDED\", response, header, content, (long)_res_te);\n      return MHD_YES;\n    }\n    mhd_log_probe(\"FAIL: add_response_entry (TRANSFER_ENCODING)\", response, header, content, (long)_res_te);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    mhd_log_probe(\"BRANCH: DATE_ENTER\", response, header, content, 0);\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ (\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n      mhd_log_probe(\"DATE: removed existing date header\", response, header, content, 0);\n    }\n\n    mhd_log_probe(\"CALL: add_response_entry (DATE)\", response, header, content, 0);\n    enum MHD_Result _res_date = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n    mhd_log_probe(\"RET: add_response_entry (DATE)\", response, header, content, (long)_res_date);\n    if (MHD_NO != _res_date)\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      mhd_log_probe(\"SUCCESS: DATE_ADDED\", response, header, content, (long)_res_date);\n      return MHD_YES;\n    }\n    mhd_log_probe(\"FAIL: add_response_entry (DATE)\", response, header, content, (long)_res_date);\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    mhd_log_probe(\"BRANCH: CONTENT_LENGTH_ENTER\", response, header, content, 0);\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      mhd_log_probe(\"CALL: add_response_entry (CONTENT_LENGTH)\", response, header, content, 0);\n      enum MHD_Result _res_cl = add_response_entry (response,\n                                                    MHD_HEADER_KIND,\n                                                    header,\n                                                    content);\n      mhd_log_probe(\"RET: add_response_entry (CONTENT_LENGTH)\", response, header, content, (long)_res_cl);\n      if (MHD_NO != _res_cl)\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        mhd_log_probe(\"SUCCESS: CONTENT_LENGTH_ADDED\", response, header, content, (long)_res_cl);\n        return MHD_YES;\n      }\n    }\n    mhd_log_probe(\"EXIT: CONTENT_LENGTH_NOT_ADDED\", response, header, content, 0);\n    return MHD_NO;\n  }\n\n  /* Default case: log the call and result of add_response_entry */\n  mhd_log_probe(\"CALL: add_response_entry (DEFAULT)\", response, header, content, 0);\n  enum MHD_Result _res_def = add_response_entry (response,\n                                                 MHD_HEADER_KIND,\n                                                 header,\n                                                 content);\n  mhd_log_probe(\"RET: add_response_entry (DEFAULT)\", response, header, content, (long)_res_def);\n  return _res_def;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0b0(value-a1) extra=0 flags_auto=0x0 flags=0x0\nCALL: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0b0(value-a1) extra=0 flags_auto=0x0 flags=0x0\nRET: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0b0(value-a1) extra=1 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0de(value-a2) extra=0 flags_auto=0x0 flags=0x0\nCALL: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0de(value-a2) extra=0 flags_auto=0x0 flags=0x0\nRET: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d0de(value-a2) extra=1 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d118(value-a3) extra=0 flags_auto=0x0 flags=0x0\nCALL: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d118(value-a3) extra=0 flags_auto=0x0 flags=0x0\nRET: add_response_entry (DEFAULT): response=0x56137589b2a0 header=0x56134cd9d0b9(Header-Type-A) content=0x56134cd9d118(value-a3) extra=1 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d18c(a,b,c,d,e) extra=0 flags_auto=0x0 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d18c(a,b,c,d,e) extra=0 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d22f(i,k,l,m,n,o,p,close) extra=0 flags_auto=0x0 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d22f(i,k,l,m,n,o,p,close) extra=0 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d2eb(1,2,3,4,5,6,7,close) extra=0 flags_auto=0x0 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d2eb(1,2,3,4,5,6,7,close) extra=0 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d31a(8,9,close) extra=0 flags_auto=0x3 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d31a(8,9,close) extra=0 flags_auto=0x3 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d3f1(10,12) extra=0 flags_auto=0x3 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d3f1(10,12) extra=0 flags_auto=0x3 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x1 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x1 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x3 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x3 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x0 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x0 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x3 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d4b3(close) extra=0 flags_auto=0x3 flags=0x0\nENTRY: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=0x56134cd9d649(close,other-token) extra=0 flags_auto=0x0 flags=0x0\nBRANCH: CONNECTION: response=0x56137589b2a0 header=0x56134cd9d196(Connection) content=\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation would only occur if add_response_entry were declared to accept non-const char * parameters (thus discarding the const qualifier when called with const char *). However the provided test run shows the code compiled and executed calls to add_response_entry without casts or errors, which indicates add_response_entry already accepts const-qualified parameters (or otherwise no const-discard occurred). MISRA\u00a0C\u00a02023 Rule\u00a08.13 is about pointer declarations (parameters) being const-qualified when possible \u2014 the real fix would be to change add_response_entry's declaration if it were non-const. Given the observed behavior and absence of evidence that add_response_entry takes non-const pointers, the agent A report is not correct for the shown code."
}