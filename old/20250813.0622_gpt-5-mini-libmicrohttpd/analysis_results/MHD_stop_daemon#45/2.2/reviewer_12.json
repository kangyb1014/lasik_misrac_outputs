{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The mhd_assert macro is defined as ((void)0) in the provided project. Therefore the statement mhd_assert (1 < daemon->worker_pool_size); compiles to a no-op expression statement whose removal would not affect program behaviour. That is an executed operation with no effect and thus constitutes dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const MHD_socket MHD_INVALID_SOCKET = -1;\nstruct MHD_Worker {\n  bool shutdown;\n  uintptr_t itc;\n};\nextern void MHD_PANIC (const char *msg);\nextern void mhd_assert (int cond);\nextern bool MHD_thread_handle_ID_is_valid_handle_ (uintptr_t h);\nextern bool MHD_ITC_IS_VALID_ (uintptr_t itc);\nextern bool MHD_ITC_IS_INVALID_ (uintptr_t itc);\nextern bool MHD_itc_activate_ (uintptr_t itc, const char *sig);\nextern bool MHD_thread_handle_ID_join_thread_ (uintptr_t h);\nextern void MHD_itc_destroy_chk_ (uintptr_t itc);\nextern void MHD_socket_close_chk_ (int fd);\nextern void MHD_mutex_destroy_chk_ (void *m);\nextern bool MHD_D_IS_USING_THREADS_ (const struct MHD_Daemon *d);\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fputs(\"\\n\", f);\n  va_end(ap);\n  fclose(f);\n}\nstatic void mhd_probe_dump_daemon(const struct MHD_Daemon *d, const char *stage)\n{\n  if (d == NULL)\n  {\n    mhd_probe_log(\"[%s] daemon = NULL\", stage);\n    return;\n  }\n  /* Print the key fields used around the assertion of interest. */\n  mhd_probe_log(\"[%s] daemon=%p master=%p shutdown=%d was_quiesced=%d\\n\"\n                \"  options=0x%08x worker_pool=%p worker_pool_size=%u\\n\"\n                \"  tid=%p listen_fd=%d itc=%p\",\n                stage,\n                (const void *)d,\n                (const void *)d->master,\n                (int)d->shutdown,\n                (int)d->was_quiesced,\n                (unsigned int)d->options,\n                (const void *)d->worker_pool,\n                (unsigned int)d->worker_pool_size,\n                (const void *)(uintptr_t)d->tid,\n                (int)d->listen_fd,\n                (const void *)(uintptr_t)d->itc);\n}\n\nvoid\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  /* Log entry and initial state */\n  mhd_probe_dump_daemon(daemon, \"entry\");\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_probe_log(\"[pre-panic] shutdown already true and master==NULL -> panic\");\n    MHD_PANIC (\"MHD_stop_daemon() was called twice.\");\n  }\n\n  mhd_probe_log(\"[pre-assert-1] checking select/worker_pool/tid invariants\");\n  mhd_probe_dump_daemon(daemon, \"pre-assert-1\");\n  mhd_assert ((0 == (daemon->options & 0)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_probe_log(\"[post-assert-1] continued after assert (no side-effects should have occurred)\");\n\n  mhd_probe_log(\"[pre-assert-2] checking complementary invariants\");\n  mhd_probe_dump_daemon(daemon, \"pre-assert-2\");\n  mhd_assert (((0 != (daemon->options & 0)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_probe_log(\"[post-assert-2] continued after assert\");\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_probe_log(\"[pre-assert-3] slave/master assertion\");\n  mhd_probe_dump_daemon(daemon, \"pre-assert-3\");\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n  mhd_probe_log(\"[post-assert-3] continued after assert\");\n\n  daemon->shutdown = true;\n  mhd_probe_log(\"[state-change] set daemon->shutdown = true\");\n\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    /* Log the key values right before the assertion that is reported as\n     * dead code in the violation scenario. This gives exact evidence of\n     * the runtime values so other agents can reproduce the situation. */\n    mhd_probe_log(\"[worker-pool-branch] worker_pool != NULL. size=%u fd=%d itc=%p\",\n                  (unsigned int)daemon->worker_pool_size,\n                  (int)fd,\n                  (const void *)(uintptr_t)daemon->itc);\n\n    mhd_probe_dump_daemon(daemon, \"before-worker-pool-assert-size\");\n\n    /* This is the statement reported as dead code: log before and after\n     * so that the log file contains the fact that the statement was\n     * executed in the control flow and the value it referenced. */\n    mhd_probe_log(\"[pre-assert-worker-pool-size] executing mhd_assert(1 < daemon->worker_pool_size)\");\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_probe_log(\"[post-assert-worker-pool-size] executed assert; worker_pool_size=%u\",\n                  (unsigned int)daemon->worker_pool_size);\n\n    mhd_probe_log(\"[pre-assert-thread-check] checking thread usage\");\n    mhd_probe_dump_daemon(daemon, \"pre-assert-thread-check\");\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    mhd_probe_log(\"[post-assert-thread-check] continued after assert\");\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (\"Failed to signal shutdown via inter-thread communication channel.\\n\");\n      }\n      else\n        mhd_probe_log(\"[worker-loop] itc invalid for worker %u; fd=%d, asserting socket validity\", i, (int)fd);\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n      mhd_probe_log(\"[listen-shutdown] shutdown called on fd=%d\", (int)fd);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_probe_log(\"[recursive-stop] stopping worker daemon %u at %p\", i, (const void *)&daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_probe_log(\"[free] freed daemon->worker_pool\");\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_probe_log(\"[thread-using-branch] D_IS_USING_THREADS true\");\n      mhd_probe_dump_daemon(daemon, \"thread-using-branch\");\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (\"Failed to signal shutdown via inter-thread communication channel.\\n\");\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n          mhd_probe_log(\"[listen-shutdown] shutdown called on fd=%d by master==NULL branch\", (int)fd);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (\"Failed to join a thread.\\n\");\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_probe_log(\"[no-threads] calling close_all_connections for daemon=%p\", (const void *)daemon);\n      close_all_connections (daemon);\n    }\n    mhd_probe_log(\"[post-close] checking connection lists are empty\");\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      MHD_socket_close_chk_ (fd);\n      mhd_probe_log(\"[master-cleanup] closed listen fd=%d\", (int)fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      /* gnutls_dh_params_deinit (daemon->https_mem_dhparams); */\n      daemon->have_dhparams = false;\n      mhd_probe_log(\"[tls] deinitialized dhparams\");\n    }\n    if (0 != (daemon->options & 0))\n    {\n      /* gnutls_priority_deinit, gnutls_certificate_free_credentials, etc. */\n      mhd_probe_log(\"[tls] deinitialized TLS credentials\");\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n    mhd_probe_log(\"[dauth] freed auth resources\");\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n    mhd_probe_log(\"[exit] freed daemon memory (master) and exiting MHD_stop_daemon\");\n  }\n  else\n  {\n    mhd_probe_log(\"[exit] exiting MHD_stop_daemon (worker or non-master)\");\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. If, in the project, mhd_assert is defined as ((void)0) then each mhd_assert(\u2026) in MHD_stop_daemon becomes an evaluated void-expression statement with no side\u2011effects. Those statements are reachable in normal control flow and their removal would not alter program behaviour (including observable state or I/O), which matches the Rule 2.2 definition of dead code. Note that unreachable code would not be covered by Rule 2.2, but these assertions are reachable. To address the violation either enable a non\u2011no\u2011op assert implementation (so the statements have an observable effect), remove the redundant assertions, or document/approve the exception via the project\u2019s MISRA deviation procedure."
}