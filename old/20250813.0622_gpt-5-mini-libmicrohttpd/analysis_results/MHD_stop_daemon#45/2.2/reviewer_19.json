{
  "user_message": "An agent A claimed that the following MHD_stop_daemon code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_stop_daemon.\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the provided project mhd_assert is defined as ((void)0). Therefore the statement mhd_assert(NULL == daemon->connections_head); expands to a no-op (an executed statement with no effect). Removing that statement would not change program behaviour, so it constitutes dead code and thus violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef struct { int dummy; } MHD_thread_handle;\ntypedef struct { int dummy; } MHD_itc;\nstruct MHD_worker {\n    MHD_itc itc;\n    bool shutdown;\n};\nextern void mhd_assert (int cond);\nextern void MHD_PANIC (const char *msg);\nextern int MHD_thread_handle_ID_is_valid_handle_ (MHD_thread_handle tid);\nextern int MHD_ITC_IS_VALID_ (MHD_itc itc);\nextern int MHD_ITC_IS_INVALID_ (MHD_itc itc);\nextern int MHD_itc_activate_ (MHD_itc itc, const char *s);\nextern void MHD_itc_destroy_chk_ (MHD_itc itc);\nextern void MHD_socket_close_chk_ (MHD_socket fd);\nextern int MHD_D_IS_USING_THREADS_ (struct MHD_Daemon *daemon);\nextern int MHD_D_IS_USING_EPOLL_ (struct MHD_Daemon *daemon);\nextern void MHD_mutex_destroy_chk_ (void *mutex);\nextern int MHD_thread_handle_ID_join_thread_ (MHD_thread_handle tid);\nstatic void mhd_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/362.txt\", \"a\");\n    if (f == NULL)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  mhd_log(\"ENTER MHD_stop_daemon: daemon=%p\", (void *) (uintptr_t) daemon);\n\n  if (NULL == daemon)\n  {\n    mhd_log(\"EXIT MHD_stop_daemon: daemon is NULL\");\n    return;\n  }\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n  {\n    mhd_log(\"PANIC: MHD_stop_daemon() was called twice. shutdown=%d master=%p\", (int) daemon->shutdown, (void *) (uintptr_t) daemon->master);\n    MHD_PANIC (\"MHD_stop_daemon() was called twice.\");\n  }\n\n  /* Log state related to the assertion below. We intentionally log the\n   * component fields rather than invoking complex helpers that might have\n   * side-effects. This provides reproducible evidence about the runtime\n   * state at the point where mhd_assert is used. */\n  mhd_log(\"ASSERT_CHECK 1: options & MHD_USE_SELECT_INTERNALLY = 0x%llx, worker_pool=%p, tid=%p\",\n          (unsigned long long) (daemon->options & (unsigned long long)0xFFFFFFFFULL),\n          (void *) (uintptr_t) daemon->worker_pool,\n          /* tid may be an aggregate type on some platforms; take its address for logging */\n          (void *) &daemon->tid);\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  mhd_log(\"ASSERT_CHECK 2: (0 != (daemon->options & MHD_USE_SELECT_INTERNALLY))=%d, worker_pool=%p, tid_valid=%d\",\n          (int) (0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)),\n          (void *) (uintptr_t) daemon->worker_pool,\n          (int) MHD_thread_handle_ID_is_valid_handle_ (daemon->tid));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  mhd_log(\"ASSERT_CHECK 3: master=%p shutdown=%d\", (void *) (uintptr_t) daemon->master, (int) daemon->shutdown);\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  mhd_log(\"ACTION: daemon->shutdown set true\");\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  mhd_log(\"STATE: was_quiesced=%d fd=%d listen_fd=%d\", (int) daemon->was_quiesced, (int) fd, (int) daemon->listen_fd);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_log(\"BRANCH: master daemon with worker_pool, pool_size=%u\", daemon->worker_pool_size);\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      mhd_log(\"worker[%u].shutdown set true\", i);\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        mhd_log(\"worker[%u].itc is valid, activating ITC\", i);\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\");\n      }\n      else\n      {\n        mhd_log(\"worker[%u].itc is invalid, fd expected to be valid: fd=%d\", i, (int) fd);\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n      }\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_log(\"Calling shutdown(fd) for listen socket: fd=%d\", (int) fd);\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      mhd_log(\"Recursing into MHD_stop_daemon for worker[%u] at %p\", i, (void *) (uintptr_t) &daemon->worker_pool[i]);\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_log(\"Freed worker_pool\");\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_log(\"BRANCH: using internal threads, worker_pool_size=%u\", daemon->worker_pool_size);\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        mhd_log(\"Internal ITC valid, activating ITC\");\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\");\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (\"Failed to join a thread.\\n\");\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      mhd_log(\"BRANCH: no internal threads used for polling sockets \u2014 calling close_all_connections\");\n      close_all_connections (daemon);\n    }\n    mhd_log(\"ASSERT_CHECK connections_head=%p cleanup_head=%p suspended_connections_head=%p new_connections_head=%p\",\n            (void *) (uintptr_t) daemon->connections_head,\n            (void *) (uintptr_t) daemon->cleanup_head,\n            (void *) (uintptr_t) daemon->suspended_connections_head,\n            (void *) (uintptr_t) daemon->new_connections_head);\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      mhd_log(\"Destroying ITC for daemon: itc=%p\", (void *) &daemon->itc);\n      MHD_itc_destroy_chk_ (daemon->itc);\n    }\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n    {\n      mhd_log(\"Closing epoll_fd=%d\", (int) daemon->epoll_fd);\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n    {\n      mhd_log(\"Closing epoll_upgrade_fd=%d\", (int) daemon->epoll_upgrade_fd);\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    mhd_log(\"MASTER cleanup: master is NULL, performing master-only cleanup. fd=%d\", (int) fd);\n\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      mhd_log(\"Closing listen socket fd=%d\", (int) fd);\n      MHD_socket_close_chk_ (fd);\n    }\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      mhd_log(\"Deinitializing DH params\");\n      /* gnutls_dh_params_deinit (daemon->https_mem_dhparams); */\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      mhd_log(\"Deinitializing TLS credentials\");\n      /* gnutls_priority_deinit (daemon->priority_cache); */\n      if (daemon->x509_cred)\n        ; /* gnutls_certificate_free_credentials (daemon->x509_cred); */\n      if (daemon->psk_cred)\n        ; /* gnutls_psk_free_server_credentials (daemon->psk_cred); */\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    mhd_log(\"Freeing daemon structure at %p\", (void *) (uintptr_t) daemon);\n    free (daemon);\n  }\n  mhd_log(\"EXIT MHD_stop_daemon\");\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s reasoning is correct under the stated assumption. If in the project mhd_assert is defined as ((void)0), each mhd_assert(\u2026) call becomes an executed no-op expression statement. By the Rule 2.2 definition, an executed operation whose removal would not affect program behaviour is dead code, so those assertion statements (in that build configuration) are dead code and thus violate MISRA C 2023 Rule 2.2. The fact the provided test harness did not compile does not change the logical conclusion: in the actual project configuration where mhd_assert is a no-op, the assertions are dead. To fix or avoid the violation either ensure assertions have observable behaviour in that build, or prevent generation of the no-op statements (for example by conditioning the code with preprocessor guards so they are not present in the release build), or remove the redundant assertions for the release configuration."
}