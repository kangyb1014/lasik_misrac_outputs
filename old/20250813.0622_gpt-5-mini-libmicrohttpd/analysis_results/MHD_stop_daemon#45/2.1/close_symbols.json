{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_stop_daemon': {'callees': ['__builtin_unreachable', 'MHD_stop_daemon', 'close_all_connections'], 'callers': ['MHD_start_daemon_va', 'MHD_stop_daemon', 'main', 'run_mhd']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'close_all_connections': {'callees': ['__builtin_unreachable', 'new_connection_close_', 'resume_suspended_connections', 'MHD_DLOG', 'close_connection', 'MHD_cleanup_connections'], 'callers': ['MHD_polling_thread', 'MHD_stop_daemon']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}, 'run_mhd': {'callees': ['get_num_threads', 'print_perf_warnings', 'get_mhd_response_size', 'MHD_start_daemon', 'MHD_get_daemon_info', 'get_mhd_conn_limit', 'MHD_stop_daemon'], 'callers': ['main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon (full definition)",
    "mhd_assert (macro / implementation)",
    "MHD_PANIC (macro / function)",
    "__builtin_unreachable (compiler intrinsic)",
    "MHD_INVALID_SOCKET (constant)",
    "MHD_ITC_IS_VALID_ (macro)",
    "MHD_ITC_IS_INVALID_ (macro)",
    "MHD_itc_activate_ (function)",
    "MHD_itc_destroy_chk_ (function)",
    "MHD_thread_handle_ID_is_valid_handle_ (function/macro)",
    "MHD_thread_handle_ID_join_thread_ (function)",
    "MHD_D_IS_USING_THREADS_ (macro)",
    "MHD_D_IS_USING_EPOLL_ (macro)",
    "MHD_socket_close_chk_ (function)",
    "close_all_connections (function)",
    "MHD_mutex_destroy_chk_ (function)",
    "shutdown (system call) and HAVE_LISTEN_SHUTDOWN (compile-time macro)",
    "Compilation feature macros: MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS, EPOLL_SUPPORT, HTTPS_SUPPORT, UPGRADE_SUPPORT, DAUTH_SUPPORT, MHD_USE_SELECT_INTERNALLY, MHD_USE_TLS (option flag)"
  ],
  "explanation": "For determining whether any code in MHD_stop_daemon is unreachable (MISRA rule), the analyzer needs the definitions/semantics of the following symbols because they affect control-flow, conditional compilation, and whether called operations are non-returning:\n\n- struct MHD_Daemon (full definition): The function's control flow depends on many daemon fields (master, shutdown, was_quiesced, listen_fd, worker_pool, worker_pool_size, tid, itc, epoll_fd, epoll_upgrade_fd, connections_head, cleanup_head, suspended_connections_head, new_connections_head, urh_head, have_dhparams, options, credentials, etc.). Knowing field types and meaning is required to determine which branches are possible and thus whether later code is reachable.\n\n- mhd_assert (macro / implementation): Assertions can be compiled out or may expand to code that calls __builtin_unreachable or abort. The precise expansion determines whether paths guarded only by asserts are considered reachable or are marked unreachable.\n\n- MHD_PANIC (macro / function): Likely a non-returning error routine (abort/exit/longjmp). Any code following a call to MHD_PANIC is unreachable. Analyzer must know whether MHD_PANIC is non-returning.\n\n- __builtin_unreachable (compiler intrinsic): Used (directly or via asserts) to mark unreachable paths. Semantics needed so the analyzer can treat code after an occurrence as unreachable.\n\n- MHD_INVALID_SOCKET (constant): Used in runtime checks to decide whether to call shutdown/close \u2014 affects which branches execute.\n\n- MHD_ITC_IS_VALID_ and MHD_ITC_IS_INVALID_ (macros): Affect whether inter-thread communication handling branches (itc activate/destroy) are taken; the analyzer needs these predicates to decide reachability of branches using daemon->itc.\n\n- MHD_itc_activate_ and MHD_itc_destroy_chk_ (functions): itc_activate_ returns boolean; if false leads to MHD_PANIC (non-return). Knowing its return behavior and side effects is necessary to determine if subsequent code is reachable.\n\n- MHD_thread_handle_ID_is_valid_handle_ and MHD_thread_handle_ID_join_thread_ (functions/macros): The code asserts on validity and later joins the thread; join_thread_ can fail and lead to MHD_PANIC. Their behavior determines whether the path continues or is terminated.\n\n- MHD_D_IS_USING_THREADS_ and MHD_D_IS_USING_EPOLL_ (macros): Used to select major code paths (thread vs non-thread, epoll cleanup). Their definitions (how they inspect daemon->options/fields) are needed to know which blocks are present at runtime.\n\n- MHD_socket_close_chk_ (function): Called on epoll_fd and listen fd; knowledge not required for non-return but relevant to whether calls are reachable under given fd values.\n\n- close_all_connections (function): Called in the non-threaded path; that function itself may call __builtin_unreachable or non-returning functions. To reason about reachability into and out of that call site the analyzer needs its control-flow behavior.\n\n- MHD_mutex_destroy_chk_ (function): Called unconditionally in some paths; if it can abort on error, that affects reachability of later code.\n\n- shutdown (system call) and HAVE_LISTEN_SHUTDOWN (compile-time macro): The presence of the HAVE_LISTEN_SHUTDOWN branch and behavior of shutdown on the listen fd affect whether shutdown() calls are present in the control flow. The macro presence controls code inclusion.\n\n- Compilation feature macros (MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS, EPOLL_SUPPORT, HTTPS_SUPPORT, UPGRADE_SUPPORT, DAUTH_SUPPORT, MHD_USE_SELECT_INTERNALLY, and option flag MHD_USE_TLS): These determine which blocks of code are compiled in or out. For unreachable-code analysis you must know which of these macros are defined for the build being analyzed, as they can remove or add large portions of the function (making some code textually unreachable in that configuration).\n\nTogether, these symbols let an analyzer resolve which branches exist (compile-time and runtime), which calls may not return, and therefore which source statements are actually reachable in the build/configuration under analysis. Without them the analyzer cannot reliably decide whether identified code is truly unreachable or merely guarded by assertions/feature macros or terminated by a non-returning call."
}