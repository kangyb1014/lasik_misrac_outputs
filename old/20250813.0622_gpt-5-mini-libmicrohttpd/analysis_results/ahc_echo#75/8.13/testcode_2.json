{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function parameter 'struct MHD_Connection *connection' is not const-qualified even though the function does not modify the object pointed to. The pointer is only stored (req->connection = connection) and passed to other APIs (MHD_queue_response, MHD_suspend_connection) \u2014 therefore, unless the external API requires a non-const pointer, this parameter could be declared as 'const struct MHD_Connection *connection'. Declaring it non-const when it could be const violates MISRA C 2023 Rule 8.13.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified ahc_echo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/603.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct Request *req;\n  struct itimerspec ts;\n\n  (void) cls;\n  (void) method;\n  (void) version;           /* Unused. Silence compiler warning. */\n  (void) upload_data;       /* Unused. Silence compiler warning. */\n  (void) upload_data_size;  /* Unused. Silence compiler warning. */\n  req = *req_cls;\n  if (NULL == req)\n  {\n\n    req = malloc (sizeof(struct Request));\n    if (NULL == req)\n      return MHD_NO;\n    req->connection = connection;\n    req->timerfd = -1;\n    *req_cls = req;\n    return MHD_YES;\n  }\n\n  if (-1 != req->timerfd)\n  {\n    /* send response (echo request url) */\n    response = MHD_create_response_from_buffer_copy (strlen (url),\n                                                     (const void *) url);\n    if (NULL == response)\n      return MHD_NO;\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n  /* create timer and suspend connection */\n  req->timerfd = timerfd_create (CLOCK_MONOTONIC, TFD_NONBLOCK);\n  if (-1 == req->timerfd)\n  {\n    printf (\"timerfd_create: %s\", strerror (errno));\n    return MHD_NO;\n  }\n  evt.events = EPOLLIN;\n  evt.data.ptr = req;\n  if (-1 == epoll_ctl (epfd, EPOLL_CTL_ADD, req->timerfd, &evt))\n  {\n    printf (\"epoll_ctl: %s\", strerror (errno));\n    return MHD_NO;\n  }\n  ts.it_value.tv_sec = 1;\n  ts.it_value.tv_nsec = 0;\n  ts.it_interval.tv_sec = 0;\n  ts.it_interval.tv_nsec = 0;\n  if (-1 == timerfd_settime (req->timerfd, 0, &ts, NULL))\n  {\n    printf (\"timerfd_settime: %s\", strerror (errno));\n    return MHD_NO;\n  }\n  MHD_suspend_connection (connection);\n  return MHD_YES;\n}\n```\n</target_code>\nPlease provide the modified ahc_echo code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n\n/* Probe logging function: append timestamped messages to /tmp/logs/603.txt */\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/603.txt\", \"a\");\n  if (NULL == f)\n  {\n    /* If logging cannot be opened we silently continue to avoid altering program flow. */\n    return;\n  }\n\n  time_t t = time(NULL);\n  struct tm tm_buf;\n  (void)gmtime_r(&t, &tm_buf);\n  char timestr[64];\n  (void)strftime(timestr, sizeof(timestr), \"%Y-%m-%dT%H:%M:%SZ\", &tm_buf);\n\n  fprintf(f, \"%s pid=%d: \", timestr, (int)getpid());\n\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  struct Request *req;\n  struct itimerspec ts;\n\n  (void) cls;\n  (void) method;\n  (void) version;           /* Unused. Silence compiler warning. */\n  (void) upload_data;       /* Unused. Silence compiler warning. */\n  (void) upload_data_size;  /* Unused. Silence compiler warning. */\n\n  /* Log entry and incoming state */\n  probe_log(\"ahc_echo entry: connection=%p, url=%s, req_cls=%p, *req_cls=%p\",\n            (void *) connection,\n            (url != NULL) ? url : \"(null)\",\n            (void *) req_cls,\n            (void *) (req_cls ? *req_cls : NULL));\n\n  req = *req_cls;\n  if (NULL == req)\n  {\n    probe_log(\"no existing request object; allocating new Request\");\n\n    req = malloc (sizeof(struct Request));\n    if (NULL == req)\n    {\n      probe_log(\"malloc failed: errno=%d (%s)\", errno, strerror(errno));\n      return MHD_NO;\n    }\n\n    probe_log(\"allocated Request at %p\", (void *) req);\n\n    /* store the connection pointer in the request (no modification of *connection) */\n    req->connection = connection;\n    probe_log(\"stored connection pointer in req->connection: %p\", (void *) req->connection);\n\n    req->timerfd = -1;\n    *req_cls = req;\n    probe_log(\"returning MHD_YES after initial allocation; req_cls now points to %p\", (void *) *req_cls);\n    return MHD_YES;\n  }\n\n  probe_log(\"found existing Request at %p; timerfd=%d\", (void *) req, req->timerfd);\n\n  if (-1 != req->timerfd)\n  {\n    /* send response (echo request url) */\n    probe_log(\"timerfd active, preparing response for url=%s\", (url != NULL) ? url : \"(null)\");\n    response = MHD_create_response_from_buffer_copy (strlen (url),\n                                                     (const void *) url);\n    if (NULL == response)\n    {\n      probe_log(\"MHD_create_response_from_buffer_copy returned NULL\");\n      return MHD_NO;\n    }\n\n    probe_log(\"calling MHD_queue_response(connection=%p, code=%d, response=%p)\",\n              (void *) connection, MHD_HTTP_OK, (void *) response);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    probe_log(\"MHD_queue_response returned %d\", (int) ret);\n    MHD_destroy_response (response);\n    probe_log(\"destroyed response %p and returning %d\", (void *) response, (int) ret);\n    return ret;\n  }\n\n  /* create timer and suspend connection */\n  probe_log(\"creating timerfd for Request at %p\", (void *) req);\n  req->timerfd = timerfd_create (CLOCK_MONOTONIC, TFD_NONBLOCK);\n  if (-1 == req->timerfd)\n  {\n    probe_log(\"timerfd_create failed: errno=%d (%s)\", errno, strerror(errno));\n    return MHD_NO;\n  }\n  probe_log(\"created timerfd=%d for Request %p\", req->timerfd, (void *) req);\n\n  evt.events = EPOLLIN;\n  evt.data.ptr = req;\n  probe_log(\"adding timerfd=%d to epoll (epfd=%d)\", req->timerfd, epfd);\n  if (-1 == epoll_ctl (epfd, EPOLL_CTL_ADD, req->timerfd, &evt))\n  {\n    probe_log(\"epoll_ctl failed: errno=%d (%s)\", errno, strerror(errno));\n    return MHD_NO;\n  }\n\n  ts.it_value.tv_sec = 1;\n  ts.it_value.tv_nsec = 0;\n  ts.it_interval.tv_sec = 0;\n  ts.it_interval.tv_nsec = 0;\n  probe_log(\"setting timerfd=%d timeout to 1s\", req->timerfd);\n  if (-1 == timerfd_settime (req->timerfd, 0, &ts, NULL))\n  {\n    probe_log(\"timerfd_settime failed: errno=%d (%s)\", errno, strerror(errno));\n    return MHD_NO;\n  }\n\n  probe_log(\"suspending connection %p (no modification of the object pointed to)\", (void *) connection);\n  MHD_suspend_connection (connection);\n  probe_log(\"connection %p suspended; returning MHD_YES\", (void *) connection);\n  return MHD_YES;\n}\n"
}