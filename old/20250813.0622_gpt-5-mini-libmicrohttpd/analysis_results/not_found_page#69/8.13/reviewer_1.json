{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'struct Session *session' is declared as a pointer to a non-const type but is unused (and not modified or passed to APIs that require a non-const pointer). It could and should be declared 'const struct Session *session' so the pointer points to a const-qualified type.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_write_line(const char *line)\n{\n  FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"%s\\n\", line);\n    fclose(f);\n  }\n}\nstatic void probe_log_params(const void *cls,\n                             const char *mime,\n                             struct Session *session,\n                             struct MHD_Connection *connection)\n{\n  FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f,\n            \"not_found_page: enter - cls=%p mime=%s session=%p connection=%p\\n\",\n            cls,\n            (mime != NULL) ? mime : \"(null)\",\n            (void *) session,\n            (void *) connection);\n    fclose(f);\n  }\n}\nstatic void probe_log_response_creation(struct MHD_Response *response)\n{\n  FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n  if (f)\n  {\n    if (NULL == response)\n      fprintf(f, \"not_found_page: response creation FAILED (NULL)\\n\");\n    else\n      fprintf(f, \"not_found_page: response created at %p\\n\", (void *) response);\n    fclose(f);\n  }\n}\nstatic void probe_log_queue_and_header(enum MHD_Result ret,\n                                       int header_ok)\n{\n  FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"not_found_page: MHD_queue_response returned %d\\n\", (int) ret);\n    if (header_ok)\n      fprintf(f, \"not_found_page: header add succeeded\\n\");\n    else\n      fprintf(f, \"not_found_page: header add FAILED\\n\");\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n\n  /* Probe: log entry and parameters */\n  probe_log_params(cls, mime, session, connection);\n\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Capture pointer value to show session is not modified by this function */\n  {\n    FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"not_found_page: session pointer observed (should remain unchanged) = %p\\n\", (void *) session);\n      fclose(f);\n    }\n  }\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n\n  /* Probe: log whether response creation succeeded */\n  probe_log_response_creation(response);\n\n  if (NULL == response)\n    return MHD_NO;\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  /* Preserve original logic but capture header add result for logging */\n  {\n    int header_ok = (MHD_YES ==\n                     MHD_add_response_header (response,\n                                              MHD_HTTP_HEADER_CONTENT_ENCODING,\n                                              mime));\n    if (!header_ok)\n    {\n      fprintf (stderr,\n               \"Failed to set content encoding header!\\n\");\n    }\n\n    /* Probe: log queue/header outcomes */\n    probe_log_queue_and_header(ret, header_ok);\n  }\n\n  MHD_destroy_response (response);\n\n  /* Probe: final state before return */\n  {\n    FILE *f = fopen(\"/tmp/logs/555.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"not_found_page: exit - returning %d; session still = %p\\n\", (int) ret, (void *) session);\n      fclose(f);\n    }\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 8.13 recommends that a pointer should point to a const-qualified type whenever possible. In the shown code the parameter 'struct Session *session' is not modified and is only cast to void to suppress an \"unused\" warning, so there is no need for it to be a pointer to a mutable object. Because the function is declared static (internal linkage) there is no external prototype forcing a non-const parameter, so the parameter could and should be declared 'const struct Session *session' to comply with Rule 8.13. (If, conversely, this function were required to match an external API that mandates a non-const signature, that would be a legitimate reason not to change it.)"
}