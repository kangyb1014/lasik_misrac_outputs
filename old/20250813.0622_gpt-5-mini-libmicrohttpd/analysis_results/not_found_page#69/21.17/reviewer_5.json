{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memcmp(hdr->value, \"close\", 5) unconditionally reads 5 bytes from hdr->value. If an existing \"Connection\" header entry has value_size < 5 (for example a short value like \"on\", an empty string, or any user-provided header shorter than \"close\"), memcmp will access bytes beyond the hdr->value buffer. Thus this use can result in out-of-bounds access and violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_append (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/559.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  (void) vfprintf (f, fmt, ap);\n  va_end (ap);\n  (void) fclose (f);\n}\nstatic size_t\nsafe_strnlen (const char *s, size_t max)\n{\n  size_t i = 0;\n  if (NULL == s)\n    return 0u;\n  while (i < max && s[i] != '\\0')\n  {\n    ++i;\n  }\n  return i;\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Log entry and parameter state for diagnostics. */\n  {\n    /* Record entry into the handler and pointer values. */\n    probe_log_append (\"[not_found_page] ENTER\\n\");\n    probe_log_append (\"[not_found_page] cls=%p session=%p connection=%p\\n\",\n                      (const void *) cls, (const void *) session, (const void *) connection);\n    if (NULL == mime)\n    {\n      probe_log_append (\"[not_found_page] mime=NULL\\n\");\n    }\n    else\n    {\n      /* Limit how many bytes we will inspect when logging to avoid reading large/invalid memory. */\n      size_t len = safe_strnlen (mime, 256u);\n      char buf[257];\n      /* Copy up to len bytes and NUL-terminate. */\n      if (len > 0u)\n      {\n        (void) memcpy (buf, mime, len);\n      }\n      buf[len] = '\\0';\n      probe_log_append (\"[not_found_page] mime_len=%zu mime_preview='%s'\\n\", len, buf);\n    }\n  }\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n  {\n    probe_log_append (\"[not_found_page] MHD_create_response_from_buffer_static returned NULL\\n\");\n    return MHD_NO;\n  }\n\n  probe_log_append (\"[not_found_page] response=%p (created)\\n\", (const void *) response);\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n\n  probe_log_append (\"[not_found_page] MHD_queue_response returned=%d\\n\", (int) ret);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    probe_log_append (\"[not_found_page] MHD_add_response_header FAILED for mime=%p\\n\",\n                      (const void *) mime);\n  }\n  else\n  {\n    probe_log_append (\"[not_found_page] MHD_add_response_header succeeded for mime=%p\\n\",\n                      (const void *) mime);\n  }\n\n  MHD_destroy_response (response);\n  probe_log_append (\"[not_found_page] EXIT ret=%d\\n\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not applicable to the provided not_found_page code. The agent's scenario refers to a memcmp(hdr->value, \"close\", 5) that may read beyond hdr->value; there is no memcmp (nor any hdr->value handling) in the target not_found_page implementation. The only use of string.h in the original snippet is strlen(NOT_FOUND_ERROR) applied to a string literal (or otherwise NUL-terminated constant), which does not cause out-of-bounds access. In the supplied test/diagnostic variant the manual safe_strnlen limits the inspected bytes and the subsequent memcpy copies at most that bounded length into a buffer sized to hold it plus a terminating NUL \u2014 this is also safe. Therefore the specific Rule 21.17 violation claimed by agent A is incorrect for the shown code. (Note: other issues \u2014 e.g. passing a NULL mime to MHD_add_response_header or assumptions about external API contracts \u2014 are separate concerns, but they are not the memcmp-based out-of-bounds string.h violation described.)"
}