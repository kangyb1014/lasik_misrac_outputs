{
  "user_message": "An agent A claimed that the following not_found_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of not_found_page.\n```c\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function add_response_entry calls strlen(header) and strlen(content) without validating that header is non-NULL or that either pointer references a NUL-terminated object. If add_response_entry is invoked with header == NULL then strlen(header) dereferences a NULL pointer (out-of-bounds/undefined access). Likewise if either header or content points to a buffer that is not NUL-terminated within its allocated bounds, strlen will read past the object boundary. For example: add_response_entry(..., header = NULL, content = \"ok\") or add_response_entry(..., header = \"X\", content = ptr_to_non_terminated_buffer) will cause out-of-bounds accesses.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n  struct timespec ts;\n  char timestr[64];\n\n  /* Ensure directory exists (best-effort; ignore errors). */\n  (void) mkdir (\"/tmp/logs\", 0755);\n\n  f = fopen (\"/tmp/logs/559.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  if (clock_gettime (CLOCK_REALTIME, &ts) == 0)\n    {\n      struct tm tm;\n      if (localtime_r (&ts.tv_sec, &tm) != NULL)\n        strftime (timestr, sizeof (timestr), \"%Y-%m-%d %H:%M:%S\", &tm);\n      else\n        snprintf (timestr, sizeof (timestr), \"unknown-time\");\n    }\n  else\n    snprintf (timestr, sizeof (timestr), \"unknown-time\");\n\n  fprintf (f, \"[%s] \", timestr);\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n\n  /* Silent compiler warnings for unused args retained. */\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* Log entry and incoming parameter state (do not dereference mime). */\n  log_probe (\"entered not_found_page: cls=%p mime=%p session=%p connection=%p\",\n             cls, (const void *) mime, (const void *) session, (const void *) connection);\n  log_probe (\"mime pointer is %s\", (mime != NULL) ? \"non-NULL\" : \"NULL\");\n\n  /* Log the length of the static NOT_FOUND_ERROR constant before using it. */\n  {\n    size_t not_found_len = strlen (NOT_FOUND_ERROR);\n    log_probe (\"NOT_FOUND_ERROR length=%zu\", not_found_len);\n  }\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n\n  if (NULL == response)\n    {\n      log_probe (\"MHD_create_response_from_buffer_static returned NULL, returning MHD_NO\");\n      return MHD_NO;\n    }\n\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  log_probe (\"MHD_queue_response returned %d\", (int) ret);\n\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    /* Preserve original stderr message, but also log. */\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    log_probe (\"MHD_add_response_header failed: response=%p mime=%p\",\n               (void *) response, (const void *) mime);\n    log_probe (\"mime pointer is %s\", (mime != NULL) ? \"non-NULL\" : \"NULL\");\n  }\n\n  MHD_destroy_response (response);\n  log_probe (\"exiting not_found_page with ret=%d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for not_found_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The provided not_found_page implementation only calls strlen() on NOT_FOUND_ERROR (a compile-time/static string constant) \u2014 that is safe provided NOT_FOUND_ERROR is a NUL-terminated string literal or otherwise a properly terminated object. The agent\u2019s scenario describes calls to strlen(header) and strlen(content) inside an add_response_entry function (and dereferencing header==NULL), but that function and those calls do not appear in the supplied not_found_page code. The call to MHD_add_response_header(response, ..., mime) passes mime to a library function; MISRA C:2023 Rule 21.17 concerns direct use of <string.h> functions (memcpy, strlen, etc.) and ensuring those calls cannot read past object bounds. Unless NOT_FOUND_ERROR were non-NUL-terminated (unlikely) or the code itself called strlen on mime/header pointers without validation, Rule 21.17 is not violated here. (Separately, it may be good defensive practice to validate pointers documented as non-NULL before passing them to library functions, but that is not the specific MISRA 21.17 violation claimed.)"
}