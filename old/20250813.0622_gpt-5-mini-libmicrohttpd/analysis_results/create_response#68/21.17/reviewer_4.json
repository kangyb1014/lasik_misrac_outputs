{
  "user_message": "An agent A claimed that the following create_response code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of create_response.\n```c\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strcmp(method, MHD_HTTP_METHOD_POST) can read beyond the bounds of the object referenced by 'method' if 'method' is NULL or not NUL-terminated. The code does not check that 'method' is non-NULL (or a valid NUL-terminated string) before calling strcmp, so a NULL or unterminated 'method' will cause out-of-bounds access and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_state(const char *stage,\n                const char *url,\n                const char *method,\n                const char *version,\n                const char *upload_data,\n                const size_t *upload_data_size,\n                void **req_cls)\n{\n  FILE *fp = fopen(\"/tmp/logs/551.txt\", \"a\");\n  if (NULL == fp)\n    return;\n\n  fprintf(fp, \"[probe] stage=%s; url=%p; method=%p; version=%p; upload_data=%p; upload_data_size_ptr=%p; req_cls_ptr=%p\",\n          stage,\n          (void *) url,\n          (void *) method,\n          (void *) version,\n          (void *) upload_data,\n          (void *) upload_data_size,\n          (void *) req_cls);\n  if (NULL != upload_data_size)\n  {\n    fprintf(fp, \"; *upload_data_size=%zu\", *upload_data_size);\n  }\n  fprintf(fp, \"\\n\");\n  fclose(fp);\n}\nstatic void\nprobe_before_strcmp(const char *label, const char *method, const char *cmp)\n{\n  FILE *fp = fopen(\"/tmp/logs/551.txt\", \"a\");\n  if (NULL == fp)\n    return;\n\n  fprintf(fp, \"[probe] about to strcmp() - label=%s; method_ptr=%p; cmp_ptr=%p; method_is_NULL=%s\\n\",\n          label,\n          (void *) method,\n          (void *) cmp,\n          (method == NULL) ? \"yes\" : \"no\");\n  fclose(fp);\n}\n\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  /* Log entry state */\n  probe_log_state(\"entry\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    /* Log that we are in the request==NULL branch */\n    probe_log_state(\"request_null_before_alloc\", url, method, version, upload_data, upload_data_size, req_cls);\n\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      probe_log_state(\"calloc_failed\", url, method, version, upload_data, upload_data_size, req_cls);\n      return MHD_NO;\n    }\n    *req_cls = request;\n\n    /* Log right before the risky strcmp call */\n    probe_before_strcmp(\"initial_post_check\", method, MHD_HTTP_METHOD_POST);\n\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        probe_log_state(\"post_processor_failed\", url, method, version, upload_data, upload_data_size, req_cls);\n        return MHD_NO; /* internal error */\n      }\n    }\n    probe_log_state(\"request_allocated_after_post_check\", url, method, version, upload_data, upload_data_size, req_cls);\n    return MHD_YES;\n  }\n\n  /* Log entering existing-request path */\n  probe_log_state(\"existing_request_path_entry\", url, method, version, upload_data, upload_data_size, req_cls);\n\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      probe_log_state(\"get_session_failed\", url, method, version, upload_data, upload_data_size, req_cls);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n\n  /* Log right before POST-processing strcmp */\n  probe_before_strcmp(\"post_processing_check\", method, MHD_HTTP_METHOD_POST);\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n\n    probe_log_state(\"after_post_handling\", url, method, version, upload_data, upload_data_size, req_cls);\n  }\n\n  /* Log right before GET/HEAD branch check */\n  probe_before_strcmp(\"get_head_check_GET\", method, MHD_HTTP_METHOD_GET);\n  probe_before_strcmp(\"get_head_check_HEAD\", method, MHD_HTTP_METHOD_HEAD);\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    probe_log_state(\"returning_from_get_head\", url, method, version, upload_data, upload_data_size, req_cls);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  probe_log_state(\"unsupported_method_response\", url, method, version, upload_data, upload_data_size, req_cls);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for create_response. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct: the code calls strcmp() on the incoming method parameter without validating it, so the use of the string.h function can result in out-of-bounds accesses if the caller supplies a NULL pointer or a non-NUL-terminated buffer. MISRA C:2023 Rule 21.17 requires that uses of the standard string functions must not be able to read beyond the bounds of the referenced objects. The code as shown does not check method != NULL nor otherwise ensure method is a valid NUL-terminated string before calling strcmp, so the call is potentially non-compliant. Note: if the surrounding API (libmicrohttpd) formally guarantees that the method argument is always non-NULL and NUL-terminated, then the calls would be safe in practice \u2014 in that case you must document and rely on that contract to satisfy MISRA. As written (without such documented precondition or explicit validation), the report of a Rule 21.17 violation is correct. Also consider similar risks for other strcmp calls (e.g. comparing with url) and fix by validating pointers or using bounded APIs / documented preconditions."
}