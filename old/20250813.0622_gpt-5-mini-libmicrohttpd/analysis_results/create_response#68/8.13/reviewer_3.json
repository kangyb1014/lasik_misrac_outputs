{
  "user_message": "An agent A claimed that the following create_response code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of create_response.\n```c\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'cls' is declared as void * but is not modified (only cast to void to silence warnings). It could and should be declared as const void * (or void const *) to indicate it points to read\u2011only data. Therefore Rule 8.13 is violated. (Other input pointers such as 'url', 'method', 'version', and 'upload_data' are already const-qualified. Parameters like 'req_cls' and 'upload_data_size' are intentionally non-const because the function writes through them.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret = MHD_NO;\n  unsigned int i;\n  FILE *log = fopen(\"/tmp/logs/547.txt\", \"a\");\n  void *orig_cls = cls;\n\n  /* Log entry with parameter/state snapshot. Use safe prints for possibly NULL strings */\n  if (log)\n  {\n    fprintf(log, \"create_response: entry\\n\");\n    fprintf(log, \"  cls=%p url=%s method=%s version=%s\\n\",\n            orig_cls,\n            (url != NULL) ? url : \"(null)\",\n            (method != NULL) ? method : \"(null)\",\n            (version != NULL) ? version : \"(null)\");\n    fprintf(log, \"  upload_data=%p upload_data_size_ptr=%p upload_data_size_value=%zu\\n\",\n            (const void *) upload_data,\n            (void *) upload_data_size,\n            (upload_data_size != NULL) ? *upload_data_size : (size_t)0);\n    fprintf(log, \"  req_cls_ptr=%p *req_cls=%p\\n\",\n            (void *) req_cls,\n            (void *) ((req_cls != NULL) ? *req_cls : NULL));\n    fflush(log);\n  }\n\n  (void) version;           /* Unused (still), silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      if (log)\n      {\n        fprintf(log, \"  calloc failed errno=%d (%s)\\n\", errno,\n                strerror (errno));\n        fflush(log);\n      }\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      ret = MHD_NO;\n      goto LOG_AND_RETURN;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        if (log)\n        {\n          fprintf(log, \"  Failed to setup post processor for `%s'\\n\",\n                  (url != NULL) ? url : \"(null)\");\n          fflush(log);\n        }\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        ret = MHD_NO; /* internal error */\n        goto LOG_AND_RETURN;\n      }\n    }\n    ret = MHD_YES;\n    goto LOG_AND_RETURN;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      if (log)\n      {\n        fprintf(log, \"  Failed to setup session for `%s'\\n\",\n                (url != NULL) ? url : \"(null)\");\n        fflush(log);\n      }\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      ret = MHD_NO; /* internal error */\n      goto LOG_AND_RETURN;\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n    {\n      ret = MHD_NO;\n      goto LOG_AND_RETURN;\n    }\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      ret = MHD_YES;\n      goto LOG_AND_RETURN;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n    {\n      if (log)\n      {\n        fprintf(log, \"  Failed to create page for `%s' -> ret=%d\\n\",\n                (url != NULL) ? url : \"(null)\", (int) ret);\n        fflush(log);\n      }\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    }\n    goto LOG_AND_RETURN;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n\nLOG_AND_RETURN:\n  /* Log exit and whether 'cls' was modified inside the function. The violation scenario\n     claims 'cls' is unused (only cast to void). We capture evidence whether it changed. */\n  if (log)\n  {\n    fprintf(log, \"create_response: exit final_ret=%d\\n\", (int) ret);\n    fprintf(log, \"  cls_orig=%p cls_now=%p cls_changed=%s\\n\",\n            orig_cls, cls, (orig_cls == cls) ? \"no\" : \"yes\");\n    /* Log current request pointer state to help reproduce scenario */\n    fprintf(log, \"  req_cls_ptr=%p *req_cls=%p\\n\",\n            (void *) req_cls,\n            (void *) ((req_cls != NULL) ? *req_cls : NULL));\n    fflush(log);\n    fclose(log);\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for create_response. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Rule 8.13 says a pointer should point to a const-qualified type whenever possible, and indeed the local use of cls shows it is not modified. However create_response is an implementation of a library callback whose prototype (libmicrohttpd) requires the first parameter to be void *cls. That external API imposes the non\u2011const type; you cannot change the function signature to const void * without breaking the required callback type. MISRA\u2019s \u201cshould\u201d guidance is applied \u201cwhenever possible\u201d \u2014 when the type is externally mandated by an API it is not possible to make it const. Therefore this is a false positive: the code cannot reasonably be changed and the report is not correct. If desired, document/justify the deviation (or suppress the diagnostic) rather than changing the signature."
}