{
  "user_message": "An agent A claimed that the following create_response code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of create_response.\n```c\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:METHOD_ERROR is (or expands to) a non-const string (e.g. a char[] or char * pointing to a string literal) and is explicitly cast to (const void *) when passed to MHD_create_response_from_buffer_static. MISRA C 2023 Rule 8.13 expects pointers to point to const-qualified types when modification is not required; here the underlying object is not declared const and the code relies on a cast to add const qualification rather than declaring METHOD_ERROR as const (e.g. const char[] or const char *).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/547.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputs (\"\\n\", f);\n  fflush (f);\n  fclose (f);\n}\n\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  probe_log (\"ENTER create_response: url='%s' method='%s' version='%s' upload_data_size=%zu\",\n             url ? url : \"(null)\", method ? method : \"(null)\",\n             version ? version : \"(null)\", upload_data_size ? *upload_data_size : 0);\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    probe_log (\"request is NULL: allocating Request for url='%s' method='%s'\", url ? url : \"(null)\", method ? method : \"(null)\");\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      probe_log (\"calloc error: %s\", strerror (errno));\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      probe_log (\"method POST: setting up post processor for url='%s'\", url ? url : \"(null)\");\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        probe_log (\"Failed to setup post processor for '%s'\", url ? url : \"(null)\");\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    probe_log (\"initial request created and stored in req_cls\");\n    return MHD_YES;\n  }\n  probe_log (\"existing request found in req_cls\");\n\n  if (NULL == request->session)\n  {\n    probe_log (\"request->session is NULL: obtaining session for connection\");\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      probe_log (\"Failed to setup session for '%s'\", url ? url : \"(null)\");\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  probe_log (\"session start set: start=%ld\", (long) session->start);\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    probe_log (\"processing POST data: upload_data_size=%zu\", upload_data_size ? *upload_data_size : 0);\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      probe_log (\"POST upload_data remaining: %zu -> reset to 0 and return MHD_YES\", *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    probe_log (\"done with POST data: destroying post processor and converting to GET\");\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n    {\n      url = request->post_url;\n      probe_log (\"using post_url='%s'\", url ? url : \"(null)\");\n    }\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    probe_log (\"serving GET/HEAD for url='%s'\", url ? url : \"(null)\");\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    probe_log (\"selected page index=%u url='%s' handler=%p\", i, pages[i].url ? pages[i].url : \"(null)\", (void *) pages[i].handler);\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    probe_log (\"page handler returned %d for url='%s'\", (int) ret, url ? url : \"(null)\");\n    return ret;\n  }\n  /* unsupported HTTP method */\n\n  /* Log detailed evidence for the violation scenario: METHOD_ERROR is passed\n     to MHD_create_response_from_buffer_static with an explicit cast to const void *.\n     We record the pointer value and the length used. */\n  probe_log (\"unsupported method '%s' for url='%s' -> preparing METHOD_ERROR response\", method ? method : \"(null)\", url ? url : \"(null)\");\n  probe_log (\"METHOD_ERROR pointer=%p strlen=%zu casting to (const void *) and passing to MHD_create_response_from_buffer_static\",\n             (const void *) METHOD_ERROR, strlen (METHOD_ERROR));\n\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  probe_log (\"MHD_create_response_from_buffer_static returned response=%p\", (void *) response);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  probe_log (\"MHD_queue_response returned %d; destroying response %p\", (int) ret, (void *) response);\n  MHD_destroy_response (response);\n  probe_log (\"exit create_response returning %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for create_response. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct under the scenario they described. Rule 8.13 requires that pointers point to const-qualified types whenever possible. In the shown code the string object METHOD_ERROR is passed to a function that expects a const-qualified pointer via an explicit cast: (const void *) METHOD_ERROR. If METHOD_ERROR itself is declared without const (e.g. as char[] or char *), then the code is effectively relying on a cast to add const qualification instead of declaring the object as const. That hides the fact that the object should have been const-qualified and therefore breaches the intent of MISRA C 2023 Rule 8.13. The proper fix is to declare METHOD_ERROR as const char[] or const char * (or otherwise ensure the object has a const-qualified type) and then pass it (no cast required) to MHD_create_response_from_buffer_static. If METHOD_ERROR is already declared const, then there is no violation."
}