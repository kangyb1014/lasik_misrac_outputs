{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "CPU_COUNT",
    "CPU_COUNT_S",
    "CPU_ISSET",
    "CPU_SETSIZE_SAFE",
    "CPU_SETSIZE",
    "CPU_ALLOC",
    "CPU_ALLOC_SIZE",
    "CPU_FREE",
    "cpuset_getaffinity",
    "cpuset_t",
    "id_t",
    "CPU_LEVEL_WHICH",
    "CPU_WHICH_PID",
    "MHD_FUNC_CPU_COUNT_S_GETS_CPUS",
    "HAVE_CPUSET_GETAFFINITY",
    "HAVE_CPU_COUNT",
    "HAVE_CPU_COUNT_S"
  ],
  "explanation": "To determine whether the function uses any compiler language extensions you must inspect the definitions and configuration macros used inside it. The listed symbols are required for that inspection for these reasons:\n\n- CPU_COUNT: macro/function used to count CPUs; implementations in system headers often use GCC extensions (e.g. statement expressions, typeof, builtins). We must see its definition to detect any non\u2011standard constructs.\n- CPU_COUNT_S: alternative count routine whose signature/implementation can differ (and may use extensions). The code selects between two different parameter conventions via MHD_FUNC_CPU_COUNT_S_GETS_CPUS, so the exact definition is needed.\n- CPU_ISSET: macro that checks a bit in cpuset; may be implemented with bit\u2011manipulation macros or compiler extensions \u2014 inspect definition.\n- CPU_SETSIZE_SAFE: size constant used in the loop; its definition may be computed via other macros or expressions that could use extensions.\n- CPU_SETSIZE: base CPU set size used to compute mask_size_cpus; definition needed to understand arithmetic and any macros that might use extensions.\n- CPU_ALLOC / CPU_ALLOC_SIZE / CPU_FREE: allocation helpers for cpusets. These are often macros or inline functions which can use non\u2011standard features (alloca, GCC statement expressions, attributes). Their definitions must be checked.\n- cpuset_getaffinity: the function/macro invoked to get the cpuset. On some platforms this could be a macro wrapper or inline with syscall macros that use compiler extensions; inspect its declaration/definition.\n- cpuset_t: the CPU set type. Its underlying type/definition could use compiler extensions (e.g. unnamed/anonymous structs, compiler attributes) that violate the rule.\n- id_t: type used in the cpuset_getaffinity call; inspect typedef (from sys/types) to ensure no extensions are present.\n- CPU_LEVEL_WHICH / CPU_WHICH_PID: constants/macros passed to cpuset_getaffinity; their definitions could be macros that rely on extensions (less likely, but verify).\n- MHD_FUNC_CPU_COUNT_S_GETS_CPUS: build macro that changes how CPU_COUNT_S is called (bytes vs element count). Its value affects which form of CPU_COUNT_S is used and thus which implementation must be inspected.\n- HAVE_CPUSET_GETAFFINITY, HAVE_CPU_COUNT, HAVE_CPU_COUNT_S: configuration macros that determine which code paths compile. You must know their values to know which macros/functions are actually active so you can inspect only the relevant definitions for extensions.\n\nIn short: inspect the definitions of the macros, types, and configuration flags above to detect any use of compiler-specific language extensions (e.g., GCC statement expressions, typeof, inline asm, attributes, __extension__ constructs)."
}