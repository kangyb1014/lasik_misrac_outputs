{
  "user_message": "An agent A claimed that the following process_value code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of process_value.\n```c\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta;\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        return;\n      }\n    }\n    pp->value_offset += xoff;\n    if (cut)\n      break;\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n    }\n    xoff = clen;\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the fragment, the pointer parameter 'value_start' (declared as 'const char *value_start') is incremented with 'value_start += delta', i.e. the pointer parameter itself is reassigned. MISRA C 2023 Rule 17.8 forbids modifying a function parameter (the pointer itself shall not be modified). This is a direct violation. A correct approach is to copy the parameter into a local pointer (e.g. 'const char *p = value_start') and update that local variable instead, or use an offset index.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *event,\n           const struct MHD_PostProcessor *pp,\n           const char *value_start,\n           const char *value_end,\n           const char *last_escape,\n           size_t xoff,\n           size_t delta,\n           bool cut,\n           size_t clen)\n{\n  FILE *f = fopen(\"/tmp/logs/653.txt\", \"a\");\n  if (NULL == f)\n    return;\n  /* Print pointer addresses and some pp state so other agents can reproduce */\n  fprintf (f,\n           \"%s: value_start=%p value_end=%p last_escape=%p xbuf_pos=%zu xoff=%zu delta=%zu cut=%d clen=%zu value_offset=%zu must_ikvi=%d state=%d\\n\",\n           event,\n           (const void *) value_start,\n           (const void *) value_end,\n           (const void *) last_escape,\n           (size_t) pp->xbuf_pos,\n           xoff,\n           delta,\n           cut ? 1 : 0,\n           clen,\n           (size_t) pp->value_offset,\n           pp->must_ikvi ? 1 : 0,\n           (int) pp->state);\n  fclose (f);\n}\n\nstatic void\nprocess_value (struct MHD_PostProcessor *pp,\n               const char *value_start,\n               const char *value_end,\n               const char *last_escape)\n{\n  char xbuf[XBUF_SIZE + 1];\n  size_t xoff;\n\n  mhd_assert (pp->xbuf_pos < sizeof (xbuf));\n  /* 'value_start' and 'value_end' must be either both non-NULL or both NULL */\n  mhd_assert ( (NULL == value_start) || (NULL != value_end) );\n  mhd_assert ( (NULL != value_start) || (NULL == value_end) );\n  mhd_assert ( (NULL == last_escape) || (NULL != value_start) );\n\n  /* Log entry state */\n  log_probe (\"enter\", pp, value_start, value_end, last_escape, 0, 0, false, 0);\n\n  /* move remaining input from previous round into processing buffer */\n  if (0 != pp->xbuf_pos)\n    memcpy (xbuf,\n            pp->xbuf,\n            pp->xbuf_pos);\n  xoff = pp->xbuf_pos;\n  pp->xbuf_pos = 0;\n  if ( (NULL != last_escape) &&\n       (((size_t) (value_end - last_escape)) < sizeof (pp->xbuf)) )\n  {\n    mhd_assert (value_end >= last_escape);\n    pp->xbuf_pos = (size_t) (value_end - last_escape);\n    memcpy (pp->xbuf,\n            last_escape,\n            (size_t) (value_end - last_escape));\n    value_end = last_escape;\n    /* Log that we adjusted value_end due to last_escape handling */\n    log_probe (\"adjust_last_escape\", pp, value_start, value_end, last_escape, xoff, 0, false, 0);\n  }\n  while ( (value_start != value_end) ||\n          (pp->must_ikvi) ||\n          (xoff > 0) )\n  {\n    size_t delta = (size_t) (value_end - value_start);\n    bool cut = false;\n    size_t clen = 0;\n\n    mhd_assert (value_end >= value_start);\n\n    if (delta > XBUF_SIZE - xoff)\n      delta = XBUF_SIZE - xoff;\n    /* move (additional) input into processing buffer */\n    if (0 != delta)\n    {\n      /* Log before advancing value_start */\n      log_probe (\"before_memcpy_advance\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      memcpy (&xbuf[xoff],\n              value_start,\n              delta);\n      xoff += delta;\n      value_start += delta; /* <-- this is the reported violation: parameter is modified */\n      /* Log after advancing value_start to capture the changed pointer */\n      log_probe (\"after_memcpy_advance\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n    }\n    /* find if escape sequence is at the end of the processing buffer;\n       if so, exclude those from processing (reduce delta to point at\n       end of processed region) */\n    if ( (xoff > 0) &&\n         ('%' == xbuf[xoff - 1]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff--;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        pp->xbuf[0] = '%';\n        pp->xbuf_pos = 1;\n        log_probe (\"cut_1_set\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 1;\n        log_probe (\"skip_escape_1\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      }\n    }\n    else if ( (xoff > 1) &&\n              ('%' == xbuf[xoff - 2]) )\n    {\n      cut = (xoff != XBUF_SIZE);\n      xoff -= 2;\n      if (cut)\n      {\n        /* move escape sequence into buffer for next function invocation */\n        memcpy (pp->xbuf,\n                &xbuf[xoff],\n                2);\n        pp->xbuf_pos = 2;\n        log_probe (\"cut_2_set\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      }\n      else\n      {\n        /* just skip escape sequence for next loop iteration */\n        delta = xoff;\n        clen = 2;\n        log_probe (\"skip_escape_2\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      }\n    }\n    mhd_assert (xoff < sizeof (xbuf));\n    /* unescape */\n    xbuf[xoff] = '\\0';        /* 0-terminate in preparation */\n    if (0 != xoff)\n    {\n      MHD_unescape_plus (xbuf);\n      xoff = MHD_http_unescape (xbuf);\n      /* Log after unescape to capture resulting xoff */\n      log_probe (\"after_unescape\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n    }\n    /* finally: call application! */\n    if (pp->must_ikvi || (0 != xoff) )\n    {\n      pp->must_ikvi = false;\n      /* Log before calling ikvi */\n      log_probe (\"before_ikvi_call\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      if (MHD_NO == pp->ikvi (pp->cls,\n                              MHD_POSTDATA_KIND,\n                              (const char *) &pp[1],      /* key */\n                              NULL,\n                              NULL,\n                              NULL,\n                              xbuf,\n                              pp->value_offset,\n                              xoff))\n      {\n        pp->state = PP_Error;\n        /* Log the error return */\n        log_probe (\"ikvi_return_error\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n        return;\n      }\n      /* Log after successful ikvi call */\n      log_probe (\"after_ikvi_call\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n    }\n    pp->value_offset += xoff;\n    if (cut)\n    {\n      log_probe (\"break_on_cut\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n      break;\n    }\n    if (0 != clen)\n    {\n      xbuf[delta] = '%';        /* undo 0-termination */\n      memmove (xbuf,\n               &xbuf[delta],\n               clen);\n      log_probe (\"after_clen_memmove\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n    }\n    xoff = clen;\n    /* Log end of loop iteration */\n    log_probe (\"loop_iteration_end\", pp, value_start, value_end, last_escape, xoff, delta, cut, clen);\n  }\n\n  /* Log exit state */\n  log_probe (\"exit\", pp, value_start, value_end, last_escape, xoff, 0, false, 0);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nenter: value_start=0x5564e4548057 value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=1 state=5\nbefore_memcpy_advance: value_start=0x5564e4548057 value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=0 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=5\nafter_memcpy_advance: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=5\nafter_unescape: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=5\nbefore_ikvi_call: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=0 state=5\nafter_ikvi_call: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=0 state=5\nloop_iteration_end: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=0 delta=4 cut=0 clen=0 value_offset=4 must_ikvi=0 state=5\nexit: value_start=0x5564e454805b value_end=0x5564e454805b last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=4 must_ikvi=0 state=5\nenter: value_start=0x5564e4548062 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nbefore_memcpy_advance: value_start=0x5564e4548062 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=0 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nafter_memcpy_advance: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nafter_unescape: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nbefore_ikvi_call: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nafter_ikvi_call: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=4 delta=4 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nloop_iteration_end: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=0 delta=4 cut=0 clen=0 value_offset=4 must_ikvi=0 state=6\nexit: value_start=0x5564e4548066 value_end=0x5564e4548066 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=4 must_ikvi=0 state=6\nenter: value_start=0x5564e454806c value_end=0x5564e454806c last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nbefore_ikvi_call: value_start=0x5564e454806c value_end=0x5564e454806c last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nafter_ikvi_call: value_start=0x5564e454806c value_end=0x5564e454806c last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nloop_iteration_end: value_start=0x5564e454806c value_end=0x5564e454806c last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nexit: value_start=0x5564e454806c value_end=0x5564e454806c last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nenter: value_start=0x5564e454e2e8 value_end=0x5564e454e2e8 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=1 state=6\nbefore_ikvi_call: value_start=0x5564e454e2e8 value_end=0x5564e454e2e8 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nafter_ikvi_call: value_start=0x5564e454e2e8 value_end=0x5564e454e2e8 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nloop_iteration_end: value_start=0x5564e454e2e8 value_end=0x5564e454e2e8 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 clen=0 value_offset=0 must_ikvi=0 state=6\nexit: value_start=0x5564e454e2e8 value_end=0x5564e454e2e8 last_escape=(nil) xbuf_pos=0 xoff=0 delta=0 cut=0 \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C:2023 Rule 17.8 prohibits modifying function parameters; pointer parameters may be used to modify the pointed object but the pointer itself shall not be reassigned. In process_value the code reassigns the pointer parameters: value_start is advanced with value_start += delta (and value_end is reassigned earlier with value_end = last_escape). The provided runtime logs explicitly show value_start changing between the before_memcpy_advance and after_memcpy_advance entries, confirming the parameter was modified. Therefore agent A's report is correct. A compliant fix is to copy the parameters into local pointer variables (e.g. const char *p = value_start; const char *end = value_end) and update those locals instead of the formal parameters."
}