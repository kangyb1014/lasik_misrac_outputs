{
  "user_message": "An agent A claimed that the following detect_cpu_core_count code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of detect_cpu_core_count.\n```c\nstatic unsigned int\ndetect_cpu_core_count (void)\n{\n  int sys_cpu_count;\n  sys_cpu_count = mhd_tool_get_system_cpu_count ();\n  if (0 >= sys_cpu_count)\n  {\n    int proc_cpu_count;\n    fprintf (stderr, \"Failed to detect the number of logical CPU cores \"\n             \"available on the system.\\n\");\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (0 < proc_cpu_count)\n    {\n      fprintf (stderr, \"The number of CPU cores available for this process \"\n               \"is used as a fallback.\\n\");\n      sys_cpu_count = proc_cpu_count;\n    }\n#ifdef MHD_REAL_CPU_COUNT\n    if (0 >= sys_cpu_count)\n    {\n      fprintf (stderr, \"configure-detected hardcoded number is used \"\n               \"as a fallback.\\n\");\n      sys_cpu_count = MHD_REAL_CPU_COUNT;\n    }\n#endif\n    if (0 >= sys_cpu_count)\n      sys_cpu_count = 1;\n    printf (\"Assuming %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  else\n  {\n    printf (\"Detected %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  return (unsigned int) sys_cpu_count;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The typedef uses the WINAPI calling-convention macro (e.g. expands to MSVC/MinGW __stdcall), which is a compiler-specific calling-convention extension. When compiled on Windows with MSVC/MinGW this invokes a non\u2011standard language extension and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *stage, int sys_cpu, int proc_cpu, int used_real)\n{\n  FILE *f = fopen (\"/tmp/logs/320.txt\", \"a\");\n  if (f != NULL)\n  {\n    /* Log stage and relevant integer state values. */\n    fprintf (f, \"detect_cpu_core_count: %s; sys_cpu=%d; proc_cpu=%d; used_real=%d\\n\",\n             stage, sys_cpu, proc_cpu, used_real);\n    fclose (f);\n  }\n}\n\nstatic unsigned int\ndetect_cpu_core_count (void)\n{\n  int sys_cpu_count;\n  int proc_cpu_count = -1;\n  int used_real = 0;\n\n  mhd_log_probe (\"entry\", -1, -1, 0);\n\n  sys_cpu_count = mhd_tool_get_system_cpu_count ();\n  mhd_log_probe (\"after_mhd_tool_get_system_cpu_count\", sys_cpu_count, -1, 0);\n\n  if (0 >= sys_cpu_count)\n  {\n    fprintf (stderr, \"Failed to detect the number of logical CPU cores \"\n             \"available on the system.\\n\");\n    mhd_log_probe (\"sys_count_failed_before_proc\", sys_cpu_count, -1, 0);\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    mhd_log_probe (\"after_mhd_tool_get_proc_cpu_count\", sys_cpu_count,\n                   proc_cpu_count, 0);\n\n    if (0 < proc_cpu_count)\n    {\n      fprintf (stderr, \"The number of CPU cores available for this process \"\n               \"is used as a fallback.\\n\");\n      mhd_log_probe (\"using_proc_fallback\", sys_cpu_count, proc_cpu_count, 0);\n      sys_cpu_count = proc_cpu_count;\n      mhd_log_probe (\"sys_count_set_to_proc\", sys_cpu_count, proc_cpu_count, 0);\n    }\n#ifdef MHD_REAL_CPU_COUNT\n    if (0 >= sys_cpu_count)\n    {\n      fprintf (stderr, \"configure-detected hardcoded number is used \"\n               \"as a fallback.\\n\");\n      mhd_log_probe (\"about_to_use_MHD_REAL_CPU_COUNT\", sys_cpu_count,\n                     proc_cpu_count, 0);\n      sys_cpu_count = MHD_REAL_CPU_COUNT;\n      used_real = 1;\n      mhd_log_probe (\"used_MHD_REAL_CPU_COUNT\", sys_cpu_count,\n                     proc_cpu_count, used_real);\n    }\n#endif\n    if (0 >= sys_cpu_count)\n      sys_cpu_count = 1;\n\n    mhd_log_probe (\"before_assuming_message\", sys_cpu_count, proc_cpu_count,\n                   used_real);\n    printf (\"Assuming %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  else\n  {\n    mhd_log_probe (\"detected_system_count_ok\", sys_cpu_count, -1, 0);\n    printf (\"Detected %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n\n  mhd_log_probe (\"exit\", sys_cpu_count, proc_cpu_count, used_real);\n  return (unsigned int) sys_cpu_count;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for detect_cpu_core_count. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not supported by the supplied code. The detect_cpu_core_count and the instrumented test code use only standard C features (local int variables, calls to standard library functions, preprocessor conditional on MHD_REAL_CPU_COUNT which is an application macro, and a simple cast to unsigned int). There is no use of WINAPI, __stdcall, calling\u2011convention macros, or any other compiler\u2011specific language extension shown. Rule 1.2 would only apply if a compiler\u2011documented language extension (e.g. a calling\u2011convention macro that expands to __stdcall) is actually used; that is not the case here. The empty test log is a test/harness issue and does not indicate a language\u2011extension usage in the code. Therefore the report is incorrect."
}