{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_ready_normal_body': {'callees': ['MHD_connection_alloc_memory_', '__builtin_unreachable', 'connection_close_error', 'MHD_connection_close_'], 'callers': ['MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'connection_close_error': {'callees': ['MHD_DLOG', 'MHD_connection_close_'], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'transmit_error_response_len', 'handle_recv_no_space', 'call_connection_handler', 'process_request_body', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct MHD_Response",
    "enum MHD_Result (MHD_YES / MHD_NO)",
    "MHD_connection_alloc_memory_ (declaration/definition)",
    "MHD_MIN (macro or inline definition)",
    "response->crc (type / function-pointer declaration)",
    "MHD_iovec_ (type definition)",
    "mhd_assert (macro or function)",
    "CONNECTION_CLOSE_ERROR (macro)",
    "MHD_mutex_unlock_chk_ (macro or function)",
    "MHD_connection_close_ (declaration/definition)",
    "MHD_CONTENT_READER_END_OF_STREAM (constant/macro)",
    "MHD_resp_sender_sendfile (symbol / enum value)",
    "_MHD_HAVE_SENDFILE (preprocessor symbol)",
    "MHD_USE_POSIX_THREADS and MHD_USE_W32_THREADS (preprocessor symbols)"
  ],
  "explanation": "To determine whether try_ready_normal_body uses any compiler/language extensions we must examine the definitions of all macros, types and called functions that could hide such extensions. For each listed symbol: \n\n- struct MHD_Connection: its definition may include anonymous structs/unions, nested functions, or non-standard attributes on members (all possible language extensions). The function reads connection->rp so the rp sub-structure layout must be checked for extensions.\n\n- struct MHD_Response: the response type may use anonymous unions/structs, flexible array members, GCC attributes or other extensions on members (e.g. data, crc, mutex). The code accesses many fields (total_size, data, data_iov, crc, mutex) so their declarations must be inspected.\n\n- enum MHD_Result (MHD_YES / MHD_NO): the enum's definition may use compiler-specific attributes (e.g. __attribute__((enum_ext))) or be a typedef to an extension; confirm it is standard C.\n\n- MHD_connection_alloc_memory_ (declaration/definition): this allocator may be declared with GCC attributes (alloc_size, malloc, noinline), inline assembly, or use statement-expressions/typeof in its implementation or macro wrapper \u2014 any of which are language extensions.\n\n- MHD_MIN (macro or inline definition): min/max macros are often implemented using GCC typeof and statement-expressions (e.g. ({ typeof(a) _a = (a); ... })) \u2014 these are GNU extensions; its definition must be checked.\n\n- response->crc (type / function-pointer declaration): the CRC callback's prototype may include attributes, non-standard calling conventions or use variadic/extension features. The function call site relies on that prototype (ssize_t return); its declaration may use extension syntax.\n\n- MHD_iovec_ (type definition): the iovec type may contain compiler-specific extensions (anonymous members, attributes, packed/aligned attributes, flexible array members) that affect conformance.\n\n- mhd_assert (macro or function): assert-like macros often use do { ... } while (0), but may also use statement-expressions or __builtin_expect/__builtin_unreachable; inspect its definition for compiler builtins or extensions.\n\n- CONNECTION_CLOSE_ERROR (macro): this macro likely expands to logging + close; it may use GCC statement-expressions, __builtin_unreachable, or stringizing/concatenation tricks that are extensions.\n\n- MHD_mutex_unlock_chk_ (macro or function): may be a wrapper with attributes or use pthread functions with compiler-specific annotations; check for extension usage in its declaration/definition.\n\n- MHD_connection_close_ (declaration/definition): the function prototype/definition may include attributes (noreturn, deprecated, visibility, calling convention) or inline asm \u2014 inspect for extensions.\n\n- MHD_CONTENT_READER_END_OF_STREAM (constant/macro): though likely a constant, its definition could be an expression using extension constructs; include to be thorough.\n\n- MHD_resp_sender_sendfile (symbol / enum value): referenced under #if defined(_MHD_HAVE_SENDFILE) \u2014 its type/definition could be an inline function, macro or use extension-specific constructs.\n\n- _MHD_HAVE_SENDFILE, MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS (preprocessor symbols): conditional compilation controls code paths in the function. Different configuration may enable code that uses extensions (e.g. platform-specific code using __attribute__ or builtins). You must inspect code activated under those defines.\n\nIn short, each listed symbol is directly referenced by try_ready_normal_body (fields, macros, or callees) and their definitions are the likely places where compiler or language extensions (typeof, statement-expressions, __attribute__, __builtin_*, inline asm, anonymous structs/unions, nested functions, labels-as-values, etc.) could appear. To decide MISRA conformance for the rule on language extensions you must review these definitions (rather than only the body of try_ready_normal_body)."
}