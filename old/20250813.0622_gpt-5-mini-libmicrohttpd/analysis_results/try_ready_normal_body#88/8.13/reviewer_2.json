{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The field response->data_iov is used only as a read-only source (passed to memcpy and indexed via response->data_iovcnt) and is not modified in this fragment, so it could and should be declared to point to a const-qualified element type (e.g. const MHD_iovec_ *). Because the pointer target is not const-qualified while it can be, this violates MISRA C 2023 Rule 8.13. Note: connection->rp.resp_iov.iov is a destination buffer and must remain non-const, so it is not a violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/707.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  probe_log(\"try_ready_normal_body: entry connection=%p response=%p send_reply_body=%d total_size=%zu rsp_write_position=%zu\",\n            (void *) connection, (void *) response,\n            (int) connection->rp.props.send_reply_body,\n            (response ? response->total_size : (size_t)0),\n            (size_t) connection->rp.rsp_write_position);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n  {\n    probe_log(\"try_ready_normal_body: zero-length or already written -> return MHD_YES (total_size=%zu rsp_write_position=%zu)\",\n              response->total_size, (size_t) connection->rp.rsp_write_position);\n    return MHD_YES;  /* 0-byte response is always ready */\n  }\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    probe_log(\"try_ready_normal_body: response->data_iov != NULL, data_iov=%p data_iovcnt=%zu\",\n              (void *) response->data_iov, response->data_iovcnt);\n\n    if (NULL != connection->rp.resp_iov.iov)\n    {\n      probe_log(\"try_ready_normal_body: connection->rp.resp_iov.iov already set (%p) -> return MHD_YES\",\n                (void *) connection->rp.resp_iov.iov);\n      return MHD_YES;\n    }\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    probe_log(\"try_ready_normal_body: allocating resp_iov.iov copy_size=%zu\", copy_size);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      probe_log(\"try_ready_normal_body: allocation failed for size=%zu -> unlocking and closing connection\", copy_size);\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n\n    probe_log(\"try_ready_normal_body: allocation succeeded resp_iov.iov=%p, performing memcpy from data_iov=%p size=%zu\",\n              (void *) connection->rp.resp_iov.iov,\n              (void *) response->data_iov,\n              copy_size);\n\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n\n    probe_log(\"try_ready_normal_body: memcpy done; setting resp_iov.cnt=%zu sent=0\",\n              response->data_iovcnt);\n\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    probe_log(\"try_ready_normal_body: returning MHD_YES after preparing resp_iov\");\n    return MHD_YES;\n  }\n  probe_log(\"try_ready_normal_body: response->data_iov == NULL, checking crc\");\n  if (NULL == response->crc)\n  {\n    probe_log(\"try_ready_normal_body: response->crc == NULL -> return MHD_YES\");\n    return MHD_YES;\n  }\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n  {\n    probe_log(\"try_ready_normal_body: response already ready (data_start=%zu data_size=%zu rsp_write_position=%zu) -> return MHD_YES\",\n              response->data_start, response->data_size, (size_t) connection->rp.rsp_write_position);\n    return MHD_YES; /* response already ready */\n  }\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    probe_log(\"try_ready_normal_body: using sendfile resp_sender=%p -> return MHD_YES\",\n              (void *) connection->rp.resp_sender);\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  probe_log(\"try_ready_normal_body: invoking response->crc (crc_cls=%p rsp_write_position=%zu data=%p data_buffer_size=%zu total_size=%zu)\",\n            (void *) response->crc_cls,\n            (size_t) connection->rp.rsp_write_position,\n            (void *) response->data,\n            (size_t) response->data_buffer_size,\n            (size_t) response->total_size);\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  probe_log(\"try_ready_normal_body: response->crc returned ret=%zd\", ret);\n\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n    {\n      probe_log(\"try_ready_normal_body: crc signaled end of stream -> closing connection completed ok\");\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    }\n    else\n    {\n      probe_log(\"try_ready_normal_body: crc error (ret=%zd) -> CONNECTION_CLOSE_ERROR\", ret);\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    }\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  probe_log(\"try_ready_normal_body: crc succeeded new data_start=%zu data_size=%zu\",\n            response->data_start, response->data_size);\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    probe_log(\"try_ready_normal_body: crc returned 0 -> set state UNREADY and return MHD_NO\");\n    return MHD_NO;\n  }\n  probe_log(\"try_ready_normal_body: returning MHD_YES (ret=%zd)\", ret);\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for try_ready_normal_body. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s claim is not proven by the fragment. MISRA 8.13 concerns pointer declarations (they should be const-qualified where possible). In the shown function response->data_iov is only read, but it is a member of struct MHD_Response declared elsewhere. You cannot conclude a rule violation just from this use: to decide whether the member should be const requires looking at the declaration of data_iov and all places that may modify it. If the struct field is never modified anywhere, then changing its declaration to a pointer-to-const would be appropriate; if it is written elsewhere, making it const would be incorrect and break code. Also note that memcpy\u2019s source parameter is already const-qualified, so passing a non-const pointer to memcpy is permitted and does not itself violate the rule.\n\nTherefore the report as stated is not correct: the function\u2019s use of response->data_iov does not by itself prove a MISRA 8.13 violation. If you want to satisfy Rule 8.13 locally without changing the struct, introduce a local const pointer (e.g. const MHD_iovec_ *src = response->data_iov;) and use that, or audit the struct field\u2019s declaration and all uses before changing it globally."
}