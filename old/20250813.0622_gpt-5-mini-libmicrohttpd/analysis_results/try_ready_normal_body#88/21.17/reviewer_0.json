{
  "user_message": "An agent A claimed that the following try_ready_normal_body code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of try_ready_normal_body.\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If response->data_iov does not actually point to an array of response->data_iovcnt elements (for example due to a bug or corrupted metadata where data_iovcnt is larger than the real allocation), the computed copy_size = response->data_iovcnt * sizeof(MHD_iovec_) will cause memcpy(connection->rp.resp_iov.iov, response->data_iov, copy_size) to read past the bounds of response->data_iov. There is no validation that response->data_iov actually contains data_iovcnt elements nor any check for multiplication overflow, so memcpy may access beyond the source object\u2019s bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\ntry_ready_log_probe_response_state (struct MHD_Connection *connection,\n                                     struct MHD_Response *response,\n                                     size_t copy_size,\n                                     int overflow_flag,\n                                     const char *stage)\n{\n  FILE *f = fopen(\"/tmp/logs/711.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"[try_ready_normal_body] stage=%s\\n\", stage);\n  fprintf (f, \" response=%p\\n\", (void *) response);\n  fprintf (f, \" response->data_iov=%p\\n\", (void *) response->data_iov);\n  fprintf (f, \" response->data_iovcnt=%llu\\n\", (unsigned long long) response->data_iovcnt);\n  fprintf (f, \" response->total_size=%llu\\n\", (unsigned long long) response->total_size);\n  fprintf (f, \" response->data_start=%llu\\n\", (unsigned long long) response->data_start);\n  fprintf (f, \" response->data_size=%llu\\n\", (unsigned long long) response->data_size);\n  fprintf (f, \" response->data_buffer_size=%llu\\n\", (unsigned long long) response->data_buffer_size);\n  fprintf (f, \" connection=%p\\n\", (void *) connection);\n  fprintf (f, \" connection->rp.resp_iov.iov=%p\\n\", (void *) connection->rp.resp_iov.iov);\n  fprintf (f, \" computed copy_size=%llu\\n\", (unsigned long long) copy_size);\n  fprintf (f, \" multiplication_overflow_detected=%d\\n\", overflow_flag);\n  fprintf (f, \"---\\n\");\n  fclose (f);\n}\n\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n\n    /* Probe: compute and log potential overflow condition without changing logic */\n    {\n      int overflow = 0;\n      if (response->data_iovcnt > ((size_t) -1) / sizeof (MHD_iovec_))\n        overflow = 1;\n\n      copy_size = response->data_iovcnt * sizeof (MHD_iovec_);\n\n      /* Log state before allocation */\n      try_ready_log_probe_response_state (connection, response, copy_size, overflow,\n                                          \"before_alloc\");\n    }\n\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      /* Log allocation failure */\n      try_ready_log_probe_response_state (connection, response, copy_size, 0,\n                                          \"alloc_failed\");\n\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n\n    /* Log after successful allocation, before memcpy */\n    try_ready_log_probe_response_state (connection, response, copy_size, 0,\n                                        \"after_alloc_before_memcpy\");\n\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n\n    /* Log after memcpy to capture pointers and sizes (evidence if data_iov was smaller) */\n    try_ready_log_probe_response_state (connection, response, copy_size, 0,\n                                        \"after_memcpy\");\n\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for try_ready_normal_body. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s scenario is valid. The code computes copy_size = response->data_iovcnt * sizeof(MHD_iovec_) and then calls memcpy(..., response->data_iov, copy_size) without any local validation that response->data_iov actually points to at least response->data_iovcnt elements and without checking for multiplication overflow. If data_iovcnt is corrupted or larger than the real allocation, or if the multiplication overflows, memcpy can read beyond the bounds of the source object (or write past the allocated destination), which is exactly what MISRA C 2023 Rule 21.17 forbids. The only way this would not be a violation is if there is a provable, externally enforced invariant (documented and enforced elsewhere) that guarantees response->data_iov and response->data_iovcnt are consistent and that the multiplication cannot overflow; no such guarantee is visible in the function itself. Therefore the report is correct."
}