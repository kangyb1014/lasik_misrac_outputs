{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code calls memcmp(hdr->value, \"close, \", MHD_STATICSTR_LEN_(\"close, \")). hdr->value is explicitly null-terminated earlier (hdr->value[hdr->value_size] = 0) and the RHS is a string literal, so memcmp is being used to compare null-terminated strings. According to MISRA C 2023 Rule 21.14 this use of memcmp for string comparison is forbidden (strcmp/strncmp or other string functions should be used).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n  FILE *fp = NULL;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  /* Open log file for probes. If the preferred path fails, fall back to /tmp/398.txt */\n  fp = fopen(\"/tmp/logs/398.txt\", \"a\");\n  if (NULL == fp)\n    fp = fopen(\"/tmp/398.txt\", \"a\");\n\n  if (fp)\n  {\n    fprintf(fp, \"ENTER: MHD_del_response_header header=%p len=%zu \\\"%.*s\\\"\\n\",\n            (void *)header, header_len, (int)header_len, header);\n    fflush(fp);\n  }\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    if (fp)\n    {\n      fprintf(fp, \"BRANCH: del_response_header_connection will be called for header=\\\"%.*s\\\"\\n\",\n              (int)header_len, header);\n      fclose(fp);\n      fp = NULL;\n    }\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  if (fp)\n  {\n    fprintf(fp, \"PARAM: content=%p len=%zu \\\"%.*s\\\"\\n\",\n            (void *)content, content_len, (int)content_len, content);\n    fflush(fp);\n  }\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    /* Preserve original logic but capture memcmp results into temporaries\n       so we can log them without changing control flow. */\n    int header_cmp = 1;\n    int content_cmp = 1;\n\n    if (fp)\n    {\n      fprintf(fp, \"LOOP: pos=%p pos->header=%p pos->value=%p pos->header_size=%zu pos->value_size=%zu\\n\",\n              (void *)pos, (void *)pos->header, (void *)pos->value,\n              pos->header_size, pos->value_size);\n      /* Print header and value safely (not relying on NUL termination) */\n      if (pos->header && pos->header_size > 0)\n      {\n        fprintf(fp, \"LOOP: pos->header (as bytes, len=%zu): '%.*s'\\n\",\n                pos->header_size, (int)pos->header_size, pos->header);\n      }\n      if (pos->value && pos->value_size > 0)\n      {\n        fprintf(fp, \"LOOP: pos->value (as bytes, len=%zu): '%.*s'\\n\",\n                pos->value_size, (int)pos->value_size, pos->value);\n      }\n      fflush(fp);\n    }\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size))\n    {\n      /* memcmp is used in the original implementation; capture results here */\n      header_cmp = memcmp (header, pos->header, header_len);\n      content_cmp = memcmp (content, pos->value, content_len);\n\n      if (fp)\n      {\n        fprintf(fp, \"CMP: header_cmp=%d content_cmp=%d (header_len=%zu content_len=%zu)\\n\",\n                header_cmp, content_cmp, header_len, content_len);\n        /* Log whether the provided 'content' is NUL-terminated at content_len (it is, since content_len from strlen)\n           and report the pointer addresses to help reproduce the scenario. */\n        fprintf(fp, \"INFO: content pointer=%p content_len=%zu (strlen confirmed NUL termination)\\n\",\n                (void *)content, content_len);\n        fprintf(fp, \"INFO: pos->value pointer=%p pos->value_size=%zu\\n\",\n                (void *)pos->value, pos->value_size);\n        fflush(fp);\n      }\n    }\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == header_cmp) &&\n        (0 == content_cmp))\n    {\n      if (fp)\n      {\n        fprintf(fp, \"MATCH: header and content matched for pos=%p; removing header\\n\",\n                (void *)pos);\n        fflush(fp);\n      }\n\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n\n      if (fp)\n      {\n        fprintf(fp, \"EXIT: returning MHD_YES\\n\");\n        fclose(fp);\n        fp = NULL;\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n\n  if (fp)\n  {\n    fprintf(fp, \"EXIT: no matching header found; returning MHD_NO\\n\");\n    fclose(fp);\n    fp = NULL;\n  }\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTER: MHD_del_response_header header=0x55dfb61c20b9 len=13 \"Header-Type-A\"\nPARAM: content=0x55dfb61c20b0 len=8 \"value-a1\"\nLOOP: pos=0x55dff2e033a0 pos->header=0x55dff2e03360 pos->value=0x55dff2e03380 pos->header_size=13 pos->value_size=8\nLOOP: pos->header (as bytes, len=13): 'Header-Type-A'\nLOOP: pos->value (as bytes, len=8): 'value-a1'\nCMP: header_cmp=0 content_cmp=0 (header_len=13 content_len=8)\nINFO: content pointer=0x55dfb61c20b0 content_len=8 (strlen confirmed NUL termination)\nINFO: pos->value pointer=0x55dff2e03380 pos->value_size=8\nMATCH: header and content matched for pos=0x55dff2e033a0; removing header\nEXIT: returning MHD_YES\nENTER: MHD_del_response_header header=0x55dfb61c20b9 len=13 \"Header-Type-A\"\nPARAM: content=0x55dfb61c2118 len=8 \"value-a3\"\nLOOP: pos=0x55dff2e03420 pos->header=0x55dff2e033e0 pos->value=0x55dff2e03400 pos->header_size=13 pos->value_size=8\nLOOP: pos->header (as bytes, len=13): 'Header-Type-A'\nLOOP: pos->value (as bytes, len=8): 'value-a2'\nCMP: header_cmp=0 content_cmp=1 (header_len=13 content_len=8)\nINFO: content pointer=0x55dfb61c2118 content_len=8 (strlen confirmed NUL termination)\nINFO: pos->value pointer=0x55dff2e03400 pos->value_size=8\nLOOP: pos=0x55dff2e03640 pos->header=0x55dff2e03380 pos->value=0x55dff2e03360 pos->header_size=13 pos->value_size=8\nLOOP: pos->header (as bytes, len=13): 'Header-Type-A'\nLOOP: pos->value (as bytes, len=8): 'value-a3'\nCMP: header_cmp=0 content_cmp=0 (header_len=13 content_len=8)\nINFO: content pointer=0x55dfb61c2118 content_len=8 (strlen confirmed NUL termination)\nINFO: pos->value pointer=0x55dff2e03360 pos->value_size=8\nMATCH: header and content matched for pos=0x55dff2e03640; removing header\nEXIT: returning MHD_YES\nENTER: MHD_del_response_header header=0x55dfb61c212f len=13 \"Header-Type-C\"\nPARAM: content=0x55dfb61c2118 len=8 \"value-a3\"\nLOOP: pos=0x55dff2e03420 pos->header=0x55dff2e033e0 pos->value=0x55dff2e03400 pos->header_size=13 pos->value_size=8\nLOOP: pos->header (as bytes, len=13): 'Header-Type-A'\nLOOP: pos->value (as bytes, len=8): 'value-a2'\nCMP: header_cmp=2 content_cmp=1 (header_len=13 content_len=8)\nINFO: content pointer=0x55dfb61c2118 content_len=8 (strlen confirmed NUL termination)\nINFO: pos->value pointer=0x55dff2e03400 pos->value_size=8\nEXIT: no matching header found; returning MHD_NO\nENTER: MHD_del_response_header header=0x55dfb61c20b9 len=13 \"Header-Type-A\"\nPARAM: content=0x55dfb61c215b len=7 \"value-c\"\nLOOP: pos=0x55dff2e03420 pos->header=0x55dff2e033e0 pos->value=0x55dff2e03400 pos->header_size=13 pos->value_size=8\nLOOP: pos->header (as bytes, len=13): 'Header-Type-A'\nLOOP: pos->value (as bytes, len=8): 'value-a2'\nEXIT: no matching header found; returning MHD_NO\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55dfb61c2196 len=10 \"Connection\"\nBRANCH: del_response_header_connection will be called for header=\"Connection\"\nENTER: MHD_del_response_header header=0x55d\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the function the lengths header_len and content_len are computed with strlen(header)/strlen(content), so header and content are null-terminated strings. The code then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len). MISRA C 2023 Rule 21.14 prohibits using memcmp to compare null-terminated strings; thus the reported use of memcmp to compare the null-terminated inputs constitutes a violation. The provided traces confirm content was NUL-terminated (content_len from strlen) and show memcmp returning results based on those comparisons, supporting the scenario."
}