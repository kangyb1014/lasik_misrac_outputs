{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In del_response_header_connection the code sets hdr->value[hdr->value_size] = 0 (making hdr->value a NUL-terminated C string) and then calls memcmp(hdr->value, \"close\", MHD_STATICSTR_LEN_(\"close\")). This uses memcmp to compare a NUL-terminated string against a string literal, which violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/398.txt\", \"a\");\n    if (NULL == f)\n        return;\n\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputs(\"\\n\", f);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    probe_log(\"MHD_del_response_header: early return NULL param header=%p content=%p\",\n              (const void *) header, (const void *) content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  probe_log(\"MHD_del_response_header: entry header='%.*s' ptr=%p header_len=%zu\",\n            (int)header_len, header, (const void *) header, header_len);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    /* Log content info before delegating */\n    content_len = strlen (content);\n    probe_log(\"MHD_del_response_header: delegating to del_response_header_connection: content='%.*s' ptr=%p content_len=%zu\",\n              (int)content_len, content, (const void *) content, content_len);\n\n    /* Call the connection-specific handler and record result */\n    enum MHD_Result res = del_response_header_connection (response, content);\n    probe_log(\"MHD_del_response_header: del_response_header_connection returned %d\", (int) res);\n    return res;\n  }\n\n  content_len = strlen (content);\n  probe_log(\"MHD_del_response_header: searching headers: content='%.*s' ptr=%p content_len=%zu\",\n            (int)content_len, content, (const void *) content, content_len);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    probe_log(\"MHD_del_response_header: inspect pos=%p header_size=%zu value_size=%zu\",\n              (const void *) pos, pos->header_size, pos->value_size);\n\n    /* Compute comparators in variables for logging, but preserve original checks */\n    int r_header = 1;\n    int r_content = 1;\n\n    if (header_len == pos->header_size)\n    {\n      r_header = memcmp (header,\n                         pos->header,\n                         header_len);\n    }\n    else\n    {\n      probe_log(\"MHD_del_response_header: header size mismatch: header_len=%zu pos->header_size=%zu\",\n                header_len, pos->header_size);\n    }\n\n    if (content_len == pos->value_size)\n    {\n      r_content = memcmp (content,\n                          pos->value,\n                          content_len);\n    }\n    else\n    {\n      probe_log(\"MHD_del_response_header: content size mismatch: content_len=%zu pos->value_size=%zu\",\n                content_len, pos->value_size);\n    }\n\n    probe_log(\"MHD_del_response_header: memcmp results r_header=%d r_content=%d\",\n              r_header, r_content);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == r_header) &&\n        (0 == r_content))\n    {\n      probe_log(\"MHD_del_response_header: match found, removing header at pos=%p\", (const void *) pos);\n\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        probe_log(\"MHD_del_response_header: clearing MHD_RAF_HAS_TRANS_ENC_CHUNKED flag (was 0x%X)\", (unsigned) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: clearing MHD_RAF_HAS_DATE_HDR flag (was 0x%X)\", (unsigned) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          probe_log(\"MHD_del_response_header: clearing MHD_RAF_HAS_CONTENT_LENGTH flag (was 0x%X)\", (unsigned) response->flags_auto);\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n      }\n      probe_log(\"MHD_del_response_header: returning MHD_YES\");\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  probe_log(\"MHD_del_response_header: no matching header found, returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry header='Header-Type-A' ptr=0x562ee96470b9 header_len=13\nMHD_del_response_header: searching headers: content='value-a1' ptr=0x562ee96470b0 content_len=8\nMHD_del_response_header: inspect pos=0x562eee0613a0 header_size=13 value_size=8\nMHD_del_response_header: memcmp results r_header=0 r_content=0\nMHD_del_response_header: match found, removing header at pos=0x562eee0613a0\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry header='Header-Type-A' ptr=0x562ee96470b9 header_len=13\nMHD_del_response_header: searching headers: content='value-a3' ptr=0x562ee9647118 content_len=8\nMHD_del_response_header: inspect pos=0x562eee061420 header_size=13 value_size=8\nMHD_del_response_header: memcmp results r_header=0 r_content=1\nMHD_del_response_header: inspect pos=0x562eee061640 header_size=13 value_size=8\nMHD_del_response_header: memcmp results r_header=0 r_content=0\nMHD_del_response_header: match found, removing header at pos=0x562eee061640\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry header='Header-Type-C' ptr=0x562ee964712f header_len=13\nMHD_del_response_header: searching headers: content='value-a3' ptr=0x562ee9647118 content_len=8\nMHD_del_response_header: inspect pos=0x562eee061420 header_size=13 value_size=8\nMHD_del_response_header: memcmp results r_header=2 r_content=1\nMHD_del_response_header: no matching header found, returning MHD_NO\nMHD_del_response_header: entry header='Header-Type-A' ptr=0x562ee96470b9 header_len=13\nMHD_del_response_header: searching headers: content='value-c' ptr=0x562ee964715b content_len=7\nMHD_del_response_header: inspect pos=0x562eee061420 header_size=13 value_size=8\nMHD_del_response_header: content size mismatch: content_len=7 pos->value_size=8\nMHD_del_response_header: memcmp results r_header=0 r_content=1\nMHD_del_response_header: no matching header found, returning MHD_NO\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='e,b,c,d,a' ptr=0x562ee96471ea content_len=9\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='i,k,l,m,n,o,p,close' ptr=0x562ee964722f content_len=19\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='1,3,5,7,9' ptr=0x562ee9647391 content_len=9\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='12  ,10  ,8  ,close' ptr=0x562ee964744c content_len=19\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='4  ,5,6,7  8,' ptr=0x562ee9647502 content_len=13\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='close, 10, 12, 22, nothing' ptr=0x562ee9647570 content_len=26\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='2' ptr=0x562ee96475e1 content_len=1\nMHD_del_response_header: del_response_header_connection returned 1\nMHD_del_response_header: entry header='Connection' ptr=0x562ee9647196 header_len=10\nMHD_del_response_header: delegating to del_response_header_connection: content='close' ptr=0x562ee96474b3 content_len=5\nMHD_del_response_header: del_r\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function computes header_len = strlen(header) and content_len = strlen(content) (so header and content are NUL-terminated C strings) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) to compare them. MISRA C 2023 Rule 21.14 forbids using memcmp to compare null-terminated strings. The same pattern reported for del_response_header_connection (making a value NUL-terminated and then calling memcmp against a literal such as \"close\") also constitutes the same violation. The provided test logs show invocation paths that exercise these comparisons (including cases involving the Connection header and the string \"close\"), supporting the scenario. Therefore the agent A report is correct."
}