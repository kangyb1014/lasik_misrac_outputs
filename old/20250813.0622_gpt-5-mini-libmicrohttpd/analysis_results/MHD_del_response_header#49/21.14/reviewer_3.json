{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code computes content_len = strlen(content) (so content is a null-terminated C string) and pos->value is used as a header value that is null-terminated elsewhere (e.g. buf[pos] = 0 and hdr->value[hdr->value_size] = 0). Then it calls memcmp(content, pos->value, content_len) to compare them. Using memcmp to compare these null-terminated strings violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log(const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fp;\n    /* try to create the directory; ignore errors */\n    (void)mkdir(\"/tmp/logs\", 0777);\n    fp = fopen(\"/tmp/logs/398.txt\", \"a\");\n    if (NULL == fp)\n        return;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  /* Log entry into function and arguments */\n  mhd_log(\"MHD_del_response_header called: response=%p, header=%p, content=%p\", (void *)response, (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    mhd_log(\"Null argument detected: header=%p, content=%p - returning MHD_NO\", (const void *)header, (const void *)content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  mhd_log(\"header: '%s' (len=%zu)\", header, header_len);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    mhd_log(\"Special-case Connection header branch taken for header '%s'\", header);\n    mhd_log(\"content: '%s' (will be passed to del_response_header_connection)\", content);\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  mhd_log(\"content: '%s' (len=%zu)\", content, content_len);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    /* Log current header node state */\n    mhd_log(\"Inspecting header node: pos=%p, header_size=%zu, value_size=%zu, header_ptr=%p, value_ptr=%p\",\n            (void *)pos, pos->header_size, pos->value_size, (void *)pos->header, (void *)pos->value);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size))\n    {\n      /* Only perform memcmp when sizes match to preserve original logic and side-effects */\n      int header_cmp = memcmp (header, pos->header, header_len);\n      int content_cmp = memcmp (content, pos->value, content_len);\n\n      mhd_log(\"memcmp results: header_cmp=%d, content_cmp=%d\", header_cmp, content_cmp);\n      mhd_log(\"header (expected/actual): '%.*s' / '%.*s'\",\n              (int)header_len, header,\n              (int)pos->header_size, pos->header ? pos->header : \"\");\n      mhd_log(\"content (expected/actual): '%.*s' / '%.*s'\",\n              (int)content_len, content,\n              (int)pos->value_size, pos->value ? pos->value : \"\");\n\n      if ((0 == header_cmp) && (0 == content_cmp))\n      {\n        mhd_log(\"Match found: removing header node %p (header='%.*s', value='%.*s')\",\n                (void *)pos,\n                (int)pos->header_size, pos->header ? pos->header : \"\",\n                (int)pos->value_size, pos->value ? pos->value : \"\");\n\n        _MHD_remove_header (response, pos);\n        free (pos->header);\n        free (pos->value);\n        free (pos);\n\n        if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n              header_len) &&\n             MHD_str_equal_caseless_bin_n_ (header,\n                                            MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                            header_len) )\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                   header_len) &&\n                  MHD_str_equal_caseless_bin_n_ (header,\n                                                 MHD_HTTP_HEADER_DATE,\n                                                 header_len) )\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                   header_len) &&\n                  MHD_str_equal_caseless_bin_n_ (header,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len) )\n        {\n          if (NULL == MHD_get_response_element_n_ (response,\n                                                   MHD_HEADER_KIND,\n                                                   MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                   header_len))\n            response->flags_auto &=\n              ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n        mhd_log(\"Header removed and flags updated. Returning MHD_YES\");\n        return MHD_YES;\n      }\n      else\n      {\n        mhd_log(\"Size matched but contents differ for node %p: header_cmp=%d, content_cmp=%d\",\n                (void *)pos, header_cmp, content_cmp);\n      }\n    }\n    pos = pos->next;\n  }\n  mhd_log(\"No matching header found. Returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa0b9, content=0x561cfaeaa0b0\nheader: 'Header-Type-A' (len=13)\ncontent: 'value-a1' (len=8)\nInspecting header node: pos=0x561d201cb3a0, header_size=13, value_size=8, header_ptr=0x561d201cb360, value_ptr=0x561d201cb380\nmemcmp results: header_cmp=0, content_cmp=0\nheader (expected/actual): 'Header-Type-A' / 'Header-Type-A'\ncontent (expected/actual): 'value-a1' / 'value-a1'\nMatch found: removing header node 0x561d201cb3a0 (header='Header-Type-A', value='value-a1')\nHeader removed and flags updated. Returning MHD_YES\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa0b9, content=0x561cfaeaa118\nheader: 'Header-Type-A' (len=13)\ncontent: 'value-a3' (len=8)\nInspecting header node: pos=0x561d201cb420, header_size=13, value_size=8, header_ptr=0x561d201cb3e0, value_ptr=0x561d201cb400\nmemcmp results: header_cmp=0, content_cmp=1\nheader (expected/actual): 'Header-Type-A' / 'Header-Type-A'\ncontent (expected/actual): 'value-a3' / 'value-a2'\nSize matched but contents differ for node 0x561d201cb420: header_cmp=0, content_cmp=1\nInspecting header node: pos=0x561d201cb640, header_size=13, value_size=8, header_ptr=0x561d201cb380, value_ptr=0x561d201cb360\nmemcmp results: header_cmp=0, content_cmp=0\nheader (expected/actual): 'Header-Type-A' / 'Header-Type-A'\ncontent (expected/actual): 'value-a3' / 'value-a3'\nMatch found: removing header node 0x561d201cb640 (header='Header-Type-A', value='value-a3')\nHeader removed and flags updated. Returning MHD_YES\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa12f, content=0x561cfaeaa118\nheader: 'Header-Type-C' (len=13)\ncontent: 'value-a3' (len=8)\nInspecting header node: pos=0x561d201cb420, header_size=13, value_size=8, header_ptr=0x561d201cb3e0, value_ptr=0x561d201cb400\nmemcmp results: header_cmp=2, content_cmp=1\nheader (expected/actual): 'Header-Type-C' / 'Header-Type-A'\ncontent (expected/actual): 'value-a3' / 'value-a2'\nSize matched but contents differ for node 0x561d201cb420: header_cmp=2, content_cmp=1\nNo matching header found. Returning MHD_NO\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa0b9, content=0x561cfaeaa15b\nheader: 'Header-Type-A' (len=13)\ncontent: 'value-c' (len=7)\nInspecting header node: pos=0x561d201cb420, header_size=13, value_size=8, header_ptr=0x561d201cb3e0, value_ptr=0x561d201cb400\nNo matching header found. Returning MHD_NO\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa1ea\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: 'e,b,c,d,a' (will be passed to del_response_header_connection)\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa22f\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: 'i,k,l,m,n,o,p,close' (will be passed to del_response_header_connection)\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa391\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: '1,3,5,7,9' (will be passed to del_response_header_connection)\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa44c\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: '12  ,10  ,8  ,close' (will be passed to del_response_header_connection)\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa502\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: '4  ,5,6,7  8,' (will be passed to del_response_header_connection)\nMHD_del_response_header called: response=0x561d201cb2a0, header=0x561cfaeaa196, content=0x561cfaeaa570\nheader: 'Connection' (len=10)\nSpecial-case Connection header branch taken for header 'Connection'\ncontent: 'close, 10, 12, 22, nothing' (will be passed t\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls strlen(header) and strlen(content) and then uses memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len). Because header and content are obtained via strlen they are null-terminated C strings; the scenario/test confirms pos->value/pos->header are also null-terminated. MISRA C 2023 Rule 21.14 explicitly forbids using memcmp to compare null-terminated strings. Therefore these memcmp calls violate Rule 21.14 (both the header and content comparisons). The report is correct."
}