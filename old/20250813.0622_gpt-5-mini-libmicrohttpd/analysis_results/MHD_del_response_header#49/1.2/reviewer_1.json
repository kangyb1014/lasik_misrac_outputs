{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro _MHD_EXTERN expands to __attribute__((visibility(\"default\"))) which is a GCC/Clang compiler-specific attribute (a documented compiler language extension). Using __attribute__ is an explicit compiler extension and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/392.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    fprintf(f, \"\\n\");\n    va_end(ap);\n    fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  probe_log(\"MHD_del_response_header: entry header=%p content=%p\", (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    probe_log(\"MHD_del_response_header: early return MHD_NO due to NULL header/content\");\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  probe_log(\"MHD_del_response_header: header_len=%zu header=\\\"%s\\\"\", header_len, header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    probe_log(\"MHD_del_response_header: taking connection-header fast path\");\n    enum MHD_Result __res = del_response_header_connection (response, content);\n    probe_log(\"MHD_del_response_header: del_response_header_connection returned=%d\", (int)__res);\n    return __res;\n  }\n\n  content_len = strlen (content);\n  probe_log(\"MHD_del_response_header: content_len=%zu content=\\\"%s\\\"\", content_len, content);\n  pos = response->first_header;\n  probe_log(\"MHD_del_response_header: starting scan of headers first_header=%p\", (void *)pos);\n  while (NULL != pos)\n  {\n    /* Log state for current header node */\n    probe_log(\"MHD_del_response_header: inspecting pos=%p header_size=%zu value_size=%zu pos->header=%p pos->value=%p\",\n              (void *)pos, pos->header_size, pos->value_size, (void *)pos->header, (void *)pos->value);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      probe_log(\"MHD_del_response_header: match found at pos=%p\", (void *)pos);\n      _MHD_remove_header (response, pos);\n      probe_log(\"MHD_del_response_header: removed header node %p, freeing memory\", (void *)pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        unsigned long old_flags = (unsigned long) response->flags_auto;\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        probe_log(\"MHD_del_response_header: cleared TRANS_ENC_CHUNKED flag old=0x%lx new=0x%lx\",\n                  old_flags, (unsigned long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        unsigned long old_flags = (unsigned long) response->flags_auto;\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        probe_log(\"MHD_del_response_header: cleared DATE_HDR flag old=0x%lx new=0x%lx\",\n                  old_flags, (unsigned long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: content-length header removed, checking for remaining content-length entries\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          unsigned long old_flags = (unsigned long) response->flags_auto;\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n          probe_log(\"MHD_del_response_header: cleared CONTENT_LENGTH flag old=0x%lx new=0x%lx\",\n                    old_flags, (unsigned long) response->flags_auto);\n        }\n        else\n        {\n          probe_log(\"MHD_del_response_header: another content-length header remains, flags unchanged=0x%lx\",\n                    (unsigned long) response->flags_auto);\n        }\n      }\n      probe_log(\"MHD_del_response_header: returning MHD_YES\");\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  probe_log(\"MHD_del_response_header: no matching header found, returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry header=0x5557f75690b9 content=0x5557f75690b0\nMHD_del_response_header: header_len=13 header=\"Header-Type-A\"\nMHD_del_response_header: content_len=8 content=\"value-a1\"\nMHD_del_response_header: starting scan of headers first_header=0x55581c3923a0\nMHD_del_response_header: inspecting pos=0x55581c3923a0 header_size=13 value_size=8 pos->header=0x55581c392360 pos->value=0x55581c392380\nMHD_del_response_header: match found at pos=0x55581c3923a0\nMHD_del_response_header: removed header node 0x55581c3923a0, freeing memory\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry header=0x5557f75690b9 content=0x5557f7569118\nMHD_del_response_header: header_len=13 header=\"Header-Type-A\"\nMHD_del_response_header: content_len=8 content=\"value-a3\"\nMHD_del_response_header: starting scan of headers first_header=0x55581c392420\nMHD_del_response_header: inspecting pos=0x55581c392420 header_size=13 value_size=8 pos->header=0x55581c3923e0 pos->value=0x55581c392400\nMHD_del_response_header: inspecting pos=0x55581c392640 header_size=13 value_size=8 pos->header=0x55581c392380 pos->value=0x55581c392360\nMHD_del_response_header: match found at pos=0x55581c392640\nMHD_del_response_header: removed header node 0x55581c392640, freeing memory\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry header=0x5557f756912f content=0x5557f7569118\nMHD_del_response_header: header_len=13 header=\"Header-Type-C\"\nMHD_del_response_header: content_len=8 content=\"value-a3\"\nMHD_del_response_header: starting scan of headers first_header=0x55581c392420\nMHD_del_response_header: inspecting pos=0x55581c392420 header_size=13 value_size=8 pos->header=0x55581c3923e0 pos->value=0x55581c392400\nMHD_del_response_header: no matching header found, returning MHD_NO\nMHD_del_response_header: entry header=0x5557f75690b9 content=0x5557f756915b\nMHD_del_response_header: header_len=13 header=\"Header-Type-A\"\nMHD_del_response_header: content_len=7 content=\"value-c\"\nMHD_del_response_header: starting scan of headers first_header=0x55581c392420\nMHD_del_response_header: inspecting pos=0x55581c392420 header_size=13 value_size=8 pos->header=0x55581c3923e0 pos->value=0x55581c392400\nMHD_del_response_header: no matching header found, returning MHD_NO\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f75691ea\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f756922f\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f7569391\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f756944c\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f7569502\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f7569570\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection returned=1\nMHD_del_response_header: entry header=0x5557f7569196 content=0x5557f75695e1\nMHD_del_response_header: header_len=10 header=\"Connection\"\nMHD_del_response_header: taking connection-header fast path\nMHD_del_response_header: del_response_header_connection return\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. If _MHD_EXTERN expands to __attribute__((visibility(\"default\"))) then the code relies on GCC/Clang __attribute__ syntax, which is a documented compiler-specific language extension and not part of standard ISO C. MISRA C 2023 Rule 1.2 prohibits use of language extensions that are explicitly documented as extensions by a compiler. Using __attribute__ via the _MHD_EXTERN macro therefore constitutes a violation of Rule 1.2, even though the attribute has no observable effect in the provided runtime log."
}