{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The memmove in the fragment can write past the end of buf because the allocation (buf_size = old_value_len + initial_norm_len) does not guarantee space for inserting the prefix \"close, \" plus the normalized tokens and the terminating NUL. The code only has an mhd_assert to check buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1, but that assert is not a runtime bound-check (it may be compiled out). If the computed initial_norm_len used for allocation is too small relative to the actual norm_len returned by MHD_str_remove_token_caseless_ plus the extra \"close, \" prefix, the memmove (moving norm_len+1 bytes to buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len) will access/write beyond the allocated buf. Thus Rule 21.17 is violated (possible out-of-bounds access).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_logf (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  mhd_logf (\"MHD_del_response_header: entry: response=%p, header=%p, content=%p\",\n            (void *) response, (void *) header, (void *) content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    mhd_logf (\"MHD_del_response_header: early return MHD_NO because header or content is NULL (header=%p, content=%p)\",\n              (void *) header, (void *) content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  mhd_logf (\"MHD_del_response_header: header_len=%zu, header='%s'\", header_len, header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    mhd_logf (\"MHD_del_response_header: connection header special-case triggered: response->flags_auto=0x%lX\",\n              (unsigned long) response->flags_auto);\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  mhd_logf (\"MHD_del_response_header: content_len=%zu, content='%s'\", content_len, content);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    mhd_logf (\"MHD_del_response_header: iter pos=%p: pos->header_size=%zu, pos->value_size=%zu, pos->header=%p, pos->value=%p\",\n              (void *) pos, pos->header_size, pos->value_size, (void *) pos->header, (void *) pos->value);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      /* Log the exact match condition before modifying state */\n      mhd_logf (\"MHD_del_response_header: match found at pos=%p (header_len=%zu, content_len=%zu). Preparing to remove header.\",\n                (void *) pos, header_len, content_len);\n\n      _MHD_remove_header (response, pos);\n      mhd_logf (\"MHD_del_response_header: _MHD_remove_header called for pos=%p\", (void *) pos);\n\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      mhd_logf (\"MHD_del_response_header: freed pos and its header/value memory\");\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        mhd_logf (\"MHD_del_response_header: clearing MHD_RAF_HAS_TRANS_ENC_CHUNKED flag. flags_auto before=0x%lX\",\n                  (unsigned long) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n        mhd_logf (\"MHD_del_response_header: flags_auto after=0x%lX\",\n                  (unsigned long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        mhd_logf (\"MHD_del_response_header: clearing MHD_RAF_HAS_DATE_HDR flag. flags_auto before=0x%lX\",\n                  (unsigned long) response->flags_auto);\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n        mhd_logf (\"MHD_del_response_header: flags_auto after=0x%lX\",\n                  (unsigned long) response->flags_auto);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          mhd_logf (\"MHD_del_response_header: no other Content-Length header found; clearing MHD_RAF_HAS_CONTENT_LENGTH. flags_auto before=0x%lX\",\n                    (unsigned long) response->flags_auto);\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n          mhd_logf (\"MHD_del_response_header: flags_auto after=0x%lX\",\n                    (unsigned long) response->flags_auto);\n        }\n        else\n        {\n          mhd_logf (\"MHD_del_response_header: another Content-Length header present; not clearing flag.\");\n        }\n      }\n\n      mhd_logf (\"MHD_del_response_header: returning MHD_YES\");\n      return MHD_YES;\n    }\n\n    /* Log the fact that this pos did not match (if lengths or memcmp differ) */\n    mhd_logf (\"MHD_del_response_header: pos=%p did not match; moving to next. next=%p\",\n              (void *) pos, (void *) pos->next);\n    pos = pos->next;\n  }\n\n  mhd_logf (\"MHD_del_response_header: completed iteration with no match; returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e0b9, content=0x55f420d2e0b0\nMHD_del_response_header: header_len=13, header='Header-Type-A'\nMHD_del_response_header: content_len=8, content='value-a1'\nMHD_del_response_header: iter pos=0x55f439bd33a0: pos->header_size=13, pos->value_size=8, pos->header=0x55f439bd3360, pos->value=0x55f439bd3380\nMHD_del_response_header: match found at pos=0x55f439bd33a0 (header_len=13, content_len=8). Preparing to remove header.\nMHD_del_response_header: _MHD_remove_header called for pos=0x55f439bd33a0\nMHD_del_response_header: freed pos and its header/value memory\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e0b9, content=0x55f420d2e118\nMHD_del_response_header: header_len=13, header='Header-Type-A'\nMHD_del_response_header: content_len=8, content='value-a3'\nMHD_del_response_header: iter pos=0x55f439bd3420: pos->header_size=13, pos->value_size=8, pos->header=0x55f439bd33e0, pos->value=0x55f439bd3400\nMHD_del_response_header: pos=0x55f439bd3420 did not match; moving to next. next=0x55f439bd3640\nMHD_del_response_header: iter pos=0x55f439bd3640: pos->header_size=13, pos->value_size=8, pos->header=0x55f439bd3380, pos->value=0x55f439bd3360\nMHD_del_response_header: match found at pos=0x55f439bd3640 (header_len=13, content_len=8). Preparing to remove header.\nMHD_del_response_header: _MHD_remove_header called for pos=0x55f439bd3640\nMHD_del_response_header: freed pos and its header/value memory\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e12f, content=0x55f420d2e118\nMHD_del_response_header: header_len=13, header='Header-Type-C'\nMHD_del_response_header: content_len=8, content='value-a3'\nMHD_del_response_header: iter pos=0x55f439bd3420: pos->header_size=13, pos->value_size=8, pos->header=0x55f439bd33e0, pos->value=0x55f439bd3400\nMHD_del_response_header: pos=0x55f439bd3420 did not match; moving to next. next=(nil)\nMHD_del_response_header: completed iteration with no match; returning MHD_NO\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e0b9, content=0x55f420d2e15b\nMHD_del_response_header: header_len=13, header='Header-Type-A'\nMHD_del_response_header: content_len=7, content='value-c'\nMHD_del_response_header: iter pos=0x55f439bd3420: pos->header_size=13, pos->value_size=8, pos->header=0x55f439bd33e0, pos->value=0x55f439bd3400\nMHD_del_response_header: pos=0x55f439bd3420 did not match; moving to next. next=(nil)\nMHD_del_response_header: completed iteration with no match; returning MHD_NO\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e1ea\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_header: connection header special-case triggered: response->flags_auto=0x1\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e22f\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_header: connection header special-case triggered: response->flags_auto=0x3\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e391\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_header: connection header special-case triggered: response->flags_auto=0x3\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e44c\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_header: connection header special-case triggered: response->flags_auto=0x3\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e502\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_header: connection header special-case triggered: response->flags_auto=0x3\nMHD_del_response_header: entry: response=0x55f439bd32a0, header=0x55f420d2e196, content=0x55f420d2e570\nMHD_del_response_header: header_len=10, header='Connection'\nMHD_del_response_hea\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported problem (an out\u2011of\u2011bounds memmove caused by an insufficient allocation and only an assert check) does not apply to the MHD_del_response_header code shown. That function uses strlen and memcmp (both functions from <string.h> mentioned by MISRA 21.17) but it performs a runtime check header_len == pos->header_size and content_len == pos->value_size before calling memcmp. header_len and content_len are computed by strlen(header)/strlen(content) so memcmp(header, pos->header, header_len) and memcmp(content, pos->value, content_len) read exactly the number of bytes established at runtime and only when the stored pos sizes match \u2014 therefore there is a runtime bound check and no memmove or other write into a computed buffer inside this function. The memmove/alloc/assert scenario described by agent A refers to a different fragment (e.g. del_response_header_connection) that is not present in the target code. The provided test logs show normal operation and no evidence of out\u2011of\u2011bounds access for MHD_del_response_header. Consequently the report is not correct for the shown function."
}