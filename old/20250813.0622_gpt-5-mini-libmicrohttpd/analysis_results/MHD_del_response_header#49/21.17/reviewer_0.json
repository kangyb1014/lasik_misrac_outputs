{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When add_response_header_connection is called with value == NULL (for example, via a call to MHD_add_response_header(response, \"Connection\", NULL)), the code calls strchr(value, '\\r') / strchr(value, '\\n') and then strlen(value). These string.h calls will dereference a NULL pointer / access memory beyond the bounds of the object, so the use of strlen(value) can result in out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log_simple(const char *tag, struct MHD_Response *response, const char *header, const char *content)\n{\n  FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf(f, \"[%s] response=%p header=%p content=%p\\n\", tag, (void *) response, (void *) header, (void *) content);\n  if (header)\n    fprintf(f, \"  header=\\\"%s\\\"\\n\", header);\n  else\n    fprintf(f, \"  header=NULL\\n\");\n  if (content)\n    fprintf(f, \"  content=\\\"%s\\\"\\n\", content);\n  else\n    fprintf(f, \"  content=NULL\\n\");\n  fclose(f);\n}\nstatic void mhd_probe_log_msg(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n  if (!f)\n    return;\n  fprintf(f, \"%s\\n\", msg);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  /* Entry probe: log pointers and strings (safely) */\n  mhd_probe_log_simple(\"ENTRY\", response, header, content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    /* Log the early return reason */\n    mhd_probe_log_msg(\"EARLY_RETURN: header or content is NULL -> returning MHD_NO\");\n    mhd_probe_log_simple(\"EARLY_STATE\", response, header, content);\n    return MHD_NO;\n  }\n\n  /* Safe: header is non-NULL here */\n  header_len = strlen (header);\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"AFTER_HEADER_LEN: header_len=%zu\", header_len);\n    mhd_probe_log_msg(buf);\n  }\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    /* Log that we are about to call the specialized del for Connection */\n    mhd_probe_log_msg(\"SPECIAL_CASE: header is Connection -> calling del_response_header_connection\");\n    mhd_probe_log_simple(\"SPECIAL_CALL\", response, header, content);\n    return del_response_header_connection (response, content);\n  }\n\n  /* Safe: content is non-NULL here */\n  content_len = strlen (content);\n  {\n    char buf[128];\n    snprintf(buf, sizeof(buf), \"AFTER_CONTENT_LEN: content_len=%zu\", content_len);\n    mhd_probe_log_msg(buf);\n  }\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    /* Log current position and sizes (do not dereference value buffers as strings) */\n    {\n      FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n      if (f)\n      {\n        fprintf(f, \"LOOP_POS: pos=%p pos->header_size=%zu pos->value_size=%zu\\n\",\n                (void *) pos, pos->header_size, pos->value_size);\n        fclose(f);\n      }\n    }\n\n    /* Compute memcmp results for logging but do not change behaviour */\n    int header_cmp = 1;\n    int value_cmp = 1;\n    if (header_len == pos->header_size)\n      header_cmp = memcmp (header, pos->header, header_len);\n    if (content_len == pos->value_size)\n      value_cmp = memcmp (content, pos->value, content_len);\n\n    {\n      char buf[256];\n      snprintf(buf, sizeof(buf), \"CMP_RESULTS: header_cmp=%d value_cmp=%d (header_len==pos->header_size?%d content_len==pos->value_size?%d)\",\n               header_cmp, value_cmp, (int)(header_len == pos->header_size), (int)(content_len == pos->value_size));\n      mhd_probe_log_msg(buf);\n    }\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      /* Log the match and safely dump bounded header/value bytes */\n      {\n        FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n        if (f)\n        {\n          fprintf(f, \"MATCH_FOUND: removing header at pos=%p\\n\", (void *) pos);\n          if (header_len > 0 && pos->header)\n          {\n            fprintf(f, \"  matched_header (len=%zu): \\\"\", header_len);\n            fwrite(pos->header, 1, header_len, f);\n            fprintf(f, \"\\\"\\n\");\n          }\n          if (content_len > 0 && pos->value)\n          {\n            fprintf(f, \"  matched_value (len=%zu): \\\"\", content_len);\n            fwrite(pos->value, 1, content_len, f);\n            fprintf(f, \"\\\"\\n\");\n          }\n          fclose(f);\n        }\n      }\n\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n\n      mhd_probe_log_msg(\"RETURNING: MHD_YES (header removed)\");\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n\n  mhd_probe_log_msg(\"LOOP_COMPLETE: no matching header found -> returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_del_response_header. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for this function. MHD_del_response_header explicitly checks for NULL for both header and content at the top: if ((NULL == header) || (NULL == content)) return MHD_NO; So subsequent calls to strlen(header) and strlen(content) (and any other string.h functions used here) only occur when those pointers are non-NULL. The special-case that invokes del_response_header_connection(response, content) is reached only after that NULL-check, so content cannot be NULL when passed to the specialized routine from this function. The memcmp calls are guarded by equal-length checks (and memcmp with n==0 is harmless), so no out-of-bounds access is introduced here. The agent appears to have confused behavior in some add_response_header path (or del_response_header_connection implementation) with this function. For MHD_del_response_header as shown, the claim of a MISRA 21.17 violation is incorrect."
}