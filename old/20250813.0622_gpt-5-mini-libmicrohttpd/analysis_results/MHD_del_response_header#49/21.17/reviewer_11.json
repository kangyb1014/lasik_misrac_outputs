{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memcmp(hdr->value, \"close\", 5) can read five bytes from hdr->value unconditionally. If hdr is NULL (the NULL check is performed only in a later mhd_assert) or hdr->value has length < 5 (e.g. malformed/corrupted header), memcmp will access bytes beyond the object bounds. This use of memcmp therefore can result in out-of-bounds accesses and violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/399.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  probe_log(\"MHD_del_response_header: entry response=%p header=%p content=%p\",\n            (void *) response, (void *) header, (void *) content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    probe_log(\"MHD_del_response_header: NULL param, header=%p content=%p\",\n              (void *) header, (void *) content);\n    return MHD_NO;\n  }\n\n  header_len = strlen (header);\n  probe_log(\"MHD_del_response_header: header_len=%zu header='%..*s'\",\n            header_len > 200 ? 200U : (unsigned)header_len,\n            (int)(header_len > 200 ? 200 : (unsigned)header_len),\n            header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    probe_log(\"MHD_del_response_header: special-case CONNECTION header -> del_response_header_connection called\");\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  probe_log(\"MHD_del_response_header: content_len=%zu content='%..*s'\",\n            content_len > 200 ? 200U : (unsigned)content_len,\n            (int)(content_len > 200 ? 200 : (unsigned)content_len),\n            content);\n\n  pos = response->first_header;\n  probe_log(\"MHD_del_response_header: starting traversal, first_header=%p\", (void *) pos);\n  while (NULL != pos)\n  {\n    /* Log header node state safely (do not dereference strings that may be NULL) */\n    probe_log(\"node: pos=%p header_ptr=%p value_ptr=%p header_size=%zu value_size=%zu next=%p\",\n              (void *) pos,\n              (void *) pos->header,\n              (void *) pos->value,\n              pos->header_size,\n              pos->value_size,\n              (void *) pos->next);\n\n    /* Log the individual condition checks to capture control flow */\n    probe_log(\"compare: header_len==pos->header_size ? %s\",\n              (header_len == pos->header_size) ? \"true\" : \"false\");\n    probe_log(\"compare: content_len==pos->value_size ? %s\",\n              (content_len == pos->value_size) ? \"true\" : \"false\");\n\n    /* If either pos->header or pos->value are NULL, record that explicitly */\n    if (NULL == pos->header)\n      probe_log(\"warning: pos->header is NULL (pos=%p)\", (void *) pos);\n    if (NULL == pos->value)\n      probe_log(\"warning: pos->value is NULL (pos=%p)\", (void *) pos);\n\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      probe_log(\"MHD_del_response_header: match found at pos=%p; removing header\", (void *) pos);\n\n      _MHD_remove_header (response, pos);\n      probe_log(\"MHD_del_response_header: removed header from list; freeing memory of pos=%p header_ptr=%p value_ptr=%p\",\n                (void *) pos, (void *) pos->header, (void *) pos->value);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        probe_log(\"MHD_del_response_header: cleared RAF_HAS_TRANS_ENC_CHUNKED flag\");\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: cleared RAF_HAS_DATE_HDR flag\");\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: matched CONTENT_LENGTH header; checking for other elements\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          probe_log(\"MHD_del_response_header: no other CONTENT_LENGTH element found; clearing RAF_HAS_CONTENT_LENGTH flag\");\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n        else\n        {\n          probe_log(\"MHD_del_response_header: other CONTENT_LENGTH element exists; not clearing flag\");\n        }\n      }\n      probe_log(\"MHD_del_response_header: returning MHD_YES\");\n      return MHD_YES;\n    }\n    probe_log(\"MHD_del_response_header: no match at pos=%p; continuing\", (void *) pos);\n    pos = pos->next;\n  }\n  probe_log(\"MHD_del_response_header: traversal finished, no match found; returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f0b9 content=0x562a1651f0b0\nMHD_del_response_header: header_len=13 header='%.0.*s'\nMHD_del_response_header: content_len=8 content='%.0.*s'\nMHD_del_response_header: starting traversal, first_header=0x562a538c63a0\nnode: pos=0x562a538c63a0 header_ptr=0x562a538c6360 value_ptr=0x562a538c6380 header_size=13 value_size=8 next=0x562a538c6420\ncompare: header_len==pos->header_size ? true\ncompare: content_len==pos->value_size ? true\nMHD_del_response_header: match found at pos=0x562a538c63a0; removing header\nMHD_del_response_header: removed header from list; freeing memory of pos=0x562a538c63a0 header_ptr=0x562a538c6360 value_ptr=0x562a538c6380\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f0b9 content=0x562a1651f118\nMHD_del_response_header: header_len=13 header='%.0.*s'\nMHD_del_response_header: content_len=8 content='%.0.*s'\nMHD_del_response_header: starting traversal, first_header=0x562a538c6420\nnode: pos=0x562a538c6420 header_ptr=0x562a538c63e0 value_ptr=0x562a538c6400 header_size=13 value_size=8 next=0x562a538c6640\ncompare: header_len==pos->header_size ? true\ncompare: content_len==pos->value_size ? true\nMHD_del_response_header: no match at pos=0x562a538c6420; continuing\nnode: pos=0x562a538c6640 header_ptr=0x562a538c6380 value_ptr=0x562a538c6360 header_size=13 value_size=8 next=(nil)\ncompare: header_len==pos->header_size ? true\ncompare: content_len==pos->value_size ? true\nMHD_del_response_header: match found at pos=0x562a538c6640; removing header\nMHD_del_response_header: removed header from list; freeing memory of pos=0x562a538c6640 header_ptr=0x562a538c6380 value_ptr=0x562a538c6360\nMHD_del_response_header: returning MHD_YES\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f12f content=0x562a1651f118\nMHD_del_response_header: header_len=13 header='%.0.*s'\nMHD_del_response_header: content_len=8 content='%.0.*s'\nMHD_del_response_header: starting traversal, first_header=0x562a538c6420\nnode: pos=0x562a538c6420 header_ptr=0x562a538c63e0 value_ptr=0x562a538c6400 header_size=13 value_size=8 next=(nil)\ncompare: header_len==pos->header_size ? true\ncompare: content_len==pos->value_size ? true\nMHD_del_response_header: no match at pos=0x562a538c6420; continuing\nMHD_del_response_header: traversal finished, no match found; returning MHD_NO\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f0b9 content=0x562a1651f15b\nMHD_del_response_header: header_len=13 header='%.0.*s'\nMHD_del_response_header: content_len=7 content='%.0.*s'\nMHD_del_response_header: starting traversal, first_header=0x562a538c6420\nnode: pos=0x562a538c6420 header_ptr=0x562a538c63e0 value_ptr=0x562a538c6400 header_size=13 value_size=8 next=(nil)\ncompare: header_len==pos->header_size ? true\ncompare: content_len==pos->value_size ? false\nMHD_del_response_header: no match at pos=0x562a538c6420; continuing\nMHD_del_response_header: traversal finished, no match found; returning MHD_NO\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f196 content=0x562a1651f1ea\nMHD_del_response_header: header_len=10 header='%.0.*s'\nMHD_del_response_header: special-case CONNECTION header -> del_response_header_connection called\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f196 content=0x562a1651f22f\nMHD_del_response_header: header_len=10 header='%.0.*s'\nMHD_del_response_header: special-case CONNECTION header -> del_response_header_connection called\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f196 content=0x562a1651f391\nMHD_del_response_header: header_len=10 header='%.0.*s'\nMHD_del_response_header: special-case CONNECTION header -> del_response_header_connection called\nMHD_del_response_header: entry response=0x562a538c62a0 header=0x562a1651f196 content=0x562a1651f44c\nMHD_del_response_header: header_len=10 header='%.0.*s'\nMHD_del_response_header: special-case CONNECTION header -> del_response_header_connection called\nMHD_del_response_header: entry r\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MHD_del_response_header performs the necessary checks before calling memcmp: header and content are checked for NULL and their lengths computed with strlen; the code only calls memcmp when header_len == pos->header_size and content_len == pos->value_size. That guarantees the memcmp length is equal to the recorded sizes, and for the input pointers (header/content) strlen guarantees at least header_len/content_len bytes are accessible. The test log confirms that when memcmp is reached the node pointers are non-NULL and the sizes match (compare: ... ? true), and matches are found only in those cases. The hypothetical scenario (memcmp(hdr->value, \"close\",5) reading beyond bounds because hdr is NULL or shorter) does not reflect this function\u2019s control flow or the observed test results. Therefore the claimed MISRA Rule 21.17 violation is not supported by the code or the provided exhaustive test output."
}