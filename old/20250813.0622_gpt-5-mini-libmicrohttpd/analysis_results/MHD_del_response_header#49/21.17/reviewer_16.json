{
  "user_message": "An agent A claimed that the following MHD_del_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_del_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The computed buf_size is old_value_len + norm_len but later code may memmove/memcpy more bytes than that. In add_response_header_connection, when value_has_close is true the code does memmove(buf + MHD_STATICSTR_LEN_(\"close, \") + old_value_len, buf + old_value_len, norm_len + 1) and then writes the \"close\" token and possibly \", \" and a terminating NUL. The earlier mhd_assert expects buf_size >= old_value_len + norm_len + MHD_STATICSTR_LEN_(\"close, \") + 1, but buf_size was allocated as only old_value_len + norm_len. If assertions are disabled this leads to memmove/memcpy accessing/writing past the end of the allocated buffer (out-of-bounds), violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_ensure_dir(void)\n{\n  /* Best-effort create directory; ignore errors. */\n  (void)mkdir(\"/tmp/logs\", 0777);\n}\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n  probe_ensure_dir();\n  f = fopen(\"/tmp/logs/399.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  probe_log(\"MHD_del_response_header: entry: response=%p, header=%p, content=%p\",\n            (void *)response, (const void *)header, (const void *)content);\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n  {\n    probe_log(\"MHD_del_response_header: NULL parameter(s): header=%p content=%p\",\n              (const void *)header, (const void *)content);\n    return MHD_NO;\n  }\n  header_len = strlen (header);\n  probe_log(\"MHD_del_response_header: header_len=%zu, header_text='%s'\", header_len, header);\n\n  probe_log(\"MHD_del_response_header: flags_auto=0x%08x\",\n            (unsigned int) response->flags_auto);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n  {\n    probe_log(\"MHD_del_response_header: taking Connection special-case path (del_response_header_connection) for header='%s'\", header);\n    return del_response_header_connection (response, content);\n  }\n\n  content_len = strlen (content);\n  probe_log(\"MHD_del_response_header: content_len=%zu, content_text='%s'\", content_len, content);\n\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    probe_log(\"MHD_del_response_header: iter pos=%p header_size=%zu value_size=%zu pos->header=%p pos->value=%p\",\n              (void *)pos, pos->header_size, pos->value_size, (const void *)pos->header, (const void *)pos->value);\n\n    /* Evaluate comparisons once and log their intermediate results to help reproduce\n       potential out-of-bounds scenarios. */\n    int header_size_eq = (header_len == pos->header_size);\n    int value_size_eq = (content_len == pos->value_size);\n    int header_memcmp = 1;\n    int value_memcmp = 1;\n\n    if (header_size_eq)\n    {\n      /* Only compare if sizes match to avoid memcmp reading beyond buffers. */\n      header_memcmp = (0 == memcmp (header, pos->header, header_len));\n    }\n    else\n    {\n      probe_log(\"MHD_del_response_header: skipping header memcmp because sizes differ: header_len=%zu pos->header_size=%zu\",\n                header_len, pos->header_size);\n    }\n\n    if (value_size_eq)\n    {\n      /* Only compare if sizes match to avoid memcmp reading beyond buffers. */\n      value_memcmp = (0 == memcmp (content, pos->value, content_len));\n    }\n    else\n    {\n      probe_log(\"MHD_del_response_header: skipping value memcmp because sizes differ: content_len=%zu pos->value_size=%zu\",\n                content_len, pos->value_size);\n    }\n\n    probe_log(\"MHD_del_response_header: comparisons: header_size_eq=%d value_size_eq=%d header_memcmp=%d value_memcmp=%d\",\n              header_size_eq, value_size_eq, header_memcmp, value_memcmp);\n\n    if (header_size_eq && value_size_eq && header_memcmp && value_memcmp)\n    {\n      probe_log(\"MHD_del_response_header: match found at pos=%p; about to remove header. pos->header='%.*s' pos->value='%.*s'\",\n                (void *)pos,\n                (int)pos->header_size, pos->header,\n                (int)pos->value_size, pos->value);\n\n      _MHD_remove_header (response, pos);\n\n      /* Log the memory addresses and sizes before freeing to capture state. */\n      probe_log(\"MHD_del_response_header: freeing pos->header=%p (size=%zu) pos->value=%p (size=%zu) pos=%p\",\n                (const void *)pos->header, pos->header_size, (const void *)pos->value, pos->value_size, (void *)pos);\n\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n      {\n        probe_log(\"MHD_del_response_header: clearing MHD_RAF_HAS_TRANS_ENC_CHUNKED flag\");\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: clearing MHD_RAF_HAS_DATE_HDR flag\");\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      }\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        probe_log(\"MHD_del_response_header: header is Content-Length; checking for remaining content-length headers\");\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n        {\n          probe_log(\"MHD_del_response_header: no remaining Content-Length header found; clearing MHD_RAF_HAS_CONTENT_LENGTH flag\");\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n        }\n        else\n        {\n          probe_log(\"MHD_del_response_header: another Content-Length header remains; not clearing flag\");\n        }\n      }\n\n      probe_log(\"MHD_del_response_header: leaving with MHD_YES; flags_auto now=0x%08x\",\n                (unsigned int) response->flags_auto);\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  probe_log(\"MHD_del_response_header: no match found; returning MHD_NO\");\n  return MHD_NO;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a0b9, content=0x559ff872a0b0\nMHD_del_response_header: header_len=13, header_text='Header-Type-A'\nMHD_del_response_header: flags_auto=0x00000000\nMHD_del_response_header: content_len=8, content_text='value-a1'\nMHD_del_response_header: iter pos=0x55a008a723a0 header_size=13 value_size=8 pos->header=0x55a008a72360 pos->value=0x55a008a72380\nMHD_del_response_header: comparisons: header_size_eq=1 value_size_eq=1 header_memcmp=1 value_memcmp=1\nMHD_del_response_header: match found at pos=0x55a008a723a0; about to remove header. pos->header='Header-Type-A' pos->value='value-a1'\nMHD_del_response_header: freeing pos->header=0x55a008a72360 (size=13) pos->value=0x55a008a72380 (size=8) pos=0x55a008a723a0\nMHD_del_response_header: leaving with MHD_YES; flags_auto now=0x00000000\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a0b9, content=0x559ff872a118\nMHD_del_response_header: header_len=13, header_text='Header-Type-A'\nMHD_del_response_header: flags_auto=0x00000000\nMHD_del_response_header: content_len=8, content_text='value-a3'\nMHD_del_response_header: iter pos=0x55a008a72420 header_size=13 value_size=8 pos->header=0x55a008a723e0 pos->value=0x55a008a72400\nMHD_del_response_header: comparisons: header_size_eq=1 value_size_eq=1 header_memcmp=1 value_memcmp=0\nMHD_del_response_header: iter pos=0x55a008a72640 header_size=13 value_size=8 pos->header=0x55a008a72380 pos->value=0x55a008a72360\nMHD_del_response_header: comparisons: header_size_eq=1 value_size_eq=1 header_memcmp=1 value_memcmp=1\nMHD_del_response_header: match found at pos=0x55a008a72640; about to remove header. pos->header='Header-Type-A' pos->value='value-a3'\nMHD_del_response_header: freeing pos->header=0x55a008a72380 (size=13) pos->value=0x55a008a72360 (size=8) pos=0x55a008a72640\nMHD_del_response_header: leaving with MHD_YES; flags_auto now=0x00000000\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a12f, content=0x559ff872a118\nMHD_del_response_header: header_len=13, header_text='Header-Type-C'\nMHD_del_response_header: flags_auto=0x00000000\nMHD_del_response_header: content_len=8, content_text='value-a3'\nMHD_del_response_header: iter pos=0x55a008a72420 header_size=13 value_size=8 pos->header=0x55a008a723e0 pos->value=0x55a008a72400\nMHD_del_response_header: comparisons: header_size_eq=1 value_size_eq=1 header_memcmp=0 value_memcmp=0\nMHD_del_response_header: no match found; returning MHD_NO\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a0b9, content=0x559ff872a15b\nMHD_del_response_header: header_len=13, header_text='Header-Type-A'\nMHD_del_response_header: flags_auto=0x00000000\nMHD_del_response_header: content_len=7, content_text='value-c'\nMHD_del_response_header: iter pos=0x55a008a72420 header_size=13 value_size=8 pos->header=0x55a008a723e0 pos->value=0x55a008a72400\nMHD_del_response_header: skipping value memcmp because sizes differ: content_len=7 pos->value_size=8\nMHD_del_response_header: comparisons: header_size_eq=1 value_size_eq=0 header_memcmp=1 value_memcmp=1\nMHD_del_response_header: no match found; returning MHD_NO\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a196, content=0x559ff872a1ea\nMHD_del_response_header: header_len=10, header_text='Connection'\nMHD_del_response_header: flags_auto=0x00000001\nMHD_del_response_header: taking Connection special-case path (del_response_header_connection) for header='Connection'\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a196, content=0x559ff872a22f\nMHD_del_response_header: header_len=10, header_text='Connection'\nMHD_del_response_header: flags_auto=0x00000003\nMHD_del_response_header: taking Connection special-case path (del_response_header_connection) for header='Connection'\nMHD_del_response_header: entry: response=0x55a008a722a0, header=0x559ff872a196, content=0x559ff872a391\nMHD_del_response_header: header_len=10, header_text='Connection'\nMHD_del_response_header: flags_auto=0x00000003\nMHD_del_response_header: taking Connection specia\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct. The shown MHD_del_response_header implementation performs length checks before any memcmp calls (it compares header_len==pos->header_size and content_len==pos->value_size and only then calls memcmp with those exact lengths), so the memcmp and strlen usages in this function do not read beyond the referenced objects. The function delegates Connection-specific handling to del_response_header_connection via the special-case path; any out-of-bounds memmove/memcpy described by agent A occurs in add_response_header_connection (or other Connection-handling code), not in MHD_del_response_header itself. Therefore MHD_del_response_header as presented does not violate MISRA C 2023 Rule 21.17."
}