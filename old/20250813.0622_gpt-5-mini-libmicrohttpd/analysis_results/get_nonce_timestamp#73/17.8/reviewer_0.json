{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function parameter 'noncelen' (a non-const size_t) is assigned to inside the function: if (0 == noncelen) noncelen = strlen(nonce); \u2014 this modifies the parameter variable, violating MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  /* Log entry state */\n  {\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"ENTRY: get_nonce_timestamp nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n                (void *)nonce, noncelen, (void *)ptimestamp);\n        if (nonce != NULL && noncelen > 0U)\n          {\n            /* print a short prefix of the nonce for context, avoid overruns */\n            size_t show = (noncelen > 64U) ? 64U : noncelen;\n            fprintf(f, \"ENTRY: nonce prefix (len=%zu): \\\"%.*s\\\"\\n\",\n                    show, (int)show, nonce);\n          }\n        fclose(f);\n      }\n  }\n\n  if (0 == noncelen)\n    {\n      /* Log that we will compute strlen and the value computed */\n      size_t computed = strlen (nonce);\n      {\n        FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"ACTION: noncelen was 0, computed strlen(nonce)=%zu\\n\", computed);\n            fclose(f);\n          }\n      }\n\n      /* Preserve original behavior: assign to parameter (existing violation scenario) */\n      noncelen = computed;\n\n      /* Log post-modification state */\n      {\n        FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"STATE: noncelen updated to %zu after strlen(nonce)\\n\", noncelen);\n            fclose(f);\n          }\n      }\n    }\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    {\n      FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n      if (f)\n        {\n          fprintf(f, \"CHECK: standard-length check failed, noncelen=%zu -> returning false\\n\", noncelen);\n          fclose(f);\n        }\n      return false;\n    }\n\n  /* Log details before parsing timestamp */\n  {\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"ACTION: about to parse timestamp from nonce at offset (noncelen - TIMESTAMP_CHARS_LEN) = %zu\\n\",\n                (noncelen >= TIMESTAMP_CHARS_LEN) ? (noncelen - TIMESTAMP_CHARS_LEN) : 0U);\n        fclose(f);\n      }\n  }\n\n  /* Call the existing parser but capture its return to log it */\n  {\n    size_t rv = MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                                       TIMESTAMP_CHARS_LEN,\n                                       ptimestamp);\n\n    /* Log parse result and the parsed timestamp value (if any) */\n    {\n      FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n      if (f)\n        {\n          fprintf(f, \"RESULT: MHD_strx_to_uint64_n_ returned=%zu\\n\", rv);\n          if (ptimestamp != NULL)\n            fprintf(f, \"RESULT: parsed ptimestamp=%\" PRIu64 \"\\n\", *ptimestamp);\n          fclose(f);\n        }\n    }\n\n    if (TIMESTAMP_CHARS_LEN != rv)\n      {\n        FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n        if (f)\n          {\n            fprintf(f, \"CHECK: timestamp length mismatch (expected %d != got %zu) -> returning false\\n\", TIMESTAMP_CHARS_LEN, rv);\n            fclose(f);\n          }\n        return false;\n      }\n  }\n\n  {\n    FILE *f = fopen(\"/tmp/logs/589.txt\", \"a\");\n    if (f)\n      {\n        fprintf(f, \"EXIT: returning true\\n\");\n        fclose(f);\n      }\n  }\n\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_nonce_timestamp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 states that a function parameter shall not be modified. In the provided code the scalar parameter noncelen (declared as size_t noncelen) is assigned to inside the function (noncelen = strlen(nonce);), which is a direct modification of a parameter variable and therefore violates Rule 17.8. The pointer parameters are handled correctly: the pointer values themselves are not reassigned (nonce is declared const char *const and ptimestamp is uint64_t *const) and only the object pointed-to may be written via ptimestamp, which is allowed. A compliant fix is to introduce a local variable (for example size_t len = noncelen;) and modify that local copy instead of the parameter, or mark the parameter const and use a separate local variable for any derived length."
}