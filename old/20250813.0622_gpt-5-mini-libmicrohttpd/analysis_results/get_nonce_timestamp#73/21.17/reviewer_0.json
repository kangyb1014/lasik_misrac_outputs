{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Calling strlen(username) without verifying that 'username' is non-NULL and NUL-terminated can read beyond the referenced object. In this function there is no runtime check of username != NULL or of its termination (only mhd_asserts, which may be disabled), so if a caller supplies a NULL pointer or a non-NUL-terminated buffer, strlen(username) will access out-of-bounds memory.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nnonce_log_append (const char *msg, const void *nonce, size_t noncelen, uint64_t value)\n{\n  FILE *f = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  /* Log a compact record: message, pointer, length and a numeric value when available. */\n  fprintf(f, \"%s: nonce=%p noncelen=%zu value=%\" PRIu64 \"\\n\",\n          msg ? msg : \"(null)\", nonce, noncelen, value);\n\n  fclose(f);\n}\n\nstatic uint64_t\nget_nonce_timestamp(const void *nonce, size_t noncelen)\n{\n  if (nonce == NULL || noncelen < sizeof(uint64_t))\n    return 0;\n\n  const unsigned char *b = (const unsigned char *)nonce;\n  uint64_t ts = 0;\n  for (size_t i = 0; i < sizeof(uint64_t); ++i)\n    ts = (ts << 8) | (uint64_t)b[i];\n\n  return ts;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function calls strlen(nonce) when noncelen == 0 without any runtime check that nonce is non-NULL or that the pointed object is NUL-terminated. Under MISRA C 2023 Rule 21.17 the use of string.h functions (strlen here) must not result in accesses beyond the bounds of the object referenced by their pointer parameters. If a caller passes NULL or a non-NUL-terminated buffer with noncelen == 0, strlen(nonce) can dereference NULL or read out-of-bounds \u2014 a violation. Relying on asserts (which may be disabled) does not prevent the violation. To fix, check nonce != NULL before calling strlen and ensure the buffer is properly terminated or require the caller to provide a length (non-zero) and validate it before use."
}