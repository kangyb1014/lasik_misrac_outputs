{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:memcmp(hash1_bin, hash2_bin, digest_size) compares digest_size bytes but hash1_bin and hash2_bin are declared as uint8_t hash1_bin[MAX_DIGEST]; uint8_t hash2_bin[MAX_DIGEST]. There is no explicit check in this function that digest_size <= MAX_DIGEST, so if digest_get_size(da) returns a value greater than MAX_DIGEST (due to misinitialised/incorrect digest algorithm, corrupted state or API misuse), memcmp will read beyond the bounds of the hash buffers. This would violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_nonce(const char *stage,\n                const char *nonce_ptr,\n                size_t noncelen_val,\n                size_t parsed_len,\n                uint64_t ptimestamp_val,\n                int have_timestamp)\n{\n  /* Try to create the directory if it does not exist. Ignore errors other than EEXIST. */\n  (void)mkdir(\"/tmp/logs\", 0777);\n\n  FILE *fp = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (NULL == fp)\n    return;\n\n  /* Log a compact single-line record describing the control point and state. */\n  fprintf(fp,\n          \"[get_nonce_timestamp] stage=%s nonce_ptr=%p noncelen=%zu parsed_len=%zu have_timestamp=%d ptimestamp=%\" PRIu64 \"\\n\",\n          stage,\n          (const void *)nonce_ptr,\n          noncelen_val,\n          parsed_len,\n          have_timestamp,\n          ptimestamp_val);\n\n  fclose(fp);\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  /* Log entry with original inputs. */\n  probe_log_nonce(\"entry\", nonce, noncelen, 0u, 0u, 0);\n\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  /* Log after potential strlen() adjustment. */\n  probe_log_nonce(\"after_len\", nonce, noncelen, 0u, 0u, 0);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n  {\n    /* Log the algorithm/length mismatch before returning. */\n    probe_log_nonce(\"alg_len_mismatch\", nonce, noncelen, 0u, 0u, 0);\n    return false;\n  }\n\n  /* Parse the timestamp substring once and record the parse length. */\n  size_t parsed = MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                                        TIMESTAMP_CHARS_LEN,\n                                        ptimestamp);\n\n  /* Log the parse result (do not read *ptimestamp unless parse succeeded). */\n  if (TIMESTAMP_CHARS_LEN != parsed)\n  {\n    probe_log_nonce(\"timestamp_parse_failed\", nonce, noncelen, parsed, 0u, 0);\n    return false;\n  }\n\n  /* On success, log the parsed timestamp value. */\n  probe_log_nonce(\"success\", nonce, noncelen, parsed, *ptimestamp, 1);\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_nonce_timestamp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The target get_nonce_timestamp implementation does not contain any memcmp calls or the hash/buffer variables described in the scenario, so the memcmp/digest_size out\u2011of\u2011bounds scenario that agent A describes is irrelevant to this function and Rule 21.17 as reported. In the shown code the only standard string function used is strlen (and a project-specific MHD_strx_to_uint64_n_). strlen is only called when noncelen == 0, which is a caller contract (nonce must point to a valid NUL\u2011terminated string in that case). The later pointer arithmetic (nonce + noncelen - TIMESTAMP_CHARS_LEN) is only reached when noncelen matches the expected nonce lengths (the function returns false otherwise), so there is no obvious read\u2011past\u2011end caused by a standard <string.h> call in this snippet. (Note: if callers violate the preconditions \u2014 e.g. pass a non\u2011NUL\u2011terminated buffer with noncelen == 0 or a NULL nonce \u2014 undefined behaviour can occur, but that is a caller contract issue, not the memcmp/digest_size scenario agent A claimed.)"
}