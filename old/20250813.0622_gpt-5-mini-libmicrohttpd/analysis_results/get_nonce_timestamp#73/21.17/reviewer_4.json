{
  "user_message": "An agent A claimed that the following get_nonce_timestamp code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_nonce_timestamp.\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call memcmp(nn->nonce, new_nonce, new_nonce_len) can read new_nonce_len bytes from both pointers. If new_nonce_len exceeds the actual allocated/valid bytes of new_nonce or exceeds the storage available in nn->nonce, memcmp will access beyond the objects\u2019 bounds. Although the function has mhd_assert checks (e.g. new_nonce_len <= NONCE_STD_LEN(MAX_DIGEST)) and later assertions about nn->nonce termination, these are runtime assertions that may be compiled out and do not guarantee at compile/runtime that the buffers are large enough. Example violation: a caller passes a new_nonce pointer to a short buffer but supplies a larger new_nonce_len (or corrupts noncelen), causing memcmp to read past new_nonce\u2019s end and thus violate Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_nonce_state (const char *nonce, size_t noncelen, const uint64_t *ptimestamp, const char *stage)\n{\n  FILE *f = fopen(\"/tmp/logs/591.txt\", \"a\");\n  if (!f)\n    return;\n\n  /* Print basic state */\n  fprintf(f, \"[get_nonce_timestamp] stage=%s nonce=%p noncelen=%zu ptimestamp=%p\\n\",\n          stage, (const void *)nonce, noncelen, (const void *)ptimestamp);\n\n  /* Print a sample of the nonce contents safely (only up to noncelen bytes) */\n  if (nonce != NULL && noncelen > 0) {\n    size_t sample = (noncelen < 64) ? noncelen : 64;\n    fprintf(f, \"[get_nonce_timestamp] nonce sample (len=%zu):\", sample);\n    for (size_t i = 0; i < sample; ++i) {\n      /* print as two-hex-digit values for clarity */\n      fprintf(f, \" %02x\", (unsigned char)nonce[i]);\n    }\n    fprintf(f, \"\\n\");\n  } else {\n    fprintf(f, \"[get_nonce_timestamp] nonce empty or NULL\\n\");\n  }\n\n  /* If timestamp area is addressable, log its pointer and a safe sample */\n#ifdef TIMESTAMP_CHARS_LEN\n  if (nonce != NULL && noncelen >= (size_t)TIMESTAMP_CHARS_LEN) {\n    const char *ts_ptr = nonce + noncelen - TIMESTAMP_CHARS_LEN;\n    fprintf(f, \"[get_nonce_timestamp] timestamp region ptr=%p (offset=%zu)\\n\",\n            (const void *)ts_ptr, noncelen - (size_t)TIMESTAMP_CHARS_LEN);\n    fprintf(f, \"[get_nonce_timestamp] timestamp sample:\");\n    for (size_t i = 0; i < (size_t)TIMESTAMP_CHARS_LEN; ++i)\n      fprintf(f, \" %02x\", (unsigned char)ts_ptr[i]);\n    fprintf(f, \"\\n\");\n  } else {\n    fprintf(f, \"[get_nonce_timestamp] timestamp region not readable (noncelen=%zu, TIMESTAMP_CHARS_LEN=%d)\\n\",\n            noncelen, (int)TIMESTAMP_CHARS_LEN);\n  }\n#else\n  (void)stage; /* avoid unused warning if TIMESTAMP_CHARS_LEN not defined here */\n#endif\n\n  if (ptimestamp != NULL)\n    fprintf(f, \"[get_nonce_timestamp] ptimestamp currently %llu\\n\", (unsigned long long)*ptimestamp);\n\n  fclose(f);\n}\n\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  /* Log entry state */\n  log_nonce_state(nonce, noncelen, ptimestamp, \"entry\");\n\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  /* Log after possible strlen adjustment */\n  log_nonce_state(nonce, noncelen, ptimestamp, \"after_strlen_if_zero\");\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      ) {\n    /* Log failing length check */\n    log_nonce_state(nonce, noncelen, ptimestamp, \"length_check_failed\");\n    return false;\n  }\n\n  /* Before calling MHD_strx_to_uint64_n_, log the timestamp region pointer info.\n   * Only read the timestamp bytes if it is safe (noncelen >= TIMESTAMP_CHARS_LEN). */\n  log_nonce_state(nonce, noncelen, ptimestamp, \"before_strx_to_uint64\");\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp)) {\n    /* Log failure to parse timestamp */\n    log_nonce_state(nonce, noncelen, ptimestamp, \"strx_failed\");\n    return false;\n  }\n\n  /* Successful parse - log final state */\n  log_nonce_state(nonce, noncelen, ptimestamp, \"success\");\n  return true;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_nonce_timestamp. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report as stated is not correct. The example scenario that cites memcmp (memcmp(nn->nonce, new_nonce, new_nonce_len)) does not apply to the provided get_nonce_timestamp function \u2014 that function does not call memcmp. Therefore the specific violation scenario asserted by agent A is not relevant to this code snippet.\n\nThat said, the function does call the standard library function strlen when noncelen == 0. strlen will scan memory until a NUL byte and therefore can read beyond the bounds of the buffer if the caller passes a pointer that is not NUL-terminated. Also the later expression nonce + noncelen - TIMESTAMP_CHARS_LEN dereferences a region of the buffer; if the caller-supplied noncelen does not actually reflect the allocated/valid length of nonce, the read performed by MHD_strx_to_uint64_n_ could also access out of bounds. Those are real failure modes that would violate MISRA C 2023 Rule 21.17 if they can occur at runtime.\n\nIn short: agent A\u2019s concrete example (memcmp) is incorrect for this function, so the report as given is not correct. However there is a separate, valid concern that calling strlen when noncelen==0 (or trusting a caller-supplied noncelen) can lead to out-of-bounds accesses; to be MISRA-compliant the code must ensure (by contract, checks, or use of length-limited APIs) that these conditions cannot occur."
}