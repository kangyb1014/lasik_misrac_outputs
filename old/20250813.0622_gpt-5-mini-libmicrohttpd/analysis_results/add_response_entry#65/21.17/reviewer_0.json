{
  "user_message": "An agent A claimed that the following add_response_entry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry.\n```c\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code can invoke memchr(header, '\\t', header_len) with an invalid pointer/length. add_response_entry calls header_len = strlen(header) without checking header != NULL, so passing a NULL header (or a header whose representation/length does not match header_len) leads to undefined behaviour: strlen(NULL) already dereferences NULL and, more generally, memchr will read header_len bytes from header and thus may access beyond the bounds of the object referenced by header. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void add_response_entry_probe(const char *header, const char *content)\n{\n  FILE *f = fopen(\"/tmp/logs/527.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  fprintf(f, \"add_response_entry invoked\\n\");\n  fprintf(f, \"  header pointer: %p\\n\", (const void *) header);\n  fprintf(f, \"  content pointer: %p\\n\", (const void *) content);\n\n  if (content != NULL)\n  {\n    /* content is guaranteed non-NULL by the original function's check, so it's safe to measure. */\n    size_t content_len = strlen(content);\n    fprintf(f, \"  content length (strlen): %zu\\n\", content_len);\n  }\n  else\n  {\n    fprintf(f, \"  content is NULL\\n\");\n  }\n\n  /* We explicitly log that we're about to call strlen(header). Do NOT call strlen(header) here,\n     because we must preserve the original ordering/behavior (including the potential UB when\n     header is NULL) so that the violation scenario can be reproduced and evidenced. */\n  if (header == NULL)\n    fprintf(f, \"  header is NULL -- about to call strlen(header) (this will cause undefined behavior)\\n\");\n  else\n    fprintf(f, \"  header non-NULL -- about to call strlen(header)\\n\");\n\n  fflush(f);\n  fclose(f);\n}\n\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  /* Insert probe here to capture the control flow and state before the risky call to strlen(header).\n     This preserves the original logic and ordering so the violation can be reproduced. */\n  add_response_entry_probe(header, content);\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for add_response_entry. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A's report is correct. MISRA C:2023 Rule 21.17 requires that uses of string.h functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the posted code add_response_entry the function checks content for NULL but does not check header. The call header_len = strlen(header) will dereference header; if header is NULL (or otherwise invalid/dangling) this is undefined behaviour and constitutes an out\u2011of\u2011bounds/invalid access with respect to the string.h functions. Further, header and header_len are then forwarded to add_response_entry_n, which (per the scenario) may call memchr(header, ..., header_len) and thus would also perform out\u2011of\u2011bounds reads if header is invalid or shorter than header_len. The only circumstance in which this would not be a violation is if there is an explicit, documented and enforced precondition (API contract) that header is never NULL and all callers satisfy that contract; in the absence of such a guarantee the code violates Rule 21.17. Recommended fixes include validating header != NULL before calling strlen, using a bounded variant (e.g. strnlen with a known maximum) or otherwise ensuring the calling contract guarantees a valid, NUL\u2011terminated buffer."
}