{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 2.2.\nHere is the comment from the agent.\n<violation scenario>\nThe statement '(void) fd_setsize;' is executed but has no effect: immediately afterwards fd_setsize is assigned a value, and the (void) cast does not change program behaviour. Removing that (void) statement would not affect behaviour, so it is dead code.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified thread_main_handle_connection code that contains useful probe functions that print useful logs to a file \"/tmp/logs/122.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of thread_main_handle_connection as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of thread_main_handle_connection:\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\nPlease provide the modified thread_main_handle_connection code.\n",
  "test_code": "static void probe_logf(const char *fmt, ...)\n{\n  /* Simple probe logger to /tmp/logs/122.txt. Open in append mode so multiple\n   * threads will append. Keep function small to avoid changing program logic. */\n  FILE *f = fopen(\"/tmp/logs/122.txt\", \"a\");\n  if (! f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  probe_logf(\"thread_main_handle_connection: enter con=%p daemon=%p state=%d socket_fd=%ld\",\n             (void *)con, (void *)daemon, (int)con->state, (long)con->socket_fd);\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      probe_logf(\"con=%p suspended branch entered (was_suspended=%d)\", (void *)con, (int)was_suspended);\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n          probe_logf(\"con=%p failed to add itc fd to rs in suspended branch\", (void *)con);\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          probe_logf(\"con=%p select on itc returned error=%d\", (void *)con, err);\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          {\n            probe_logf(\"con=%p select interrupted (EINTR), continuing loop\", (void *)con);\n            continue;\n          }\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          probe_logf(\"con=%p select on itc failed, breaking loop\", (void *)con);\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        probe_logf(\"con=%p poll waiting on itc fd=%d\", (void *)con, (int)p[0].fd);\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          probe_logf(\"con=%p poll on itc returned error, breaking loop\", (void *)con);\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      probe_logf(\"con=%p suspended branch: itc cleared, continue to check resume\", (void *)con);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      probe_logf(\"con=%p resumed from suspend: updating last activity and handling idle\", (void *)con);\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    probe_logf(\"con=%p event_loop_info=0x%x use_zero_timeout=%d use_poll=%d\",\n               (void *)con, (unsigned)con->event_loop_info, (int)use_zero_timeout, (int)use_poll);\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        probe_logf(\"con=%p added socket_fd=%ld to rs (err_state=%d maxsock=%ld)\",\n                   (void *)con, (long)con->socket_fd, (int)err_state, (long)maxsock);\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        probe_logf(\"con=%p added socket_fd=%ld to ws (err_state=%d maxsock=%ld)\",\n                   (void *)con, (long)con->socket_fd, (int)err_state, (long)maxsock);\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        probe_logf(\"con=%p added socket_fd=%ld to es (err_state=%d maxsock=%ld)\",\n                   (void *)con, (long)con->socket_fd, (int)err_state, (long)maxsock);\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        probe_logf(\"con=%p event loop cleanup state reached, goto exit\", (void *)con);\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n        probe_logf(\"con=%p (WINDOWS) added itc fd to rs (err_state=%d maxsock=%ld)\",\n                   (void *)con, (int)err_state, (long)maxsock);\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        probe_logf(\"con=%p err_state true, goto exit\", (void *)con);\n        goto exit;\n      }\n\n      probe_logf(\"con=%p calling select(maxsock+1=%ld) tvp=%p (timeout %s)\",\n                 (void *)con, (long)(maxsock + 1), (void *)tvp,\n                 (tvp ? \"configured\" : \"infinite\"));\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      probe_logf(\"con=%p select returned num_ready=%d\", (void *)con, num_ready);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        probe_logf(\"con=%p select error=%d\", (void *)con, err);\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        probe_logf(\"con=%p select unrecoverable error, breaking loop\", (void *)con);\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      probe_logf(\"con=%p FD_ISSET read=%d write=%d except=%d\",\n                 (void *)con,\n                 FD_ISSET (con->socket_fd, &rs) ? 1 : 0,\n                 FD_ISSET (con->socket_fd, &ws) ? 1 : 0,\n                 FD_ISSET (con->socket_fd, &es) ? 1 : 0);\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n      {\n        probe_logf(\"con=%p call_handlers returned MHD_NO, goto exit\", (void *)con);\n        goto exit;\n      }\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        probe_logf(\"con=%p poll branch: cleanup state reached, goto exit\", (void *)con);\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      probe_logf(\"con=%p calling poll on fd=%ld timeout=%d events=0x%x\",\n                 (void *)con, (long)p[0].fd, timeout_val, (unsigned)p[0].events);\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        probe_logf(\"con=%p poll returned error, breaking loop\", (void *)con);\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      probe_logf(\"con=%p poll revents=0x%x -> read=%d write=%d except=%d\",\n                 (void *)con,\n                 (unsigned)p[0].revents,\n                 (0 != (p[0].revents & POLLIN)) ? 1 : 0,\n                 (0 != (p[0].revents & POLLOUT)) ? 1 : 0,\n                 (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ? 1 : 0);\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n      {\n        probe_logf(\"con=%p call_handlers returned MHD_NO in poll branch, goto exit\", (void *)con);\n        goto exit;\n      }\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      probe_logf(\"con=%p connection upgrade branch entered\", (void *)con);\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      probe_logf(\"con=%p upgrade handling done, returning from thread\", (void *)con);\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n  {\n    probe_logf(\"con=%p connection not closed; closing with reason daemon->shutdown=%d\", (void *)con, (int)daemon->shutdown);\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  }\n  MHD_connection_handle_idle (con);\nexit:\n  probe_logf(\"con=%p reached exit label: response=%p socket_fd=%ld\",\n             (void *)con, (void *)con->rp.response, (long)con->socket_fd);\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n    probe_logf(\"con=%p destroyed response and cleared pointer\", (void *)con);\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    probe_logf(\"con=%p shutting down socket_fd=%ld (SHUT_WR)\", (void *)con, (long)con->socket_fd);\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n    probe_logf(\"con=%p failed to signal thread termination via itc\", (void *)con);\n  }\n  probe_logf(\"con=%p thread_main_handle_connection exiting\", (void *)con);\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n"
}