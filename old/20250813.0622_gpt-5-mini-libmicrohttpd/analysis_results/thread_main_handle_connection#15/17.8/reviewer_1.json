{
  "user_message": "An agent A claimed that the following thread_main_handle_connection code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of thread_main_handle_connection.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In MHD_add_to_fd_set_ the value parameter 'fd_setsize' (type int) is assigned to: 'fd_setsize = (int) FD_SETSIZE;'. This modifies a non\u2011pointer function parameter inside the function (when HAS_FD_SETSIZE_OVERRIDABLE is not defined), which violates MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n/* Fixed, self-contained compilation unit for thread_main_handle_connection\n * This file provides minimal type definitions and function declarations so that\n * the function compiles. It intentionally does not implement external library\n * functions (they are declared extern) and does not define main().\n */\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n#include <sys/select.h>\n#include <string.h>\n\n/* Minimal typedefs to match original names. No macros are defined. */\ntypedef int MHD_THRD_RTRN_TYPE_;\ntypedef /* calling convention placeholder */ int MHD_THRD_CALL_SPEC_;\n\ntypedef int MHD_socket;\n\n/* Forward declarations of external functions (no implementations here). */\nextern bool MHD_add_to_fd_set_ (int fd, fd_set *set, MHD_socket *maxsock, int fd_setsize);\nextern int MHD_SYS_select_ (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\nextern uint64_t connection_get_wait (void *con);\nextern int call_handlers (void *con, int read_ready, int write_ready, int except_ready);\nextern void MHD_thread_handle_ID_set_current_thread_ID_ (int *idptr);\nextern void MHD_update_last_activity_ (void *con);\nextern void MHD_connection_handle_idle (void *con);\nextern void MHD_destroy_response (void *response);\nextern void MHD_connection_close_ (void *con, int why);\nextern int MHD_itc_r_fd_ (void *itc);\nextern void MHD_itc_clear_ (void *itc);\nextern int MHD_ITC_IS_VALID_ (void *itc);\nextern bool MHD_itc_activate_ (void *itc, const char *s);\nextern int MHD_socket_get_error_ (void);\nextern bool MHD_SCKT_ERR_IS_EINTR_ (int err);\nextern int shutdown (int fd, int how);\n\n/* Minimal constants to preserve control flow. */\nenum {\n  MHD_CONNECTION_CLOSED = 0,\n  MHD_CONNECTION_UPGRADE = 2\n};\n\nenum {\n  MHD_EVENT_LOOP_INFO_READ = 1,\n  MHD_EVENT_LOOP_INFO_WRITE = 2,\n  MHD_EVENT_LOOP_INFO_PROCESS = 3,\n  MHD_EVENT_LOOP_INFO_PROCESS_READ = 4,\n  MHD_EVENT_LOOP_INFO_CLEANUP = 5,\n  MHD_EVENT_LOOP_INFO_PROCESS_FLAG = 0x10\n};\n\n#define MHD_INVALID_SOCKET (-1)\n\n/* Minimal struct definitions matching used fields in the function. */\nstruct MHD_Rq {\n  bool client_aware;\n  void *client_context;\n};\nstruct MHD_RP {\n  void *response;\n};\n\nstruct MHD_Daemon {\n  bool shutdown;\n  void *itc;\n  void (*notify_completed)(void *cls, void *con, void *ctx, int reason);\n  void *notify_completed_cls;\n};\n\nstruct MHD_Connection {\n  struct MHD_Daemon *daemon;\n  int state;\n  bool suspended;\n  void *urh; /* upgrade handle pointer or NULL */\n  int tid;\n  int socket_fd;\n  int event_loop_info;\n  int connection_timeout_ms;\n  bool tls_read_ready;\n  struct MHD_Rq rq;\n  struct MHD_RP rp;\n};\n\n/* Utility probe logging function (kept from original). */\nstatic void probe_log_fdset(const char *site, int fd, const void *maxsock_ptr, int fd_setsize, int ret)\n{\n  FILE *f = fopen(\"/tmp/logs/125.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf(f, \"%s: fd=%d maxsock_ptr=%p fd_setsize=%d ret=%d\\n\",\n          site, fd, maxsock_ptr, fd_setsize, ret);\n  fclose(f);\n}\n\n/* The main function ported to the minimal environment above. */\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = (struct MHD_Connection *) data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  const bool use_poll = false; /* Polling disabled in this minimal build. */\n  bool was_suspended = false;\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n    /* No upgrade support in this minimal build. */\n\n    if ( (con->suspended) && (NULL == con->urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        {\n          /* Probe: log before calling MHD_add_to_fd_set_ */\n          int fd_arg = MHD_itc_r_fd_ (daemon->itc);\n          probe_log_fdset(\"suspended_add_before\", fd_arg, NULL, FD_SETSIZE, -1);\n          bool add_ok = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                            &rs,\n                                            NULL,\n                                            FD_SETSIZE);\n          probe_log_fdset(\"suspended_add_after\", fd_arg, NULL, FD_SETSIZE, add_ok ? 1 : 0);\n          if (! add_ok)\n          {\n            goto exit;\n          }\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n\n          break;\n        }\n      }\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info) );\n\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n        tv.tv_sec = (time_t)(mseconds_left / 1000);\n        tv.tv_usec = (suseconds_t)((mseconds_left % 1000) * 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        {\n          int fd_arg = con->socket_fd;\n          probe_log_fdset(\"switch_add_read_before\", fd_arg, &maxsock, FD_SETSIZE, -1);\n          bool add_ok = MHD_add_to_fd_set_ (con->socket_fd,\n                                            &rs,\n                                            &maxsock,\n                                            FD_SETSIZE);\n          probe_log_fdset(\"switch_add_read_after\", fd_arg, &maxsock, FD_SETSIZE, add_ok ? 1 : 0);\n          if (! add_ok)\n            err_state = true;\n        }\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        {\n          int fd_arg = con->socket_fd;\n          probe_log_fdset(\"switch_add_write_before\", fd_arg, &maxsock, FD_SETSIZE, -1);\n          bool add_ok = MHD_add_to_fd_set_ (con->socket_fd,\n                                            &ws,\n                                            &maxsock,\n                                            FD_SETSIZE);\n          probe_log_fdset(\"switch_add_write_after\", fd_arg, &maxsock, FD_SETSIZE, add_ok ? 1 : 0);\n          if (! add_ok)\n            err_state = true;\n        }\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        {\n          int fd_arg = con->socket_fd;\n          probe_log_fdset(\"switch_add_process_before\", fd_arg, &maxsock, FD_SETSIZE, -1);\n          bool add_ok = MHD_add_to_fd_set_ (con->socket_fd,\n                                            &es,\n                                            &maxsock,\n                                            FD_SETSIZE);\n          probe_log_fdset(\"switch_add_process_after\", fd_arg, &maxsock, FD_SETSIZE, add_ok ? 1 : 0);\n          if (! add_ok)\n            err_state = true;\n        }\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n\n      if (err_state)\n      {\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n\n        break;\n      }\n\n      if (0 == call_handlers (con,\n                         FD_ISSET (con->socket_fd, &rs),\n                         FD_ISSET (con->socket_fd, &ws),\n                         FD_ISSET (con->socket_fd, &es)) )\n        goto exit;\n    }\n\n    /* Poll branch omitted in this minimal build (use_poll == false). */\n\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished; notify application if present. */\n      if ( (NULL != daemon->notify_completed) && (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  0);\n      con->rq.client_aware = false;\n\n      /* In the minimal build we don't call thread_main_connection_upgrade. */\n\n      /* Skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n  }\n\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ? 0 : 1);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd, /* SHUT_WR */ 1);\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) && (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n    /* In the minimal build we don't log errors. */\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct as applied to thread_main_handle_connection. MISRA C:2023 Rule 17.8 forbids modifying a function parameter inside that same function. In the provided thread_main_handle_connection implementation the parameter is void *data and the function does not assign to that parameter; it only converts the pointer to a local variable (struct MHD_Connection *con = data) and calls other functions. Converting or using the object pointed to is allowed; modifying the object via the pointer is allowed, but changing the parameter variable itself would be a violation. The assignment described by agent A (fd_setsize = (int) FD_SETSIZE;) occurs inside MHD_add_to_fd_set_ (the callee), not inside thread_main_handle_connection (the caller). If MHD_add_to_fd_set_ actually assigns to its non-pointer parameter, that would be a violation in MHD_add_to_fd_set_ itself, but it does not make thread_main_handle_connection violate Rule 17.8. Therefore the report that thread_main_handle_connection violates MISRA C 2023 Rule 17.8 is incorrect."
}