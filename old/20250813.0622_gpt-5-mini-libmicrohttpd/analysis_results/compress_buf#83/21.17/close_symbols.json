{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'compress_buf': {'callees': [], 'callers': ['read_cb']}, 'read_cb': {'callees': ['compress_buf'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "CHUNK (macro)",
    "tmp buffer object/parameter (the buffer pointed to by 'tmp' and its allocated size in the caller)",
    "deflate (zlib function)",
    "Z_NO_FLUSH, Z_SYNC_FLUSH, Z_OK (zlib constants)",
    "z_stream (type) and its fields: avail_out, avail_in, next_out, next_in",
    "uInt and Bytef (zlib typedefs)",
    "src buffer object and src_size (caller-provided buffer and its valid length)",
    "read_cb (the caller)",
    "realloc and free (allocation semantics, realloc(NULL) behaviour)",
    "memcpy (from <string.h>)",
    "uint8_t, size_t, NULL",
    "enum MHD_Result, MHD_YES, MHD_NO"
  ],
  "explanation": "Explain why each symbol is required to check memcpy bounds (MISRA rule):\n\n- CHUNK (macro): The code uses CHUNK to set avail_out and compute have = CHUNK - strm->avail_out. The maximum number of bytes copied (have) is bounded by CHUNK, so the numeric value of CHUNK is required to verify memcpy does not read or write past buffer limits.\n\n- tmp buffer object/parameter: 'tmp' is used as the destination passed to deflate (next_out) and as the memcpy source. You must know how many bytes are actually allocated for 'tmp' in the caller to ensure copying 'have' bytes from tmp cannot read out-of-bounds.\n\n- deflate (zlib function): The contract of deflate (how many bytes it writes to next_out, whether it can exceed avail_out, and behavior with the chosen flush mode) is required to ensure have does not reflect more bytes in tmp than tmp actually holds.\n\n- Z_NO_FLUSH, Z_SYNC_FLUSH, Z_OK (zlib constants): These constants control deflate behavior and return codes. Understanding Z_SYNC_FLUSH semantics is necessary to reason about loop termination and whether partial/zero-length outputs can occur, which affects memcpy size calculations.\n\n- z_stream and its fields (avail_out, avail_in, next_out, next_in): The code relies on avail_out to compute have and on avail_in for src consumption. The types, ranges and update semantics of these fields determine whether computed offsets/sizes are valid and not truncated.\n\n- uInt and Bytef: These typedefs affect truncation when casting src_size to uInt and the pointer type of next_in/next_out; potential truncation or pointer typing can influence buffer-size reasoning for memcpy and source consumption.\n\n- src buffer object and src_size: The function sets next_in = src and avail_in to at most CHUNK or (uInt)src_size; you must know that src actually contains at least avail_in bytes for each iteration to ensure deflate consuming next_in cannot read out-of-bounds (indirectly affecting produced output and memcpy source content).\n\n- read_cb (caller): The caller provides the tmp buffer, src pointer/size, and the z_stream setup. Inspecting read_cb (or other callers) is necessary to know actual buffer allocations and invariants that guarantee memcpy arguments are in-bounds.\n\n- realloc and free: realloc is used to grow *dest and the code copies into the newly allocated block. Understanding realloc semantics (especially realloc(NULL) acting as malloc, and behavior when it fails) is necessary to prove the destination pointer arithmetic passed to memcpy is within allocated memory.\n\n- memcpy (from <string.h>): This is the string-handling function under the MISRA rule. To determine compliance you must analyze each of its pointer arguments and the length parameter against the actual object bounds.\n\n- uint8_t, size_t, NULL: Fundamental types/macros used in pointer arithmetic and size calculations. size_t is the type of sizes; uint8_t is used for pointer casting in the memcpy destination arithmetic; NULL is used in allocation/failure handling\u2014all needed to reason precisely about addresses and bounds.\n\n- enum MHD_Result, MHD_YES, MHD_NO: While not directly affecting bounds, these symbols determine control-flow on deflate return values; include them to fully understand early returns and whether a failing path could leave intermediate sizes or buffers in a state that could affect subsequent memcpy calls.\n\nIn short: to verify that memcpy in compress_buf cannot access beyond the bounds of its source or destination objects you must know (a) the numeric CHUNK, (b) the size of the tmp buffer passed in, (c) the zlib deflate and z_stream semantics (including constants and typedefs), and (d) how the caller (read_cb) allocates and passes tmp, src and initial dest state, together with standard allocation and memcpy semantics."
}