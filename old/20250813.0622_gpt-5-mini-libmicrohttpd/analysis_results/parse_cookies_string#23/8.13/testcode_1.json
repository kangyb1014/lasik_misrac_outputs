{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 8.13.\nHere is the comment from the agent.\n<violation scenario>\nThe function parameter 'value' is declared as 'const char *value' but is assigned to the struct member 'pos->value' which is a non-const pointer (pos->value = value). This drops the const qualifier from the pointer target (and likewise pos->header = key does the same), thereby discarding const qualification. According to MISRA C 2023 Rule 8.13 the pointer target should be const-qualified where possible \u2014 the struct members should be 'const char *' to avoid losing constness.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified parse_cookies_string code that contains useful probe functions that print useful logs to a file \"/tmp/logs/187.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of parse_cookies_string as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of parse_cookies_string:\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\nPlease provide the modified parse_cookies_string code.\n",
  "test_code": "#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n/* Probe logging helper: append actionable logs to /tmp/logs/187.txt */\nstatic void probe_log_call(const char *event,\n                           const char *name,\n                           size_t name_len,\n                           const char *value,\n                           size_t value_len,\n                           size_t i,\n                           size_t str_len,\n                           bool non_strict)\n{\n  FILE *f = fopen(\"/tmp/logs/187.txt\", \"a\");\n  if (f == NULL)\n    return;\n  fprintf(f, \"EVENT=%s i=%zu str_len=%zu non_strict=%d name_len=%zu value_len=%zu\\n\",\n          event, i, str_len, non_strict ? 1 : 0, name_len, value_len);\n  if (name != NULL && name_len > 0)\n  {\n    /* Print name (may contain non-printables); limit output to name_len) */\n    fprintf(f, \"  name=(%zu) '%.*s'\\n\", name_len, (int)name_len, name);\n  }\n  if (value != NULL)\n  {\n    fprintf(f, \"  value=(%zu) '%.*s'\\n\", value_len, (int)value_len, value);\n  }\n  fclose(f);\n}\n\nstatic void probe_log_event(const char *event, size_t i, size_t str_len, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/187.txt\", \"a\");\n  if (f == NULL)\n    return;\n  if (extra)\n    fprintf(f, \"EVENT=%s i=%zu str_len=%zu extra=%s\\n\", event, i, str_len, extra);\n  else\n    fprintf(f, \"EVENT=%s i=%zu str_len=%zu\\n\", event, i, str_len);\n  fclose(f);\n}\n\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  /* Log entry into function */\n  probe_log_event(\"parse_cookies_string_entry\", 0, str_len, NULL);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n      {\n        probe_log_event(\"malformed_allow_wsp_empty\", i, str_len, \"whitespace_or_semicolon_not_allowed\");\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n      if (i == str_len)\n      {\n        probe_log_event(\"end_after_skip\", i, str_len, NULL);\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n      }\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if ((('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n           (';' == l) || (0 == l)))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n      {\n        probe_log_event(\"malformed_wsp_around_eq\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n    {\n      probe_log_event(\"malformed_incomplete_name\", i, str_len, NULL);\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    }\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n      {\n        probe_log_event(\"malformed_wsp_around_eq2\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if (('\\'' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n          {\n            probe_log_event(\"malformed_wsp_in_quoted\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n        {\n          probe_log_event(\"malformed_no_closing_quote\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        }\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n          {\n            probe_log_event(\"malformed_trailing_whitespace\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n      {\n        probe_log_event(\"malformed_garbage_at_end\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n      }\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n\n      /* Probe log before calling MHD_set_connection_value_n_nocheck_ for non-empty value */\n      probe_log_call(\"set_connection_value_non_empty\",\n                     str + name_start,\n                     name_len,\n                     str + value_start,\n                     value_len,\n                     i,\n                     str_len,\n                     non_strict);\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n      {\n        probe_log_event(\"set_connection_value_no_memory\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n    else\n    {\n      /* Probe log before calling MHD_set_connection_value_n_nocheck_ for empty value */\n      probe_log_call(\"set_connection_value_empty\",\n                     str + name_start,\n                     name_len,\n                     \"\",\n                     0,\n                     i,\n                     str_len,\n                     non_strict);\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n      {\n        probe_log_event(\"set_connection_value_no_memory_empty\", i, str_len, NULL);\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n      }\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n        {\n          probe_log_event(\"malformed_no_next_cookie_after_semicolon\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n        {\n          probe_log_event(\"malformed_no_space_after_semicolon\", i, str_len, NULL);\n          return MHD_PARSE_COOKIE_MALFORMED;\n        }\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n          {\n            probe_log_event(\"malformed_trailing_space_after_semicolon\", i, str_len, NULL);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n      }\n    }\n  }\n\n  probe_log_event(\"parse_cookies_string_exit\", i, str_len, NULL);\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n"
}