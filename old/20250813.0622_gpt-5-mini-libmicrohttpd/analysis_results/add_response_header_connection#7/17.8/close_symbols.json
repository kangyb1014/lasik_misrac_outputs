{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_response_header_connection': {'callees': ['MHD_get_response_element_n_'], 'callers': ['MHD_add_response_header']}, 'MHD_get_response_element_n_': {'callees': [], 'callers': ['add_response_header_connection', 'del_response_header_connection', 'MHD_add_response_header', 'MHD_del_response_header']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_get_response_element_n_",
    "MHD_str_remove_token_caseless_",
    "MHD_str_remove_tokens_caseless_",
    "_MHD_insert_header_first",
    "MHD_calloc_",
    "malloc",
    "free",
    "memcpy",
    "memmove",
    "strlen",
    "strchr",
    "memcmp",
    "mhd_assert",
    "MHD_STATICSTR_LEN_",
    "struct MHD_Response",
    "struct MHD_HTTP_Res_Header",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_HEADER_KIND",
    "SSIZE_MAX",
    "MHD_YES",
    "MHD_NO",
    "UPGRADE_SUPPORT",
    "response->upgrade_handler"
  ],
  "explanation": "For verifying whether this function modifies its parameter variables (violating MISRA: a function parameter shall not be modified) you must be able to rule out any assignments to the parameter identifiers (response, value) and any macro expansions or callees that could expand/compile into code that assigns to those parameter variables. The listed symbols are relevant for that analysis: \n\n- MHD_get_response_element_n_: called with 'response'; must inspect its declaration/definition to ensure it is a normal function (cannot reassign the caller's local parameter variable) and to see any macros/wrappers that might expand into code touching the 'response' identifier. Also it returns hdr used later. \n- MHD_str_remove_token_caseless_: called with 'value'; check its prototype/macros to ensure it does not contain any macro expansion that assigns to the local parameter identifier (value) or performs casts that would modify the pointer variable. \n- MHD_str_remove_tokens_caseless_: similar reason as above for the other string helper called with buf pointers. \n- _MHD_insert_header_first: called with 'response'; inspect definition/macros to ensure no macro rebinds/assigns the 'response' parameter identifier. \n- MHD_calloc_, malloc, free, memcpy, memmove: memory functions used; check for macro wrappers that might expand into code that assigns to local parameter identifiers, and to understand ownership (they never reassign the parameter variable, but wrappers could). Also necessary to track whether pointers returned/assigned into hdr/new_hdr/value are used to overwrite the parameter variable. \n- strlen, strchr, memcmp: standard functions called with 'value' or used in assertions; inspect any project-specific redefinitions/macros that could rewrite into assignments. \n- mhd_assert: likely a macro; must inspect its expansion to ensure it does not assign to parameters (assert macros sometimes evaluate expressions or expand into statements). \n- MHD_STATICSTR_LEN_: macro used extensively; inspect expansion to ensure it does not reassign parameter identifiers when used with arguments that might be parameter tokens. \n- struct MHD_Response: the type definition is needed to know whether 'response' is actually a macro, or whether any of its members (e.g. flags_auto, upgrade_handler) are implemented as bitfield macros that could hide assignments to 'response' itself; also to confirm that modifications like response->flags_auto = ... modify the pointee (allowed) and not the parameter variable. \n- struct MHD_HTTP_Res_Header: the header type is assigned into and used; inspect for any macros or inline functions that might alias 'hdr' and 'response' identifiers. \n- MHD_HTTP_HEADER_CONNECTION, MHD_RAF_HAS_CONNECTION_HDR, MHD_RAF_HAS_CONNECTION_CLOSE, MHD_HEADER_KIND: constants/flags used to set members of the response; needed to verify those uses are member assignments (permitted) and to exclude any macro shenanigans that could reassign the parameter variable. \n- SSIZE_MAX: used in bounds checks; included to verify no macro redefinition causes unexpected code altering parameters. \n- MHD_YES, MHD_NO: return values/macros \u2014 inspect if they are plain enum values or macros that could expand into code with side effects. \n- UPGRADE_SUPPORT: conditional compilation symbol \u2014 needed to see if code compiled in your build could expand differently (e.g. extra code that might assign the parameter identifier). \n- response->upgrade_handler: the presence and type of this field matters because the code conditionally reads it; inspect its type (macro? function pointer?) to ensure no hidden macro expansion assigns to the parameter variable.\n\nIn short: to conclude whether the function modifies the parameter identifiers themselves you must inspect all called functions and macros and the relevant type/flag definitions listed above to ensure none of them expand or are defined in a way that assigns to the local parameters (response or value). The above symbols cover the callees, macros and type/constant definitions that appear in the function and therefore must be checked for such side-effects."
}