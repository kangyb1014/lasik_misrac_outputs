{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_response_header_connection': {'callees': ['MHD_get_response_element_n_'], 'callers': ['MHD_add_response_header']}, 'MHD_get_response_element_n_': {'callees': [], 'callers': ['add_response_header_connection', 'del_response_header_connection', 'MHD_add_response_header', 'MHD_del_response_header']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "struct MHD_HTTP_Res_Header",
    "MHD_get_response_element_n_(struct MHD_Response *, int kind, const char *key, size_t key_len)",
    "MHD_str_remove_token_caseless_(const char *src, size_t src_len, const char *token, size_t token_len, char *dst, ssize_t *dst_len)",
    "MHD_str_remove_tokens_caseless_(char *buf, size_t *buf_len, const char *token, size_t token_len)",
    "MHD_STATICSTR_LEN_(x) macro",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_HEADER_KIND",
    "MHD_calloc_(size_t nmemb, size_t size)",
    "_MHD_insert_header_first(struct MHD_Response *, struct MHD_HTTP_Res_Header *)",
    "SSIZE_MAX"
  ],
  "explanation": "Explain why each symbol is required for analyzing potential out-of-bounds uses of string.h functions in add_response_header_connection:\n\n- struct MHD_Response\n  - Needed to know the layout and types of members accessed in the function (flags_auto, upgrade_handler and any header list pointer used by MHD_get_response_element_n_). The analysis must confirm how flags_auto relates to presence/size of headers and whether upgrade_handler affects early returns. This determines when hdr is non-NULL and whether accesses to hdr->value are valid.\n\n- struct MHD_HTTP_Res_Header\n  - Must know exact fields (value pointer, value_size, header pointer, header_size, kind) and semantics: whether value points to a NUL-terminated buffer or only length-counted data, and whether value_size is the allocated size or stored content length. memcpy/memmove/memcmp/strlen uses hinge on these semantics (e.g., memcmp(hdr->value,\"close\",5) requires hdr->value to have at least 5 accessible bytes).\n\n- MHD_get_response_element_n_(...)\n  - Prototype and behavior are required to reason about the returned hdr pointer (ownership, lifetime) and correctness of hdr->value/value_size when flags indicate a header exists. We need to know whether it can return a header with smaller value_size than asserted/assumed by code, and whether it ever returns non-NULL hdr whose value pointer or value_size could be inconsistent (which would create OOB reads in memcmp/memcpy).\n\n- MHD_str_remove_token_caseless_(...)\n  - This function writes into the provided dst (buf + old_value_len) and returns/updates the output length via ssize_t pointer. To prove memcpy/memmove/memcmp calls safe we must know its contract: maximum bytes it can write, whether it NUL-terminates, and whether it can write more than the passed-in capacity (norm_len). Without its precise semantics we cannot guarantee buf has enough space and subsequent memmove/memcpy/memcmp/pos arithmetic are safe.\n\n- MHD_str_remove_tokens_caseless_(...)\n  - Called to remove tokens (e.g. \"keep-alive\") in-place. Need its contract: it modifies the buffer and updates the length; must confirm it never writes beyond the provided buffer length and how it adjusts buf contents/length, because later code relies on norm_len and buffer contents for memmove/memcpy and final NUL termination.\n\n- MHD_STATICSTR_LEN_(x) macro\n  - The code uses this to compute lengths for memcpy/memmove/assumptions (e.g., MHD_STATICSTR_LEN_(\"close\"), MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_CONNECTION), MHD_STATICSTR_LEN_(\"close, \")). Need the exact definition (does it return length excluding NUL? including?) to validate that the sizes passed to memcpy/memmove and the allocated header buffer (key_len + 1) are correct and do not cause overruns.\n\n- MHD_HTTP_HEADER_CONNECTION\n  - The actual string value used for key (and used with MHD_STATICSTR_LEN_) determines key_len. The code mallocs key_len+1 and memcpy(key, key, key_len+1) \u2014 we must confirm the expected length vs. null-termination interactions so that memcpy does not read beyond the constant and allocated area.\n\n- MHD_RAF_HAS_CONNECTION_HDR and MHD_RAF_HAS_CONNECTION_CLOSE\n  - The bitmask semantics are used to decide whether hdr is present and whether the existing header contains the \"close\" token. To ensure memcmp(hdr->value, \"close\", 5) is safe when flags indicate close present we must know the invariant that the flags imply a sufficiently long hdr->value. Without knowing that invariant the memcmp could be an OOB read.\n\n- MHD_HEADER_KIND\n  - The kind passed to MHD_get_response_element_n_ must match how headers are stored/searched. Understanding this ensures the returned hdr (if any) corresponds to a normal header entry with the expected fields and lengths, not some other internal object layout.\n\n- MHD_calloc_(size_t, size_t)\n  - The wrapper used to allocate the new header struct; we need its behavior/signature to reason about allocation success/failure branches and to ensure that when new_hdr->header and new_hdr->value are assigned, sizes are consistent and code paths free memory correctly (influence on later frees and double-free or use-after-free concerns indirectly relevant to buffer ownership).\n\n- _MHD_insert_header_first(struct MHD_Response *, struct MHD_HTTP_Res_Header *)\n  - Needed to ensure that after insertion the response/list invariants (value pointers, flags) are preserved. Also to confirm whether this function may modify header/value pointers or sizes, which would affect safety of pointers returned previously or later accesses.\n\n- SSIZE_MAX\n  - Used to bound value_len and norm_len before casting to ssize_t. The numeric value and intended range affect whether the code's checks legitimately prevent negative or truncated lengths and thus prevent later signed/unsigned conversion issues that could cause buffer overruns when sizes are used with memcpy/memmove.\n\nNote: Standard C library functions used in the target (strlen, strchr, memcmp, memcpy, memmove, malloc, free) are already known, but the above internal symbols/macros/structs are required to prove that the arguments passed to those string.h functions are within the bounds of the referenced objects and that the code maintains the necessary invariants (buffer capacities and lengths) before the calls."
}