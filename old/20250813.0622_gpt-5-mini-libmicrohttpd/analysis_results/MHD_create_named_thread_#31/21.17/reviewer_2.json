{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:MHD_create_named_thread_ only checks that thread_name != NULL and stores it in param->name. The fragment calls MHD_set_cur_thread_name_(param->name) but does not validate the string length or NUL-termination. If MHD_set_cur_thread_name_ internally uses one of the <string.h> functions (e.g. strcpy/strncpy/strlen/memcpy) to copy or measure the name into a fixed-size buffer (typical thread-name limits exist, e.g. 16 bytes on Linux) without checking the source length or ensuring truncation, then a caller-supplied overly long or non-NUL-terminated string will cause those functions to read or write beyond the bounds of their source or destination objects. That would violate MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *where, const void *handle_id_ptr,\n               const void *thread_name_ptr, size_t stack_size, int res)\n{\n  FILE *f = fopen(\"/tmp/logs/255.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s: handle=%p thread_name=%p stack_size=%zu res=%d\\n\",\n           where, handle_id_ptr, thread_name_ptr, stack_size, res);\n  fflush (f);\n  fclose (f);\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  /* Log entry state (do not dereference thread_name). */\n  mhd_log_probe (\"entry(MHD_USE_THREAD_ATTR_SETNAME)\", handle_id,\n                 (const void *) thread_name, stack_size, 0);\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    /* Log result of setname attempt. We still avoid reading thread_name.\n     * This records that we attempted to pass the caller-supplied pointer to\n     * pthread_attr_setname_np which may internally copy/inspect it. */\n    mhd_log_probe (\"after_setname\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n\n    /* Log result of create. */\n    mhd_log_probe (\"after_create\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n\n    /* Log failure and errno. */\n    mhd_log_probe (\"error_set_invalid\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  /* Log entry for the non-attr branch. */\n  mhd_log_probe (\"entry(!MHD_USE_THREAD_ATTR_SETNAME)\", handle_id,\n                 (const void *) thread_name, stack_size, 0);\n\n  if (NULL == thread_name)\n  {\n    /* Log the immediate error condition (NULL thread_name). */\n    mhd_log_probe (\"null_name\", handle_id, NULL, stack_size, EINVAL);\n\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Log param allocation and the pointer stored (do not read the contents). */\n  mhd_log_probe (\"param_allocated\", handle_id, (const void *) param->name,\n                 stack_size, 0);\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n\n    /* Log failure to create thread; record errno and the param pointer. */\n    mhd_log_probe (\"create_thread_failed\", handle_id,\n                   (const void *) param->name, stack_size, err_num);\n\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  /* Log success: thread creation started and param handed off. */\n  mhd_log_probe (\"create_thread_ok\", handle_id, (const void *) param->name,\n                 stack_size, 0);\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b52e3f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nparam_allocated: handle=0x55697b52e3f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b52e3f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b52eb98 thread_name=0x7fb4aac963eb stack_size=0 res=0\nparam_allocated: handle=0x55697b52eb98 thread_name=0x7fb4aac963eb stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b52eb98 thread_name=0x7fb4aac963eb stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b52f498 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b52f498 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b52f498 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b52f740 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b52f740 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b52f740 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b52ff78 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nparam_allocated: handle=0x55697b52ff78 thread_name=0x7fb4aac963f6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b52ff78 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b5303b8 thread_name=0x7fb4aac963eb stack_size=0 res=0\nparam_allocated: handle=0x55697b5303b8 thread_name=0x7fb4aac963eb stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b5303b8 thread_name=0x7fb4aac963eb stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b5307f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nparam_allocated: handle=0x55697b5307f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b5307f8 thread_name=0x7fb4aac963f6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b530c38 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nparam_allocated: handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55697b530ee0 thread_name=0x7fb4aac964c6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55fed21c93f8 thread_name=0x7f86d682d3f6 stack_size=0 res=0\nparam_allocated: handle=0x55fed21c93f8 thread_name=0x7f86d682d3f6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55fed21c93f8 thread_name=0x7f86d682d3f6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55fed21ca498 thread_name=0x7f86d682d3f6 stack_size=0 res=0\nparam_allocated: handle=0x55fed21ca498 thread_name=0x7f86d682d3f6 stack_size=0 res=0\ncreate_thread_ok: handle=0x55fed21ca498 thread_name=0x7f86d682d3f6 stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x55fed21ca918 thread_name=0x7f86d682d3eb stack_size=0 res=0\nparam_allocated: handle=0x55fed21ca918 thread_name=0x7f86d682d3eb stack_size=0 res=0\ncreate_thread_ok: handle=0x55fed21ca918 thread_name=0x7f86d682d3eb stack_size=0 res=0\nentry(!MHD_USE_THREAD_ATTR_SETNAME): handle=0x557de4180eb8 thread_name=0x7f592ac1d3eb stack_size=0 res=0\nparam_allocated: handle=0x557de4180eb8 thread_name=0x7f592ac1d3eb stack_size=0 res=0\ncreate_thread_ok: handle=0x557de4180eb8 th\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not correct for the code shown. MISRA C 2023 Rule 21.17 applies to uses of the string.h functions that could cause out\u2011of\u2011bounds accesses. The MHD_create_named_thread_ implementation presented does not call any string.h functions itself \u2014 it only checks for NULL, stores the const char * pointer in param->name, and passes the pointer to other APIs (pthread_attr_setname_np or the thread starter). Any out\u2011of\u2011bounds access from strcpy/strncpy/strlen/memcpy/etc. would occur in the code that actually performs those string operations (e.g. MHD_set_cur_thread_name_ or the pthread implementation), not in this function. The provided test logs further show that this function only records and forwards the pointer values (no dereference or string handling is performed here). Therefore, while an unsafe implementation of a later function that copies the name could violate Rule 21.17, the reported violation cannot be attributed to MHD_create_named_thread_ itself \u2014 the report is not correct for this function."
}