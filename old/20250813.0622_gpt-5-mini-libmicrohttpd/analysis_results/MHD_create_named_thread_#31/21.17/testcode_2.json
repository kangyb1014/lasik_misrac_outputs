{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nMHD_create_named_thread_ only checks that thread_name != NULL and stores it in param->name. The fragment calls MHD_set_cur_thread_name_(param->name) but does not validate the string length or NUL-termination. If MHD_set_cur_thread_name_ internally uses one of the <string.h> functions (e.g. strcpy/strncpy/strlen/memcpy) to copy or measure the name into a fixed-size buffer (typical thread-name limits exist, e.g. 16 bytes on Linux) without checking the source length or ensuring truncation, then a caller-supplied overly long or non-NUL-terminated string will cause those functions to read or write beyond the bounds of their source or destination objects. That would violate MISRA C 2023 Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified MHD_create_named_thread_ code that contains useful probe functions that print useful logs to a file \"/tmp/logs/255.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of MHD_create_named_thread_ as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of MHD_create_named_thread_:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\nPlease provide the modified MHD_create_named_thread_ code.\n",
  "test_code": "#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/* Probe logger: write concise records about the call and key state to a file\n * so other agents can reproduce and gather evidence. This logger intentionally\n * avoids reading the contents of any caller-supplied string pointer to avoid\n * introducing additional out-of-bounds accesses. */\nstatic void\nmhd_log_probe (const char *where, const void *handle_id_ptr,\n               const void *thread_name_ptr, size_t stack_size, int res)\n{\n  FILE *f = fopen(\"/tmp/logs/255.txt\", \"a\");\n  if (NULL == f)\n    return;\n  fprintf (f, \"%s: handle=%p thread_name=%p stack_size=%zu res=%d\\n\",\n           where, handle_id_ptr, thread_name_ptr, stack_size, res);\n  fflush (f);\n  fclose (f);\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  /* Log entry state (do not dereference thread_name). */\n  mhd_log_probe (\"entry(MHD_USE_THREAD_ATTR_SETNAME)\", handle_id,\n                 (const void *) thread_name, stack_size, 0);\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    /* Log result of setname attempt. We still avoid reading thread_name.\n     * This records that we attempted to pass the caller-supplied pointer to\n     * pthread_attr_setname_np which may internally copy/inspect it. */\n    mhd_log_probe (\"after_setname\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n\n    /* Log result of create. */\n    mhd_log_probe (\"after_create\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n\n    /* Log failure and errno. */\n    mhd_log_probe (\"error_set_invalid\", handle_id, (const void *) thread_name,\n                   stack_size, res);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  /* Log entry for the non-attr branch. */\n  mhd_log_probe (\"entry(!MHD_USE_THREAD_ATTR_SETNAME)\", handle_id,\n                 (const void *) thread_name, stack_size, 0);\n\n  if (NULL == thread_name)\n  {\n    /* Log the immediate error condition (NULL thread_name). */\n    mhd_log_probe (\"null_name\", handle_id, NULL, stack_size, EINVAL);\n\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Log param allocation and the pointer stored (do not read the contents). */\n  mhd_log_probe (\"param_allocated\", handle_id, (const void *) param->name,\n                 stack_size, 0);\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n\n    /* Log failure to create thread; record errno and the param pointer. */\n    mhd_log_probe (\"create_thread_failed\", handle_id,\n                   (const void *) param->name, stack_size, err_num);\n\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  /* Log success: thread creation started and param handed off. */\n  mhd_log_probe (\"create_thread_ok\", handle_id, (const void *) param->name,\n                 stack_size, 0);\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n"
}