{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The void* parameter 'data' is cast to 'struct MHD_named_helper_param_ *' even though the function only reads the structure members (param->name, param->arg, param->start_routine) and does not modify them. The pointer therefore could and should be to a const-qualified type (e.g. 'const struct MHD_named_helper_param_ *') to satisfy MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nMHD_log_named_param (const struct MHD_named_helper_param_ *p,\n                     const char *stage)\n{\n  FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  fprintf (f, \"[MHD_log_named_param] stage=%s param=%p\\n\",\n           (stage != NULL) ? stage : \"(null)\", (const void *) p);\n  if (p != NULL)\n  {\n    fprintf (f, \"  name pointer=%p, arg pointer=%p, start_routine pointer=%p\\n\",\n             (const void *) p->name,\n             (const void *) p->arg,\n             (const void *) p->start_routine);\n    if (p->name != NULL)\n      fprintf (f, \"  name string=\\\"%s\\\"\\n\", p->name);\n  }\n  fclose (f);\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    /* Log invalid thread_name early */\n    FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"[MHD_create_named_thread_] thread_name is NULL -> EINVAL\\n\");\n      fclose (f);\n    }\n\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n  {\n    FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"[MHD_create_named_thread_] malloc failed for param (size=%zu)\\n\", sizeof (struct MHD_named_helper_param_));\n      fclose (f);\n    }\n    return 0;\n  }\n\n  /* Populate the helper parameter structure as before. */\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Log the initialized parameter contents. Use a const-qualified\n   * logging function to demonstrate that the structure is only read.\n   */\n  MHD_log_named_param (param, \"after_init\");\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  {\n    /* Log that we are about to create the thread and pass (void *) param. */\n    FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"[MHD_create_named_thread_] calling MHD_create_thread_ with param=%p (as void*)\\n\", (void *) param);\n      fclose (f);\n    }\n  }\n\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    /* Log the failure before freeing param to capture state. */\n    FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"[MHD_create_named_thread_] MHD_create_thread_ failed, errno=%d\\n\", errno);\n      /* Also log param contents again to show what was passed. */\n      if (param != NULL)\n      {\n        fprintf (f, \"[MHD_create_named_thread_] freeing param=%p after failure\\n\", (void *) param);\n      }\n      fclose (f);\n    }\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  /* Successful creation: record that we passed the param to the new thread. */\n  {\n    FILE *f = fopen(\"/tmp/logs/251.txt\", \"a\");\n    if (NULL != f)\n    {\n      fprintf (f, \"[MHD_create_named_thread_] thread creation succeeded, param=%p handed to thread starter\\n\", (void *) param);\n      fclose (f);\n    }\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da163f6, arg pointer=0x55e85d6f12a0, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-single\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da163eb, arg pointer=0x55e85d6f1a40, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-listen\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f2340, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f28a0\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f25e8, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f28a0 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f28a0 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da163f6, arg pointer=0x55e85d6f2e20, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-single\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f28a0\n  name pointer=0x7f7f7da163eb, arg pointer=0x55e85d6f3260, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-listen\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f28a0 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f28a0 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f3b20, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f2880\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f3dc8, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f2880 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f2880 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da163f6, arg pointer=0x55e85d6f36a0, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-single\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f1720\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f3ae0, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f1720 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f1720 handed to thread starter\n[MHD_log_named_param] stage=after_init param=0x55e85d6f2880\n  name pointer=0x7f7f7da164c6, arg pointer=0x55e85d6f3d88, start_routine pointer=0x7f7f7d9ca955\n  name string=\"MHD-worker\"\n[MHD_create_named_thread_] calling MHD_create_thread_ with param=0x55e85d6f2880 (as void*)\n[MHD_create_named_thread_] thread creation succeeded, param=0x55e85d6f2880 handed \n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is not correct. MISRA C 2023 Rule 8.13 advises that pointers should point to const-qualified types when possible, but that advice must be applied in context. In this code the helper parameter is allocated and passed to pthread_create via a void * (the pthread start-routine API requires the prototype void *(*)(void *)). You cannot change the pthread start-routine signature to take a const void *; and if the thread starter ever needs to free or otherwise modify or hand off the allocated structure, a const qualification would be inappropriate (and would require qualification casts when calling APIs like free which take void *). The provided runtime logs also show the same allocation addresses being reused and differing contents over time, which indicates the parameter objects are not immutable and/or are handed between threads (so const would be misleading). Finally, even if the start-routine only read fields, the correct remediation would be to use a local const-qualified pointer inside the start-routine (e.g. const struct MHD_named_helper_param_ *p = data;) \u2014 not to change the external API or the fact the object is allocated and passed as void *. Given the POSIX API constraints and the observed behaviour in the logs, the report that the code violates MISRA Rule 8.13 is not correct."
}