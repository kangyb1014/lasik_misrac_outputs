{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The statement 'length -= MD5_BLOCK_SIZE;' directly modifies the function parameter 'length'. MISRA C 2023 Rule 17.8 prohibits modifying function parameters; the code should use a local copy (e.g., size_t len = length;) and modify that instead.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_md5(const char *label,\n                        const struct Md5Ctx *ctx,\n                        const uint8_t *data,\n                        size_t length,\n                        unsigned int bytes_have)\n{\n  FILE *f = fopen(\"/tmp/logs/661.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  fprintf(f, \"%s: length=%zu, bytes_have=%u, ctx->count=%llu, ctx->buffer=%p, data=%p\",\n          label,\n          length,\n          bytes_have,\n          (unsigned long long) ctx->count,\n          (void *) ctx->buffer,\n          (void *) data);\n  if (length > 0 && data != NULL)\n  {\n    /* Print first up to 8 bytes for context. */\n    unsigned int i, show = (length > 8u) ? 8u : (unsigned int) length;\n    fprintf(f, \", first_bytes=0x\");\n    for (i = 0; i < show; ++i)\n      fprintf(f, \"%02x\", (unsigned int) data[i]);\n  }\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n  mhd_log_md5(\"ENTRY\", ctx, data, length, 0);\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    mhd_log_md5(\"EARLY_RETURN_ZERO_LENGTH\", ctx, data, length, 0);\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  mhd_log_md5(\"AFTER_COUNT_UPDATE\", ctx, data, length, bytes_have);\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      mhd_log_md5(\"BEFORE_COMBINE_WITH_BUFFER\", ctx, data, length, bytes_have);\n\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n\n      data += bytes_left;            /* NOTE: modifies function parameter 'data' */\n      length -= bytes_left;          /* NOTE: modifies function parameter 'length' */\n\n      mhd_log_md5(\"AFTER_COMBINE_ADJUST_LENGTH\", ctx, data, length, bytes_have);\n\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n\n      mhd_log_md5(\"AFTER_COMBINE_TRANSFORM\", ctx, data, length, bytes_have);\n    }\n  }\n\n  mhd_log_md5(\"BEFORE_WHILE_LOOP\", ctx, data, length, bytes_have);\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    mhd_log_md5(\"WHILE_ITER_START\", ctx, data, length, bytes_have);\n\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;         /* NOTE: modifies function parameter 'data' */\n    length -= MD5_BLOCK_SIZE;       /* NOTE: modifies function parameter 'length' */\n\n    mhd_log_md5(\"WHILE_ITER_END\", ctx, data, length, bytes_have);\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    mhd_log_md5(\"BEFORE_COPY_REMAINDER\", ctx, data, length, bytes_have);\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n    mhd_log_md5(\"AFTER_COPY_REMAINDER\", ctx, data, length, bytes_have);\n  }\n\n  mhd_log_md5(\"EXIT\", ctx, data, length, bytes_have);\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: length=28, bytes_have=0, ctx->count=0, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nAFTER_COUNT_UPDATE: length=28, bytes_have=0, ctx->count=28, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nBEFORE_WHILE_LOOP: length=28, bytes_have=0, ctx->count=28, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nBEFORE_COPY_REMAINDER: length=28, bytes_have=0, ctx->count=28, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nAFTER_COPY_REMAINDER: length=28, bytes_have=0, ctx->count=28, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nEXIT: length=28, bytes_have=0, ctx->count=28, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e020, first_bytes=0x3132333435363738\nENTRY: length=14, bytes_have=0, ctx->count=0, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nAFTER_COUNT_UPDATE: length=14, bytes_have=0, ctx->count=14, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nBEFORE_WHILE_LOOP: length=14, bytes_have=0, ctx->count=14, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nBEFORE_COPY_REMAINDER: length=14, bytes_have=0, ctx->count=14, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nAFTER_COPY_REMAINDER: length=14, bytes_have=0, ctx->count=14, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nEXIT: length=14, bytes_have=0, ctx->count=14, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e03d, first_bytes=0x53696d706c652073\nENTRY: length=26, bytes_have=0, ctx->count=0, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nAFTER_COUNT_UPDATE: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nBEFORE_WHILE_LOOP: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nBEFORE_COPY_REMAINDER: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nAFTER_COPY_REMAINDER: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nEXIT: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e04c, first_bytes=0x6162636465666768\nENTRY: length=26, bytes_have=0, ctx->count=0, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nAFTER_COUNT_UPDATE: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nBEFORE_WHILE_LOOP: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nBEFORE_COPY_REMAINDER: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nAFTER_COPY_REMAINDER: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nEXIT: length=26, bytes_have=0, ctx->count=26, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e067, first_bytes=0x7a79787776757473\nENTRY: length=104, bytes_have=0, ctx->count=0, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e088, first_bytes=0x6162636465666768\nAFTER_COUNT_UPDATE: length=104, bytes_have=0, ctx->count=104, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e088, first_bytes=0x6162636465666768\nBEFORE_WHILE_LOOP: length=104, bytes_have=0, ctx->count=104, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e088, first_bytes=0x6162636465666768\nWHILE_ITER_START: length=104, bytes_have=0, ctx->count=104, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e088, first_bytes=0x6162636465666768\nWHILE_ITER_END: length=40, bytes_have=0, ctx->count=104, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e0c8, first_bytes=0x6d6e6f7071727374\nBEFORE_COPY_REMAINDER: length=40, bytes_have=0, ctx->count=104, ctx->buffer=0x7fffc5dccb30, data=0x562f7d82e0c8, first_bytes=0x6d6e6f7071727374\nA\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The function directly assigns to the parameter variables: data is incremented (data += ...) and length is decremented (length -= ...). MISRA C 2023 Rule 17.8 forbids modifying function parameters (the pointer itself shall not be modified and non\u2011pointer parameters shall not be modified). The test log demonstrates this: in the 104\u2011byte case the printed length changes from 104 to 40 and the data pointer advances (data addresses and first_bytes change), proving the code mutates the parameters. Modifying ctx->count (the object pointed to by ctx) is allowed, but modifying the parameter variables data and length violates Rule 17.8. A compliant fix is to make local copies (e.g. const uint8_t *p = data; size_t len = length;) and modify those instead."
}