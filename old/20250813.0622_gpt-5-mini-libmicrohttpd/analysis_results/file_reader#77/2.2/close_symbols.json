{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) (uintptr_t) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t) (pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64 (response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread (response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t) INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n  {\n    OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0};   /* Initialize to zero. */\n    ULARGE_INTEGER pos_uli;\n    DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n    DWORD resRead;\n\n    pos_uli.QuadPart = (uint64_t) offset64;   /* Simple transformation 64bit -> 2x32bit. */\n    f_ol.Offset = pos_uli.LowPart;\n    f_ol.OffsetHigh = pos_uli.HighPart;\n    if (! ReadFile (fh, (void *) buf, toRead, &resRead, &f_ol))\n      return MHD_CONTENT_READER_END_WITH_ERROR;   /* Read error. */\n    if (0 == resRead)\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    return (ssize_t) resRead;\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "MHD_Response.fd",
    "MHD_Response.fd_off",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "_WIN32",
    "__CYGWIN__",
    "HAVE_PREAD64",
    "HAVE_PREAD",
    "HAVE_LSEEK64",
    "pread64",
    "pread",
    "read",
    "lseek64",
    "lseek",
    "SSIZE_MAX",
    "ssize_t",
    "size_t",
    "off_t",
    "int64_t",
    "uint64_t",
    "INT32_MAX",
    "SEEK_SET",
    "HANDLE",
    "INVALID_HANDLE_VALUE",
    "_get_osfhandle",
    "ReadFile",
    "OVERLAPPED",
    "ULARGE_INTEGER",
    "DWORD",
    "uintptr_t"
  ],
  "explanation": "To decide whether any statements or blocks in file_reader are dead code under the MISRA rule (removal would not affect program behaviour) the analyser needs both compile-time and runtime symbols and semantic definitions referenced by the function:\n\n- struct MHD_Response, MHD_Response.fd, MHD_Response.fd_off: definition and types of the response object and the exact types/valid ranges of fd and fd_off are required to judge whether branches that inspect or use them can ever be taken or are redundant.\n\n- MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM: the actual values (and whether they collide with normal return values) are needed to see if return statements are meaningful or redundant.\n\n- _WIN32, __CYGWIN__, HAVE_PREAD64, HAVE_PREAD, HAVE_LSEEK64: these compile-time macros control which blocks are compiled. Knowing which are defined is essential to know which code is actually present and therefore whether any branch is dead.\n\n- pread64, pread, read, lseek64, lseek: prototypes and documented return behaviours (return types, meanings of return values on EOF/error, and possible errno effects) are required to understand whether checks like n==0 or n<0 are reachable and meaningful.\n\n- SSIZE_MAX, ssize_t, size_t: constants and types used to clamp/return sizes; necessary to determine whether the max clamping can ever change behaviour or be optimized away.\n\n- off_t, int64_t, uint64_t, INT32_MAX, SEEK_SET: types and constants used in size and range checks and seeks; needed to evaluate compile- and run-time comparisons such as (sizeof(off_t) < sizeof(uint64_t)) and offset64 > INT32_MAX and whether those conditions are ever true on the target platform.\n\n- HANDLE, INVALID_HANDLE_VALUE, _get_osfhandle, ReadFile, OVERLAPPED, ULARGE_INTEGER, DWORD: Windows-specific types and functions used in the alternative code path. Their semantics (how _get_osfhandle maps fd to HANDLE, whether ReadFile with an OVERLAPPED structure is synchronous/asynchronous for the given handle, and how ReadFile reports bytes read/errors) are required to decide if the Windows branch can succeed, fail, or be no-op \u2014 which affects whether related checks/returns are dead.\n\n- uintptr_t: used in the cast of _get_osfhandle result; its size/behavior matters when reasoning about the translation between file descriptors and HANDLE values.\n\nIn short: compile-time feature macros determine presence/absence of entire blocks; type sizes and constants determine the truth of range tests inside blocks; function return semantics determine whether subsequent conditionals (n==0, n<0, ReadFile failures) can be executed or are redundant. All listed symbols are required to conclude whether any statement or branch in file_reader is dead code."
}