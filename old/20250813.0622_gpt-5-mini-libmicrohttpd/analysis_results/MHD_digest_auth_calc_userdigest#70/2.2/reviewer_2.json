{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro digest_deinit(da) is defined as (void)0. Calls such as digest_deinit(&da); in MHD_digest_auth_calc_userdigest expand to a no-op (a null statement) that has no side effects; removing these calls would not change program behaviour in the current build configuration. This constitutes dead code and therefore violates MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_logf (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/562.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\nstatic unsigned long mhd_checksum_da (const struct DigestAlgorithm *da)\n{\n  const unsigned char *p = (const unsigned char *) da;\n  size_t i;\n  unsigned long sum = 0UL;\n  for (i = 0U; i < sizeof (*da); ++i)\n    sum += (unsigned long) p[i];\n  return sum;\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  mhd_logf (\"MHD_digest_auth_calc_userdigest: entry algo3=%d username=%s realm=%s password_ptr=%p bin_buf_size=%zu\",\n            (int) algo3,\n            (username != NULL) ? username : \"(null)\",\n            (realm != NULL) ? realm : \"(null)\",\n            (void *) password,\n            bin_buf_size);\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: digest_init_one_time() returned false - returning MHD_NO\");\n    return MHD_NO;\n  }\n\n  /* Record a checksum of the digest algorithm state after initialization. */\n  {\n    unsigned long cs_after_init = mhd_checksum_da (&da);\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: checksum after init = %lu\", cs_after_init);\n  }\n\n  if (digest_get_size (&da) > bin_buf_size)\n  {\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: digest_get_size() > bin_buf_size (%zu) -> MHD_NO\", bin_buf_size);\n    ret = MHD_NO;\n  }\n  else\n  {\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: calling calc_userdigest()\");\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n    {\n      mhd_logf (\"MHD_digest_auth_calc_userdigest: digest_ext_error() returned true -> setting ret = MHD_NO\");\n      ret = MHD_NO;\n    }\n    else\n    {\n      mhd_logf (\"MHD_digest_auth_calc_userdigest: digest_ext_error() returned false\");\n    }\n#else\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: MHD_DIGEST_HAS_EXT_ERROR not defined\");\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n\n  /* Take a checksum snapshot immediately before and after calling digest_deinit\n     to capture whether digest_deinit actually modified the DigestAlgorithm\n     structure. If digest_deinit is defined as (void)0 (a no-op macro), the\n     checksums will be equal which demonstrates the dead-code scenario. */\n  {\n    unsigned long cs_before_deinit = mhd_checksum_da (&da);\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: checksum before digest_deinit = %lu\", cs_before_deinit);\n\n    /* Call the (possibly no-op) deinit. Keep this call to preserve original logic. */\n    digest_deinit (&da);\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: called digest_deinit(&da)\");\n\n    unsigned long cs_after_deinit = mhd_checksum_da (&da);\n    mhd_logf (\"MHD_digest_auth_calc_userdigest: checksum after digest_deinit = %lu\", cs_after_deinit);\n\n    if (cs_before_deinit == cs_after_deinit)\n      mhd_logf (\"MHD_digest_auth_calc_userdigest: NOTE - checksum unchanged by digest_deinit -> likely a no-op (dead code)\");\n    else\n      mhd_logf (\"MHD_digest_auth_calc_userdigest: checksum changed by digest_deinit -> digest_deinit performed work\");\n  }\n\n  mhd_logf (\"MHD_digest_auth_calc_userdigest: return %d\", (int) ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_calc_userdigest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's scenario is correct for the build configuration described. MISRA C 2023 Rule 2.2 says that any operation that is executed but whose removal would not affect program behaviour is dead code. If, in the current project build, digest_deinit(&da) expands to a no-op macro (for example (void)0), then the call produces no side effects and removing that statement would not change program behaviour \u2014 which meets the definition of dead code under Rule 2.2. The absence of runtime log output in the supplied test does not invalidate the reasoning; it only means the test did not exercise or record the function, but the preprocessor expansion alone demonstrates the call is a no-op in that configuration. Note: if other build configurations define digest_deinit to perform real work, then in those configurations the call is not dead; MISRA compliance must be assessed for the actual project build. Recommendation: either ensure digest_deinit provides observable behaviour in the project build, avoid emitting no-op calls (e.g. conditionally omit the call when it truly is a no-op), or document and justify the no-op to satisfy a rules deviation process."
}