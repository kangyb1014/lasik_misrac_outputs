{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userdigest code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userdigest.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strlen(realm) can read beyond the object if realm is NULL or not a NUL\u2011terminated buffer. In MHD_digest_auth_calc_userdigest there is no check that realm != NULL (nor that it is NUL\u2011terminated), so if a caller passes NULL (or a non NUL\u2011terminated pointer) strlen(realm) will dereference/read out of bounds \u2014 violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  /* Include needed headers for logging. It's valid to include headers here\n     to ensure the logging functions are declared even if this snippet is\n     pasted into a larger compilation unit. */\n  #include <stdio.h>\n\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  /* Open log early so we can record input pointer values before any\n     potential crash (e.g. strlen(realm)) occurs. Do not change control\n     flow even if logging fails. */\n  FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"ENTER: MHD_digest_auth_calc_userdigest\\n\");\n    fprintf(log, \"  algo3=%d, username=%p, realm=%p, password=%p, userdigest_bin=%p, bin_buf_size=%zu\\n\",\n            (int)algo3,\n            (const void *)username,\n            (const void *)realm,\n            (const void *)password,\n            userdigest_bin,\n            bin_buf_size);\n    /* Log explicit nullness to highlight violation scenarios where realm == NULL. */\n    fprintf(log, \"  username_is_null=%d, realm_is_null=%d, password_is_null=%d\\n\",\n            username == NULL,\n            realm == NULL,\n            password == NULL);\n    fflush(log);\n  }\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n  {\n    if (log)\n    {\n      fprintf(log, \"  digest_init_one_time: FAILED -> returning MHD_NO\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  /* Record digest algorithm size info. */\n  size_t needed = digest_get_size (&da);\n  if (log)\n  {\n    fprintf(log, \"  digest_get_size = %zu\\n\", needed);\n    fprintf(log, \"  bin_buf_size = %zu\\n\", bin_buf_size);\n    fflush(log);\n  }\n\n  if (needed > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    /* Log that the code is about to call calc_userdigest which uses strlen on\n       username and realm. We intentionally do NOT call strlen on realm here to\n       avoid adding additional reads that could hide or change the original\n       behavior; we only record that the call will occur and whether realm is\n       NULL. This preserves the original control flow and potential violation. */\n    if (log)\n    {\n      fprintf(log, \"  About to call calc_userdigest(). Note: calc_userdigest will call strlen(username) and strlen(realm).\\n\");\n      fprintf(log, \"  realm_is_null=%d\\n\", realm == NULL);\n      fflush(log);\n    }\n\n    /* Original logic preserved exactly as much as possible: the strlen calls\n       remain in place (and therefore a real run can demonstrate the out-of-bounds\n       read if realm is NULL or not NUL-terminated). */\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (log)\n    {\n      fprintf(log, \"  calc_userdigest returned, provisional ret=%d\\n\", (int)ret);\n      fflush(log);\n    }\n  }\n  digest_deinit (&da);\n\n  if (log)\n  {\n    fprintf(log, \"EXIT: MHD_digest_auth_calc_userdigest -> ret=%d\\n\", (int)ret);\n    fclose(log);\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_digest_auth_calc_userdigest. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. MISRA C 2023 Rule 21.17 covers strlen (listed in <string.h>) and requires that uses of these functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. In the shown code strlen(username) and strlen(realm) are invoked without any prior validation that those pointers are non-NULL and refer to NUL\u2011terminated character arrays. If a caller passes NULL (or a pointer to a buffer that is not NUL\u2011terminated), the call to strlen will perform out\u2011of\u2011bounds accesses / undefined behavior and therefore violates Rule 21.17 unless there is a documented and externally enforced precondition guaranteeing non\u2011NULL, NUL\u2011terminated inputs. The safe fixes are to validate the pointers (and provide lengths) or document and enforce the non\u2011NULL/NUL\u2011terminated contract at API boundaries. The empty run log does not change the static correctness issue."
}