{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_sysconf_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SYSCONF) && \\\n  (defined(HAS_DECL__SC_NPROCESSORS_ONLN) || defined(HAS_DECL__SC_NPROC_ONLN))\n  long value = -1;\n#ifdef HAS_DECL__SC_NPROCESSORS_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROCESSORS_ONLN);\n#endif /* HAS_DECL__SC_NPROCESSORS_ONLN */\n#ifdef HAS_DECL__SC_NPROC_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROC_ONLN);\n#endif /* HAS_DECL__SC_NPROC_ONLN */\n  if (0 >= value)\n    return -1;\n  ret = (int) value;\n  if ((long) ret != value)\n    return -1; /* Overflow */\n#endif /* HAVE_SYSCONF &&\n          (HAS_DECL__SC_NPROCESSORS_ONLN || HAS_DECL__SC_NPROC_ONLN) */\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_sys_cpu_count_sysconf_': {'callees': [], 'callers': ['mhd_tool_get_system_cpu_count']}, 'mhd_tool_get_system_cpu_count': {'callees': ['mhd_tool_get_sys_cpu_count_special_api_', 'mhd_tool_get_sys_cpu_count_sysctl_', 'mhd_tool_get_sys_cpu_count_sysconf_', 'mhd_tool_get_proc_cpu_count', 'mhd_tool_get_sys_cpu_count_sysctl_fallback_', 'mhd_tool_get_sys_cpu_count_sysconf_fallback_'], 'callers': ['detect_cpu_core_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_SYSCONF",
    "HAS_DECL__SC_NPROCESSORS_ONLN",
    "HAS_DECL__SC_NPROC_ONLN",
    "sysconf",
    "_SC_NPROCESSORS_ONLN",
    "_SC_NPROC_ONLN",
    "config header (e.g. config.h) where the HAVE_/HAS_DECL_ macros are defined",
    "unistd.h (or platform header that declares/defines sysconf and _SC_* macros)"
  ],
  "explanation": "To decide whether the target function uses any compiler language extensions (per the MISRA rule), the analyzer must inspect any macros or declarations that could expand to or rely on compiler-specific extensions rather than plain standard C.\n\n- HAVE_SYSCONF: This build-config macro controls whether the sysconf-based code is compiled. You must see its definition to know whether the code path is actually enabled and whether the macro itself is defined using any extension mechanisms.\n\n- HAS_DECL__SC_NPROCESSORS_ONLN and HAS_DECL__SC_NPROC_ONLN: These configure-style macros gate use of the corresponding _SC_* names. Their definitions (often from the config header) must be inspected to ensure they are plain 0/1 defines and not macros that expand to compiler-specific constructs or attributes.\n\n- sysconf: The function or macro sysconf may be declared as a normal POSIX function, but on some platforms it could be provided as a macro or inline/GNU extension. Examining its declaration in the platform headers confirms whether its use invokes any compiler extensions.\n\n- _SC_NPROCESSORS_ONLN and _SC_NPROC_ONLN: These platform macros/constants are used as arguments to sysconf. They may be defined in system headers in an implementation-specific way (macros, enum, etc.). Their definitions must be checked to ensure they do not use compiler extensions.\n\n- config header (e.g. config.h) where the HAVE_/HAS_DECL_ macros are defined: The configure-generated header can use nonstandard constructs or be influenced by compiler-specific tests. Inspecting it is necessary to confirm the macros are simple integer defines and do not hide language extensions.\n\n- unistd.h (or the platform header that declares/defines sysconf and _SC_*): The system header that provides sysconf/_SC_* must be inspected to detect any use of compiler-specific extensions (e.g., function-like macros, attributes, builtin intrinsics) that would make the target function rely on language extensions.\n\nCollecting these symbols/headers lets the next analysis determine whether any of the identifiers used by the function expand to or rely on compiler language extensions; if they are all plain standard declarations/macros, the function does not violate the MISRA 'Language extensions' rule."
}