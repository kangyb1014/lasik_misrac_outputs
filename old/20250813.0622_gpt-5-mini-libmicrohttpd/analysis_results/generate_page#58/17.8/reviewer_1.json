{
  "user_message": "An agent A claimed that the following generate_page code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of generate_page.\n```c\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In MHD_create_post_processor the value parameter 'buffer_size' is modified via 'buffer_size += 4;'. MISRA C 2023 Rule 17.8 prohibits modifying function parameters (unless working on the object referred to by a pointer), so this direct modification of the value parameter violates the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nlog_probe (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/469.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  va_list ap;\n  va_start (ap, fmt);\n  (void) vfprintf (f, fmt, ap);\n  va_end (ap);\n\n  (void) fputc('\\n', f);\n  (void) fclose (f);\n}\nstatic void\nlog_upload_context (struct UploadContext *uc, const char *prefix)\n{\n  if (NULL == uc)\n  {\n    log_probe (\"%s: UploadContext = NULL\", prefix);\n    return;\n  }\n  /* We print only pointers and fd/int-like fields that are used by\n     generate_page. This mirrors the state without changing it. */\n  /* Using casts to void* for pointer printing to avoid depending on\n     full type details here. */\n  /* Note: fields referenced below (fd, pp, response, connection) exist\n     in the original code's UploadContext. */\n  {\n    /* We can't reference fields by name here without the struct\n       definition; to keep this snippet self-contained and safe we use\n       pointer printing only. If the struct is visible to the\n       translation unit, the compiler will optimise/allow direct access\n       in the real build; otherwise this still yields useful tracing. */\n    log_probe (\"%s: UploadContext @%p\", prefix, (void *) uc);\n  }\n}\n\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  /* Log entry into generate_page with key inputs */\n  log_probe (\"generate_page: entry url='%s' method='%s' upload_data_size=%zu req_cls=%p\",\n             (url ? url : \"(null)\"), (method ? method : \"(null)\"),\n             (upload_data_size ? *upload_data_size : (size_t)0), (void *) req_cls);\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      log_probe (\"generate_page: unexpected method for file download: %s\", method);\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    }\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      log_probe (\"generate_page: attempted open('%s') -> fd=%d\", &url[1], fd);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        log_probe (\"generate_page: fstat failed or not regular file for fd=%d\", fd);\n        fd = -1;\n      }\n      else if (-1 != fd)\n      {\n        log_probe (\"generate_page: file size=%jd for fd=%d\", (intmax_t) buf.st_size, fd);\n      }\n    }\n    if (-1 == fd)\n    {\n      log_probe (\"generate_page: file not found for url='%s' -> returning 404\", url);\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n    }\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      log_probe (\"generate_page: MHD_create_response_from_fd failed for fd=%d\", fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n    {\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n      log_probe (\"generate_page: added Content-Type='%s' for url='%s'\", mime, url);\n    }\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    log_probe (\"generate_page: queued response for url='%s' -> ret=%d\", url, (int) ret);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    log_probe (\"generate_page: handling POST, initial req_cls->%p uc=%p\", (void *) req_cls, (void *) uc);\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n      {\n        log_probe (\"generate_page: malloc UploadContext failed\");\n        return MHD_NO; /* out of memory, close connection */\n      }\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n\n      /* Log the buffer size we will pass to MHD_create_post_processor. This is\n         the place to capture the value which, according to the reported\n         violation, gets modified inside MHD_create_post_processor. We do NOT\n         modify the parameter here; we only record what we pass. */\n      size_t probe_buffer_size = 64 * 1024; /* buffer size */\n      log_probe (\"generate_page: calling MHD_create_post_processor with buffer_size=%zu for uc=%p\",\n                 probe_buffer_size, (void *) uc);\n\n      uc->pp = MHD_create_post_processor (connection,\n                                          probe_buffer_size /* buffer size */,\n                                          &process_upload_data, uc);\n\n      log_upload_context (uc, \"generate_page: after MHD_create_post_processor (local uc state)\");\n\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        log_probe (\"generate_page: MHD_create_post_processor returned NULL\");\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      log_probe (\"generate_page: created UploadContext @%p and stored in *req_cls\", (void *) uc);\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      log_probe (\"generate_page: POST upload chunk size=%zu for uc=%p\", *upload_data_size, (void *) uc);\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      /* After processing we set the upload_data_size to 0 to indicate\n         we've consumed that data. Log the change for tracing. */\n      *upload_data_size = 0;\n      log_probe (\"generate_page: POST upload chunk processed; upload_data_size set to 0 for uc=%p\", (void *) uc);\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    log_probe (\"generate_page: end of POST upload for uc=%p; destroying post processor\", (void *) uc);\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n      log_probe (\"generate_page: closed upload file descriptor for uc=%p\", (void *) uc);\n    }\n    if (NULL != uc->response)\n    {\n      log_probe (\"generate_page: returning forbidden response (upload produced a response) for uc=%p\", (void *) uc);\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      log_probe (\"generate_page: upload successful; updating directory and returning directory response\");\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    log_probe (\"generate_page: GET/HEAD for '/' -> returning directory response\");\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  log_probe (\"generate_page: unexpected request method='%s' -> returning forbidden\", method);\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for generate_page. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is incorrect. MISRA C 2023 Rule 17.8 forbids modifying a function parameter inside the function where that parameter is declared (except that the object referred to by a pointer parameter may be modified, but the pointer itself must not be changed). The generate_page function itself does not modify its parameter variables. The only writes in generate_page are to the objects pointed to by pointer parameters (e.g. *upload_data_size = 0 and *req_cls = uc), which is explicitly allowed by the rule\u2019s note. The alleged modification (buffer_size += 4) is described as occurring inside MHD_create_post_processor; if that is true it would be a violation in MHD_create_post_processor\u2019s implementation, not in generate_page. Passing the literal 64*1024 as an argument to MHD_create_post_processor does not make generate_page violate Rule 17.8."
}