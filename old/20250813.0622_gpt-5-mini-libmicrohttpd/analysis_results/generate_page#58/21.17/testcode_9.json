{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.17.\nHere is the comment from the agent.\n<violation scenario>\nThe call strrchr(&url[1], '.') can read out-of-bounds if url is too short. For example, if url points to an empty string (\"\"), &url[1] points one-past the null terminator and strrchr will attempt to read from that location, accessing memory beyond the object bounds. Thus the use of strrchr here can violate Rule 21.17.\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified generate_page code that contains useful probe functions that print useful logs to a file \"/tmp/logs/471.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of generate_page as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of generate_page:\n```c\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n```\n</target_code>\nPlease provide the modified generate_page code.\n",
  "test_code": "static FILE *open_log_file(void)\n{\n  FILE *f = fopen(\"/tmp/logs/471.txt\", \"a\");\n  if (NULL != f)\n    return f;\n  /* try to create directory if not present (ignore errors) */\n  (void) mkdir(\"/tmp/logs\", 0700);\n  return fopen(\"/tmp/logs/471.txt\", \"a\");\n}\n\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  size_t url_len;\n  FILE *logf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  /* Probe: log entry */\n  logf = open_log_file();\n  if (NULL != logf)\n  {\n    fprintf(logf, \"ENTER generate_page: connection=%p url=%s method=%s\\n\",\n            (void *) connection,\n            (NULL != url) ? url : \"(null)\",\n            (NULL != method) ? method : \"(null)\");\n    fclose(logf);\n  }\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n\n    /* Probe: log url length and characteristics before security checks */\n    url_len = strlen(url);\n    logf = open_log_file();\n    if (NULL != logf)\n    {\n      fprintf(logf, \"file download branch: url_len=%zu url=%s\\n\", url_len, url);\n      if (0u == url_len)\n      {\n        fprintf(logf, \"WARNING: url is empty (\\\"\\\"). &url[1] will point one-past the null terminator.\"\n                      \" Passing &url[1] to string functions (strstr/strrchr) may read out-of-bounds.\\n\");\n      }\n      else\n      {\n        /* safe to read url[1] when url_len >= 1 (url[0] exists; url[1] is at most the '\\0') */\n        fprintf(logf, \"url[1]=0x%02x at %p\\n\",\n                (unsigned int) (unsigned char) url[1], (void *) &url[1]);\n      }\n      fclose(logf);\n    }\n\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = NULL;\n\n      /* Probe: log just before calling strrchr and capture the state */\n      url_len = strlen(url); /* re-evaluate length (unchanged) */\n      logf = open_log_file();\n      if (NULL != logf)\n      {\n        fprintf(logf, \"about to call strrchr(&url[1], '.') url_len=%zu url=%s\\n\",\n                url_len, url);\n        if (0u == url_len)\n        {\n          fprintf(logf, \"WARNING: Calling strrchr(&url[1], '.') when url is empty may cause out-of-bounds reads.\\n\");\n        }\n        fprintf(logf, \"calling strrchr(&url[1], '.') ->\\n\");\n        fclose(logf);\n      }\n\n      /* Original potentially problematic call retained to preserve logic */\n      ldot = strrchr (&url[1], '.');\n\n      /* Probe: log the result pointer of strrchr without dereferencing it */\n      logf = open_log_file();\n      if (NULL != logf)\n      {\n        if (NULL != ldot)\n          fprintf(logf, \"strrchr returned pointer %p (note: not dereferenced)\\n\", (void *) ldot);\n        else\n          fprintf(logf, \"strrchr returned NULL\\n\");\n        fclose(logf);\n      }\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n"
}