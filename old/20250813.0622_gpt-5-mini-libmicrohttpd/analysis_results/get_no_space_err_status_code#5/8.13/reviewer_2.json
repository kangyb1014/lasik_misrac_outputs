{
  "user_message": "An agent A claimed that the following get_no_space_err_status_code code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of get_no_space_err_status_code.\n```c\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The fragment performs pointer subtraction between c->read_buffer + c->read_buffer_offset and c->rq.field_lines.start. MISRA C 2023 Rule 8.13 is concerned with the declared pointee types. Pointer arithmetic itself does not violate the rule, but a violation occurs if either pointer is declared as a non-const pointer to data that is only read. For example, if c->rq.field_lines.start is declared as char * (and likewise c->read_buffer is char *) but the code never modifies the bytes through those pointers (they are only used for reading/length calculations), then they should be declared const char * and the rule is violated. Conversely, if the buffers are legitimately mutable (they are written elsewhere), then no violation occurs. In short: the fragment may violate Rule 8.13 depending on the declarations \u2014 it is a violation when the pointers are non-const but could be const.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_log_probe (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/43.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\n\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  /* Log entry state */\n  mhd_log_probe (\n    \"ENTER get_no_space_err_status_code: c=%p state=%d stage=%d add_element=%p add_element_size=%zu read_buffer=%p read_buffer_offset=%zu rq.field_lines.start=%p rq.field_lines.size=%zu rq.req_target_len=%zu rq.http_mthd=%d rq.method=%p\",\n    (void *) c,\n    (int) c->state,\n    (int) stage,\n    (void *) add_element,\n    add_element_size,\n    (void *) c->read_buffer,\n    c->read_buffer_offset,\n    (void *) c->rq.field_lines.start,\n    c->rq.field_lines.size,\n    c->rq.req_target_len,\n    (int) c->rq.http_mthd,\n    (void *) c->rq.method);\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n\n    /* Log the pointer subtraction and result to capture potential violation evidence */\n    mhd_log_probe (\n      \"Computed opt_headers_size from buffer pointers: (read_buffer + read_buffer_offset)=%p start=%p subtraction=%td opt_headers_size=%zu\",\n      (void *) (c->read_buffer + c->read_buffer_offset),\n      (void *) c->rq.field_lines.start,\n      ((c->read_buffer + c->read_buffer_offset) - c->rq.field_lines.start),\n      opt_headers_size);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    mhd_log_probe (\"RETURN %u (MHD_HTTP_CONTENT_TOO_LARGE) - chunked stage and add_element_size=%zu\",\n                   (unsigned) MHD_HTTP_CONTENT_TOO_LARGE,\n                   add_element_size);\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n\n      /* Log host header parsing path and sizes */\n      mhd_log_probe (\n        \"Host header parsed: is_host_header=%d is_parsed=%d add_element=%p add_element_size=%zu actual_element_size=%zu host_field_line_size=%zu opt_headers_size=%zu\",\n        (int) is_host_header,\n        (int) is_parsed,\n        (void *) add_element,\n        add_element_size,\n        actual_element_size,\n        host_field_line_size,\n        opt_headers_size);\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n\n      mhd_log_probe (\n        \"Host field from lookup: host_field_name_value_len=%zu host_field_line_size=%zu opt_headers_size=%zu\",\n        host_field_name_value_len,\n        host_field_line_size,\n        opt_headers_size);\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  mhd_log_probe (\"After initial calculations: opt_headers_size=%zu host_field_line_size=%zu uri_size=%zu method_size=%zu\",\n                 opt_headers_size, host_field_line_size, uri_size, method_size);\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size) {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      } else {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_NOT_IMPLEMENTED,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n      }\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size) {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_URI_TOO_LONG,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_URI_TOO_LONG;\n      } else {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_NOT_IMPLEMENTED,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n      }\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size) {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - uri_size=%zu method_size=%zu\",\n                     (unsigned) MHD_HTTP_URI_TOO_LONG, uri_size, method_size);\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    } else {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - uri_size=%zu method_size=%zu\",\n                     (unsigned) MHD_HTTP_NOT_IMPLEMENTED, uri_size, method_size);\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size) {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      } else {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_NOT_IMPLEMENTED,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n      }\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4) {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_URI_TOO_LONG,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_URI_TOO_LONG;\n      } else {\n        mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - opt_headers_size=%zu uri_size=%zu method_size=%zu\",\n                       (unsigned) MHD_HTTP_NOT_IMPLEMENTED,\n                       opt_headers_size, uri_size, method_size);\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n      }\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4) {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - uri_size=%zu method_size=%zu\",\n                     (unsigned) MHD_HTTP_URI_TOO_LONG, uri_size, method_size);\n      return MHD_HTTP_URI_TOO_LONG;\n    } else {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - uri_size=%zu method_size=%zu\",\n                     (unsigned) MHD_HTTP_NOT_IMPLEMENTED, uri_size, method_size);\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    mhd_log_probe (\"RETURN %u (MHD_HTTP_NOT_IMPLEMENTED) - method_size=%zu\",\n                   (unsigned) MHD_HTTP_NOT_IMPLEMENTED, method_size);\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size) {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE) - final opt_headers_size=%zu uri_size=%zu\",\n                     (unsigned) MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                     opt_headers_size, uri_size);\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    } else {\n      mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - final opt_headers_size=%zu uri_size=%zu\",\n                     (unsigned) MHD_HTTP_URI_TOO_LONG,\n                     opt_headers_size, uri_size);\n      return MHD_HTTP_URI_TOO_LONG;\n    }\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size) {\n    mhd_log_probe (\"RETURN %u (MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE) - host_field_line_size=%zu\",\n                   (unsigned) MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                   host_field_line_size);\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n  }\n\n  mhd_log_probe (\"RETURN %u (MHD_HTTP_URI_TOO_LONG) - default/last resort\",\n                 (unsigned) MHD_HTTP_URI_TOO_LONG);\n  return MHD_HTTP_URI_TOO_LONG;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_no_space_err_status_code. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct: the pointer subtraction itself does not trigger MISRA C 2023 Rule 8.13. The rule concerns the declared pointee types \u2014 pointers that are only used for reading should be declared to point to const-qualified types. From the snippet alone we do not have the declarations of c->read_buffer or c->rq.field_lines.start, so you cannot determine a definite violation. If those members are declared as non-const (e.g. char *) but are only ever read (as in this function) and could be declared const char *, then that would violate Rule 8.13 and should be fixed by adding const. Conversely, if those buffers are legitimately modified elsewhere (written to), then non-const is appropriate and there is no violation. Recommendation: inspect the definitions of struct MHD_Connection (and nested types) and change pointee types to const where the data is read-only."
}