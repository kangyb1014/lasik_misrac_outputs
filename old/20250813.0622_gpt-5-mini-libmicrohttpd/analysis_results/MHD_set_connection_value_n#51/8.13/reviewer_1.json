{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Violation occurs if the callee is declared to take non-const pointers, e.g.:\n\nenum MHD_Result MHD_set_connection_value_n_nocheck_(struct MHD_Connection *connection,\n                                                  enum MHD_ValueKind kind,\n                                                  char *key,\n                                                  size_t key_size,\n                                                  char *value,\n                                                  size_t value_size);\n\nIn that case the call passes const char *key and const char *value to parameters of type char *, discarding the const qualifier and allowing the callee to modify data through those pointers \u2014 this violates MISRA C 2023 Rule 8.13. If, however, the callee's prototype uses const char * for key and value, there is no violation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void MHD_log_probe(const char *event,\n                                 struct MHD_Connection *connection,\n                                 enum MHD_ValueKind kind,\n                                 const char *key,\n                                 size_t key_size,\n                                 const char *value,\n                                 size_t value_size,\n                                 const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/411.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  /* Log a concise snapshot of control flow and state. Use safe prints. */\n  fprintf(f, \"EVENT=%s\\n\", event);\n  fprintf(f, \" connection=%p kind=%d\\n\", (void *) connection, (int) kind);\n  fprintf(f, \" key_ptr=%p key_size=%zu\\n\", (const void *) key, key_size);\n  if (key != NULL)\n    fprintf(f, \" key_str=\\\"%s\\\"\\n\", key);\n  else\n    fprintf(f, \" key_str=NULL\\n\");\n  fprintf(f, \" value_ptr=%p value_size=%zu\\n\", (const void *) value, value_size);\n  if (value != NULL)\n    fprintf(f, \" value_str=\\\"%s\\\"\\n\", value);\n  else\n    fprintf(f, \" value_str=NULL\\n\");\n  if (extra != NULL)\n    fprintf(f, \" extra=%s\\n\", extra);\n  fprintf(f, \"---\\n\");\n\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  /* Probe: entry */\n  MHD_log_probe(\"enter\", connection, kind, key, key_size, value, value_size, NULL);\n\n  /* Compute lengths explicitly for clearer logs and to preserve original logic. */\n  size_t computed_key_len = (key ? strlen (key) : 0U);\n  size_t computed_value_len = (value ? strlen (value) : 0U);\n\n  /* Log computed lengths and the decision about the GET-argument check */\n  {\n    char extra[128];\n    /* Describe the check that will be performed. */\n    (void) snprintf(extra, sizeof(extra), \"computed_key_len=%zu computed_value_len=%zu\",\n                    computed_key_len, computed_value_len);\n    MHD_log_probe(\"pre_check\", connection, kind, key, key_size, value, value_size, extra);\n  }\n\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( (computed_key_len != key_size) ||\n         (computed_value_len != value_size) ) )\n  {\n    /* Probe: early return due to length mismatch (binary zero allowed only in GET args) */\n    MHD_log_probe(\"early_return_length_mismatch\", connection, kind, key, key_size, value, value_size,\n                  \"binary zero is allowed only in GET arguments\");\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  /* Probe: about to call the nocheck function. This is where const -> non-const pointer\n     conversion would occur if the callee expects non-const char * parameters. */\n  MHD_log_probe(\"calling_nocheck\", connection, kind, key, key_size, value, value_size,\n                \"Note: passing const char *key/value to MHD_set_connection_value_n_nocheck_\");\n\n  enum MHD_Result res = MHD_set_connection_value_n_nocheck_ (connection,\n                                                            kind,\n                                                            key,\n                                                            key_size,\n                                                            value,\n                                                            value_size);\n\n  /* Probe: result from nocheck call */\n  {\n    char extra[64];\n    (void) snprintf(extra, sizeof(extra), \"result=%d\", (int) res);\n    MHD_log_probe(\"post_nocheck\", connection, kind, key, key_size, value, value_size, extra);\n  }\n\n  return res;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_set_connection_value_n. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reporter\u2019s scenario is technically possible but the claim that MHD_set_connection_value_n itself violates MISRA C:2023 Rule 8.13 is not established by the code shown. In the posted function the pointer parameters are declared as const char * (which is what Rule 8.13 requires whenever possible). The only way a problem would occur is if the callee MHD_set_connection_value_n_nocheck_ were declared to take non-const char * for key/value; that would (a) cause a const-qualification discard when calling it and (b) mean the callee\u2019s prototype/definition is the entity that does not follow the \u201cpointer should point to a const-qualified type whenever possible\u201d advice. In other words, the violation would be in the nocheck function\u2019s declaration/definition (or in an incompatible prototype visible at the call site), not in the caller shown here. If the nocheck function is correctly declared with const char * parameters, there is no violation. Recommendation: ensure the nocheck function prototype uses const char * for key/value (or add an explicit const-correct wrapper) so no qualifier is discarded and MISRA guidance is met."
}