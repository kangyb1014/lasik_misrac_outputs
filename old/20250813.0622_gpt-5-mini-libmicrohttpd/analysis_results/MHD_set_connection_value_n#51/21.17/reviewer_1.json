{
  "user_message": "An agent A claimed that the following MHD_set_connection_value_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_value_n.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:strlen is called only guarded by (key ? ... : 0) but not by any bound on the buffer length. If key points to a non-NULL buffer that is not NUL-terminated within its allocated/key_size bytes (e.g. binary data or a buffer of key_size bytes without a terminating '\\0'), strlen(key) will scan past the intended object and can read out-of-bounds. Example: key points to a 4-byte buffer {'a','b','c','d'} with key_size == 4; the expression calls strlen(key) and will continue reading beyond the 4 bytes until a NUL is found, causing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *stage,\n                          struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          size_t key_size,\n                          const char *value,\n                          size_t value_size,\n                          size_t len_key,\n                          size_t len_value)\n{\n  FILE *f = fopen(\"/tmp/logs/415.txt\", \"a\");\n  if (f == NULL)\n    return;\n\n  fprintf(f, \"stage=%s conn=%p kind=%d key=%p key_size=%zu value=%p value_size=%zu len_key=%zu len_value=%zu\\n\",\n          stage, (void *)connection, (int)kind,\n          (void *)key, key_size,\n          (void *)value, value_size,\n          len_key, len_value);\n\n  /* Dump up to the first 16 bytes of key/value within the provided sizes to help reproduce the scenario. */\n  if (key && key_size > 0) {\n    size_t n = key_size < 16 ? key_size : 16;\n    fprintf(f, \"key_bytes=\");\n    for (size_t i = 0; i < n; ++i)\n      fprintf(f, \"%02x%s\", (unsigned char)key[i], (i + 1 < n) ? \" \" : \"\\n\");\n  }\n  if (value && value_size > 0) {\n    size_t n = value_size < 16 ? value_size : 16;\n    fprintf(f, \"value_bytes=\");\n    for (size_t i = 0; i < n; ++i)\n      fprintf(f, \"%02x%s\", (unsigned char)value[i], (i + 1 < n) ? \" \" : \"\\n\");\n  }\n\n  fclose(f);\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  /* Compute the strlen results once (preserving the original behavior which may read beyond key_size/value_size\n     if the buffers are not NUL-terminated). This mirrors the original control flow while allowing us to log the\n     computed lengths and other state for reproducing the violation scenario. */\n  size_t len_key = key ? strlen(key) : 0;\n  size_t len_value = value ? strlen(value) : 0;\n\n  mhd_log_probe(\"entry\", connection, kind, key, key_size, value, value_size, len_key, len_value);\n\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((len_key) != key_size) || ((len_value) != value_size) ) ) {\n    mhd_log_probe(\"return_MHD_NO\", connection, kind, key, key_size, value, value_size, len_key, len_value);\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  mhd_log_probe(\"call_nocheck\", connection, kind, key, key_size, value, value_size, len_key, len_value);\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_set_connection_value_n. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Calling strlen(key) (and strlen(value)) guarded only by a non-NULL check does not prevent strlen from scanning past key_size/value_size and past the allocated object if a NUL byte is not present within the intended bounds. That can produce an out\u2011of\u2011bounds access and therefore violates MISRA C 2023 Rule 21.17, unless there is an external, enforceable API contract that guarantees the buffers are NUL\u2011terminated within the provided sizes. In the presented code there is no such explicit guarantee visible, and the presence of separate key_size/value_size parameters implies the buffers may contain binary data; thus using strlen is unsafe. Recommended fixes: use a bounded search (e.g. memchr(key, '\\0', key_size) to locate a terminator or a safe strnlen-like routine that limits the scan to key_size) or otherwise enforce/validate that the caller supplies NUL\u2011terminated strings before calling strlen."
}