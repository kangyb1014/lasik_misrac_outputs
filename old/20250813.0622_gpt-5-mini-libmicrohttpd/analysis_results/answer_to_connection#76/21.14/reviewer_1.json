{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses memcmp(auth_info->password, \"pa$$w0rd\", auth_info->password_len). auth_info->password is explicitly zero-terminated by MHD_basic_auth_get_username_password3 (password[password_len] = 0) and \"pa$$w0rd\" is a null-terminated string literal, so memcmp is being used to compare null-terminated strings (even though the comparison length excludes the terminator). This violates MISRA C 2023 Rule 21.14.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Probe logging: append control flow and state to /tmp/logs/614.txt */\n  {\n    FILE *log = fopen(\"/tmp/logs/614.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"answer_to_connection: entry; method=%s, connection=%p, req_cls_ptr=%p, *req_cls=%p\\n\",\n              (method != NULL) ? method : \"(null)\", (void *) connection, (void *) req_cls, (void *) (req_cls ? *req_cls : NULL));\n      fclose(log);\n    }\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    FILE *log = fopen(\"/tmp/logs/614.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"answer_to_connection: rejected method (not GET): %s\\n\", method);\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    FILE *log = fopen(\"/tmp/logs/614.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"answer_to_connection: initial request, storing req_cls=%p\\n\", (void *) connection);\n      fclose(log);\n    }\n    *req_cls = connection;\n    return MHD_YES;\n  }\n\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n\n  /* Log auth_info state and the data used in comparisons. */\n  {\n    FILE *log = fopen(\"/tmp/logs/614.txt\", \"a\");\n    if (log != NULL)\n    {\n      if (NULL == auth_info)\n      {\n        fprintf(log, \"answer_to_connection: auth_info == NULL\\n\");\n      }\n      else\n      {\n        size_t i;\n        size_t ulen = auth_info->username_len;\n        size_t plen = auth_info->password_len;\n\n        fprintf(log, \"answer_to_connection: auth_info=%p, username=%p, username_len=%zu, password=%p, password_len=%zu\\n\",\n                (void *) auth_info,\n                (void *) auth_info->username, ulen,\n                (void *) auth_info->password, plen);\n\n        /* Print username bytes up to username_len and one extra byte (to show possible NUL terminator). */\n        if (auth_info->username != NULL)\n        {\n          fprintf(log, \"username bytes (hex, up to len+1):\");\n          /* limit to reasonable maximum to avoid huge logs */\n          for (i = 0; i <= ulen && i < ulen + 2 && i < 256; ++i)\n          {\n            unsigned char c = (unsigned char) auth_info->username[i];\n            fprintf(log, \" %02x\", c);\n          }\n          fprintf(log, \"\\n\");\n\n          /* If possible, print ASCII view of the username up to username_len. */\n          {\n            size_t to_print = (ulen < 128u) ? ulen : 128u;\n            fprintf(log, \"username (first %zu chars): '\", to_print);\n            fwrite(auth_info->username, 1, to_print, log);\n            if (ulen > to_print)\n              fprintf(log, \"...\");\n            fprintf(log, \"'\\n\");\n          }\n        }\n        else\n        {\n          fprintf(log, \"username pointer is NULL\\n\");\n        }\n\n        /* Print password bytes up to password_len and one extra byte (to show possible NUL terminator). */\n        if (auth_info->password != NULL)\n        {\n          fprintf(log, \"password bytes (hex, up to len+1):\");\n          for (i = 0; i <= plen && i < plen + 2 && i < 256; ++i)\n          {\n            unsigned char c = (unsigned char) auth_info->password[i];\n            fprintf(log, \" %02x\", c);\n          }\n          fprintf(log, \"\\n\");\n\n          size_t to_print = (plen < 128u) ? plen : 128u;\n          fprintf(log, \"password (first %zu chars): '\", to_print);\n          fwrite(auth_info->password, 1, to_print, log);\n          if (plen > to_print)\n            fprintf(log, \"...\");\n          fprintf(log, \"'\\n\");\n        }\n        else\n        {\n          fprintf(log, \"password pointer is NULL\\n\");\n        }\n\n        /* Log expected literal lengths */\n        fprintf(log, \"expected username literal 'root' length=%zu, expected password literal 'pa$$w0rd' length=%zu\\n\",\n                strlen(\"root\"), strlen(\"pa$$w0rd\"));\n\n        /* Evaluate and log comparison results (do not change program logic). */\n        {\n          int cmp_user = 0;\n          int cmp_pass = 0;\n          if (auth_info->username != NULL)\n            cmp_user = memcmp (auth_info->username, \"root\", auth_info->username_len);\n          else\n            cmp_user = 1; /* treat as non-equal */\n          if (auth_info->password != NULL)\n            cmp_pass = memcmp (auth_info->password, \"pa$$w0rd\", auth_info->password_len);\n          else\n            cmp_pass = 1; /* treat as non-equal */\n\n          fprintf(log, \"memcmp username result=%d (memcmp of username_len=%zu bytes)\\n\", cmp_user, auth_info->username_len);\n          fprintf(log, \"memcmp password result=%d (memcmp of password_len=%zu bytes)\\n\", cmp_pass, auth_info->password_len);\n\n          /* Additionally record whether a NUL byte is present at index [len] for username/password. */\n          if (auth_info->username != NULL)\n          {\n            unsigned char c = (unsigned char) auth_info->username[auth_info->username_len];\n            fprintf(log, \"username byte at [username_len] = 0x%02x (%s)\\n\", c, (c == 0) ? \"NUL\" : \"non-NUL\");\n          }\n          if (auth_info->password != NULL)\n          {\n            unsigned char c = (unsigned char) auth_info->password[auth_info->password_len];\n            fprintf(log, \"password byte at [password_len] = 0x%02x (%s)\\n\", c, (c == 0) ? \"NUL\" : \"non-NUL\");\n          }\n        }\n      }\n      fclose(log);\n    }\n  }\n\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n\n  /* Final probe: log selected response code and cleanup. */\n  {\n    FILE *log = fopen(\"/tmp/logs/614.txt\", \"a\");\n    if (log != NULL)\n    {\n      fprintf(log, \"answer_to_connection: exit; ret=%d\\n\", (int) ret);\n      fclose(log);\n    }\n  }\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for answer_to_connection. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C:2023 Rule 21.14 forbids using memcmp to compare null-terminated strings. In the code memcmp is used with the second operand a string literal (\"root\", \"pa$$w0rd\") \u2014 these are null-terminated arrays \u2014 and the first operand is auth_info->username / auth_info->password, which (per the library behaviour noted) are also provided with a terminating NUL (password[password_len] = 0). Even though the memcmp length argument excludes the NUL terminator in these checks, the prohibition in 21.14 applies because memcmp is being used to compare null-terminated string objects. To comply, use the appropriate string-comparison functions (e.g. strcmp/strncmp with careful bounds checks) or ensure comparisons operate on pure byte buffers that are not null-terminated strings."
}