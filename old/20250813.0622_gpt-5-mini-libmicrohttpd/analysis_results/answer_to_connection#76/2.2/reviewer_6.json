{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The five '(void) <name>;' expression-statements (for cls, url, version, upload_data, upload_data_size) are executed but have no side effects; removing them would not affect program behaviour (they only suppress unused-variable warnings). Therefore these statements constitute dead code under MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_ptr(const char *name, const void *p)\n{\n  FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"probe: %s -> ptr=%p\\n\", name, p);\n    fclose(f);\n  }\n}\nstatic void probe_str(const char *name, const char *s)\n{\n  FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n  if (f)\n  {\n    if (s)\n      fprintf(f, \"probe: %s -> str=\\\"%s\\\"\\n\", name, s);\n    else\n      fprintf(f, \"probe: %s -> NULL\\n\", name);\n    fclose(f);\n  }\n}\nstatic void probe_msg(const char *msg)\n{\n  FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\nstatic void probe_fmt(const char *label, const void *p, const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n  if (f)\n  {\n    fprintf(f, \"%s: ptr=%p %s\\n\", label, p, extra ? extra : \"\");\n    fclose(f);\n  }\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n\n  /* Probes inserted in place of the (void) <name>; statements to record that\n     these expression-statements were executed and to capture their state. */\n  probe_msg(\"answer_to_connection: entry\");\n  /* Record pointers and string contents where safe. */\n  probe_ptr(\"cls\", cls);\n  probe_str(\"url\", url);\n  probe_str(\"version\", version);\n  probe_str(\"upload_data\", upload_data);\n  probe_ptr(\"upload_data_size\", upload_data_size);\n\n  /* Also log method and request-class state to capture control flow decisions. */\n  {\n    FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"method=%s connection=%p req_cls_ptr=%p req_cls_val=%p\\n\",\n              method ? method : \"(null)\", (void *) connection,\n              (void *) req_cls, (void *) (req_cls ? *req_cls : NULL));\n      fclose(f);\n    }\n  }\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    probe_msg(\"decision: method != GET -> returning MHD_NO\");\n    return MHD_NO;\n  }\n  if (NULL == *req_cls)\n  {\n    probe_msg(\"decision: *req_cls is NULL -> set to connection and return MHD_YES\");\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    probe_msg(\"decision: auth_info == NULL -> require authorization page\");\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    probe_msg(\"decision: bad username/password -> wrong credentials page\");\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    probe_msg(\"decision: credentials ok -> secret page\");\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n  {\n    probe_msg(\"cleanup: freeing auth_info\");\n    MHD_free (auth_info);\n  }\n  MHD_destroy_response (response);\n\n  /* Final return value logged so external agents can observe outcome. */\n  {\n    FILE *f = fopen(\"/tmp/logs/610.txt\", \"a\");\n    if (f)\n    {\n      fprintf(f, \"answer_to_connection: return ret=%d\\n\", (int) ret);\n      fclose(f);\n    }\n  }\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for answer_to_connection. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The five lines of the form (void) name; are executed expression-statements that have no side effects (they merely evaluate and discard the parameter). Removing them would not change the program behaviour, so they meet the definition of dead code in MISRA C 2023 Rule 2.2 and therefore constitute a violation. (Minor caveat: if a parameter were volatile or its evaluation provoked a side effect, the cast-to-void would not be dead; that is not the case here.) The test probe added by agent A does not invalidate the conclusion \u2014 the probe run produced no logs because the test did not exercise the function \u2014 but that does not change the static observation that the original (void) statements are dead code under Rule 2.2."
}