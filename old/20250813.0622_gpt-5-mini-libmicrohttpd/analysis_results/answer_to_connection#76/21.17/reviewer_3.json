{
  "user_message": "An agent A claimed that the following answer_to_connection code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of answer_to_connection.\n```c\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *req_cls)\n  {\n    *req_cls = connection;\n    return MHD_YES;\n  }\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The call strcmp(method, \"GET\") is made without ensuring that 'method' is non-NULL and points to a NUL-terminated character array. If 'method' is NULL (or refers to a buffer not NUL-terminated within its allocated bounds), strcmp will read out-of-bounds (e.g. dereferencing NULL or scanning past the object), violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nprobe_log_state(const char *stage, const char *method,\n                struct MHD_Connection *connection, void **req_cls)\n{\n  FILE *f = fopen(\"/tmp/logs/615.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  /* Log basic state without dereferencing potentially unsafe pointers. */\n  fprintf(f, \"%s: method_ptr=%p method_is_null=%d connection=%p req_cls=%p\",\n          stage, (const void *) method, (int) (method == NULL), (void *) connection,\n          (void *) req_cls);\n  if (NULL != req_cls)\n    /* Log the pointer stored in *req_cls (no dereference of what it points to). */\n    fprintf(f, \" *req_cls=%p\", *req_cls);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\nstatic enum MHD_Result\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_BasicAuthInfo *auth_info;\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Probe: log entry state (do not dereference 'method'). */\n  probe_log_state(\"entry\", method, connection, req_cls);\n\n  /* Probe: log just before the unsafe call to strcmp so that callers can\n   * reproduce whether 'method' is NULL (or not) prior to the call. */\n  probe_log_state(\"pre_strcmp\", method, connection, req_cls);\n\n  if (0 != strcmp (method, \"GET\"))\n  {\n    probe_log_state(\"post_strcmp_not_get\", method, connection, req_cls);\n    return MHD_NO;\n  }\n\n  if (NULL == *req_cls)\n  {\n    /* Log state when initializing the request-class for the first time. */\n    probe_log_state(\"init_req_cls\", method, connection, req_cls);\n    *req_cls = connection;\n    return MHD_YES;\n  }\n\n  auth_info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == auth_info)\n  {\n    static const char *page =\n      \"<html><body>Authorization required</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else if ((strlen (\"root\") != auth_info->username_len) ||\n           (0 != memcmp (auth_info->username, \"root\",\n                         auth_info->username_len)) ||\n           /* The next check against NULL is optional,\n            * if 'password' is NULL then 'password_len' is always zero. */\n           (NULL == auth_info->password) ||\n           (strlen (\"pa$$w0rd\") != auth_info->password_len) ||\n           (0 != memcmp (auth_info->password, \"pa$$w0rd\",\n                         auth_info->password_len)))\n  {\n    static const char *page =\n      \"<html><body>Wrong username or password</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_basic_auth_required_response3 (connection,\n                                                   \"admins\",\n                                                   MHD_YES,\n                                                   response);\n  }\n  else\n  {\n    static const char *page = \"<html><body>A secret.</body></html>\";\n    response = MHD_create_response_from_buffer_static (strlen (page), page);\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  }\n  if (NULL != auth_info)\n    MHD_free (auth_info);\n  MHD_destroy_response (response);\n\n  /* Log exit state. */\n  probe_log_state(\"exit\", method, connection, req_cls);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for answer_to_connection. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s scenario is correct under the MISRA intent. Rule 21.17 requires that calls to the <string.h> functions must not result in accesses beyond the bounds of the objects referenced by their pointer parameters. The call strcmp(method, \"GET\") is made with no prior check that method is non-NULL and refers to a NUL-terminated array. If, contrary to any external API guarantee, method were NULL or not NUL-terminated within its object bounds, strcmp would read out-of-bounds (or dereference NULL) and thus violate Rule 21.17. \n\nNote: other uses of string functions in the routine are handled safely: the memcmp calls are guarded by length checks (and password is checked for NULL before use), and strlen is only applied to static string literals. Therefore the only problematic usage is strcmp(method, \"GET\"). If the surrounding framework/API (libmicrohttpd) formally and unambiguously guarantees that method is always a valid, NUL-terminated non-NULL string, then the call is safe and there is no MISRA violation; absent such a documented guarantee, the code should defensively check method != NULL (or otherwise ensure bounds/NUL-termination) to comply with Rule 21.17.\n"
}