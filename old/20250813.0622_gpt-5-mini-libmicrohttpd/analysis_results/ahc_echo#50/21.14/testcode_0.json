{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n\nAnother agent reported that the target code violated the Rule 21.14.\nHere is the comment from the agent.\n<violation scenario>\nThe code uses memcmp(hdr->value, \"close\", 5) to test whether the header value equals the token \"close\". hdr->value is a C string (header values are stored/used as NUL-terminated strings elsewhere) and \"close\" is a NUL\u2011terminated string literal. Using memcmp to compare these string values violates MISRA C 2023 Rule 21.14 (memcmp shall not be used to compare null\u2011terminated strings).\n</violation scenario>\n\nYour job is to insert logging code to capture the control flow and state information of the program.\nInsert logging code so that other agents can reproduce and get evidence for the violation scenario.\n<response format>\n- test_code: a modified ahc_echo code that contains useful probe functions that print useful logs to a file \"/tmp/logs/406.txt\". The logs should contain the control path and state information of the violation scenario. If test code is not required to validate the scenario, you can leave this blank.\nHere are the constraints for the test code:\n- The test code MUST preserve the original logic of ahc_echo as much as possible.\nYou CAN just insert probe functions to the original code.\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\nPlease provide the modified ahc_echo code.\n",
  "test_code": "#include <stdio.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\n/* Probe logging helper. Appends human-readable logs to /tmp/logs/406.txt.\n * Creates /tmp/logs directory if necessary. Keeps behavior of ahc_echo unchanged.\n */\nstatic void probe_logf(const char *fmt, ...)\n{\n  FILE *f = NULL;\n  struct stat st;\n  va_list ap;\n\n  if (0 != stat(\"/tmp/logs\", &st))\n  {\n    /* attempt to create directory; ignore errors if it fails */\n    (void) mkdir(\"/tmp/logs\", 0777);\n  }\n\n  f = fopen(\"/tmp/logs/406.txt\", \"a\");\n  if (NULL == f)\n  {\n    /* If logging is not possible, silently return to avoid changing program flow. */\n    return;\n  }\n\n  va_start(ap, fmt);\n  (void) vfprintf(f, fmt, ap);\n  va_end(ap);\n\n  (void) fflush(f);\n  (void) fclose(f);\n}\n\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  /* Log entry with key inputs and current req_cls pointer value. */\n  probe_logf(\"ahc_echo ENTRY: method=%s url=%s req_cls_ptr=%p req_cls_val=%p\\n\",\n             (NULL != method) ? method : \"(null)\",\n             (NULL != url) ? url : \"(null)\",\n             (void *) req_cls, (NULL != req_cls) ? *req_cls : (void *) 0);\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    probe_logf(\"ahc_echo: unexpected method '%s' --> return MHD_NO\\n\",\n               (NULL != method) ? method : \"(null)\");\n    return MHD_NO;              /* unexpected method */\n  }\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    probe_logf(\"ahc_echo: first call detected, setting req_cls to %p and returning MHD_YES\\n\",\n               (void *) *req_cls);\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n\n  /* Log the URL inspection and potential security check. */\n  probe_logf(\"ahc_echo: serving path check, url=%s\\n\",\n             (NULL != url) ? url : \"(null)\");\n\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n  {\n    probe_logf(\"ahc_echo: detected '..' in url -> refusing to traverse up, fd will be -1\\n\");\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  }\n  else\n  {\n    const char *fname = url + 1;\n    probe_logf(\"ahc_echo: attempting to open file '%s'\\n\",\n               (NULL != fname) ? fname : \"(null)\");\n    fd = open (fname, O_RDONLY);\n    probe_logf(\"ahc_echo: open('%s') returned fd=%d (errno=%d)\\n\",\n               (NULL != fname) ? fname : \"(null)\", fd, errno);\n  }\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      probe_logf(\"ahc_echo: fstat/regular check failed: fstat_ret=%d S_ISREG=%d\\n\",\n                 (int) (0 != fstat (fd, &buf)), (int) S_ISREG (buf.st_mode));\n      if (0 != close (fd))\n      {\n        probe_logf(\"ahc_echo: close(fd=%d) failed with errno=%d -> aborting\\n\",\n                   fd, errno);\n        abort ();\n      }\n      fd = -1;\n    }\n    else\n    {\n      probe_logf(\"ahc_echo: file is regular, st_size=%lld st_mode=0%o\\n\",\n                 (long long) buf.st_size, (unsigned int) buf.st_mode);\n    }\n  }\n  if (-1 == fd)\n  {\n    probe_logf(\"ahc_echo: preparing 404 response for url=%s\\n\",\n               (NULL != url) ? url : \"(null)\");\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    probe_logf(\"ahc_echo: queued 404 response -> ret=%d\\n\", (int) ret);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    probe_logf(\"ahc_echo: preparing 200 response from fd=%d size=%lld\\n\",\n               fd, (long long) buf.st_size);\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      probe_logf(\"ahc_echo: MHD_create_response_from_fd64 returned NULL for fd=%d -> closing fd and returning MHD_NO\\n\",\n                 fd);\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    probe_logf(\"ahc_echo: queued 200 response -> ret=%d\\n\", (int) ret);\n    MHD_destroy_response (response);\n  }\n\n  probe_logf(\"ahc_echo EXIT: returning ret=%d\\n\", (int) ret);\n  return ret;\n}\n"
}