{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "SSIZE_MAX",
    "mhd_assert"
  ],
  "explanation": "To determine whether the target function itself (not callees) violates the MISRA rule \"A function parameter should not be modified\" we need the following symbols so we can inspect signatures, constness and any macro expansions that might assign to parameter variables:\n\n- MHD_str_pct_decode_strict_n_: need its prototype/implementation to confirm the parameter types (e.g. whether buf is passed as char * or a pointer-to-pointer) and to verify that the call expression cannot modify the caller's parameter variables (only the pointee). This ensures the call doesn't implicitly modify the function parameter variables themselves.\n\n- MHD_str_equal_caseless_bin_n_: need its prototype/definition (or macro) to check its parameter types/const qualifiers and whether it is a macro that could expand to code that assigns to uname_ext or uname_ext_len. If it is a macro, its expansion must be examined for side effects on parameters.\n\n- MHD_STATICSTR_LEN_: this is a macro used in the call to MHD_str_equal_caseless_bin_n_ and in computing r. We must see its definition to ensure it has no side effects or inadvertent use of function parameter names that could modify them.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: need its definition (string/macro) because it is used as an argument to the equality check and to MHD_STATICSTR_LEN_. If it is a complex macro it could expand to code with side effects; confirm it's a plain compile-time constant.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: constant used in a comparison against uname_ext_len. We need its definition to ensure no macro side-effects and to validate that no assignment to uname_ext_len occurs via a macro expansion.\n\n- SSIZE_MAX: used in a comparison and in mhd_assert; include to confirm the comparison and cast do not rely on macros with side effects that could modify parameters.\n\n- mhd_assert: typically a macro; we must inspect its definition to ensure it does not expand to code that modifies function parameters (for example via comma expressions, assignments, or evaluating expressions with side effects that could reassign parameters).\n\nNote: Other internal callees (e.g. toxdigitvalue) are not required for determining whether this function modifies its own parameter variables because the function never passes addresses of its parameter variables (no &buf, &uname_ext_len, etc.) and only passes values/pointers by value. The listed symbols suffice to detect any macro expansions or callees that could modify the parameter variables inside this function."
}