{
  "user_message": "An agent A claimed that the following get_rq_extended_uname_copy_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_extended_uname_copy_z.\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Yes. If MHD_str_pct_decode_strict_n_ returns w == buf_size (which it can: e.g. when buf_size >= pct_encoded_len and the decoded length equals pct_encoded_len == buf_size), the subsequent buf[w] = 0 writes one past the end of the buffer. Example: uname_ext+r has length equal to buf_size and contains no percent-encodings, so the decoder writes buf[0..buf_size-1], returns w == buf_size, and buf[buf_size] = 0 is an out-of-bounds write.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log_probe(const char *phase,\n                          const char *uname_ext, size_t uname_ext_len,\n                          size_t r, size_t w, char *buf, size_t buf_size,\n                          const char *extra)\n{\n    FILE *fp = fopen(\"/tmp/logs/79.txt\", \"a\");\n    if (!fp)\n        return;\n\n    /* Limit how many characters of uname_ext we dump to the log to avoid huge outputs. */\n    int dump_len = 0;\n    if (uname_ext)\n    {\n        dump_len = (int) (uname_ext_len > 256 ? 256 : uname_ext_len);\n    }\n\n    fprintf(fp, \"[get_rq_extended_uname_copy_z] phase=%s\\n\", phase);\n    fprintf(fp, \"  uname_ext=%p, uname_ext_len=%zu\\n\", (const void *) uname_ext, uname_ext_len);\n    if (uname_ext && dump_len > 0)\n        fprintf(fp, \"  uname_ext[0..%d]=\\'%.*s\\'\\n\", dump_len - 1, dump_len, uname_ext);\n    fprintf(fp, \"  r=%zu, w=%zu, buf=%p, buf_size=%zu\\n\", r, w, (void *) buf, buf_size);\n    if (extra)\n        fprintf(fp, \"  note=%s\\n\", extra);\n    fprintf(fp, \"------------------------------------------------------------\\n\");\n    fclose(fp);\n}\n\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  mhd_log_probe(\"entry\", uname_ext, uname_ext_len, 0, 0, buf, buf_size,\n                \"function entry\");\n\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n  {\n    mhd_log_probe(\"early_return_too_long\", uname_ext, uname_ext_len, 0, 0, buf, buf_size,\n                  \"input length > SSIZE_MAX\");\n    return -1; /* Too long input string */\n  }\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n  {\n    mhd_log_probe(\"early_return_missing_prefix\", uname_ext, uname_ext_len, 0, 0, buf, buf_size,\n                  \"required prefix missing (too short)\");\n    return -1; /* Required prefix is missing */\n  }\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n  {\n    mhd_log_probe(\"early_return_prefix_mismatch\", uname_ext, uname_ext_len, 0, 0, buf, buf_size,\n                  \"prefix does not match case-insensitive\");\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n  }\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  mhd_log_probe(\"after_prefix\", uname_ext, uname_ext_len, r, 0, buf, buf_size,\n                \"starting language tag scan\");\n\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n    {\n      mhd_log_probe(\"invalid_lang_tag_char\", uname_ext, uname_ext_len, r, 0, buf, buf_size,\n                    \"invalid char found in language tag\");\n      return -1; /* Wrong char in language tag */\n    }\n    r++;\n  }\n  if (r >= uname_ext_len)\n  {\n    mhd_log_probe(\"early_return_no_end_lang_tag\", uname_ext, uname_ext_len, r, 0, buf, buf_size,\n                  \"end of language tag not found\");\n    return -1; /* The end of the language tag was not found */\n  }\n  r++; /* Advance to the next char */\n\n  mhd_log_probe(\"before_decode\", uname_ext, uname_ext_len, r, 0, buf, buf_size,\n                \"about to call MHD_str_pct_decode_strict_n_\");\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n\n  mhd_log_probe(\"after_decode\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                \"returned from MHD_str_pct_decode_strict_n_\");\n\n  if ((0 == w) && (0 != uname_ext_len - r))\n  {\n    mhd_log_probe(\"broken_pct_encoding\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                  \"broken percent-encoding detected (w==0 and input remains)\");\n    return -1; /* Broken percent encoding */\n  }\n\n  /* Log potential out-of-bounds scenario before performing the original zero-termination. */\n  if (w == buf_size)\n  {\n    mhd_log_probe(\"about_to_oob_write\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                  \"WARNING: w == buf_size; the following buf[w] = 0 will write past the buffer end\");\n  }\n  else\n  {\n    mhd_log_probe(\"about_to_write_term\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                  \"writing terminating null within buffer\");\n  }\n\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_log_probe(\"after_write_term\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                \"termination write done\");\n\n  mhd_assert (SSIZE_MAX > w);\n  mhd_log_probe(\"exit_ok\", uname_ext, uname_ext_len, r, w, buf, buf_size,\n                \"returning success\");\n  return (ssize_t) w;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for get_rq_extended_uname_copy_z. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s scenario correctly identifies a real potential out\u2011of\u2011bounds write (buf[w] = 0 when w == buf_size). However MISRA C 2023 Rule 21.17 specifically concerns the use of the string handling functions from <string.h> (e.g. memcpy, strcpy, strlen, etc.) and requires that calls to those standard functions not access beyond the bounds of the objects passed. The code shown does not call any <string.h> functions \u2014 it calls a project decoder MHD_str_pct_decode_strict_n_ and performs a direct buffer write. Therefore the diagnosis that this function violates MISRA Rule 21.17 is incorrect. That said, the code does appear to have a genuine bounds/termination bug: either the decoder must guarantee it never returns w == buf_size (reserving space for the terminator), or get_rq_extended_uname_copy_z must check w < buf_size (or fail/adjust) before writing buf[w] = 0. So the report is wrong with respect to Rule 21.17, but the underlying out\u2011of\u2011bounds concern is valid and should be fixed (under other MISRA rules about array bounds and buffer handling)."
}