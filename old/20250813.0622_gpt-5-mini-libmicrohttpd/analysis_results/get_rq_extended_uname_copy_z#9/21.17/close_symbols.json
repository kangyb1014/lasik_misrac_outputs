{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "toxdigitvalue",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "SSIZE_MAX"
  ],
  "explanation": "Explain why each symbol is needed for MISRA C bounds analysis of get_rq_extended_uname_copy_z:\n\n- MHD_str_pct_decode_strict_n_: The core decoder that writes into buf and returns w. You must know its exact contract: how many bytes it may write relative to buf_size (does it guarantee to never write more than buf_size or to leave room for a terminating NUL?), whether it can write a NUL itself, and whether it performs any unchecked writes on buf. Without its implementation/spec you cannot determine if buf[w] = 0 is in-bounds or whether the decoder itself may overrun buf or read beyond uname_ext + r.\n\n- toxdigitvalue: Called by MHD_str_pct_decode_strict_n_ (per the static call graph). Its behavior affects how percent-escapes are parsed and whether invalid sequences cause early returns or extra reads; its implementation helps determine if pct decoder can read out of bounds from the input string when parsing escapes.\n\n- MHD_str_equal_caseless_bin_n_: Used to compare uname_ext to the required prefix. You must know whether this function reads exactly the provided length (binary compare) or expects NUL-terminated strings, and whether it may read beyond the provided buffer when the length argument is the static prefix length. This determines if the initial prefix check can access bytes beyond uname_ext_len.\n\n- MHD_STATICSTR_LEN_: Macro used to compute the prefix length passed to the caseless compare and assigned to r. You need its expansion/value for the specific MHD_DAUTH_EXT_PARAM_PREFIX to know the starting r and to check the subsequent loop bounds reasoning (r < uname_ext_len).\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: The static prefix string itself (and its length) \u2014 required to reason about what MHD_STR_EQUAL... compares and whether the code's logic for skipping the language tag is correct relative to the actual prefix content.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: The minimum allowed uname_ext_len tested at the start. Its numeric value is needed to confirm the initial length check covers the prefix and minimal extra content so that subsequent reads (e.g., accessing uname_ext[r]) cannot be out of bounds.\n\n- SSIZE_MAX: Used in the initial check and in the mhd_assert. Its value is needed to reason about the cast/compare correctness (size_t vs ssize_t) and potential edge cases where uname_ext_len could exceed what can be safely returned as ssize_t; this can indirectly affect whether the function might produce or signal conditions that lead to out-of-bounds accesses.\n\n(These symbols are the minimal additional definitions/implementations required to determine whether any string/buffer accesses in get_rq_extended_uname_copy_z \u2014 including calls into library helpers \u2014 can access beyond the bounds of their pointer parameters in violation of the stated MISRA rule.)"
}