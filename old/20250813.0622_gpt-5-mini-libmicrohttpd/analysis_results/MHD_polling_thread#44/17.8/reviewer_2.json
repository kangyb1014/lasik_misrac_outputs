{
  "user_message": "An agent A claimed that the following MHD_polling_thread code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_polling_thread.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Inside MHD_select the value parameter 'millisec' (int32_t) is assigned: 'millisec = 0;'. Modifying a function parameter variable violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic const int MHD_TEST_ALLOW_SUSPEND_RESUME = 0x01;\nstatic const int MHD_OPTION_USE_POLL = 0x02;\nstatic const int MHD_OPTION_USE_EPOLL = 0x04;\nstatic void MHD_logf (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/357.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fprintf (f, \"\\n\");\n  fclose (f);\n}\nstatic void\nMHD_poll_probe (struct MHD_Daemon *daemon, int yes)\n{\n  MHD_logf (\"MHD_poll_probe: enter: daemon=%p, yes=%d, shutdown=%d\",\n            (void *) daemon, yes, (daemon ? daemon->shutdown : 0));\n  MHD_poll (daemon, yes);\n  MHD_logf (\"MHD_poll_probe: exit: daemon=%p, shutdown=%d\",\n            (void *) daemon, (daemon ? daemon->shutdown : 0));\n}\nstatic void\nMHD_epoll_probe (struct MHD_Daemon *daemon, int timeout)\n{\n  MHD_logf (\"MHD_epoll_probe: enter: daemon=%p, timeout=%d, shutdown=%d\",\n            (void *) daemon, timeout, (daemon ? daemon->shutdown : 0));\n  MHD_epoll (daemon, timeout);\n  MHD_logf (\"MHD_epoll_probe: exit: daemon=%p, shutdown=%d\",\n            (void *) daemon, (daemon ? daemon->shutdown : 0));\n}\nstatic void\nMHD_select_probe (struct MHD_Daemon *daemon, int32_t millisec)\n{\n  /* Log the value passed for millisec before calling MHD_select. This\n   * allows observers to see the parameter value as provided by the caller.\n   * The reported violation concerns modification of the parameter inside\n   * MHD_select; this probe records the input value and the control path. */\n  MHD_logf (\"MHD_select_probe: enter: daemon=%p, millisec=%ld, shutdown=%d\",\n            (void *) daemon, (long) millisec, (daemon ? daemon->shutdown : 0));\n  MHD_select (daemon, millisec);\n  MHD_logf (\"MHD_select_probe: exit: daemon=%p, millisec=%ld, shutdown=%d\",\n            (void *) daemon, (long) millisec, (daemon ? daemon->shutdown : 0));\n}\nstatic void MHD_thread_handle_ID_set_current_thread_ID_ (long *slot)\n{\n  if (slot)\n    *slot = (long) 1; /* set a dummy thread id */\n}\nstatic int MHD_D_IS_USING_POLL_ (struct MHD_Daemon *daemon)\n{\n  return (daemon && (daemon->options & MHD_OPTION_USE_POLL)) != 0;\n}\nstatic int MHD_D_IS_USING_EPOLL_ (struct MHD_Daemon *daemon)\n{\n  return (daemon && (daemon->options & MHD_OPTION_USE_EPOLL)) != 0;\n}\n\nstatic void MHD_poll (struct MHD_Daemon *daemon, int yes)\n{\n  (void) daemon; (void) yes;\n  /* no-op for compilation unit */\n}\nstatic void MHD_epoll (struct MHD_Daemon *daemon, int timeout)\n{\n  (void) daemon; (void) timeout;\n}\nstatic void MHD_select (struct MHD_Daemon *daemon, int32_t millisec)\n{\n  (void) daemon; (void) millisec;\n}\nstatic void MHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  (void) daemon;\n}\nstatic void resume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  (void) daemon;\n}\nstatic void close_all_connections (struct MHD_Daemon *daemon)\n{\n  (void) daemon;\n}\nstatic void *\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = (struct MHD_Daemon *) cls;\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n  MHD_logf (\"MHD_polling_thread: started: daemon=%p, tid=%ld\",\n            (void *) daemon, (long) daemon->tid);\n\n  while (! daemon->shutdown)\n  {\n    MHD_logf (\"MHD_polling_thread: loop start: daemon=%p, shutdown=%d\",\n              (void *) daemon, daemon->shutdown);\n\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll_probe (daemon, 1);\n    else if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll_probe (daemon, -1);\n    else\n      /* Use our probe wrapper around MHD_select so that callers can\n       * observe the value passed for millisec and the control path. */\n      MHD_select_probe (daemon, -1);\n\n    MHD_cleanup_connections (daemon);\n    MHD_logf (\"MHD_polling_thread: after cleanup: daemon=%p, shutdown=%d\",\n              (void *) daemon, daemon->shutdown);\n  }\n\n  /* Resume any pending-for-resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  MHD_logf (\"MHD_polling_thread: exiting: daemon=%p\", (void *) daemon);\n\n  return NULL;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 17.8 prohibits modifying a function\u2019s own parameters. In MHD_polling_thread the parameter cls is not modified \u2014 it is copied into a local pointer variable (struct MHD_Daemon *daemon = cls;), and the code modifies the object pointed-to (daemon->...), which is permitted. The alleged assignment millisec = 0 would be inside MHD_select; if MHD_select assigns to its own non\u2011pointer parameter millisec that would be a violation in MHD_select itself, not in MHD_polling_thread. Therefore the claim that MHD_polling_thread violates Rule 17.8 is false."
}