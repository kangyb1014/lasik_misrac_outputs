{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of update_directory:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function update_directory:\nstruct ResponseDataContext\n{\n  /**\n   * Response data string.\n   */\n  char *buf;\n\n  /**\n   * Number of bytes allocated for 'buf'.\n   */\n  size_t buf_len;\n\n  /**\n   * Current position where we append to 'buf'. Must be smaller or equal to 'buf_len'.\n   */\n  size_t off;\n\n}\n...\nstruct Language\n{\n  /**\n   * Directory name for the language.\n   */\n  const char *dirname;\n\n  /**\n   * Long name for humans.\n   */\n  const char *longname;\n\n}\n...\nstatic const struct Language languages[] = {\n  { \"no-lang\", \"No language specified\" },\n  { \"en\", \"English\" },\n  { \"de\", \"German\" },\n  { \"fr\", \"French\" },\n  { \"es\", \"Spanish\" },\n  { NULL, NULL },\n}\n...\nstatic const char *const categories[] = {\n  \"books\",\n  \"images\",\n  \"music\",\n  \"software\",\n  \"videos\",\n  \"other\",\n  NULL,\n}\n...\n#define INDEX_PAGE_HEADER \"<html>\\n<head><title>Welcome</title></head>\\n<body>\\n\"\"<h1>Upload</h1>\\n\"\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" action=\\\"/\\\">\\n\"\"<dl><dt>Content type:</dt><dd>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"books\\\">Book</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"images\\\">Image</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"music\\\">Music</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"software\\\">Software</input>\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"videos\\\">Videos</input>\\n\"\"<input type=\\\"radio\\\" name=\\\"category\\\" value=\\\"other\\\" checked>Other</input></dd>\"\"<dt>Language:</dt><dd>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"no-lang\\\" checked>none</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"en\\\">English</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"de\\\">German</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"fr\\\">French</input>\"\"<input type=\\\"radio\\\" name=\\\"language\\\" value=\\\"es\\\">Spanish</input></dd>\\n\"\"<dt>File:</dt><dd>\"\"<input type=\\\"file\\\" name=\\\"upload\\\"/></dd></dl>\"\"<input type=\\\"submit\\\" value=\\\"Send!\\\"/>\\n\"\"</form>\\n\"\"<h1>Download</h1>\\n\"\"<ol>\\n\"\n...\n#define INDEX_PAGE_FOOTER \"</ol>\\n</body>\\n</html>\"\n...\nstruct MHD_Response\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstruct MHD_Response *response;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The pointer is used to hold the mutable object returned by MHD_create_response_from_buffer_with_free_callback and is subsequently passed to functions that modify it (mark_as_html, MHD_add_response_header, update_cached_response). The API returns and expects a non-const struct MHD_Response *, so adding const would be incorrect. Therefore the declaration 'struct MHD_Response *response;' does not violate Rule 8.13."
}