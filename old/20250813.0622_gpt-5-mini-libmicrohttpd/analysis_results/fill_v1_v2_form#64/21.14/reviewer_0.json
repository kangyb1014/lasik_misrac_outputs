{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the assertion mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5))); memcmp is used to compare hdr->value (a null-terminated header string) with the string literal \"close\". This is effectively comparing null-terminated strings using memcmp (even though only 5 bytes are compared), which violates MISRA C 2023 Rule 21.14. A string comparison function (e.g. strcmp/strncmp or the existing case-insensitive helpers) should be used instead.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void log_append(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/518.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\nstatic void probe_session_state(const struct Session *session,\n                                const char *mime,\n                                size_t slen)\n{\n  if (session == NULL)\n  {\n    log_append(\"probe_session_state: session == NULL, mime=%s, slen=%zu\", mime ? mime : \"(null)\", slen);\n    return;\n  }\n\n  /* Use strnlen to avoid reading beyond intended bounds. Limit printed lengths. */\n  size_t v1_len = session->value_1 ? strnlen(session->value_1, 1024) : 0;\n  size_t v2_len = session->value_2 ? strnlen(session->value_2, 1024) : 0;\n\n  log_append(\"probe_session_state: session=%p, mime=%s, slen=%zu, value_1_len=%zu, value_2_len=%zu\",\n             (const void *) session,\n             mime ? mime : \"(null)\",\n             slen,\n             v1_len,\n             v2_len);\n\n  if (session->value_1)\n    log_append(\"probe_session_state: value_1=(%zu) '%.*s'\", v1_len, (int) v1_len, session->value_1);\n  else\n    log_append(\"probe_session_state: value_1=(null)\");\n\n  if (session->value_2)\n    log_append(\"probe_session_state: value_2=(%zu) '%.*s'\", v2_len, (int) v2_len, session->value_2);\n  else\n    log_append(\"probe_session_state: value_2=(null)\");\n}\nstatic void probe_memcmp_usage(const char *hdr_value,\n                               const char *literal,\n                               size_t n,\n                               int cmp_result)\n{\n  if (hdr_value == NULL || literal == NULL)\n  {\n    log_append(\"probe_memcmp_usage: hdr_value=%p, literal=%p, n=%zu, cmp_result=%d\",\n               (const void *) hdr_value,\n               (const void *) literal,\n               n,\n               cmp_result);\n    return;\n  }\n\n  /* Check if hdr_value has a NUL within the first n bytes. This is what makes memcmp inappropriate\n     for comparing null-terminated strings. */\n  size_t hdr_nulen = strnlen(hdr_value, n + 1);\n  int has_nul_within_n = (hdr_nulen < n) ? 1 : 0;\n\n  /* Also measure literal NUL (should normally be present within n for string literal). */\n  size_t lit_nulen = strnlen(literal, n + 1);\n  int lit_has_nul_within_n = (lit_nulen < n) ? 1 : 0;\n\n  log_append(\"probe_memcmp_usage: hdr_value=%p, literal=%p, n=%zu, cmp_result=%d\",\n             (const void *) hdr_value,\n             (const void *) literal,\n             n,\n             cmp_result);\n  log_append(\"probe_memcmp_usage: hdr_first_%zu='%.*s'\", n, (int) (hdr_nulen > n ? n : hdr_nulen), hdr_value);\n  log_append(\"probe_memcmp_usage: hdr_has_nul_within_n=%d, hdr_nulen=%zu\", has_nul_within_n, hdr_nulen);\n  log_append(\"probe_memcmp_usage: literal_first_%zu='%.*s'\", n, (int) (lit_nulen > n ? n : lit_nulen), literal);\n  log_append(\"probe_memcmp_usage: literal_has_nul_within_n=%d, lit_nulen=%zu\", lit_has_nul_within_n, lit_nulen);\n\n  if (has_nul_within_n || lit_has_nul_within_n)\n  {\n    log_append(\"probe_memcmp_usage: WARNING: a NUL was detected within the first %zu bytes; using memcmp may be comparing NUL-terminated strings.\", n);\n  }\n}\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Probe initial state */\n  /* Compute slen as original code does (before allocating reply) so we can log it). */\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  probe_session_state(session, mime, slen);\n\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n  {\n    log_append(\"fill_v1_v2_form: malloc failed for size %zu\", slen + 1);\n    return MHD_NO;\n  }\n\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n\n  /* Log reply content up to a reasonable limit */\n  size_t reply_show = strnlen(reply, 4096);\n  log_append(\"fill_v1_v2_form: reply_len=%zu, reply_preview='%.*s'\", reply_show, (int) reply_show, reply);\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    log_append(\"fill_v1_v2_form: MHD_create_response_from_buffer_with_free_callback returned NULL\");\n    return MHD_NO;\n  }\n\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    log_append(\"fill_v1_v2_form: Failed to set content encoding header: mime=%s\", mime ? mime : \"(null)\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  log_append(\"fill_v1_v2_form: queued response, ret=%d\", (int) ret);\n  MHD_destroy_response (response);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_v2_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings. The provided fill_v1_v2_form implementation contains no call to memcmp, so the function as shown cannot violate Rule 21.14. Agent A\u2019s scenario refers to an assertion that uses memcmp (mhd_assert(... 0 == memcmp(hdr->value, \"close\", 5) ...)), but that assertion is not present in the fill_v1_v2_form source you supplied \u2014 it would be a violation only if hdr->value is a null\u2011terminated string and memcmp is being used to compare it to a string literal. The supplied test/instrumentation also does not introduce or demonstrate any memcmp use in fill_v1_v2_form. Conclusion: the reported violation against fill_v1_v2_form is not correct. (Note: if memcmp is used elsewhere to compare NUL\u2011terminated strings, that usage would indeed violate Rule 21.14 and should be replaced by an appropriate string comparison such as strcmp/strncmp or a dedicated token comparison.)"
}