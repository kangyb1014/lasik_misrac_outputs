{
  "user_message": "An agent A claimed that the following fill_v1_v2_form code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of fill_v1_v2_form.\n```c\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the computed slen overflows or the session strings are not properly NUL-terminated, the malloc(slen + 1) allocation can be too small and the subsequent snprintf can write past the buffer. Example: if strlen(session->value_1) + strlen(session->value_2) + strlen(SECOND_PAGE) > SIZE_MAX - 1, the sum wraps (slen becomes small), malloc allocates a much smaller buffer, and snprintf(reply, slen + 1, SECOND_PAGE, session->value_1, session->value_2) then writes more bytes than allocated \u2014 causing an out\u2011of\u2011bounds access by the string handling (formatting) operation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  size_t len_page, len_v1, len_v2;\n  size_t alloc_size;\n  int snprintf_ret;\n  FILE *logf = NULL;\n\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  /* Probe: compute individual lengths first so we can log them. */\n  len_page = strlen (SECOND_PAGE);\n  len_v1 = strlen (session->value_1);\n  len_v2 = strlen (session->value_2);\n\n  /* Sum as in original code */\n  slen = len_page + len_v1 + len_v2;\n  alloc_size = slen + 1;\n\n  /* Open log file for append. If that fails, fall back to stderr. */\n  logf = fopen(\"/tmp/logs/519.txt\", \"a\");\n  if (NULL == logf)\n    logf = stderr;\n\n  fprintf (logf,\n           \"[fill_v1_v2_form] computed lengths: SECOND_PAGE=%zu, value_1=%zu, value_2=%zu, slen(sum)=%zu, alloc_size=%zu\\n\",\n           len_page, len_v1, len_v2, slen, alloc_size);\n  fprintf (logf,\n           \"[fill_v1_v2_form] pointers: session=%p, value_1=%p, value_2=%p\\n\",\n           (void *) session, (void *) session->value_1, (void *) session->value_2);\n\n  /* Heuristic detection of wrap-around: if the sum is smaller than any operand, a wrap likely occurred. */\n  if (slen < len_page || slen < len_v1 || slen < len_v2)\n  {\n    fprintf (logf,\n             \"[fill_v1_v2_form] WARNING: possible size_t overflow (wrap-around) detected when summing lengths.\\n\");\n  }\n\n  /* Original allocation (preserve behavior) */\n  reply = malloc (alloc_size);\n  fprintf (logf, \"[fill_v1_v2_form] malloc(%zu) returned %p\\n\", alloc_size, (void *) reply);\n  if (NULL == reply)\n  {\n    fprintf (logf, \"[fill_v1_v2_form] malloc failed, returning MHD_NO\\n\");\n    if (logf != stderr)\n      fclose (logf);\n    return MHD_NO;\n  }\n\n  /* Call snprintf as originally done and capture return for logging. */\n  snprintf_ret = snprintf (reply,\n                           alloc_size,\n                           SECOND_PAGE,\n                           session->value_1,\n                           session->value_2);\n\n  fprintf (logf, \"[fill_v1_v2_form] snprintf returned %d (bytes that would have been written, excluding NUL)\\n\", snprintf_ret);\n  if (snprintf_ret < 0)\n  {\n    fprintf (logf, \"[fill_v1_v2_form] snprintf reported encoding error (negative return)\\n\");\n  }\n  else if ((size_t) snprintf_ret >= alloc_size)\n  {\n    /* snprintf would have required more space than allocated. Log this as evidence. */\n    fprintf (logf, \"[fill_v1_v2_form] WARNING: snprintf would have written %d bytes, which is >= alloc_size (%zu). Potential out-of-bounds write.\\n\",\n             snprintf_ret, alloc_size);\n  }\n  else\n  {\n    fprintf (logf, \"[fill_v1_v2_form] snprintf wrote %d bytes within alloc_size %zu.\\n\",\n             snprintf_ret, alloc_size);\n  }\n\n  /* Log a small extract of the reply buffer (bounded to avoid large dumps). */\n  {\n    size_t dump_len = (alloc_size > 0) ? alloc_size - 1 : 0;\n    if (dump_len > 200)\n      dump_len = 200;\n    fprintf (logf, \"[fill_v1_v2_form] reply buffer (first %zu bytes):\\n\", dump_len);\n    if (dump_len > 0)\n    {\n      /* fwrite may read only allocated bytes; we limit to dump_len which is <= alloc_size-1 */\n      fwrite (reply, 1, dump_len, logf);\n      fprintf (logf, \"\\n\");\n    }\n  }\n\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  fprintf (logf, \"[fill_v1_v2_form] MHD_create_response_from_buffer_with_free_callback returned %p (slen=%zu)\\n\",\n           (void *) response, slen);\n  if (NULL == response)\n  {\n    fprintf (logf, \"[fill_v1_v2_form] MHD_create_response... failed, freeing reply and returning MHD_NO\\n\");\n    free (reply);\n    if (logf != stderr)\n      fclose (logf);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n    fprintf (logf, \"[fill_v1_v2_form] Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  fprintf (logf, \"[fill_v1_v2_form] MHD_queue_response returned %d\\n\", ret);\n  MHD_destroy_response (response);\n\n  if (logf != stderr)\n    fclose (logf);\n\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for fill_v1_v2_form. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The code calls strlen(session->value_1) and strlen(session->value_2) (functions from <string.h>) without any checks that the pointed objects are valid NUL-terminated strings or that the arithmetic on the resulting lengths cannot overflow. Under Rule 21.17 the use of string.h functions shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. If session->value_1 or session->value_2 are not properly NUL-terminated, the strlen calls themselves will read out-of-bounds (UB) and thus violate the rule. Independently, an attacker or malformed inputs could make the sum len_page + len_v1 + len_v2 overflow size_t; the wrapped slen leads to a too-small malloc(slen+1) and then snprintf can write more bytes than allocated \u2014 producing an out-of-bounds write (even though snprintf is not in <string.h>, the root cause is the unchecked use of strlen and unchecked size arithmetic). The test harness not producing logs does not refute the theoretical and practical risks in the code. To comply with MISRA C 2023 R21.17, the code must ensure the strings are properly bounded/NUL-terminated and must check for size_t overflow (e.g. detect sum overflow before malloc, or compute required size in a safe way, or use bounded functions and verify snprintf return value)."
}