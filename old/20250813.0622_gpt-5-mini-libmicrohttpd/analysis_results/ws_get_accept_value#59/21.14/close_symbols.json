{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}, 'SHA1Reset': {'callees': [], 'callers': ['ws_get_accept_value']}, 'SHA1Input': {'callees': ['SHA1ProcessMessageBlock'], 'callers': ['ws_get_accept_value']}, 'SHA1Result': {'callees': ['SHA1PadMessage'], 'callers': ['ws_get_accept_value']}, 'BASE64Encode': {'callees': [], 'callers': ['ws_get_accept_value']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "SHA1Reset",
    "SHA1Input",
    "SHA1Result",
    "SHA1ProcessMessageBlock",
    "SHA1PadMessage",
    "BASE64Encode",
    "WS_KEY_LEN",
    "WS_GUID_LEN",
    "WS_KEY_GUID_LEN",
    "WS_GUID",
    "SHA1HashSize",
    "struct SHA1Context",
    "strlen",
    "strncpy",
    "memcmp"
  ],
  "explanation": "For checking the MISRA rule about memcmp-on-null-terminated-strings you must inspect not only this function but any called code and the definitions that determine whether buffers are NUL-terminated or treated as strings:\n\n- SHA1Reset, SHA1Input, SHA1Result: Provide the implementations called from ws_get_accept_value. If any of these use memcmp to compare buffers that may be NUL-terminated strings, that would be a MISRA violation. SHA1Result is known to call SHA1PadMessage, so include it too.\n- SHA1ProcessMessageBlock, SHA1PadMessage: Indirect callees of the SHA1 routines. Their source must be checked for memcmp usage on string data.\n- BASE64Encode: Called by ws_get_accept_value; its implementation must be inspected for any memcmp usage on data that might be or be treated as null-terminated strings.\n- WS_KEY_LEN, WS_GUID_LEN, WS_KEY_GUID_LEN, WS_GUID: Macros/constants determine buffer sizes and whether the concatenated buffer (str) will include a terminating '\\0'. Whether WS_GUID is NUL-terminated and how the lengths are defined affects whether buffers passed to other routines are null-terminated strings (and thus whether a memcmp there would be comparing null-terminated strings).\n- SHA1HashSize: Size of the hash passed into BASE64Encode; ensures BASE64Encode is operating on binary data (unlikely a string) but must be known to decide if memcmp use would be on strings or binary blobs.\n- struct SHA1Context: The SHA1 context type may reveal how input length/termination is handled inside SHA1 functions.\n- strlen, strncpy: These standard functions are used to build the buffer passed into SHA1Input. Knowing exactly how they are used (and the values of the WS_* length macros) is necessary to determine whether the buffer is NUL-terminated and thus whether any downstream memcmp would be comparing null-terminated strings.\n- memcmp: The target of the MISRA rule. Provide the implementations/usages of memcmp found in the codebase (especially inside the above functions) so they can be examined to see if they are used to compare null-terminated strings.\n\nInclude the source (or prototypes) for each of the listed symbols so the next analyzer can determine whether any memcmp call compares NUL-terminated strings in this call chain."
}