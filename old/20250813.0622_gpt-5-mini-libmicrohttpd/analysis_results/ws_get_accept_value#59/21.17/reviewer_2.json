{
  "user_message": "An agent A claimed that the following ws_get_accept_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ws_get_accept_value.\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If 'key' points to a buffer that is not null-terminated within its allocated bounds (for example a caller-supplied char key[WS_KEY_LEN] filled with 24 non-zero bytes and no terminating '\\0'), the call to strlen(key) will scan past the buffer looking for a '\\0' and thus access memory beyond the object bounds. There is no prior guarantee in the function that 'key' is a null-terminated string of sufficient size, so this use of strlen can result in out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n  FILE *log = fopen(\"/tmp/logs/479.txt\", \"a\");\n  size_t i;\n\n  if (log)\n  {\n    fprintf(log, \"---- ws_get_accept_value entry ----\\n\");\n    fprintf(log, \"key ptr=%p, val ptr=%p\\n\", (const void *)key, (void *)val);\n  }\n\n  if (NULL == key)\n  {\n    if (log)\n    {\n      fprintf(log, \"key is NULL -> returning MHD_NO\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  /* Probe: dump the first WS_KEY_LEN bytes of the provided key buffer as hex\n     Note: we intentionally only read up to WS_KEY_LEN bytes to avoid reading\n     beyond the expected key buffer size. This is safe for a buffer that is\n     at least WS_KEY_LEN bytes long (the violation scenario uses such a buffer\n     but without a terminating '\\0'). */\n  if (log)\n  {\n    fprintf(log, \"dumping first %d bytes of key (hex):\", WS_KEY_LEN);\n    for (i = 0; i < (size_t)WS_KEY_LEN; ++i)\n    {\n      /* cast to unsigned to avoid sign-extension when printing */\n      fprintf(log, \" %02x\", (unsigned char) key[i]);\n    }\n    fprintf(log, \"\\n\");\n    fprintf(log, \"About to call strlen(key) (this will reproduce the reported behavior if key is not null-terminated)\\n\");\n    fflush(log);\n  }\n\n  /* Preserve original behavior: call strlen once as in the original code. */\n  if (WS_KEY_LEN != strlen (key))\n  {\n    if (log)\n    {\n      size_t observed = strlen(key); /* repeated only for logging in the failure case */\n      fprintf(log, \"strlen(key) returned %zu (expected %d) -> returning MHD_NO\\n\", observed, WS_KEY_LEN);\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  if (log)\n  {\n    fprintf(log, \"strlen(key) indicates key length == %d -> continuing\\n\", WS_KEY_LEN);\n    fflush(log);\n  }\n\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    if (log)\n    {\n      fprintf(log, \"malloc failed for str -> returning MHD_NO\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  if (log)\n  {\n    fprintf(log, \"malloc returned %p for str (size=%d)\\n\", (void *)str, WS_KEY_LEN + WS_GUID_LEN + 1);\n    fprintf(log, \"About to strncpy(str, key, WS_KEY_LEN + 1) -> this mirrors the original code and may read beyond the key object if the key is not null-terminated\\n\");\n    fflush(log);\n  }\n\n  strncpy (str, key, (WS_KEY_LEN + 1));\n\n  if (log)\n  {\n    /* Dump the portion of str we care about (safe within allocated bounds) */\n    fprintf(log, \"dumping str[0..%d) (hex):\", WS_KEY_LEN + WS_GUID_LEN + 1);\n    for (i = 0; i < (size_t)(WS_KEY_LEN + WS_GUID_LEN + 1); ++i)\n      fprintf(log, \" %02x\", (unsigned char) str[i]);\n    fprintf(log, \"\\n\");\n    fflush(log);\n  }\n\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n\n  if (log)\n  {\n    fprintf(log, \"after appending GUID, dumping first %d bytes used for SHA1 (hex):\", WS_KEY_GUID_LEN);\n    for (i = 0; i < (size_t)WS_KEY_GUID_LEN; ++i)\n      fprintf(log, \" %02x\", (unsigned char) str[i]);\n    fprintf(log, \"\\n\");\n    fflush(log);\n  }\n\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    if (log)\n    {\n      fprintf(log, \"SHA1Result failed -> freeing str and returning MHD_NO\\n\");\n      fclose(log);\n    }\n    free (str);\n    return MHD_NO;\n  }\n\n  if (log)\n  {\n    fprintf(log, \"SHA1Result succeeded, SHA1 hash (hex):\");\n    for (i = 0; i < (size_t)SHA1HashSize; ++i)\n      fprintf(log, \" %02x\", hash[i]);\n    fprintf(log, \"\\n\");\n    fflush(log);\n  }\n\n  free (str);\n\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    if (log)\n    {\n      fprintf(log, \"BASE64Encode failed (len == -1) -> returning MHD_NO\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  /* Log the base64 result pointer and length before null-terminating. */\n  if (log)\n  {\n    fprintf(log, \"BASE64Encode returned len=%zd, val ptr=%p\\n\", len, (void *)(*val));\n    if (NULL != *val && len >= 0)\n    {\n      fprintf(log, \"base64 bytes (hex) up to len:\");\n      for (i = 0; i < (size_t)len; ++i)\n        fprintf(log, \" %02x\", (unsigned char)(*val)[i]);\n      fprintf(log, \"\\n\");\n    }\n    fflush(log);\n  }\n\n  (*val)[len] = '\\0';\n\n  if (log)\n  {\n    fprintf(log, \"Final base64 string (printed safely up to len): \");\n    if (NULL != *val)\n    {\n      /* Print as ASCII but avoid relying on null-termination other than what we just set. */\n      for (i = 0; i < (size_t)len; ++i)\n        fputc((*val)[i], log);\n      fputc('\\n', log);\n    }\n    fprintf(log, \"Returning MHD_YES\\n\");\n    fclose(log);\n  }\n\n  return MHD_YES;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ws_get_accept_value. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Calling strlen(key) without any prior guarantee that key is a null\u2011terminated string can cause strlen to scan past the caller\u2019s object bounds (and therefore violate MISRA C 2023 Rule 21.17). In this function there is no size parameter or asserted contract shown that guarantees key contains a terminating '\\0' within its allocated storage, so the use of strlen is potentially out\u2011of\u2011bounds.\n\nAdditionally, even the subsequent strncpy(str, key, WS_KEY_LEN + 1) is unsafe in the same scenario: it will attempt to read WS_KEY_LEN+1 bytes from key and so can also access beyond key\u2019s bounds if key is not large enough or not NUL\u2011terminated. Any fix must bound reads (e.g. use a provided buffer length, use a bounded length function like strnlen with a known object size, or change the API to accept an explicit length) or document and enforce a precondition that key is NUL\u2011terminated and at least WS_KEY_LEN+1 bytes long. Without such guarantees the code violates Rule 21.17."
}