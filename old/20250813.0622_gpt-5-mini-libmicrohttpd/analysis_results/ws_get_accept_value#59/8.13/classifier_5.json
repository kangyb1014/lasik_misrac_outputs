{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of ws_get_accept_value:\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ws_get_accept_value:\nstruct SHA1Context\n{\n  uint32_t intermediate_hash[SHA1HashSize / 4];\n  uint32_t length_low;\n  uint32_t length_high;\n  int_least16_t message_block_index;\n  unsigned char message_block[64];\n  int computed;\n  int corrupted;\n}\n...\n#define SHA1HashSize 20\n...\nstatic enum SHA1_RESULT\nSHA1Reset (struct SHA1Context *context)\n{\n  if (! context)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  context->length_low = 0;\n  context->length_high = 0;\n  context->message_block_index = 0;\n  context->intermediate_hash[0] = 0x67452301;\n  context->intermediate_hash[1] = 0xEFCDAB89;\n  context->intermediate_hash[2] = 0x98BADCFE;\n  context->intermediate_hash[3] = 0x10325476;\n  context->intermediate_hash[4] = 0xC3D2E1F0;\n  context->computed = 0;\n  context->corrupted = 0;\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Input (struct SHA1Context *context, const unsigned char *message_array,\n           unsigned length)\n{\n  if (! length)\n  {\n    return SHA1_RESULT_SUCCESS;\n  }\n  if (! context || ! message_array)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->computed)\n  {\n    context->corrupted = 1;\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  while (length-- && ! context->corrupted)\n  {\n    context->message_block[context->message_block_index++]\n      = (*message_array & 0xFF);\n    context->length_low += 8;\n    if (context->length_low == 0)\n    {\n      context->length_high++;\n      if (context->length_high == 0)\n      {\n        context->corrupted = 1;\n      }\n    }\n    if (context->message_block_index == 64)\n    {\n      SHA1ProcessMessageBlock (context);\n    }\n    message_array++;\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic enum SHA1_RESULT\nSHA1Result (struct SHA1Context *context, unsigned char\n            Message_Digest[SHA1HashSize])\n{\n  int i;\n\n  if (! context || ! Message_Digest)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (! context->computed)\n  {\n    SHA1PadMessage (context);\n    for (i = 0; i < 64; ++i)\n    {\n      context->message_block[i] = 0;\n    }\n    context->length_low = 0;\n    context->length_high = 0;\n    context->computed = 1;\n  }\n  for (i = 0; i < SHA1HashSize; ++i)\n  {\n    Message_Digest[i]\n      = (unsigned char) (context->intermediate_hash[i >> 2]\n                         >> 8 * (3 - (i & 0x03)));\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n...\nstatic ssize_t\nBASE64Encode (const void *in, size_t len, char **output)\n{\n#define FILLCHAR '='\n  const char *cvt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    \"abcdefghijklmnopqrstuvwxyz\"\n                    \"0123456789+/\";\n  const char *data = in;\n  char *opt;\n  ssize_t ret;\n  size_t i;\n  char c;\n  ret = 0;\n\n  opt = malloc (2 + (len * 4 / 3) + 8);\n  if (NULL == opt)\n  {\n    return -1;\n  }\n  for (i = 0; i < len; ++i)\n  {\n    c = (data[i] >> 2) & 0x3F;\n    opt[ret++] = cvt[(int) c];\n    c = (data[i] << 4) & 0x3F;\n    if (++i < len)\n    {\n      c = (char) (c | ((data[i] >> 4) & 0x0F));\n    }\n    opt[ret++] = cvt[(int) c];\n    if (i < len)\n    {\n      c = (char) (c | ((data[i] << 2) & 0x3F));\n      if (++i < len)\n      {\n        c = (char) (c | ((data[i] >> 6) & 0x03));\n      }\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      ++i;\n      opt[ret++] = FILLCHAR;\n    }\n    if (i < len)\n    {\n      c = data[i] & 0x3F;\n      opt[ret++] = cvt[(int) c];\n    }\n    else\n    {\n      opt[ret++] = FILLCHAR;\n    }\n  }\n  *output = opt;\n  return ret;\n}\n...\n#define WS_GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n...\n#define WS_KEY_LEN 24\n...\n#define WS_GUID_LEN 36\n...\n#define WS_KEY_GUID_LEN ((WS_KEY_LEN)+(WS_GUID_LEN))\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nconst char *data = in;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: 'in' is declared as 'const void *' and 'data' is declared as 'const char *', so the pointer points to a const-qualified type. (A violating scenario would be if the code used a non-const pointer, e.g. 'char *data = in;'.)"
}