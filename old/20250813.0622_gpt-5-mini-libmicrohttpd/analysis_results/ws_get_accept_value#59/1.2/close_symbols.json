{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  if ( (NULL == key) || (WS_KEY_LEN != strlen (key)))\n  {\n    return MHD_NO;\n  }\n  str = malloc (WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    return MHD_NO;\n  }\n  strncpy (str, key, (WS_KEY_LEN + 1));\n  strncpy (str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN + 1);\n  SHA1Reset (&ctx);\n  SHA1Input (&ctx, (const unsigned char *) str, WS_KEY_GUID_LEN);\n  if (SHA1_RESULT_SUCCESS != SHA1Result (&ctx, hash))\n  {\n    free (str);\n    return MHD_NO;\n  }\n  free (str);\n  len = BASE64Encode (hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    return MHD_NO;\n  }\n  (*val)[len] = '\\0';\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}, 'SHA1Reset': {'callees': [], 'callers': ['ws_get_accept_value']}, 'SHA1Input': {'callees': ['SHA1ProcessMessageBlock'], 'callers': ['ws_get_accept_value']}, 'SHA1Result': {'callees': ['SHA1PadMessage'], 'callers': ['ws_get_accept_value']}, 'BASE64Encode': {'callees': [], 'callers': ['ws_get_accept_value']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ssize_t",
    "enum MHD_Result",
    "MHD_NO",
    "MHD_YES",
    "WS_KEY_LEN",
    "WS_GUID_LEN",
    "WS_KEY_GUID_LEN",
    "WS_GUID",
    "SHA1Context",
    "SHA1HashSize",
    "SHA1Reset (prototype/definition)",
    "SHA1Input (prototype/definition)",
    "SHA1Result (prototype/definition)",
    "BASE64Encode (prototype/definition)",
    "malloc (prototype)",
    "strlen (prototype)",
    "strncpy (prototype)",
    "free (prototype)"
  ],
  "explanation": "For checking whether the function uses compiler language extensions you must inspect any types, macros or function declarations that could themselves be implemented with extensions (attributes, GCC/clang keywords, non\u2011standard types, asm, typeof, statement expressions, etc.). Brief rationale for each symbol:\n\n- ssize_t: non\u2011standard/POSIX type whose presence or typedef could be a compiler/library extension; BASE64Encode also returns ssize_t so its definition matters.\n- enum MHD_Result: the enum type may be defined with compiler attributes or extension syntax; needed to see if its declaration uses extensions.\n- MHD_NO / MHD_YES: macro/enum constants that may expand to extension constructs (attributes, casts, asm) or be defined via non\u2011portable macros.\n- WS_KEY_LEN, WS_GUID_LEN, WS_KEY_GUID_LEN: macros controlling buffer sizes; macros can be defined using extension constructs (e.g. sizeof tricks, typeof, compound literals) so their definitions must be checked.\n- WS_GUID: macro string appended to the key \u2014 its definition could use non\u2011standard character/encoding macros or extension syntax.\n- SHA1Context: structure type used on stack; its definition could include bit\u2011fields or compiler extensions (packed, aligned, __attribute__, anonymous structs/unions) that violate the rule.\n- SHA1HashSize: macro or constant used for array size; check if its definition uses extensions (VLA, typeof, non\u2011standard constant expressions).\n- SHA1Reset / SHA1Input / SHA1Result (prototypes/definitions): these APIs may be declared with compiler\u2011specific function attributes (e.g. __attribute__((noreturn)), calling\u2011convention attributes, inline/asm, variadic macros, or use non\u2011standard parameter types). SHA1Input in particular calls other internal functions \u2014 inspect declaration for extensions.\n- BASE64Encode (prototype/definition): returns ssize_t and is used to allocate/produce the output; its prototype or implementation might use non\u2011standard attributes, calling conventions, or types.\n- malloc / strlen / strncpy / free (prototypes): standard library functions are normally not extensions, but their declarations in the project headers (or any wrappers/macros used in place of them) must be confirmed to not use compiler extensions.\n\nProvide these symbol definitions to the next agent so it can detect any use of compiler\u2011specific extensions (keywords, attributes, non\u2011standard types, inline asm, statement expressions, typeof, designated initializers with extension syntax, etc.) that would violate the MISRA rule."
}