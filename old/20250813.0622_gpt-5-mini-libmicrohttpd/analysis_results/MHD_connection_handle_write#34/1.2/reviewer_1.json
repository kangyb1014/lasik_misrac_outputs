{
  "user_message": "An agent A claimed that the following MHD_connection_handle_write code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_write.\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro uses BUILTIN_NOT_REACHED which is not a standard C identifier and is typically implemented as a compiler-specific builtin (for example mapping to GCC/Clang __builtin_unreachable). This is a language extension, so Rule 1.2 is violated.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef ssize_t ss;\nstruct MHD_RP_Props { int send_reply_body; int chunked; };\nstruct MHD_RP\n{\n  size_t rsp_write_position;\n  struct MHD_Response *response;\n  struct MHD_RP_Props props;\n  void *resp_iov;\n  int resp_sender;\n};\nstatic const ssize_t MHD_ERR_AGAIN_ = -11;\nstatic inline size_t MHD_STATICSTR_LEN_(const char *s)\n{\n  return s ? strlen(s) : 0;\n}\nstatic const char HTTP_100_CONTINUE[] = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\";\nextern int MHD_run_tls_handshake_ (struct MHD_Connection *connection);\nextern void CONNECTION_CLOSE_ERROR (struct MHD_Connection *connection, void *arg);\nextern void mhd_assert (int cond);\nextern void MHD_PANIC (const char *msg);\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/272.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc('\\n', f);\n  fclose (f);\n}\n\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n\n  /* Log entry and core state. Note: avoid accessing fields that may not exist\n     in all build configurations (e.g. TLS-specific fields). */\n  mhd_probe_log (\"ENTER MHD_connection_handle_write: state=%d suspended=%d write_send=%zu write_append=%zu rsp_write_position=%zu url=%s\",\n                 (int) connection->state,\n                 (int) connection->suspended,\n                 (size_t) connection->write_buffer_send_offset,\n                 (size_t) connection->write_buffer_append_offset,\n                 (size_t) connection->rp.rsp_write_position,\n                 (connection->rq.url ? connection->rq.url : \"(null)\"));\n\n  if (connection->suspended)\n  {\n    mhd_probe_log (\"EXIT: suspended = true, returning immediately (state=%d)\", (int) connection->state);\n    return;\n  }\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      mhd_probe_log (\"TLS handshake needed: tls_state=%d\", (int) connection->tls_state);\n      if (! MHD_run_tls_handshake_ (connection))\n      {\n        mhd_probe_log (\"TLS handshake not completed, returning (tls_state=%d)\", (int) connection->tls_state);\n        return;\n      }\n      mhd_probe_log (\"TLS handshake completed, continuing (tls_state=%d)\", (int) connection->tls_state);\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_probe_log (\"ASSERTION PATH: reached mhd_assert(0) for header/initial states, state=%d\", (int) connection->state);\n    mhd_assert (0);\n    mhd_probe_log (\"RETURN after mhd_assert(0) for state=%d\", (int) connection->state);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE[connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_(HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          1);\n    mhd_probe_log (\"CONTINUE_SENDING: sent attempt ret=%zd continue_offset=%zu\",\n                   (ssize_t) ret,\n                   connection->continue_message_write_offset);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n      {\n        mhd_probe_log (\"CONTINUE_SENDING: would block (MHD_ERR_AGAIN_), returning\");\n        return;\n      }\n      mhd_probe_log (\"CONTINUE_SENDING: error ret=%zd, closing connection, url=%s\",\n                     (ssize_t) ret,\n                     (connection->rq.url ? connection->rq.url : \"(null)\"));\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    mhd_probe_log (\"CONTINUE_SENDING: progress continue_message_write_offset=%zu\", connection->continue_message_write_offset);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_probe_log (\"ASSERTION PATH: reached mhd_assert(0) for body/footer/fullreq states, state=%d\", (int) connection->state);\n    mhd_assert (0);\n    mhd_probe_log (\"RETURN after mhd_assert(0) for state=%d\", (int) connection->state);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_probe_log (\"ASSERTION PATH: reached mhd_assert(0) for START_REPLY state=%d\", (int) connection->state);\n    mhd_assert (0);\n    mhd_probe_log (\"RETURN after mhd_assert(0) for START_REPLY state=%d\", (int) connection->state);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n\n      mhd_probe_log (\"HEADERS_SENDING: wb_ready=%zu resp_total=%zu resp_data_size=%zu send_reply_body=%d chunked=%d rsp_write_position=%zu\",\n                     wb_ready,\n                     (size_t) resp->total_size,\n                     (size_t) resp->data_size,\n                     (int) connection->rp.props.send_reply_body,\n                     (int) connection->rp.props.chunked,\n                     (size_t) connection->rp.rsp_write_position);\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer[connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      0,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n        mhd_probe_log (\"HEADERS_SENDING: called send_hdr_and_body (with body), ret=%zd\", (ssize_t) ret);\n      }\n      else\n      {\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer[connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      0,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) || (! connection->rp.props.send_reply_body)));\n        mhd_probe_log (\"HEADERS_SENDING: called send_hdr_and_body (no body), ret=%zd\", (ssize_t) ret);\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          mhd_probe_log (\"HEADERS_SENDING: would block (MHD_ERR_AGAIN_), returning\");\n          return;\n        }\n        mhd_probe_log (\"HEADERS_SENDING: error ret=%zd, closing connection, url=%s\",\n                       (ssize_t) ret,\n                       (connection->rq.url ? connection->rq.url : \"(null)\"));\n        CONNECTION_CLOSE_ERROR (connection, NULL);\n        return;\n      }\n      if (((size_t) ret) > wb_ready)\n      {\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n        mhd_probe_log (\"HEADERS_SENDING: sent headers + body fragment, send_offset=%zu rsp_write_position=%zu\",\n                       connection->write_buffer_send_offset,\n                       connection->rp.rsp_write_position);\n      }\n      else\n      {\n        connection->write_buffer_send_offset += (size_t) ret;\n        mhd_probe_log (\"HEADERS_SENDING: sent headers only, send_offset=%zu\", connection->write_buffer_send_offset);\n      }\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n      {\n        mhd_probe_log (\"HEADERS_SENDING: state changed during send, new state=%d, returning\", (int) connection->state);\n        return;\n      }\n      check_write_done (connection, MHD_CONNECTION_HEADERS_SENT);\n      mhd_probe_log (\"HEADERS_SENDING: check_write_done returned, state now=%d\", (int) connection->state);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    mhd_probe_log (\"HEADERS_SENT: nothing to do, returning\");\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    mhd_probe_log (\"NORMAL_BODY_READY: rsp_write_position=%zu response_total=%zu\",\n                   (size_t) connection->rp.rsp_write_position,\n                   (size_t) connection->rp.response->total_size);\n    if (connection->rp.rsp_write_position < connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n      if (NULL == response)\n      {\n        mhd_probe_log (\"NORMAL_BODY_READY: no response, returning\");\n        return;\n      }\n\n      if (try_ready_normal_body (connection) == 0)\n      {\n        mhd_probe_log (\"NORMAL_BODY_READY: try_ready_normal_body returned MHD_NO, returning\");\n        return;\n      }\n\n      /* For simplicity, handle only the basic data send case (no sendfile/iovec). */\n      data_write_offset = connection->rp.rsp_write_position - response->data_start;\n      if (data_write_offset > (uint64_t) SIZE_MAX)\n      {\n        mhd_probe_log (\"NORMAL_BODY_READY: Data offset exceeds limit, panic condition triggered\");\n        MHD_PANIC (\"Data offset exceeds limit.\\n\");\n      }\n      ret = MHD_send_data_ (connection,\n                            &response->data[(size_t) data_write_offset],\n                            response->data_size - (size_t) data_write_offset,\n                            1);\n      mhd_probe_log (\"NORMAL_BODY_READY: send_data attempt ret=%zd data_write_offset=%zu\",\n                     (ssize_t) ret,\n                     (size_t) data_write_offset);\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n        {\n          mhd_probe_log (\"NORMAL_BODY_READY: would block (MHD_ERR_AGAIN_), returning\");\n          return;\n        }\n        mhd_probe_log (\"NORMAL_BODY_READY: error ret=%zd, closing connection, url=%s\",\n                       (ssize_t) ret,\n                       (connection->rq.url ? connection->rq.url : \"(null)\"));\n        CONNECTION_CLOSE_ERROR (connection, NULL);\n        return;\n      }\n\n      /* Update counters and activity */\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n\n      if (MHD_CONNECTION_NORMAL_BODY_READY != connection->state)\n      {\n        mhd_probe_log (\"NORMAL_BODY_READY: state changed during send, new state=%d, returning\", (int) connection->state);\n        return;\n      }\n\n      check_write_done (connection, connection->state);\n      return;\n    }\n    mhd_probe_log (\"NORMAL_BODY_READY: nothing to send, returning\");\n    return;\n  default:\n    mhd_probe_log (\"Unhandled state %d in MHD_connection_handle_write, returning\", connection->state);\n    return;\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not supported by the provided code. The MHD_connection_handle_write function as shown contains no explicit references to compiler-specific builtins such as __builtin_unreachable or to any identifier named BUILTIN_NOT_REACHED. The function uses standard preprocessor conditionals, macros and typedefs (ssize_t, uint64_t) and calls to project-specific macros/functions (mhd_assert, MHD_PANIC, etc.), but the definitions of those macros are not shown. MISRA C 2023 Rule 1.2 flags actual use of documented compiler language extensions; you cannot conclude a violation without evidence that one of the used macros expands to a non\u2011standard compiler builtin. The agent\u2019s scenario assumes a macro maps to a compiler extension (BUILTIN_NOT_REACHED/__builtin_unreachable) but provides no definition or build evidence for that mapping. The provided test code also did not demonstrate the use of a compiler extension (it failed to compile), so it does not substantiate the claim. Therefore the report is not correct."
}