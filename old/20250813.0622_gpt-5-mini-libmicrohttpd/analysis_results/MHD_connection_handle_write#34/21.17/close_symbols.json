{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'connection_close_error': {'callees': ['MHD_DLOG', 'MHD_connection_close_'], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'transmit_error_response_len', 'handle_recv_no_space', 'call_connection_handler', 'process_request_body', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'str_conn_error_': {'callees': [], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write']}, 'check_write_done': {'callees': [], 'callers': ['MHD_connection_handle_write']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'try_ready_normal_body': {'callees': ['MHD_connection_alloc_memory_', '__builtin_unreachable', 'connection_close_error', 'MHD_connection_close_'], 'callers': ['MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_send_sendfile_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}, 'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (full definition, especially: state, suspended, tls_state, continue_message_write_offset, write_buffer, write_buffer_send_offset, write_buffer_append_offset, rp, rq, keepalive, daemon)",
    "struct MHD_Response (full definition: data, data_size, data_start, total_size, crc, data_iov, mutex)",
    "connection->rp (type/layout) including fields: response, rsp_write_position, resp_sender, resp_iov, props.send_reply_body, props.chunked",
    "MHD_send_data_ (prototype and detailed semantics/contract: parameters interpreting buffer+length, return values, partial write behavior)",
    "MHD_send_hdr_and_body_ (prototype and semantics: how wb_ready and ret are interpreted, meaning of ret > wb_ready)",
    "MHD_send_iovec_ (prototype and semantics: how many bytes may be written and how iov entries are interpreted)",
    "MHD_send_sendfile_ (prototype and semantics)",
    "try_ready_normal_body (prototype and side effects: whether it alters rp.response, rp.resp_iov, rp.resp_sender, rsp_write_position or unlocks mutex; return values like MHD_NO)",
    "check_write_done (prototype and side effects: possible changes to connection->state and offsets)",
    "CONNECTION_CLOSE_ERROR macro and MHD_connection_close_ (effects on buffers/pointers and invariants when called)",
    "HTTP_100_CONTINUE (array) and MHD_STATICSTR_LEN_ macro (length of that static string)",
    "MHD_ERR_AGAIN_ constant",
    "MHD_resp_sender_sendfile constant (value used to detect sendfile path)",
    "MHD_mutex_lock_chk_ and MHD_mutex_unlock_chk_ (semantics affecting concurrent access to response fields)",
    "mhd_assert macro (semantics: whether it can be disabled / its runtime effect)",
    "SIZE_MAX and MHD_PANIC (used in data offset overflow check)"
  ],
  "explanation": "For checking MISRA C rule about out\u2011of\u2011bounds string/byte accesses you must reason about every array/index/length used and any function that reads/writes buffers or changes those indices. The target function indexes and takes addresses of: HTTP_100_CONTINUE[offset], connection->write_buffer[offset], and response->data[(size_t)data_write_offset]; it updates and relies on offsets: continue_message_write_offset, write_buffer_send_offset, write_buffer_append_offset, rp.rsp_write_position, response->data_start/data_size/total_size. Therefore you need: \n\n- struct MHD_Connection (full definition): to know the types, buffer (write_buffer) capacity, and invariants on send/append offsets and how/where they are constrained.\n  Reason: the function computes addresses & lengths from connection fields; proving no out\u2011of\u2011bounds access requires the buffer size and invariants on send/append offsets.\n\n- struct MHD_Response (full definition): to know data pointer layout and the meaning/ranges of data_size, data_start and total_size, plus whether data_iov or crc alter accesses.\n  Reason: response->data is indexed; data_size/data_start/total_size determine valid ranges for &response->data[data_write_offset] and thus potential OOB.\n\n- connection->rp structure (layout and props): to know rsp_write_position, resp_sender, resp_iov and props.send_reply_body/props.chunked semantics.\n  Reason: these fields control which send path is taken and how rsp_write_position is computed/updated; needed to bound indices.\n\n- MHD_send_data_ prototype and semantics: how many bytes are written for a given request, and the meaning of its return values (partial writes, negative error codes such as MHD_ERR_AGAIN_).\n  Reason: the code assumes ret is number of bytes actually sent and uses it to advance offsets; to check bounds you must know that ret cannot exceed the requested length and how errors are reported.\n\n- MHD_send_hdr_and_body_ prototype/semantics: it is called with header buffer size (wb_ready) and body pointer/length; the function treats a return ret > wb_ready specially (header + some body bytes sent). \n  Reason: the target code relies on that contract to update write offsets and rp.rsp_write_position; misinterpretation could lead to incorrect offset updates and OOB.\n\n- MHD_send_iovec_ and MHD_send_sendfile_ prototypes/semantics: how many bytes they can write and how they relate to resp_iov/resp_sender.\n  Reason: these routines are alternate send paths used for response bodies; their write semantics determine valid updates to rsp_write_position and ensure no OOB indexing of response data.\n\n- try_ready_normal_body prototype and side effects: whether it mutates response/rp fields (e.g., populates resp_iov, changes resp_sender, changes rsp_write_position) or unlocks mutex and when it returns MHD_NO.\n  Reason: the function is called before choosing send method; it can change the data source or state which affects subsequent indexing; you must know its guarantees to bound accesses.\n\n- check_write_done prototype/side effects: it can change connection->state and may affect offsets or trigger further side effects.\n  Reason: control flow (and whether offsets are expected to be valid after the call) depends on its behavior.\n\n- CONNECTION_CLOSE_ERROR macro and MHD_connection_close_ semantics: closing/freeing buffers or invalidating pointers.\n  Reason: the function calls this on errors; to ensure no accidental use-after-free or further accesses beyond bounds you must know what resources are freed/invalidated.\n\n- HTTP_100_CONTINUE array and MHD_STATICSTR_LEN_ macro: the actual length of the static continue message.\n  Reason: the code indexes HTTP_100_CONTINUE using continue_message_write_offset and subtracts that offset from the length when calling send; you must know the real length to check OOB.\n\n- MHD_ERR_AGAIN_ constant: to understand non\u2011fatal return handling.\n  Reason: errors cause early returns; distinguishing transient from fatal errors affects whether offsets are advanced and whether further sends may cause OOB.\n\n- MHD_resp_sender_sendfile constant: to understand the branch that selects sendfile path.\n  Reason: selecting the sendfile branch changes which buffers/indexing are relevant.\n\n- MHD_mutex_lock_chk_ and MHD_mutex_unlock_chk_ semantics: to reason about concurrent modifications of response fields while they are read.\n  Reason: the function locks/unlocks around accessing response when crc present; concurrent mutation could change sizes and cause OOB if not synchronized.\n\n- mhd_assert macro behavior: whether assertions are compiled out in release builds or abort at runtime.\n  Reason: many checks in the code are expressed as mhd_assert; to rely on them for safety proof you must know if they are enforced or omitted.\n\n- SIZE_MAX and MHD_PANIC: the overflow check uses these.\n  Reason: to validate the check preventing data_write_offset > SIZE_MAX and subsequent cast to size_t; understand if that suffices to avoid OOB.\n\nIn short: you need the concrete struct layouts and buffer size constants, plus the precise contracts (prototypes and return semantics) of all send/prepare functions and the helpers that can mutate the response or offsets. With those symbols you can trace each index/length expression and determine whether any string/byte accesses can exceed their object bounds."
}