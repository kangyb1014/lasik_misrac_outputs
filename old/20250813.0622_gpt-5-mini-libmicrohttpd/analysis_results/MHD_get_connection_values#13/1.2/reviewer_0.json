{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function declaration uses the macro _MHD_EXTERN which expands to __attribute__((visibility(\"default\"))) extern. The GCC-style __attribute__((...)) syntax is a compiler-specific language extension (documented in GCC/clang docs), so the code violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_logf(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/104.txt\", \"a\");\n  if (f == NULL)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fputc('\\n', f);\n  fclose(f);\n}\n\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  probe_logf(\"ENTER MHD_get_connection_values: connection=%p kind=%u iterator=%p iterator_cls=%p\",\n             (void *)connection,\n             (unsigned int)kind,\n             (void *)iterator,\n             iterator_cls);\n\n  if (NULL == connection)\n  {\n    probe_logf(\"connection is NULL -> returning -1\");\n    return -1;\n  }\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    probe_logf(\"loop header: pos=%p pos->kind=%u header=%s value=%s\",\n               (void *)pos,\n               (unsigned int)pos->kind,\n               (pos->header ? pos->header : \"(null)\"),\n               (pos->value ? pos->value : \"(null)\"));\n\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      probe_logf(\"header matched: incremented ret to %d\", ret);\n      if (NULL != iterator)\n      {\n        probe_logf(\"calling iterator %p for pos=%p\", (void *)iterator, (void *)pos);\n        int iterator_result = iterator (iterator_cls,\n                                       pos->kind,\n                                       pos->header,\n                                       pos->value);\n        probe_logf(\"iterator returned %d\", iterator_result);\n        if (MHD_NO == iterator_result)\n        {\n          probe_logf(\"iterator requested early stop -> returning %d\", ret);\n          return ret;\n        }\n      }\n    }\n  }\n  probe_logf(\"EXIT MHD_get_connection_values: returning %d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_get_connection_values. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim depends entirely on what _MHD_EXTERN expands to. MISRA C 2023 Rule 1.2 forbids use of compiler language extensions (e.g. GCC/Clang __attribute__((...))) unless you can show they are not used. The snippet shown only contains the macro identifier _MHD_EXTERN \u2014 it does not show its definition. If _MHD_EXTERN is defined (in a header) as something like __attribute__((visibility(\"default\"))) extern then that is a documented GCC/Clang language extension and would violate Rule 1.2. If, however, _MHD_EXTERN expands to a plain extern or to nothing on the compiler in use, then the function declaration is standard C and there is no Rule 1.2 violation. The provided test code and empty log do not prove the macro expansion. Therefore the report as stated is not conclusively correct: it may be correct if the macro actually expands to GCC attributes, but you must inspect the macro definition in the included headers (or the build macros) to determine whether a compiler-specific attribute is being used."
}