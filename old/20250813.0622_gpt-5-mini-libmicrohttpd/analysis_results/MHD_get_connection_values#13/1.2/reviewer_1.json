{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The macro _MHD_EXTERN expands to the GCC-specific attribute syntax __attribute__((visibility(\"default\"))) (i.e. #define _MHD_EXTERN __attribute__((visibility(\"default\")))extern). The __attribute__((...)) visibility specifier is a compiler-specific language extension (documented as such by GCC), so this use violates MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void probe_log(const char *fmt, ...)\n{\n  FILE *f;\n  va_list ap;\n  /* try to create directory if missing; ignore errors */\n  (void)mkdir(\"/tmp/logs\", 0777);\n  f = fopen(\"/tmp/logs/104.txt\", \"a\");\n  if (NULL == f)\n    return;\n\n  {\n    time_t t = time(NULL);\n    struct tm tm_buf;\n    struct tm *tm_p = localtime_r(&t, &tm_buf);\n    if (tm_p != NULL)\n    {\n      fprintf(f, \"%04d-%02d-%02d %02d:%02d:%02d \", tm_p->tm_year + 1900, tm_p->tm_mon + 1,\n              tm_p->tm_mday, tm_p->tm_hour, tm_p->tm_min, tm_p->tm_sec);\n    }\n    fprintf(f, \"pid=%ld: \", (long)getpid());\n  }\n\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  va_end(ap);\n  fprintf(f, \"\\n\");\n  fclose(f);\n}\n\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  probe_log(\"Enter MHD_get_connection_values: connection=%p kind=%d iterator=%p iterator_cls=%p\",\n            (void *)connection, (int)kind, (void *)iterator, iterator_cls);\n\n  if (NULL == connection)\n  {\n    probe_log(\"Null connection, returning -1\");\n    return -1;\n  }\n\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    probe_log(\"Loop header: pos=%p kind=0x%08x header_ptr=%p header_str=%s value_ptr=%p value_str=%s\",\n              (void *)pos,\n              (unsigned int)pos->kind,\n              (void *)pos->header,\n              (NULL != pos->header) ? pos->header : \"(null)\",\n              (void *)pos->value,\n              (NULL != pos->value) ? pos->value : \"(null)\");\n\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      probe_log(\"Header matched kind filter: pos->kind=0x%08x incremented ret=%d\",\n                (unsigned int)pos->kind, ret);\n\n      if (NULL != iterator)\n      {\n        /* Call the iterator exactly once, capture return value for logging and for original logic */\n        int itret = iterator (iterator_cls,\n                              pos->kind,\n                              pos->header,\n                              pos->value);\n\n        probe_log(\"Iterator called for header %p returned=%d\", (void *)pos, itret);\n\n        if (MHD_NO == itret)\n        {\n          probe_log(\"Iterator requested stop, returning ret=%d\", ret);\n          return ret;\n        }\n      }\n    }\n  }\n\n  probe_log(\"Exit MHD_get_connection_values returning ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_get_connection_values. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct under the stated scenario. MISRA C 2023 Rule 1.2 prohibits the use of compiler language extensions. The token _MHD_EXTERN in the presented code is a macro; if that macro expands to GCC's __attribute__((visibility(\"default\"))) (or any other compiler-specific __attribute__ form), that is a documented GCC language extension and therefore a breach of Rule 1.2. The mere use of a macro name does not hide the violation \u2014 the expansion matters. To be definitive you should inspect the macro definition; if it expands to the GCC attribute (or any other non\u2011standard extension) then the reported violation is correct. If instead _MHD_EXTERN expands to plain standard C (for example simply to extern) or is conditionally defined to nothing for compilers that do not support the attribute, then there is no Rule 1.2 violation."
}