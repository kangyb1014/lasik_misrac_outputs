{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the function pointer type MHD_KeyValueIterator and/or the struct members pos->header and pos->value are declared as non-const pointers (for example: typedef int (*MHD_KeyValueIterator)(void *cls, enum MHD_ValueKind kind, char *header, char *value); and struct MHD_HTTP_Req_Header { char *header; char *value; ... };), then Rule 8.13 is violated. The header/value pointers (and possibly iterator_cls if the iterator does not modify the pointed-to object) should be declared pointing to const-qualified types (const char * and/or const void *) whenever the objects are not modified by the iterator.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_log(const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/107.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(f, fmt, ap);\n  fprintf(f, \"\\n\");\n  va_end(ap);\n  fclose(f);\n}\n\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  mhd_log(\"MHD_get_connection_values ENTRY: connection=%p kind=%d iterator=%p iterator_cls=%p\",\n          (void *)connection, (int)kind, (void *)iterator, (void *)iterator_cls);\n\n  if (NULL == connection)\n  {\n    mhd_log(\"MHD_get_connection_values: connection is NULL -> returning -1\");\n    return -1;\n  }\n  ret = 0;\n  mhd_log(\"MHD_get_connection_values: start iteration, initial ret=%d, headers_received=%p\",\n          ret, (void *)connection->rq.headers_received);\n\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    /* Log pointer and member state for each header node */\n    mhd_log(\"loop: pos=%p pos->kind=%d pos->header=%p pos->value=%p\",\n            (void *)pos, (int)pos->kind, (void *)pos->header, (void *)pos->value);\n\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      mhd_log(\"match: pos=%p matched kind mask, incremented ret=%d\", (void *)pos, ret);\n\n      if (NULL != iterator)\n      {\n        mhd_log(\"about to call iterator: iterator=%p iterator_cls=%p pos->kind=%d pos->header=%p pos->value=%p\",\n                (void *)iterator, (void *)iterator_cls, (int)pos->kind,\n                (void *)pos->header, (void *)pos->value);\n\n        /* Call iterator and capture its return for logging, preserving original behavior. */\n        int it_ret = iterator (iterator_cls, pos->kind, pos->header, pos->value);\n\n        mhd_log(\"iterator returned: %d (compared to MHD_NO=%d)\", it_ret, (int)MHD_NO);\n\n        if (MHD_NO == it_ret)\n        {\n          mhd_log(\"iterator requested stop -> returning ret=%d\", ret);\n          return ret;\n        }\n      }\n    }\n  }\n\n  mhd_log(\"MHD_get_connection_values EXIT: returning ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_get_connection_values. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is essentially correct: the shown function uses non-const pointer types where const could/should be used, so it (or the surrounding API) can violate MISRA C 2023 Rule 8.13. Concretely:\n\n- MHD_get_connection_values takes struct MHD_Connection *connection but only reads through that pointer. If the function does not modify the pointed-to structure, the parameter should be declared const struct MHD_Connection *connection. That is a direct application of Rule 8.13.\n\n- The code reads pos->header and pos->value and passes them to the iterator but does not modify them itself. If the strings are not intended to be modified by the iterator, the members should be declared const char * and the iterator prototype should accept const char * for header/value. Likewise iterator_cls should be const void * if it is not modified by the iterator.\n\n- Whether a MISRA violation actually exists for a given build depends on the declarations elsewhere in the project. If MHD_KeyValueIterator and struct MHD_HTTP_Req_Header members are already declared with non-const pointer types (as Agent A\u2019s scenario assumes), then Rule 8.13 is violated because the pointers are not const-qualified even though they could be. If those types are already declared as const-qualified, there is no violation.\n\n- Note: changing types to add const may be an ABI/API change; it must be applied consistently (function prototype, typedefs, struct definitions, and all callers) to avoid incompatibilities.\n\nRecommendation: audit the declarations of MHD_KeyValueIterator, struct MHD_HTTP_Req_Header, and MHD_get_connection_values\u2019 prototype. If none of the called code/modifiers need to write through those pointers, change the declarations to use const (e.g. const struct MHD_Connection *, const char * header/value, const void * iterator_cls and adjust the iterator typedef). This will bring the code into compliance with Rule 8.13 while preserving intent."
}