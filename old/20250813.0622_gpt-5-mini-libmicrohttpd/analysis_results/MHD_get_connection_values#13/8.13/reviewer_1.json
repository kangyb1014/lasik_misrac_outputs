{
  "user_message": "An agent A claimed that the following MHD_get_connection_values code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_values.\n```c\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      if ( (NULL != iterator) &&\n           (MHD_NO == iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)) )\n        return ret;\n    }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The loop variable 'pos' is declared as 'struct MHD_HTTP_Req_Header *pos' but is only used to read fields (pos->kind, pos->header, pos->value) while iterating connection->rq.headers_received. Per MISRA C 2023 Rule 8.13 it should point to a const-qualified type (e.g. 'const struct MHD_HTTP_Req_Header *pos') since the pointed-to object is not modified here. Thus the code fragment violates Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/107.txt\", \"a\");\n    if (NULL == f)\n    {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fputc('\\n', f);\n    fclose(f);\n}\n\n_MHD_EXTERN int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Req_Header *pos;\n\n  mhd_probe_log(\"MHD_get_connection_values: entry connection=%p kind=%d iterator=%p iterator_cls=%p\",\n                (void *)connection, (int)kind, (void *)iterator, iterator_cls);\n\n  if (NULL == connection)\n  {\n    mhd_probe_log(\"MHD_get_connection_values: connection is NULL, returning -1\");\n    return -1;\n  }\n  ret = 0;\n  mhd_probe_log(\"MHD_get_connection_values: initial ret=%d\", ret);\n\n  for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n  {\n    mhd_probe_log(\"iterating header: pos=%p pos->next=%p pos->kind=0x%08x header=%s value=%s\",\n                  (void *)pos,\n                  (void *)pos->next,\n                  (unsigned)pos->kind,\n                  (pos->header != NULL) ? pos->header : \"(null)\",\n                  (pos->value != NULL) ? pos->value : \"(null)\");\n\n    if (0 != (pos->kind & kind))\n    {\n      ret++;\n      mhd_probe_log(\"MHD_get_connection_values: kind matched (pos->kind & kind) != 0, ret incremented to %d\", ret);\n\n      if (NULL != iterator)\n      {\n        int iterator_result = iterator (iterator_cls,\n                                       pos->kind,\n                                       pos->header,\n                                       pos->value);\n        mhd_probe_log(\"MHD_get_connection_values: iterator called, result=%d\", iterator_result);\n        if (MHD_NO == iterator_result)\n        {\n          mhd_probe_log(\"MHD_get_connection_values: iterator returned MHD_NO, returning ret=%d\", ret);\n          return ret;\n        }\n      }\n    }\n  }\n\n  mhd_probe_log(\"MHD_get_connection_values: loop complete, returning ret=%d\", ret);\n  return ret;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for MHD_get_connection_values. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 R8.13 recommends that a pointer should point to a const-qualified type whenever it does not need to be used to modify the pointed-to object. In MHD_get_connection_values the loop variable pos is only used for reading (pos->kind, pos->header, pos->value) and for advancing the traversal (pos = pos->next). Declaring pos as const struct MHD_HTTP_Req_Header *pos would be appropriate and does not break the code: assigning the non-const connection->rq.headers_received (struct MHD_HTTP_Req_Header *) to a const-qualified pointer is allowed, and reading pos->next yields a struct MHD_HTTP_Req_Header * value that can again be assigned to the const-qualified pos. There is no observable write through pos in this function, so the original declaration without const violates R8.13."
}