{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pre_send_setopt",
    "post_send_setopt",
    "struct MHD_Connection",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "struct MHD_Daemon",
    "daemon->options",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT",
    "gnutls_record_send",
    "GNUTLS_E_AGAIN",
    "GNUTLS_E_INTERRUPTED",
    "GNUTLS_E_ENCRYPTION_FAILED",
    "GNUTLS_E_INVALID_SESSION",
    "GNUTLS_E_COMPRESSION_FAILED",
    "GNUTLS_E_EXPIRED",
    "GNUTLS_E_HASH_FAILED",
    "GNUTLS_E_PUSH_ERROR",
    "GNUTLS_E_INTERNAL_ERROR",
    "GNUTLS_E_CRYPTODEV_IOCTL_ERROR",
    "GNUTLS_E_CRYPTODEV_DEVICE_ERROR",
    "GNUTLS_E_PREMATURE_TERMINATION",
    "GNUTLS_E_UNEXPECTED_PACKET_LENGTH",
    "GNUTLS_E_MEMORY_ERROR",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_TLS_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_BADF_",
    "SSIZE_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MHD_send4_",
    "MHD_USE_MSG_MORE",
    "MSG_MORE",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EBADF_",
    "EPOLL_SUPPORT",
    "enum MHD_EpollState",
    "MHD_EPOLL_STATE_WRITE_READY",
    "connection->epoll_state",
    "ssize_t",
    "MHD_DLOG"
  ],
  "explanation": "For a correct dead-code (MISRA) analysis we must know all compile-time enables, control-flow predicates, called functions and any symbols that could introduce observable side-effects or remove code paths. Brief reasons by symbol:\n\n- pre_send_setopt: external function called inside both TLS and plaintext branches; must know if it has observable side effects (I/O, state changes, logging) before deciding its call is removable.\n- post_send_setopt: same as above for the late-path call; its side effects (and internal calls like MHD_DLOG) determine whether that post-call is dead.\n- struct MHD_Connection: definition and member types are needed to verify which fields (socket_fd, state, daemon, tls_session, epoll_state) influence control flow and whether accesses have side effects.\n- MHD_socket: type of socket_fd; needed to understand comparisons with MHD_INVALID_SOCKET and underlying semantics.\n- MHD_INVALID_SOCKET: sentinel value used in an early-return check; whether the check can ever be true/false matters for dead-code determination.\n- MHD_CONNECTION_CLOSED: connection state constant used in early-return; required to decide reachability of subsequent code.\n- struct MHD_Daemon: to understand daemon->options layout and possible side effects or constness.\n- daemon->options: runtime option word tested for TLS enable; its possible values affect whether TLS code is live.\n- MHD_USE_TLS: option bit tested; needed to determine runtime selection of TLS branch.\n- HTTPS_SUPPORT: compile-time macro gating the entire TLS code path; if undefined the whole TLS branch is compile-time dead \u2014 must be known.\n- gnutls_record_send: external TLS send function; its behavior (side effects, return semantics) determines whether calls and following error-handling are necessary.\n- GNUTLS_E_* error macros (listed): the specific GNUTLS error codes compared against gnutls_record_send return value drive the many return branches inside the TLS branch; their presence/values and whether they can occur affect whether the associated return statements are reachable/necessary.\n- MHD_ERR_* return macros (listed): these are the observable return values emitted by this function; to decide whether particular return statements are removable we must know their semantics and whether callers observe them.\n- SSIZE_MAX: upper limit used to cap buffer_size; affects branches that modify buffer_size and push_data \u2014 needed to verify whether the cap logic can execute.\n- MHD_SCKT_SEND_MAX_SIZE_: non-TLS send-size cap for plaintext path; its value affects the plaintext branch and whether the cap and subsequent logic can be dead.\n- MHD_send4_: the low-level send wrapper used on plaintext path; it may have side effects and distinct error behavior (in conjunction with MHD_SCKT_* macros) that determine whether the calling code is required.\n- MHD_USE_MSG_MORE and MSG_MORE: compile-time/OS constants that change arguments to MHD_send4_; presence or absence changes which call variant is used \u2014 impacts dead-code reasoning for the corresponding conditional.\n- MHD_socket_get_error_: used to obtain errno-like value after send failure; semantics determine which error branches are reachable.\n- MHD_SCKT_ERR_IS_* macros and MHD_SCKT_* error constants (listed): used to test socket error classes; whether these macros can be true for particular platforms influences reachability of many error-handling return statements.\n- EPOLL_SUPPORT: compile-time macro that controls code that manipulates epoll_state; if undefined those epoll-state clearings are compile-time dead \u2014 must be known.\n- enum MHD_EpollState and MHD_EPOLL_STATE_WRITE_READY: enum and constant used in bit-clearing operations under EPOLL_SUPPORT; needed to judge whether those writes are observable and thus not dead.\n- connection->epoll_state: the actual field mutated under EPOLL_SUPPORT; its type and aliasing rules determine whether the write is observable.\n- ssize_t: return type of function and used for comparison with buffer_size; required to reason about numeric range, casts and whether some branches (like buffer_size > SSIZE_MAX) are ever true.\n- MHD_DLOG: used by post_send_setopt (and potentially others); if post_send_setopt only logs, then removing its call might change only logging behavior (still observable) \u2014 include to judge side effects.\n\nIn short, these symbols cover compile-time guards, runtime option bits, the connection/daemon fields used in decisions, all called functions that may have side effects, the error codes tested, and the return values produced. Without their definitions/values you cannot soundly decide whether specific operations and branches in MHD_send_data_ are removable (dead) under MISRA."
}