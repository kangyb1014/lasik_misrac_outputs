{
  "user_message": "An agent A claimed that the following MHD_send_data_ code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_data_.\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code fragment assigns to the value parameters 'buffer_size' and 'push_data' (buffer_size = SSIZE_MAX; push_data = false;). Both are non-pointer function parameters and are being modified inside the function, which violates MISRA C 2023 Rule 17.8 (a function parameter should not be modified).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_probe_log(const char *fmt, ...)\n{\n    FILE *f = fopen(\"/tmp/logs/341.txt\", \"a\");\n    if (NULL == f)\n        return;\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(f, fmt, ap);\n    va_end(ap);\n    fprintf(f, \"\\n\");\n    fclose(f);\n}\n\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  /* Entry probe */\n  mhd_probe_log(\"ENTRY: MHD_send_data_: connection=%p socket_fd=%d buffer=%p buffer_size=%zu push_data=%d\",\n                (void *)connection, (int)s, (const void *)buffer, buffer_size, push_data ? 1 : 0);\n  mhd_probe_log(\"ENTRY: tls_conn=%d\", tls_conn ? 1 : 0);\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    mhd_probe_log(\"EARLY RETURN: invalid socket or connection closed: socket=%d state=%d\", (int)s, connection->state);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    mhd_probe_log(\"CONDITION: buffer_size (%zu) > SSIZE_MAX (%ld) -> will cap and set push_data=false\", buffer_size, (long)SSIZE_MAX);\n    /* Log original values before modification */\n    mhd_probe_log(\"BEFORE MODIFY: buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n\n    /* Log new values after modification */\n    mhd_probe_log(\"AFTER MODIFY: buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    mhd_probe_log(\"TLS PATH: calling gnutls_record_send with buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    mhd_probe_log(\"TLS RETURN: gnutls_record_send ret=%zd\", (ssize_t)ret);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      mhd_probe_log(\"TLS EARLY RETURN: E_AGAIN\");\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n    {\n      mhd_probe_log(\"TLS EARLY RETURN: INTERRUPTED\");\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n    {\n      mhd_probe_log(\"TLS ERROR: GNUTLS error classification -> returning TLS error\");\n      return MHD_ERR_TLS_;\n    }\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n    {\n      mhd_probe_log(\"TLS ERROR: GNUTLS pipe/internal/crypto device error -> returning PIPE\");\n      return MHD_ERR_PIPE_;\n    }\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n    {\n      mhd_probe_log(\"TLS ERROR: GNUTLS premature termination -> returning CONNRESET\");\n      return MHD_ERR_CONNRESET_;\n    }\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n    {\n      mhd_probe_log(\"TLS ERROR: GNUTLS unexpected packet length -> returning CONNRESET\");\n      return MHD_ERR_CONNRESET_;\n    }\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n    {\n      mhd_probe_log(\"TLS ERROR: GNUTLS memory error -> returning NOMEM\");\n      return MHD_ERR_NOMEM_;\n    }\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      mhd_probe_log(\"TLS ERROR: gnutls_record_send returned <0 -> NOTCONN\");\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n    mhd_probe_log(\"TLS PATH: HTTPS_SUPPORT not enabled -> ret set to NOTCONN\");\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      mhd_probe_log(\"CONDITION: buffer_size (%zu) > MHD_SCKT_SEND_MAX_SIZE_ (%zu) -> will cap and set push_data=false\",\n                    buffer_size, (size_t)MHD_SCKT_SEND_MAX_SIZE_);\n      mhd_probe_log(\"BEFORE MODIFY (plaintext): buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n\n      mhd_probe_log(\"AFTER MODIFY (plaintext): buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    mhd_probe_log(\"PLAINTEXT PATH: calling MHD_send4_ with buffer_size=%zu push_data=%d\", buffer_size, push_data ? 1 : 0);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    mhd_probe_log(\"PLAINTEXT RETURN: MHD_send4_ returned ret=%zd\", (ssize_t)ret);\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n      mhd_probe_log(\"PLAINTEXT ERROR: send returned <0, socket error=%d\", err);\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        mhd_probe_log(\"PLAINTEXT EARLY RETURN: EAGAIN -> MHD_ERR_AGAIN_\");\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        mhd_probe_log(\"PLAINTEXT EARLY RETURN: EINTR -> MHD_ERR_AGAIN_\");\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: REMOTE DISCONNECT -> CONNRESET\");\n        return MHD_ERR_CONNRESET_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: EPIPE -> PIPE\");\n        return MHD_ERR_PIPE_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: EOPNOTSUPP -> OPNOTSUPP\");\n        return MHD_ERR_OPNOTSUPP_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: ENOTCONN -> NOTCONN\");\n        return MHD_ERR_NOTCONN_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: EINVAL -> INVAL\");\n        return MHD_ERR_INVAL_;\n      }\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: LOW RESOURCES -> NOMEM\");\n        return MHD_ERR_NOMEM_;\n      }\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      {\n        mhd_probe_log(\"PLAINTEXT ERROR: EBADF -> BADF\");\n        return MHD_ERR_BADF_;\n      }\n      /* Treat any other error as a hard error. */\n      mhd_probe_log(\"PLAINTEXT ERROR: other -> NOTCONN\");\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n  {\n    mhd_probe_log(\"POST SEND: calling post_send_setopt: push_data=%d buffer_size=%zu ret=%zd\",\n                  push_data ? 1 : 0, buffer_size, (ssize_t)ret);\n    post_send_setopt (connection, (! tls_conn), push_data);\n  }\n\n  mhd_probe_log(\"EXIT: MHD_send_data_ returning ret=%zd\", (ssize_t)ret);\n  return ret;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nENTRY: MHD_send_data_: connection=0x56543e6d6870 socket_fd=6 buffer=0x56543e6d6b50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x56543e6df500 socket_fd=7 buffer=0x56543e6d6b50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x56543e6d6b10 socket_fd=7 buffer=0x56543e6dff70 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=6 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=6 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=6 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=6 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=7 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc90000f50 socket_fd=7 buffer=0x7fbc900011e0 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc90000b70 socket_fd=9 buffer=0x7fbc90000e30 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=6 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_data=1\nPLAINTEXT RETURN: MHD_send4_ returned ret=125\nPOST SEND: calling post_send_setopt: push_data=1 buffer_size=125 ret=125\nEXIT: MHD_send_data_ returning ret=125\nENTRY: MHD_send_data_: connection=0x7fbc8c000b90 socket_fd=7 buffer=0x7fbc8c000e50 buffer_size=125 push_data=1\nENTRY: tls_conn=0\nPLAINTEXT PATH: calling MHD_send4_ with buffer_size=125 push_d\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 prohibits modifying non-pointer function parameters. In MHD_send_data_ the value parameters buffer_size and push_data are assigned to (e.g. buffer_size = SSIZE_MAX; push_data = false; and buffer_size = MHD_SCKT_SEND_MAX_SIZE_; push_data = false;), which is a direct violation of that rule. The provided runtime logs simply show executions where the conditions that trigger those assignments were not met; that does not change the fact that the source code contains assignments to non-pointer parameters and therefore breaches Rule 17.8."
}