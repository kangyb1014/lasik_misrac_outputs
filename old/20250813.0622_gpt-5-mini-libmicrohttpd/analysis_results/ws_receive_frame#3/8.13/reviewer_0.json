{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The parameter 'frame' is declared as 'unsigned char *frame' but is only read (indexed) in ws_receive_frame and never modified. Per MISRA C 2023 Rule 8.13 it should be a pointer to a const-qualified type (e.g. 'const unsigned char *frame'). Changing the signature to 'static unsigned char *ws_receive_frame(const unsigned char *frame, ssize_t *length, int *type)' would resolve the violation. (The other pointer parameters are modified and thus cannot be const-qualified.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nws_log (const char *fmt, ...)\n{\n  FILE *f = fopen(\"/tmp/logs/27.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', f);\n  fclose (f);\n}\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n\n  /* Entry log: pointer and basic info */\n  if (frame != NULL)\n  {\n    /* Guard reading frame[0] only if length > 0 */\n    if (length != NULL && *length > 0)\n    {\n      ws_log (\"ENTER ws_receive_frame: frame=%p, length_in=%zd, type_ptr=%p, first_byte=0x%02X\",\n              (void *) frame, *length, (void *) type, (unsigned int) frame[0]);\n    }\n    else\n    {\n      ws_log (\"ENTER ws_receive_frame: frame=%p, length_in=(invalid), type_ptr=%p\",\n              (void *) frame, (void *) type);\n    }\n  }\n  else\n  {\n    ws_log (\"ENTER ws_receive_frame: frame=NULL, length_in_ptr=%p, type_ptr=%p\",\n            (void *) length, (void *) type);\n  }\n\n  if (frame != NULL && length != NULL && *length > 0 && frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    ws_log (\"Branch: TEXT frame detected (frame[0]=0x%02X)\", (unsigned int) frame[0]);\n\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    ws_log (\"Initial mask byte=0x%02X, flength=0x%02X (%u)\", (unsigned int) mask, (unsigned int) flength, (unsigned int) flength);\n\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n      ws_log (\"Extended 16-bit length: idx_first_mask set to %u\", (unsigned int) idx_first_mask);\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n      ws_log (\"Extended 64-bit length: idx_first_mask set to %u\", (unsigned int) idx_first_mask);\n    }\n\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    if (*length < (ssize_t) idx_first_data)\n    {\n      ws_log (\"Invalid frame: total length (%zd) < idx_first_data (%u)\", *length, (unsigned int) idx_first_data);\n      return NULL;\n    }\n\n    data_length = (size_t) *length - idx_first_data;\n    ws_log (\"Computed idx_first_mask=%u, idx_first_data=%u, data_length=%zu\", (unsigned int) idx_first_mask, (unsigned int) idx_first_data, data_length);\n\n    /* capture mask bytes safely (guarding against out-of-bounds) */\n    if ((size_t) idx_first_mask + 4 <= (size_t) *length)\n    {\n      masks[0] = frame[idx_first_mask + 0];\n      masks[1] = frame[idx_first_mask + 1];\n      masks[2] = frame[idx_first_mask + 2];\n      masks[3] = frame[idx_first_mask + 3];\n      ws_log (\"Masks read: [%02X, %02X, %02X, %02X]\",\n              (unsigned int) masks[0], (unsigned int) masks[1], (unsigned int) masks[2], (unsigned int) masks[3]);\n    }\n    else\n    {\n      ws_log (\"Insufficient length to read masks: idx_first_mask=%u, total_length=%zd\", (unsigned int) idx_first_mask, *length);\n      return NULL;\n    }\n\n    msg = malloc (data_length + 1);\n    ws_log (\"malloc requested size=%zu, returned msg=%p\", data_length + 1, (void *) msg);\n    if (NULL != msg)\n    {\n      ws_log (\"Entering unmask loop: i starts at %u, loop end (exclusive) = %zd\", (unsigned int) idx_first_data, *length);\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        unsigned char orig = frame[i];\n        unsigned char unm = (unsigned char) (orig ^ masks[j % 4]);\n        msg[j] = unm;\n\n        /* Log a limited set of iterations to avoid excessive logging: first 32 and the final byte */\n        if (j < 32 || i == *length - 1)\n        {\n          ws_log (\"unmask iteration: i=%d, j=%d, frame[i]=0x%02X, mask=0x%02X, msg[j]=0x%02X\",\n                  i, j, (unsigned int) orig, (unsigned int) masks[j % 4], (unsigned int) msg[j]);\n        }\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n      ws_log (\"Unmask complete: final j=%d, new length=%zd, msg_ptr=%p\", j, *length, (void *) msg);\n    }\n    else\n    {\n      ws_log (\"malloc failed for data_length=%zu\", data_length);\n    }\n  }\n  else if (frame != NULL && length != NULL && *length > 0 && frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    ws_log (\"Branch: CONNECTION CLOSE frame detected (frame[0]=0x%02X)\", (unsigned int) frame[0]);\n  }\n  else\n  {\n    if (frame != NULL && length != NULL && *length > 0)\n    {\n      *type = frame[0] & 0x0F;\n      ws_log (\"Branch: Other frame. frame[0]=0x%02X, inferred type=%d\", (unsigned int) frame[0], *type);\n    }\n    else\n    {\n      ws_log (\"Branch: Other frame but invalid inputs (frame or length). Cannot infer type safely.\");\n    }\n  }\n\n  ws_log (\"EXIT ws_receive_frame: returning msg=%p, type_out=%d, length_out=%zd\", (void *) msg, (type != NULL) ? *type : -1, (length != NULL) ? *length : -1);\n  return msg;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ws_receive_frame. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the provided ws_receive_frame implementation the parameter frame is only read (indexed) and never used to modify the pointee object. MISRA C:2023 Rule 8.13 advises that a pointer should point to a const-qualified type whenever possible; therefore frame should be declared as const unsigned char *frame (or otherwise be const-qualified) unless there is an external reason that prevents changing the API (e.g. it must match an existing non-const prototype or be used via a function pointer expecting non-const). Agent A's suggested signature change (static unsigned char *ws_receive_frame(const unsigned char *frame, ssize_t *length, int *type)) would address the rule violation. If the function must remain API-compatible with callers expecting a non-const parameter, that constraint should be documented and the violation justified; otherwise update the signature and call sites to be const-correct."
}