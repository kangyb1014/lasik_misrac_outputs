{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:ws_receive_frame takes a non-const unsigned char *frame but only reads from frame. The frame parameter could (and should) be const unsigned char *frame; therefore the call msg = ws_receive_frame(buf, &got, &type); (and the function declaration) violates MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type whenever possible.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nws_probe_log(const unsigned char *frame,\n             ssize_t length,\n             int *type_ptr,\n             int type_valid,\n             unsigned char flength,\n             const unsigned char *masks,\n             unsigned char idx_first_mask,\n             unsigned char idx_first_data,\n             size_t data_length,\n             const unsigned char *msg,\n             const char *stage)\n{\n  FILE *f = fopen(\"/tmp/logs/27.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n\n  fprintf(f, \"[%s] frame=%p length=%zd type_ptr=%p flength=%u idx_first_mask=%u idx_first_data=%u data_length=%zu\\n\",\n          stage, (void *) frame, length, (void *) type_ptr, (unsigned) flength, (unsigned) idx_first_mask, (unsigned) idx_first_data, data_length);\n\n  if (frame != NULL)\n  {\n    /* print first two bytes of the frame if available (original code reads frame[0] and frame[1]) */\n    fprintf(f, \"[%s] frame[0]=0x%02X frame[1]=0x%02X\\n\", stage, (unsigned) frame[0], (unsigned) frame[1]);\n  }\n\n  if (masks != NULL)\n  {\n    fprintf(f, \"[%s] masks=%02X %02X %02X %02X\\n\", stage, masks[0], masks[1], masks[2], masks[3]);\n  }\n\n  if (msg != NULL)\n  {\n    fprintf(f, \"[%s] msg_ptr=%p first_bytes=\", stage, (void *) msg);\n    {\n      size_t limit = (data_length > 16U) ? 16U : data_length;\n      size_t k;\n      for (k = 0U; k < limit; ++k)\n      {\n        fprintf(f, \"%02X \", (unsigned) msg[k]);\n      }\n    }\n    fprintf(f, \"\\n\");\n  }\n\n  if (type_valid != 0 && type_ptr != NULL)\n  {\n    fprintf(f, \"[%s] *type=%d\\n\", stage, *type_ptr);\n  }\n  else\n  {\n    fprintf(f, \"[%s] *type=(invalid or not set)\\n\", stage);\n  }\n\n  fclose(f);\n}\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  /* Entry probe: do not assume *type is valid yet */\n  ws_probe_log(frame, *length, type, 0, 0U, NULL, 0U, 0U, 0U, NULL, \"entry\");\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n\n    /* Log after parsing flength and initial indices */\n    ws_probe_log(frame, *length, type, 1, flength, NULL, idx_first_mask, 0U, 0U, NULL, \"parsed_length_info\");\n\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n\n    /* Read masks (original logic preserved) */\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n\n    /* Log masks and computed data_length */\n    ws_probe_log(frame, *length, type, 1, flength, masks, idx_first_mask, idx_first_data, data_length, NULL, \"masks_computed\");\n\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n\n      /* Log the produced message (first bytes) and final length/type */\n      ws_probe_log(frame, *length, type, 1, flength, masks, idx_first_mask, idx_first_data, data_length, msg, \"message_unmasked\");\n    }\n    else\n    {\n      /* Log malloc failure */\n      ws_probe_log(frame, *length, type, 1, flength, masks, idx_first_mask, idx_first_data, data_length, NULL, \"malloc_failed\");\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    ws_probe_log(frame, *length, type, 1, 0U, NULL, 0U, 0U, 0U, NULL, \"close_frame\");\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n    ws_probe_log(frame, *length, type, 1, 0U, NULL, 0U, 0U, 0U, NULL, \"other_frame\");\n  }\n\n  /* Exit probe with final state */\n  ws_probe_log(frame, *length, type, 1, 0U, (msg != NULL) ? masks : NULL, 0U, 0U, (msg != NULL) ? (size_t) *length : 0U, msg, \"exit\");\n\n  return msg;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ws_receive_frame. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 8.13 says a pointer should point to a const-qualified type whenever possible. In the shown ws_receive_frame implementation the parameter frame is only read (frame[...] accesses) and never modified. Therefore the parameter should be declared as const unsigned char *frame (and corresponding call sites updated) to meet the rule. The probe/test code and empty log do not change the fact that the original declaration (unsigned char *frame) is not const-qualified while it could be, so this is a violation of Rule 8.13. (Note: if there is an API reason to intentionally allow modification, that should be documented; otherwise change the declaration to const.)"
}