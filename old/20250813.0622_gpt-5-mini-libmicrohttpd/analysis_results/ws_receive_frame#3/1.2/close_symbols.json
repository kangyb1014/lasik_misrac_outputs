{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "malloc",
    "NULL",
    "ssize_t",
    "size_t"
  ],
  "explanation": "To decide whether ws_receive_frame uses any language/compiler extensions you must inspect the external symbols it relies on (macros, typedefs, and functions) because those definitions might themselves use compiler extensions. Each listed symbol is required for that check:\n\n- WS_FIN: this macro/constant is combined with opcode macros using bitwise |. Its definition must be inspected to ensure it is a plain standard C macro/constant and not created with a compiler extension (e.g. nonstandard literals, attributes, or extension-specific constructs).\n\n- WS_OPCODE_TEXT_FRAME: as above, its definition must be checked for nonstandard constructs or extension-specific encoding.\n\n- WS_OPCODE_CON_CLOSE_FRAME: same rationale \u2014 the macro/constant definition could hide an extension.\n\n- malloc: the allocation call could be to a function declared with compiler-specific attributes or extensions (e.g. nonstandard linkage, builtins, or attribute syntax). Verify the prototype used in the translation unit (stdlib.h or a replacement) is standard C.\n\n- NULL: the macro expansion of NULL can differ (0, ((void*)0), etc.). Although standard C defines NULL, some projects or headers re-define it using compiler-specific constructs \u2014 check its definition for extensions.\n\n- ssize_t: this typedef is not part of standard C (it's POSIX). Its definition (typically in sys/types.h) should be checked to ensure it isn\u2019t provided via a compiler extension or nonstandard typedef mechanism.\n\n- size_t: ensure the typedef/prototype used is the standard size_t and not a project/compiler-specific redefinition that uses extensions.\n\nInspecting the definitions of these symbols (in the headers or translation-unit scope) lets an analyst determine whether any nonstandard/implementation-specific language extensions are being used that would violate the MISRA prohibition on language extensions."
}