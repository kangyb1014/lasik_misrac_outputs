{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The check for WS_OPCODE_CON_CLOSE_FRAME inside the final else is unreachable. ws_receive_frame only returns a non-NULL msg when frame[0] matches (WS_FIN | WS_OPCODE_TEXT_FRAME) (and only then *type is set to WS_OPCODE_TEXT_FRAME). For close or other opcodes ws_receive_frame leaves msg NULL and the caller immediately breaks on if (NULL == msg). Therefore, after that NULL check, type cannot be WS_OPCODE_CON_CLOSE_FRAME, so the nested if (type == WS_OPCODE_CON_CLOSE_FRAME) { free(msg); break; } can never be reached. This violates MISRA C 2023 Rule 2.1 (no unreachable code).\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void ws_log_probe(const char *stage,\n                         unsigned char *frame,\n                         ssize_t length,\n                         int type,\n                         unsigned char *msg,\n                         const char *extra)\n{\n  FILE *f = fopen(\"/tmp/logs/25.txt\", \"a\");\n  if (f == NULL)\n  {\n    return;\n  }\n  time_t t = time(NULL);\n  fprintf(f, \"[%ld] %s\\n\", (long)t, stage);\n  if (frame != NULL && length > 0)\n  {\n    fprintf(f, \"  frame[0]=0x%02X, length=%zd\\n\", (unsigned int)frame[0], length);\n  }\n  else\n  {\n    fprintf(f, \"  frame=NULL or length<=0 (length=%zd)\\n\", length);\n  }\n  fprintf(f, \"  type(before)=%d, msg=%p\\n\", type, (void *)msg);\n  if (extra != NULL)\n  {\n    fprintf(f, \"  note: %s\\n\", extra);\n  }\n  fprintf(f, \"\\n\");\n  fflush(f);\n  fclose(f);\n}\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  /* Log entry: start of function */\n  ws_log_probe(\"enter ws_receive_frame\", frame, (length != NULL) ? *length : -1, (type != NULL) ? *type : -1, NULL, \"start\");\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n\n    /* Capture masks bytes safely if within bounds */\n    if ((ssize_t)(idx_first_mask + 3) < *length)\n    {\n      masks[0] = frame[idx_first_mask + 0];\n      masks[1] = frame[idx_first_mask + 1];\n      masks[2] = frame[idx_first_mask + 2];\n      masks[3] = frame[idx_first_mask + 3];\n    }\n    else\n    {\n      masks[0] = masks[1] = masks[2] = masks[3] = 0;\n    }\n\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n\n      /* Log successful text-frame extraction */\n      ws_log_probe(\"text frame processed\", frame, *length, *type, msg, \"text payload extracted\");\n    }\n    else\n    {\n      /* Log allocation failure */\n      ws_log_probe(\"malloc failed for text frame\", frame, *length, *type, msg, \"malloc returned NULL\");\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n\n    /* Log close control frame event; msg remains NULL */\n    ws_log_probe(\"control close frame\", frame, (length != NULL) ? *length : -1, *type, msg, \"control close frame received; msg left NULL\");\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n\n    /* Log other opcodes */\n    ws_log_probe(\"other frame opcode\", frame, (length != NULL) ? *length : -1, *type, msg, \"non-text non-close opcode\");\n  }\n\n  /* Log exit state */\n  ws_log_probe(\"exit ws_receive_frame\", frame, (length != NULL) ? *length : -1, (type != NULL) ? *type : -1, msg, NULL);\n  return msg;\n}\n\n```\nThe test code was compiled successfully, but the test log is empty for ws_receive_frame. The test suite might not cover this function or the test code might be not suitable to print important information.\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. The ws_receive_frame function itself contains no provably unreachable statements: every branch (text-frame, close control frame, other opcode) can be selected at runtime depending on frame[0], so none of the branches in this function are syntactically or semantically unreachable in isolation. MISRA C 2023 Rule 2.1 forbids code that is provably unreachable in the project; proving a violation requires whole\u2011program evidence that a particular statement can never be executed. Agent A\u2019s argument depends on the behavior of an external caller (that allegedly always breaks on if (NULL == msg)), but that caller is not supplied and there is no proof that that break always occurs for all calls. Therefore you cannot conclude the code is unreachable from the provided function alone. The empty test log does not establish unreachable code either. If there is a genuine unreachable-code issue, it would need to be demonstrated by analyzing the actual caller(s) and the program\u2019s control flow to show a statement can never be executed."
}