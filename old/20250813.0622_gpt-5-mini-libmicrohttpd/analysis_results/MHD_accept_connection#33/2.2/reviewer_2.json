{
  "user_message": "An agent A claimed that the following MHD_accept_connection code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_accept_connection.\n```c\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:When compiled with HAVE_MESSAGES not defined, the #else branch yields the expression statement (void)0 which is executed but has no effect \u2014 removing it would not change program behaviour. Therefore that statement is dead code. (In builds with HAVE_MESSAGES defined the else branch is not compiled, but in the configuration where HAVE_MESSAGES is absent this fragment violates MISRA C 2023 Rule 2.2.)\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void\nmhd_probe_log (const char *fmt, ...)\n{\n  FILE *f = fopen (\"/tmp/logs/266.txt\", \"a\");\n  if (NULL == f)\n    return;\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (f, fmt, ap);\n  fprintf (f, \"\\n\");\n  va_end (ap);\n  fclose (f);\n}\n\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Log entry and key initial state */\n  mhd_probe_log (\"enter MHD_accept_connection: daemon=%p, listen_fd=%d, was_quiesced=%d, connections=%u, avoid_accept4=%d, use_accept4=%d\",\n                 (void *) daemon,\n                 (int) daemon->listen_fd,\n                 (int) daemon->was_quiesced,\n                 (unsigned) daemon->connections,\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n                 (int) daemon->avoid_accept4,\n#else\n                 0,\n#endif\n                 (int) use_accept4);\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n  {\n    mhd_probe_log (\"early return: invalid listen fd or quiesced (listen_fd=%d, was_quiesced=%d)\", (int) fd, (int) daemon->was_quiesced);\n    return MHD_NO;\n  }\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n    mhd_probe_log (\"accept4 succeeded: s=%d, addrlen=%d, sk_nonbl=%d, sk_spipe_supprs=%d, sk_cloexec=%d\",\n                   (int) s, (int) addrlen, (int) sk_nonbl, (int) sk_spipe_supprs, (int) sk_cloexec);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n    mhd_probe_log (\"accept succeeded: s=%d, addrlen=%d, sk_nonbl=%d, sk_spipe_supprs=%d, sk_cloexec=%d\",\n                   (int) s, (int) addrlen, (int) sk_nonbl, (int) sk_spipe_supprs, (int) sk_cloexec);\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n    {\n      mhd_probe_log (\"accept failed: err=EINVAL (shutdown race)\");\n      return MHD_NO;   /* can happen during shutdown */\n    }\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n    {\n      mhd_probe_log (\"accept failed: client disconnected before accept (err=%d)\", err);\n      return MHD_NO;   /* do not print error if client just disconnected early */\n    }\n#ifndef HAVE_MESSAGES\n    /* In the configuration without HAVE_MESSAGES the original code\n     * muted the error with an expression-statement (void)0. That was\n     * reported as dead code (it has no effect). We log here to make\n     * the control flow and state visible for analysis. */\n    mhd_probe_log (\"HAVE_MESSAGES not defined: would have logged: err=%d, strerr=%s\",\n                   err,\n                   MHD_socket_strerr_ (err));\n#else\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifndef HAVE_MESSAGES\n        /* original code contained MHD_DLOG here; absent HAVE_MESSAGES\n         * this branch was mute with (void)0. Log for evidence. */\n        mhd_probe_log (\"low resources at FIRST connection, connections=0; entering busy-wait warning path\");\n#else\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifndef HAVE_MESSAGES\n        mhd_probe_log (\"low resources: connections=%u, set daemon->at_limit=true\", (unsigned) daemon->connections);\n#else\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifndef HAVE_MESSAGES\n    mhd_probe_log (\"accepted socket has zero-length address; listen_is_unix=%d\", (int) daemon->listen_is_unix);\n#else\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifndef HAVE_MESSAGES\n    mhd_probe_log (\"accepted socket address larger than expected: addrlen=%d; treating as non-IP\", (int) addrlen);\n#else\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifndef HAVE_MESSAGES\n    /* Original code muted this with (void)0 to avoid compiler warnings.\n     * We log here to capture the control path and state when HAVE_MESSAGES\n     * is not defined (the reported dead-code scenario). */\n    mhd_probe_log (\"failed to set nonblocking on incoming connection socket: s=%d, sk_nonbl=%d, last_err=%s\",\n                   (int) s,\n                   (int) sk_nonbl,\n                   MHD_socket_last_strerr_ ());\n#else  /* HAVE_MESSAGES */\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifndef HAVE_MESSAGES\n    /* Replacing the mute (void)0 with a probe log for the non-HAVE_MESSAGES build. */\n    mhd_probe_log (\"failed to set noninheritable mode on socket: s=%d, sk_cloexec=%d\", (int) s, (int) sk_cloexec);\n#else  /* HAVE_MESSAGES */\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifndef HAVE_MESSAGES\n    mhd_probe_log (\"failed to suppress SIGPIPE on incoming connection socket: s=%d, last_err=%s, sk_spipe_supprs=%d\",\n                   (int) s,\n                   MHD_socket_last_strerr_ (),\n                   (int) sk_spipe_supprs);\n#else  /* HAVE_MESSAGES */\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  mhd_probe_log (\"adding connection: s=%d, addrlen=%d, sk_nonbl=%d, sk_spipe_supprs=%d, sk_non_ip=%d\",\n                 (int) s, (int) addrlen, (int) sk_nonbl, (int) sk_spipe_supprs, (int) sk_non_ip);\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  mhd_probe_log (\"exit MHD_accept_connection: returned MHD_YES for s=%d\", (int) s);\n  return MHD_YES;\n}\n\n```\nAfter executing all tests, we received the following output from the test code.\nFor this task, assume the following:\n- The test suite is exhaustive and has covered all edge cases.\n- There are no missing scenarios.\n- You must not include any caveats or question the test results.\n\nBased on this, analyze the output and validate the scenario accordingly.\n```\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection: daemon=0x5601bb624350, listen_fd=3, was_quiesced=0, connections=0, avoid_accept4=0, use_accept4=1\naccept4 succeeded: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_cloexec=1\nadding connection: s=5, addrlen=16, sk_nonbl=1, sk_spipe_supprs=0, sk_non_ip=0\nexit MHD_accept_connection: returned MHD_YES for s=5\nenter MHD_accept_connection:\n```\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. MISRA C 2023 Rule 2.2 prohibits dead code, defined as operations that are executed but whose removal would not affect program behaviour. The (void)0 expression-statements in the branches compiled when HAVE_MESSAGES is not defined are executed no-ops with no semantic effect; removing them would not change the program\u2019s observable behaviour (other than maybe timing), therefore they meet the definition of dead code. The test code/probe demonstrates the normal successful path, but the original (void)0 occurrences live in executed error/else branches and are still no-ops \u2014 so they violate Rule 2.2."
}