{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_dir_tell code that contains useful probe functions that print useful logs to a file \"/tmp/logs/275.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_dir_tell as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_dir_tell:\n```c\nlfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_tell(%p, %p)\", (void*)lfs, (void*)dir);\n\n    lfs_soff_t res = lfs_dir_tell_(lfs, dir);\n\n    LFS_TRACE(\"lfs_dir_tell -> %\"PRId32, res);\n    LFS_UNLOCK(lfs->cfg);\n    return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_tell:\nstatic lfs_soff_t lfs_dir_tell_(lfs_t *lfs, lfs_dir_t *dir) {\n    (void)lfs;\n    return dir->pos;\n}\n...\ntypedef struct lfs_dir {\n    struct lfs_dir *next;\n    uint16_t id;\n    uint8_t type;\n    lfs_mdir_t m;\n\n    lfs_off_t pos;\n    lfs_block_t head[2];\n} lfs_dir_t\n...\ntypedef struct lfs {\n    lfs_cache_t rcache;\n    lfs_cache_t pcache;\n\n    lfs_block_t root[2];\n    struct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    } *mlist;\n    uint32_t seed;\n\n    lfs_gstate_t gstate;\n    lfs_gstate_t gdisk;\n    lfs_gstate_t gdelta;\n\n    struct lfs_lookahead {\n        lfs_block_t start;\n        lfs_block_t size;\n        lfs_block_t next;\n        lfs_block_t ckpoint;\n        uint8_t *buffer;\n    } lookahead;\n\n    const struct lfs_config *cfg;\n    lfs_size_t block_count;\n    lfs_size_t name_max;\n    lfs_size_t file_max;\n    lfs_size_t attr_max;\n    lfs_size_t inline_max;\n\n#ifdef LFS_MIGRATE\n    struct lfs1 *lfs1;\n#endif\n} lfs_t\n</additional code>\nJudge whether the above lfs_dir_tell code violates the rule 8.13 or not.",
  "is_rule_violated": true,
  "scenario": "lfs_dir_tell takes non-const pointers (lfs_t *lfs, lfs_dir_t *dir) but does not modify the objects. The helper lfs_dir_tell_ only reads dir->pos and does not modify either object. Therefore the pointers could be const-qualified (const lfs_t * and const lfs_dir_t *). Not qualifying them as const violates MISRA C 2023 Rule 8.13.",
  "test_code": "#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n/*\n * Modified lfs_dir_tell with logging probes to demonstrate the violation scenario.\n * Preserves original logic: locks, delegates to lfs_dir_tell_, unlocks, and returns result.\n * Note: This function intentionally keeps the pointer parameters non-const to show\n * that they could have been const-qualified (they are only read), which is the\n * MISRA Rule 8.13 violation scenario.\n */\n\nlfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {\n    /* probe log file */\n    FILE *log = fopen(\"/tmp/logs/275.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"ENTER lfs_dir_tell: lfs=%p, dir=%p\\n\", (void*)lfs, (void*)dir);\n    }\n\n    int err = LFS_LOCK(lfs->cfg);\n    if (log) {\n        fprintf(log, \"After LFS_LOCK: err=%d\\n\", err);\n    }\n    if (err) {\n        if (log) {\n            fprintf(log, \"EARLY RETURN (lock failed): err=%d\\n\", err);\n            fclose(log);\n        }\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_dir_tell(%p, %p)\", (void*)lfs, (void*)dir);\n\n    /* delegate to the internal function that only reads dir->pos */\n    lfs_soff_t res = lfs_dir_tell_(lfs, dir);\n\n    if (log) {\n        /* print control path and state info showing that only reads occurred */\n        /* dir->pos is an offset type; print via PRId32 same as original tracing */\n        fprintf(log, \"lfs_dir_tell_: dir->pos (observed) = %"
}