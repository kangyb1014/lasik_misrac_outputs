{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_dir_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/254.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_dir_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_dir_open:\n```c\nint lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_open(%p, %p, \\\"%s\\\")\", (void*)lfs, (void*)dir, path);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));\n\n    err = lfs_dir_open_(lfs, dir, path);\n\n    LFS_TRACE(\"lfs_dir_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_open:\nstatic bool lfs_mlist_isopen(struct lfs_mlist *head,\n        struct lfs_mlist *node) {\n    for (struct lfs_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n...\nstatic int lfs_dir_open_(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n        return LFS_ERR_NOTDIR;\n    }\n\n    lfs_block_t pair[2];\n    if (lfs_tag_id(tag) == 0x3ff) {\n        // handle root dir separately\n        pair[0] = lfs->root[0];\n        pair[1] = lfs->root[1];\n    } else {\n        // get dir pair from parent\n        lfs_stag_t res = lfs_dir_get(lfs, &dir->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);\n        if (res < 0) {\n            return res;\n        }\n        lfs_pair_fromle32(pair);\n    }\n\n    // fetch first pair\n    int err = lfs_dir_fetch(lfs, &dir->m, pair);\n    if (err) {\n        return err;\n    }\n\n    // setup entry\n    dir->head[0] = dir->m.pair[0];\n    dir->head[1] = dir->m.pair[1];\n    dir->id = 0;\n    dir->pos = 0;\n\n    // add to list of mdirs\n    dir->type = LFS_TYPE_DIR;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)dir);\n\n    return 0;\n}\n...\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    // we reduce path to a single name if we can find it\n    const char *name = *path;\n\n    // default to root dir\n    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    // empty paths are not allowed\n    if (*name == '\\0') {\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        // skip slashes if we're a directory\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            name += strspn(name, \"/\");\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        // skip '.'\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            name += namelen;\n            goto nextname;\n        }\n\n        // error on unmatched '..', trying to go above root?\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            return LFS_ERR_INVAL;\n        }\n\n        // skip if matched by '..' in name\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                // noop\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        // found path\n        if (*name == '\\0') {\n            return tag;\n        }\n\n        // update what we've found so far\n        *path = name;\n\n        // only continue if we're a directory\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            return LFS_ERR_NOTDIR;\n        }\n\n        // grab the entry data\n        if (lfs_tag_id(tag) != 0x3ff) {\n            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),\n                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs_pair_fromle32(dir->tail);\n        }\n\n        // find entry matching name\n        while (true) {\n            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    LFS_MKTAG(0x780, 0, 0),\n                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),\n                    id,\n                    lfs_dir_find_match, &(struct lfs_dir_find_match){\n                        lfs, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        // to next name\n        name += namelen;\n    }\n}\n...\nstatic inline uint16_t lfs_tag_type3(lfs_tag_t tag) {\n    return (tag & 0x7ff00000) >> 20;\n}\n...\nstatic inline uint16_t lfs_tag_id(lfs_tag_t tag) {\n    return (tag & 0x000ffc00) >> 10;\n}\n...\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    return lfs_dir_getslice(lfs, dir,\n            gmask, gtag,\n            0, buffer, lfs_tag_size(gtag));\n}\n...\nstatic inline void lfs_pair_fromle32(lfs_block_t pair[2]) {\n    pair[0] = lfs_fromle32(pair[0]);\n    pair[1] = lfs_fromle32(pair[1]);\n}\n...\nstatic int lfs_dir_fetch(lfs_t *lfs,\n        lfs_mdir_t *dir, const lfs_block_t pair[2]) {\n    // note, mask=-1, tag=-1 can never match a tag since this\n    // pattern has the invalid bit set\n    return (int)lfs_dir_fetchmatch(lfs, dir, pair,\n            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);\n}\n...\nstatic void lfs_mlist_append(lfs_t *lfs, struct lfs_mlist *mlist) {\n    mlist->next = lfs->mlist;\n    lfs->mlist = mlist;\n}\n...\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\n#define LFS_ASSERT(test) assert(test)\n</additional code>\nJudge whether the above lfs_dir_open code violates the rule 21.14 or not.",
  "is_rule_violated": true,
  "scenario": "The code calls memcmp in lfs_dir_find to compare path name segments to the literal strings \".\" and \"..\" (e.g. memcmp(name, \".\", 1) and memcmp(name, \"..\", 2)). These memcmp calls are being used to compare null-terminated string segments and therefore violate MISRA C 2023 Rule 21.14 (the Standard Library function memcmp shall not be used to compare null terminated strings). A concrete violation occurs when a normal null-terminated path string is passed to lfs_dir_open and lfs_dir_find runs the logic that compares segments to \".\" or \"..\".",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\n/* Forward declarations/types assumed to exist in the project */\nstruct lfs_cfg { int dummy; };\ntypedef struct lfs_cfg lfs_cfg_t;\ntypedef struct lfs_t lfs_t;\ntypedef struct lfs_dir_t lfs_dir_t;\n\n/* Keep original locking/trace/assert macros as used in the project */\n\n/* Helper probe functions to log the control path and state for the violation scenario. */\nstatic void lfs_log_plain(const char *tag, const char *path, int err)\n{\n    FILE *f = fopen(\"/tmp/logs/254.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n    if (path == NULL) {\n        fprintf(f, \"%s: path=(null) err=%d\\n\", tag, err);\n    } else {\n        fprintf(f, \"%s: path=\\\"%s\\\" err=%d\\n\", tag, path, err);\n    }\n    fclose(f);\n}\n\n/* Detect and log dot-segments (this is a local, safe scanner that does not use memcmp).\n   It logs whether '.' or '..' segments exist in the incoming path, which are the\n   segments that cause lfs_dir_find to use memcmp in the original code. */\nstatic void lfs_log_dot_segments(const char *path)\n{\n    FILE *f = fopen(\"/tmp/logs/254.txt\", \"a\");\n    if (f == NULL) {\n        return;\n    }\n\n    fprintf(f, \"scan_dot_segments: path=\\\"%s\\\"\\n\", path ? path : \"(null)\");\n\n    if (path == NULL) {\n        fprintf(f, \"scan_dot_segments: path is null\\n\");\n        fclose(f);\n        return;\n    }\n\n    const char *p = path;\n    while (*p != '\\0') {\n        /* skip leading slashes */\n        while (*p == '/') {\n            p++;\n        }\n        if (*p == '\\0') {\n            break;\n        }\n        /* find segment length */\n        const char *seg = p;\n        size_t len = 0U;\n        while (p[len] != '/' && p[len] != '\\0') {\n            len++;\n        }\n\n        if (len == 1U && seg[0] == '.') {\n            fprintf(f, \"scan_dot_segments: found '.' segment at offset %td\\n\", seg - path);\n        } else if (len == 2U && seg[0] == '.' && seg[1] == '.') {\n            fprintf(f, \"scan_dot_segments: found '..' segment at offset %td\\n\", seg - path);\n        }\n\n        p = seg + len;\n    }\n\n    fclose(f);\n}\n\n/* Modified lfs_dir_open that preserves original logic but adds probes/logging.\n   This function intentionally does not change the original behavior other than\n   logging; it calls the existing lfs_dir_open_ implementation. */\nint lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    int err = LFS_LOCK(lfs->cfg);\n\n    /* Log entry state */\n    lfs_log_plain(\"enter_lfs_dir_open\", path, err);\n\n    if (err) {\n        lfs_log_plain(\"early_return_lfs_dir_open_lock_failed\", path, err);\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_dir_open(%p, %p, \\\"%s\\\")\", (void*)lfs, (void*)dir, path);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));\n\n    /* Log whether the incoming path contains '.' or '..' segments which\n       are the places where the original code uses memcmp to compare\n       null-terminated string segments. */\n    if (path != NULL) {\n        lfs_log_dot_segments(path);\n    }\n\n    lfs_log_plain(\"before_lfs_dir_open_\", path, 0);\n    err = lfs_dir_open_(lfs, dir, path);\n    lfs_log_plain(\"after_lfs_dir_open_\", path, err);\n\n    LFS_TRACE(\"lfs_dir_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    lfs_log_plain(\"exit_lfs_dir_open\", path, err);\n    return err;\n}\n"
}