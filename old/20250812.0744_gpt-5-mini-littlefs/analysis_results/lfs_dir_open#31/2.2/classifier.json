{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_dir_open code that contains useful probe functions that print useful logs to a file \"/tmp/logs/250.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_dir_open as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_dir_open:\n```c\nint lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_dir_open(%p, %p, \\\"%s\\\")\", (void*)lfs, (void*)dir, path);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));\n\n    err = lfs_dir_open_(lfs, dir, path);\n\n    LFS_TRACE(\"lfs_dir_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_dir_open:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n...\n#define LFS_ASSERT(test) assert(test)\n...\nstatic bool lfs_mlist_isopen(struct lfs_mlist *head,\n        struct lfs_mlist *node) {\n    for (struct lfs_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n...\nstatic int lfs_dir_open_(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n        return LFS_ERR_NOTDIR;\n    }\n\n    lfs_block_t pair[2];\n    if (lfs_tag_id(tag) == 0x3ff) {\n        // handle root dir separately\n        pair[0] = lfs->root[0];\n        pair[1] = lfs->root[1];\n    } else {\n        // get dir pair from parent\n        lfs_stag_t res = lfs_dir_get(lfs, &dir->m, LFS_MKTAG(0x700, 0x3ff, 0),\n                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);\n        if (res < 0) {\n            return res;\n        }\n        lfs_pair_fromle32(pair);\n    }\n\n    // fetch first pair\n    int err = lfs_dir_fetch(lfs, &dir->m, pair);\n    if (err) {\n        return err;\n    }\n\n    // setup entry\n    dir->head[0] = dir->m.pair[0];\n    dir->head[1] = dir->m.pair[1];\n    dir->id = 0;\n    dir->pos = 0;\n\n    // add to list of mdirs\n    dir->type = LFS_TYPE_DIR;\n    lfs_mlist_append(lfs, (struct lfs_mlist *)dir);\n\n    return 0;\n}\n...\nstruct lfs_mlist {\n        struct lfs_mlist *next;\n        uint16_t id;\n        uint8_t type;\n        lfs_mdir_t m;\n    }\n</additional code>\nJudge whether the above lfs_dir_open code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The LFS_LOCK macro is defined as '((void)cfg,0)', so err is always 0 after calling LFS_LOCK. Therefore the conditional branch 'if (err) { return err; }' can never execute in this project build; that early return is dead code (it is an operation that can be removed without affecting program behaviour under the provided definitions).",
  "test_code": "#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n/* Probe helper that logs control path and state to /tmp/logs/250.txt. */\nstatic void lfs_log_probe(const char *event, int err, const void *lfs, const void *dir, const char *path) {\n    /* Try to create directory if it doesn't exist; ignore errors. */\n    (void)mkdir(\"/tmp/logs\", 0777);\n\n    FILE *f = fopen(\"/tmp/logs/250.txt\", \"a\");\n    if (!f) {\n        return;\n    }\n\n    fprintf(f, \"EVENT=%s; err=%d; lfs=%p; dir=%p; path=\\\"%s\\\"\\n\",\n            event, err, (const void*)lfs, (const void*)dir, (path != NULL) ? path : \"(null)\");\n    fclose(f);\n}\n\nint lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {\n    /* Preserve original logic. Add probes to illustrate the dead branch. */\n    int err = LFS_LOCK(lfs->cfg);\n    lfs_log_probe(\"after_lock\", err, lfs, dir, path);\n\n    if (err) {\n        /* This branch is never taken with the provided macro definition\n         * LFS_LOCK(cfg) ((void)cfg,0) which always yields 0. The existence\n         * of this early return is therefore dead code in the current\n         * project configuration. */\n        lfs_log_probe(\"lock_failed_return\", err, lfs, dir, path);\n        return err;\n    }\n\n    LFS_TRACE(\"lfs_dir_open(%p, %p, \\\"%s\\\")\", (void*)lfs, (void*)dir, path);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));\n\n    err = lfs_dir_open_(lfs, dir, path);\n\n    lfs_log_probe(\"after_dir_open_\", err, lfs, dir, path);\n\n    LFS_TRACE(\"lfs_dir_open -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    lfs_log_probe(\"before_return\", err, lfs, dir, path);\n    return err;\n}\n"
}