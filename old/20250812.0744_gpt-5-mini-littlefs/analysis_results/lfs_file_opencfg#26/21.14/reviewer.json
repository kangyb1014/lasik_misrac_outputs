{
  "user_message": "An agent A claimed that the following lfs_file_opencfg code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of lfs_file_opencfg.\n```c\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs, (void*)file, path, (unsigned)flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));\n\n    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);\n\n    LFS_TRACE(\"lfs_file_opencfg -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In lfs_dir_find, the code uses memcmp(name, \".\", 1) and memcmp(name, \"..\", 2) (and similar comparisons with 'suffix') to detect '.' and '..' path components. These comparisons use memcmp against string literals (null-terminated C strings), which constitutes using memcmp to compare null-terminated strings and therefore violates MISRA C 2023 Rule 21.14. A concrete scenario is when lfs_file_opencfg is called with a path that contains '.' or '..' components (for example \"./file\" or \"dir/../file\"); lfs_dir_find will reach the memcmp calls and perform the forbidden comparisons.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct lfs_mlist {\n    /* Keep m (mdir) as the first member so that casting between\n       struct lfs_mlist* and struct lfs_mdir* as in the original code\n       is compatible when taking the address. */\n    struct lfs_mdir m;\n    uint16_t id;\n    uint16_t type;\n    struct lfs_mlist *next;\n};\nstatic void log_probe(const char *fmt, ...)\n{\n    FILE *fp = fopen(\"/tmp/logs/214.txt\", \"a\");\n    if (!fp) {\n        return;\n    }\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    fputs(\"\\n\", fp);\n    va_end(ap);\n    fclose(fp);\n}\n\nstatic inline uint16_t lfs_tag_type3(lfs_tag_t tag) {\n    (void)tag;\n    return LFS_TYPE_DIR; /* simplify: treat current tag as directory in example */\n}\nstatic lfs_stag_t lfs_dir_get(lfs_t *lfs, const struct lfs_mdir *dir,\n        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {\n    (void)lfs; (void)dir; (void)gmask; (void)gtag; (void)buffer;\n    return 0;\n}\nstatic void lfs_pair_fromle32(uint32_t *p) { (void)p; }\nstatic void lfs_mlist_append(lfs_t *lfs, struct lfs_mlist *mlist) {\n    mlist->next = lfs->mlist;\n    lfs->mlist = mlist;\n}\nstatic lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs, struct lfs_mdir *dir,\n        uint32_t *tail, lfs_tag_t a, lfs_tag_t b, uint16_t *id,\n        int (*match)(void*, lfs_stag_t), void *p) {\n    (void)lfs; (void)dir; (void)tail; (void)a; (void)b; (void)id; (void)match; (void)p;\n    /* For example purposes, indicate no match (0) so the caller loops */\n    return 0;\n}\nstatic inline lfs_size_t lfs_path_namelen(const char *path) {\n    return strcspn(path, \"/\");\n}\nstatic inline bool lfs_path_islast(const char *path) {\n    lfs_size_t namelen = lfs_path_namelen(path);\n    return path[namelen + strspn(path + namelen, \"/\")] == '\\0';\n}\nstatic lfs_stag_t lfs_dir_find(lfs_t *lfs, struct lfs_mdir *dir,\n        const char **path, uint16_t *id) {\n    const char *name = *path;\n\n    lfs_stag_t tag = 0; /* assume directory tag for control flow */\n    dir->tail[0] = lfs->root[0];\n    dir->tail[1] = lfs->root[1];\n\n    log_probe(\"lfs_dir_find: start path=\\\"%s\\\"\", name);\n\n    if (*name == '\\0') {\n        log_probe(\"lfs_dir_find: empty path -> LFS_ERR_INVAL\");\n        return LFS_ERR_INVAL;\n    }\n\n    while (true) {\nnextname:\n        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {\n            size_t skipped = strspn(name, \"/\");\n            log_probe(\"lfs_dir_find: skipping %zu leading '/', name before='%s'\", skipped, name);\n            name += skipped;\n        }\n        lfs_size_t namelen = strcspn(name, \"/\");\n\n        /* skip '.' */\n        if (namelen == 1 && memcmp(name, \".\", 1) == 0) {\n            log_probe(\"lfs_dir_find: matched '.' via memcmp(name, \\\".\\\", 1)\");\n            name += namelen;\n            goto nextname;\n        }\n\n        /* error on unmatched '..' */\n        if (namelen == 2 && memcmp(name, \"..\", 2) == 0) {\n            log_probe(\"lfs_dir_find: matched '..' via memcmp(name, \\\"..\\\", 2) -> LFS_ERR_INVAL\");\n            return LFS_ERR_INVAL;\n        }\n\n        /* skip if matched by '..' in name */\n        const char *suffix = name + namelen;\n        lfs_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 1 && memcmp(suffix, \".\", 1) == 0) {\n                log_probe(\"lfs_dir_find: suffix '.' matched via memcmp(suffix, \\\".\\\", 1)\");\n                /* noop */\n            } else if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                log_probe(\"lfs_dir_find: suffix '..' matched via memcmp(suffix, \\\"..\\\", 2), depth=%d\", depth);\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    log_probe(\"lfs_dir_find: resolved '..' to new name='%s'\", name);\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n                log_probe(\"lfs_dir_find: suffix normal component (len=%zu), depth=%d\", sufflen, depth);\n            }\n\n            suffix += sufflen;\n        }\n\n        if (*name == '\\0') {\n            log_probe(\"lfs_dir_find: found path -> returning tag=%d\", tag);\n            return tag;\n        }\n\n        *path = name;\n\n        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {\n            log_probe(\"lfs_dir_find: not a directory -> LFS_ERR_NOTDIR\");\n            return LFS_ERR_NOTDIR;\n        }\n\n        /* Attempt to find a matching entry; simplified to show control flow */\n        while (true) {\n            lfs_stag_t fres = lfs_dir_fetchmatch(lfs, dir, dir->tail,\n                    0, 0, id, NULL, NULL);\n            log_probe(\"lfs_dir_find: lfs_dir_fetchmatch returned %d\", fres);\n            if (fres < 0) {\n                return fres;\n            }\n\n            if (fres) {\n                tag = fres;\n                break;\n            }\n\n            if (!dir->split) {\n                log_probe(\"lfs_dir_find: no match and not split -> LFS_ERR_NOENT\");\n                return LFS_ERR_NOENT;\n            }\n        }\n\n        name += namelen;\n    }\n}\nint lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,\n        const char *path, int flags,\n        const struct lfs_file_config *cfg) {\n    (void)flags;\n    int err = 0; /* assume lock success in this simplified example */\n    if (err) {\n        return err;\n    }\n\n    log_probe(\"lfs_file_opencfg: entry lfs=%p file=%p path=\\\"%s\\\" flags=%x cfg=%p\",\n            (void*)lfs, (void*)file, path, (unsigned)flags, (void*)cfg);\n\n    /* mimic original assert that file is not already open */\n    /* lfs_mlist_isopen omitted for brevity */\n\n    /* call into the underlying implementation that does the path parsing */\n    err = (int)lfs_dir_find(lfs, (struct lfs_mdir *)&file->mlist, &path, &file->id);\n\n    log_probe(\"lfs_file_opencfg: lfs_dir_find -> %d\", err);\n\n    /* unlock and return */\n    return err;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C:2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated strings (i.e. using memcmp in the role of strcmp/strncmp where both operands are C-strings and the null terminator is relevant). In lfs_dir_find the code computes the component length with strcspn (namelen) and then compares a fixed, known number of bytes (1 or 2) with memcmp(name, \".\", 1) and memcmp(name, \"..\", 2). The substring pointed to by name is not necessarily a null\u2011terminated C string (it's an interior slice of the path), and the memcmp calls only compare the explicit character bytes (not the terminator). Thus these are raw fixed-length memory comparisons, not comparisons of null\u2011terminated strings, so they do not violate the literal text of Rule 21.14. (If one wanted to avoid any potential static\u2011analysis warnings, the checks could be rewritten using explicit character comparisons, e.g. namelen==1 && name[0]=='.' and namelen==2 && name[0]=='.' && name[1]=='.'.)"
}