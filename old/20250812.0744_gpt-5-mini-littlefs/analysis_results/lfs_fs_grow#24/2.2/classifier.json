{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified lfs_fs_grow code that contains useful probe functions that print useful logs to a file \"/tmp/logs/194.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of lfs_fs_grow as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of lfs_fs_grow:\n```c\nint lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {\n    int err = LFS_LOCK(lfs->cfg);\n    if (err) {\n        return err;\n    }\n    LFS_TRACE(\"lfs_fs_grow(%p, %\"PRIu32\")\", (void*)lfs, block_count);\n\n    err = lfs_fs_grow_(lfs, block_count);\n\n    LFS_TRACE(\"lfs_fs_grow -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n    return err;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function lfs_fs_grow:\n#define LFS_LOCK(cfg) ((void)cfg,0)\n...\n#define LFS_UNLOCK(cfg) ((void)cfg)\n...\n#define LFS_TRACE(__VA_ARGS__) \n</additional code>\nJudge whether the above lfs_fs_grow code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "The LFS_UNLOCK macro is defined as ((void)cfg), which executes a no-op expression statement. This means the LFS_UNLOCK invocation in lfs_fs_grow is an operation that is executed but has no effect; removing that invocation would not change program behaviour in the current project configuration \u2014 i.e. it constitutes dead code according to MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <inttypes.h>\n\n/*\n * Probe helpers: append control-path and state information to\n * /tmp/logs/194.txt. These helpers do not change the original\n * logic of lfs_fs_grow and are designed to be lightweight.\n */\nstatic void probe_log_open_and_enter(const void *lfs, uint32_t block_count, int lock_ret) {\n    FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"ENTER lfs_fs_grow: lfs=%p block_count=%\" PRIu32 \" LFS_LOCK_ret=%d\\n\",\n                lfs, block_count, lock_ret);\n        fclose(f);\n    }\n}\n\nstatic void probe_log_event(const char *event, int value) {\n    FILE *f = fopen(\"/tmp/logs/194.txt\", \"a\");\n    if (f) {\n        if (event) {\n            if (value == INT32_MIN) {\n                fprintf(f, \"%s\\n\", event);\n            } else {\n                fprintf(f, \"%s: %d\\n\", event, value);\n            }\n        }\n        fclose(f);\n    }\n}\n\n/* Forward declaration of the internal grow function. */\nint lfs_fs_grow_(lfs_t *lfs, lfs_size_t block_count);\n\n/*\n * Modified lfs_fs_grow that preserves the original control flow\n * while probing state and path information to /tmp/logs/194.txt.\n * The original logic is kept: lock, trace, call internal grow, trace,\n * unlock, return err.\n */\nint lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {\n    int err = LFS_LOCK(lfs->cfg);\n\n    /* Log entry and the result of the lock call. */\n    probe_log_open_and_enter((const void*)lfs, (uint32_t)block_count, err);\n\n    if (err) {\n        probe_log_event(\"early_return_due_to_lock_error\", err);\n        return err;\n    }\n\n    /* Call the underlying implementation (preserve original call). */\n    err = lfs_fs_grow_(lfs, block_count);\n\n    /* Log return value from internal grow. */\n    probe_log_event(\"lfs_fs_grow_ returned\", err);\n\n    /* Original code calls LFS_TRACE (no-op in this config) and LFS_UNLOCK.\n     * In the provided project configuration LFS_UNLOCK is defined as\n     * ((void)cfg) which is a no-op expression statement. This invocation\n     * is executed but has no effect; removing it would not change program\n     * behaviour in the present configuration (hence the dead-code scenario).\n     */\n    LFS_TRACE(\"lfs_fs_grow -> %d\", err);\n    LFS_UNLOCK(lfs->cfg);\n\n    probe_log_event(\"after_LFS_UNLOCK (no-op in this config)\", INT32_MIN);\n\n    return err;\n}\n"
}