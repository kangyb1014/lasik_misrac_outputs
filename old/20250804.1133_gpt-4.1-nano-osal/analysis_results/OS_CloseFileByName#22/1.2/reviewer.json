{
  "user_message": "An agent A claimed that the following OS_CloseFileByName code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of OS_CloseFileByName.\n```c\nint32 OS_CloseFileByName(const char *Filename)\n{\n    int32                        return_code;\n    int32                        close_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_FS_ERR_PATH_INVALID;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            /* call OS_close() on the entry referred to by the iterator */\n            close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);\n\n            if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)\n            {\n                return_code = close_code;\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a compiler-specific extension (assuming OS_CHECK_POINTER macro) which is indeed a language extension, not part of standard C, and is used here without explicit mention of any compiler-specific attributes or extension directives.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nint OS_CheckPointer(const void *ptr) {\n    if (ptr == NULL) {\n        fprintf(stderr, \"Pointer is NULL\\n\");\n        return -1; // error code\n    }\n    return 0; // success\n}\n\nint OS_CloseFileByName(const char *filename) {\n    if (OS_CheckPointer(filename) != 0) {\n        return -1;\n    }\n    // Presumably close the file here\n    // ...\n    return 0;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The macro OS_CHECK_POINTER appears to be a user-defined macro, and such macros are often implemented as compiler extensions or might rely on compiler-specific features. Since MISRA C 2023 Rule 1.2 prohibits language extensions unless explicitly stated and documented, using a macro like OS_CHECK_POINTER without explicit mention of compiler-specific extensions can be seen as a violation. The provided code does not specify whether OS_CHECK_POINTER is implemented in a portable, standard C manner or as a compiler extension. Given the scenario, it is reasonable to conclude that OS_CHECK_POINTER is a language extension, and its use without explicit documentation constitutes a violation."
}