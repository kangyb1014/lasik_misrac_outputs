{
  "user_message": "<misra_rule>
  MISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.
  This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.
  </misra_rule>
  <response format>
  Provide your answer with these fields.
  - is_rule_violated: whether the rule is violated or not (true/false),
  - scenario: a specific violation scenario.
  - test_code: a modified OS_CloseFileByName code that contains useful probe functions that print useful logs to a file \"/tmp/logs/183.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.
  Here are the constraints for the test code:
  - DO NOT introduce new violations to demonstrate your scenario.
  - The test code MUST be compilable and executable.
  - The test code MUST include line breaks.
  - The test code MUST preserve the original logic of OS_CloseFileByName as much as possible.
  - You MUST NOT define the main function.
  - You MUST NOT define macros.
  - The test code MUST not contain any mock functions.
  </response format>
  <target_code>
  Here is the code of OS_CloseFileByName:
  ```c
  int32 OS_CloseFileByName(const char *Filename)
  {
      int32                        return_code;
      int32                        close_code;
      OS_object_iter_t             iter;
      OS_stream_internal_record_t *stream;
  
      /* Check parameters */
      OS_CHECK_POINTER(Filename);
  
      return_code = OS_FS_ERR_PATH_INVALID;
  
      OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);
  
      while (OS_ObjectIdIteratorGetNext(&iter))
      {
          stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);
  
          if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))
          {
              /* call OS_close() on the entry referred to by the iterator */
              close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);
  
              if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS)
              {
                  return_code = close_code;
              }
          }
      }
  
      OS_ObjectIdIteratorDestroy(&iter);
  
      return return_code;
  }
  ```
  </target_code>
  Judge whether the above OS_CloseFileByName code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses strcmp on stream->stream_name and Filename without verifying the lengths of the involved strings, which could lead to buffer overreads if either string is not null-terminated within its allocated size.",
  "test_code": "#include <stdio.h>
  #include <string.h>
  
  /* Log function to record violations and control flow. */
  void log_violation(const char *message) {
      FILE *logfile = fopen(\"/tmp/logs/183.txt\", \"a\");
      if (logfile != NULL) {
          fprintf(logfile, \"%s\
  \", message);
          fclose(logfile);
      }
  }
  
  int32 OS_CloseFileByName(const char *Filename)
  {
      int32 return_code;
      int32 close_code;
      OS_object_iter_t iter;
      OS_stream_internal_record_t *stream;
  
      if (!Filename) {
          log_violation(\"Filename pointer is NULL.\");
          return OS_FS_ERR_PATH_INVALID;
      }
  
      return_code = OS_FS_ERR_PATH_INVALID;
  
      OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);
  
      while (OS_ObjectIdIteratorGetNext(&iter)) {
          stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);
          if (stream == NULL) {
              log_violation(\"Stream object is NULL.\
  \");
              continue;
          }
          if (stream->socket_domain == OS_SocketDomain_INVALID) {
              /* Check for string pointer validity before strcmp */
              if (stream->stream_name == NULL) {
                  log_violation(\"stream_name is NULL.\");
                  continue;
              }
              if (Filename == NULL) {
                  log_violation(\"Filename pointer is NULL during comparison.\");
                  continue;
              }
              size_t stream_name_len = strlen(stream->stream_name);
              size_t filename_len = strlen(Filename);
              /* Log lengths for debugging */
              FILE *logfile = fopen(\"/tmp/logs/183.txt\", \"a\");
              if (logfile != NULL) {
                  fprintf(logfile, \"Comparing stream_name of length %zu with Filename of length %zu\
  \", stream_name_len, filename_len);
                  fclose(logfile);
              }
              /* Proceed with strcmp if both strings are null-terminated */
              if (stream_name_len > 0 && filename_len > 0) {
                  if (strcmp(stream->stream_name, Filename) == 0) {
                      close_code = OS_ObjectIdIteratorProcessEntry(&iter, OS_FileIteratorClose);
                      if (return_code == OS_FS_ERR_PATH_INVALID || close_code != OS_SUCCESS) {
                          return_code = close_code;
                      }
                  }
              }
          }
      }
  
      OS_ObjectIdIteratorDestroy(&iter);
  
      return return_code;
  }"
}