{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_CondVarLock_Impl code that contains useful probe functions that print useful logs to a file \"/tmp/logs/202.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_CondVarLock_Impl as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_CondVarLock_Impl:\n```c\nint32 OS_CondVarLock_Impl(const OS_object_token_t *token)\n{\n    int                                status;\n    OS_impl_condvar_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_condvar_table, *token);\n\n    status = pthread_mutex_lock(&impl->mut);\n    if (status != 0)\n    {\n        return OS_ERROR;\n    }\n\n    return OS_SUCCESS;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function OS_CondVarLock_Impl:\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n...\nOS_impl_condvar_internal_record_t OS_impl_condvar_table[OS_MAX_CONDVARS]\n...\ntypedef struct\n{\n    pthread_mutex_t mut;\n    pthread_cond_t  cv;\n} OS_impl_condvar_internal_record_t\n</additional code>\nJudge whether the above OS_CondVarLock_Impl code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "If the function 'OS_CondVarLock_Impl' is called but the acquired lock is never used or released in the code, the lock acquisition could be considered dead code, especially if subsequent code also doesn't use this lock or the call. This would mean the lock operation has no net effect on the program's behavior, indicating dead code.",
  "test_code": "#include <pthread.h>\n#include <stdio.h>\n\ntypedef int int32;\n\ntypedef struct {\n    int ObjectIndex;\n} OS_object_token_t;\n\n#define OS_MAX_CONDVARS 10\n#define OS_OBJECT_TABLE_GET(tbl, tok) (&tbl[OS_ObjectIndexFromToken(&(tok))])\n#define OS_ERROR -1\n#define OS_SUCCESS 0\n\n// Mimic function \nint OS_ObjectIndexFromToken(const OS_object_token_t *token) {\n    return token->ObjectIndex;\n}\n\nOS_impl_condvar_internal_record_t OS_impl_condvar_table[OS_MAX_CONDVARS];\n\nvoid log_state(const char* message) {\n    FILE *file = fopen(\"/tmp/logs/202.txt\", \"a\");\n    if (file != NULL) {\n        fprintf(file, \"%s\\n\", message);\n        fclose(file);\n    }\n}\n\nint32 OS_CondVarLock_Impl(const OS_object_token_t *token)\n{\n    int status;\n    OS_impl_condvar_internal_record_t *impl;\n\n    impl = OS_OBJECT_TABLE_GET(OS_impl_condvar_table, *token);\n\n    status = pthread_mutex_lock(&impl->mut);\n    if (status != 0)\n    {\n        log_state(\"Mutex lock failed\") ;\n        return OS_ERROR;\n    }\n    log_state(\"Mutex locked successfully\") ;\n    return OS_SUCCESS;\n}\n"
}