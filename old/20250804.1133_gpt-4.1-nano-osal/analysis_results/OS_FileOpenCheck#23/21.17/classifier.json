{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified OS_FileOpenCheck code that contains useful probe functions that print useful logs to a file \"/tmp/logs/191.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of OS_FileOpenCheck as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of OS_FileOpenCheck:\n```c\nint32 OS_FileOpenCheck(const char *Filename)\n{\n    int32                        return_code;\n    OS_object_iter_t             iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    OS_CHECK_POINTER(Filename);\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream->socket_domain == OS_SocketDomain_INVALID && (strcmp(stream->stream_name, Filename) == 0))\n        {\n            return_code = OS_SUCCESS;\n            break;\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}\n```\n</target_code>\nJudge whether the above OS_FileOpenCheck code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses strcmp(stream->stream_name, Filename), which compares strings without verifying that the pointers are valid and properly null-terminated within bounds  before usage.",
  "test_code": "int32 OS_FileOpenCheck(const char *Filename)\n{\n    int32 return_code;\n    OS_object_iter_t iter;\n    OS_stream_internal_record_t *stream;\n\n    /* Check parameters */\n    if (Filename == NULL) {\n        FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n        if (logfile != NULL) {\n            fprintf(logfile, \"Parameter Filename is NULL at OS_FileOpenCheck.\\n\");\n            fclose(logfile);\n        }\n        return OS_ERROR;\n    }\n\n    return_code = OS_ERROR;\n\n    OS_ObjectIdIterateActive(LOCAL_OBJID_TYPE, &iter);\n\n    while (OS_ObjectIdIteratorGetNext(&iter))\n    {\n        stream = OS_OBJECT_TABLE_GET(OS_stream_table, iter.token);\n        if (stream != NULL && stream->socket_domain == OS_SocketDomain_INVALID) {\n            // Check stream_name pointer validity\n            if (stream->stream_name != NULL) {\n                // Check for null-terminator within a reasonable size to ensure string safety\n                size_t max_check = 256;\n                size_t i = 0;\n                int null_found = 0;\n                while (i < max_check) {\n                    if (stream->stream_name[i] == '\\0') {\n                        null_found = 1;\n                        break;\n                    }\n                    i++;\n                }\n                if (null_found) {\n                    if (strcmp(stream->stream_name, Filename) == 0) {\n                        return_code = OS_SUCCESS;\n                        break;\n                    }\n                } else {\n                    // log potential string without null-terminator\n                    FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n                    if (logfile != NULL) {\n                        fprintf(logfile, \"Potential unterminated string in stream_name at iter token %d.\\n\", iter.token);\n                        fclose(logfile);\n                    }\n                }\n            } else {\n                // log null pointer for stream_name\n                FILE *logfile = fopen(\"/tmp/logs/191.txt\", \"a\");\n                if (logfile != NULL) {\n                    fprintf(logfile, \"stream_name is NULL at iter token %d.\\n\", iter.token);\n                    fclose(logfile);\n                }\n            }\n        }\n    }\n\n    OS_ObjectIdIteratorDestroy(&iter);\n\n    return return_code;\n}"
}