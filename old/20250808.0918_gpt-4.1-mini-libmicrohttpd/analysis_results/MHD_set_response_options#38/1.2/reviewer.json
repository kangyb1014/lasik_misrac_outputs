{
  "user_message": "An agent A claimed that the following MHD_set_response_options code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_response_options.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n        return MHD_NO;\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n    return MHD_NO;\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      break;\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses the compiler-specific extension __attribute__((visibility(\"default\"))) in the definition of _MHD_EXTERN, which is a GCC extension for controlling symbol visibility, and thus violates Rule 1.2 which forbids the use of language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  FILE *log = fopen(\"/tmp/logs/304.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entering MHD_set_response_options\\n\");\n  }\n\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  if (log != NULL)\n    fprintf(log, \"response->flags_auto = %u\\n\", (unsigned int)response->flags_auto);\n\n  if (0 != (response->flags_auto & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if ((0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n        (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      if (log != NULL)\n        fprintf(log, \"Rejecting removal of INSANITY_HEADER_CONTENT_LENGTH flag\\n\");\n      if (log != NULL) fclose(log);\n      return MHD_NO;\n    }\n    if ((0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n        (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n      {\n        if (log != NULL)\n          fprintf(log, \"Rejecting removal of HEAD_ONLY_RESPONSE flag without INSANITY_HEADER_CONTENT_LENGTH flag\\n\");\n        if (log != NULL) fclose(log);\n        return MHD_NO;\n      }\n    }\n  }\n\n  if ((0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n      (0 != response->total_size))\n  {\n    if (log != NULL)\n      fprintf(log, \"Rejecting HEAD_ONLY_RESPONSE flag with nonzero total_size\\n\");\n    if (log != NULL) fclose(log);\n    return MHD_NO;\n  }\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  va_start(ap, flags);\n  while (MHD_RO_END != (ro = va_arg(ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    case MHD_RO_END:\n      break;\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end(ap);\n\n  if (log != NULL)\n    fprintf(log, \"Exiting MHD_set_response_options with ret=%d\\n\", ret);\n  if (log != NULL)\n    fclose(log);\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of the _MHD_EXTERN macro, which the agent claims is defined using the GCC-specific __attribute__((visibility(\"default\"))) extension. MISRA C 2023 Rule 1.2 prohibits the use of language extensions that are explicitly compiler-specific. If _MHD_EXTERN indeed expands to something that uses __attribute__((visibility(...))) or any other compiler-specific extension, the usage in this code violates Rule 1.2. The provided code snippet itself does not show the definition of _MHD_EXTERN, so direct confirmation from the snippet is not possible. However, the scenario reasonably points out that the code uses a known GCC language extension for symbol visibility. The test code failure to compile is irrelevant to the presence of the extension\u2014it does not negate the fact that the extension is used and thus violates the rule. Therefore, the report that this code violates MISRA C 2023 Rule 1.2 is correct based on the given scenario and the general knowledge of __attribute__((visibility())) being a GCC extension."
}