{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  FILE *log_file = fopen(\"/tmp/logs/641.txt\", \"a\");\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"send_iov_nontls: start\\n\");\n  }\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: invalid socket or connection closed\\n\");\n      fclose(log_file);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: _MHD_IOV_MAX is zero, returning error\\n\");\n        fclose(log_file);\n      }\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: limited items_to_send to _MHD_IOV_MAX and push_data set to false\\n\");\n    }\n  }\n#endif /* _MHD_IOV_MAX */\n\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EAGAIN error, returning MHD_ERR_AGAIN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EINTR error, returning MHD_ERR_AGAIN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Remote disconnect error, returning MHD_ERR_CONNRESET_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EPIPE error, returning MHD_ERR_PIPE_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Operation not supported error, returning MHD_ERR_OPNOTSUPP_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Not connected error, returning MHD_ERR_NOTCONN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Invalid argument error, returning MHD_ERR_INVAL_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Low resources error, returning MHD_ERR_NOMEM_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Bad file descriptor error, returning MHD_ERR_BADF_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: Unhandled error code, returning MHD_ERR_NOTCONN_\\n\");\n    }\n    if (log_file != NULL) fclose(log_file);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: Entering always-true if(1) block, res=%zd\\n\", res);\n    }\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Advancing sent index=%zu, track_sent=%zu\\n\", r_iov->sent, track_sent);\n      }\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: All iovecs sent, calling post_send_setopt\\n\");\n      }\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        if (log_file != NULL)\n        {\n          fprintf(log_file, \"send_iov_nontls: Partially sent iov %zu, adjusted pointers and length\\n\", r_iov->sent);\n        }\n      }\n    }\n  }\n  else\n  {\n    /* This else branch is unreachable code as the if condition is always true */\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: Unreachable else branch accessed\\n\");\n    }\n  }\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"send_iov_nontls: end, returning res=%zd\\n\", res);\n    fclose(log_file);\n  }\n\n  return res;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nFailed to parse the test code.\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of send_iov_nontls as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  FILE *log_file = fopen(\"/tmp/logs/641.txt\", \"a\");\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"send_iov_nontls: start\\n\");\n  }\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: invalid socket or connection closed\\n\");\n      fclose(log_file);\n    }\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: _MHD_IOV_MAX is zero, returning error\\n\");\n        fclose(log_file);\n      }\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    }\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: limited items_to_send to _MHD_IOV_MAX and push_data set to false\\n\");\n    }\n  }\n#endif /* _MHD_IOV_MAX */\n\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EAGAIN error, returning MHD_ERR_AGAIN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EINTR error, returning MHD_ERR_AGAIN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Remote disconnect error, returning MHD_ERR_CONNRESET_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_CONNRESET_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: EPIPE error, returning MHD_ERR_PIPE_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_PIPE_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Operation not supported error, returning MHD_ERR_OPNOTSUPP_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_OPNOTSUPP_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Not connected error, returning MHD_ERR_NOTCONN_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_NOTCONN_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Invalid argument error, returning MHD_ERR_INVAL_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_INVAL_;\n    }\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Low resources error, returning MHD_ERR_NOMEM_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_NOMEM_;\n    }\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Bad file descriptor error, returning MHD_ERR_BADF_\\n\");\n      }\n      if (log_file != NULL) fclose(log_file);\n      return MHD_ERR_BADF_;\n    }\n    /* Treat any other error as a hard error. */\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: Unhandled error code, returning MHD_ERR_NOTCONN_\\n\");\n    }\n    if (log_file != NULL) fclose(log_file);\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  {\n    size_t track_sent = (size_t) res;\n    if (log_file != NULL)\n    {\n      fprintf(log_file, \"send_iov_nontls: Entering always-true block, res=%zd\\n\", res);\n    }\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: Advancing sent index=%zu, track_sent=%zu\\n\", r_iov->sent, track_sent);\n      }\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n    {\n      if (log_file != NULL)\n      {\n        fprintf(log_file, \"send_iov_nontls: All iovecs sent, calling post_send_setopt\\n\");\n      }\n      post_send_setopt (connection, true, push_data);\n    }\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n        if (log_file != NULL)\n        {\n          fprintf(log_file, \"send_iov_nontls: Partially sent iov %zu, adjusted pointers and length\\n\", r_iov->sent);\n        }\n      }\n    }\n  }\n\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"send_iov_nontls: end, returning res=%zd\\n\", res);\n    fclose(log_file);\n  }\n\n  return res;\n}\n",
  "explanation": "The build error \"Failed to parse the test code\" suggests that the code could not be parsed properly, likely due to an issue with the 'if (1)' block. The original code contains an if statement with a constant true condition 'if (1)', followed by an else branch. This else branch is clearly unreachable, which may confuse some parsers or compilers in certain strict parsing or testing environments.\n\nTo fix this issue without changing the logic, I removed the enclosing 'if (1)' conditional and moved its contents directly to the parent block. This eliminates the unreachable else block and any unnecessary branching while preserving the intended logic and flow of the function.\n\nNo other code logic or structure was modified, maintaining the original behavior and correctness of the function."
}