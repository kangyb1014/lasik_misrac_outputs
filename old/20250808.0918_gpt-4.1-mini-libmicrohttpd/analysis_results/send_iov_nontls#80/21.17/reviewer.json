{
  "user_message": "An agent A claimed that the following send_iov_nontls code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of send_iov_nontls.\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If r_iov->sent index is incorrectly incremented beyond r_iov->cnt, subsequent accesses to r_iov->iov[r_iov->sent] when adjusting iov_base and iov_len will access beyond the bounds of the iov array, violating the rule.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstruct iovec {\n  void *iov_base;\n  size_t iov_len;\n};\nstatic ssize_t\nsend_iov_nontls(struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res = 10; // fake send some bytes\n  size_t items_to_send;\n\n  mhd_assert(0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ((MHD_INVALID_SOCKET == connection->socket_fd) ||\n      (MHD_CONNECTION_CLOSED == connection->state))\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert(0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n\n  pre_send_setopt(connection, true, push_data);\n\n  // simulate successful send\n  if ((size_t)res > 0)\n  {\n    size_t track_sent = (size_t)res;\n\n    FILE *logf = fopen(\"/tmp/logs/647.txt\", \"a\");\n    if (logf)\n    {\n      fprintf(logf, \"send_iov_nontls: start with r_iov->cnt=%zu, r_iov->sent=%zu, track_sent=%zu\\n\",\n              r_iov->cnt, r_iov->sent, track_sent);\n      fclose(logf);\n    }\n\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->sent < r_iov->cnt) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n\n      // Log sent index increment\n      logf = fopen(\"/tmp/logs/647.txt\", \"a\");\n      if (logf)\n      {\n        fprintf(logf, \"Incrementing sent index to %zu\\n\", r_iov->sent);\n        fclose(logf);\n      }\n\n      // Bounds checked now to avoid violation\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt(connection, true, push_data);\n    else\n    {\n      if (0 != track_sent && r_iov->sent < r_iov->cnt)\n      {\n        // Log about partial send\n        logf = fopen(\"/tmp/logs/647.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"Partial last iov element sent: sent=%zu, r_iov->cnt=%zu\\n\",\n                  r_iov->sent, r_iov->cnt);\n          fclose(logf);\n        }\n\n        void *base = r_iov->iov[r_iov->sent].iov_base;\n        size_t len = r_iov->iov[r_iov->sent].iov_len;\n\n        logf = fopen(\"/tmp/logs/647.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"Before adjust: iov_base=%p, iov_len=%zu\\n\", base, len);\n          fclose(logf);\n        }\n\n        r_iov->iov[r_iov->sent].iov_base = (void *)((uint8_t *)base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (size_t)track_sent;\n\n        logf = fopen(\"/tmp/logs/647.txt\", \"a\");\n        if (logf)\n        {\n          fprintf(logf, \"After adjust: iov_base=%p, iov_len=%zu\\n\",\n                  r_iov->iov[r_iov->sent].iov_base,\n                  r_iov->iov[r_iov->sent].iov_len);\n          fclose(logf);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nstatic void pre_send_setopt(struct MHD_Connection *connection, bool plain_send, bool push_data) {}\nstatic void post_send_setopt(struct MHD_Connection *connection, bool plain_send_next, bool push_data) {}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "In the original `send_iov_nontls` implementation, the while loop that increments `r_iov->sent` includes a condition that ensures `r_iov->sent` never surpasses `r_iov->cnt` during iteration: `while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))`. Additionally, there is an assertion inside the loop: `mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent))`, which checks that if `track_sent` is non-zero, `r_iov->sent` must still be less than `r_iov->cnt`. This effectively prevents out-of-bounds access to `r_iov->iov[r_iov->sent]` within the loop.\n\nAfter the loop, there is a conditional check `if (r_iov->cnt == r_iov->sent)` before calling `post_send_setopt`, and in the else clause where the partial adjustment of `iov_base` and `iov_len` occurs, it implies that `r_iov->sent` is less than `r_iov->cnt`.\n\nHence, the original code uses assertions and control flow checks to prevent access beyond the array bounds. The provided modified code by agent A added explicit bounds checks before adjusting `iov_base` and `iov_len`, which are consistent with good practice to avoid rule violations. The test code provided by agent A fails to compile and thus does not provide observable evidence of the violation.\n\nOverall, the original code appears written carefully to avoid accesses beyond the bounds of the `iov` array, complying with MISRA C 2023 Rule 21.17. Without a demonstrated scenario or evidence where `r_iov->sent` exceeds `r_iov->cnt` leading to out-of-bounds access, the claim is not sufficiently substantiated."
}