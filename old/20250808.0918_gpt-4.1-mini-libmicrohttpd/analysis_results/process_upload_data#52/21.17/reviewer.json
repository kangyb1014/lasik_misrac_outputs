{
  "user_message": "An agent A claimed that the following process_upload_data code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of process_upload_data.\n```c\nstatic enum MHD_Result\nprocess_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n  {\n    fprintf (stderr,\n             \"Ignoring unexpected form value `%s'\\n\",\n             key);\n    return MHD_YES;   /* ignore */\n  }\n  if (NULL == filename)\n  {\n    fprintf (stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n  {\n    fprintf (stderr,\n             \"Missing form data for upload `%s'\\n\",\n             filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n  if (-1 == uc->fd)\n  {\n    char fn[PATH_MAX];\n\n    if ( (NULL != strstr (filename, \"..\")) ||\n         (NULL != strchr (filename, '/')) ||\n         (NULL != strchr (filename, '\\\\')) )\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n    (void) mkdir (uc->language);\n#else\n    (void) mkdir (uc->language, S_IRWXU);\n#endif\n    snprintf (fn, sizeof (fn),\n              \"%s/%s\",\n              uc->language,\n              uc->category);\n#ifdef WINDOWS\n    (void) mkdir (fn);\n#else\n    (void) mkdir (fn, S_IRWXU);\n#endif\n    /* open file */\n    res = snprintf (fn, sizeof (fn),\n                    \"%s/%s/%s\",\n                    uc->language,\n                    uc->category,\n                    filename);\n    if ((0 >= res) || (sizeof (fn) <= (size_t) res))\n    {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    for (i = 0; i < (size_t) res; i++)\n      if (! isprint ((unsigned char) fn[i]))\n        fn[i] = '_';\n    uc->fd = open (fn,\n                   O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                   | O_LARGEFILE\n#endif\n                   | O_WRONLY,\n                   S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd)\n    {\n      fprintf (stderr,\n               \"Error opening file `%s' for upload: %s\\n\",\n               fn,\n               strerror (errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup (fn);\n  }\n  if ( (0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n       (size != (size_t) write (uc->fd, data, size))\n#else  /* Native W32 */\n       (size != (size_t) write (uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n       )\n  {\n    /* write failed; likely: disk full */\n    fprintf (stderr,\n             \"Error writing to file `%s': %s\\n\",\n             uc->filename,\n             strerror (errno));\n    uc->response = internal_error_response;\n    (void) close (uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename)\n    {\n      unlink (uc->filename);\n      free (uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The violation occurs in the do_append function called by process_upload_data. It uses memcpy with 'size' bytes from 'data' without ensuring that 'data' actually points to at least 'size' bytes. If 'data' is shorter than 'size', this leads to out-of-bounds memory access, violating Rule 21.17. Since process_upload_data passes 'data' and 'size' to do_append without additional validation, the risk of out-of-bounds access exists if the caller parameters are not well-formed.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result do_append(char **ret, const char *data, size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  FILE *log = fopen(\"/tmp/logs/423.txt\", \"a\");\n  if (log) {\n    fprintf(log, \"do_append called with size=%zu\\n\", size);\n  }\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen(*ret);\n\n  if (log) {\n    fprintf(log, \"old_len=%zu\\n\", old_len);\n  }\n\n  if (NULL == (buf = malloc(old_len + size + 1))) {\n    if (log) {\n      fprintf(log, \"malloc failed\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n\n  if (NULL != *ret) {\n    memcpy(buf, *ret, old_len);\n    free(*ret);\n  }\n\n  if (log) {\n    fprintf(log, \"Copying %zu bytes from data (pointer %p)\\n\", size, (const void *)data);\n  }\n\n  // Ensure data is accessed only if size > 0\n  if (size > 0 && data != NULL) {\n    memcpy(&buf[old_len], data, size);\n  }\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n\n  if (log) {\n    fprintf(log, \"do_append completed, new string length %zu\\n\", strlen(buf));\n    fclose(log);\n  }\n\n  return MHD_YES;\n}\nstatic enum MHD_Result process_upload_data (void *cls,\n                     enum MHD_ValueKind kind,\n                     const char *key,\n                     const char *filename,\n                     const char *content_type,\n                     const char *transfer_encoding,\n                     const char *data,\n                     uint64_t off,\n                     size_t size)\n{\n  struct UploadContext *uc = cls;\n  size_t i;\n  int res;\n\n  FILE *log = fopen(\"/tmp/logs/423.txt\", \"a\");\n  if (log) {\n    fprintf(log, \"Entering process_upload_data with key=%s, size=%zu, off=%llu\\n\", key, size, (unsigned long long)off);\n  }\n\n  (void) kind;              /* Unused. Silent compiler warning. */\n  (void) content_type;      /* Unused. Silent compiler warning. */\n  (void) transfer_encoding; /* Unused. Silent compiler warning. */\n  (void) off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp(key, \"category\")) {\n    if (log) fprintf(log, \"Calling do_append for category\\n\");\n    enum MHD_Result r = do_append(&uc->category, data, size);\n    if (log) fprintf(log, \"do_append for category returned %d\\n\", r);\n    if (log) fclose(log);\n    return r;\n  }\n  if (0 == strcmp(key, \"language\")) {\n    if (log) fprintf(log, \"Calling do_append for language\\n\");\n    enum MHD_Result r = do_append(&uc->language, data, size);\n    if (log) fprintf(log, \"do_append for language returned %d\\n\", r);\n    if (log) fclose(log);\n    return r;\n  }\n\n  if (log) fclose(log);\n\n  if (0 != strcmp(key, \"upload\")) {\n    fprintf(stderr, \"Ignoring unexpected form value `%s'\\n\", key);\n    return MHD_YES;   /* ignore */\n  }\n\n  if (NULL == filename) {\n    fprintf(stderr, \"No filename, aborting upload.\\n\");\n    return MHD_NO;   /* no filename, error */\n  }\n\n  if ((NULL == uc->category) || (NULL == uc->language)) {\n    fprintf(stderr, \"Missing form data for upload `%s'\\n\", filename);\n    uc->response = request_refused_response;\n    return MHD_NO;\n  }\n\n  if (-1 == uc->fd) {\n    char fn[PATH_MAX];\n\n    if ((NULL != strstr(filename, \"..\")) || (NULL != strchr(filename, '/')) || (NULL != strchr(filename, '\\\\'))) {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n\n#ifdef _WIN32\n    (void) mkdir(uc->language);\n#else\n    (void) mkdir(uc->language, S_IRWXU);\n#endif\n\n    snprintf(fn, sizeof(fn), \"%s/%s\", uc->language, uc->category);\n\n#ifdef _WIN32\n    (void) mkdir(fn);\n#else\n    (void) mkdir(fn, S_IRWXU);\n#endif\n\n    res = snprintf(fn, sizeof(fn), \"%s/%s/%s\", uc->language, uc->category, filename);\n    if ((0 >= res) || (sizeof(fn) <= (size_t)res)) {\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n\n    for (i = 0; i < (size_t)res; i++)\n      if (!isprint((unsigned char)fn[i]))\n        fn[i] = '_';\n    uc->fd = open(fn, O_CREAT | O_EXCL\n#ifdef O_LARGEFILE\n                 | O_LARGEFILE\n#endif\n                 | O_WRONLY,\n                 S_IRUSR | S_IWUSR);\n    if (-1 == uc->fd) {\n      fprintf(stderr, \"Error opening file `%s' for upload: %s\\n\", fn, strerror(errno));\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n    uc->filename = strdup(fn);\n  }\n\n  if ((0 != size) &&\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n      (size != (size_t) write(uc->fd, data, size))\n#else  /* Native W32 */\n    (size != (size_t) write(uc->fd, data, (unsigned int) size))\n#endif /* Native W32 */\n      ) {\n    fprintf(stderr, \"Error writing to file `%s': %s\\n\", uc->filename, strerror(errno));\n    uc->response = internal_error_response;\n    (void) close(uc->fd);\n    uc->fd = -1;\n    if (NULL != uc->filename) {\n      unlink(uc->filename);\n      free(uc->filename);\n      uc->filename = NULL;\n    }\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 aims to prevent out-of-bounds accesses caused by standard string handling functions. In the provided process_upload_data code, the only functions called that handle memory copying related to strings are do_append (which internally uses memcpy) and some string comparison functions like strcmp, strstr, and strchr which are safe given proper null-terminated strings. The report claims that do_append uses memcpy with 'size' bytes from 'data' without verifying the actual length of the 'data' buffer, and since process_upload_data passes 'data' and 'size' directly without additional validation, this might lead to accesses beyond the bounds if 'data' is shorter than 'size'. This is correct: the caller of process_upload_data would need to guarantee that the 'data' pointer references at least 'size' bytes. The function process_upload_data does not validate this explicitly or take any measures to ensure that 'data' points to a buffer at least 'size' bytes long before passing it to do_append and then to memcpy. Thus, the risk of out-of-bounds access exists if input parameters are not well-formed or validated elsewhere. The responsibility may partially reside in the caller, but MISRA Rule 21.17 requires the code not to lead to unsafe accesses due to usage of string functions. Since process_upload_data directly uses do_append passing 'data' and 'size' without checking whether 'data' points to at least 'size' bytes, the violation is valid. Therefore, Agent A's report that the code violates Rule 21.17 due to potential out-of-bounds access in the use of memcpy in do_append is correct."
}