{
  "user_message": "An agent A claimed that the following ahc_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of ahc_cb.\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the function ws_get_accept_value, strncpy is called to copy WS_KEY_LEN + 1 bytes from 'key' to 'str', but 'key' is only guaranteed to be WS_KEY_LEN bytes long, causing an out-of-bounds read beyond the 'key' buffer. This usage violates MISRA C 2023 Rule 21.17 as it results in access beyond the bounds of the object referenced by the pointer parameter to strncpy.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nconst char WS_GUID[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\nvoid SHA1Reset(struct SHA1Context *ctx) { (void)ctx; }\nvoid SHA1Input(struct SHA1Context *ctx, const unsigned char *data, size_t len) { (void)ctx; (void)data; (void)len; }\nint SHA1Result(struct SHA1Context *ctx, unsigned char *hash) { (void)ctx; (void)hash; return SHA1_RESULT_SUCCESS; }\nint BASE64Encode(const unsigned char *input, int length, char **output) { (void)input; (void)length; *output = malloc(30); if (*output == NULL) return -1; strcpy(*output, \"MOCK_BASE64_ENCODED\"); return 17; }\nstatic enum MHD_Result\nws_get_accept_value (const char *key, char **val)\n{\n  FILE *f = fopen(\"/tmp/logs/495.txt\", \"a\");\n  if(!f) return 0;\n  struct SHA1Context ctx;\n  unsigned char hash[SHA1HashSize];\n  char *str;\n  ssize_t len;\n\n  fprintf(f, \"Entering ws_get_accept_value\\n\");\n\n  if ((NULL == key) || (WS_KEY_LEN != strlen(key)))\n  {\n    fprintf(f, \"Invalid key length: %zu\\n\", key ? strlen(key) : 0);\n    fclose(f);\n    return 0; // MHD_NO\n  }\n\n  str = malloc(WS_KEY_LEN + WS_GUID_LEN + 1);\n  if (NULL == str)\n  {\n    fprintf(f, \"malloc failed\\n\");\n    fclose(f);\n    return 0; // MHD_NO\n  }\n\n  // Correct the copy length to avoid buffer overflow\n  strncpy(str, key, WS_KEY_LEN);\n  str[WS_KEY_LEN] = '\\0';\n  fprintf(f, \"strncpy called with WS_KEY_LEN=%d bytes\\n\", WS_KEY_LEN);\n\n  strncpy(str + WS_KEY_LEN, WS_GUID, WS_GUID_LEN);\n  str[WS_KEY_LEN + WS_GUID_LEN] = '\\0';\n  fprintf(f, \"Copied WS_GUID to str+WS_KEY_LEN\\n\");\n\n  SHA1Reset(&ctx);\n  SHA1Input(&ctx, (const unsigned char *)str, WS_KEY_GUID_LEN);\n\n  if (SHA1_RESULT_SUCCESS != SHA1Result(&ctx, hash))\n  {\n    fprintf(f, \"SHA1Result failed\\n\");\n    free(str);\n    fclose(f);\n    return 0; // MHD_NO\n  }\n\n  free(str);\n\n  len = BASE64Encode(hash, SHA1HashSize, val);\n  if (-1 == len)\n  {\n    fprintf(f, \"BASE64Encode failed\\n\");\n    fclose(f);\n    return 0; // MHD_NO\n  }\n\n  (*val)[len] = '\\0';\n\n  fprintf(f, \"ws_get_accept_value success, base64 length: %zd\\n\", len);\n  fclose(f);\n  return 1; // MHD_YES\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns the use of strncpy in the ws_get_accept_value function, where the copy length of WS_KEY_LEN + 1 is used on the 'key' input, while 'key' is only guaranteed to be WS_KEY_LEN characters long. According to the scenario, this usage results in an out-of-bounds read of one byte beyond the 'key' buffer, which would indeed violate MISRA C 2023 Rule 21.17 as it forbids accesses beyond the bounds of the objects referenced by the parameters to string.h functions. The test code attempts to address this by changing strncpy calls to copy exactly WS_KEY_LEN bytes and then add a null terminator, which is the correct approach to avoid overflow or out-of-bounds reads. Although the test code failed to compile, this does not invalidate the correctness of the violation scenario described. The misuse of strncpy leading to a possible over-read beyond the 'key' buffer is a genuine violation of Rule 21.17. Hence, the agent A's report is correct."
}