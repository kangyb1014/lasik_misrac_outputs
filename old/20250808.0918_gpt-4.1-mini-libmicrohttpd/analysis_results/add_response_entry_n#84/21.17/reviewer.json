{
  "user_message": "An agent A claimed that the following add_response_entry_n code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry_n.\n```c\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation occurs if the pointers 'header' or 'content' do not actually point to memory buffers at least 'header_len' or 'content_len' bytes long respectively, leading memchr calls and later memcpy calls in MHD_add_response_entry_no_check_ to access beyond the objects' bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  FILE *log = fopen(\"/tmp/logs/679.txt\", \"a\");\n  if (log == NULL) return false;\n\n  fprintf(log, \"Entered add_response_entry_n\\n\");\n  fprintf(log, \"response=%p, kind=%d, header_len=%zu, content_len=%zu\\n\", (void *)response, (int)kind, header_len, content_len);\n\n  if (NULL == response) {\n    fprintf(log, \"response is NULL, returning false\\n\");\n    fclose(log);\n    return false;\n  }\n  if (0 == header_len) {\n    fprintf(log, \"header_len is 0, returning false\\n\");\n    fclose(log);\n    return false;\n  }\n  if (0 == content_len) {\n    fprintf(log, \"content_len is 0, returning false\\n\");\n    fclose(log);\n    return false;\n  }\n\n  if (NULL != memchr (header, '\\t', header_len)) {\n    fprintf(log, \"header contains tab character within header_len\\n\");\n    fclose(log);\n    return false;\n  }\n  if (NULL != memchr (header, ' ', header_len)) {\n    fprintf(log, \"header contains space character within header_len\\n\");\n    fclose(log);\n    return false;\n  }\n  if (NULL != memchr (header, '\\r', header_len)) {\n    fprintf(log, \"header contains carriage return within header_len\\n\");\n    fclose(log);\n    return false;\n  }\n  if (NULL != memchr (header, '\\n', header_len)) {\n    fprintf(log, \"header contains newline within header_len\\n\");\n    fclose(log);\n    return false;\n  }\n  if (NULL != memchr (content, '\\r', content_len)) {\n    fprintf(log, \"content contains carriage return within content_len\\n\");\n    fclose(log);\n    return false;\n  }\n  if (NULL != memchr (content, '\\n', content_len)) {\n    fprintf(log, \"content contains newline within content_len\\n\");\n    fclose(log);\n    return false;\n  }\n\n  fprintf(log, \"Calling MHD_add_response_entry_no_check_\\n\");\n  fclose(log);\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 requires that calls to string handling functions from <string.h> (including memchr) must not access beyond the bounds of the objects referenced by their pointer parameters. In the provided code, memchr() is called on the 'header' pointer with a length of 'header_len', and similarly on 'content' with 'content_len'. The code does not internally verify that 'header' points to a memory region of at least 'header_len' bytes, or that 'content' points to at least 'content_len' bytes. It only checks that these lengths are non-zero and that 'response' is not NULL.\n\nThe scenario suggested by Agent A is that if the caller passes pointers that do not point to buffers at least that large, then memchr could access beyond object bounds, violating Rule 21.17. This is a correct interpretation because the function cannot guarantee the validity of those pointers and lengths; it relies on the caller to provide valid buffers.\n\nTherefore, the violation stems from usage assumptions without enforcing or validating the pointer-length consistency within the function. The function itself does not cause out-of-bounds access if called with valid inputs, but the absence of bounds validation means the usage can easily violate Rule 21.17.\n\nThe failing to compile test code is irrelevant to the validity of the violation claim since the reasoning about bounds remains. Thus, agent A's report about a potential Rule 21.17 violation is correct."
}