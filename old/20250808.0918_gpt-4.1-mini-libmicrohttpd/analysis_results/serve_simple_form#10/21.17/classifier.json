{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified serve_simple_form code that contains useful probe functions that print useful logs to a file \"/tmp/logs/87.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of serve_simple_form as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of serve_simple_form:\n```c\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form), form);\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function serve_simple_form:\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n</additional code>\nJudge whether the above serve_simple_form code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The function serve_simple_form uses strlen(form) to determine the length of the buffer passed to MHD_create_response_from_buffer_static. If the pointer 'form' does not point to a valid null-terminated string or if the memory beyond 'form' is not valid (e.g., if cls is not a properly null-terminated string), then strlen(form) may read beyond the bounds of the object, violating Rule 21.17.",
  "test_code": "static enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n  FILE *log = fopen(\"/tmp/logs/87.txt\", \"w\");\n\n  if (log != NULL) {\n    fprintf(log, \"serve_simple_form called with cls=%p\\n\", cls);\n  }\n\n  /* Check if form is NULL or points to invalid string */\n  if (form == NULL) {\n    if (log != NULL) {\n      fprintf(log, \"Error: form is NULL\\n\");\n      fclose(log);\n    }\n    return (enum MHD_Result)0; /* Indicate failure */\n  }\n\n  /* Log the string content and length - this can potentially cause undefined behavior if form is not valid but included to show the violation scenario */\n  size_t length = 0;\n  const char *ptr = form;\n  while (*ptr != '\\0') {\n    length++;\n    ptr++;\n    if (length > 1024) { /* safeguard to avoid infinite loop in logging */\n      if (log != NULL) {\n        fprintf(log, \"Potentially invalid string: no null terminator within 1024 chars\\n\");\n        fclose(log);\n      }\n      return (enum MHD_Result)0;\n    }\n  }\n\n  if (log != NULL) {\n    fprintf(log, \"form string length determined by strlen: %zu\\n\", length);\n    fprintf(log, \"form string content: %.*s\\n\", (int)length, form);\n    fclose(log);\n  }\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (length, form);\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n    /* return response without content type anyway ... */\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n"
}