{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic enum MHD_Result\nis_websocket_request(struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  FILE *log = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (log == NULL) {\n    /* Cannot open log file, proceed without logging. */\n    (void)con;\n    return ((upg_header != NULL) && (con_header != NULL)\n            && (0 == strcmp(upg_header, WS_UPGRADE_VALUE))\n            && (NULL != strstr(con_header, \"Upgrade\")))\n           ? MHD_YES\n           : MHD_NO;\n  }\n\n  fprintf(log, \"Entered is_websocket_request\\n\");\n  fprintf(log, \"upg_header: %p, con_header: %p\\n\", (void*)upg_header, (void*)con_header);\n\n  if (upg_header == NULL) {\n    fprintf(log, \"upg_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n  if (con_header == NULL) {\n    fprintf(log, \"con_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  size_t upg_len = strlen(upg_header);\n  size_t ws_len = strlen(WS_UPGRADE_VALUE);\n  fprintf(log, \"upg_header length: %zu, WS_UPGRADE_VALUE length: %zu\\n\", upg_len, ws_len);\n\n  /* Probe potential risk: log if upg_header length is less than WS_UPGRADE_VALUE length */\n  if (upg_len < ws_len) {\n    fprintf(log, \"Warning: upg_header length (%zu) smaller than WS_UPGRADE_VALUE (%zu), risk of out-of-bounds in strcmp\\n\", upg_len, ws_len);\n  }\n\n  int strcmp_res = strcmp(upg_header, WS_UPGRADE_VALUE);\n  fprintf(log, \"strcmp(upg_header, WS_UPGRADE_VALUE) = %d\\n\", strcmp_res);\n\n  char *strstr_res = strstr(con_header, \"Upgrade\");\n  fprintf(log, \"strstr(con_header, \\\"Upgrade\\\") = %p\\n\", (void*)strstr_res);\n\n  enum MHD_Result result = (strcmp_res == 0 && strstr_res != NULL) ? MHD_YES : MHD_NO;\n\n  fprintf(log, \"Returning result: %d\\n\", result);\n  fclose(log);\n  (void)con;  /* Unused. Silent compiler warning. */\n  return result;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nIn file included from ../../src/include/mhd_options.h:34,\n                 from ../../src/include/platform.h:37,\n                 from websocket_threaded_example.c:39:\n../../MHD_config.h:783: warning: \"_MHD_EXTERN\" redefined\n  783 | #define _MHD_EXTERN __attribute__((visibility(\"default\"))) extern\n      | \nIn file included from websocket_threaded_example.c:3:\n../../src/include/microhttpd.h:191: note: this is the location of the previous definition\n  191 | #define _MHD_EXTERN extern\n      | \n/tmp/tmpqladiq1k/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of is_websocket_request as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "static enum MHD_Result\nis_websocket_request(struct MHD_Connection *con, const char *upg_header,\n                      const char *con_header)\n{\n  FILE *log = fopen(\"/tmp/logs/487.txt\", \"a\");\n  if (log == NULL) {\n    /* Cannot open log file, proceed without logging. */\n    (void)con;\n    return ((upg_header != NULL) && (con_header != NULL)\n            && (0 == strcmp(upg_header, WS_UPGRADE_VALUE))\n            && (NULL != strstr(con_header, \"Upgrade\")))\n           ? MHD_YES\n           : MHD_NO;\n  }\n\n  fprintf(log, \"Entered is_websocket_request\\n\");\n  fprintf(log, \"upg_header: %p, con_header: %p\\n\", (const void*)upg_header, (const void*)con_header);\n\n  if (upg_header == NULL) {\n    fprintf(log, \"upg_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n  if (con_header == NULL) {\n    fprintf(log, \"con_header is NULL\\n\");\n    fclose(log);\n    return MHD_NO;\n  }\n\n  size_t upg_len = strlen(upg_header);\n  size_t ws_len = strlen(WS_UPGRADE_VALUE);\n  fprintf(log, \"upg_header length: %zu, WS_UPGRADE_VALUE length: %zu\\n\", upg_len, ws_len);\n\n  /* Probe potential risk: log if upg_header length is less than WS_UPGRADE_VALUE length */\n  if (upg_len < ws_len) {\n    fprintf(log, \"Warning: upg_header length (%zu) smaller than WS_UPGRADE_VALUE (%zu), risk of out-of-bounds in strcmp\\n\", upg_len, ws_len);\n  }\n\n  int strcmp_res = strcmp(upg_header, WS_UPGRADE_VALUE);\n  fprintf(log, \"strcmp(upg_header, WS_UPGRADE_VALUE) = %d\\n\", strcmp_res);\n\n  const char *strstr_res = strstr(con_header, \"Upgrade\");\n  fprintf(log, \"strstr(con_header, \\\"Upgrade\\\") = %p\\n\", (const void*)strstr_res);\n\n  enum MHD_Result result = (strcmp_res == 0 && strstr_res != NULL) ? MHD_YES : MHD_NO;\n\n  fprintf(log, \"Returning result: %d\\n\", result);\n  fclose(log);\n  (void)con;  /* Unused. Silent compiler warning. */\n  return result;\n}\n",
  "explanation": "The original compilation errors were related to redefinition of macros and missing build tools, not syntax errors in the function itself. To ensure the provided function compiles cleanly as standalone code, I replaced the casts in fprintf with casts to (const void*) instead of (void*), which is more appropriate for printing string pointers without modifying data and avoids some warnings. No changes were needed in the logic or structure of the function. The function contains no macro definitions, no main function, and preserves the original logic exactly, meeting all the constraints."
}