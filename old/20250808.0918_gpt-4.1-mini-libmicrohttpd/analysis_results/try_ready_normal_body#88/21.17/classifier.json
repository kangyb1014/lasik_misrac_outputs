{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_ready_normal_body code that contains useful probe functions that print useful logs to a file \"/tmp/logs/711.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_ready_normal_body as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_ready_normal_body:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_normal_body:\nstatic void\nconnection_close_error (struct MHD_Connection *connection,\n                        const char *emsg)\n{\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              \"%s\\n\",\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void) emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}\n...\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\n#define MHD_mutex_unlock_chk_(pmutex) do{if(!MHD_mutex_unlock_(pmutex))MHD_PANIC(_(\"Failed to unlock mutex.\\n\"));\\\n}while(0)\n...\n#define CONNECTION_CLOSE_ERROR(c, emsg) connection_close_error(c,emsg)\n</additional code>\nJudge whether the above try_ready_normal_body code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The memcpy function is called with the source pointer connection->rp.response->data_iov and the size copy_size calculated as response->data_iovcnt * sizeof(MHD_iovec_). If response->data_iovcnt is incorrect (e.g., larger than the actual number of elements allocated in data_iov), this could cause memcpy to access beyond the bounds of data_iov, violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nstruct MHD_iovec_ {\n  void *iov_base;\n  size_t iov_len;\n};\n\nenum MHD_Result { MHD_YES = 1, MHD_NO = 0 };\n\ntypedef ssize_t (*crc_func)(void *, uint64_t, char *, size_t);\n\nstruct MHD_Response {\n  size_t total_size;\n  struct MHD_iovec_ *data_iov;\n  size_t data_iovcnt;\n  void *crc_cls;\n  crc_func crc;\n  size_t data_buffer_size;\n  void *data;\n  size_t data_start;\n  size_t data_size;\n  void *mutex;\n};\n\nstruct {\n  struct MHD_Response *response;\n  bool send_reply_body;\n  struct {\n    struct MHD_iovec_ *iov;\n    size_t cnt;\n    size_t sent;\n  } resp_iov;\n  size_t rsp_write_position;\n  enum MHD_Result resp_sender;\n} rp;\n\nstruct MHD_Connection {\n  struct MHD_Response *rp_response;\n  struct {\n    struct MHD_iovec_ *iov;\n    size_t cnt;\n    size_t sent;\n  } resp_iov;\n  size_t rsp_write_position;\n  enum MHD_Result resp_sender;\n  struct MHD_Response rp;\n  bool stop_with_error;\n  bool discard_request;\n} connection;\n\nvoid *MHD_connection_alloc_memory_(struct MHD_Connection *connection, size_t size);\n\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  if (!connection->rp.send_reply_body) return MHD_NO;\n\n  FILE *log = fopen(\"/tmp/logs/711.txt\", \"a\");\n  fprintf(log, \"try_ready_normal_body start\\n\");\n\n  if ( (0 == response->total_size) ||\n       (connection->rp.rsp_write_position == response->total_size) )\n  {\n    fprintf(log, \"Zero byte or fully sent response; returning MHD_YES\\n\");\n    fclose(log);\n    return MHD_YES;  /* 0-byte response is always ready */\n  }\n\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n    {\n      fprintf(log, \"resp_iov.iov not NULL; returning MHD_YES\\n\");\n      fclose(log);\n      return MHD_YES;\n    }\n\n    copy_size = response->data_iovcnt * sizeof(struct MHD_iovec_);\n    fprintf(log, \"Allocating memory for resp_iov.iov, size: %zu\\n\", copy_size);\n\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection, copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      fprintf(log, \"Memory allocation failed, unlocking mutex and closing connection with error\\n\");\n      fclose(log);\n      /* not enough memory */\n      connection->stop_with_error = true;\n      connection->discard_request = true;\n      return MHD_NO;\n    }\n\n    fprintf(log, \"Performing memcpy with copy_size: %zu\\n\", copy_size);\n    memcpy (connection->rp.resp_iov.iov, response->data_iov, copy_size); // Potential violation here\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    fprintf(log, \"memcpy done, returning MHD_YES\\n\");\n    fclose(log);\n    return MHD_YES;\n  }\n\n  fclose(log);\n  return MHD_YES; // For simplicity in this test code, returning MHD_YES here\n}\n"
}