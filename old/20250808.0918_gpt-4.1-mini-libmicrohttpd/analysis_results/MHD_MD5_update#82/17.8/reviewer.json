{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer parameter 'data' of type 'const uint8_t *data' is modified within the function by pointer arithmetic (incrementing the pointer 'data += bytes_left;' and 'data += MD5_BLOCK_SIZE;'). Although the object it points to is not modified (due to 'const'), the function parameter pointer itself is modified, violating MISRA C 2023 Rule 17.8.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void md5_transform(uint32_t H[4], const void *M)\n{\n  /* Stub for md5_transform - no modification needed for this test */\n}\nvoid MHD_MD5_update (struct Md5Ctx *ctx,\n                     const uint8_t *data,\n                     size_t length)\n{\n  FILE *log = fopen(\"/tmp/logs/661.txt\", \"a\");\n  unsigned int bytes_have;\n\n  if (log != NULL) {\n    fprintf(log, \"MHD_MD5_update called with length=%zu\\n\", length);\n  }\n\n  if (length == 0) {\n    if (log != NULL) {\n      fprintf(log, \"Early return due to zero length\\n\");\n      fclose(log);\n    }\n    return; /* Shortcut, do nothing */\n  }\n\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (log != NULL) {\n    fprintf(log, \"bytes_have=%u, updated count=%lu\\n\", bytes_have, (unsigned long)ctx->count);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {\n      memcpy(((uint8_t *) ctx->buffer) + bytes_have, data, bytes_left);\n\n      if (log != NULL) {\n        fprintf(log, \"Before modifying pointer parameter 'data': %p\\n\", (const void *)data);\n      }\n\n      data += bytes_left; /* Modification of pointer parameter 'data' (violation) */\n      length -= bytes_left;\n\n      if (log != NULL) {\n        fprintf(log, \"After modifying pointer parameter 'data': %p, length=%zu\\n\", (const void *)data, length);\n      }\n\n      md5_transform(ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {\n    md5_transform(ctx->H, data);\n\n    if (log != NULL) {\n      fprintf(log, \"Processing full block at data=%p, length=%zu\\n\", (const void *)data, length);\n    }\n\n    data += MD5_BLOCK_SIZE; /* Modification of pointer parameter 'data' (violation) */\n    length -= MD5_BLOCK_SIZE;\n\n    if (log != NULL) {\n      fprintf(log, \"After modifying pointer parameter 'data': %p, length=%zu\\n\", (const void *)data, length);\n    }\n  }\n\n  if (0 != length)\n  {\n    memcpy(((uint8_t *) ctx->buffer) + bytes_have, data, length);\n\n    if (log != NULL) {\n      fprintf(log, \"Copy incomplete block of length=%zu from data=%p\\n\", length, (const void *)data);\n    }\n  }\n\n  if (log != NULL) {\n    fclose(log);\n  }\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 states that a function parameter itself should not be modified. In this code, the parameter 'data' is a pointer of type 'const uint8_t *'. While the data being pointed to is const and not modified, the pointer variable 'data' itself is updated within the function by pointer arithmetic (e.g., 'data += bytes_left;' and 'data += MD5_BLOCK_SIZE;'). These statements modify the pointer parameter 'data', which violates Rule 17.8, even though the pointed-to data is not changed. Therefore, Agent A's report that the code violates MISRA C 2023 Rule 17.8 is correct. The failure of the test code to compile is irrelevant to the correctness of the claim; the rule is about modifying the formal parameter variable 'data', not about compilation success."
}