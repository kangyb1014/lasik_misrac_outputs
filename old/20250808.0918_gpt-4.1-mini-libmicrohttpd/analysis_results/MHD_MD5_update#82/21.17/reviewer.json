{
  "user_message": "An agent A claimed that the following MHD_MD5_update code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_MD5_update.\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation can occur when the memcpy calls in MHD_MD5_update access more bytes than the allocated buffer size if length exceeds buffer remaining size, especially when the caller does not guarantee that the data buffer is large enough. This could cause memcpy to access beyond the bounds of the data pointer parameter, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic void md5_transform(uint32_t H[4], const void *M) {\n  /* Dummy implementation to allow compilation */\n  (void)H;\n  (void)M;\n}\nvoid MHD_MD5_update(struct Md5Ctx *ctx, const uint8_t *data, size_t length)\n{\n  unsigned int bytes_have; /* Number of bytes in the context buffer */\n\n  /* Logging start */\n  FILE *log_file = fopen(\"/tmp/logs/663.txt\", \"a\");\n  if (log_file != NULL)\n  {\n    fprintf(log_file, \"MHD_MD5_update called: data=%p, length=%zu, ctx_count=%llu\\n\", (void*)data, length, ctx->count);\n  }\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n  {\n    if (log_file) fprintf(log_file, \"Length is zero, returning early.\\n\");\n    if (log_file) fclose(log_file);\n    return; /* Shortcut, do nothing */\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  bytes_have = (unsigned int)(ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (log_file) fprintf(log_file, \"Buffer has %u bytes, %u bytes left to fill block.\\n\", bytes_have, bytes_left);\n    if (length >= bytes_left)\n    {\n      if (log_file) fprintf(log_file, \"Copying %u bytes to complete buffer block from data %p\\n\", bytes_left, (void*)data);\n      memcpy(((uint8_t *)ctx->buffer) + bytes_have, data, bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform(ctx->H, ctx->buffer);\n      bytes_have = 0;\n      if (log_file) fprintf(log_file, \"Block processed, remaining length %zu\\n\", length);\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {\n    if (log_file) fprintf(log_file, \"Processing full block from data %p, length %zu\\n\", (void*)data, length);\n    md5_transform(ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {\n    if (log_file) fprintf(log_file, \"Copying remaining %zu bytes to buffer at offset %u\\n\", length, bytes_have);\n    memcpy(((uint8_t *)ctx->buffer) + bytes_have, data, length);\n  }\n\n  if (log_file) fclose(log_file);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits causing out-of-bounds accesses via string.h functions such as memcpy by ensuring that the size arguments do not exceed the actual object sizes to which the pointers point. In the provided code, memcpy is called in two places copying length bytes from the data pointer and in another copying bytes_left from data. The agent's scenario claims a violation if length exceeds the size of the data buffer, i.e., if the caller passes a length larger than the actual size of the data array, causing memcpy to access beyond data's bounds. However, this is a violation fundamentally caused by incorrect or unsafe inputs from the caller, not by the code's internal logic. The MHD_MD5_update function correctly handles buffer offsets and block sizes for its internal buffer (ctx->buffer). It copies at most the buffer capacity (MD5_BLOCK_SIZE bytes) for its internal buffer. The only safety requirement here is that the caller must guarantee that the data pointer points to at least length bytes. Since memcpy is called with length, the function assumes that the caller's parameters are valid. MISRA Rule 21.17 applies to ensure calls to string functions are safe in terms of the function's own pointers and lengths. It does not require checking arbitrary external assumptions about parameter validity beyond what the function itself manages. Therefore, the code itself does not internally cause accesses beyond the bounds of the objects referenced by the pointer parameters used in memcpy. The agent's scenario is essentially about the caller violating the contract by passing a length too large. This is not a violation by the function\u2019s use of string functions per se. Consequently, the agent's report that MHD_MD5_update violates Rule 21.17 is not correct. Also, the test code provided to confirm the scenario failed to compile and thus does not provide evidence demonstrating the violation within the function itself."
}