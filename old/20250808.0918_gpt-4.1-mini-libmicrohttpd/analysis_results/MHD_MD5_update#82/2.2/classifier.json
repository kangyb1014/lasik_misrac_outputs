{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_MD5_update code that contains useful probe functions that print useful logs to a file \"/tmp/logs/658.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_MD5_update as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_MD5_update:\n```c\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_MD5_update:\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    memcpy (X, M, sizeof(X));\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n}\n...\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n</additional code>\nJudge whether the above MHD_MD5_update code violates the rule 2.2 or not.",
  "is_rule_violated": false,
  "scenario": "The provided MHD_MD5_update function does not contain operations that would be considered dead code under MISRA C 2023 Rule 2.2. Each operation contributes to the function's behavior in updating the MD5 context with new data and ensures proper state management. There are no operations whose removal would not affect program behaviour, such as redundant computations or assignments that have no effect on outputs or state beyond the function scope. The early return on length==0 is a valid shortcut and not dead code, initialization and copying operations are necessary, and all loops and conditional branches perform meaningful work.",
  "test_code": ""
}