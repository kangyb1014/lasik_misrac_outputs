{
  "user_message": "An agent A claimed that the following ws_receive_frame code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of ws_receive_frame.\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The pointer parameter 'unsigned char *frame' points to non-const data, even though the function 'ws_receive_frame' does not modify the data pointed to by 'frame'. Therefore, 'frame' should be a pointer to const-qualified type ('const unsigned char *frame') to comply with MISRA C 2023 Rule 8.13.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic unsigned char *\nws_receive_frame(unsigned char *frame, ssize_t *length, int *type)\n{\n  FILE *log = fopen(\"/tmp/logs/27.txt\", \"a\");\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  // Define constants locally to fix undeclared identifier issue\n  const unsigned char WS_FIN = 0x80;\n  const unsigned char WS_OPCODE_TEXT_FRAME = 0x01;\n  const unsigned char WS_OPCODE_CON_CLOSE_FRAME = 0x08;\n\n  msg = NULL;\n  if(frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    fprintf(log, \"Entered text frame processing. flength= %u\\n\", flength);\n    if(flength == 126)\n    {\n      idx_first_mask = 4;\n      fprintf(log, \"Extended payload length indicator 126 detected. idx_first_mask= %u\\n\", idx_first_mask);\n    }\n    else if(flength == 127)\n    {\n      idx_first_mask = 10;\n      fprintf(log, \"Extended payload length indicator 127 detected. idx_first_mask= %u\\n\", idx_first_mask);\n    }\n    idx_first_data = (unsigned char)(idx_first_mask + 4);\n    data_length = (size_t)*length - idx_first_data;\n    fprintf(log, \"Data length calculated as %zu\\n\", data_length);\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc(data_length + 1);\n    if(NULL != msg)\n    {\n      for(i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t)data_length;\n      msg[j] = '\\0';\n      fprintf(log, \"Message extracted and unmasked. Length= %zd\\n\", *length);\n    }\n    else\n    {\n      fprintf(log, \"Memory allocation failed for message.\\n\");\n    }\n  }\n  else if(frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    fprintf(log, \"Close frame received.\\n\");\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n    fprintf(log, \"Other frame received with type= %d\\n\", *type);\n  }\n\n  fclose(log);\n  return msg;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 encourages using pointers to const-qualified types when the pointed-to object is not modified by the function. In the provided code, the pointer parameter 'unsigned char *frame' is used purely for reading data; the code does not modify any data through this pointer. Therefore, from a MISRA perspective, it would be preferable to declare the parameter as 'const unsigned char *frame' to indicate that the function does not modify the data pointed to by 'frame'. This change would enhance code safety and intent clarity, aligning with Rule 8.13.\n\nRegarding the test code failure, it is unrelated to the correctness of the rule violation report. The reported issue is conceptual and based on the code as presented, not dependent on the compilation or runtime behavior of the test wrapper.\n\nThus, the report by agent A that the function violates MISRA C 2023 Rule 8.13 by not using a pointer to const-qualified type for a non-modified data buffer is justified and correct."
}