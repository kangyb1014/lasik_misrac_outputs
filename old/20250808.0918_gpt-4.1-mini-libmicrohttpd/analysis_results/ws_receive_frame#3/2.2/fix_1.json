{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  FILE *log = fopen(\"/tmp/logs/26.txt\", \"a\");\n  if (log != NULL) {\n    fprintf(log, \"Entering ws_receive_frame\\n\");\n  }\n\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    if (log != NULL) {\n      fprintf(log, \"mask assigned with frame[1]=%u at line %d\\n\", mask, __LINE__);\n    }\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n      if (log != NULL) {\n        fprintf(log, \"flength==126, idx_first_mask set to 4 at line %d\\n\", __LINE__);\n      }\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n      if (log != NULL) {\n        fprintf(log, \"flength==127, idx_first_mask set to 10 at line %d\\n\", __LINE__);\n      }\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    if (log != NULL) {\n      fprintf(log, \"idx_first_data calculated as %u at line %d\\n\", idx_first_data, __LINE__);\n    }\n    data_length = (size_t) *length - idx_first_data;\n    if (log != NULL) {\n      fprintf(log, \"data_length computed as %zu at line %d\\n\", data_length, __LINE__);\n    }\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (msg != NULL)\n    {\n      if (log != NULL) {\n        fprintf(log, \"Allocated message buffer of size %zu at line %d\\n\", data_length+1, __LINE__);\n      }\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n        if (log != NULL) {\n          fprintf(log, \"msg[%d] decoded as %u at index frame[%d] ^ masks[%d] at line %d\\n\", j, msg[j], i, j % 4, __LINE__);\n        }\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n      if (log != NULL) {\n        fprintf(log, \"Final message length set to %zd at line %d\\n\", *length, __LINE__);\n        fprintf(log, \"Message null-terminated at position %d at line %d\\n\", j, __LINE__);\n      }\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    if (log != NULL) {\n      fprintf(log, \"Received CON_CLOSE_FRAME at line %d\\n\", __LINE__);\n    }\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n    if (log != NULL) {\n      fprintf(log, \"Other frame type received: %d at line %d\\n\", *type, __LINE__);\n    }\n  }\n\n  if (log != NULL) {\n    fprintf(log, \"Exiting ws_receive_frame\\n\");\n    fclose(log);\n  }\n\n  return msg;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmptbs5ir7k/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of ws_receive_frame as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstatic unsigned char WS_FIN = 0x80;\nstatic unsigned char WS_OPCODE_TEXT_FRAME = 0x01;\nstatic unsigned char WS_OPCODE_CON_CLOSE_FRAME = 0x08;\n\nstatic unsigned char *\nws_receive_frame(unsigned char *frame, ssize_t *length, int *type)\n{\n  FILE *log = fopen(\"/tmp/logs/26.txt\", \"a\");\n  if (log != NULL) {\n    fprintf(log, \"Entering ws_receive_frame\\n\");\n  }\n\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    if (log != NULL) {\n      fprintf(log, \"mask assigned with frame[1]=%u at line %d\\n\", mask, __LINE__);\n    }\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n      if (log != NULL) {\n        fprintf(log, \"flength==126, idx_first_mask set to 4 at line %d\\n\", __LINE__);\n      }\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n      if (log != NULL) {\n        fprintf(log, \"flength==127, idx_first_mask set to 10 at line %d\\n\", __LINE__);\n      }\n    }\n    idx_first_data = (unsigned char)(idx_first_mask + 4);\n    if (log != NULL) {\n      fprintf(log, \"idx_first_data calculated as %u at line %d\\n\", idx_first_data, __LINE__);\n    }\n    data_length = (size_t)(*length) - idx_first_data;\n    if (log != NULL) {\n      fprintf(log, \"data_length computed as %zu at line %d\\n\", data_length, __LINE__);\n    }\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc(data_length + 1);\n    if (msg != NULL)\n    {\n      if (log != NULL) {\n        fprintf(log, \"Allocated message buffer of size %zu at line %d\\n\", data_length + 1, __LINE__);\n      }\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n        if (log != NULL) {\n          fprintf(log, \"msg[%d] decoded as %u at index frame[%d] ^ masks[%d] at line %d\\n\", j, msg[j], i, j % 4, __LINE__);\n        }\n      }\n      *length = (ssize_t)data_length;\n      msg[j] = '\\0';\n      if (log != NULL) {\n        fprintf(log, \"Final message length set to %zd at line %d\\n\", *length, __LINE__);\n        fprintf(log, \"Message null-terminated at position %d at line %d\\n\", j, __LINE__);\n      }\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n    if (log != NULL) {\n      fprintf(log, \"Received CON_CLOSE_FRAME at line %d\\n\", __LINE__);\n    }\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n    if (log != NULL) {\n      fprintf(log, \"Other frame type received: %d at line %d\\n\", *type, __LINE__);\n    }\n  }\n\n  if (log != NULL) {\n    fprintf(log, \"Exiting ws_receive_frame\\n\");\n    fclose(log);\n  }\n\n  return msg;\n}\n",
  "explanation": "The provided code failed to compile likely because several constants (WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME) were not defined, and header files were missing which made the code incomplete for compilation. The build errors shown are unrelated to the code itself but rather related to the build environment (missing makeinfo), so they do not prevent the code from compiling if built properly.\n\nTo fix the code compilation, I have:\n- Added necessary #include directives: <stdio.h>, <stdlib.h>, and <unistd.h> to get definitions for FILE, malloc, and ssize_t.\n- Defined WS_FIN, WS_OPCODE_TEXT_FRAME, and WS_OPCODE_CON_CLOSE_FRAME constants as unsigned char variables at the top, with values matching typical WebSocket frame header bits.\n\nNo other logic changes were made to preserve the original functionality exactly. This makes the code self-contained and compilable as a standalone function passing the constraints."
}