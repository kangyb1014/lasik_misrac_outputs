{
  "user_message": "An agent A claimed that the following post_process_urlencoded code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of post_process_urlencoded.\n```c\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      /* initial phase */\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: (no key)'=' */\n        /* Empty key with value */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* Case: (no key)'&' */\n        /* Empty key without value */\n        poff++;\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: (no key)'\\n' or (no key)'\\r' */\n        pp->state = PP_Done;\n        poff++;\n        break;\n      default:\n        /* normal character, key start, advance! */\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      /* key phase */\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: 'key=' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        /* Case: 'key&' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        /* Case: 'key\\n' or 'key\\r' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        /* No advance here, 'PP_Done' will be selected by next 'PP_Init' phase */\n        pp->state = PP_Callback;\n        break;\n      default:\n        /* normal character, advance! */\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        /* case 'key==' */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* case 'value&' */\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: 'value\\n' or 'value\\r' */\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback; /* No poff advance here to set PP_Done in the next iteration */\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        /* character, may be part of escaping */\n        poff++;\n        continue;\n      default:\n        /* normal character, no more escaping! */\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      /* unexpected data at the end, fail! */\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            /* key too long, cannot parse! */\n            pp->state = PP_Error;\n            continue;\n          }\n          /* compute key, if we have not already */\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n#ifdef _DEBUG\n      else\n        mhd_assert (0 != pp->buffer_pos);\n#endif /* _DEBUG */\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    case PP_NextBoundary:\n    case PP_ProcessEntryHeaders:\n    case PP_PerformCheckMultipart:\n    case PP_ProcessValueToBoundary:\n    case PP_PerformCleanup:\n    case PP_Nested_Init:\n    case PP_Nested_PerformMarking:\n    case PP_Nested_ProcessEntryHeaders:\n    case PP_Nested_ProcessValueToBoundary:\n    case PP_Nested_PerformCleanup:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n\n  /* save remaining data for next iteration */\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len); /* it must be always non-zero here */\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    /* compute key, if we have not already */\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation of MISRA C 2023 Rule 21.17 occurs if the memcpy function copies data beyond the bounds of the destination buffer kbuf in the PP_Callback or the ending part of the function when copying start_key and end_key data into kbuf, specifically if pp->buffer_pos + key_len exceeds pp->buffer_size, which in current code leads to PP_Error state to avoid overflow. However, there is a subtle risk that boundary checks might be insufficient or race conditions might arise if buffer_pos or buffer_size are manipulated unexpectedly, potentially causing out-of-bounds accesses in memcpy. The code contains explicit checks to prevent this; however, if these checks are bypassed or incorrect, the memcpy calls could read or write beyond buffer bounds, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n  FILE *log_file = fopen(\"/tmp/logs/103.txt\", \"a\");\n\n  if (log_file == NULL)\n    return MHD_NO;\n\n  // Fix: Replace mhd_assert calls with if checks and log + abort\n  if (PP_Callback == pp->state) {\n    fprintf(log_file, \"Assertion failed: PP_Callback != pp->state\\n\");\n    fclose(log_file);\n    abort();\n  }\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    fprintf(log_file, \"State: %d, poff: %zu, buffer_pos: %zu\\n\", pp->state, poff, pp->buffer_pos);\n    switch (pp->state)\n    {\n    case PP_Error:\n      abort ();\n      break;\n    case PP_Init:\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        fprintf(log_file, \"Empty key '=' encountered, setting error state.\\n\");\n        continue;\n      case '&':\n        poff++;\n        fprintf(log_file, \"Empty key '&' skipped.\\n\");\n        continue;\n      case '\\n':\n      case '\\r':\n        pp->state = PP_Done;\n        poff++;\n        break;\n      default:\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        continue;\n      }\n      break;\n    case PP_ProcessKey:\n      switch (post_data[poff])\n      {\n      case '=':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        if (0 != poff)\n          end_key = &post_data[poff];\n        pp->state = PP_Callback;\n        break;\n      default:\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      break;\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi || (start_value != end_value))\n          pp->state = PP_Callback;\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        end_value = &post_data[poff];\n        if (pp->must_ikvi || (start_value != end_value))\n          pp->state = PP_Callback;\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':\n        poff++;\n        continue;\n      default:\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break;\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      if (NULL != end_key && start_key != NULL) {\n        const size_t key_len = (size_t) (end_key - start_key);\n        fprintf(log_file, \"Processing key with length %zu, buffer_pos %zu, buffer_size %zu\\n\",\n                key_len, pp->buffer_pos, pp->buffer_size);\n        if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n             (pp->buffer_pos + key_len < pp->buffer_pos) )\n        {\n          fprintf(log_file, \"Buffer overflow risk: setting PP_Error state\\n\");\n          pp->state = PP_Error;\n          continue;\n        }\n        memcpy(&kbuf[pp->buffer_pos], start_key, key_len);\n        pp->buffer_pos += key_len;\n        start_key = NULL;\n        end_key = NULL;\n        pp->must_unescape_key = true;\n      }\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0';\n        MHD_unescape_plus(kbuf);\n        MHD_http_unescape(kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp, start_value, end_value, NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    default:\n      // Replace MHD_PANIC with logging and abort\n      fprintf(log_file, \"internal error.\\n\");\n      fclose(log_file);\n      abort();\n    }\n    // Replace mhd_assert with if checks\n    if ((end_key != NULL) && (start_key == NULL)) {\n      fprintf(log_file, \"Assertion failed: end_key != NULL implies start_key != NULL\\n\");\n      fclose(log_file);\n      abort();\n    }\n    if ((end_value != NULL) && (start_value == NULL)) {\n      fprintf(log_file, \"Assertion failed: end_value != NULL implies start_value != NULL\\n\");\n      fclose(log_file);\n      abort();\n    }\n  }\n\n  if (PP_Callback == pp->state) {\n    fprintf(log_file, \"Assertion failed: PP_Callback != pp->state at end\\n\");\n    fclose(log_file);\n    abort();\n  }\n\n  if (PP_Error == pp->state)\n  {\n    fprintf(log_file, \"Encountered error state, returning MHD_NO\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    if (!((PP_ProcessKey == pp->state) || (NULL != end_key))) {\n      fprintf(log_file, \"Assertion failed near processing leftover key\\n\");\n      fclose(log_file);\n      abort();\n    }\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    if (end_key < start_key) {\n      fprintf(log_file, \"Assertion failed: end_key < start_key\\n\");\n      fclose(log_file);\n      abort();\n    }\n    key_len = (size_t) (end_key - start_key);\n    if (0 == key_len) {\n      fprintf(log_file, \"Assertion failed: key_len is zero\\n\");\n      fclose(log_file);\n      abort();\n    }\n    fprintf(log_file, \"Copying leftover key part, length %zu, buffer_pos %zu, buffer_size %zu\\n\",\n            key_len, pp->buffer_pos, pp->buffer_size);\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      fprintf(log_file, \"Buffer overflow risk detected when copying leftover key, setting error state\\n\");\n      pp->state = PP_Error;\n      fclose(log_file);\n      return MHD_NO;\n    }\n    memcpy(&kbuf[pp->buffer_pos], start_key, key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n\n  if ( (NULL != start_value) && (PP_ProcessValue == pp->state) )\n  {\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0';\n      MHD_unescape_plus(kbuf);\n      MHD_http_unescape(kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) && (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp, start_value, end_value, last_escape);\n    pp->must_ikvi = false;\n  }\n\n  if (PP_Error == pp->state)\n  {\n    fprintf(log_file, \"Error state after processing leftover data, returning MHD_NO\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n  fclose(log_file);\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 requires that the use of string handling functions like memcpy must not result in accesses beyond the bounds of the involved objects. In the provided code, before each use of memcpy to copy data into the buffer kbuf, there are explicit checks ensuring that the sum of pp->buffer_pos and the length to be copied (key_len) does not exceed pp->buffer_size. These conditions effectively prevent buffer overflows by setting the state to PP_Error and avoiding the memcpy call when capacity is insufficient. Although agent A suggests a potential subtle risk if these checks are bypassed or if race conditions arise, such scenarios depend on factors outside the code snippet (e.g., concurrent modifications) and are not evidence of a direct violation in the given code as written. The code itself follows MISRA C 2023 Rule 21.17 by properly validating the memcpy parameters and preventing out-of-bounds access. The test code attempting to log or reproduce issues failed to compile and thus did not provide additional verification. Therefore, based on the given source code and analysis, the reported violation is not substantiated."
}