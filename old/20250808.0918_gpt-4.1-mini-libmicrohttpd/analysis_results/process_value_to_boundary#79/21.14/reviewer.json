{
  "user_message": "An agent A claimed that the following process_value_to_boundary code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n.\n</misra_rule>\n<target_code>\nHere is the original code of process_value_to_boundary.\n```c\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n        break;\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      /* can check boundary */\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        /* no boundary, \"\\r\\n--\" is part of content, skip */\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        /* boundary found, process until newline then\n           skip boundary and go back to init */\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;             /* skip boundary as well */\n        buf[newline] = '\\0';\n        break;\n      }\n    }\n    else\n    {\n      /* cannot check for boundary, process content that\n         we have and check again later; except, if we have\n         no content, abort (out of memory) */\n      if ( (0 == newline) &&\n           (pp->buffer_pos == pp->buffer_size) )\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      break;\n    }\n  }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (pp->must_ikvi) ||\n         (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    pp->state = PP_Error;\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n  return MHD_YES;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function process_value_to_boundary uses the standard library function memcmp to compare portions of character buffers with constant strings (\"\\r\\n--\" and the boundary). This includes comparing buffer content to null-terminated strings, which violates MISRA C 2023 Rule 21.14, as memcmp shall not be used to compare null-terminated strings.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  FILE *log_file = fopen(\"/tmp/logs/638.txt\", \"a\");\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n\n  if (log_file != NULL) {\n    fprintf(log_file, \"Entered process_value_to_boundary\\n\");\n    fprintf(log_file, \"buffer_pos=%zu, buffer_size=%zu\\n\", pp->buffer_pos, pp->buffer_size);\n  }\n\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline], '\\r', pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        if (log_file != NULL) {\n          fprintf(log_file, \"memchr returned NULL, newline set to %zu\\n\", newline);\n        }\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\", &buf[newline], 4))\n      {\n        if (log_file != NULL) {\n          fprintf(log_file, \"memcmp found boundary prefix at newline=%zu\\n\", newline);\n        }\n        break;\n      }\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      if (0 != memcmp (&buf[newline + 4], boundary, blen))\n      {\n        newline += 4;\n        if (log_file != NULL) {\n          fprintf(log_file, \"Boundary not matched. Skipping to newline=%zu\\n\", newline);\n        }\n        continue;\n      }\n      else\n      {\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;\n        buf[newline] = '\\0';\n        if (log_file != NULL) {\n          fprintf(log_file, \"Boundary found at newline=%zu. State updated\\n\", newline);\n        }\n        break;\n      }\n    }\n    else\n    {\n      if ( (0 == newline) && (pp->buffer_pos == pp->buffer_size) )\n      {\n        pp->state = PP_Error;\n        if (log_file != NULL) {\n          fprintf(log_file, \"Buffer full with no content. Aborting with error state\\n\");\n        }\n        if (log_file != NULL) {\n          fclose(log_file);\n        }\n        return MHD_NO;\n      }\n      if (log_file != NULL) {\n        fprintf(log_file, \"Cannot check full boundary yet. Breaking to wait for more data\\n\");\n      }\n      break;\n    }\n  }\n  if ( ((pp->must_ikvi) || (0 != newline)) && (MHD_NO == pp->ikvi(pp->cls, MHD_POSTDATA_KIND, pp->content_name, pp->content_filename, pp->content_type, pp->content_transfer_encoding, buf, pp->value_offset, newline)) )\n  {\n    pp->state = PP_Error;\n    if (log_file != NULL) {\n      fprintf(log_file, \"ikvi callback indicates error. State set to PP_Error\\n\");\n      fclose(log_file);\n    }\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n\n  if (log_file != NULL) {\n    fprintf(log_file, \"Exiting process_value_to_boundary successfully. New value_offset=%lu\\n\", (unsigned long)pp->value_offset);\n    fclose(log_file);\n  }\n\n  return MHD_YES;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.14 states that the standard library function memcmp shall not be used to compare null-terminated strings. In the provided code, memcmp is used to compare fixed-length memory areas against constant strings such as \"\\r\\n--\" with an explicit length of 4, and the variable \"boundary\" with its length \"blen\". These comparisons are performed over specified lengths and not relying on null termination. Specifically, memcmp compares a fixed number of bytes, not null-terminated strings, which is allowed since memcmp operates on raw memory blocks rather than relying on string semantics. Therefore, the use of memcmp here does not violate Rule 21.14, as the function is not being used to compare null-terminated strings but rather byte sequences with explicitly specified lengths. The violation claim is incorrect."
}