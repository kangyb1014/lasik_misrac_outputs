{
  "user_message": "An agent A claimed that the following MHD_create_named_thread_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_named_thread_.\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses compiler-specific extensions indicated by preprocessor macros such as HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD and HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI, which are non-standard extensions for setting thread names via pthread attributes. These functions like pthread_attr_setname_np are POSIX threads extensions and are not part of the C standard language, constituting language extensions as per compiler documentation.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n#include <stdio.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdlib.h>\n\ntypedef void *(*MHD_THREAD_START_ROUTINE_)(void *);\n\ntypedef struct {\n    pthread_t handle;\n    int ID;\n} MHD_thread_handle_ID_;\n\nvoid MHD_thread_handle_ID_set_invalid_(MHD_thread_handle_ID_ *h) {\n    FILE *f = fopen(\"/tmp/logs/248.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"Set invalid called for thread handle %p\\n\", (void *)h);\n        fclose(f);\n    }\n}\n\nvoid MHD_thread_handle_ID_set_native_handle_(MHD_thread_handle_ID_ *h, pthread_t native) {\n    FILE *f = fopen(\"/tmp/logs/248.txt\", \"a\");\n    if (f) {\n        fprintf(f, \"Set native handle called: %lu\\n\", (unsigned long)native);\n        fclose(f);\n    }\n    h->handle = native;\n}\n\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n    int res;\n    pthread_attr_t attr;\n    pthread_t new_tid;\n    pthread_t *const new_tid_ptr = &new_tid;\n\n    FILE *logf = fopen(\"/tmp/logs/248.txt\", \"a\");\n    if (logf) {\n        fprintf(logf, \"MHD_create_named_thread_: started with thread_name=%s\\n\", thread_name);\n    }\n\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n        /*\n         * Since no specific platform macros are defined,\n         * skip pthread_attr_setname_np to ensure compilation.\n         * Setting thread name can be done after thread creation if needed.\n         */\n\n        if ((0 != stack_size) )\n        {\n            if (logf) fprintf(logf, \"Setting stack size: %zu\\n\", stack_size);\n            res = pthread_attr_setstacksize (&attr, stack_size);\n        }\n        if (0 == res)\n        {\n            if (logf) fprintf(logf, \"Creating pthread\\n\");\n            res = pthread_create (new_tid_ptr, &attr, start_routine, arg);\n        }\n        pthread_attr_destroy (&attr);\n    }\n    if (0 != res)\n    {\n        errno = res;\n        if (logf) fprintf(logf, \"Thread creation failed with res: %d\\n\", res);\n        MHD_thread_handle_ID_set_invalid_ (handle_id);\n    }\n    else\n        MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n\n    if (logf) fclose(logf);\n\n    return ! res;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions should not be used, explicitly referring to compiler-specific language extensions, not to the use of platform-specific or library-specific APIs such as POSIX threads. The code uses POSIX threads API functions, including pthread_attr_setname_np variants, which are non-standard library functions but do not constitute language extensions. They are part of the POSIX threading library on various platforms and are therefore standard library extensions, not compiler language extensions. The use of preprocessor macros (e.g., HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD) to conditionally compile code for different POSIX variants does not imply the use of language extensions. Consequently, the code does not violate MISRA C 2023 Rule 1.2 since it does not employ compiler-specific language extensions but instead uses standard or POSIX threading APIs. Therefore, agent A\u2019s claim is incorrect."
}