{
  "user_message": "An agent A claimed that the following mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n.\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_proc_cpu_count_cpuset_getaffinity_.\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ contains conditional compilation and multiple conditional branches that may cause some code blocks to never be executed, resulting in unreachable code. For example, if HAVE_CPUSET_GETAFFINITY is not defined, the entire main code body is excluded, leaving only the initial assignment and return statements. Similarly, the conditionals inside the code can produce branches that are not reachable depending on the runtime conditions. Hence, there's a possibility of unreachable code depending on the build configuration or runtime conditions violating MISRA C 2023 Rule 2.1.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  FILE *logf = fopen(\"/tmp/logs/137.txt\", \"w\");\n  if (logf == NULL) return -1;\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  fprintf(logf, \"Entered HAVE_CPUSET_GETAFFINITY block\\n\");\n  if (ret <= 0)\n  {\n    fprintf(logf, \"ret <= 0, proceeding with cpuset_getaffinity\\n\");\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n      fprintf(logf, \"cpuset_getaffinity succeeded\\n\");\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n      fprintf(logf, \"CPU_COUNT returned %d\\n\", ret);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      fprintf(logf, \"Counted CPUs without CPU_COUNT, ret = %d\\n\", ret);\n      if (ret == 0)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    } else {\n      fprintf(logf, \"cpuset_getaffinity failed\\n\");\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (ret <= 0)\n  {\n    fprintf(logf, \"ret <= 0, entering HAVE_CPU_COUNT_S block\\n\");\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (p_mask != NULL)\n    {\n      fprintf(logf, \"Allocated mask with size %zu bytes\\n\", mask_size_bytes);\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n        fprintf(logf, \"cpuset_getaffinity succeeded in HAVE_CPU_COUNT_S block\\n\");\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n        fprintf(logf, \"CPU_COUNT_S returned %d\\n\", ret);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n        fprintf(logf, \"CPU_COUNT_S returned %d\\n\", ret);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      } else {\n        fprintf(logf, \"cpuset_getaffinity failed in HAVE_CPU_COUNT_S block\\n\");\n      }\n      CPU_FREE (p_mask);\n    } else {\n      fprintf(logf, \"Failed to allocate mask\\n\");\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#else\n  fprintf(logf, \"HAVE_CPUSET_GETAFFINITY not defined, skipping main affinity code\\n\");\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (ret <= 0)\n  {\n    fprintf(logf, \"ret <= 0, returning -1\\n\");\n    fclose(logf);\n    return -1;\n  }\n  fprintf(logf, \"Returning ret = %d\\n\", ret);\n  fclose(logf);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 2.1 prohibits unreachable code within a project. The given code uses conditional compilation (e.g., #if defined(HAVE_CPUSET_GETAFFINITY)) to selectively include or exclude large portions of code based on build-time macros. However, conditional compilation itself does not constitute unreachable code by MISRA standards. Unreachable code refers to code that can never be executed at runtime regardless of configuration\u2014for example, code after a return statement or code within branches that are logically never taken.\n\nIn this case, if HAVE_CPUSET_GETAFFINITY is not defined, large parts of the function are not compiled at all, but the code does not contain any unreachable statements within the compiled code. Similarly, the branches inside (such as if statements depending on runtime conditions) may or may not execute depending on actual execution paths, and hence are not unreachable code.\n\nTherefore, the claim that this function contains unreachable code in violation of MISRA C 2023 Rule 2.1 is not correct\u2014the use of conditional compilation to exclude code at build time is standard practice and not considered unreachable code under MISRA. The agent's attempt to demonstrate the violation by runtime logging is irrelevant to Rule 2.1 as it deals with static unreachable code, not code excluded by build configurations or code path conditions at runtime.\n\nHence, the report by agent A is incorrect."
}