{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified iterate_post code that contains useful probe functions that print useful logs to a file \"/tmp/logs/431.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of iterate_post as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of iterate_post:\n```c\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;               /* Unused. Silent compiler warning. */\n  (void) filename;           /* Unused. Silent compiler warning. */\n  (void) content_type;       /* Unused. Silent compiler warning. */\n  (void) transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void) off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring;\n      answerstring = malloc (MAXANSWERSIZE);\n      if (! answerstring)\n        return MHD_NO;\n\n      snprintf (answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n      con_info->answerstring = answerstring;\n    }\n    else\n      con_info->answerstring = NULL;\n\n    return MHD_NO;\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function iterate_post:\n#define MAXNAMESIZE 20\n...\n#define MAXANSWERSIZE 512\n...\n#define GREETINGPAGE \"<html><body><h1>Welcome, %s!</center></h1></body></html>\"\n...\nstruct connection_info_struct\n{\n  int connectiontype;\n  char *answerstring;\n  struct MHD_PostProcessor *postprocessor;\n}\n</additional code>\nJudge whether the above iterate_post code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "The call to snprintf with GREETINGPAGE and data does not ensure that data is a null-terminated string within bounds, potentially causing snprintf to read beyond the bounds of data and violating Rule 21.17.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\n#define MAXNAMESIZE 20\n#define MAXANSWERSIZE 512\n#define GREETINGPAGE \"<html><body><h1>Welcome, %s!</center></h1></body></html>\"\n\nstruct connection_info_struct\n{\n  int connectiontype;\n  char *answerstring;\n  void *postprocessor;\n};\n\nstatic enum MHD_Result\niterate_post (void *coninfo_cls, int kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void) kind;\n  (void) filename;\n  (void) content_type;\n  (void) transfer_encoding;\n  (void) off;\n\n  FILE *log = fopen(\"/tmp/logs/431.txt\", \"a\");\n  if(log == NULL) return MHD_NO;\n\n  fprintf(log, \"iterate_post called with key='%s', size=%zu\\n\", key, size);\n\n  if (0 == strcmp (key, \"name\"))\n  {\n    if ((size > 0) && (size <= MAXNAMESIZE))\n    {\n      char *answerstring = malloc(MAXANSWERSIZE);\n      if (!answerstring)\n      {\n        fprintf(log, \"malloc failed\\n\");\n        fclose(log);\n        return MHD_NO;\n      }\n\n      // Log data content in hex up to 'size'\n      fprintf(log, \"Data buffer: \");\n      for(size_t i=0; i<size; ++i)\n      {\n        fprintf(log, \"%02X \", (unsigned char)data[i]);\n      }\n      fprintf(log, \"\\n\");\n\n      // Attempt to copy using snprintf directly with data\n      // Potentially reads beyond data[size-1] if data is not null-terminated\n      snprintf(answerstring, MAXANSWERSIZE, GREETINGPAGE, data);\n\n      con_info->answerstring = answerstring;\n\n      fprintf(log, \"Formatted answerstring: %s\\n\", answerstring);\n      fprintf(log, \"Potential buffer over-read on 'data' due to lack of null-termination.\\n\");\n    }\n    else\n    {\n      con_info->answerstring = NULL;\n      fprintf(log, \"Size out of bounds or zero, answerstring set to NULL\\n\");\n    }\n\n    fclose(log);\n    return MHD_NO;\n  }\n\n  fclose(log);\n  return MHD_YES;\n}\n"
}