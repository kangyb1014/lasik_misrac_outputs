{
  "user_message": "An agent A claimed that the following MHD_send_data_ code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_data_.\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function MHD_send_data_ contains code segments within the HTTPS_SUPPORT conditional compilation block that are never executed if HTTPS_SUPPORT is not defined. For example, the entire block under if (tls_conn) is effectively dead code (removal would not affect program behavior) when HTTPS_SUPPORT is not defined. Similarly, the 'else' branch for non-TLS connections executes, but the HTTPS_SUPPORT related TLS code sections remain unused and effectively dead. Hence, dead code exists in the form of conditionally compiled code that is never executed given the build configuration, violating MISRA C 2023 Rule 2.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nssize_t MHD_send4_(MHD_socket s, const char *buffer, size_t buffer_size, int flags)\n{\n    FILE *fp = fopen(\"/tmp/logs/338.txt\", \"a\");\n    if(fp) {\n        fprintf(fp, \"MHD_send4_ called: socket=%d, buffer_size=%zu, flags=%d\\n\", s, buffer_size, flags);\n        fclose(fp);\n    }\n    return (ssize_t)buffer_size; // Simulate successful send\n}\nint MHD_socket_get_error_(void) { return 0; }\nbool MHD_SCKT_ERR_IS_EAGAIN_(int err) { return false; }\nbool MHD_SCKT_ERR_IS_EINTR_(int err) { return false; }\nbool MHD_SCKT_ERR_IS_REMOTE_DISCNN_(int err) { return false; }\nbool MHD_SCKT_ERR_IS_(int err, int code) { return false; }\nbool MHD_SCKT_ERR_IS_LOW_RESOURCES_(int err) { return false; }\n\nstatic void pre_send_setopt(struct MHD_Connection *connection, bool plain_send, bool push_data)\n{\n    FILE *fp = fopen(\"/tmp/logs/338.txt\", \"a\");\n    if(fp) {\n        fprintf(fp, \"pre_send_setopt called: plain_send=%d, push_data=%d\\n\", plain_send, push_data);\n        fclose(fp);\n    }\n}\nstatic void post_send_setopt(struct MHD_Connection *connection, bool plain_send_next, bool push_data)\n{\n    FILE *fp = fopen(\"/tmp/logs/338.txt\", \"a\");\n    if(fp) {\n        fprintf(fp, \"post_send_setopt called: plain_send_next=%d, push_data=%d\\n\", plain_send_next, push_data);\n        fclose(fp);\n    }\n}\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n    MHD_socket s = connection->socket_fd;\n    ssize_t ret;\n\n#ifndef HTTPS_SUPPORT\n    const bool tls_conn = false;\n#else\n    const bool tls_conn = (connection->daemon->options & MHD_USE_TLS) != 0;\n#endif\n\n    if ( (MHD_INVALID_SOCKET == s) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n    {\n        FILE *fp = fopen(\"/tmp/logs/338.txt\", \"a\");\n        if(fp) {\n            fprintf(fp, \"Error: invalid socket or connection closed\\n\");\n            fclose(fp);\n        }\n        return MHD_ERR_NOTCONN_;\n    }\n\n    if (buffer_size > SSIZE_MAX)\n    {\n        buffer_size = SSIZE_MAX; /* Max return value */\n        push_data = false; /* Incomplete send */\n    }\n\n    if (tls_conn)\n    {\n        // Dead code path if HTTPS_SUPPORT not defined\n        FILE *fp = fopen(\"/tmp/logs/338.txt\", \"a\");\n        if(fp) {\n            fprintf(fp, \"TLS connection path - dead code if HTTPS_SUPPORT not defined\\n\");\n            fclose(fp);\n        }\n        ret = -1; // Dummy\n    }\n    else\n    {\n        /* plaintext transmission */\n        if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n        {\n            buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n            push_data = false; /* Incomplete send */\n        }\n\n        pre_send_setopt(connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n        ret = MHD_send4_(s, buffer, buffer_size, push_data ? 0 : MSG_MORE);\n#else\n        ret = MHD_send4_(s, buffer, buffer_size, 0);\n#endif\n\n        if (ret < 0)\n        {\n            const int err = MHD_socket_get_error_();\n\n            if (MHD_SCKT_ERR_IS_EAGAIN_(err))\n            {\n#ifdef EPOLL_SUPPORT\n                /* EAGAIN, no longer write-ready */\n                connection->epoll_state &= ~((unsigned int)0x01); /* Example mask */\n#endif\n                return MHD_ERR_AGAIN_;\n            }\n            if (MHD_SCKT_ERR_IS_EINTR_(err))\n                return MHD_ERR_AGAIN_;\n            if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_(err))\n                return MHD_ERR_CONNRESET_;\n            if (MHD_SCKT_ERR_IS_(err, 0)) /* Dummy */\n                return MHD_ERR_PIPE_;\n            if (MHD_SCKT_ERR_IS_(err, 0))\n                return MHD_ERR_OPNOTSUPP_;\n            if (MHD_SCKT_ERR_IS_(err, 0))\n                return MHD_ERR_NOTCONN_;\n            if (MHD_SCKT_ERR_IS_(err, 0))\n                return MHD_ERR_INVAL_;\n            if (MHD_SCKT_ERR_IS_LOW_RESOURCES_(err))\n                return MHD_ERR_NOMEM_;\n            if (MHD_SCKT_ERR_IS_(err, 0))\n                return MHD_ERR_BADF_;\n            return MHD_ERR_NOTCONN_;\n        }\n\n#ifdef EPOLL_SUPPORT\n        else if (buffer_size > (size_t) ret)\n            connection->epoll_state &= ~((unsigned int)0x01); /* Example mask */\n#endif\n    }\n\n    if ( (push_data) && (buffer_size == (size_t) ret) )\n        post_send_setopt(connection, (! tls_conn), push_data);\n\n    return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent A claims that the code violates MISRA C 2023 Rule 2.2 because the code within the HTTPS_SUPPORT conditional compilation block is never executed if HTTPS_SUPPORT is not defined, making it dead code. However, Rule 2.2 defines dead code as code that is executed but whose removal would not affect program behavior. Code that is conditionally compiled out (i.e., excluded from compilation via #ifdef/#ifndef directives) is not considered dead code but rather code that is conditionally included or excluded based on configuration. This is a common and acceptable practice to manage features like TLS support, and such code is reachable and executable when the feature is enabled. The scenario described involves code that is simply excluded from the build, not executed and superfluous within a single build. Therefore, the presence of HTTPS_SUPPORT-conditioned code that is omitted when the macro is not defined does not constitute dead code within the same build. Additionally, the failed compilation of the test code does not impact the assessment of the original code compliance with MISRA C 2023 Rule 2.2. Hence, the report is incorrect."
}