{
  "user_message": "An agent A claimed that the following calculate_add_nonce_with_retry code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of calculate_add_nonce_with_retry.\n```c\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function uses memcpy to copy nonce2 into nonce using NONCE_STD_LEN(digest_size) as the length parameter. If the calculated length exceeds the actual bounds of nonce or nonce2 buffers, it will result in buffer overrun, violating Rule 21.17. Specifically, if digest_size returned by digest_get_size(da) is larger than expected or if NONCE_STD_LEN macro expands to a length beyond the allocated size of nonce or nonce2, memcpy will access beyond buffer bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic void mhd_assert(bool condition) {\n  if (!condition) {\n    FILE *f = fopen(\"/tmp/logs/599.txt\", \"a\");\n    if (f) {\n      fprintf(f, \"ASSERT FAILED\\n\");\n      fclose(f);\n    }\n  }\n}\nsize_t strlen(const char *s);\nvoid log_state(const char *msg) {\n  FILE *f = fopen(\"/tmp/logs/599.txt\", \"a\");\n  if (f) {\n    fprintf(f, \"%s\\n\", msg);\n    fclose(f);\n  }\n}\nstatic bool calculate_add_nonce_with_retry(struct MHD_Connection *const connection,\n                                           const char *realm,\n                                           struct DigestAlgorithm *da,\n                                           char *nonce) {\n  const uint64_t timestamp1 = 0; // assuming MHD_monotonic_msec_counter() -> 0 for testing\n  const size_t realm_len = strlen(realm);\n  mhd_assert(!da->hashing);\n\n  log_state(\"Entered calculate_add_nonce_with_retry\");\n\n  if (!calculate_add_nonce(connection, timestamp1, realm, realm_len, da, nonce)) {\n    const size_t digest_size = digest_get_size(da);\n    char nonce2[NONCE_STD_LEN(digest_size) + 1];\n    uint64_t timestamp2 = timestamp1 + 1;\n\n    log_state(\"calculate_add_nonce failed initially, retrying with nonce2\");\n\n    if (!calculate_add_nonce(connection, timestamp2, realm, realm_len, da, nonce2)) {\n      log_state(\"calculate_add_nonce failed on retry\");\n      return false;\n    }\n\n    /* Intentional unsafe memcpy to demonstrate potential buffer overflow */\n    log_state(\"About to memcpy nonce2 to nonce with length exceeding nonce buffer\");\n    memcpy(nonce, nonce2, NONCE_STD_LEN(digest_size));\n    log_state(\"memcpy completed\");\n  }\n  return true;\n}\n\nstatic unsigned int digest_get_size(struct DigestAlgorithm *da) {\n  // Intentionally return a large size to cause oversized memcpy length\n  return 64; // deliberately large\n}\nstatic bool calculate_add_nonce(struct MHD_Connection *const connection,\n                                uint64_t timestamp,\n                                const char *realm,\n                                size_t realm_len,\n                                struct DigestAlgorithm *da,\n                                char *nonce) {\n  return true;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 forbids the use of string handling functions like memcpy in such a way that accesses beyond the bounds of the referenced objects occur. In the reported code, the memcpy copies NONCE_STD_LEN(digest_size) bytes from nonce2 to nonce. The actual bounds of nonce and nonce2 depend on the macro NONCE_STD_LEN and the digest_size returned by digest_get_size(). Since the code relies on the macro and digest_size to be correctly matched to the allocated buffers, if digest_size is larger than expected or if NONCE_STD_LEN expands to a value larger than the buffers allocated to nonce and nonce2, this memcpy can indeed cause buffer overrun. The report correctly points out that this is a potential violation if the inputs are not properly controlled \u2014 in other words, if the size parameters or macro expansions exceed actual array lengths, then buffer overflows can occur. Thus, the code as written takes a risk violating Rule 21.17, relying on external assumptions about buffer sizes. Without stronger safeguards or static guarantees, this is a valid concern and violation. Therefore, Agent A's report is correct as it highlights a real risk of violating Rule 21.17 due to potential out-of-bounds access in memcpy."
}