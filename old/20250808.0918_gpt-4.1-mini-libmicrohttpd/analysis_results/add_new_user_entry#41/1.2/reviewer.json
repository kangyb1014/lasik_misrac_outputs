{
  "user_message": "An agent A claimed that the following add_new_user_entry code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of add_new_user_entry.\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Usage of _MHD_EXTERN before functions MHD_digest_auth_calc_userhash and MHD_digest_auth_calc_userdigest potentially indicates a language extension specific to the compiler environment, such as specifying calling conventions, linkage, or visibility attributes, which are not part of standard C. This constitutes a violation of MISRA C 2023 Rule 1.2 which prohibits language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash(enum MHD_DigestAuthAlgo3 algo3,\n                              const char *username,\n                              const char *realm,\n                              void *userhash_bin,\n                              size_t bin_buf_size)\n{\n  FILE *fp = fopen(\"/tmp/logs/328.txt\", \"a\");\n  if(fp) {\n    fprintf(fp, \"Entered MHD_digest_auth_calc_userhash with algo3=%d, username=%s, realm=%s\\n\", algo3, username, realm);\n    fclose(fp);\n  }\n  return MHD_YES;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n                                const char *username,\n                                const char *realm,\n                                const char *password,\n                                void *userdigest_bin,\n                                size_t bin_buf_size)\n{\n  FILE *fp = fopen(\"/tmp/logs/328.txt\", \"a\");\n  if(fp) {\n    fprintf(fp, \"Entered MHD_digest_auth_calc_userdigest with algo3=%d, username=%s, realm=%s, password=%s\\n\", algo3, username, realm, password);\n    fclose(fp);\n  }\n  return MHD_YES;\n}\n\nstatic int\nadd_new_user_entry(const char *const username,\n                   const char *const password,\n                   const char *const realm,\n                   int allow_area_1,\n                   int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  FILE *fp = fopen(\"/tmp/logs/328.txt\", \"a\");\n  if(fp) {\n    fprintf(fp, \"Entering add_new_user_entry\\n\");\n  }\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used) {\n    if(fp) {\n      fprintf(fp, \"No space left for new entry. user_ids_used=%zu\\n\", user_ids_used);\n      fclose(fp);\n    }\n    return 0; /* No more space to add new entry */\n  }\n\n  entry = user_ids + user_ids_used;\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash(MHD_YES,\n                                        username,\n                                        realm,\n                                        entry->userhash_md5,\n                                        sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest(MHD_YES,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_md5,\n                                          sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash(MHD_YES,\n                                        username,\n                                        realm,\n                                        entry->userhash_sha256,\n                                        sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest(MHD_YES,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_sha256,\n                                          sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash(MHD_YES,\n                                        username,\n                                        realm,\n                                        entry->userhash_sha512_256,\n                                        sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest(MHD_YES,\n                                          username,\n                                          realm,\n                                          password,\n                                          entry->userdigest_sha512_256,\n                                          sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res) {\n    if(fp) {\n      fprintf(fp, \"Digest calculation failed, exiting with failure.\\n\");\n      fclose(fp);\n    }\n    return 0; /* Failure exit point */\n  }\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  if(fp) {\n    fprintf(fp, \"User entry added successfully. user_ids_used=%zu\\n\", user_ids_used);\n    fclose(fp);\n  }\n\n  return 1;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The MISRA C 2023 Rule 1.2 prohibits the use of language extensions that are not part of the standard C language. The scenario provided by agent A points out the usage of _MHD_EXTERN before function definitions as a potential language extension, which could represent compiler-specific attributes or linkage conventions. However, the provided original add_new_user_entry code snippet does not show the use of _MHD_EXTERN anywhere; it is only present in the additional test code that agent A added, which isn't part of the original code under inspection. The original code appears standard and does not include explicit compiler extensions. Moreover, usage of macros like _MHD_EXTERN is common for portability and may be defined as empty or standard linkage specifiers depending on the compiler environment. Unless the original code itself uses language-specific extensions explicitly, merely calling functions that might be declared with such macros elsewhere does not necessarily constitute a violation. Finally, the test code containing _MHD_EXTERN failed to compile, so it cannot be considered a valid reproduction or evidence of an actual violation in the original code. Therefore, the report that the original code violates MISRA C 2023 Rule 1.2 due to language extensions is not correct based on the information provided."
}