{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:Use of the '_MHD_EXTERN' specifier before the function MHD_digest_auth_get_request_info3 indicates a compiler-specific language extension or macro not standard in standard C. This use constitutes a violation of MISRA C 2023 Rule 1.2, which forbids language extensions.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3(struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/32.txt\", \"a\");\n  if (log != NULL)\n  {\n    fprintf(log, \"Entered MHD_digest_auth_get_request_info3\\n\");\n  }\n\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_(connection);\n  if (NULL == params)\n  {\n    if (log != NULL) fprintf(log, \"params is NULL, returning NULL\\n\");\n    if (log) fclose(log);\n    return NULL;\n  }\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type(params);\n  if (log != NULL) fprintf(log, \"uname_type: %d\\n\", (int)uname_type);\n\n  unif_buf_size += get_rq_unames_size(params, uname_type);\n\n  if (params->opaque.value.str != NULL)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (params->realm.value.str != NULL)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_(1, sizeof(struct MHD_DigestAuthInfo) + unif_buf_size);\n\n  if (info == NULL)\n  {\n    if (log) fclose(log);\n    return NULL;\n  }\n\n  unif_buf_ptr = (uint8_t *)(info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n      (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type))\n  {\n    unif_buf_used +=\n      get_rq_uname(params, uname_type,\n                   (struct MHD_DigestAuthUsernameInfo *)info,\n                   unif_buf_ptr + unif_buf_used,\n                   unif_buf_size - unif_buf_used);\n    if (log != NULL) fprintf(log, \"uname processed, unif_buf_used: %zu\\n\", unif_buf_used);\n  }\n  else\n  {\n    info->uname_type = uname_type;\n    if (log != NULL) fprintf(log, \"uname_type missing or invalid, set info->uname_type: %d\\n\", (int)uname_type);\n  }\n\n  if (params->opaque.value.str != NULL)\n  {\n    info->opaque = (char *)(unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z(&params->opaque,\n                                                    info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n    if (log != NULL) fprintf(log, \"opaque processed, length: %zu, buffer used: %zu\\n\", info->opaque_len, unif_buf_used);\n  }\n  if (params->realm.value.str != NULL)\n  {\n    info->realm = (char *)(unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z(&params->realm,\n                                                   info->realm);\n    unif_buf_used += info->realm_len + 1;\n    if (log != NULL) fprintf(log, \"realm processed, length: %zu, buffer used: %zu\\n\", info->realm_len, unif_buf_used);\n  }\n\n  // mhd_assert skips\n\n  info->qop = params->qop;\n  if (log != NULL) fprintf(log, \"qop set to: %d\\n\", info->qop);\n\n  if (params->cnonce.value.str != NULL)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  if (log != NULL) fprintf(log, \"cnonce_len: %zu\\n\", info->cnonce_len);\n\n  nc_res = get_rq_nc(params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n  {\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n    if (log != NULL) fprintf(log, \"nc invalid, set to invalid value\\n\");\n  }\n  else\n  {\n    if (log != NULL) fprintf(log, \"nc valid, value: %u\\n\", info->nc);\n  }\n\n  if (log) fclose(log);\n  return info;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation concerns the use of the macro or specifier '_MHD_EXTERN' preceding the function definition, which agent A claims is a compiler-specific language extension forbidden by MISRA C 2023 Rule 1.2. MISRA C 2023 Rule 1.2 forbids the use of compiler language extensions that are explicitly documented as such and not part of standard C. The identifier '_MHD_EXTERN' is a macro likely defined elsewhere, possibly for linkage or visibility control (e.g., expanding to 'extern' or '__declspec(dllexport)' on Windows). Its use as a macro in itself is not automatically a violation unless it expands to compiler-specific extensions. Without the actual definition of '_MHD_EXTERN', it cannot be concluded definitively that it uses a prohibited compiler extension. The mere presence of a macro before a function is common practice to handle platform/compiler differences and does not necessarily violate Rule 1.2. Furthermore, the test code supplied by agent A failed to compile, providing no evidence that '_MHD_EXTERN' is a prohibited extension. Therefore, the claim that this alone violates MISRA C 2023 Rule 1.2 is unsubstantiated unless the macro expands to non-standard language extensions explicitly. Hence, the report from agent A is not correct, based on the information given."
}