{
  "user_message": "An agent A claimed that the following parse_cookie_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookie_header.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the hdr_len obtained from the header length is larger than the actual buffer size pointed to by hdr, the memcpy call copying hdr_len bytes to cpy may access memory beyond the hdr object bounds, violating Rule 21.17. Specifically, if MHD_lookup_connection_value_n returns hdr_len greater than the actual length of hdr, the memcpy could read beyond hdr's allocated space.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum _MHD_ParseCookie {\n  MHD_PARSE_COOKIE_OK,\n  MHD_PARSE_COOKIE_OK_LAX,\n  MHD_PARSE_COOKIE_MALFORMED,\n  MHD_PARSE_COOKIE_NO_MEMORY\n};\n\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  if (hdr_len > strlen(hdr))\n    hdr_len = strlen(hdr);  // Fix: do not read beyond hdr string\n\n  cpy = malloc(hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy(cpy, hdr, hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    while (i < hdr_len && (cpy[i] == ' ' || cpy[i] == '\\t'))\n      ++i;\n\n    parse_res = MHD_PARSE_COOKIE_OK;  // As original test_parse_cookies_string\n    free(cpy);\n  }\n\n  return parse_res;\n}\n\n// Definitions of used types and constants\nstruct MHD_Connection {\n  struct {\n    struct MHD_HTTP_Req_Header *headers_received_tail;\n  } rq;\n  struct MHD_Daemon *daemon;\n};\nstruct MHD_HTTP_Req_Header {};\nstruct MHD_Daemon {};\n\n#define MHD_NO 0\n#define MHD_YES 1\n#define MHD_HEADER_KIND 0\n#define MHD_HTTP_HEADER_COOKIE \"Cookie\"\n#define MHD_STATICSTR_LEN_(str) (sizeof(str) - 1)\n\n// Forward declaration of MHD_lookup_connection_value_n, assume returns int\nint MHD_lookup_connection_value_n(struct MHD_Connection *connection,\n                                 int kind,\n                                 const char *key,\n                                 size_t key_size,\n                                 const char **value_ptr,\n                                 size_t *value_size_ptr);\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported violation concerns potential out-of-bounds memory access in the use of memcpy with hdr_len obtained from MHD_lookup_connection_value_n. According to the scenario, if hdr_len exceeds the actual size of the memory buffer pointed to by hdr, memcpy could indeed read beyond the valid memory object bounds, violating MISRA C 2023 Rule 21.17. The source code calls memcpy(cpy, hdr, hdr_len) immediately after allocating cpy with hdr_len + 1 bytes, assuming hdr_len correctly reflects the length of the hdr buffer. However, the code does not show any internal validation that hdr_len matches the actual size of the buffer hdr points to. If MHD_lookup_connection_value_n returns an incorrect length, this could cause an out-of-bounds access. Therefore, the risk is present unless MHD_lookup_connection_value_n guarantees that hdr_len is always within the actual bounds of hdr's storage. Since the standard library string functions do not perform bounds checking, misuse with incorrect length parameters can cause violation of Rule 21.17."
}