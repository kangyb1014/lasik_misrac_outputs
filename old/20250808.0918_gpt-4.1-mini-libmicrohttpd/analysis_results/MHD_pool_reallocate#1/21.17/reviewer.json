{
  "user_message": "An agent A claimed that the following MHD_pool_reallocate code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_reallocate.\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation of MISRA C 2023 Rule 21.17 can occur if memcpy or memset accesses memory beyond the bounds of the objects referenced by their pointer parameters. In MHD_pool_reallocate, memcpy(new_blc, old, old_size) and memset((uint8_t *) old + new_size, 0, old_size - new_size) are called. Provided that the assertions hold, these accesses should be safe. However, if incorrect values are passed for old_size or new_size, or if pool boundaries are insufficiently checked, the functions might access beyond the allocated object bounds, causing a violation. Thus, improper usage or corrupted parameters could result in out-of-bounds access.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  FILE *log = fopen(\"/tmp/logs/15.txt\", \"a\");\n  if (log)\n  {\n    fprintf(log, \"Entering MHD_pool_reallocate: old=%p, old_size=%zu, new_size=%zu, pool->pos=%zu, pool->end=%zu, pool->size=%zu\\n\",\n            old, old_size, new_size, pool->pos, pool->end, pool->size);\n  }\n  size_t asize;\n  unsigned char *new_blc;\n\n  // Use assert from <assert.h> instead of mhd_assert\n  #include <assert.h>\n\n  assert (pool->end >= pool->pos);\n  assert (pool->size >= pool->end - pool->pos);\n  assert (old != NULL || old_size == 0);\n  assert (pool->size >= old_size);\n  // Assuming ROUND_TO_ALIGN is a function, declare a local temp variable to simulate its logic\n  size_t ROUND_TO_ALIGN(size_t x) { return (x + 7) & ~7; }\n  size_t ROUND_TO_ALIGN_PLUS_RED_ZONE(size_t x) { return ROUND_TO_ALIGN(x) + _MHD_RED_ZONE_SIZE; }\n\n  assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n\n  if (NULL != old)\n  {\n    size_t mp_ptr_diff_(const void *a, const void *b) { return (const unsigned char *)a - (const unsigned char *)b; }\n    int mp_ptr_le_(const void *a, const void *b) { return a <= b; }\n\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const int shrinking = (old_size > new_size);\n\n    if (log) {\n      fprintf(log, \"old_offset=%zu, shrinking=%d\\n\", old_offset, shrinking);\n    }\n\n    assert (mp_ptr_le_ (pool->memory, old));\n    assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    assert ((old_size == 0) || (pool->pos > old_offset));\n    assert ((old_size == 0) || ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n\n    if (shrinking)\n    {\n      if (log) {\n        fprintf(log, \"Shrinking in-place: memset from %p size %zu\\n\", (unsigned char *) old + new_size, old_size - new_size);\n      }\n      memset ((unsigned char *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((unsigned char *) old + new_size, old_size - new_size);\n    }\n\n    if (pool->pos == ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {\n      const size_t new_apos = ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {\n        if ((new_apos > pool->end) || (new_apos < pool->pos))\n        {\n          if (log) {\n            fprintf(log, \"No space for grow in-place, returning NULL\\n\");\n            fclose(log);\n          }\n          return NULL;\n        }\n      }\n\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      if (log) {\n        fprintf(log, \"Resized in-place, returning old block %p\\n\", old);\n        fclose(log);\n      }\n      return old;\n    }\n    if (shrinking)\n    {\n      if (log) {\n        fprintf(log, \"Shrinking in-place, freed part remains allocated, returning old block %p\\n\", old);\n        fclose(log);\n      }\n      return old;\n    }\n  }\n\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if (((0 == asize) && (0 != new_size)) || (asize > pool->end - pool->pos))\n  {\n    if (log) {\n      fprintf(log, \"Allocation failed: asize=%zu, available=%zu\\n\", asize, pool->end - pool->pos);\n      fclose(log);\n    }\n    return NULL;\n  }\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    if (log) {\n      fprintf(log, \"Copying old_size %zu bytes from %p to %p\\n\", old_size, old, new_blc);\n    }\n    memcpy (new_blc, old, old_size);\n    if (log) {\n      fprintf(log, \"Zeroing old block %p size %zu\\n\", old, old_size);\n    }\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  if (log) fclose(log);\n  return new_blc;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits any use of string handling functions from <string.h> that results in accesses beyond the bounds of the objects referenced by their pointer parameters. In the given code, the functions memcpy and memset are used with sizes and pointers derived from the parameters old, old_size, new_size, and the internal pool structure. The code has multiple assertions designed to ensure bounds safety (e.g., verifying that old_size fits within the pool's size, offsets calculated are within the pool's boundaries, and that shrinking operations do not access beyond allocated memory). Provided these assertions hold true, all memcpy and memset calls remain within the allocated memory areas, thus respecting Rule 21.17.\n\nHowever, the rule also applies to the actual runtime behavior, and if these assumptions/assertions are violated (e.g., corrupted or incorrect parameters passed, or if pool boundaries are corrupted), then out-of-bounds accesses could theoretically occur. This is more a matter of the correctness of the code's use and assumptions rather than a violation inherently present in this implementation. \n\nTherefore, the code as written is not inherently violating Rule 21.17 but depends on strict enforcement of its preconditions. Agent A's scenario hypothesizes parameter corruption or incorrect usage as a basis for violation, which is true in a general sense but does not prove that the given code intrinsically violates the rule. Their test code attempt to demonstrate was incomplete (did not compile), and no direct violation in the code is visible with the given assumptions.\n\nHence, the report overstates the violation: the code itself follows the rule under its stated assumptions; misuse or corruption of parameters would indeed violate the rule, but that is outside the compliance of the code snippet itself."
}