{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n  FILE *log = fopen(\"/tmp/logs/296.txt\", \"w\");\n  if (log == NULL)\n    return -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking PSTAT_GETDYNAMIC path\\n\");\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n      {\n        ret = (int) psd_data.psd_proc_cnt;\n        fprintf(log, \"PSTAT proc count: %d\\n\", ret);\n      }\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking VxWorks cpu enabled path\\n\");\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n    fprintf(log, \"VxWorks cpu count: %d\\n\", ret);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    fprintf(log, \"Entering Windows API dynamic loading path\\n\");\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    fprintf(log, \"LoadLibraryA kernel32.dll returned: %p\\n\", (void *)k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      fprintf(log, \"GetProcAddress GetActiveProcessorCount returned: %p\\n\", (void *)ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        fprintf(log, \"GetActiveProcessorCount result: %u, ret: %d\\n\", res, ret);\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      fprintf(log, \"GetProcAddress GetNativeSystemInfo returned: %p\\n\", (void *)ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        fprintf(log, \"GetNativeSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary (k32hndl);\n      fprintf(log, \"FreeLibrary called\\n\");\n    }\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    fprintf(log, \"GetSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  fclose(log);\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\nmhd_tool_get_cpu_count.c:3:10: fatal error: windows.h: No such file or directory\n    3 | #include <windows.h>\n      |          ^~~~~~~~~~~\ncompilation terminated.\nmake[4]: *** [Makefile:513: mhd_tool_get_cpu_count.o] Error 1\nmake[3]: *** [Makefile:549: all-recursive] Error 1\nmake[2]: *** [Makefile:449: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_sys_cpu_count_special_api_ as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n#include <sys/param.h>\n#include <sys/pstat.h>\n#endif\n\n#ifdef HAVE_VXCPUENABLEDGET\n#include <vxWorks.h>\n#include <vxCpuLib.h>\n#endif\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#endif\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_(void)\n{\n  int ret = -1;\n  FILE *log = fopen(\"/tmp/logs/296.txt\", \"w\");\n  if (log == NULL)\n    return -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking PSTAT_GETDYNAMIC path\\n\");\n    struct pst_dynamic psd_data;\n    memset((void *)&psd_data, 0, sizeof(psd_data));\n    if (1 == pstat_getdynamic(&psd_data, sizeof(psd_data), (size_t)1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n      {\n        ret = (int)psd_data.psd_proc_cnt;\n        fprintf(log, \"PSTAT proc count: %d\\n\", ret);\n      }\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking VxWorks cpu enabled path\\n\");\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet();\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n    fprintf(log, \"VxWorks cpu count: %d\\n\", ret);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && !defined(__CYGWIN__)\n  if (0 >= ret)\n  {\n    fprintf(log, \"Entering Windows API dynamic loading path\\n\");\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA(\"kernel32.dll\");\n    fprintf(log, \"LoadLibraryA kernel32.dll returned: %p\\n\", (void *)k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD(WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n          (GAPC_PTR)(void *)GetProcAddress(k32hndl, \"GetActiveProcessorCount\");\n      fprintf(log, \"GetProcAddress GetActiveProcessorCount returned: %p\\n\", (void *)ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n        ret = (int)res;\n        fprintf(log, \"GetActiveProcessorCount result: %u, ret: %d\\n\", res, ret);\n        if (res != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void(WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n          (GNSI_PTR)(void *)GetProcAddress(k32hndl, \"GetNativeSystemInfo\");\n      fprintf(log, \"GetProcAddress GetNativeSystemInfo returned: %p\\n\", (void *)ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset((void *)&sysInfo, 0, sizeof(sysInfo));\n        ptrGetNativeSystemInfo(&sysInfo);\n        ret = (int)sysInfo.dwNumberOfProcessors;\n        fprintf(log, \"GetNativeSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n        if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary(k32hndl);\n      fprintf(log, \"FreeLibrary called\\n\");\n    }\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset((void *)&sysInfo, 0, sizeof(sysInfo));\n    GetSystemInfo(&sysInfo);\n    ret = (int)sysInfo.dwNumberOfProcessors;\n    fprintf(log, \"GetSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n    if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  fclose(log);\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n",
  "explanation": "I added the necessary #include directives at the top of the code to ensure all used types and functions are declared, including <windows.h> only when compiling on Windows systems, guarded by the appropriate #if defined(_WIN32) && !defined(__CYGWIN__) condition. This prevents inclusion of windows.h on non-Windows platforms, avoiding the compilation error. I preserved all existing logic and platform-specific code inside the proper preprocessor conditions, ensuring the function remains unchanged but compiles successfully on all platforms."
}