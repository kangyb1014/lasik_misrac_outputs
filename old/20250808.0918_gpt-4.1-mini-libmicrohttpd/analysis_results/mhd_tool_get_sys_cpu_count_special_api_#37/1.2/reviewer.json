{
  "user_message": "An agent A claimed that the following mhd_tool_get_sys_cpu_count_special_api_ code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_sys_cpu_count_special_api_.\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The function uses the Windows API functions LoadLibraryA, GetProcAddress, and FreeLibrary to dynamically load system DLLs and retrieve function addresses. These are documented Windows-specific compiler and platform extensions beyond standard C, hence their usage constitutes use of language extensions not compliant with MISRA C 2023 Rule 1.2.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_(void)\n{\n  int ret = -1;\n  FILE *log = fopen(\"/tmp/logs/296.txt\", \"w\");\n  if (log == NULL)\n    return -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking PSTAT_GETDYNAMIC path\\n\");\n    struct pst_dynamic psd_data;\n    memset((void *)&psd_data, 0, sizeof(psd_data));\n    if (1 == pstat_getdynamic(&psd_data, sizeof(psd_data), (size_t)1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n      {\n        ret = (int)psd_data.psd_proc_cnt;\n        fprintf(log, \"PSTAT proc count: %d\\n\", ret);\n      }\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    fprintf(log, \"Checking VxWorks cpu enabled path\\n\");\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet();\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n    fprintf(log, \"VxWorks cpu count: %d\\n\", ret);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && !defined(__CYGWIN__)\n  if (0 >= ret)\n  {\n    fprintf(log, \"Entering Windows API dynamic loading path\\n\");\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA(\"kernel32.dll\");\n    fprintf(log, \"LoadLibraryA kernel32.dll returned: %p\\n\", (void *)k32hndl);\n    if (NULL != k32hndl)\n    {\n      typedef DWORD(WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n          (GAPC_PTR)(void *)GetProcAddress(k32hndl, \"GetActiveProcessorCount\");\n      fprintf(log, \"GetProcAddress GetActiveProcessorCount returned: %p\\n\", (void *)ptrGetActiveProcessorCount);\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n        ret = (int)res;\n        fprintf(log, \"GetActiveProcessorCount result: %u, ret: %d\\n\", res, ret);\n        if (res != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void(WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n          (GNSI_PTR)(void *)GetProcAddress(k32hndl, \"GetNativeSystemInfo\");\n      fprintf(log, \"GetProcAddress GetNativeSystemInfo returned: %p\\n\", (void *)ptrGetNativeSystemInfo);\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset((void *)&sysInfo, 0, sizeof(sysInfo));\n        ptrGetNativeSystemInfo(&sysInfo);\n        ret = (int)sysInfo.dwNumberOfProcessors;\n        fprintf(log, \"GetNativeSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n        if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n    {\n      FreeLibrary(k32hndl);\n      fprintf(log, \"FreeLibrary called\\n\");\n    }\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset((void *)&sysInfo, 0, sizeof(sysInfo));\n    GetSystemInfo(&sysInfo);\n    ret = (int)sysInfo.dwNumberOfProcessors;\n    fprintf(log, \"GetSystemInfo processor count: %u, ret: %d\\n\", sysInfo.dwNumberOfProcessors, ret);\n    if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  fclose(log);\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 states that language extensions should not be used and specifically refers to language compiler extensions explicitly documented by the compiler as extensions beyond the standard C language. The Windows API functions LoadLibraryA, GetProcAddress, FreeLibrary, and related Windows system calls are part of the Windows platform SDK and are not language extensions or compiler extensions; rather, they are platform-specific APIs callable from standard C code. Their usage involves including platform-specific headers and linking to platform libraries, but this does not constitute a violation of Rule 1.2, which focuses on language extensions such as non-standard keywords, attributes, or syntax introduced by compilers. Therefore, agent A's scenario that using these Windows API functions constitutes use of language extensions violating MISRA C 2023 Rule 1.2 is incorrect. The test code failing to compile does not prove the presence of language extensions; it might be due to environment setup or missing headers/libraries. Hence, the report wrongly interprets platform API use as a language extension violation."
}