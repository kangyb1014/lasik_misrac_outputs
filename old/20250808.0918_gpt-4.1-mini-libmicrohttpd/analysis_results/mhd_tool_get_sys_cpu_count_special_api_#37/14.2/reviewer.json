{
  "user_message": "An agent A claimed that the following mhd_tool_get_sys_cpu_count_special_api_ code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop count and optionally loop flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with essentially Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement..\n</misra_rule>\n<target_code>\nHere is the original code of mhd_tool_get_sys_cpu_count_special_api_.\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The for loop in the VxWorks section modifies the loop counter 'ret' in the loop body through the expression '++ret;', which violates the MISRA C 2023 Rule 14.2 Clause 4 stating the loop counter shall not be modified in the for loop body. Also, the third clause uses 'enb_set', which is modified inside the loop body, violating Clauses 2 and 3 regarding no modification of objects used there within the loop body.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_(void)\n{\n  FILE *log = fopen(\"/tmp/logs/300.txt\", \"a\");\n  int ret = -1;\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (ret <= 0)\n  {\n    struct pst_dynamic psd_data;\n    memset(&psd_data, 0, sizeof(psd_data));\n    if (1 == pstat_getdynamic(&psd_data, sizeof(psd_data), (size_t)1, 0))\n    {\n      if (psd_data.psd_proc_cnt > 0)\n        ret = (int)psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n\n#ifdef HAVE_VXCPUENABLEDGET\n  if (ret <= 0)\n  {\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet();\n    if(log) fprintf(log, \"Entered VxWorks for loop, initial enb_set=0x%X, ret=%d\\n\", (unsigned)enb_set, ret);\n    ret = 0;\n    while (enb_set != 0)\n    {\n      ++ret;\n      enb_set &= (enb_set - 1);\n      if(log) fprintf(log, \"Loop iteration: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n    }\n    if(log) fprintf(log, \"Exited loop: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n  if (ret <= 0)\n  {\n    HMODULE k32hndl = LoadLibraryA(\"kernel32.dll\");\n    if (k32hndl != NULL)\n    {\n      typedef DWORD(WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount = (GAPC_PTR)GetProcAddress(k32hndl, \"GetActiveProcessorCount\");\n      if (ptrGetActiveProcessorCount != NULL)\n      {\n        DWORD res = ptrGetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n        ret = (int)res;\n        if (res != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    \n      if (ret <= 0)\n      {\n        typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO*);\n        GNSI_PTR ptrGetNativeSystemInfo = (GNSI_PTR)GetProcAddress(k32hndl, \"GetNativeSystemInfo\");\n        if (ptrGetNativeSystemInfo != NULL)\n        {\n          SYSTEM_INFO sysInfo;\n          memset(&sysInfo, 0, sizeof(sysInfo));\n          ptrGetNativeSystemInfo(&sysInfo);\n          ret = (int)sysInfo.dwNumberOfProcessors;\n          if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n            ret = -1; /* Overflow */\n        }\n      }\n\n      FreeLibrary(k32hndl);\n    }\n\n    if (ret <= 0)\n    {\n      SYSTEM_INFO sysInfo;\n      memset(&sysInfo, 0, sizeof(sysInfo));\n      GetSystemInfo(&sysInfo);\n      ret = (int)sysInfo.dwNumberOfProcessors;\n      if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n        ret = -1; /* Overflow */\n    }\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n\n  if (log)\n    fclose(log);\n\n  if (ret <= 0)\n    return -1;\n\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A claims that the for loop in the VxWorks section of the original code violates MISRA C 2023 Rule 14.2 because the loop counter 'ret' is modified in the loop body (via '++ret;'), and the third clause of the for loop modifies 'enb_set', which is also modified inside the loop body, violating the rule about side effects in the second and third clauses.\n\nAnalyzing the original for loop:\n\n```c\nfor (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n    ++ret;\n```\n\nThe rule states:\n1. The first clause shall initialize or set the loop counter.\n2. The second clause shall have no persistent side effects and use only loop counter and optionally loop flags, but not objects modified in the loop body.\n3. The third clause shall modify only the loop counter and not use objects modified in the loop body.\n4. There shall be only one loop counter, and it shall not be modified inside the loop body.\n\nHere, the \"loop counter\" is clearly 'ret', since it is initialized in the first clause and incremented in the loop body. According to clause 4, the loop counter shall NOT be modified inside the loop body. However, here 'ret' is incremented inside the loop body.\n\nAlso, the third clause modifies 'enb_set' by the expression `enb_set &= enb_set - 1`. But 'enb_set' is also modified inside the loop body (although that's inside the third clause, which is considered part of the for statement, not the loop body?). Actually, in a for loop:\n- The first clause is initialization,\n- The second clause is the condition,\n- The third clause is the iteration expression executed after each iteration of the loop body.\n\nIn this code, the third clause includes side effects on 'enb_set'. The rule forbids this unless the side effect is on the loop counter only.\n\nThus, both issues pointed out are real violations:\n- The loop counter 'ret' is modified in the loop body.\n- The third clause modifies 'enb_set', which is also used in the loop condition and, importantly, is modified in the iteration expression, making it have side effects beyond the loop counter.\n\nTherefore, the agent A's claim about MISRA C 2023 Rule 14.2 violation in the for loop is correct.\n\nRegarding the test code, the agent replaced the for loop with a while loop, which is a valid approach to avoid the MISRA violation. The fact that their test code failed to compile does not invalidate their reasoning or the correctness of their claim about the violation in the original code."
}