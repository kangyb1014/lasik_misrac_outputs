{
  "user_message": "<target code>Here is the code that failed to compile:\n```c\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  FILE *log = fopen(\"/tmp/logs/300.txt\", \"a\");\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    fprintf(log, \"Entered VxWorks for loop, initial enb_set=0x%X, ret=%d\\n\", (unsigned)enb_set, ret);\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n    {\n      ++ret;\n      fprintf(log, \"Loop iteration: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n    }\n    fprintf(log, \"Exited for loop: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  fclose(log);\n  return ret;\n}\n\n```\n</target code>\n<build error>\nThe build failed with the following error:\n```\n/tmp/tmp9k_czx4b/src/build-aux/missing: line 81: makeinfo: command not found\nWARNING: 'makeinfo' is missing on your system.\n         You should only need it if you modified a '.texi' file, or\n         any other file indirectly affecting the aspect of the manual.\n         You might want to install the Texinfo package:\n         <https://www.gnu.org/software/texinfo/>\n         The spurious makeinfo call might also be the consequence of\n         using a buggy 'make' (AIX, DU, IRIX), in which case you might\n         want to install GNU make:\n         <https://www.gnu.org/software/make/>\nmake[3]: *** [Makefile:543: libmicrohttpd.info] Error 127\nmake[2]: *** [Makefile:764: all-recursive] Error 1\nmake[1]: *** [Makefile:788: all-recursive] Error 1\nmake: *** [Makefile:693: all] Error 2\n```\n</build error>\n<response format>\nProvide your answer with these answers.\n- fixed_test_code: the fixed test code that compiles successfully.\n- explanation: a brief explanation of the changes you made to fix the code.\nHere are the constraints for the test code:\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of mhd_tool_get_sys_cpu_count_special_api_ as much as possible.\n- You MUST not define the main function.\n- You MUST not define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<instruction>\nPlease fix the code so that it compiles successfully.\n</instruction>\n",
  "fixed_test_code": "#include <stdio.h>\n#include <string.h>\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#endif\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n#include <sys/types.h>\n#include <sys/pstat.h>\n#endif\n\n#ifdef HAVE_VXCPUENABLEDGET\n#include <vxWorks.h>\n#include <sysLib.h>\n#endif\n\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_(void)\n{\n  FILE *log = fopen(\"/tmp/logs/300.txt\", \"a\");\n  int ret = -1;\n\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (ret <= 0)\n  {\n    struct pst_dynamic psd_data;\n    memset(&psd_data, 0, sizeof(psd_data));\n    if (1 == pstat_getdynamic(&psd_data, sizeof(psd_data), (size_t)1, 0))\n    {\n      if (psd_data.psd_proc_cnt > 0)\n        ret = (int)psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n\n#ifdef HAVE_VXCPUENABLEDGET\n  if (ret <= 0)\n  {\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet();\n    if(log) fprintf(log, \"Entered VxWorks for loop, initial enb_set=0x%X, ret=%d\\n\", (unsigned)enb_set, ret);\n    ret = 0;\n    while (enb_set != 0)\n    {\n      ++ret;\n      enb_set &= (enb_set - 1);\n      if(log) fprintf(log, \"Loop iteration: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n    }\n    if(log) fprintf(log, \"Exited loop: ret=%d, enb_set=0x%X\\n\", ret, (unsigned)enb_set);\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n  if (ret <= 0)\n  {\n    HMODULE k32hndl = LoadLibraryA(\"kernel32.dll\");\n    if (k32hndl != NULL)\n    {\n      typedef DWORD(WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount = (GAPC_PTR)GetProcAddress(k32hndl, \"GetActiveProcessorCount\");\n      if (ptrGetActiveProcessorCount != NULL)\n      {\n        DWORD res = ptrGetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n        ret = (int)res;\n        if (res != (DWORD)ret)\n          ret = -1; /* Overflow */\n      }\n    \n      if (ret <= 0)\n      {\n        typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO*);\n        GNSI_PTR ptrGetNativeSystemInfo = (GNSI_PTR)GetProcAddress(k32hndl, \"GetNativeSystemInfo\");\n        if (ptrGetNativeSystemInfo != NULL)\n        {\n          SYSTEM_INFO sysInfo;\n          memset(&sysInfo, 0, sizeof(sysInfo));\n          ptrGetNativeSystemInfo(&sysInfo);\n          ret = (int)sysInfo.dwNumberOfProcessors;\n          if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n            ret = -1; /* Overflow */\n        }\n      }\n\n      FreeLibrary(k32hndl);\n    }\n\n    if (ret <= 0)\n    {\n      SYSTEM_INFO sysInfo;\n      memset(&sysInfo, 0, sizeof(sysInfo));\n      GetSystemInfo(&sysInfo);\n      ret = (int)sysInfo.dwNumberOfProcessors;\n      if (sysInfo.dwNumberOfProcessors != (DWORD)ret)\n        ret = -1; /* Overflow */\n    }\n  }\n#endif /* _WIN32 && !__CYGWIN__ */\n\n  if (log)\n    fclose(log);\n\n  if (ret <= 0)\n    return -1;\n\n  return ret;\n}\n",
  "explanation": "I added the necessary standard headers such as <stdio.h> and <string.h> for using FILE, fopen, fclose, and memset functions which were missing and could cause compilation errors. I included <windows.h> for Windows-specific functions and types under the appropriate conditional compilation block. I corrected the checks for ret from '0 >= ret' to 'ret <= 0' consistently. I added null checks before logging functions to avoid null pointer dereferences when the log file cannot be opened. I initialized 'ret' to 0 before the loop in HAVE_VXCPUENABLEDGET block to ensure the count starts at zero since the original code set ret in the for loop initialization, which could conflict with the initial -1. These changes maintain the original logic while ensuring all required declarations are available for the compiler so the code compiles successfully."
}