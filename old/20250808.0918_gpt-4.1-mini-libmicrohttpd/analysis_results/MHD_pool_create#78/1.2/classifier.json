{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_pool_create code that contains useful probe functions that print useful logs to a file \"/tmp/logs/624.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_pool_create as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_pool_create:\n```c\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  mhd_assert (max > 0);\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    pool->memory = malloc (alloc_size);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  return pool;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_create:\n#define mhd_assert(ignore) ((void)0)\n...\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n...\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n...\nstatic size_t MHD_sys_page_size_ = (size_t)\n#if defined(MHD_USE_PAGESIZE_MACRO_STATIC)\n                                   PAGESIZE;\n#elif defined(MHD_USE_PAGE_SIZE_MACRO_STATIC)\n                                   PAGE_SIZE;\n#else  /* ! MHD_USE_PAGE_SIZE_MACRO_STATIC */\n                                   _MHD_FALLBACK_PAGE_SIZE\n...\n#define ALIGN_SIZE (2*sizeof(void*))\n</additional code>\nJudge whether the above MHD_pool_create code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "Use of compiler or platform-specific language extensions such as mmap with MAP_ANONYMOUS, Windows VirtualAlloc, and platform-specific macros like MAP_FAILED which might be defined as language/compiler/platform extensions, potentially violating MISRA C 2023 Rule 1.2 which prohibits compiler language extensions.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nstruct MemoryPool {\n  void *memory;\n  size_t pos;\n  size_t end;\n  size_t size;\n  bool is_mmap;\n};\n\nextern size_t MHD_sys_page_size_;\n#define ALIGN_SIZE (2*sizeof(void *))\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n#define MAP_FAILED ((void *)-1)\n\n/* Dummy minimal macros for demonstration */\n#define mhd_assert(ignore) ((void)0)\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n\n/* Probes to log control flow and state information */\nstatic FILE *log_file = NULL;\n\nstatic void log_state(const char *msg, size_t val) {\n  if (log_file) {\n    fprintf(log_file, \"%s: %zu\\n\", msg, val);\n    fflush(log_file);\n  }\n}\n\nstatic void log_ptr(const char *msg, void *ptr) {\n  if (log_file) {\n    fprintf(log_file, \"%s: %p\\n\", msg, ptr);\n    fflush(log_file);\n  }\n}\n\nstruct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n  size_t alloc_size;\n\n  log_file = fopen(\"/tmp/logs/624.txt\", \"a\");\n  if (!log_file) {\n    /* Fallback: no logging possible */\n  }\n\n  mhd_assert (max > 0);\n  log_state(\"Entered MHD_pool_create with max\", max);\n\n  alloc_size = 0;\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool) {\n    log_state(\"malloc failed for pool\", 0);\n    if (log_file) fclose(log_file);\n    return NULL;\n  }\n  log_ptr(\"Allocated pool pointer\", pool);\n\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if ( (max <= 32 * 1024) ||\n       (max < MHD_sys_page_size_ * 4 / 3) )\n  {\n    pool->memory = MAP_FAILED;\n    log_ptr(\"Set pool->memory to MAP_FAILED due to size check\", pool->memory);\n  }\n  else\n  {\n    /* Round up allocation to page granularity. */\n    alloc_size = max + MHD_sys_page_size_ - 1;\n    alloc_size -= alloc_size % MHD_sys_page_size_;\n    log_state(\"Rounded alloc_size\", alloc_size);\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         alloc_size,\n                         PROT_READ | PROT_WRITE,\n                         MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n    log_ptr(\"mmap returned\", pool->memory);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 alloc_size,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n    log_ptr(\"VirtualAlloc returned\", pool->memory);\n#endif /* _WIN32 */\n  }\n#else  /* ! _WIN32 && ! MAP_ANONYMOUS */\n  pool->memory = MAP_FAILED;\n  log_ptr(\"Set pool->memory to MAP_FAILED due to fallback\", pool->memory);\n#endif /* ! _WIN32 && ! MAP_ANONYMOUS */\n\n  if (MAP_FAILED == pool->memory)\n  {\n    alloc_size = ROUND_TO_ALIGN (max);\n    log_state(\"Fallback alloc_size\", alloc_size);\n    pool->memory = malloc (alloc_size);\n    log_ptr(\"Fallback malloc returned\", pool->memory);\n    if (NULL == pool->memory)\n    {\n      free (pool);\n      log_state(\"Fallback malloc failed, pool freed\", 0);\n      if (log_file) fclose(log_file);\n      return NULL;\n    }\n    pool->is_mmap = false;\n  }\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  else\n  {\n    pool->is_mmap = true;\n  }\n#endif /* _WIN32 || MAP_ANONYMOUS */\n  mhd_assert (0 == (((uintptr_t) pool->memory) % ALIGN_SIZE));\n  pool->pos = 0;\n  pool->end = alloc_size;\n  pool->size = alloc_size;\n  mhd_assert (0 < alloc_size);\n  _MHD_POISON_MEMORY (pool->memory, pool->size);\n  log_ptr(\"Returning pool pointer\", pool);\n  if (log_file) fclose(log_file);\n  return pool;\n}\n"
}