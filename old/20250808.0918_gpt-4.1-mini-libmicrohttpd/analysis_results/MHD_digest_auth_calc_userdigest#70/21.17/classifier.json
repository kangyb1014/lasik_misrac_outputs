{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_digest_auth_calc_userdigest code that contains useful probe functions that print useful logs to a file \"/tmp/logs/567.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_digest_auth_calc_userdigest as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_calc_userdigest:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userdigest (enum MHD_DigestAuthAlgo3 algo3,\n                                 const char *username,\n                                 const char *realm,\n                                 const char *password,\n                                 void *userdigest_bin,\n                                 size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userdigest (&da,\n                     username,\n                     strlen (username),\n                     realm,\n                     strlen (realm),\n                     password,\n                     userdigest_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_digest_auth_calc_userdigest:\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n...\n_MHD_static_inline enum MHD_DigestBaseAlgo\nget_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3)\n{\n  unsigned int base_algo;\n\n  base_algo =\n    ((unsigned int) algo3)\n    & ~((unsigned int)\n        (MHD_DIGEST_AUTH_ALGO3_NON_SESSION\n         | MHD_DIGEST_AUTH_ALGO3_NON_SESSION));\n  return (enum MHD_DigestBaseAlgo) base_algo;\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n...\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n...\n_MHD_static_inline void\ndigest_update_with_colon (struct DigestAlgorithm *da)\n{\n  static const uint8_t colon = (uint8_t) ':';\n  digest_update (da, &colon, 1);\n}\n...\n_MHD_static_inline void\ndigest_update_str (struct DigestAlgorithm *da,\n                   const char *str)\n{\n  const size_t str_len = strlen (str);\n  digest_update (da, (const uint8_t *) str, str_len);\n}\n...\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n</additional code>\nJudge whether the above MHD_digest_auth_calc_userdigest code violates the rule 21.17 or not.",
  "is_rule_violated": true,
  "scenario": "If the username or realm strings are not properly null-terminated or if their length reports are incorrect, calls to strlen(username) or strlen(realm) in MHD_digest_auth_calc_userdigest could cause accesses beyond the bounds of the respective objects, violating Rule 21.17. This could happen if the input strings are malformed or incorrectly handled upstream before calling this function.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef enum { MHD_NO = 0, MHD_YES = 1 } MHD_Result;\nenum MHD_DigestAuthAlgo3 { ALG_INVALID = 0 };\ntypedef enum { MHD_DIGEST_BASE_ALGO_MD5 = 1, MHD_DIGEST_BASE_ALGO_INVALID = 0 } MHD_DigestBaseAlgo;\n\nstruct DigestAlgorithm {\n    bool uninitialised;\n    bool algo_selected;\n    bool ready_for_hashing;\n    bool hashing;\n    MHD_DigestBaseAlgo algo;\n    union {\n        int md5_ctx;\n    } ctx;\n};\n\nstatic void digest_update(struct DigestAlgorithm *da, const void *data, size_t length) { /* dummy */ (void)da; (void)data; (void)length; }\nstatic bool digest_init_one_time(struct DigestAlgorithm *da, MHD_DigestBaseAlgo algo) {\n    da->algo = algo;\n    da->algo_selected = true;\n    da->ready_for_hashing = true;\n    da->uninitialised = false;\n    return true;\n}\nstatic size_t digest_get_size(struct DigestAlgorithm *da) {\n    (void)da;\n    return 16;\n}\nstatic void digest_deinit(struct DigestAlgorithm *da) { (void)da; }\nstatic void calc_userdigest(struct DigestAlgorithm *da, const char *username, const size_t username_len, const char *realm, const size_t realm_len, const char *password, uint8_t *userdigest_bin) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    if (log) {\n        fprintf(log, \"calc_userdigest called with username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n        fprintf(log, \"username buffer contents (up to 20 chars): %.*s\\n\", (int)(username_len < 20 ? username_len : 20), username);\n        fprintf(log, \"realm buffer contents (up to 20 chars): %.*s\\n\", (int)(realm_len < 20 ? realm_len : 20), realm);\n        fclose(log);\n    }\n    digest_update(da, username, username_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, realm, realm_len);\n    digest_update(da, \":\", 1);\n    digest_update(da, password, strlen(password));\n    /* Simulate writing a dummy digest */\n    if (userdigest_bin) {\n        for (size_t i = 0; i < 16; i++) {\n            userdigest_bin[i] = (uint8_t)i;\n        }\n    }\n}\n\nMHD_Result MHD_digest_auth_calc_userdigest(enum MHD_DigestAuthAlgo3 algo3,\n                                          const char *username,\n                                          const char *realm,\n                                          const char *password,\n                                          void *userdigest_bin,\n                                          size_t bin_buf_size) {\n    FILE *log = fopen(\"/tmp/logs/567.txt\", \"a\");\n    struct DigestAlgorithm da;\n    MHD_Result ret;\n\n    if (log) fprintf(log, \"Entered MHD_digest_auth_calc_userdigest\\n\");\n\n    if (!digest_init_one_time(&da, MHD_DIGEST_BASE_ALGO_MD5)) {\n        if (log) fprintf(log, \"digest_init_one_time failed\\n\");\n        if (log) fclose(log);\n        return MHD_NO;\n    }\n\n    if (digest_get_size(&da) > bin_buf_size) {\n        if (log) fprintf(log, \"Buffer too small: digest size > bin_buf_size\\n\");\n        ret = MHD_NO;\n    } else {\n        size_t username_len = strlen(username);\n        size_t realm_len = strlen(realm);\n        if (log) fprintf(log, \"username_len=%zu, realm_len=%zu\\n\", username_len, realm_len);\n\n        /* PROBE: Here is risk of reading beyond bounds if username or realm buffers are not properly null-terminated */\n        calc_userdigest(&da, username, username_len, realm, realm_len, password, (uint8_t *)userdigest_bin);\n        ret = MHD_YES;\n    }\n\n    digest_deinit(&da);\n\n    if (log) {\n        fprintf(log, \"Exiting MHD_digest_auth_calc_userdigest with result %d\\n\", ret);\n        fclose(log);\n    }\n\n    return ret;\n}\n"
}