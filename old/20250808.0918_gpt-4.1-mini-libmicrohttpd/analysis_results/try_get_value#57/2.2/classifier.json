{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_get_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/458.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_get_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_get_value:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_get_value:\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  if (newline == pp->buffer_size)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n    return MHD_NO;              /* will need more data */\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n  {\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"name\",\n                   &pp->content_name);\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"filename\",\n                   &pp->content_filename);\n  }\n  else\n  {\n    try_match_header (\"Content-type: \",\n                      MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                      buf,\n                      &pp->content_type);\n    try_match_header (\"Content-Transfer-Encoding: \",\n                      MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                      buf,\n                      &pp->content_transfer_encoding);\n  }\n  (*ioffptr) += newline + 1;\n  return MHD_YES;\n}\n</additional code>\nJudge whether the above try_get_value code violates the rule 2.2 or not.",
  "is_rule_violated": true,
  "scenario": "In the provided try_get_value function, the comment 'no match' precedes a 'continue' statement inside a while loop. The operations following the check (spos[klen] != '=') || ((spos != buf) && (spos[-1] != ' ')) include updating bpos and continuing the loop. This code segment executes an operation whose removal would not affect program behavior, constituting dead code according to MISRA C 2023 Rule 2.2.",
  "test_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  FILE *log = fopen(\"/tmp/logs/458.txt\", \"a\");\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination) {\n    fprintf(log, \"destination already set, returning early\\n\");\n    fclose(log);\n    return;\n  }\n\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    fprintf(log, \"Found key at position: %ld\\n\", (long)(spos - buf));\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      fprintf(log, \"No match for key at position: %ld, updating bpos and continuing\\n\", (long)(spos - buf));\n      /* no match */\n      bpos = spos + 1;\n      fprintf(log, \"New bpos set at position: %ld\\n\", (long)(bpos - buf));\n      continue;\n    }\n    if (spos[klen + 1] != '\"') {\n      fprintf(log, \"Not quoted value at position: %ld, returning\\n\", (long)(spos - buf));\n      fclose(log);\n      return;                   /* not quoted */\n    }\n    if (NULL == (endv = strchr (&spos[klen + 2], '\"'))) {\n      fprintf(log, \"No end quote found for key at position: %ld, returning\\n\", (long)(spos - buf));\n      fclose(log);\n      return;                   /* no end-quote */\n    }\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination) {\n      fprintf(log, \"Out of memory for key at position: %ld, returning\\n\", (long)(spos - buf));\n      fclose(log);\n      return;                   /* out of memory */\n    }\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination, &spos[klen + 2], vlen - 1);\n    fprintf(log, \"Value extracted for key at position: %ld: %s\\n\", (long)(spos - buf), *destination);\n    fclose(log);\n    return;                     /* success */\n  }\n  fprintf(log, \"Key not found in buffer\\n\");\n  fclose(log);\n}\n"
}