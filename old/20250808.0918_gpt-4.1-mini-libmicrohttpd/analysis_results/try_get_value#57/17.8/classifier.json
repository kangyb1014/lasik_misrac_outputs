{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified try_get_value code that contains useful probe functions that print useful logs to a file \"/tmp/logs/461.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of try_get_value as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of try_get_value:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\nJudge whether the above try_get_value code violates the rule 17.8 or not.",
  "is_rule_violated": true,
  "scenario": "The function try_get_value modifies the pointer parameter 'destination' itself (i.e., the pointer variable), by assigning newly allocated memory to '*destination'. This modifies the content of the pointer parameter. According to MISRA C 2023 Rule 17.8, the pointer parameter itself should not be modified. Although the object pointed to by the pointer may be modified, the pointer should remain unmodified. In this case, the pointer '*destination' is assigned a new address, which is a modification of the pointer parameter, violating Rule 17.8.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n  FILE *logfile = fopen(\"/tmp/logs/461.txt\", \"a\");\n\n  if (logfile != NULL) {\n    fprintf(logfile, \"Entered try_get_value\\n\");\n    fprintf(logfile, \"*destination before check: %p\\n\", (void*)(*destination));\n  }\n\n  if (NULL != *destination) {\n    if (logfile != NULL) {\n      fprintf(logfile, \"*destination not NULL, returning early\\n\");\n      fclose(logfile);\n    }\n    return;\n  }\n\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      if (logfile != NULL) {\n        fprintf(logfile, \"No match at position %ld, continuing\\n\", (long)(spos - buf));\n      }\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"') {\n      if (logfile != NULL) {\n        fprintf(logfile, \"Not quoted value, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* not quoted */\n    }\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\"'))) {\n      if (logfile != NULL) {\n        fprintf(logfile, \"No end-quote found, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* no end-quote */\n    }\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination) {\n      if (logfile != NULL) {\n        fprintf(logfile, \"Out of memory, returning\\n\");\n        fclose(logfile);\n      }\n      return;                   /* out of memory */\n    }\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n\n    if (logfile != NULL) {\n      fprintf(logfile, \"*destination assigned new memory at %p\\n\", (void*)(*destination));\n      fprintf(logfile, \"Extracted value: %s\\n\", *destination);\n      fclose(logfile);\n    }\n    return;                     /* success */\n  }\n  if (logfile != NULL) {\n    fprintf(logfile, \"Key not found, no assignment made\\n\");\n    fclose(logfile);\n  }\n}\n"
}