{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n- test_code: a modified MHD_set_connection_value_n code that contains useful probe functions that print useful logs to a file \"/tmp/logs/408.txt\". The logs should contain the control path and state information of the violation scenario. If the MISRA C rule is not violated, you can just return an empty string for the test code.\nHere are the constraints for the test code:\n- DO NOT introduce new violations to demonstrate your scenario.\n- The test code MUST be compilable and executable.\n- The test code MUST include line breaks.\n- The test code MUST preserve the original logic of MHD_set_connection_value_n as much as possible.\n- You MUST NOT define the main function.\n- You MUST NOT define macros.\n- The test code MUST not contain any mock functions.\n</response format>\n<target_code>\nHere is the code of MHD_set_connection_value_n:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_connection_value_n:\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n</additional code>\nJudge whether the above MHD_set_connection_value_n code violates the rule 1.2 or not.",
  "is_rule_violated": true,
  "scenario": "The code uses the identifier '_MHD_EXTERN' which is potentially a compiler language extension for symbol visibility or linkage, depending on the compiler documentation. Such use constitutes a language extension, violating MISRA C 2023 Rule 1.2.",
  "test_code": "#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n\nenum MHD_Result { MHD_NO = 0, MHD_YES = 1 };\nenum MHD_ValueKind { MHD_GET_ARGUMENT_KIND = 0 };\n\nstruct MHD_HTTP_Req_Header\n{\n  const char *header;\n  size_t header_size;\n  const char *value;\n  size_t value_size;\n  enum MHD_ValueKind kind;\n  struct MHD_HTTP_Req_Header *next;\n};\n\nstruct MHD_Request_Queue\n{\n  struct MHD_HTTP_Req_Header *headers_received;\n  struct MHD_HTTP_Req_Header *headers_received_tail;\n};\n\nstruct MHD_Connection\n{\n  struct MHD_Request_Queue rq;\n};\n\nstatic void * MHD_connection_alloc_memory_(struct MHD_Connection *connection, size_t size)\n{\n  (void)connection;\n  return malloc(size);\n}\n\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  FILE *log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"In MHD_set_connection_value_n_nocheck_: key_size=%zu, value_size=%zu\\n\", key_size, value_size);\n    fclose(log);\n  }\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_(connection,\n                                    sizeof(struct MHD_HTTP_Req_Header));\n  if (NULL == pos)\n  {\n    log = fopen(\"/tmp/logs/408.txt\", \"a\");\n    if (NULL != log)\n    {\n      fprintf(log, \"Allocation failed in MHD_set_connection_value_n_nocheck_\\n\");\n      fclose(log);\n    }\n    return MHD_NO;\n  }\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"Header appended successfully in MHD_set_connection_value_n_nocheck_\\n\");\n    fclose(log);\n  }\n\n  return MHD_YES;\n}\n\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  FILE *log = fopen(\"/tmp/logs/408.txt\", \"a\");\n  if (NULL != log)\n  {\n    fprintf(log, \"Entered MHD_set_connection_value_n with kind=%d\\n\", (int)kind);\n    fclose(log);\n  }\n\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n  {\n    log = fopen(\"/tmp/logs/408.txt\", \"a\");\n    if (NULL != log)\n    {\n      fprintf(log, \"Violation condition met: key or value size mismatch\\n\");\n      fclose(log);\n    }\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n  }\n\n  return MHD_set_connection_value_n_nocheck_(connection,\n                                             kind,\n                                             key,\n                                             key_size,\n                                             value,\n                                             value_size);\n}\n"
}