{
  "user_message": "An agent A claimed that the following parse_cookies_string code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of parse_cookies_string.\n```c\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (' ' == str[i] || '\\t' == str[i] || ';' == str[i])\n    {\n      if (! allow_wsp_empty)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n      if (i == str_len)\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n    }\n    /* 'i' must point to the first char of cookie-name */\n    name_start = i;\n    /* Find the end of the cookie-name */\n    do\n    {\n      const char l = str[i];\n      if (('=' == l) || (' ' == l) || ('\\t' == l) || ('\"' == l) || (',' == l) ||\n          (';' == l) || (0 == l))\n        break;\n    } while (str_len > ++i);\n    name_len = i - name_start;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    if ((str_len == i) || ('=' != str[i]) || (0 == name_len))\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    /* 'i' must point to the '=' char */\n    mhd_assert ('=' == str[i]);\n    i++;\n    /* Skip any whitespaces */\n    while (str_len > i && (' ' == str[i] || '\\t' == str[i]))\n    {\n      if (! wsp_around_eq)\n        return MHD_PARSE_COOKIE_MALFORMED;\n      non_strict = true;\n      i++;\n    }\n    /* 'i' must point to the first char of cookie-value */\n    if (str_len == i)\n    {\n      value_start = 0;\n      value_len = 0;\n#ifdef _DEBUG\n      val_quoted = false; /* This assignment used in assert */\n#endif\n    }\n    else\n    {\n      bool valid_cookie;\n      val_quoted = ('\"' == str[i]);\n      if (val_quoted)\n        i++;\n      value_start = i;\n      /* Find the end of the cookie-value */\n      while (str_len > i)\n      {\n        const char l = str[i];\n        if ((';' == l) || ('\"' == l) || (',' == l) || (';' == l) ||\n            ('\\\\' == l) || (0 == l))\n          break;\n        if ((' ' == l) || ('\\t' == l))\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      if (val_quoted)\n      {\n        if ((str_len == i) || ('\"' != str[i]))\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        i++;\n      }\n      /* Skip any whitespaces */\n      if ((str_len > i) && ((' ' == str[i]) || ('\\t' == str[i])))\n      {\n        do\n        {\n          i++;\n        } while (str_len > i && (' ' == str[i] || '\\t' == str[i]));\n        /* Whitespace at the end? */\n        if (str_len > i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n      if (str_len == i)\n        valid_cookie = true;\n      else if (';' == str[i])\n        valid_cookie = true;\n      else\n        valid_cookie = false;\n\n      if (! valid_cookie)\n        return MHD_PARSE_COOKIE_MALFORMED; /* Garbage at the end of the cookie value */\n    }\n    mhd_assert (0 != name_len);\n    str[name_start + name_len] = 0; /* Zero-terminate the name */\n    if (0 != value_len)\n    {\n      mhd_assert (value_start + value_len <= str_len);\n      str[value_start + value_len] = 0; /* Zero-terminate the value */\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               str + value_start,\n                                               value_len))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    else\n    {\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (connection,\n                                               MHD_COOKIE_KIND,\n                                               str + name_start,\n                                               name_len,\n                                               \"\",\n                                               0))\n        return MHD_PARSE_COOKIE_NO_MEMORY;\n    }\n    if (str_len > i)\n    {\n      mhd_assert (0 == str[i] || ';' == str[i]);\n      mhd_assert (! val_quoted || ';' == str[i]);\n      mhd_assert (';' != str[i] || val_quoted || non_strict || 0 == value_len);\n      i++;\n      if (str_len == i)\n      { /* No next cookie after semicolon */\n        if (! allow_wsp_empty)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else if (' ' != str[i])\n      {/* No space after semicolon */\n        if (('\\t' == str[i]) && tab_as_sp)\n          i++;\n        else if (! allow_no_space)\n          return MHD_PARSE_COOKIE_MALFORMED;\n        non_strict = true;\n      }\n      else\n      {\n        i++;\n        if (str_len == i)\n        {\n          if (! allow_wsp_empty)\n            return MHD_PARSE_COOKIE_MALFORMED;\n          non_strict = true;\n        }\n      }\n    }\n  }\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation scenario occurs if the function writes zero termination characters beyond the buffer pointed to by 'str'. Specifically, the statements 'str[name_start + name_len] = 0;' and 'str[value_start + value_len] = 0;' both write within bounds only if 'name_start + name_len < str_len' and 'value_start + value_len < str_len', respectively. However, there is no explicit check for these conditions before writing the zero termination, so if 'name_start + name_len == str_len' or 'value_start + value_len == str_len', it will write beyond the buffer, violating rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum _MHD_ParseCookie {\n    MHD_PARSE_COOKIE_OK = 0,\n    MHD_PARSE_COOKIE_OK_LAX = 1,\n    MHD_PARSE_COOKIE_MALFORMED = 2,\n    MHD_PARSE_COOKIE_NO_MEMORY = 3\n};\ntypedef enum { MHD_BOOL_FALSE = 0, MHD_BOOL_TRUE = 1 } MHD_bool;\nstatic enum _MHD_ParseCookie\nparse_cookies_string (char *str,\n                      const size_t str_len,\n                      struct MHD_Connection *connection)\n{\n  FILE *log = fopen(\"/tmp/logs/191.txt\", \"w\");\n  size_t i;\n  bool non_strict;\n  /* Skip extra whitespaces and empty cookies */\n  const bool allow_wsp_empty = (0 >= connection->daemon->client_discipline);\n  /* Allow whitespaces around '=' character */\n  const bool wsp_around_eq = (-3 >= connection->daemon->client_discipline);\n  /* Allow whitespaces in quoted cookie value */\n  const bool wsp_in_quoted = (-2 >= connection->daemon->client_discipline);\n  /* Allow tab as space after semicolon between cookies */\n  const bool tab_as_sp = (0 >= connection->daemon->client_discipline);\n  /* Allow no space after semicolon between cookies */\n  const bool allow_no_space = (0 >= connection->daemon->client_discipline);\n\n  non_strict = false;\n  i = 0;\n  fprintf(log, \"Start parsing cookies, str_len=%zu\\n\", str_len);\n  while (i < str_len)\n  {\n    size_t name_start;\n    size_t name_len;\n    size_t value_start;\n    size_t value_len;\n    bool val_quoted;\n    /* Skip any whitespaces and empty cookies */\n    while (i < str_len && (str[i] == ' ' || str[i] == '\\t' || str[i] == ';'))\n    {\n      fprintf(log, \"Skipping whitespace/semicolon at i=%zu char='%c'\\n\", i, str[i]);\n      if (! allow_wsp_empty) {\n        fprintf(log, \"Rule violation: no whitespace allowed here\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n      if (i == str_len) {\n        fprintf(log, \"End of string reached after skipping, returning OK_LAX=%d\\n\", non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK);\n        fclose(log);\n        return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n      }\n    }\n    if (i >= str_len) {\n      break;\n    }\n    name_start = i;\n    fprintf(log, \"Found cookie name start at i=%zu\\n\", i);\n    do\n    {\n      const char l = str[i];\n      if (l == '=' || l == ' ' || l == '\\t' || l == '\"' || l == ',' || l == ';' || l == 0)\n        break;\n    } while (++i < str_len);\n    name_len = i - name_start;\n    fprintf(log, \"Cookie name length=%zu\\n\", name_len);\n    while (i < str_len && (str[i] == ' ' || str[i] == '\\t'))\n    {\n      fprintf(log, \"Skipping whitespace after cookie name at i=%zu\\n\", i);\n      if (! wsp_around_eq) {\n        fprintf(log, \"Space around '=' not allowed, malformed\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if (i == str_len || str[i] != '=' || name_len == 0) {\n      fprintf(log, \"Malformed cookie name or '=' missing at i=%zu\\n\", i);\n      fclose(log);\n      return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie name */\n    }\n    i++; /* skip '=' */\n    while (i < str_len && (str[i] == ' ' || str[i] == '\\t'))\n    {\n      fprintf(log, \"Skipping whitespace after '=' at i=%zu\\n\", i);\n      if (! wsp_around_eq) {\n        fprintf(log, \"Space around '=' not allowed, malformed\\n\");\n        fclose(log);\n        return MHD_PARSE_COOKIE_MALFORMED;\n      }\n      non_strict = true;\n      i++;\n    }\n    if (i == str_len) {\n      value_start = 0;\n      value_len = 0;\n      val_quoted = false;\n    } else {\n      val_quoted = (str[i] == '\"');\n      if (val_quoted) {\n        i++;\n        fprintf(log, \"Quoted cookie value detected at i=%zu\\n\", i);\n      }\n      value_start = i;\n      while (i < str_len)\n      {\n        const char l = str[i];\n        if (l == ';' || l == '\"' || l == ',' || l == '\\'' || l == 0)\n          break;\n        if (l == ' ' || l == '\\t')\n        {\n          if (! val_quoted)\n            break;\n          if (! wsp_in_quoted)\n          {\n            fprintf(log, \"Malformed: whitespace in quoted value not allowed at i=%zu\\n\", i);\n            fclose(log);\n            return MHD_PARSE_COOKIE_MALFORMED;\n          }\n          non_strict = true;\n        }\n        i++;\n      }\n      value_len = i - value_start;\n      fprintf(log, \"Cookie value length=%zu, val_quoted=%d, i=%zu\\n\", value_len, val_quoted, i);\n      if (val_quoted)\n      {\n        if (i == str_len || str[i] != '\"') {\n          fprintf(log, \"Malformed: quoted value not closed properly at i=%zu\\n\", i);\n          fclose(log);\n          return MHD_PARSE_COOKIE_MALFORMED; /* Incomplete cookie value, no closing quote */\n        }\n        i++;\n      }\n      if (name_start + name_len < str_len) {\n        str[name_start + name_len] = 0; /* Zero-terminate the name */\n      } else {\n        fprintf(log, \"Violation: writing zero terminator beyond str buffer for name at pos %zu\\n\", name_start + name_len);\n      }\n      if (value_len != 0)\n      {\n        if (value_start + value_len < str_len) {\n          str[value_start + value_len] = 0; /* Zero-terminate the value */\n        } else {\n          fprintf(log, \"Violation: writing zero terminator beyond str buffer for value at pos %zu\\n\", value_start + value_len);\n        }\n        if (MHD_NO ==\n            MHD_set_connection_value_n_nocheck_ (connection,\n                                                 MHD_COOKIE_KIND,\n                                                 str + name_start,\n                                                 name_len,\n                                                 str + value_start,\n                                                 value_len))\n        {\n          fprintf(log, \"Memory allocation failed for cookie value\\n\");\n          fclose(log);\n          return MHD_PARSE_COOKIE_NO_MEMORY;\n        }\n      }\n      else\n      {\n        if (MHD_NO ==\n            MHD_set_connection_value_n_nocheck_ (connection,\n                                                 MHD_COOKIE_KIND,\n                                                 str + name_start,\n                                                 name_len,\n                                                 \"\",\n                                                 0))\n        {\n          fprintf(log, \"Memory allocation failed for empty cookie value\\n\");\n          fclose(log);\n          return MHD_PARSE_COOKIE_NO_MEMORY;\n        }\n      }\n      if (i < str_len)\n      {\n        i++;\n      }\n    }\n  }\n  fclose(log);\n  return non_strict? MHD_PARSE_COOKIE_OK_LAX : MHD_PARSE_COOKIE_OK;\n}\n\nMHD_bool\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                    int kind,\n                                    const char *name,\n                                    size_t name_len,\n                                    const char *value,\n                                    size_t value_len) {\n    (void)connection; (void)kind; (void)name; (void)name_len; (void)value; (void)value_len;\n    return MHD_YES;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The reported scenario points out that the code writes zero termination characters at positions 'name_start + name_len' and 'value_start + value_len' in the buffer 'str' without explicit checks that these positions are strictly less than 'str_len'. The code does contain an assertion 'mhd_assert(value_start + value_len <= str_len)' before writing the zero terminator for the value part, which partially guards the write for the value. However, there is no explicit assertion or check ensuring 'name_start + name_len < str_len' before writing zero terminator for the name part, nor for the value part (only an assert for <= str_len, which means it could be equal to str_len, then writing zero would go out of bounds). Writing a zero terminator exactly at 'str_len' offset would write out of bounds, violating Rule 21.17 which forbids accesses beyond object bounds via string functions. Since these writes could indeed occur at the boundary without being explicitly prevented, the agent A's violation scenario is valid. Furthermore, the test code added to log boundary cases found no output because the function failed to parse in those cases, potentially indicating the boundary situation is reached but not handled properly. Therefore, the report that the code can violate MISRA C 2023 Rule 21.17 due to out-of-bounds zero writes is correct."
}