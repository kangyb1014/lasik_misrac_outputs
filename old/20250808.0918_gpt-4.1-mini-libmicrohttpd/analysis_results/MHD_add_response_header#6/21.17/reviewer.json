{
  "user_message": "An agent A claimed that the following MHD_add_response_header code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_add_response_header.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:A violation scenario occurs if the input 'content' string passed to add_response_entry or add_response_header_connection contains a non-null-terminated string or if the length passed to functions like memcpy or memmove exceeds the actual memory bounds of the related buffers, e.g., 'hdr->value' length inconsistencies or improperly null-terminated strings leading to accesses beyond buffer bounds.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nenum MHD_ValueKind { MHD_HEADER_KIND };\nvoid mhd_assert(int expr)\n{\n    if (!expr)\n    {\n        FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n        if (f)\n        {\n            fprintf(f, \"Assertion failed\\n\");\n            fclose(f);\n        }\n        abort();\n    }\n}\nvoid *_MHD_malloc(size_t size);\nvoid _MHD_free(void *ptr);\nsize_t MHD_STATICSTR_LEN_(const char *str)\n{\n    // Returns string literal length assuming str is a literal\n    // This cannot be done properly for arbitrary pointers, so here we fallback to strlen\n    // The original macro was for literals only, so this is best-effort replacement\n    return strlen(str);\n}\nstatic void log_control_path(const char *msg)\n{\n    FILE *f = fopen(\"/tmp/logs/55.txt\", \"a\");\n    if (f)\n    {\n        fprintf(f, \"%s\\n\", msg);\n        fclose(f);\n    }\n}\nvoid _MHD_remove_header(struct MHD_Response *response, struct MHD_HTTP_Res_Header *hdr);\n\nstatic enum MHD_Result add_response_entry(struct MHD_Response *response,\n                                          enum MHD_ValueKind kind,\n                                          const char *header,\n                                          const char *content)\n{\n    size_t header_len;\n    size_t content_len;\n\n    log_control_path(\"Entered add_response_entry\");\n\n    if (NULL == content)\n    {\n        log_control_path(\"add_response_entry: content is NULL\");\n        return MHD_NO;\n    }\n\n    header_len = strlen(header);\n    content_len = strlen(content);\n\n    log_control_path(\"add_response_entry: header and content length calculated\");\n\n    return add_response_entry_n(response, kind, header, header_len, content, content_len) ? MHD_YES : MHD_NO;\n}\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header(struct MHD_Response *response,\n                        const char *header,\n                        const char *content)\n{\n    log_control_path(\"Entered MHD_add_response_header\");\n\n    if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_CONNECTION))\n    {\n        log_control_path(\"Header equals CONNECTION\");\n        return add_response_header_connection(response, content);\n    }\n\n    if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_TRANSFER_ENCODING))\n    {\n        log_control_path(\"Header equals TRANSFER_ENCODING\");\n        if (!MHD_str_equal_caseless_(content, \"chunked\"))\n        {\n            log_control_path(\"Content is not 'chunked'\");\n            return MHD_NO;\n        }\n        if ((0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED)))\n        {\n            log_control_path(\"Already has TRANS_ENC_CHUNKED flag\");\n            return MHD_YES;\n        }\n        if (((0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n             (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags))))\n        {\n            log_control_path(\"Content-Length header with no Insanity flag - no update\");\n            return MHD_NO;\n        }\n        if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n        {\n            response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n            log_control_path(\"Added TRANS_ENC_CHUNKED header successfully\");\n            return MHD_YES;\n        }\n        log_control_path(\"Failed to add TRANS_ENC_CHUNKED header\");\n        return MHD_NO;\n    }\n\n    if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_DATE))\n    {\n        log_control_path(\"Header equals DATE\");\n        if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n        {\n            log_control_path(\"Removing old DATE header\");\n            struct MHD_HTTP_Res_Header *hdr;\n            hdr = MHD_get_response_element_n_(response, MHD_HEADER_KIND, MHD_HTTP_HEADER_DATE, MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_DATE));\n            mhd_assert(NULL != hdr);\n            _MHD_remove_header(response, hdr);\n            if (NULL != hdr->value)\n                free(hdr->value);\n            free(hdr->header);\n            free(hdr);\n        }\n        if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n        {\n            response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n            log_control_path(\"Added new DATE header successfully\");\n            return MHD_YES;\n        }\n        log_control_path(\"Failed to add DATE header\");\n        return MHD_NO;\n    }\n\n    if (MHD_str_equal_caseless_(header, MHD_HTTP_HEADER_CONTENT_LENGTH))\n    {\n        log_control_path(\"Header equals CONTENT_LENGTH\");\n        if (((0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n             ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n              (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED | MHD_RAF_HAS_CONTENT_LENGTH))))))\n        {\n            if (MHD_NO != add_response_entry(response, MHD_HEADER_KIND, header, content))\n            {\n                response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n                log_control_path(\"Added CONTENT_LENGTH header successfully\");\n                return MHD_YES;\n            }\n        }\n        log_control_path(\"Not adding CONTENT_LENGTH header\");\n        return MHD_NO;\n    }\n\n    log_control_path(\"Header does not match special cases, adding as a generic entry\");\n    return add_response_entry(response, MHD_HEADER_KIND, header, content);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The code uses string handling functions such as strlen on the 'header' and 'content' pointers passed into MHD_add_response_header and subsequently to add_response_entry. According to the provided scenario, a violation of MISRA C 2023 rule 21.17 would occur if these strings are not properly null-terminated or if their lengths lead to buffer overflows when functions like memcpy are called indirectly. However, from the given code snippet alone, there is no direct evidence that the code itself performs out-of-bounds accesses or uses unsafe string functions beyond the provided pointers. The rule requires that string handling functions must not result in accesses beyond the bounds of the objects referenced, but the code relies on the assumption that 'header' and 'content' are properly null-terminated strings. This is a reasonable assumption for API usage and consistent with typical C string handling. The test code aimed to demonstrate the violation does not compile, indicating the test scenario is not reproducible as is. Therefore, the reported violation depends on external input validity (the correctness of inputs passed to these functions), not on a definite violation inside the code itself. The code itself does not forcibly cause out-of-bounds accesses; rather, it requires callers to pass valid strings. Thus, the report that this code violates MISRA C 2023 rule 21.17 is not fully supported by the provided evidence. If the caller passes invalid strings, that is an input validation issue, not a direct violation in the code snippet as written."
}