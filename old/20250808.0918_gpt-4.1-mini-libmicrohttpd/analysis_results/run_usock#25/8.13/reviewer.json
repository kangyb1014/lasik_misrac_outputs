{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\nA pointer should not point to a const-qualified type if the pointer is used by a function that modifies the object pointed to by the pointer..\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In the function run_usock, the pointer msg is declared as unsigned char * and it is assigned the return value of ws_receive_frame, which returns an unsigned char * pointer to a dynamically allocated buffer containing a decoded message. The function run_usock does not modify the contents of the message pointed to by msg; it only reads from it and then frees the memory. According to MISRA C 2023 Rule 8.13, pointers should point to const-qualified types whenever possible when the object pointed to is not modified. Here, the pointer msg should ideally be declared as const unsigned char * to reflect that the content is not modified. However, the pointer is currently unsigned char *, which violates the rule because it does not use const qualification even though the pointed-to data is not modified through this pointer.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\ntypedef int MHD_socket;\nstruct MHD_UpgradeResponseHandle { int dummy; };\nextern void MHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh, int action);\nconst int WS_OPCODE_TEXT_FRAME = 1;\nconst int WS_OPCODE_CON_CLOSE_FRAME = 8;\nconst int WS_FIN = 0x80;\nconst int MHD_UPGRADE_ACTION_CLOSE = 0;\n\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = (struct WsData *)cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  /* Open log file to print control path and state info for violation scenario */\n  FILE *log = fopen(\"/tmp/logs/203.txt\", \"w\");\n  if (log == NULL)\n  {\n    abort();\n  }\n\n  make_blocking (ws->sock);\n\n  fprintf(log, \"Entering run_usock for socket %d\\n\", (int) ws->sock);\n\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    fprintf(log, \"recv returned %zd\\n\", got);\n    if (0 >= got)\n    {\n      fprintf(log, \"Breaking loop due to recv <= 0\\n\");\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    fprintf(log, \"ws_receive_frame returned %p, type=%d, got=%zd\\n\", (void *)msg, type, got);\n    if (NULL == msg)\n    {\n      fprintf(log, \"Breaking loop due to NULL msg\\n\");\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      fprintf(log, \"Calculated buf_size=%d\\n\", buf_size);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          fprintf(log, \"Allocated text buffer at %p\\n\", (void *)text);\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n          fprintf(log, \"Freed text buffer, sent=%zd\\n\", sent);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      fprintf(log, \"Freed msg buffer, sent=%zd\\n\", sent);\n      if (-1 == sent)\n      {\n        fprintf(log, \"Breaking loop due to send failure\\n\");\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        fprintf(log, \"Freeing msg and breaking loop on close frame\\n\");\n        break;\n      }\n    }\n  }\n\n  if (0 != pthread_mutex_lock (&MUTEX))\n  {\n    fprintf(log, \"Mutex lock failed, aborting\\n\");\n    fclose(log);\n    abort ();\n  }\n  fprintf(log, \"Locked mutex, cleaning up client socket %d\\n\", (int) ws->sock);\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      fprintf(log, \"Removed socket from CLIENT_SOCKS[%d]\\n\", i);\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n  {\n    fprintf(log, \"Mutex unlock failed, aborting\\n\");\n    fclose(log);\n    abort ();\n  }\n  fprintf(log, \"Unlocked mutex\\n\");\n  free (ws);\n  fprintf(log, \"Freed WsData structure\\n\");\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  fprintf(log, \"Called MHD_upgrade_action with CLOSE\\n\");\n\n  fclose(log);\n  return NULL;\n}\n\n```\nThe test code failed to parse, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 encourages pointers to point to const-qualified types whenever the pointed-to object is not modified through that pointer, to better express intent and improve code safety and maintainability. In the provided code, the pointer msg is declared as unsigned char * and is assigned the return value of ws_receive_frame, which returns a dynamically allocated buffer. The code only reads from msg (e.g., using it in snprintf) and does not modify the content; it eventually frees the buffer. Therefore, to conform to Rule 8.13, msg should be declared as const unsigned char * to indicate that the pointed-to data is not modified. Since the code does not use const here despite not modifying the data via msg, this constitutes a violation of MISRA C 2023 Rule 8.13. The report from agent A correctly identifies this violation. The test code with additional logging does not change this fact and is mostly for runtime tracing rather than affecting MISRA compliance. Hence, the report is correct."
}