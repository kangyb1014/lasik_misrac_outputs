{
  "user_message": "An agent A claimed that the following MHD_queue_basic_auth_required_response3 code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_queue_basic_auth_required_response3.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses a function-like macro '_MHD_EXTERN' before the function definition, which may be implemented as a language extension depending on compiler documentation. If '_MHD_EXTERN' is defined using compiler-specific extensions or attributes that are not standard C, it violates MISRA C 2023 Rule 1.2. However, from the provided code snippet, the exact definition of '_MHD_EXTERN' is not visible, so assuming it is a compiler-specific extension, this constitutes the violation scenario.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nsize_t MHD_str_quote(const char *unquoted, size_t unquoted_len, char *result, size_t buf_size)\n{\n  size_t r=0, w=0;\n  while (r < unquoted_len && w < buf_size)\n  {\n    char c = unquoted[r++];\n    if (c == '\\\\' || c == '\"')\n    {\n      if (w+1 >= buf_size) break;\n      result[w++] = '\\\\';\n    }\n    if (w >= buf_size) break;\n    result[w++] = c;\n  }\n  return w;\n}\nenum MHD_Result MHD_add_response_header(struct MHD_Response *response, const char *header, const char *content)\n{\n  (void)response; (void)header; (void)content;\n  return MHD_YES;\n}\nenum MHD_Result MHD_queue_response(struct MHD_Connection *connection, unsigned int status_code, struct MHD_Response *response)\n{\n  (void)connection; (void)status_code; (void)response;\n  return MHD_YES;\n}\nstatic size_t mhd_staticstr_len(const char *str) { return strlen(str); }\n\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3(struct MHD_Connection *connection,\n                                       const char *realm,\n                                       int prefer_utf8,\n                                       struct MHD_Response *response)\n{\n  FILE *log_file = fopen(\"/tmp/logs/576.txt\", \"a\");\n  if (log_file == NULL) return MHD_NO;\n  fprintf(log_file, \"Entered MHD_queue_basic_auth_required_response3\\n\");\n\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = mhd_staticstr_len(prefix);\n  static const size_t suff_simple_len = mhd_staticstr_len(\"\\\"\");\n  static const size_t suff_charset_len = mhd_staticstr_len(suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n  {\n    fprintf(log_file, \"Response is NULL - returning MHD_NO\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen(realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n  fprintf(log_file, \"Calculated h_maxlen: %zu\\n\", h_maxlen);\n\n  h_str = (char *) malloc(h_maxlen + 1);\n  if (NULL == h_str)\n  {\n    fprintf(log_file, \"Memory allocation failed for h_str\\n\");\n    fclose(log_file);\n    return MHD_NO;\n  }\n\n  memcpy(h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote(realm, realm_len, h_str + pos, h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\"';\n    h_str[pos] = '\\0';  /* Zero terminate the result */\n  }\n  else\n  {\n    memcpy(h_str + pos, suff_charset, suff_charset_len + 1);\n  }\n\n  fprintf(log_file, \"Composed WWW-Authenticate header: %s\\n\", h_str);\n\n  ret = MHD_add_response_header(response, \"WWW-Authenticate\", h_str);\n  free(h_str);\n\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response(connection, 401, response);\n    fprintf(log_file, \"Queued response with status 401, ret=%d\\n\", ret);\n  }\n  else\n  {\n    fprintf(log_file, \"Failed to add Basic Authentication header\\n\");\n  }\n\n  fclose(log_file);\n  return ret;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 1.2 strictly forbids using compiler language extensions that are not part of the standard C language. The macro '_MHD_EXTERN' used before the function definition is not a standard C keyword or a built-in specifier. However, from the provided code snippet, the definition or expansion of '_MHD_EXTERN' is not given. Without knowing its exact definition, it cannot be conclusively determined whether '_MHD_EXTERN' expands to a compiler-specific language extension or simply to a standard storage-class specifier like 'extern'. The mere use of an undefined macro does not imply violation unless it clearly expands to a language extension. Additionally, the failed compilation of the test code suggests that no valid evidence was provided that '_MHD_EXTERN' uses language extensions. Hence, based only on the snippet and information given, there is insufficient evidence to assert a MISRA 1.2 violation. Therefore, the report of a violation is not correct in this context."
}