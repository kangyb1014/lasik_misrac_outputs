{
  "user_message": "An agent A claimed that the following MHD_get_response_element_n_ code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_response_element_n_.\n```c\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the key_len parameter is greater than the actual length of the key string (which is expected to be null-terminated), then passing key and key_len to MHD_str_equal_caseless_bin_n_ may result in out-of-bounds read from key, violating Rule 21.17. Specifically, the loop inside MHD_str_equal_caseless_bin_n_ accesses str2[i] up to len without bounds checking, so if key_len is larger than the allocated length of key, this causes an access beyond the bounds of key.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nint charsequalcaseless(char a, char b) {\n    if (a >= 'A' && a <= 'Z') {\n        a += 'a' - 'A';\n    }\n    if (b >= 'A' && b <= 'Z') {\n        b += 'a' - 'A';\n    }\n    return a == b;\n}\nvoid mhd_assert(int condition) {\n    if (!condition) {\n        /* In real code, handle assertion failure appropriately. For compile, leave empty. */\n    }\n}\n\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_(struct MHD_Response *response,\n                           enum MHD_ValueKind kind,\n                           const char *key,\n                           size_t key_len)\n{\n    struct MHD_HTTP_Res_Header *pos;\n\n    mhd_assert(NULL != key);\n    mhd_assert(0 != key[0]);\n    mhd_assert(0 != key_len);\n\n    for (pos = response->first_header;\n         NULL != pos;\n         pos = pos->next)\n    {\n        if ((pos->header_size == key_len) &&\n            (kind == pos->kind) &&\n            (MHD_str_equal_caseless_bin_n_(pos->header, key, pos->header_size)))\n        {\n            return pos;\n        }\n    }\n    return NULL;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 prohibits string handling functions from accessing memory beyond the bounds of the referenced objects. In the provided code, the function MHD_get_response_element_n_ calls MHD_str_equal_caseless_bin_n_ with the parameters (pos->header, key, pos->header_size). The key pointer is asserted to be non-NULL and key_len to be non-zero, but no explicit assertion or check verifies that key_len does not exceed the actual length of the null-terminated key string. Therefore, if key_len is larger than the allocated or actual length of key, MHD_str_equal_caseless_bin_n_ could read beyond key's buffer, leading to a violation of Rule 21.17. The agent's scenario correctly identifies this potential out-of-bounds read via key. The test code does not negate this as it failed to compile and provided no contradictory evidence. Thus, the report is correct that the function can lead to a Rule 21.17 violation if key_len does not reflect the actual size of the key buffer."
}