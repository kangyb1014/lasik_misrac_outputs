{
  "user_message": "An agent A claimed that the following MHD_select code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified..\n</misra_rule>\n<target_code>\nHere is the original code of MHD_select.\n```c\nstatic enum MHD_Result\nMHD_select (struct MHD_Daemon *daemon,\n            int32_t millisec)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) )\n    millisec = 0;\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* single-threaded, go over everything */\n    if (MHD_NO ==\n        internal_get_fdset2 (daemon,\n                             &rs,\n                             &ws,\n                             &es,\n                             &maxsock,\n                             (int) FD_SETSIZE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Could not obtain daemon fdsets.\\n\"));\n#endif\n      err_state = MHD_YES;\n    }\n  }\n  else\n  {\n    bool itc_added;\n    /* accept only, have one thread per connection */\n    itc_added = false;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      itc_added = MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                      &rs,\n                                      &maxsock,\n                                      (int) FD_SETSIZE);\n      if (! itc_added)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon, _ (\"Could not add control inter-thread \" \\\n                             \"communication channel FD to fdset.\\n\"));\n#endif\n        err_state = MHD_YES;\n      }\n    }\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) )\n    {\n      /* Stop listening if we are at the configured connection limit */\n      /* If we're at the connection limit, no point in really\n         accepting new connections; however, make sure we do not miss\n         the shutdown OR the termination of an existing connection; so\n         only do this optimisation if we have a signaling ITC in\n         place. */\n      if (! itc_added ||\n          ((daemon->connections < daemon->connection_limit) &&\n           ! daemon->at_limit))\n      {\n        if (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  (int) FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Could not add listen socket to fdset.\\n\"));\n#endif\n          err_state = MHD_YES;\n        }\n      }\n    }\n  }\n\n  if (MHD_NO != err_state)\n    millisec = 0;\n  if (0 == millisec)\n  {\n    timeout.tv_usec = 0;\n    timeout.tv_sec = 0;\n    tv = &timeout;\n  }\n  else\n  {\n    uint64_t mhd_tmo;\n    uint64_t select_tmo;\n\n    if ( (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n         (MHD_NO != MHD_get_timeout64 (daemon, &mhd_tmo)) )\n    {\n      if ( (0 < millisec) &&\n           (mhd_tmo > (uint64_t) millisec) )\n        select_tmo = (uint64_t) millisec;\n      else\n        select_tmo = mhd_tmo;\n      tv = &timeout; /* have timeout value */\n    }\n    else if (0 < millisec)\n    {\n      select_tmo = (uint64_t) millisec;\n      tv = &timeout; /* have timeout value */\n    }\n    else\n    {\n      select_tmo = 0; /* Not actually used, silent compiler warning */\n      tv = NULL;\n    }\n\n    if (NULL != tv)\n    { /* have timeout value */\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n      if (select_tmo / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n      timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) (select_tmo / 1000);\n\n      timeout.tv_usec = ((uint16_t) (select_tmo % 1000)) * ((int32_t) 1000);\n    }\n  }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"select failed: %s\\n\"),\n              MHD_socket_strerr_ (err));\n#endif\n    return MHD_NO;\n  }\n  if (MHD_NO != internal_run_from_select (daemon,\n                                          &rs,\n                                          &ws,\n                                          &es,\n                                          (int) FD_SETSIZE))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:In function MHD_select, the parameter 'millisec' (of type int32_t) is modified within the function body. Specifically, the code contains statements like 'millisec = 0;' and 'millisec = 0;' again in different branches. This modification of a non-pointer function parameter directly violates MISRA C 2023 Rule 17.8, which states that function parameters should not be modified, while allowing modification of objects referred to by pointer parameters but not the pointers themselves.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\nstatic FILE *log_fp = NULL;\nstatic void log_message(const char *msg)\n{\n    if (!log_fp) {\n        // Ensure directory exists on your local system if tests are run\n        log_fp = fopen(\"/tmp/logs/133.txt\", \"a\");\n    }\n    if (log_fp) {\n        fprintf(log_fp, \"%s\\n\", msg);\n        fflush(log_fp);\n    }\n}\nstatic bool MHD_D_IS_USING_THREAD_PER_CONN_(const struct MHD_Daemon *daemon)\n{\n    (void)daemon;\n    return false;\n}\nstatic int MHD_SYS_select_(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n{\n    (void)nfds; (void)readfds; (void)writefds; (void)exceptfds; (void)timeout;\n    log_message(\"MHD_SYS_select_ called\");\n    return 0; // simulate no ready descriptors\n}\nstatic int MHD_socket_get_error_(void)\n{\n    log_message(\"MHD_socket_get_error_ called\");\n    return errno;\n}\nstatic int MHD_SCKT_ERR_IS_EINTR_(int err)\n{\n    (void)err;\n    return 0;\n}\nstatic void MHD_DLOG(const struct MHD_Daemon *daemon, const char *format, ...)\n{\n    (void)daemon; (void)format;\n    log_message(\"MHD_DLOG called\");\n}\n\nstatic MHD_Result resume_suspended_connections(struct MHD_Daemon *daemon)\n{\n    log_message(\"resume_suspended_connections called\");\n    return MHD_NO;\n}\nstatic MHD_Result internal_get_fdset2(struct MHD_Daemon *daemon,\n                                     fd_set *read_fd_set,\n                                     fd_set *write_fd_set,\n                                     fd_set *except_fd_set,\n                                     MHD_socket *max_fd,\n                                     int fd_setsize)\n{\n    (void)daemon; (void)read_fd_set; (void)write_fd_set; (void)except_fd_set; (void)max_fd; (void)fd_setsize;\n    log_message(\"internal_get_fdset2 called\");\n    return MHD_YES;\n}\nstatic MHD_Result internal_run_from_select(struct MHD_Daemon *daemon,\n                                          const fd_set *read_fd_set,\n                                          const fd_set *write_fd_set,\n                                          const fd_set *except_fd_set,\n                                          int fd_setsize)\n{\n    (void)daemon; (void)read_fd_set; (void)write_fd_set; (void)except_fd_set; (void)fd_setsize;\n    log_message(\"internal_run_from_select called\");\n    return MHD_NO;\n}\nstatic MHD_Result\nMHD_select(struct MHD_Daemon *daemon,\n           int32_t millisec)\n{\n    char logbuf[256];\n    int num_ready;\n    fd_set rs;\n    fd_set ws;\n    fd_set es;\n    MHD_socket maxsock;\n    struct timeval timeout;\n    struct timeval *tv;\n    int err_state;\n\n    snprintf(logbuf, sizeof(logbuf), \"MHD_select: start with millisec=%d\", millisec);\n    log_message(logbuf);\n\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 0;\n\n    if (daemon->shutdown) {\n        log_message(\"MHD_select: daemon shutdown true, return MHD_NO\");\n        return MHD_NO;\n    }\n\n    FD_ZERO(&rs);\n    FD_ZERO(&ws);\n    FD_ZERO(&es);\n\n    maxsock = MHD_INVALID_SOCKET;\n    err_state = MHD_NO;\n\n    int local_millisec = millisec; // Use local copy to avoid modifying parameter\n\n    if ((0 != (daemon->options & 1)) &&\n        (MHD_NO != resume_suspended_connections(daemon)) &&\n        (!MHD_D_IS_USING_THREAD_PER_CONN_(daemon)))\n    {\n        log_message(\"Condition to set local_millisec=0 met\");\n        local_millisec = 0;\n    }\n\n    if (!MHD_D_IS_USING_THREAD_PER_CONN_(daemon)) {\n        if (MHD_NO == internal_get_fdset2(daemon, &rs, &ws, &es, &maxsock, (int)FD_SETSIZE)) {\n            log_message(\"internal_get_fdset2 failed\");\n            err_state = MHD_YES;\n        }\n    } else {\n        bool itc_added = false;\n        (void)itc_added; // suppression unused in this stub\n    }\n\n    if (MHD_NO != err_state) {\n        log_message(\"err_state != MHD_NO, setting local_millisec=0\");\n        local_millisec = 0;\n    }\n\n    if (0 == local_millisec) {\n        log_message(\"local_millisec == 0 branch taken\");\n        timeout.tv_usec = 0;\n        timeout.tv_sec = 0;\n        tv = &timeout;\n    } else {\n        log_message(\"local_millisec != 0 branch taken\");\n        tv = NULL;\n    }\n\n    num_ready = MHD_SYS_select_(maxsock + 1, &rs, &ws, &es, tv);\n    snprintf(logbuf, sizeof(logbuf), \"MHD_SYS_select_ returned %d\", num_ready);\n    log_message(logbuf);\n\n    if (daemon->shutdown) {\n        log_message(\"daemon shutdown after select, return MHD_NO\");\n        return MHD_NO;\n    }\n\n    if (num_ready < 0) {\n        const int err = MHD_socket_get_error_();\n        snprintf(logbuf, sizeof(logbuf), \"select failed with error %d\", err);\n        log_message(logbuf);\n\n        if (MHD_SCKT_ERR_IS_EINTR_(err))\n            return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n\n        return MHD_NO;\n    }\n\n    if (MHD_NO != internal_run_from_select(daemon, &rs, &ws, &es, (int)FD_SETSIZE))\n        return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n\n    log_message(\"MHD_select completed normally\");\n    return MHD_NO;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 17.8 prohibits modification of function parameters themselves, meaning the formal parameter variables, but allows modification of the objects they point to via pointers. In the provided code, the parameter 'millisec' is a scalar (int32_t) parameter passed by value, not a pointer. The code explicitly modifies 'millisec' multiple times within the function body, e.g., 'millisec = 0;'. This constitutes direct modification of a function parameter variable, which violates Rule 17.8. Therefore, the agent A's report correctly identifies a violation of MISRA C 2023 Rule 17.8 in the 'MHD_select' function. The test code attempts to avoid modifying the parameter 'millisec' by using a local variable, but it fails to compile and does not affect the fact that the original code modifies the parameter. Hence, the report is correct."
}