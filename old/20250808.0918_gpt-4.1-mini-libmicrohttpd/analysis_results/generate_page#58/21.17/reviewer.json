{
  "user_message": "An agent A claimed that the following generate_page code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of generate_page.\n```c\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:The code uses string handling functions like strcmp, strcasecmp, strrchr, and strstr on pointers derived from the url parameter. Particularly, expressions like &url[1] are used without explicit bounds checks to ensure safe access. If url points to a string of length 0 or 1, accessing &url[1] and passing it to these functions can result in accesses beyond the bounds of the referenced object, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  FILE *log = fopen(\"/tmp/logs/471.txt\", \"a\");\n  if(log != NULL)\n  {\n    fprintf(log, \"generate_page called. url='%s'\\n\", url ? url : \"(null)\");\n  }\n\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;\n  (void) version;\n\n  if (url == NULL) {\n    if(log) fprintf(log, \"url is NULL, return forbidden\\n\");\n    if(log) fclose(log);\n    return MHD_queue_response(connection, 403, NULL);\n  }\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    if(log) fprintf(log, \"url != /, checking for '..' in &url[1] with url length %zu\\n\", strlen(url));\n    /* Unsafe access if url length <= 1 */\n    /* Log if url length <=1 */\n    if(strlen(url) <= 1)\n    {\n      if(log) fprintf(log, \"WARNING: url too short leading to out-of-bounds access in &url[1]\\n\");\n    }\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      if(log) fprintf(log, \"unexpected method, return MHD_NO\\n\");\n      if(log) fclose(log);\n      return MHD_NO; /* Use MHD_NO constant */\n    }\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) && ('/' != url[1]) )\n    {\n      if(log) fprintf(log, \"trying to open file: %s\\n\", &url[1]);\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) || (! S_ISREG (buf.st_mode)) ) )\n      {\n        if(log) fprintf(log, \"file descriptor %d not regular, closing\\n\", fd);\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n    {\n      if(log) fprintf(log, \"file not found, returning 404\\n\");\n      if(log) fclose(log);\n      return MHD_queue_response (connection,\n                                 404,\n                                 NULL);\n    }\n\n    const char *mime = NULL;\n    {\n      const char *ldot = strrchr (&url[1], '.');\n      if(log) fprintf(log, \"file extension search result ldot=%p\\n\", (void*)ldot);\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot, \".html\"))\n          mime = \"text/html\";\n        else if (0 == strcasecmp (ldot, \".css\"))\n          mime = \"text/css\";\n        else if (0 == strcasecmp (ldot, \".css3\"))\n          mime = \"text/css\";\n        else if (0 == strcasecmp (ldot, \".js\"))\n          mime = \"application/javascript\";\n        if(log) fprintf(log, \"mime type set to: %s\\n\", mime ? mime : \"(null)\");\n      }\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size, fd)))\n    {\n      if(log) fprintf(log, \"failed to create response from fd, closing fd\\n\");\n      (void) close (fd);\n      if(log) fclose(log);\n      return MHD_NO; /* MHD_NO */\n    }\n\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      \"Content-Type\",\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK, /* Use constant */\n                              response);\n    MHD_destroy_response (response);\n    if(log) fprintf(log, \"response queued, returning %d\\n\", ret);\n    if(log) fclose(log);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    if(log) fprintf(log, \"handling POST method (upload path)\\n\");\n    /* upload handling omitted for brevity, no string functions on url used here */\n  }\n\n  if ((0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n      (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)))\n  {\n    if(log) fprintf(log, \"handling GET or HEAD method for /\\n\");\n    /* directory response handling omitted */\n  }\n\n  if(log) {\n    fprintf(log, \"unexpected request, refusing\\n\");\n    fclose(log);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             403,\n                             NULL);\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 21.17 forbids use of string functions like strcmp, strcasecmp, strrchr, and strstr that cause accesses beyond the bounds of the referenced objects. In the given code, the expressions &url[1] are used multiple times to access substring parts of url, for example in strstr(&url[1], \"..\"), open(&url[1], O_RDONLY), and strrchr(&url[1], '.'). This is done without explicit prior checks on the length of url or checks to ensure it has at least 2 characters (length >= 2) before accessing url[1]. If url is a string with length 0 or 1, then url[1] and &url[1] point beyond the string boundary, causing the string handling functions to access out-of-bounds memory, violating Rule 21.17.\n\nThe agent A's scenario correctly points out this deficiency in the code. Although the original code assumes url has suitable length, it never checks this before these &url[1] uses. The absence of length checking or ensuring the url string is long enough indeed leads to possible out-of-bounds access. Thus, the agent A report describing violation of Rule 21.17 is correct.\n\nThe test code attempted to add logging and length checks, but did not compile. This does not invalidate the original analysis that the original code contains a Rule 21.17 violation inherently in the unsafe &url[1] usages."
}