{
  "user_message": "An agent A claimed that the following get_no_space_err_status_code code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn..\n</misra_rule>\n<target_code>\nHere is the original code of get_no_space_err_status_code.\n```c\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n```\n</target_code>\n<scenario>\nThe agent A provided the following violation scenario:If the add_element string parameter is not properly null-terminated or if add_element_size does not correctly represent the size of the data buffer, then calls that access add_element by indexing into add_element[header_host_key_len] or during the MHD_str_equal_caseless_bin_n_ comparison could read beyond the bounds of the object, violating Rule 21.17.\n</scenario>\n<test_code>\nAlso, the agent A provided the following modified code that prints out the log to support their scenario:\n```c\n\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  FILE *log = fopen(\"/tmp/logs/47.txt\", \"a\");\n  if (log == NULL) return 0;\n\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  fprintf(log, \"Entered get_no_space_err_status_code\\n\");\n  fprintf(log, \"stage=%d, add_element_size=%zu\\n\", (int)stage, add_element_size);\n\n  /*\n     Replace MHD_STATICSTR_LEN_ macro with inline length calculation for MHD_HTTP_HEADER_HOST\n     Assuming MHD_HTTP_HEADER_HOST is defined as \"host\"\n  */\n\n  /*\n   * This is a safe replacement for MHD_STATICSTR_LEN_(MHD_HTTP_HEADER_HOST)\n   * length of \"host\" is 4\n   */\n  const size_t header_host_key_len = 4;\n  \n  // Simplified replacement for MHD_str_equal_caseless_bin_n_ function\n  // Case-insensitive compare first n bytes\n  int MHD_str_equal_caseless_bin_n_(const char *a, const char *b, size_t n) {\n      for (size_t i = 0; i < n; i++) {\n          char ca = a[i];\n          char cb = b[i];\n          // Convert to lowercase if uppercase ascii character\n          if (ca >= 'A' && ca <= 'Z') ca += 'a' - 'A';\n          if (cb >= 'A' && cb <= 'Z') cb += 'a' - 'A';\n          if (ca != cb) return 0;\n      }\n      return 1;\n  }\n\n  // Now continue with the original code\n\n  // Assertions replaced by ifs with logging for demonstration\n  if (!(MHD_CONNECTION_REQ_LINE_RECEIVED < c->state))\n    fprintf(log, \"Assertion failed: c->state <= MHD_CONNECTION_REQ_LINE_RECEIVED\\n\");\n  if (!(MHD_PROC_RECV_HEADERS <= stage))\n    fprintf(log, \"Assertion failed: stage < MHD_PROC_RECV_HEADERS\\n\");\n  if (!((0 == add_element_size) || (NULL != add_element)))\n    fprintf(log, \"Assertion failed: add_element NULL with non-zero size\\n\");\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    if (c->rq.field_lines.start == NULL)\n       fprintf(log, \"Assertion failed: NULL == c->rq.field_lines.start\\n\");\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset) - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    fprintf(log, \"Chunked stage with add_element_size > min reasonable\\n\");\n    fclose(log);\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n\n  if ((MHD_PROC_RECV_HEADERS == stage) && (0 != add_element_size))\n  {\n    bool is_host_header = false;\n\n    if (header_host_key_len + 1 <= add_element_size) {\n      \n      char check_char = add_element[header_host_key_len];\n      fprintf(log, \"Checking add_element[%zu] = '%c' (0x%02x)\\n\", header_host_key_len, \n              check_char, (unsigned char)check_char);\n      if ((check_char == 0) || (check_char == ':')) {\n        if (MHD_str_equal_caseless_bin_n_(\"host\", add_element, header_host_key_len)) {\n          is_host_header = true;\n          fprintf(log, \"Detected host header match\\n\");\n        }\n      }\n    } else {\n      fprintf(log, \"add_element_size (%zu) too small for host header check (need %zu)\\n\", add_element_size, header_host_key_len + 1);\n    }\n\n    if (is_host_header)\n    {\n      const bool is_parsed = !(\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n\n      if (opt_headers_size < actual_element_size)\n        fprintf(log, \"opt_headers_size (%zu) less than actual_element_size (%zu)\\n\", opt_headers_size, actual_element_size);\n\n      opt_headers_size -= actual_element_size;\n    }\n  }\n\n  fprintf(log, \"Exiting get_no_space_err_status_code\\n\");\n  fclose(log);\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n\n```\nThe test code failed to compile, so we could not obtain any output.\n\n</test_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false)\n</response format>\n<instruction>   \nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 21.17 mandates that usage of string handling functions from <string.h> must not lead to accesses beyond the bounds of the referenced objects. This includes functions like strlen, strcpy, and functions performing indexed access on character arrays. In the provided code, the function carefully uses the add_element_size parameter to ensure that any indexed access such as add_element[header_host_key_len] is only done after checking that (header_host_key_len + 1) <= add_element_size. This ensures the index is within the bounds of the buffer pointed by add_element. Additionally, the code uses size parameters consistently without assuming the string is null-terminated when not guaranteed, relying on explicit size checks and conditional logic to prevent out-of-bounds access. The scenario that if add_element is not properly null-terminated or if add_element_size does not reflect the actual buffer size, may cause issues only if the caller violates the contract of the function. Inside the function itself, all string handling and indexing respects the bounds supplied, thus conforming to Rule 21.17. Therefore, the report claiming a violation based on potential improper input or incorrect add_element_size is not a direct violation of MISRA Rule 21.17 by the code itself, but rather an issue of the calling context or input correctness. The function's own implementation ensures safe access and does not inherently violate Rule 21.17."
}