{
  "user_message": "An agent A claimed that the following connection_check_timedout code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of connection_check_timedout.\n```c\nstatic bool\nconnection_check_timedout (struct MHD_Connection *c)\n{\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t now;\n  uint64_t since_actv;\n\n  if (c->suspended)\n    return false;\n  if (0 == timeout)\n    return false;\n  now = MHD_monotonic_msec_counter ();\n  since_actv = now - c->last_activity;\n  /* Keep the next lines in sync with #connection_get_wait() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Detected system clock %u milliseconds jump back.\\n\"),\n                  (unsigned int) jump_back);\n#endif\n        return false;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (c->daemon,\n                _ (\"Detected too large system clock %\" PRIu64 \" milliseconds \"\n                   \"jump back.\\n\"),\n                jump_back);\n#endif\n    }\n    return true;\n  }\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe format string passed via _(\"...\") is used where a non-const pointer parameter may be expected (e.g. if MHD_DLOG is declared to take char *fmt rather than const char *fmt). In that case a pointer to modifiable char is used where it should be a pointer to a const-qualified type (string literals / translated strings should be treated as const). This also applies if the _() macro/gettext returns a non-const char *; the logging API should use const char * for format strings. Change the logging prototype to accept const char * (or ensure the string expression is const-qualified) to conform with MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The snippet shown does not itself contain any pointer declarations that violate MISRA C 2023 Rule 8.13. The only potentially relevant items are the uses of MHD_DLOG(\u2026, _(\"\u2026\"), \u2026). Whether there is an actual MISRA 8.13 violation depends on the declarations of the logging macro/function and of _ (gettext):\n\n- If MHD_DLOG is declared to take a const char * for its format parameter (and _ either yields const char * or a string literal), there is no violation.\n- If MHD_DLOG is declared to take a non-const char * and/or _ is declared to return non-const char * (so a non-const pointer type is used where it could be const), then the violation would be in that declaration (the logging API or gettext wrapper), not in the implementation of connection_check_timedout itself. In that case the recommendation given by agent A (make the logging prototype accept const char *) is correct as a corrective action.\n\nAlso note: in C the type of a string literal is an array of char (not const char) for historical reasons, and many gettext implementations also declare gettext()/_() to return char *; these facts affect whether a const qualifier actually appears in the types. MISRA 8.13 is about preferring const-qualified pointer types where possible, so the real fix (if a violation exists) is to change the function/macro declarations to use const char * rather than changing the call site shown.\n\nTherefore the report as applied to the shown function is not directly correct: the snippet by itself does not demonstrate a Rule 8.13 violation. The problem would be in the logging/gettext declarations if they use non-const pointers."
}