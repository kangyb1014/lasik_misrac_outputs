{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_calc_userhash_hex:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash_hex (enum MHD_DigestAuthAlgo3 algo3,\n                                   const char *username,\n                                   const char *realm,\n                                   char *userhash_hex,\n                                   size_t hex_buf_size)\n{\n  uint8_t userhash_bin[MAX_DIGEST];\n  size_t digest_size;\n\n  digest_size = digest_get_hash_size (algo3);\n  if (digest_size * 2 + 1 > hex_buf_size)\n    return MHD_NO;\n  if (MHD_NO == MHD_digest_auth_calc_userhash (algo3, username, realm,\n                                               userhash_bin, MAX_DIGEST))\n    return MHD_NO;\n\n  MHD_bin_to_hex_z (userhash_bin, digest_size, userhash_hex);\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_digest_auth_calc_userhash_hex:\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n#ifdef MHD_MD5_SUPPORT\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    return MHD_SHA256_DIGEST_SIZE;\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    return MHD_SHA512_256_DIGEST_SIZE;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  return 0; /* Wrong input or unsupported algorithm */\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n...\n#define MAX_DIGEST SHA512_256_DIGEST_SIZE\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\nenum MHD_DigestAuthAlgo3\n{\n  /**\n   * Unknown or wrong algorithm type.\n   * Used in struct MHD_DigestAuthInfo to indicate client value that\n   * cannot by identified.\n   */\n  MHD_DIGEST_AUTH_ALGO3_INVALID = 0,\n\n  /**\n   * The 'MD5' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5 =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'MD5-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5_SESSION =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-256' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256 =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-256-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-512-256' (SHA-512/256) algorithm.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256 =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-512-256-sess' (SHA-512/256 session) algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_SESSION\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The controlling expression (0 != (((unsigned int) algo3) & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5))) depends on the runtime parameter algo3 (and the macro is a non\u2011zero bitmask), so it is not invariant. (Only if MHD_DIGEST_BASE_ALGO_MD5 were erroneously defined as 0 would it become a compile\u2011time invariant, but that is a separate configuration/definition error.)"
}