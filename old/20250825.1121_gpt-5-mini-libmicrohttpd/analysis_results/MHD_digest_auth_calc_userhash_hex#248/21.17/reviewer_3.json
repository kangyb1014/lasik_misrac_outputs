{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userhash_hex code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userhash_hex.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash_hex (enum MHD_DigestAuthAlgo3 algo3,\n                                   const char *username,\n                                   const char *realm,\n                                   char *userhash_hex,\n                                   size_t hex_buf_size)\n{\n  uint8_t userhash_bin[MAX_DIGEST];\n  size_t digest_size;\n\n  digest_size = digest_get_hash_size (algo3);\n  if (digest_size * 2 + 1 > hex_buf_size)\n    return MHD_NO;\n  if (MHD_NO == MHD_digest_auth_calc_userhash (algo3, username, realm,\n                                               userhash_bin, MAX_DIGEST))\n    return MHD_NO;\n\n  MHD_bin_to_hex_z (userhash_bin, digest_size, userhash_hex);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe check digest_size * 2 + 1 > hex_buf_size can overflow the multiplication. If digest_size is large enough that (digest_size * 2 + 1) wraps around (i.e. digest_size > (SIZE_MAX - 1)/2), the condition can be false even though 2*digest_size+1 does not fit in userhash_hex. Example: on a 32-bit size_t, if digest_size == 0x80000000, digest_size*2 == 0 (wrap) and the test passes; the subsequent MHD_bin_to_hex_z call will then write 2*digest_size+1 bytes and overflow the userhash_hex buffer. Therefore the fragment does not safely prevent out-of-bounds accesses and violates the intent of Rule 21.17 (unsafe potential buffer overflow).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent is correct to point out a potential integer overflow in the size check: digest_size is size_t and the expression digest_size * 2 + 1 can wrap, so the runtime test could be bypassed and a subsequent write (by MHD_bin_to_hex_z) could overflow userhash_hex. However, MISRA C 2023 Rule 21.17 as quoted applies specifically to use of the standard string.h functions (memcpy, strcpy, strlen, etc.). The shown function does not call any <string.h> routines directly; the possible out\u2011of\u2011bounds write would occur inside MHD_bin_to_hex_z (or other internal helpers). Without evidence that MHD_bin_to_hex_z uses a <string.h> function in a way that would access out of bounds, you cannot conclude a violation of Rule 21.17 solely from this fragment. The code does contain a true safety defect (an unchecked multiplication that can overflow) and that should be fixed (for example check for digest_size > (SIZE_MAX - 1)/2 or perform the bounds test as digest_size > (hex_buf_size - 1)/2 after handling hex_buf_size == 0) \u2014 but this is a violation of integer overflow / bounds-checking requirements, not necessarily Rule 21.17 as stated. Therefore the specific report that this fragment violates MISRA C 2023 Rule 21.17 is not correct."
}