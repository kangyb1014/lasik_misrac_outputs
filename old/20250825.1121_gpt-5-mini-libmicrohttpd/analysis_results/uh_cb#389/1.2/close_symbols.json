{
  "user_message": "Target function code is:\n```c\nstatic void\nuh_cb (void *cls, struct MHD_Connection *con, void *req_cls,\n       const char *extra_in, size_t extra_in_size, MHD_socket sock,\n       struct MHD_UpgradeResponseHandle *urh)\n{\n  struct WsData *ws;\n  pthread_t pt;\n  int sock_overflow;\n  int i;\n\n  (void) cls;            /* Unused. Silent compiler warning. */\n  (void) con;            /* Unused. Silent compiler warning. */\n  (void) req_cls;        /* Unused. Silent compiler warning. */\n  (void) extra_in;       /* Unused. Silent compiler warning. */\n  (void) extra_in_size;  /* Unused. Silent compiler warning. */\n\n  ws = malloc (sizeof (struct WsData));\n  if (NULL == ws)\n    abort ();\n  memset (ws, 0, sizeof (struct WsData));\n  ws->sock = sock;\n  ws->urh = urh;\n  sock_overflow = MHD_YES;\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (MHD_INVALID_SOCKET == CLIENT_SOCKS[i])\n    {\n      CLIENT_SOCKS[i] = ws->sock;\n      sock_overflow = MHD_NO;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  if (sock_overflow)\n  {\n    free (ws);\n    MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n    return;\n  }\n  if (0 != pthread_create (&pt, NULL, &run_usock, ws))\n    abort ();\n  /* Note that by detaching like this we make it impossible to ensure\n     a clean shutdown, as the we stop the daemon even if a worker thread\n     is still running. Alas, this is a simple example... */\n  pthread_detach (pt);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'uh_cb': {'callees': ['MHD_upgrade_action'], 'callers': []}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "run_usock",
    "MUTEX",
    "CLIENT_SOCKS",
    "MAX_CLIENTS",
    "MHD_INVALID_SOCKET",
    "MHD_YES",
    "MHD_NO",
    "MHD_socket",
    "struct MHD_UpgradeResponseHandle",
    "MHD_upgrade_action",
    "MHD_UPGRADE_ACTION_CLOSE",
    "pthread_t, pthread_mutex_t, pthread_create, pthread_detach, pthread_mutex_lock, pthread_mutex_unlock",
    "malloc, free, memset, abort"
  ],
  "explanation": "For each symbol below, the analyser must see the definition/declaration to determine whether any compiler/language extensions are used (MISRA check: report only explicit compiler extensions). Explanations:\n\n- struct WsData: The function allocates and zeroes this type (malloc(sizeof(struct WsData)); memset). Its definition may contain compiler extensions (anonymous/unnamed structs/unions, zero-length/flexible array members used as an extension, non-standard bit-field widths, __attribute__ or other compiler-specific keywords). Also needed to confirm sizeof use is standard.\n\n- run_usock: Passed as thread start routine. Its prototype/definition may use compiler-specific function attributes or non-standard calling conventions (e.g. __attribute__((...)), __stdcall, typeof-based wrappers) that would be language extensions.\n\n- MUTEX: Used with pthread_mutex_lock/unlock. The MUTEX symbol (likely a global/pthread_mutex_t) definition could be a macro or a type alias that uses extensions (e.g. attributes, custom wrappers). Need the definition to exclude extensions.\n\n- CLIENT_SOCKS: Global array written under mutex. Its type and declaration (e.g. defined via unusual macros or typedefs) may use extensions; also its storage-class specifier or initialiser macros might hide extensions.\n\n- MAX_CLIENTS: Used as loop bound. Its definition (macro or const) could be implemented via non-standard constructs; check if it expands to expressions using compiler extensions.\n\n- MHD_INVALID_SOCKET: Compared against CLIENT_SOCKS entries. This macro/constant's definition may use extensions (compiler-specific constant expressions or attributes). Also needed to confirm CLIENT_SOCKS element type matches MHD_socket.\n\n- MHD_YES, MHD_NO: Used as boolean-like macros. Their definitions could be non-standard (e.g. enums with attributes, or macros using typeof or statement-expressions). Required to confirm they are standard C constructs.\n\n- MHD_socket: The socket type used for ws->sock and CLIENT_SOCKS elements. Its typedef/definition may be a compiler-specific extension or alias (e.g. defined with attributes, unusual underlying types) \u2014 need to inspect.\n\n- struct MHD_UpgradeResponseHandle: The urh parameter is passed to MHD_upgrade_action and stored. Its definition could include extensions (anonymous members, attributes) that would violate MISRA language-extension prohibition.\n\n- MHD_upgrade_action: The function is called directly in error path. Its declaration/definition must be inspected for compiler-specific attributes, inline asm, or other extensions; also to see whether MHD_UPGRADE_ACTION_CLOSE is an enum/macro that relies on extensions.\n\n- MHD_UPGRADE_ACTION_CLOSE: The value passed to MHD_upgrade_action; its definition could use extensions (e.g. statement-expression macros, typeof, __extension__ constructs) so include it.\n\n- pthread_t, pthread_mutex_t, pthread_create, pthread_detach, pthread_mutex_lock, pthread_mutex_unlock: The code uses the pthread API. While POSIX, their header declarations may include compiler attributes or extensions (e.g. __nonnull, __attribute__((...))). To be sure no language extensions are used in types or function declarations invoked here, include their declarations.\n\n- malloc, free, memset, abort: Standard library functions used here. Their prototypes/headers may contain compiler-specific attributes or non-standard extensions; include them to confirm no extensions are used in the visible declarations.\n\nIn summary: provide the definitions/declarations of all data types, macros and functions that the function references (struct/typedefs, global variables/macros, and invoked functions), because any of those could themselves introduce compiler language extensions (attributes, built-ins, anonymous/zero-length constructs, inline asm, typeof, statement-expressions, etc.)."
}