{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN const union MHD_DaemonInfo *\nMHD_get_daemon_info (struct MHD_Daemon *daemon,\n                     enum MHD_DaemonInfoType info_type,\n                     ...)\n{\n  if (NULL == daemon)\n    return NULL;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  switch (info_type)\n  {\n  case MHD_DAEMON_INFO_KEY_SIZE:\n    return NULL;   /* no longer supported */\n  case MHD_DAEMON_INFO_MAC_KEY_SIZE:\n    return NULL;   /* no longer supported */\n  case MHD_DAEMON_INFO_LISTEN_FD:\n    daemon->daemon_info_dummy_listen_fd.listen_fd = daemon->listen_fd;\n    return &daemon->daemon_info_dummy_listen_fd;\n  case MHD_DAEMON_INFO_EPOLL_FD:\n#ifdef EPOLL_SUPPORT\n    daemon->daemon_info_dummy_epoll_fd.epoll_fd = daemon->epoll_fd;\n    return &daemon->daemon_info_dummy_epoll_fd;\n#else  /* ! EPOLL_SUPPORT */\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n  case MHD_DAEMON_INFO_CURRENT_CONNECTIONS:\n    if (! MHD_D_IS_THREAD_SAFE_ (daemon))\n      MHD_cleanup_connections (daemon);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    else if (daemon->worker_pool)\n    {\n      unsigned int i;\n      /* Collect the connection information stored in the workers. */\n      daemon->connections = 0;\n      for (i = 0; i < daemon->worker_pool_size; i++)\n      {\n        /* FIXME: next line is thread-safe only if read is atomic. */\n        daemon->connections += daemon->worker_pool[i].connections;\n      }\n    }\n#endif\n    daemon->daemon_info_dummy_num_connections.num_connections\n      = daemon->connections;\n    return &daemon->daemon_info_dummy_num_connections;\n  case MHD_DAEMON_INFO_FLAGS:\n    daemon->daemon_info_dummy_flags.flags = daemon->options;\n    return &daemon->daemon_info_dummy_flags;\n  case MHD_DAEMON_INFO_BIND_PORT:\n    daemon->daemon_info_dummy_port.port = daemon->port;\n    return &daemon->daemon_info_dummy_port;\n  default:\n    return NULL;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_daemon_info': {'callees': ['MHD_cleanup_connections'], 'callers': ['main', 'run_mhd']}, 'MHD_cleanup_connections': {'callees': ['__builtin_unreachable', 'cleanup_upgraded_connection', 'MHD_pool_destroy', 'MHD_ip_limit_del', 'MHD_destroy_response'], 'callers': ['MHD_add_connection', 'internal_run_from_select', 'MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread', 'close_all_connections', 'MHD_get_daemon_info']}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}, 'run_mhd': {'callees': ['get_num_threads', 'print_perf_warnings', 'get_mhd_response_size', 'MHD_start_daemon', 'MHD_get_daemon_info', 'get_mhd_conn_limit', 'MHD_stop_daemon'], 'callers': ['main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "mhd_assert",
    "MHD_thread_handle_ID_is_valid_handle_",
    "MHD_D_IS_THREAD_SAFE_",
    "EPOLL_SUPPORT",
    "MHD_USE_SELECT_INTERNALLY",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS",
    "struct MHD_Daemon (full definition)",
    "union MHD_DaemonInfo (full definition)",
    "enum MHD_DaemonInfoType (all enumerators)",
    "MHD_cleanup_connections (declaration and definition)"
  ],
  "explanation": "Why each symbol is needed to check for language-extension use in MHD_get_daemon_info:\n\n- _MHD_EXTERN\n  - This macro prefixes the function declaration. Its expansion may include compiler-specific storage-class qualifiers or attributes (for example, __attribute__((visibility(...))), __declspec(...)) which are explicit language/compiler extensions. You must see its definition to decide if an extension is used.\n\n- mhd_assert\n  - This macro is used twice and could expand to expressions using compiler extensions (e.g. __builtin_expect, __extension__, statement-expressions ({ ... }), or compiler-specific abort/assume intrinsics). The macro body must be inspected for any non-standard keywords or builtins.\n\n- MHD_thread_handle_ID_is_valid_handle_\n  - Used in assertions; its implementation may be a macro or inline function that employs platform-specific types or compiler intrinsics (e.g. __thread, __builtin_*, __attribute__). To determine whether the target function itself uses extensions via this call, its definition is required.\n\n- MHD_D_IS_THREAD_SAFE_\n  - This macro/function controls a conditional path that leads to calling MHD_cleanup_connections. Its expansion could contain compiler extensions; inspect to ensure no extensions are injected into the target function's logic.\n\n- EPOLL_SUPPORT\n  - A preprocessor conditional (#ifdef EPOLL_SUPPORT) alters the compiled code. EPOLL_SUPPORT may be defined via compiler flags or headers; its definition is needed to know which code path is actually compiled. Also header defining it may include extension usage affecting this function.\n\n- MHD_USE_SELECT_INTERNALLY\n  - Used inside mhd_assert to test daemon->options. Its definition (macro or compile-time option) may influence whether code uses any extension-based constructs or alter assertions that expand to extension usage; include to fully evaluate macro expansions.\n\n- MHD_USE_POSIX_THREADS and MHD_USE_W32_THREADS\n  - These control the conditional block that iterates the worker_pool and are preprocessor macros. Their definitions determine whether that block is compiled. The block could contain constructs that use extensions (e.g. atomic reads, intrinsics), so their values and associated headers/macros must be known.\n\n- struct MHD_Daemon (full definition)\n  - The function accesses many fields (options, worker_pool, tid, listen_fd, epoll_fd, daemon_info_dummy_*, connections, port, worker_pool_size). The struct definition must be inspected because field types or member attributes could use compiler extensions (e.g. bitfields with implementation-defined behavior, packed/aligned attributes, __attribute__ annotations, anonymous unions/structs which may be a language extension depending on standard). Also the dummy members are unions/structs returned by address \u2014 their types may use extensions.\n\n- union MHD_DaemonInfo (full definition)\n  - The function returns a pointer to a union MHD_DaemonInfo. The union / its member types or any attributes on it might be implemented using language extensions (anonymous union members, attributes). You must inspect the union definition to detect such usages.\n\n- enum MHD_DaemonInfoType (all enumerators)\n  - The switch operates on this enum; its definition is needed to verify that the enumerators used are standard and to check for any non-standard extensions (e.g. unusual underlying type specifiers, compiler-specific attributes attached to enumerators).\n\n- MHD_cleanup_connections (declaration and definition)\n  - This function is called from MHD_get_daemon_info when !MHD_D_IS_THREAD_SAFE_. Even though the call itself is standard, the function declaration/definition might use attributes (noreturn, visibility, calling-convention extensions) or may be a macro wrapping compiler extensions. The static call graph indicates MHD_cleanup_connections uses __builtin_unreachable in its callees; you must inspect its declaration/definition to ensure no extension is pulled into the target function's translation unit via the call.\n\nIn short, any macro, typedef/struct/union/enum, or function used directly in MHD_get_daemon_info might expand to or be annotated with compiler-specific extensions. The symbols above are the minimal set whose definitions must be inspected to determine whether the target function (as compiled) uses language extensions that would violate the MISRA rule."
}