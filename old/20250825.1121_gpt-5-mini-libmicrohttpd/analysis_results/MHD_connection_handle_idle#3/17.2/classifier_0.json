{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_connection_handle_idle:\n```c\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_connection_handle_idle:\nstatic bool\nget_request_line (struct MHD_Connection *c)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Parse whitespace in URI, special parsing of the request line */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n\n  if (! get_request_line_inner (c))\n  {\n    /* End of the request line has not been found yet */\n    mhd_assert ((! wsp_in_uri) || NULL == c->rq.version);\n    if ((NULL != c->rq.version) &&\n        (HTTP_VER_LEN <\n         (c->rq.hdrs.rq_line.proc_pos\n          - (size_t) (c->rq.version - c->read_buffer))))\n    {\n      c->rq.http_ver = MHD_HTTP_VER_INVALID;\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_MALFORMED);\n      return true; /* Error in the request */\n    }\n    return false;\n  }\n  if (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state)\n    return true; /* Error in the request */\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  if (0 != c->rq.hdrs.rq_line.num_ws_in_uri)\n  {\n    if (! wsp_in_uri)\n    {\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      RQ_TARGET_INVALID_CHAR);\n      return true; /* Error in the request */\n    }\n    if (! wsp_in_uri_keep)\n    {\n      send_redirect_fixed_rq_target (c);\n      return true; /* Error in the request */\n    }\n  }\n  if (! process_request_target (c))\n    return true; /* Error in processing */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVED;\n  return true;\n}\n...\nstatic void\nparse_connection_headers (struct MHD_Connection *connection)\n{\n  const char *clen;\n  const char *enc;\n  size_t val_len;\n\n#ifdef COOKIE_SUPPORT\n  if (MHD_PARSE_COOKIE_NO_MEMORY == parse_cookie_header (connection))\n  {\n    handle_req_cookie_no_space (connection);\n    return;\n  }\n#endif /* COOKIE_SUPPORT */\n  if ( (-3 < connection->daemon->client_discipline) &&\n       (MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver)) &&\n       (MHD_NO ==\n        MHD_lookup_connection_value_n (connection,\n                                       MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_HOST,\n                                       MHD_STATICSTR_LEN_ (\n                                         MHD_HTTP_HEADER_HOST),\n                                       NULL,\n                                       NULL)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Received HTTP/1.1 request without `Host' header.\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_BAD_REQUEST,\n                                    REQUEST_LACKS_HOST);\n    return;\n  }\n\n  /* The presence of the request body is indicated by \"Content-Length:\" or\n     \"Transfer-Encoding:\" request headers.\n     Unless one of these two headers is used, the request has no request body.\n     See RFC9112, Section 6, paragraph 4. */\n  connection->rq.remaining_upload_size = 0;\n  if (MHD_NO !=\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_TRANSFER_ENCODING),\n                                     &enc,\n                                     NULL))\n  {\n    if (! MHD_str_equal_caseless_ (enc,\n                                   \"chunked\"))\n    {\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_UNSUPPORTED_TR_ENCODING);\n      return;\n    }\n    else if (MHD_NO !=\n             MHD_lookup_connection_value_n (connection,\n                                            MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                            MHD_STATICSTR_LEN_ ( \\\n                                              MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                            NULL,\n                                            NULL))\n    {\n      /* TODO: add individual settings */\n      if (1 <= connection->daemon->client_discipline)\n      {\n        transmit_error_response_static (connection,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_LENGTH_WITH_TR_ENCODING);\n        return;\n      }\n      else\n      {\n        /* Must close connection after reply to prevent potential attack */\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The 'Content-Length' request header is ignored \"\n                     \"as chunked Transfer-Encoding is used \"\n                     \"for this request.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n    }\n    connection->rq.have_chunked_upload = true;\n    connection->rq.remaining_upload_size = MHD_SIZE_UNKNOWN;\n  }\n  else if (MHD_NO !=\n           MHD_lookup_connection_value_n (connection,\n                                          MHD_HEADER_KIND,\n                                          MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          MHD_STATICSTR_LEN_ (\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                          &clen,\n                                          &val_len))\n  {\n    size_t num_digits;\n\n    num_digits = MHD_str_to_uint64_n_ (clen,\n                                       val_len,\n                                       &connection->rq.remaining_upload_size);\n\n    if (((0 == num_digits) &&\n         (0 != val_len) &&\n         ('0' <= clen[0]) && ('9' >= clen[0]))\n        || (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Too large value of 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_CONTENT_TOO_LARGE,\n                                      REQUEST_CONTENTLENGTH_TOOLARGE);\n    }\n    else if ((val_len != num_digits) ||\n             (0 == num_digits))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to parse 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_CONTENTLENGTH_MALFORMED);\n    }\n  }\n}\n...\nstatic void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t available;\n  bool instant_retry;\n  char *buffer_head;\n  const int discp_lvl = daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Allow \"Bad WhiteSpace\" in chunk extension.\n     RFC 9112, Section 7.1.1, Paragraph 2 */\n  const bool allow_bws = (2 < discp_lvl);\n\n  mhd_assert (NULL == connection->rp.response);\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n  {\n    size_t to_be_processed;\n    size_t left_unprocessed;\n    size_t processed_size;\n\n    instant_retry = false;\n    if (connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      if ( (connection->rq.current_chunk_offset ==\n            connection->rq.current_chunk_size) &&\n           (0 != connection->rq.current_chunk_size) )\n      {\n        size_t i;\n        mhd_assert (0 != available);\n        /* skip new line at the *end* of a chunk */\n        i = 0;\n        if ( (2 <= available) &&\n             ('\\r' == buffer_head[0]) &&\n             ('\\n' == buffer_head[1]) )\n          i += 2;                        /* skip CRLF */\n        else if (bare_lf_as_crlf && ('\\n' == buffer_head[0]))\n          i++;                           /* skip bare LF */\n        else if (2 > available)\n          break;                         /* need more upload data */\n        if (0 == i)\n        {\n          /* malformed encoding */\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n          return;\n        }\n        available -= i;\n        buffer_head += i;\n        connection->rq.current_chunk_offset = 0;\n        connection->rq.current_chunk_size = 0;\n        if (0 == available)\n          break;\n      }\n      if (0 != connection->rq.current_chunk_size)\n      {\n        uint64_t cur_chunk_left;\n        mhd_assert (connection->rq.current_chunk_offset < \\\n                    connection->rq.current_chunk_size);\n        /* we are in the middle of a chunk, give\n           as much as possible to the client (without\n           crossing chunk boundaries) */\n        cur_chunk_left\n          = connection->rq.current_chunk_size\n            - connection->rq.current_chunk_offset;\n        if (cur_chunk_left > available)\n          to_be_processed = available;\n        else\n        {         /* cur_chunk_left <= (size_t)available */\n          to_be_processed = (size_t) cur_chunk_left;\n          if (available > to_be_processed)\n            instant_retry = true;\n        }\n      }\n      else\n      { /* Need the parse the chunk size line */\n        /** The number of found digits in the chunk size number */\n        size_t num_dig;\n        uint64_t chunk_size;\n        bool broken;\n        bool overflow;\n\n        mhd_assert (0 != available);\n\n        overflow = false;\n        chunk_size = 0; /* Mute possible compiler warning.\n                           The real value will be set later. */\n\n        num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n                                         available,\n                                         &chunk_size);\n        mhd_assert (num_dig <= available);\n        if (num_dig == available)\n          continue; /* Need line delimiter */\n\n        broken = (0 == num_dig);\n        if (broken)\n          /* Check whether result is invalid due to uint64_t overflow */\n          overflow = ((('0' <= buffer_head[0]) && ('9' >= buffer_head[0])) ||\n                      (('A' <= buffer_head[0]) && ('F' >= buffer_head[0])) ||\n                      (('a' <= buffer_head[0]) && ('f' >= buffer_head[0])));\n        else\n        {\n          /**\n           * The length of the string with the number of the chunk size,\n           * including chunk extension\n           */\n          size_t chunk_size_line_len;\n\n          chunk_size_line_len = 0;\n          if ((';' == buffer_head[num_dig]) ||\n              (allow_bws &&\n               ((' ' == buffer_head[num_dig]) ||\n                ('\\t' == buffer_head[num_dig]))))\n          { /* Chunk extension */\n            size_t i;\n\n            /* Skip bad whitespaces (if any) */\n            for (i = num_dig; i < available; ++i)\n            {\n              if ((' ' != buffer_head[i]) && ('\\t' != buffer_head[i]))\n                break;\n            }\n            if (i == available)\n              break; /* need more data */\n            if (';' == buffer_head[i])\n            {\n              for (++i; i < available; ++i)\n              {\n                if ('\\n' == buffer_head[i])\n                  break;\n              }\n              if (i == available)\n                break; /* need more data */\n              mhd_assert (i > num_dig);\n              mhd_assert (1 <= i);\n              /* Found LF position */\n              if (bare_lf_as_crlf)\n                chunk_size_line_len = i; /* Don't care about CR before LF */\n              else if ('\\r' == buffer_head[i - 1])\n                chunk_size_line_len = i;\n            }\n            else\n            { /* No ';' after \"bad whitespace\" */\n              mhd_assert (allow_bws);\n              mhd_assert (0 == chunk_size_line_len);\n            }\n          }\n          else\n          {\n            mhd_assert (available >= num_dig);\n            if ((2 <= (available - num_dig)) &&\n                ('\\r' == buffer_head[num_dig]) &&\n                ('\\n' == buffer_head[num_dig + 1]))\n              chunk_size_line_len = num_dig + 2;\n            else if (bare_lf_as_crlf &&\n                     ('\\n' == buffer_head[num_dig]))\n              chunk_size_line_len = num_dig + 1;\n            else if (2 > (available - num_dig))\n              break; /* need more data */\n          }\n\n          if (0 != chunk_size_line_len)\n          { /* Valid termination of the chunk size line */\n            mhd_assert (chunk_size_line_len <= available);\n            /* Start reading payload data of the chunk */\n            connection->rq.current_chunk_offset = 0;\n            connection->rq.current_chunk_size = chunk_size;\n\n            available -= chunk_size_line_len;\n            buffer_head += chunk_size_line_len;\n\n            if (0 == chunk_size)\n            { /* The final (termination) chunk */\n              connection->rq.remaining_upload_size = 0;\n              break;\n            }\n            if (available > 0)\n              instant_retry = true;\n            continue;\n          }\n          /* Invalid chunk size line */\n        }\n\n        if (! overflow)\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          REQUEST_CHUNKED_MALFORMED);\n        else\n          transmit_error_response_static (connection,\n                                          MHD_HTTP_CONTENT_TOO_LARGE,\n                                          REQUEST_CHUNK_TOO_LARGE);\n        return;\n      }\n    }\n    else\n    {\n      /* no chunked encoding, give all to the client */\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      if (connection->rq.remaining_upload_size < available)\n        to_be_processed = (size_t) connection->rq.remaining_upload_size;\n      else\n        to_be_processed = available;\n    }\n    left_unprocessed = to_be_processed;\n    connection->rq.client_aware = true;\n    connection->in_access_handler = true;\n    if (MHD_NO ==\n        daemon->default_handler (daemon->default_handler_cls,\n                                 connection,\n                                 connection->rq.url,\n                                 connection->rq.method,\n                                 connection->rq.version,\n                                 buffer_head,\n                                 &left_unprocessed,\n                                 &connection->rq.client_context))\n    {\n      connection->in_access_handler = false;\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Application reported internal error, \" \\\n                                 \"closing connection.\"));\n      return;\n    }\n    connection->in_access_handler = false;\n\n    if (left_unprocessed > to_be_processed)\n      MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n\n    connection->rq.some_payload_processed =\n      (left_unprocessed != to_be_processed);\n\n    if (0 != left_unprocessed)\n    {\n      instant_retry = false; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n      if ((! connection->rq.some_payload_processed) &&\n          (! connection->suspended))\n      {\n        /* client did not process any upload data, complain if\n           the setup was incorrect, which may prevent us from\n           handling the rest of the request */\n        if (MHD_D_IS_USING_THREADS_ (daemon))\n          MHD_DLOG (daemon,\n                    _ (\"WARNING: Access Handler Callback has not processed \" \\\n                       \"any upload data and connection is not suspended. \" \\\n                       \"This may result in hung connection.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n    }\n    processed_size = to_be_processed - left_unprocessed;\n    /* dh left \"processed\" bytes in buffer for next time... */\n    buffer_head += processed_size;\n    available -= processed_size;\n    if (! connection->rq.have_chunked_upload)\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN != connection->rq.remaining_upload_size);\n      connection->rq.remaining_upload_size -= processed_size;\n    }\n    else\n    {\n      mhd_assert (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size);\n      connection->rq.current_chunk_offset += processed_size;\n    }\n  } while (instant_retry);\n  /* TODO: zero out reused memory region */\n  if ( (available > 0) &&\n       (buffer_head != connection->read_buffer) )\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  else\n    mhd_assert ((0 == available) || \\\n                (connection->read_buffer_offset == available));\n  connection->read_buffer_offset = available;\n}\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n...\nstatic void\ncall_connection_handler (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t processed;\n\n  if (NULL != connection->rp.response)\n    return;                     /* already queued a response */\n  processed = 0;\n  connection->rq.client_aware = true;\n  connection->in_access_handler = true;\n  if (MHD_NO ==\n      daemon->default_handler (daemon->default_handler_cls,\n                               connection,\n                               connection->rq.url,\n                               connection->rq.method,\n                               connection->rq.version,\n                               NULL,\n                               &processed,\n                               &connection->rq.client_context))\n  {\n    connection->in_access_handler = false;\n    /* serious internal error, close connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Application reported internal error, \" \\\n                               \"closing connection.\"));\n    return;\n  }\n  connection->in_access_handler = false;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (get_req_headers (connection, true))\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. Although get_req_headers (or functions it calls, e.g. transmit_error_response_* -> MHD_queue_response) could cause queuing a response, MHD_queue_response only calls MHD_connection_handle_idle when connection->in_idle is false. MHD_connection_handle_idle sets connection->in_idle = true before calling get_req_headers, so the indirect recursive call is prevented. Therefore the fragment if (get_req_headers(connection, true)) does not lead to direct or indirect self-call in this context."
}