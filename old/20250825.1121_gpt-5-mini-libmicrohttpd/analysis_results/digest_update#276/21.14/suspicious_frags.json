{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of digest_update:\n```c\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function digest_update:\nvoid\nMHD_MD5_update (struct Md5Ctx *ctx,\n                const uint8_t *data,\n                size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (MD5_BLOCK_SIZE-1))\n           equals (count % MD5_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (MD5_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = MD5_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      md5_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (MD5_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    md5_transform (ctx->H, data);\n    data += MD5_BLOCK_SIZE;\n    length -= MD5_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n...\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n...\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n...\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    memcpy (X, M, sizeof(X));\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n}\n...\nstatic void\nsha256_transform (uint32_t H[SHA256_DIGEST_SIZE_WORDS],\n                  const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 paragraph 6.2. */\n  uint32_t a = H[0];\n  uint32_t b = H[1];\n  uint32_t c = H[2];\n  uint32_t d = H[3];\n  uint32_t e = H[4];\n  uint32_t f = H[5];\n  uint32_t g = H[6];\n  uint32_t h = H[7];\n\n  /* Data buffer, used as cyclic buffer.\n     See FIPS PUB 180-4 paragraphs 5.2.1, 6.2. */\n  uint32_t W[16];\n\n#ifndef _MHD_GET_32BIT_BE_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT32_ALIGN))\n  {\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, SHA256_BLOCK_SIZE);\n    /* The W[] buffer itself will be used as the source of the data,\n     * but data will be reloaded in correct bytes order during\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_32BIT_BE_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimization.\n     See FIPS PUB 180-4 formulae 4.2, 4.3. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.4, 4.5, 4.6, 4.7. */\n#define SIG0(x)  (_MHD_ROTR32 ((x), 2) ^ _MHD_ROTR32 ((x), 13) ^ \\\n                  _MHD_ROTR32 ((x), 22) )\n#define SIG1(x)  (_MHD_ROTR32 ((x), 6) ^ _MHD_ROTR32 ((x), 11) ^ \\\n                  _MHD_ROTR32 ((x), 25) )\n#define sig0(x)  (_MHD_ROTR32 ((x), 7) ^ _MHD_ROTR32 ((x), 18) ^ \\\n                  ((x) >> 3) )\n#define sig1(x)  (_MHD_ROTR32 ((x), 17) ^ _MHD_ROTR32 ((x),19) ^ \\\n                  ((x) >> 10) )\n\n  /* One step of SHA-256 computation,\n     see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n           second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other data as well\n           every time when used. */\n#define SHA2STEP32(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer,\n     See FIPS PUB 180-4 paragraph 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 paragraph 3.1.2. */\n  /* Use cast to (const void*) to mute compiler alignment warning,\n   * data was already aligned in previous step */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_BE ((const void*)(((const uint8_t*) (buf)) + \\\n                                   (t) * SHA256_BYTES_IN_WORD))\n\n  /* 'W' generation and assignment for 16 <= t <= 63.\n     See FIPS PUB 180-4 paragraph 6.2.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as cyclic buffer.\n   * Note: ((t-16)&0xf) have same value as (t&0xf) */\n#define Wgen(w,t) ( (w)[(t - 16) & 0xf] + sig1 ((w)[((t) - 2) & 0xf])   \\\n                    + (w)[((t) - 7) & 0xf] + sig0 ((w)[((t) - 15) & 0xf]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP32(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP32(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7]);\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0] = \\\n                  GET_W_FROM_DATA (data, 0));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1] = \\\n                  GET_W_FROM_DATA (data, 1));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2] = \\\n                  GET_W_FROM_DATA (data, 2));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3] = \\\n                  GET_W_FROM_DATA (data, 3));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4] = \\\n                  GET_W_FROM_DATA (data, 4));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5] = \\\n                  GET_W_FROM_DATA (data, 5));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6] = \\\n                  GET_W_FROM_DATA (data, 6));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7] = \\\n                  GET_W_FROM_DATA (data, 7));\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8] = \\\n                  GET_W_FROM_DATA (data, 8));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9] = \\\n                  GET_W_FROM_DATA (data, 9));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10] = \\\n                  GET_W_FROM_DATA (data, 10));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11] = \\\n                  GET_W_FROM_DATA (data, 11));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12] = \\\n                  GET_W_FROM_DATA (data, 12));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13] = \\\n                  GET_W_FROM_DATA (data, 13));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14] = \\\n                  GET_W_FROM_DATA (data, 14));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15] = \\\n                  GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 48 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xe49b69c1), W[16 & 0xf] = \\\n                Wgen (W,16));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xefbe4786), W[17 & 0xf] = \\\n                Wgen (W,17));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x0fc19dc6), W[18 & 0xf] = \\\n                Wgen (W,18));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x240ca1cc), W[19 & 0xf] = \\\n                Wgen (W,19));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x2de92c6f), W[20 & 0xf] = \\\n                Wgen (W,20));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4a7484aa), W[21 & 0xf] = \\\n                Wgen (W,21));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5cb0a9dc), W[22 & 0xf] = \\\n                Wgen (W,22));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x76f988da), W[23 & 0xf] = \\\n                Wgen (W,23));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x983e5152), W[24 & 0xf] = \\\n                Wgen (W,24));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa831c66d), W[25 & 0xf] = \\\n                Wgen (W,25));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb00327c8), W[26 & 0xf] = \\\n                Wgen (W,26));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xbf597fc7), W[27 & 0xf] = \\\n                Wgen (W,27));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xc6e00bf3), W[28 & 0xf] = \\\n                Wgen (W,28));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd5a79147), W[29 & 0xf] = \\\n                Wgen (W,29));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x06ca6351), W[30 & 0xf] = \\\n                Wgen (W,30));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x14292967), W[31 & 0xf] = \\\n                Wgen (W,31));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x27b70a85), W[32 & 0xf] = \\\n                Wgen (W,32));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x2e1b2138), W[33 & 0xf] = \\\n                Wgen (W,33));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x4d2c6dfc), W[34 & 0xf] = \\\n                Wgen (W,34));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x53380d13), W[35 & 0xf] = \\\n                Wgen (W,35));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x650a7354), W[36 & 0xf] = \\\n                Wgen (W,36));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x766a0abb), W[37 & 0xf] = \\\n                Wgen (W,37));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x81c2c92e), W[38 & 0xf] = \\\n                Wgen (W,38));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x92722c85), W[39 & 0xf] = \\\n                Wgen (W,39));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xa2bfe8a1), W[40 & 0xf] = \\\n                Wgen (W,40));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa81a664b), W[41 & 0xf] = \\\n                Wgen (W,41));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xc24b8b70), W[42 & 0xf] = \\\n                Wgen (W,42));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xc76c51a3), W[43 & 0xf] = \\\n                Wgen (W,43));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xd192e819), W[44 & 0xf] = \\\n                Wgen (W,44));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd6990624), W[45 & 0xf] = \\\n                Wgen (W,45));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xf40e3585), W[46 & 0xf] = \\\n                Wgen (W,46));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x106aa070), W[47 & 0xf] = \\\n                Wgen (W,47));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x19a4c116), W[48 & 0xf] = \\\n                Wgen (W,48));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x1e376c08), W[49 & 0xf] = \\\n                Wgen (W,49));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x2748774c), W[50 & 0xf] = \\\n                Wgen (W,50));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x34b0bcb5), W[51 & 0xf] = \\\n                Wgen (W,51));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x391c0cb3), W[52 & 0xf] = \\\n                Wgen (W,52));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4ed8aa4a), W[53 & 0xf] = \\\n                Wgen (W,53));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5b9cca4f), W[54 & 0xf] = \\\n                Wgen (W,54));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x682e6ff3), W[55 & 0xf] = \\\n                Wgen (W,55));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x748f82ee), W[56 & 0xf] = \\\n                Wgen (W,56));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x78a5636f), W[57 & 0xf] = \\\n                Wgen (W,57));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x84c87814), W[58 & 0xf] = \\\n                Wgen (W,58));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x8cc70208), W[59 & 0xf] = \\\n                Wgen (W,59));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x90befffa), W[60 & 0xf] = \\\n                Wgen (W,60));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xa4506ceb), W[61 & 0xf] = \\\n                Wgen (W,61));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xbef9a3f7), W[62 & 0xf] = \\\n                Wgen (W,62));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc67178f2), W[63 & 0xf] = \\\n                Wgen (W,63));\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n    static const uint32_t K[80] =\n    { UINT32_C (0x428a2f98),  UINT32_C (0x71374491),  UINT32_C (0xb5c0fbcf),\n      UINT32_C (0xe9b5dba5),  UINT32_C (0x3956c25b),  UINT32_C (0x59f111f1),\n      UINT32_C (0x923f82a4),  UINT32_C (0xab1c5ed5),  UINT32_C (0xd807aa98),\n      UINT32_C (0x12835b01),  UINT32_C (0x243185be),  UINT32_C (0x550c7dc3),\n      UINT32_C (0x72be5d74),  UINT32_C (0x80deb1fe),  UINT32_C (0x9bdc06a7),\n      UINT32_C (0xc19bf174),  UINT32_C (0xe49b69c1),  UINT32_C (0xefbe4786),\n      UINT32_C (0x0fc19dc6),  UINT32_C (0x240ca1cc),  UINT32_C (0x2de92c6f),\n      UINT32_C (0x4a7484aa),  UINT32_C (0x5cb0a9dc),  UINT32_C (0x76f988da),\n      UINT32_C (0x983e5152),  UINT32_C (0xa831c66d),  UINT32_C (0xb00327c8),\n      UINT32_C (0xbf597fc7),  UINT32_C (0xc6e00bf3),  UINT32_C (0xd5a79147),\n      UINT32_C (0x06ca6351),  UINT32_C (0x14292967),  UINT32_C (0x27b70a85),\n      UINT32_C (0x2e1b2138),  UINT32_C (0x4d2c6dfc),  UINT32_C (0x53380d13),\n      UINT32_C (0x650a7354),  UINT32_C (0x766a0abb),  UINT32_C (0x81c2c92e),\n      UINT32_C (0x92722c85),  UINT32_C (0xa2bfe8a1),  UINT32_C (0xa81a664b),\n      UINT32_C (0xc24b8b70),  UINT32_C (0xc76c51a3),  UINT32_C (0xd192e819),\n      UINT32_C (0xd6990624),  UINT32_C (0xf40e3585),  UINT32_C (0x106aa070),\n      UINT32_C (0x19a4c116),  UINT32_C (0x1e376c08),  UINT32_C (0x2748774c),\n      UINT32_C (0x34b0bcb5),  UINT32_C (0x391c0cb3),  UINT32_C (0x4ed8aa4a),\n      UINT32_C (0x5b9cca4f),  UINT32_C (0x682e6ff3),  UINT32_C (0x748f82ee),\n      UINT32_C (0x78a5636f),  UINT32_C (0x84c87814),  UINT32_C (0x8cc70208),\n      UINT32_C (0x90befffa),  UINT32_C (0xa4506ceb),  UINT32_C (0xbef9a3f7),\n      UINT32_C (0xc67178f2) };\n    /* One step of SHA-256 computation with working variables rotation,\n       see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP32RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n    uint32_t tmp_h_ = (vH);                                           \\\n    SHA2STEP32((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));  \\\n    (vH) = (vG);                                                      \\\n    (vG) = (vF);                                                      \\\n    (vF) = (vE);                                                      \\\n    (vE) = (vD);                                                      \\\n    (vD) = (vC);                                                      \\\n    (vC) = (vB);                                                      \\\n    (vB) = (vA);                                                      \\\n    (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n\n    /* During last 48 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 64; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n\n  /* Compute intermediate hash.\n     See FIPS PUB 180-4 paragraph 6.2.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n...\nstatic void\nsha512_256_transform (uint64_t H[SHA512_256_HASH_SIZE_WORDS],\n                      const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 clause 6.7, 6.4. */\n  uint64_t a = H[0];\n  uint64_t b = H[1];\n  uint64_t c = H[2];\n  uint64_t d = H[3];\n  uint64_t e = H[4];\n  uint64_t f = H[5];\n  uint64_t g = H[6];\n  uint64_t h = H[7];\n\n  /* Data buffer, used as a cyclic buffer.\n     See FIPS PUB 180-4 clause 5.2.2, 6.7, 6.4. */\n  uint64_t W[16];\n\n#ifndef _MHD_GET_64BIT_BE_ALLOW_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT64_ALIGN))\n  { /* The input data is unaligned */\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, sizeof(W));\n    /* The W[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_64BIT_BE_ALLOW_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimisation.\n     See FIPS PUB 180-4 formulae 4.8, 4.9. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.10, 4.11, 4.12, 4.13. */\n#define SIG0(x)  \\\n  ( _MHD_ROTR64 ((x), 28) ^ _MHD_ROTR64 ((x), 34) ^ _MHD_ROTR64 ((x), 39) )\n#define SIG1(x)  \\\n  ( _MHD_ROTR64 ((x), 14) ^ _MHD_ROTR64 ((x), 18) ^ _MHD_ROTR64 ((x), 41) )\n#define sig0(x)  \\\n  ( _MHD_ROTR64 ((x), 1) ^ _MHD_ROTR64 ((x), 8) ^ ((x) >> 7) )\n#define sig1(x)  \\\n  ( _MHD_ROTR64 ((x), 19) ^ _MHD_ROTR64 ((x), 61) ^ ((x) >> 6) )\n\n  /* One step of SHA-512/256 computation,\n     see FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: the first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n           the second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other\n           data as well every time when used. */\n#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer for 0 <= t <= 15,\n     See FIPS PUB 180-4 clause 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 clause 3.1.2. */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_64BIT_BE (((const uint64_t*) (buf)) + (t))\n\n  /* 'W' generation and assignment for 16 <= t <= 79.\n     See FIPS PUB 180-4 clause 6.4.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as a cyclic buffer.\n   * Note: ((t-16) & 15) have same value as (t & 15) */\n#define Wgen(w,t) ( (w)[(t - 16) & 15] + sig1 ((w)[((t) - 2) & 15])   \\\n                    + (w)[((t) - 7) & 15] + sig0 ((w)[((t) - 15) & 15]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP64(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP64(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), W[0]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), W[1]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), W[2]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), W[3]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), W[4]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), W[5]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), W[6]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), W[7]);\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), W[8]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), W[9]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), W[10]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), W[11]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), W[12]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), W[13]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), W[14]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), \\\n                W[0] = GET_W_FROM_DATA (data, 0));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), \\\n                W[1] = GET_W_FROM_DATA (data, 1));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), \\\n                W[2] = GET_W_FROM_DATA (data, 2));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), \\\n                W[3] = GET_W_FROM_DATA (data, 3));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), \\\n                W[4] = GET_W_FROM_DATA (data, 4));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), \\\n                W[5] = GET_W_FROM_DATA (data, 5));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), \\\n                W[6] = GET_W_FROM_DATA (data, 6));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), \\\n                W[7] = GET_W_FROM_DATA (data, 7));\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), \\\n                W[8] = GET_W_FROM_DATA (data, 8));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), \\\n                W[9] = GET_W_FROM_DATA (data, 9));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), \\\n                W[10] = GET_W_FROM_DATA (data, 10));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), \\\n                W[11] = GET_W_FROM_DATA (data, 11));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), \\\n                W[12] = GET_W_FROM_DATA (data, 12));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), \\\n                W[13] = GET_W_FROM_DATA (data, 13));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), \\\n                W[14] = GET_W_FROM_DATA (data, 14));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), \\\n                W[15] = GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 64 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n     K values. */\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xe49b69c19ef14ad2), \\\n              W[16 & 15] = Wgen (W,16));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xefbe4786384f25e3), \\\n              W[17 & 15] = Wgen (W,17));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x0fc19dc68b8cd5b5), \\\n              W[18 & 15] = Wgen (W,18));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x240ca1cc77ac9c65), \\\n              W[19 & 15] = Wgen (W,19));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x2de92c6f592b0275), \\\n              W[20 & 15] = Wgen (W,20));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4a7484aa6ea6e483), \\\n              W[21 & 15] = Wgen (W,21));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5cb0a9dcbd41fbd4), \\\n              W[22 & 15] = Wgen (W,22));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x76f988da831153b5), \\\n              W[23 & 15] = Wgen (W,23));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x983e5152ee66dfab), \\\n              W[24 & 15] = Wgen (W,24));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa831c66d2db43210), \\\n              W[25 & 15] = Wgen (W,25));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb00327c898fb213f), \\\n              W[26 & 15] = Wgen (W,26));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xbf597fc7beef0ee4), \\\n              W[27 & 15] = Wgen (W,27));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xc6e00bf33da88fc2), \\\n              W[28 & 15] = Wgen (W,28));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd5a79147930aa725), \\\n              W[29 & 15] = Wgen (W,29));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x06ca6351e003826f), \\\n              W[30 & 15] = Wgen (W,30));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x142929670a0e6e70), \\\n              W[31 & 15] = Wgen (W,31));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x27b70a8546d22ffc), \\\n              W[32 & 15] = Wgen (W,32));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x2e1b21385c26c926), \\\n              W[33 & 15] = Wgen (W,33));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x4d2c6dfc5ac42aed), \\\n              W[34 & 15] = Wgen (W,34));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x53380d139d95b3df), \\\n              W[35 & 15] = Wgen (W,35));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x650a73548baf63de), \\\n              W[36 & 15] = Wgen (W,36));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x766a0abb3c77b2a8), \\\n              W[37 & 15] = Wgen (W,37));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x81c2c92e47edaee6), \\\n              W[38 & 15] = Wgen (W,38));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x92722c851482353b), \\\n              W[39 & 15] = Wgen (W,39));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xa2bfe8a14cf10364), \\\n              W[40 & 15] = Wgen (W,40));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa81a664bbc423001), \\\n              W[41 & 15] = Wgen (W,41));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xc24b8b70d0f89791), \\\n              W[42 & 15] = Wgen (W,42));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xc76c51a30654be30), \\\n              W[43 & 15] = Wgen (W,43));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xd192e819d6ef5218), \\\n              W[44 & 15] = Wgen (W,44));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd69906245565a910), \\\n              W[45 & 15] = Wgen (W,45));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xf40e35855771202a), \\\n              W[46 & 15] = Wgen (W,46));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x106aa07032bbd1b8), \\\n              W[47 & 15] = Wgen (W,47));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x19a4c116b8d2d0c8), \\\n              W[48 & 15] = Wgen (W,48));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x1e376c085141ab53), \\\n              W[49 & 15] = Wgen (W,49));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x2748774cdf8eeb99), \\\n              W[50 & 15] = Wgen (W,50));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x34b0bcb5e19b48a8), \\\n              W[51 & 15] = Wgen (W,51));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x391c0cb3c5c95a63), \\\n              W[52 & 15] = Wgen (W,52));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4ed8aa4ae3418acb), \\\n              W[53 & 15] = Wgen (W,53));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5b9cca4f7763e373), \\\n              W[54 & 15] = Wgen (W,54));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x682e6ff3d6b2b8a3), \\\n              W[55 & 15] = Wgen (W,55));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x748f82ee5defb2fc), \\\n              W[56 & 15] = Wgen (W,56));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x78a5636f43172f60), \\\n              W[57 & 15] = Wgen (W,57));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x84c87814a1f0ab72), \\\n              W[58 & 15] = Wgen (W,58));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x8cc702081a6439ec), \\\n              W[59 & 15] = Wgen (W,59));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x90befffa23631e28), \\\n              W[60 & 15] = Wgen (W,60));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xa4506cebde82bde9), \\\n              W[61 & 15] = Wgen (W,61));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xbef9a3f7b2c67915), \\\n              W[62 & 15] = Wgen (W,62));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc67178f2e372532b), \\\n              W[63 & 15] = Wgen (W,63));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xca273eceea26619c), \\\n              W[64 & 15] = Wgen (W,64));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xd186b8c721c0c207), \\\n              W[65 & 15] = Wgen (W,65));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xeada7dd6cde0eb1e), \\\n              W[66 & 15] = Wgen (W,66));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xf57d4f7fee6ed178), \\\n              W[67 & 15] = Wgen (W,67));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x06f067aa72176fba), \\\n              W[68 & 15] = Wgen (W,68));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x0a637dc5a2c898a6), \\\n              W[69 & 15] = Wgen (W,69));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x113f9804bef90dae), \\\n              W[70 & 15] = Wgen (W,70));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x1b710b35131c471b), \\\n              W[71 & 15] = Wgen (W,71));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x28db77f523047d84), \\\n              W[72 & 15] = Wgen (W,72));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x32caab7b40c72493), \\\n              W[73 & 15] = Wgen (W,73));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x3c9ebe0a15c9bebc), \\\n              W[74 & 15] = Wgen (W,74));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x431d67c49c100d4c), \\\n              W[75 & 15] = Wgen (W,75));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x4cc5d4becb3e42b6), \\\n              W[76 & 15] = Wgen (W,76));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x597f299cfc657e2a), \\\n              W[77 & 15] = Wgen (W,77));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5fcb6fab3ad6faec), \\\n              W[78 & 15] = Wgen (W,78));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x6c44198c4a475817), \\\n              W[79 & 15] = Wgen (W,79));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 clause 4.2.3 for K values. */\n    static const uint64_t K[80] =\n    { UINT64_C (0x428a2f98d728ae22), UINT64_C (0x7137449123ef65cd),\n      UINT64_C (0xb5c0fbcfec4d3b2f), UINT64_C (0xe9b5dba58189dbbc),\n      UINT64_C (0x3956c25bf348b538), UINT64_C (0x59f111f1b605d019),\n      UINT64_C (0x923f82a4af194f9b), UINT64_C (0xab1c5ed5da6d8118),\n      UINT64_C (0xd807aa98a3030242), UINT64_C (0x12835b0145706fbe),\n      UINT64_C (0x243185be4ee4b28c), UINT64_C (0x550c7dc3d5ffb4e2),\n      UINT64_C (0x72be5d74f27b896f), UINT64_C (0x80deb1fe3b1696b1),\n      UINT64_C (0x9bdc06a725c71235), UINT64_C (0xc19bf174cf692694),\n      UINT64_C (0xe49b69c19ef14ad2), UINT64_C (0xefbe4786384f25e3),\n      UINT64_C (0x0fc19dc68b8cd5b5), UINT64_C (0x240ca1cc77ac9c65),\n      UINT64_C (0x2de92c6f592b0275), UINT64_C (0x4a7484aa6ea6e483),\n      UINT64_C (0x5cb0a9dcbd41fbd4), UINT64_C (0x76f988da831153b5),\n      UINT64_C (0x983e5152ee66dfab), UINT64_C (0xa831c66d2db43210),\n      UINT64_C (0xb00327c898fb213f), UINT64_C (0xbf597fc7beef0ee4),\n      UINT64_C (0xc6e00bf33da88fc2), UINT64_C (0xd5a79147930aa725),\n      UINT64_C (0x06ca6351e003826f), UINT64_C (0x142929670a0e6e70),\n      UINT64_C (0x27b70a8546d22ffc), UINT64_C (0x2e1b21385c26c926),\n      UINT64_C (0x4d2c6dfc5ac42aed), UINT64_C (0x53380d139d95b3df),\n      UINT64_C (0x650a73548baf63de), UINT64_C (0x766a0abb3c77b2a8),\n      UINT64_C (0x81c2c92e47edaee6), UINT64_C (0x92722c851482353b),\n      UINT64_C (0xa2bfe8a14cf10364), UINT64_C (0xa81a664bbc423001),\n      UINT64_C (0xc24b8b70d0f89791), UINT64_C (0xc76c51a30654be30),\n      UINT64_C (0xd192e819d6ef5218), UINT64_C (0xd69906245565a910),\n      UINT64_C (0xf40e35855771202a), UINT64_C (0x106aa07032bbd1b8),\n      UINT64_C (0x19a4c116b8d2d0c8), UINT64_C (0x1e376c085141ab53),\n      UINT64_C (0x2748774cdf8eeb99), UINT64_C (0x34b0bcb5e19b48a8),\n      UINT64_C (0x391c0cb3c5c95a63), UINT64_C (0x4ed8aa4ae3418acb),\n      UINT64_C (0x5b9cca4f7763e373), UINT64_C (0x682e6ff3d6b2b8a3),\n      UINT64_C (0x748f82ee5defb2fc), UINT64_C (0x78a5636f43172f60),\n      UINT64_C (0x84c87814a1f0ab72), UINT64_C (0x8cc702081a6439ec),\n      UINT64_C (0x90befffa23631e28), UINT64_C (0xa4506cebde82bde9),\n      UINT64_C (0xbef9a3f7b2c67915), UINT64_C (0xc67178f2e372532b),\n      UINT64_C (0xca273eceea26619c), UINT64_C (0xd186b8c721c0c207),\n      UINT64_C (0xeada7dd6cde0eb1e), UINT64_C (0xf57d4f7fee6ed178),\n      UINT64_C (0x06f067aa72176fba), UINT64_C (0x0a637dc5a2c898a6),\n      UINT64_C (0x113f9804bef90dae), UINT64_C (0x1b710b35131c471b),\n      UINT64_C (0x28db77f523047d84), UINT64_C (0x32caab7b40c72493),\n      UINT64_C (0x3c9ebe0a15c9bebc), UINT64_C (0x431d67c49c100d4c),\n      UINT64_C (0x4cc5d4becb3e42b6), UINT64_C (0x597f299cfc657e2a),\n      UINT64_C (0x5fcb6fab3ad6faec), UINT64_C (0x6c44198c4a475817)};\n\n    /* One step of SHA-512/256 computation with working variables rotation,\n       see FIPS PUB 180-4 clause 6.4.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP64RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n  uint64_t tmp_h_ = (vH);                                             \\\n  SHA2STEP64((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));    \\\n  (vH) = (vG);                                                        \\\n  (vG) = (vF);                                                        \\\n  (vF) = (vE);                                                        \\\n  (vE) = (vD);                                                        \\\n  (vD) = (vC);                                                        \\\n  (vC) = (vB);                                                        \\\n  (vB) = (vA);                                                        \\\n  (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n    /* During last 64 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 80; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Compute and store the intermediate hash.\n     See FIPS PUB 180-4 clause 6.4.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\n_MHD_static_inline void\ndigest_update_str (struct DigestAlgorithm *da,\n                   const char *str)\n{\n  const size_t str_len = strlen (str);\n  digest_update (da, (const uint8_t *) str, str_len);\n}\n...\n_MHD_static_inline void\ndigest_update_with_colon (struct DigestAlgorithm *da)\n{\n  static const uint8_t colon = (uint8_t) ':';\n  digest_update (da, &colon, 1);\n}\n...\n_MHD_static_inline void\ncalc_userhash (struct DigestAlgorithm *da,\n               const char *username, const size_t username_len,\n               const char *realm, const size_t realm_len,\n               uint8_t *digest_bin)\n{\n  mhd_assert (NULL != username);\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_calc_hash (da, digest_bin);\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n...\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n...\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the entire provided code and supporting functions for any use of the Standard Library function memcmp or any code that compares null-terminated strings via memcmp. No calls to memcmp appear in the supplied snippets. The code contains uses of memcpy and strlen, and many hash/update/transform routines, but none of these use memcmp to compare strings. Therefore there are no fragments in the provided code that violate MISRA C 2023 Rule 21.14 (memcmp used to compare null-terminated strings). If memcmp is used elsewhere in the project (not included here), those occurrences should be reviewed; but within the supplied code there are no memcmp invocations or suspicious string-comparison patterns to report."
}