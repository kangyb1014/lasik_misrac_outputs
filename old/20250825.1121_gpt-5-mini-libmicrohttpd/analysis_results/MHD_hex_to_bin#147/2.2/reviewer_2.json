{
  "user_message": "An agent A claimed that the following MHD_hex_to_bin code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_hex_to_bin.\n```c\nsize_t\nMHD_hex_to_bin (const char *hex,\n                size_t len,\n                void *bin)\n{\n  uint8_t *const out = (uint8_t *) bin;\n  size_t r;\n  size_t w;\n\n  if (0 == len)\n    return 0;\n  r = 0;\n  w = 0;\n  if (0 != len % 2)\n  {\n    /* Assume the first byte is encoded with single digit */\n    const int l = toxdigitvalue (hex[r++]);\n    if (0 > l)\n      return 0;\n    out[w++] = (uint8_t) ((unsigned int) l);\n  }\n  while (r < len)\n  {\n    const int h = toxdigitvalue (hex[r++]);\n    const int l = toxdigitvalue (hex[r++]);\n    if ((0 > h) || (0 > l))\n      return 0;\n    out[w++] = (uint8_t) ( ((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)) );\n  }\n  mhd_assert (len == r);\n  mhd_assert ((len + 1) / 2 == w);\n  return w;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro #define mhd_assert(ignore) ((void)0) causes every mhd_assert(...) call in the project to become a no-op statement ((void)0); these statements are executed but have no effect \u2014 removing them would not change program behaviour. For example, lines like mhd_assert(len == r); expand to ((void)0); and are dead code.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_hex_to_bin:\n_MHD_static_inline int\ntoxdigitvalue (char c)\n{\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n  switch ((unsigned char) c)\n  {\n#if 0 /* Disabled to give the compiler a hint about low probability */\n  case 0x00U:    /* NUL */\n  case 0x01U:    /* SOH */\n  case 0x02U:    /* STX */\n  case 0x03U:    /* ETX */\n  case 0x04U:    /* EOT */\n  case 0x05U:    /* ENQ */\n  case 0x06U:    /* ACK */\n  case 0x07U:    /* BEL */\n  case 0x08U:    /* BS */\n  case 0x09U:    /* HT */\n  case 0x0AU:    /* LF */\n  case 0x0BU:    /* VT */\n  case 0x0CU:    /* FF */\n  case 0x0DU:    /* CR */\n  case 0x0EU:    /* SO */\n  case 0x0FU:    /* SI */\n  case 0x10U:    /* DLE */\n  case 0x11U:    /* DC1 */\n  case 0x12U:    /* DC2 */\n  case 0x13U:    /* DC3 */\n  case 0x14U:    /* DC4 */\n  case 0x15U:    /* NAK */\n  case 0x16U:    /* SYN */\n  case 0x17U:    /* ETB */\n  case 0x18U:    /* CAN */\n  case 0x19U:    /* EM */\n  case 0x1AU:    /* SUB */\n  case 0x1BU:    /* ESC */\n  case 0x1CU:    /* FS */\n  case 0x1DU:    /* GS */\n  case 0x1EU:    /* RS */\n  case 0x1FU:    /* US */\n  case 0x20U:    /* ' ' */\n  case 0x21U:    /* '!' */\n  case 0x22U:    /* '\"' */\n  case 0x23U:    /* '#' */\n  case 0x24U:    /* '$' */\n  case 0x25U:    /* '%' */\n  case 0x26U:    /* '&' */\n  case 0x27U:    /* '\\'' */\n  case 0x28U:    /* '(' */\n  case 0x29U:    /* ')' */\n  case 0x2AU:    /* '*' */\n  case 0x2BU:    /* '+' */\n  case 0x2CU:    /* ',' */\n  case 0x2DU:    /* '-' */\n  case 0x2EU:    /* '.' */\n  case 0x2FU:    /* '/' */\n    return -1;\n#endif\n  case 0x30U: /* '0' */\n    return 0;\n  case 0x31U: /* '1' */\n    return 1;\n  case 0x32U: /* '2' */\n    return 2;\n  case 0x33U: /* '3' */\n    return 3;\n  case 0x34U: /* '4' */\n    return 4;\n  case 0x35U: /* '5' */\n    return 5;\n  case 0x36U: /* '6' */\n    return 6;\n  case 0x37U: /* '7' */\n    return 7;\n  case 0x38U: /* '8' */\n    return 8;\n  case 0x39U: /* '9' */\n    return 9;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x3AU: /* ':' */\n  case 0x3BU: /* ';' */\n  case 0x3CU: /* '<' */\n  case 0x3DU: /* '=' */\n  case 0x3EU: /* '>' */\n  case 0x3FU: /* '?' */\n  case 0x40U: /* '@' */\n    return -1;\n#endif\n  case 0x41U: /* 'A' */\n    return 0xAU;\n  case 0x42U: /* 'B' */\n    return 0xBU;\n  case 0x43U: /* 'C' */\n    return 0xCU;\n  case 0x44U: /* 'D' */\n    return 0xDU;\n  case 0x45U: /* 'E' */\n    return 0xEU;\n  case 0x46U: /* 'F' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x47U: /* 'G' */\n  case 0x48U: /* 'H' */\n  case 0x49U: /* 'I' */\n  case 0x4AU: /* 'J' */\n  case 0x4BU: /* 'K' */\n  case 0x4CU: /* 'L' */\n  case 0x4DU: /* 'M' */\n  case 0x4EU: /* 'N' */\n  case 0x4FU: /* 'O' */\n  case 0x50U: /* 'P' */\n  case 0x51U: /* 'Q' */\n  case 0x52U: /* 'R' */\n  case 0x53U: /* 'S' */\n  case 0x54U: /* 'T' */\n  case 0x55U: /* 'U' */\n  case 0x56U: /* 'V' */\n  case 0x57U: /* 'W' */\n  case 0x58U: /* 'X' */\n  case 0x59U: /* 'Y' */\n  case 0x5AU: /* 'Z' */\n  case 0x5BU: /* '[' */\n  case 0x5CU: /* '\\' */\n  case 0x5DU: /* ']' */\n  case 0x5EU: /* '^' */\n  case 0x5FU: /* '_' */\n  case 0x60U: /* '`' */\n    return -1;\n#endif\n  case 0x61U: /* 'a' */\n    return 0xAU;\n  case 0x62U: /* 'b' */\n    return 0xBU;\n  case 0x63U: /* 'c' */\n    return 0xCU;\n  case 0x64U: /* 'd' */\n    return 0xDU;\n  case 0x65U: /* 'e' */\n    return 0xEU;\n  case 0x66U: /* 'f' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x67U: /* 'g' */\n  case 0x68U: /* 'h' */\n  case 0x69U: /* 'i' */\n  case 0x6AU: /* 'j' */\n  case 0x6BU: /* 'k' */\n  case 0x6CU: /* 'l' */\n  case 0x6DU: /* 'm' */\n  case 0x6EU: /* 'n' */\n  case 0x6FU: /* 'o' */\n  case 0x70U: /* 'p' */\n  case 0x71U: /* 'q' */\n  case 0x72U: /* 'r' */\n  case 0x73U: /* 's' */\n  case 0x74U: /* 't' */\n  case 0x75U: /* 'u' */\n  case 0x76U: /* 'v' */\n  case 0x77U: /* 'w' */\n  case 0x78U: /* 'x' */\n  case 0x79U: /* 'y' */\n  case 0x7AU: /* 'z' */\n  case 0x7BU: /* '{' */\n  case 0x7CU: /* '|' */\n  case 0x7DU: /* '}' */\n  case 0x7EU: /* '~' */\n  case 0x7FU: /* DEL */\n  case 0x80U: /* EXT */\n  case 0x81U: /* EXT */\n  case 0x82U: /* EXT */\n  case 0x83U: /* EXT */\n  case 0x84U: /* EXT */\n  case 0x85U: /* EXT */\n  case 0x86U: /* EXT */\n  case 0x87U: /* EXT */\n  case 0x88U: /* EXT */\n  case 0x89U: /* EXT */\n  case 0x8AU: /* EXT */\n  case 0x8BU: /* EXT */\n  case 0x8CU: /* EXT */\n  case 0x8DU: /* EXT */\n  case 0x8EU: /* EXT */\n  case 0x8FU: /* EXT */\n  case 0x90U: /* EXT */\n  case 0x91U: /* EXT */\n  case 0x92U: /* EXT */\n  case 0x93U: /* EXT */\n  case 0x94U: /* EXT */\n  case 0x95U: /* EXT */\n  case 0x96U: /* EXT */\n  case 0x97U: /* EXT */\n  case 0x98U: /* EXT */\n  case 0x99U: /* EXT */\n  case 0x9AU: /* EXT */\n  case 0x9BU: /* EXT */\n  case 0x9CU: /* EXT */\n  case 0x9DU: /* EXT */\n  case 0x9EU: /* EXT */\n  case 0x9FU: /* EXT */\n  case 0xA0U: /* EXT */\n  case 0xA1U: /* EXT */\n  case 0xA2U: /* EXT */\n  case 0xA3U: /* EXT */\n  case 0xA4U: /* EXT */\n  case 0xA5U: /* EXT */\n  case 0xA6U: /* EXT */\n  case 0xA7U: /* EXT */\n  case 0xA8U: /* EXT */\n  case 0xA9U: /* EXT */\n  case 0xAAU: /* EXT */\n  case 0xABU: /* EXT */\n  case 0xACU: /* EXT */\n  case 0xADU: /* EXT */\n  case 0xAEU: /* EXT */\n  case 0xAFU: /* EXT */\n  case 0xB0U: /* EXT */\n  case 0xB1U: /* EXT */\n  case 0xB2U: /* EXT */\n  case 0xB3U: /* EXT */\n  case 0xB4U: /* EXT */\n  case 0xB5U: /* EXT */\n  case 0xB6U: /* EXT */\n  case 0xB7U: /* EXT */\n  case 0xB8U: /* EXT */\n  case 0xB9U: /* EXT */\n  case 0xBAU: /* EXT */\n  case 0xBBU: /* EXT */\n  case 0xBCU: /* EXT */\n  case 0xBDU: /* EXT */\n  case 0xBEU: /* EXT */\n  case 0xBFU: /* EXT */\n  case 0xC0U: /* EXT */\n  case 0xC1U: /* EXT */\n  case 0xC2U: /* EXT */\n  case 0xC3U: /* EXT */\n  case 0xC4U: /* EXT */\n  case 0xC5U: /* EXT */\n  case 0xC6U: /* EXT */\n  case 0xC7U: /* EXT */\n  case 0xC8U: /* EXT */\n  case 0xC9U: /* EXT */\n  case 0xCAU: /* EXT */\n  case 0xCBU: /* EXT */\n  case 0xCCU: /* EXT */\n  case 0xCDU: /* EXT */\n  case 0xCEU: /* EXT */\n  case 0xCFU: /* EXT */\n  case 0xD0U: /* EXT */\n  case 0xD1U: /* EXT */\n  case 0xD2U: /* EXT */\n  case 0xD3U: /* EXT */\n  case 0xD4U: /* EXT */\n  case 0xD5U: /* EXT */\n  case 0xD6U: /* EXT */\n  case 0xD7U: /* EXT */\n  case 0xD8U: /* EXT */\n  case 0xD9U: /* EXT */\n  case 0xDAU: /* EXT */\n  case 0xDBU: /* EXT */\n  case 0xDCU: /* EXT */\n  case 0xDDU: /* EXT */\n  case 0xDEU: /* EXT */\n  case 0xDFU: /* EXT */\n  case 0xE0U: /* EXT */\n  case 0xE1U: /* EXT */\n  case 0xE2U: /* EXT */\n  case 0xE3U: /* EXT */\n  case 0xE4U: /* EXT */\n  case 0xE5U: /* EXT */\n  case 0xE6U: /* EXT */\n  case 0xE7U: /* EXT */\n  case 0xE8U: /* EXT */\n  case 0xE9U: /* EXT */\n  case 0xEAU: /* EXT */\n  case 0xEBU: /* EXT */\n  case 0xECU: /* EXT */\n  case 0xEDU: /* EXT */\n  case 0xEEU: /* EXT */\n  case 0xEFU: /* EXT */\n  case 0xF0U: /* EXT */\n  case 0xF1U: /* EXT */\n  case 0xF2U: /* EXT */\n  case 0xF3U: /* EXT */\n  case 0xF4U: /* EXT */\n  case 0xF5U: /* EXT */\n  case 0xF6U: /* EXT */\n  case 0xF7U: /* EXT */\n  case 0xF8U: /* EXT */\n  case 0xF9U: /* EXT */\n  case 0xFAU: /* EXT */\n  case 0xFBU: /* EXT */\n  case 0xFCU: /* EXT */\n  case 0xFDU: /* EXT */\n  case 0xFEU: /* EXT */\n  case 0xFFU: /* EXT */\n    return -1;\n  default:\n    mhd_assert (0);\n    break;  /* Should be unreachable */\n#else\n  default:\n    break;\n#endif\n  }\n  return -1;\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (isasciidigit (c))\n    return (unsigned char) (c - '0');\n  if ( (c >= 'A') && (c <= 'F') )\n    return (unsigned char) (c - 'A' + 10);\n  if ( (c >= 'a') && (c <= 'f') )\n    return (unsigned char) (c - 'a' + 10);\n\n  return -1;\n#endif /* MHD_FAVOR_SMALL_CODE */\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n...\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return MHD_DAUTH_WRONG_HEADER;\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3)))\n    return MHD_DAUTH_WRONG_ALGO;\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop)))\n    return MHD_DAUTH_WRONG_QOP;\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  else if (params->userhash && (NULL == params->username.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  else if (params->userhash && (digest_size * 2 > params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  else if (params->userhash && (digest_size * 4 < params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n\n  if (NULL == params->realm.value.str)\n    return MHD_DAUTH_WRONG_REALM;\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len))\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->nc.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n      return MHD_DAUTH_WRONG_HEADER;\n\n    if (NULL == params->cnonce.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->cnonce.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len)\n      return MHD_DAUTH_TOO_LARGE;\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str)\n    return MHD_DAUTH_WRONG_URI;\n  else if (0 == params->uri.value.len)\n    return MHD_DAUTH_WRONG_URI;\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len)\n    return MHD_DAUTH_TOO_LARGE;\n\n  if (NULL == params->nonce.value.str)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (0 == params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n\n  if (NULL == params->response.value.str)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (0 == params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (digest_size * 4 < params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  if (! is_param_equal (&params->realm, realm, realm_len))\n    return MHD_DAUTH_WRONG_REALM;\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      if (! is_param_equal (&params->username, username, username_len))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname)\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      if (0 > res)\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size))\n      return MHD_DAUTH_WRONG_USERNAME;\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci))\n      return MHD_DAUTH_NONCE_STALE;    /* Too large 'nc' value */\n  }\n  else\n    nci = 1; /* Force 'nc' value */\n  /* Got 'nc' digital value */\n\n  /* Get 'nonce' with basic checks */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  if ((NONCE_STD_LEN (digest_size) != unquoted.len) ||\n      (! get_nonce_timestamp (unquoted.str, unquoted.len, &nonce_time)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, invalid nonce format.\\n\"));\n#endif\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (1)\n  {\n    uint64_t t;\n\n    t = MHD_monotonic_msec_counter ();\n    /*\n     * First level vetting for the nonce validity: if the timestamp\n     * attached to the nonce exceeds `nonce_timeout', then the nonce is\n     * stale.\n     */\n    if (TRIM_TO_TIMESTAMP (t - nonce_time) > (nonce_timeout * 1000))\n      return MHD_DAUTH_NONCE_STALE; /* too old */\n  }\n  if (1)\n  {\n    enum MHD_CheckNonceNC_ nonce_nc_check;\n    /*\n     * Checking if that combination of nonce and nc is sound\n     * and not a replay attack attempt. Refuse if nonce was not\n     * generated previously.\n     */\n    nonce_nc_check = check_nonce_nc (connection,\n                                     unquoted.str,\n                                     NONCE_STD_LEN (digest_size),\n                                     nonce_time,\n                                     nci);\n    if (MHD_CHECK_NONCENC_STALE == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. If this happens a lot, you should \"\n                     \"probably increase the size of the nonce array.\\n\"));\n      else\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. This is expected when client \" \\\n                     \"uses RFC2069-compatible mode and makes more than one \" \\\n                     \"request.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_STALE;\n    }\n    else if (MHD_CHECK_NONCENC_WRONG == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Received nonce that was not \"\n                   \"generated by MHD. This may indicate an attack attempt.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_WRONG;\n    }\n    mhd_assert (MHD_CHECK_NONCENC_OK == nonce_nc_check);\n  }\n  /* The nonce was generated by MHD, is not stale and nonce-nc combination was\n     not used before */\n\n  /* ** Build H(A2) and check URI match in the header and in the request ** */\n\n  /* Get 'uri' */\n  mhd_assert (! da->hashing);\n  digest_update_str (da, connection->rq.method);\n  digest_update_with_colon (da);\n#if 0\n  /* TODO: add support for \"auth-int\" */\n  digest_update_str (da, hentity);\n  digest_update_with_colon (da);\n#endif\n  unq_res = get_unquoted_param_copy (&params->uri, tmp1, ptmp2, &tmp2_size,\n                                     &unq_copy);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  digest_update (da, unq_copy.str, unq_copy.len);\n  /* The next check will modify copied URI string */\n  if (! check_uri_match (connection, unq_copy.str, unq_copy.len))\n    return MHD_DAUTH_WRONG_URI;\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  /* Skip digest calculation external error check, the next one checks both */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A2) */\n\n  /* ** Build H(A1) ** */\n  if (NULL == userdigest)\n  {\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calc_userdigest (da,\n                     username, username_len,\n                     realm, realm_len,\n                     password,\n                     hash1_bin);\n  }\n  /* TODO: support '-sess' versions */\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A1) */\n\n  /* **  Check 'response' ** */\n\n  mhd_assert (! da->hashing);\n  digest_reset (da);\n  /* Update digest with H(A1) */\n  mhd_assert (sizeof (tmp1) >= (digest_size * 2));\n  if (NULL == userdigest)\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n  else\n    MHD_bin_to_hex (userdigest, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A1) is not needed anymore, reuse the buffer.\n   * Use hash1_bin for the client's 'response' decoded to binary form. */\n  unq_res = get_unquoted_param (&params->response, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  if (digest_size != MHD_hex_to_bin (unquoted.str, unquoted.len, hash1_bin))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  /* Update digest with 'nonce' text value */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    /* Update digest with 'nc' text value */\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'cnonce' value */\n    unq_res = get_unquoted_param (&params->cnonce, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'qop' value */\n    unq_res = get_unquoted_param (&params->qop_raw, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n  }\n  /* Update digest with H(A2) */\n  MHD_bin_to_hex (hash2_bin, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A2) is not needed anymore, reuse the buffer.\n   * Use hash2_bin for the calculated response in binary form */\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 != memcmp (hash1_bin, hash2_bin, digest_size))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  if (MHD_DAUTH_BIND_NONCE_NONE != daemon->dauth_bind_type)\n  {\n    mhd_assert (sizeof(tmp1) >= (NONCE_STD_LEN (digest_size) + 1));\n    /* It was already checked that 'nonce' (including timestamp) was generated\n       by MHD. */\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calculate_nonce (nonce_time,\n                     connection->rq.http_mthd,\n                     connection->rq.method,\n                     daemon->digest_auth_random,\n                     daemon->digest_auth_rand_size,\n                     connection->addr,\n                     (size_t) connection->addr_len,\n                     connection->rq.url,\n                     connection->rq.url_len,\n                     connection->rq.headers_received,\n                     realm,\n                     realm_len,\n                     daemon->dauth_bind_type,\n                     da,\n                     tmp1);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (! is_param_equal (&params->nonce, tmp1,\n                          NONCE_STD_LEN (digest_size)))\n      return MHD_DAUTH_NONCE_OTHER_COND;\n    /* The 'nonce' was generated in the same conditions */\n  }\n\n  return MHD_DAUTH_OK;\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n...\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n...\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all (struct MHD_Connection *connection,\n                       const char *realm,\n                       const char *username,\n                       const char *password,\n                       const uint8_t *userdigest,\n                       unsigned int nonce_timeout,\n                       uint32_t max_nc,\n                       enum MHD_DigestAuthMultiQOP mqop,\n                       enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  enum MHD_DigestAuthResult res;\n  char *buf;\n  struct DigestAlgorithm da;\n\n  buf = NULL;\n  digest_setup_zero (&da);\n  if (0 == nonce_timeout)\n    nonce_timeout = connection->daemon->dauth_def_nonce_timeout;\n  if (0 == max_nc)\n    max_nc = connection->daemon->dauth_def_max_nc;\n  res = digest_auth_check_all_inner (connection, realm, username, password,\n                                     userdigest,\n                                     nonce_timeout,\n                                     max_nc, mqop, malgo3,\n                                     &buf, &da);\n  digest_deinit (&da);\n  if (NULL != buf)\n    free (buf);\n\n  return res;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. With #define mhd_assert(ignore) ((void)0) every source-site of mhd_assert(...) becomes an expression statement that performs no action. Those statements (for example mhd_assert(len == r); -> ((void)0);) are executable no-ops whose removal would not change program behaviour, which matches the rule\u2019s definition of dead code. They are reachable and executed (or expand to an empty operation) and have no side effects, so they constitute dead code under MISRA C 2023 Rule 2.2."
}