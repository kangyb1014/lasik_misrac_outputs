{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_connection_handle_read (struct MHD_Connection *connection,\n                            bool socket_error)\n{\n  ssize_t bytes_read;\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n    return;\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  mhd_assert (NULL != connection->read_buffer);\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n    return; /* No space for receiving data. */\n\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size\n                                     - connection->read_buffer_offset);\n  if ((bytes_read < 0) || socket_error)\n  {\n    if ((MHD_ERR_AGAIN_ == bytes_read) && ! socket_error)\n      return;     /* No new data to process. */\n    if ((bytes_read > 0) && connection->sk_nonblck)\n    { /* Try to detect the socket error */\n      int dummy;\n      bytes_read = connection->recv_cls (connection, &dummy, sizeof (dummy));\n    }\n    if (MHD_ERR_CONNRESET_ == bytes_read)\n    {\n      if ( (MHD_CONNECTION_INIT < connection->state) &&\n           (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Socket has been disconnected when reading request.\\n\"));\n#endif\n        connection->discard_request = true;\n      }\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      return;\n    }\n\n#ifdef HAVE_MESSAGES\n    if (MHD_CONNECTION_INIT != connection->state)\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection socket is closed when reading \" \\\n                   \"request due to the error: %s\\n\"),\n                (bytes_read < 0) ? str_conn_error_ (bytes_read) :\n                \"detected connection closure\");\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            NULL);\n    return;\n  }\n\n  if (0 == bytes_read)\n  {   /* Remote side closed connection. */\n    connection->read_closed = true;\n    if ( (MHD_CONNECTION_INIT < connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection was closed by remote side with incomplete \"\n                   \"request.\\n\"));\n#endif\n      connection->discard_request = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n    }\n    else if (MHD_CONNECTION_INIT == connection->state)\n      /* This termination code cannot be reported to the application\n       * because application has not been informed yet about this request */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return;\n  }\n  connection->read_buffer_offset += (size_t) bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  /* TODO: check whether the next 'switch()' really needed */\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    /* nothing to do but default action */\n    if (connection->read_closed)\n    {\n      /* TODO: check whether this really needed */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n    }\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  case MHD_CONNECTION_START_REPLY:\n    /* shrink read buffer to how much is actually used */\n    /* TODO: remove shrink as it handled in special function */\n    if ((0 != connection->read_buffer_size) &&\n        (connection->read_buffer_size != connection->read_buffer_offset))\n    {\n      mhd_assert (NULL != connection->read_buffer);\n      connection->read_buffer =\n        MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             connection->read_buffer_offset);\n      connection->read_buffer_size = connection->read_buffer_offset;\n    }\n    break;\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n    /* Milestone state, no data should be read */\n    mhd_assert (0); /* Should not be possible */\n    break;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n  case MHD_CONNECTION_HEADERS_SENDING:\n  case MHD_CONNECTION_HEADERS_SENT:\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n  case MHD_CONNECTION_FOOTERS_SENDING:\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n  default:\n    mhd_assert (0); /* Should not be possible */\n    break;\n  }\n  return;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'str_conn_error_': {'callees': [], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write']}, 'connection_close_error': {'callees': ['MHD_DLOG', 'MHD_connection_close_'], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'transmit_error_response_len', 'handle_recv_no_space', 'call_connection_handler', 'process_request_body', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (fields: state, suspended, tls_state, read_buffer, read_buffer_size, read_buffer_offset, recv_cls, sk_nonblck, read_closed, discard_request, daemon, pool)",
    "MHD_CONNECTION_CLOSED",
    "MHD_CONNECTION_INIT",
    "MHD_CONNECTION_FULL_REQ_RECEIVED",
    "MHD_CONNECTION_START_REPLY",
    "MHD_CONNECTION_REQ_LINE_RECEIVING",
    "MHD_CONNECTION_REQ_HEADERS_RECEIVING",
    "MHD_CONNECTION_BODY_RECEIVING",
    "MHD_CONNECTION_FOOTERS_RECEIVING",
    "MHD_CONNECTION_REQ_LINE_RECEIVED",
    "MHD_CONNECTION_HEADERS_RECEIVED",
    "MHD_CONNECTION_HEADERS_PROCESSED",
    "MHD_CONNECTION_BODY_RECEIVED",
    "MHD_CONNECTION_FOOTERS_RECEIVED",
    "MHD_CONNECTION_CONTINUE_SENDING",
    "MHD_CONNECTION_HEADERS_SENDING",
    "MHD_CONNECTION_HEADERS_SENT",
    "MHD_CONNECTION_NORMAL_BODY_UNREADY",
    "MHD_CONNECTION_NORMAL_BODY_READY",
    "MHD_CONNECTION_CHUNKED_BODY_UNREADY",
    "MHD_CONNECTION_CHUNKED_BODY_READY",
    "MHD_CONNECTION_CHUNKED_BODY_SENT",
    "MHD_CONNECTION_FOOTERS_SENDING",
    "MHD_CONNECTION_FULL_REPLY_SENT",
    "HTTPS_SUPPORT (compile-time flag)",
    "MHD_TLS_CONN_NO_TLS",
    "MHD_TLS_CONN_CONNECTED",
    "MHD_run_tls_handshake_",
    "HAVE_MESSAGES (compile-time flag)",
    "MHD_DLOG",
    "str_conn_error_",
    "CONNECTION_CLOSE_ERROR (macro or function)",
    "MHD_connection_close_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_CONNRESET_",
    "sk_nonblck (field meaning / semantics)",
    "recv_cls (connection->recv_cls: function pointer signature and side-effects)",
    "MHD_REQUEST_TERMINATED_READ_ERROR",
    "MHD_REQUEST_TERMINATED_CLIENT_ABORT",
    "MHD_REQUEST_TERMINATED_COMPLETED_OK",
    "MHD_REQUEST_TERMINATED_WITH_ERROR",
    "MHD_update_last_activity_",
    "DEBUG_STATES (compile-time flag)",
    "MHD_FUNC_",
    "MHD_state_to_string",
    "mhd_assert",
    "UPGRADE_SUPPORT (compile-time flag)",
    "MHD_pool_reallocate (behaviour: reallocate/shrink semantics)"
  ],
  "explanation": "To decide whether any statements in MHD_connection_handle_read are dead code we must know which branches and statements can actually affect runtime behaviour. The listed symbols provide the needed information:\n\n- struct MHD_Connection and its listed fields: the function's control flow and side effects are driven entirely by connection->state, suspended, tls_state, read_buffer*, read_buffer_size/offset, recv_cls, sk_nonblck, read_closed, discard_request, daemon and pool. Their types, runtime ranges and semantics determine whether branches are ever taken and whether assignments have observable effects.\n\n- All MHD_CONNECTION_* state constants used in the initial checks and the switch: to determine which switch-case labels are reachable at runtime and whether entire case blocks are unreachable / redundant.\n\n- HTTPS_SUPPORT, MHD_TLS_CONN_NO_TLS, MHD_TLS_CONN_CONNECTED and MHD_run_tls_handshake_: the TLS-handshake code is conditional on the compile-time flag and runtime tls_state; you must know whether HTTPS_SUPPORT is defined and what run_tls_handshake_ does (side effects, success/failure) to decide if that block is live or removable.\n\n- HAVE_MESSAGES, MHD_DLOG, str_conn_error_, MHD_FUNC_, MHD_state_to_string and DEBUG_STATES: logging is often conditionally compiled; whether those calls exist (and have side effects relevant to behaviour or timing) affects whether eliminating them would change program behaviour.\n\n- CONNECTION_CLOSE_ERROR and MHD_connection_close_: these perform connection tear-down and are observable; their semantics are required to judge if preceding code that leads to them is necessary or dead.\n\n- MHD_ERR_AGAIN_, MHD_ERR_CONNRESET_, recv_cls (the receive callback) and sk_nonblck: the rules for error reporting from recv_cls and subsequent handling (retry, secondary recv, CONNECTION_CLOSE_ERROR) determine whether error-path code is reachable and whether any error-handling statements are redundant.\n\n- MHD_REQUEST_TERMINATED_* codes: the values passed to MHD_connection_close_ represent externally observable termination reasons; removal could change observable behavior.\n\n- MHD_update_last_activity_: updates timing state; per MISRA note (1) timing/when an operation occurs can be observable, so whether this call can be removed depends on its semantics.\n\n- mhd_assert: may be a no-op in release builds or abort in debug builds; knowing its definition matters for reachability / observable behaviour.\n\n- UPGRADE_SUPPORT: controls presence of the upgrade-case code; needed to decide if that case is dead under current build.\n\n- MHD_pool_reallocate: its semantics (returns same pointer, allocates new memory, side effects on pool) are required to decide if the shrink/reallocate sequence is necessary/observable.\n\nIn short, to assess dead code you must know compile-time flags that include/exclude blocks, the possible runtime values and reachability of connection->state and related fields, the semantics and side effects of the I/O callback (recv_cls), error codes, and the functions/macros that produce externally observable behavior (logging, connection close, activity updates, memory reallocation). Without these symbols and their definitions you cannot determine whether any branch or statement could be removed without changing program behaviour."
}