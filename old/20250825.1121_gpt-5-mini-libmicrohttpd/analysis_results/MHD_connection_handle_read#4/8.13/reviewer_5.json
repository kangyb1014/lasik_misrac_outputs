{
  "user_message": "An agent A claimed that the following MHD_connection_handle_read code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_handle_read.\n```c\nvoid\nMHD_connection_handle_read (struct MHD_Connection *connection,\n                            bool socket_error)\n{\n  ssize_t bytes_read;\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n    return;\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n  mhd_assert (NULL != connection->read_buffer);\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n    return; /* No space for receiving data. */\n\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size\n                                     - connection->read_buffer_offset);\n  if ((bytes_read < 0) || socket_error)\n  {\n    if ((MHD_ERR_AGAIN_ == bytes_read) && ! socket_error)\n      return;     /* No new data to process. */\n    if ((bytes_read > 0) && connection->sk_nonblck)\n    { /* Try to detect the socket error */\n      int dummy;\n      bytes_read = connection->recv_cls (connection, &dummy, sizeof (dummy));\n    }\n    if (MHD_ERR_CONNRESET_ == bytes_read)\n    {\n      if ( (MHD_CONNECTION_INIT < connection->state) &&\n           (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Socket has been disconnected when reading request.\\n\"));\n#endif\n        connection->discard_request = true;\n      }\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n      return;\n    }\n\n#ifdef HAVE_MESSAGES\n    if (MHD_CONNECTION_INIT != connection->state)\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection socket is closed when reading \" \\\n                   \"request due to the error: %s\\n\"),\n                (bytes_read < 0) ? str_conn_error_ (bytes_read) :\n                \"detected connection closure\");\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            NULL);\n    return;\n  }\n\n  if (0 == bytes_read)\n  {   /* Remote side closed connection. */\n    connection->read_closed = true;\n    if ( (MHD_CONNECTION_INIT < connection->state) &&\n         (MHD_CONNECTION_FULL_REQ_RECEIVED > connection->state) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Connection was closed by remote side with incomplete \"\n                   \"request.\\n\"));\n#endif\n      connection->discard_request = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n    }\n    else if (MHD_CONNECTION_INIT == connection->state)\n      /* This termination code cannot be reported to the application\n       * because application has not been informed yet about this request */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return;\n  }\n  connection->read_buffer_offset += (size_t) bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  /* TODO: check whether the next 'switch()' really needed */\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    /* nothing to do but default action */\n    if (connection->read_closed)\n    {\n      /* TODO: check whether this really needed */\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_READ_ERROR);\n    }\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  case MHD_CONNECTION_START_REPLY:\n    /* shrink read buffer to how much is actually used */\n    /* TODO: remove shrink as it handled in special function */\n    if ((0 != connection->read_buffer_size) &&\n        (connection->read_buffer_size != connection->read_buffer_offset))\n    {\n      mhd_assert (NULL != connection->read_buffer);\n      connection->read_buffer =\n        MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             connection->read_buffer_offset);\n      connection->read_buffer_size = connection->read_buffer_offset;\n    }\n    break;\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n    /* Milestone state, no data should be read */\n    mhd_assert (0); /* Should not be possible */\n    break;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n  case MHD_CONNECTION_HEADERS_SENDING:\n  case MHD_CONNECTION_HEADERS_SENT:\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n  case MHD_CONNECTION_FOOTERS_SENDING:\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n  default:\n    mhd_assert (0); /* Should not be possible */\n    break;\n  }\n  return;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe fragment itself passes string pointers to logging functions. This violates Rule 8.13 if any of those functions/macros return or expose non-const pointers where a const-qualified result is possible. Concrete violation scenario: if MHD_state_to_string has the signature 'char *MHD_state_to_string(int)' (i.e. returns a non-const char *), it should instead return 'const char *' because the returned textual state is not intended to be modified. Another possible violation is the translation macro/function '_' (gettext) which commonly has the signature 'char *gettext(const char *)' \u2014 using that non-const return for a string literal/format string is also contrary to Rule 8.13. If both MHD_state_to_string and the logging format string are declared to return/accept const-qualified pointers (e.g. 'const char *'), then there is no violation in this fragment.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 asks that pointers should point to const-qualified types whenever possible. The code fragment itself does not declare any non-const pointer types that obviously should be const: it only calls functions and macros (MHD_state_to_string, _/gettext, MHD_DLOG) and passes string literals/returned pointers to them. Whether there is a Rule 8.13 violation depends on the declarations of those external functions/macros \u2014 not on this call site.\n\n- If MHD_state_to_string is declared/defined as returning char * (and the returned string is immutable), then that function's declaration/definition would be the locus of a Rule 8.13 violation (it should return const char *). The same applies to _ (gettext) if it were declared to return char * but actually returns immutable data.\n\n- However, this source file as shown does not itself violate 8.13. A caller cannot be blamed for an external API that uses non-const returns; the violation (if any) resides in those function/macro declarations/definitions. Note also that some platform APIs (e.g. POSIX gettext) historically have a char * return type, so changing that may be impossible or incompatible; in such cases a justified deviation or wrapper that returns const char * should be used.\n\nConclusion: the agent A's report is not correct as stated. It only becomes correct if one can show that MHD_state_to_string or _/gettext are declared with non-const pointer returns where const would be possible; otherwise there is no violation in this fragment itself."
}