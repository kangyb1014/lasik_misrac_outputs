{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition: fields count, buffer, H, types/sizes)",
    "sha256_transform",
    "_MHD_PUT_64BIT_BE_SAFE (macro or function)",
    "_MHD_PUT_32BIT_BE (macro or function)",
    "_MHD_PUT_32BIT_BE_UNALIGNED (macro)",
    "_MHD_UINT32_ALIGN (macro/constant)",
    "MHD_FAVOR_SMALL_CODE (macro)",
    "memcpy",
    "memset",
    "__builtin_bswap32",
    "__builtin_rotateright32",
    "SHA256_DIGEST_SIZE",
    "SHA256_BLOCK_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "digest_calc_hash (caller)"
  ],
  "explanation": "For each symbol:\n\n- struct Sha256Ctx (full definition: fields count, buffer, H, types/sizes)\n  - Needed to verify the types/semantics of ctx->buffer and ctx->count (binary buffer and byte count). Determines whether any buffer is a C string (null-terminated) or plain binary data; the MISRA memcmp rule only applies to comparisons of null-terminated strings.\n\n- sha256_transform\n  - The function called to process blocks. Must be inspected to ensure it does not internally call memcmp (especially comparing C strings). If it calls memcmp on data coming from ctx->buffer or elsewhere, that could implicate this call path.\n\n- _MHD_PUT_64BIT_BE_SAFE (macro or function)\n  - This macro/function is used to write the bit-length into the buffer; it could expand to or call other routines (hypothetically memcmp) or treat data as strings. Inspecting it rules out hidden memcmp usage.\n\n- _MHD_PUT_32BIT_BE (macro or function)\n  - Used to write 32-bit words into the digest (or temporary). Must be checked for any hidden use of memcmp or string semantics in its implementation.\n\n- _MHD_PUT_32BIT_BE_UNALIGNED (macro)\n  - Controls whether unaligned-safe or alternate code paths are used. Different code paths might call different helpers; we must check all controlled expansions for memcmp use.\n\n- _MHD_UINT32_ALIGN (macro/constant)\n  - Used in alignment test that selects alternative code paths. Those alternative paths must be checked to ensure none use memcmp on string data.\n\n- MHD_FAVOR_SMALL_CODE (macro)\n  - Controls compilation branches in this function. Both branches (small-code vs full) must be examined because one branch could use an implementation that invokes memcmp.\n\n- memcpy\n  - Used here to copy the temporary aligned digest to the caller buffer. Verify that memcpy is only used for binary copy (it is), and ensure no confusion with memcmp; also to check that no accidental use of memcmp is hidden behind macro names.\n\n- memset\n  - Used for zero-padding and clearing ctx. Included to check semantics and ensure no mistaken replacement with memcmp-like calls.\n\n- __builtin_bswap32\n  - Appears in the call graph (called by sha256_transform and by this function via callees). Inspect to confirm no memcmp usage in compiler intrinsics or wrappers.\n\n- __builtin_rotateright32\n  - Called by sha256_transform (in call graph). Include to ensure no hidden memcmp or string comparison in lower-level helpers.\n\n- SHA256_DIGEST_SIZE, SHA256_BLOCK_SIZE, SHA256_SIZE_OF_LEN_ADD, SHA256_BLOCK_SIZE_WORDS, SHA256_DIGEST_SIZE_WORDS, SHA256_BYTES_IN_WORD\n  - Constants/macros define buffer sizes and offsets. Needed to confirm all buffer operations are within binary-sized boundaries (not string operations) and that padding/length encoding is purely binary.\n\n- digest_calc_hash (caller)\n  - The caller that invokes MHD_SHA256_finish. Inspecting how the returned digest is used by callers (e.g., whether callers later compare digest to strings with memcmp) is useful to rule out any indirect MISRA violation claims tied to this function\u2019s outputs. While the MISRA rule targets usage of memcmp to compare null-terminated strings, understanding the caller context helps ensure the digest produced here is not subsequently misused as a C string.\n\nIn short: include the struct and all macros/functions used or selected by compile-time branches and the direct callees. These symbols are sufficient to determine whether this function (or any called helper in its selected branches) uses memcmp to compare null-terminated strings or otherwise treats buffers as C strings."
}