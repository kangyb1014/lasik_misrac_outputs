{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "sha256_transform (prototype/definition)",
    "_MHD_PUT_64BIT_BE_SAFE (macro/function)",
    "_MHD_PUT_32BIT_BE (macro/function)",
    "_MHD_PUT_32BIT_BE_UNALIGNED (macro/define)",
    "_MHD_UINT32_ALIGN (macro/define)",
    "SHA256_BLOCK_SIZE (macro/define)",
    "SHA256_SIZE_OF_LEN_ADD (macro/define)",
    "SHA256_BLOCK_SIZE_WORDS (macro/define)",
    "SHA256_DIGEST_SIZE (macro/define)",
    "SHA256_DIGEST_SIZE_WORDS (macro/define)",
    "SHA256_BYTES_IN_WORD (macro/define)",
    "memcpy (prototype)",
    "memset (prototype)",
    "stdint typedefs: uint8_t, uint32_t, uint64_t, uintptr_t",
    "MHD_FAVOR_SMALL_CODE (macro/define)"
  ],
  "explanation": "For a MISRA check about pointer-to-const qualification we must know the exact types and parameter constness where pointers are passed or cast. Explaination by symbol:\n\n- struct Sha256Ctx: Needed to know types of ctx->buffer, ctx->H, ctx->count and whether these are arrays/pointers and if they are declared mutable or could/should be const.\n\n- sha256_transform (prototype/definition): The function is called with ctx->buffer and ctx->H; its parameter types (e.g. const void *block vs void *block) determine whether a non-const pointer is required or if a const qualification would be possible.\n\n- _MHD_PUT_64BIT_BE_SAFE (macro/function): Called with ctx->buffer + offset; must know whether its destination parameter is declared const or non-const and whether its signature forces non-const pointers.\n\n- _MHD_PUT_32BIT_BE (macro/function): Used to write into digest (and temporary alig_dgst); its parameter types determine if passing (void*)(digest + ...) or alig_dgst addresses violates/omits const qualification.\n\n- _MHD_PUT_32BIT_BE_UNALIGNED (macro/define): Controls conditional compilation and which implementation of _MHD_PUT_32BIT_BE is used; influences which pointer-types/signatures are present.\n\n- _MHD_UINT32_ALIGN (macro/define): Used in an alignment test to decide whether an intermediate aligned buffer is used; affects whether pointers are cast to (void*) and whether alignment-related casts cause non-const usage.\n\n- SHA256_BLOCK_SIZE, SHA256_SIZE_OF_LEN_ADD, SHA256_BLOCK_SIZE_WORDS, SHA256_DIGEST_SIZE, SHA256_DIGEST_SIZE_WORDS, SHA256_BYTES_IN_WORD (macros): These constants determine pointer arithmetic into ctx->buffer and digest. Knowing them helps decide whether pointers are used only for reading, writing, or both (thus whether const could apply).\n\n- memcpy (prototype) and memset (prototype): These standard functions accept const-qualified source pointers (memcpy) and non-const dest; their prototypes are needed to check that the code passes arguments with appropriate constness (e.g. memcpy(digest, alig_dgst, ...) \u2014 is source allowed to be const?).\n\n- stdint typedefs: uint8_t, uint32_t, uint64_t, uintptr_t: Required to verify pointer casts and integer types used in alignment checks and arithmetic; also to determine whether pointers point to const-qualified integer types.\n\n- MHD_FAVOR_SMALL_CODE (macro/define): Controls compile-time branches that change which pointer operations are used (temporary buffer branch vs direct writes). You must evaluate both configurations to decide if any build variant violates the rule.\n\nIn summary: to assess whether pointers in MHD_SHA256_finish could/should be const-qualified (and whether any called macros/functions unnecessarily take non-const pointers), the next analyzer needs the struct layout, signatures of the called helpers/macros, relevant compile-time switches, standard prototypes, and the size/offset macros that govern pointer arithmetic."
}