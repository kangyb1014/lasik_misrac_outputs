{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "SHA256_BLOCK_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "_MHD_PUT_32BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT32_ALIGN",
    "_MHD_PUT_32BIT_BE",
    "_MHD_PUT_64BIT_BE_SAFE"
  ],
  "explanation": "Required symbols and why they matter for checking \"Controlling expressions shall not be invariant\":\n\n- struct Sha256Ctx\n  - Needed to know the type and qualifiers of ctx->count (and whether it can be treated as a compile-time constant or volatile), and to see how ctx->buffer and ctx->H are declared (affects whether any controlling expressions depend on const/volatile qualifiers or aliasing that could make them invariant).\n\n- SHA256_BLOCK_SIZE\n  - Used in the expression (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD) and in bytes_have computation (ctx->count & (SHA256_BLOCK_SIZE - 1)). Knowing its value/type (and whether it is a compile-time constant like 64 or 128) is required to determine whether those controlling expressions can be evaluated as invariant.\n\n- SHA256_SIZE_OF_LEN_ADD\n  - Appears in the same controlling expression that decides whether to process the current block. Its value (constant) is needed to decide if that if-condition can be reduced to a compile-time invariant.\n\n- SHA256_BLOCK_SIZE_WORDS\n  - Used to compute the offset passed to _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2). While not a direct controlling expression inside this function, its value matters if any of the surrounding preprocessor logic or pointer arithmetic could make related conditions constant. (Included for completeness when reasoning about buffer layout and whether any conditions depend on its value.)\n\n- SHA256_DIGEST_SIZE and SHA256_DIGEST_SIZE_WORDS and SHA256_BYTES_IN_WORD\n  - These constants appear in the code that writes the digest and control the loops/indices used when storing output. They help determine whether the repeated _MHD_PUT_32BIT_BE calls or memcpy become compile-time invariant constructs (for example if sizes are 0) and to reason about alignment-sensitive code paths.\n\n- _MHD_PUT_32BIT_BE_UNALIGNED\n  - The presence/absence of this macro controls which branches and which if-statements remain in the compiled code (the whole #ifndef block). Whether this macro is defined directly changes whether the controlling if-expression is compiled and whether any resulting if(1) remains \u2014 a key point for evaluating invariance.\n\n- MHD_FAVOR_SMALL_CODE\n  - Controls inclusion of the alignment check (the && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)) within the if(1 ... ). Its definition/absence alters the controlling expression shape and may turn a compound condition into a plain if(1) (an invariant). Thus it is required to decide if an invariant controlling expression exists after preprocessing.\n\n- _MHD_UINT32_ALIGN\n  - The alignment constant used in the modulus expression determining whether digest is suitably aligned. Its value (for example 1, 2, 4, 8) can make the modulus test trivially always true/false for all possible digest pointers or make the test meaningful at runtime; thus it affects whether that controlling expression is invariant.\n\n- _MHD_PUT_32BIT_BE\n  - A macro/function used in both alignment branches; needed to check if any use of it imposes constraints (e.g. requiring aligned or unaligned stores) that are expressed via conditionals. Knowing whether this macro is a no-op or has compile-time behavior can affect whether related conditionals are invariant.\n\n- _MHD_PUT_64BIT_BE_SAFE\n  - Called to store the 64-bit length. Its prototype/semantics are not directly part of a controlling expression, but including it is useful to fully understand whether any surrounding preprocessor or compile-time attributes (e.g. attributes marking it as inline/constant) influence the compiled control flow.\n\nNotes:\n- The important preprocessor symbols are _MHD_PUT_32BIT_BE_UNALIGNED and MHD_FAVOR_SMALL_CODE and the numeric constants (SHA256_*) plus _MHD_UINT32_ALIGN. Those determine whether any if statements reduce to compile-time constants (e.g. if(1)) or remain runtime-dependent (e.g. alignment test using digest pointer). \n- Standard types like uintptr_t, uint8_t, uint32_t, uint64_t and standard functions (memset, memcpy) are assumed available; they do not by themselves create invariant controlling expressions, so they were omitted for brevity."
}