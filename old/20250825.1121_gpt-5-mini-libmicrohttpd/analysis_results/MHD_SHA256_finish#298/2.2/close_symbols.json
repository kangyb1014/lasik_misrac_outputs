{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "SHA256_BLOCK_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "_MHD_PUT_32BIT_BE",
    "_MHD_PUT_32BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT32_ALIGN",
    "uintptr_t (typedef/definition)",
    "memset",
    "memcpy",
    "API contract / specification of MHD_SHA256_finish (aliasing rules between ctx and digest)",
    "digest_calc_hash (caller) and its use of MHD_SHA256_finish / ctx after return"
  ],
  "explanation": "For a sound MISRA dead-code analysis we must know every symbol that can affect whether executed operations are required for correct behaviour or can be removed without effect. Concise reasons: \n\n- struct Sha256Ctx: needed to know layout, sizes and types of fields (count, buffer, H, total sizeof(ctx)). The final memset(ctx,0, sizeof(...)) and writes into ctx->buffer/H can only be judged for being necessary or redundant if the structure fields and size are known (and whether digest may alias any field).\n\n- SHA256_BLOCK_SIZE, SHA256_SIZE_OF_LEN_ADD, SHA256_BLOCK_SIZE_WORDS, SHA256_DIGEST_SIZE, SHA256_DIGEST_SIZE_WORDS, SHA256_BYTES_IN_WORD: these compile-time constants control buffer indexing, padding, array sizes and temporary arrays. Whether branches execute, whether writes overflow, or whether some writes/pads are no-ops depends on their numeric values \u2014 essential to decide if some padding/memset/transform operations are redundant (dead).\n\n- _MHD_PUT_32BIT_BE: macro/function that writes 32-bit words into digest (or temporary aligned buffer). Its semantic (does it write bytes, perform byte-swaps, have side effects, require alignment) affects whether the alternative alignment path is required or could be removed.\n\n- _MHD_PUT_32BIT_BE_UNALIGNED and MHD_FAVOR_SMALL_CODE (config macros): these preprocessor symbols determine which branches of the code are compiled/active. Dead-code determination requires knowing whether those branches are present in the build.\n\n- _MHD_UINT32_ALIGN and uintptr_t: used in the runtime alignment check of the digest pointer. The numeric alignment and the typedef of uintptr_t are needed to determine which branch executes at runtime and whether the aligned-path (temporary buffer + memcpy) is ever taken \u2014 if an alignment check is constant for the build/usage the alternative branch could be dead.\n\n- memset and memcpy prototypes/semantics: whether these calls have side effects or UB in particular situations (e.g. overlapping regions: memcpy is undefined for overlap) matters for deciding whether the memcpy path and the subsequent ctx zeroing are required or could safely be removed. Also memset of ctx may be required to erase sensitive data \u2014 removal might change program behaviour/security.\n\n- API contract / specification of MHD_SHA256_finish (aliasing rules between ctx and digest): crucial to decide if the final memset(ctx,0,...) is necessary. If the API allows digest to point inside ctx (or overlap ctx memory), zeroing ctx after writing digest could corrupt the returned digest (changing behaviour); conversely, if aliasing is explicitly forbidden, zeroing ctx might be unnecessary in some callers and could be considered dead. The contract also may state whether clearing ctx is required for security (affects behavioural semantics beyond functional correctness).\n\n- digest_calc_hash (caller) and its use of MHD_SHA256_finish / ctx after return: at least one caller must be inspected to see whether the cleared ctx value (or the act of clearing) is relied upon by the rest of the program. If no caller depends on ctx contents after finish, the final memset could be dead; if callers depend on ctx being erased (or rely on digest contents possibly affected by overlap), it is required. Having the caller(s) available lets you determine whether removal changes observable behaviour.\n\n(Notes: sha256_transform and _MHD_PUT_64BIT_BE_SAFE are in the static call graph as callees of the target and therefore already known to be relevant. The above additional symbols are those outside the immediate callee list whose definitions/configuration determine whether code paths in MHD_SHA256_finish are actually live or could be removed without changing program behaviour.)"
}