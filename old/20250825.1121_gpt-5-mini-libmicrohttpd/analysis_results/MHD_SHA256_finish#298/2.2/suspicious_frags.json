{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_SHA256_finish:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_SHA256_finish:\nstruct Sha256Ctx\n{\n  uint32_t H[SHA256_DIGEST_SIZE_WORDS];     /**< Intermediate hash value / digest at end of calculation */\n  uint32_t buffer[SHA256_BLOCK_SIZE_WORDS]; /**< SHA256 input data buffer */\n  uint64_t count;                           /**< number of bytes, mod 2^64 */\n}\n...\n#define SHA256_BLOCK_SIZE (SHA256_BLOCK_SIZE_BITS/8)\n...\n#define SHA256_SIZE_OF_LEN_ADD (64/8)\n...\n#define SHA256_BLOCK_SIZE_WORDS (SHA256_BLOCK_SIZE_BITS/SHA256_WORD_SIZE_BITS)\n...\n#define SHA256_DIGEST_SIZE (SHA256_DIGEST_SIZE_WORDS*SHA256_BYTES_IN_WORD)\n...\n#define SHA256_DIGEST_SIZE_WORDS 8\n...\n#define SHA256_BYTES_IN_WORD (SHA256_WORD_SIZE_BITS/8)\n...\n#define _MHD_PUT_32BIT_BE(addr, value32) ((*(uint32_t*)(addr))=_MHD_BYTES_SWAP32(value32))\n...\n#define _MHD_UINT32_ALIGN _MHD_ALIGNOF(uint32_t)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "/* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }",
    "/* Combined with the next 'if' */",
    "#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */",
    "memset (ctx, 0, sizeof(struct Sha256Ctx));"
  ],
  "explanation": "I selected fragments that are potentially redundant/executed operations whose removal might not change runtime behaviour (and therefore warrant investigation under MISRA C Rule 2.2):\n\n- The two occurrences of \"if (1 ... )\" and the surrounding conditional/alternative blocks used for producing the final digest. These constant-true conditionals and the complicated preprocessor wrapping can lead to cases where an evaluation or branch is always taken (or where one of the alternative branches is never taken at runtime). The first block (alig_dgst + memcpy) and the second block (_MHD_PUT_32BIT_BE into digest) implement two alternative code paths for producing the digest; the preprocessor logic and the literal \"if (1)\" constructs make the control flow appear suspicious and merit checking whether some evaluations or branches are effectively dead in particular build configurations.\n\n- The standalone comment/else marker \"/* Combined with the next 'if' */\" sits between preprocessor regions and indicates non-trivial pairing of if/else across #ifs; such constructs are a common source of dead/always-taken branches when macros are changed and should be reviewed.\n\n- The final memset that zeroes the context (memset (ctx, 0, sizeof(struct Sha256Ctx));) is a visible side-effect whose removal would not change the computed digest but would change post-call memory contents (security-sensitive). From a strict Rule 2.2 perspective it should be reviewed to determine whether it is required for program behaviour or solely for hygiene/security; MISRA analysis should confirm whether this operation is semantically required in the program (it may be intentionally present to clear secrets, in which case it is not dead code).\n\nWhy other fragments were NOT selected:\n- The buffer padding and bit-length handling (the bytes_have calculation, writing 0x80, the conditional padding/memset and the sha256_transform calls) are functional parts of the SHA-256 finalization algorithm. They affect the computed digest and are not removable without changing program behaviour, so they are not candidates for dead code.\n\n- The _MHD_PUT_64BIT_BE_SAFE call that stores the message bit length, and the subsequent sha256_transform invocation that processes the final block, are required for correct algorithm output and thus not dead.\n\n- The individual assignments to ctx->H and uses of temporary aligned buffer in the first branch are meaningful (they contribute to the final digest) and are not dead when that branch is actually taken; the investigation items above focus on whether some of those branches/evaluations are never taken in certain builds.\n\n- Simple arithmetic and casts (e.g. bytes_have calculation, pointer casts, and index multiplications) are either needed for addressing or resolved at compile time; they do not qualify as executed dead operations in general.\n\nIn short: I flagged the alignment/branching blocks (including the constant \"if (1)\" uses and the cross-#if else), and the final zeroization, because those are the locations most likely to contain executed operations that could be redundant or never affect program behaviour in some build configurations. All other parts implement algorithmic steps (padding, length encoding, block transforms) that clearly affect output and therefore are not dead code."
}