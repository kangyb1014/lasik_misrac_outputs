{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "SHA256_DIGEST_SIZE",
    "SHA256_BLOCK_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "_MHD_PUT_64BIT_BE_SAFE",
    "_MHD_PUT_32BIT_BE",
    "_MHD_PUT_32BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT32_ALIGN",
    "sha256_transform",
    "memcpy",
    "memset",
    "__builtin_bswap32",
    "stdint typedefs (uint8_t,uint32_t,uint64_t)",
    "uintptr_t"
  ],
  "explanation": "Explain why each symbol is needed for MISRA C 'for-loop well\u2011formed' analysis of MHD_SHA256_finish:\n\n- struct Sha256Ctx\n  Required to know the types and names of fields (count, buffer, H). A macro or inline accessor could refer to these fields or their types and could hide a for loop when expanded; also to confirm which objects are modified in the function body (so they cannot be loop counters or used in loop-control expressions).\n\n- SHA256_DIGEST_SIZE, SHA256_BLOCK_SIZE, SHA256_SIZE_OF_LEN_ADD, SHA256_BLOCK_SIZE_WORDS, SHA256_DIGEST_SIZE_WORDS, SHA256_BYTES_IN_WORD\n  These macros/constants affect pointer arithmetic, buffer offsets and conditional compilation in the function. They must be checked to ensure they are simple constants (no side effects, no hidden loops) and to determine which branches of code are compiled/visited; a macro definition could contain code (including for loops) that would change whether the target function contains for loops or modifies loop-control objects.\n\n- _MHD_PUT_64BIT_BE_SAFE\n  This is invoked in the function and might be a macro or inline function. If it expands to code containing a for loop or code that modifies objects used in potential for-loop clauses, it is relevant to the MISRA analysis. We need its definition to know whether it introduces loops or side effects.\n\n- _MHD_PUT_32BIT_BE\n  Appears multiple times and is likely a macro or inline routine used to store words; its expansion could contain loops or modify objects in ways that would violate the rule if used inside a for loop. Its definition is required to rule out hidden for loops or side effects in loop clauses.\n\n- _MHD_PUT_32BIT_BE_UNALIGNED and MHD_FAVOR_SMALL_CODE\n  These preprocessor symbols control which branches of code are compiled (the function has #ifdefs). Knowing their defined/undefined state (or their values) determines which code paths exist in the compiled function. A compiled path might include different code (possibly macros that expand to loops). To be certain the function contains no ill-formed for loops we must know which branches are active.\n\n- _MHD_UINT32_ALIGN\n  Used in the alignment test expression. Its value/type is needed to evaluate the conditional and determine whether the 'aligned temporary buffer' branch (which invokes _MHD_PUT_32BIT_BE and memcpy) or the direct-store branch is compiled/executed. Also to ensure that the conditional expression itself does not have side effects that could conflict with MISRA loop-clause rules.\n\n- sha256_transform\n  This callee must be inspected because if a for loop in MHD_SHA256_finish (or a macro expanded into a for loop) calls sha256_transform, the behavior of that called function is part of the for\u2011loop body per MISRA. Also confirm sha256_transform is a normal function (not a macro) and does not get inlined/expanded into the caller introducing loops or modifying loop counters from the caller scope.\n\n- memcpy, memset\n  These standard routines are used in the function. In some environments they may be implemented as macros or inline loops; we need to confirm their implementations are functions (no hidden for loops that would appear in the caller after macro expansion) and that they do not modify loop-control objects used in any for loops.\n\n- __builtin_bswap32\n  Referenced (directly or via macros) in the call graph; include to verify whether it is a plain builtin (no for loop) or a macro with unexpected side effects.\n\n- stdint typedefs (uint8_t,uint32_t,uint64_t) and uintptr_t\n  Types used in expressions and alignment checks. Needed to reason about integer widths, alignment expressions and to ensure no unexpected macro/type definitions expand into loop constructs or side effects that would affect for-loop clause analysis.\n\nRationale summary: The MISRA rule concerns structure of for statements and prohibits side effects or modifications to objects other than the loop counter in loop clauses. Even though the shown source contains no explicit for loops, preprocessor macros and inlined/expanded routines used here could themselves contain for loops or side effects that would make the compiled function contain ill-formed for loops or cause functions called inside a (hypothetical) for loop to modify loop-control objects. To conclusively determine compliance you must inspect the listed macros, typedefs, constants, and the bodies/definitions of called or potentially inlined routines to ensure no hidden for loops or side effects exist."
}