{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition: types and sizes of members count, buffer, H, and any padding)",
    "SHA256_BLOCK_SIZE",
    "SHA256_DIGEST_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "_MHD_PUT_64BIT_BE_SAFE (macro/inline function definition)",
    "_MHD_PUT_32BIT_BE (macro/inline function definition)",
    "_MHD_PUT_32BIT_BE_UNALIGNED (macro defined or not)",
    "_MHD_UINT32_ALIGN (alignment constant)",
    "MHD_FAVOR_SMALL_CODE (macro defined or not)",
    "sha256_transform prototype and its required buffer size/expectation (how many bytes/words it reads from 'buffer')",
    "memset prototype/semantics (from <string.h>)",
    "memcpy prototype/semantics (from <string.h>)",
    "typedefs: uint8_t, uint32_t, uint64_t, uintptr_t (from <stdint.h> / platform headers)",
    "sizeof(struct Sha256Ctx) value (or ability to compute it from the struct definition)"
  ],
  "explanation": "To determine whether the uses of memcpy and memset in MHD_SHA256_finish can access out-of-bounds memory we must know the exact sizes, types and layouts used and the precise behavior of the helper macros/functions that perform writes. Specifically:\n\n- struct Sha256Ctx (full definition): required to know the type and size of ctx->buffer, the type/size of ctx->count, and ctx->H layout so we can compute valid pointer ranges and sizeof(struct Sha256Ctx) for the final memset that zeroes the context.\n- SHA256_BLOCK_SIZE: used to calculate buffer offsets and lengths passed to memset and to determine how many bytes sha256_transform expects/reads.\n- SHA256_DIGEST_SIZE: size of the digest passed to memcpy and used for copying; needed to check memcpy destination/source bounds.\n- SHA256_SIZE_OF_LEN_ADD: determines how many bytes are reserved at the end of the final block for the length field; affects the amount of zero-padding written with memset.\n- SHA256_BLOCK_SIZE_WORDS: used in the expression passed to _MHD_PUT_64BIT_BE_SAFE; needed to compute the exact write address for the 64-bit length field.\n- SHA256_DIGEST_SIZE_WORDS and SHA256_BYTES_IN_WORD: used by the 32-bit put macros to compute where final digest words are stored; required to verify writes into 'alig_dgst' or 'digest'.\n- _MHD_PUT_64BIT_BE_SAFE (definition): must know how many bytes it writes and at what byte offset/interpretation (bytes vs words) to ensure the write at ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2 is in-bounds of ctx->buffer.\n- _MHD_PUT_32BIT_BE (definition): required to know whether it writes 4 bytes at the pointer passed (and whether it uses byte- or word-based pointer arithmetic) to verify all final-digest writes are within the destination buffer.\n- _MHD_PUT_32BIT_BE_UNALIGNED (presence/definition): controls which code path executes; needed to determine whether code will write directly into the user-supplied digest or into the aligned temporary + memcpy path.\n- _MHD_UINT32_ALIGN (value): used in the runtime alignment test; needed to know whether the aligned-temporary branch is taken and thus whether memcpy is invoked (and what buffers are source/destination and their sizes).\n- MHD_FAVOR_SMALL_CODE (defined or not): influences conditional compilation and which branches are present; this changes which string.h calls (memcpy/memset) and writes are executed.\n- sha256_transform prototype and expected buffer-size/read behavior: called with ctx->buffer; we must know how many bytes it reads (SHA256_BLOCK_SIZE?) and whether it expects the buffer type/size assumed by this code so earlier memset/put writes produce a full block for processing and do not index out of bounds.\n- memset and memcpy prototypes/semantics: to be explicit about parameters (destination pointer, size_t n) and that they perform byte-wise writes/reads so we can reason about byte counts vs object sizes.\n- Standard integer typedefs (uint8_t, uint32_t, uint64_t, uintptr_t): required to compute sizes, pointer arithmetic, and alignment checks precisely.\n- sizeof(struct Sha256Ctx) value: used by the final memset(ctx,0,sizeof(struct Sha256Ctx)); must be known (or computable from struct) to ensure that clearing does not overrun ctx pointer and that the size used matches the actual object allocation.\n\nWith these symbols (struct layout, size macros, put-macro definitions, alignment constants, and prototypes for sha256_transform/memset/memcpy) an analyst can compute the exact addresses and lengths passed to memset/memcpy and determine whether any call can write/read beyond the referenced object bounds, thereby deciding compliance with the MISRA string.h bounds rule."
}