{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_finish (struct Sha256Ctx *ctx,\n                   uint8_t digest[SHA256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  num_bits = ctx->count << 3;\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equal (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 paragraph 5.1.1. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space at least for one byte (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA256_BLOCK_SIZE - bytes_have < SHA256_SIZE_OF_LEN_ADD)\n  {   /* No space in current block to put total length of message.\n         Pad current block with zeros and process it. */\n    if (bytes_have < SHA256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA256_BLOCK_SIZE - bytes_have);\n    /* Process full block. */\n    sha256_transform (ctx->H, ctx->buffer);\n    /* Start new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA256_BLOCK_SIZE - SHA256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put the number of bits in processed message as big-endian value. */\n  _MHD_PUT_64BIT_BE_SAFE (ctx->buffer + SHA256_BLOCK_SIZE_WORDS - 2, num_bits);\n  /* Process full final block. */\n  sha256_transform (ctx->H, ctx->buffer);\n\n  /* Put final hash/digest in BE mode */\n#ifndef _MHD_PUT_32BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT32_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint32_t alig_dgst[SHA256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_32BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 3, ctx->H[3]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 4, ctx->H[4]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 5, ctx->H[5]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 6, ctx->H[6]);\n    _MHD_PUT_32BIT_BE (alig_dgst + 7, ctx->H[7]);\n    /* Copy result to unaligned destination address */\n    memcpy (digest, alig_dgst, SHA256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_32BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_32BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_32BIT_BE ((void *) (digest + 0 * SHA256_BYTES_IN_WORD), ctx->H[0]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 1 * SHA256_BYTES_IN_WORD), ctx->H[1]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 2 * SHA256_BYTES_IN_WORD), ctx->H[2]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 3 * SHA256_BYTES_IN_WORD), ctx->H[3]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 4 * SHA256_BYTES_IN_WORD), ctx->H[4]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 5 * SHA256_BYTES_IN_WORD), ctx->H[5]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 6 * SHA256_BYTES_IN_WORD), ctx->H[6]);\n    _MHD_PUT_32BIT_BE ((void *) (digest + 7 * SHA256_BYTES_IN_WORD), ctx->H[7]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_32BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '_MHD_PUT_64BIT_BE_SAFE': {'callees': [], 'callers': ['MHD_SHA256_finish']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "SHA256_BLOCK_SIZE",
    "SHA256_SIZE_OF_LEN_ADD",
    "SHA256_BLOCK_SIZE_WORDS",
    "SHA256_DIGEST_SIZE",
    "SHA256_DIGEST_SIZE_WORDS",
    "SHA256_BYTES_IN_WORD",
    "_MHD_PUT_32BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT32_ALIGN",
    "_MHD_PUT_32BIT_BE",
    "_MHD_PUT_64BIT_BE_SAFE",
    "MHD_SHA256_update",
    "memset",
    "memcpy",
    "uintptr_t"
  ],
  "explanation": "For determining unreachable code in MHD_SHA256_finish you must know both compile\u2011time and relevant runtime facts. Brief reasons per symbol:\n\n- struct Sha256Ctx: needed to know types/sizes and semantics of ctx->count, ctx->buffer and ctx->H (ranges, alignment, storage) so you can tell which value combinations and branches (e.g. bytes_have computation) are possible.\n- SHA256_BLOCK_SIZE: used in modulus/index computations and buffer sizing; influences whether padding branches can be taken.\n- SHA256_SIZE_OF_LEN_ADD: compared to remaining block space to decide whether to process current block or start a new one; required to decide reachability of that branch.\n- SHA256_BLOCK_SIZE_WORDS: used in computing where to put the 64\u2011bit length inside ctx->buffer; needed to verify buffer indexing/possible overflows and whether that code is reachable.\n- SHA256_DIGEST_SIZE: size used in memcpy and returned digest; affects decisions about copying and branch reachability relating to alignment handling.\n- SHA256_DIGEST_SIZE_WORDS: used to size temporary aligned digest array; needed to reason about that stack allocation and associated branch.\n- SHA256_BYTES_IN_WORD: used when storing final digest words; affects offsets used by _MHD_PUT_32BIT_BE invocations (branch semantics/side effects).\n- _MHD_PUT_32BIT_BE_UNALIGNED: preprocessor conditional controls which code blocks are compiled; whether it is defined or not changes which branches exist at all (crucial for unreachable\u2011code analysis).\n- MHD_FAVOR_SMALL_CODE: preprocessor conditional that changes the condition combined with the runtime alignment check; its definition/non\u2011definition changes whether an if becomes compile\u2011time constant (thus possibly unreachable code).\n- _MHD_UINT32_ALIGN: the numeric alignment modulus used in the runtime alignment test ((uintptr_t) digest) % _MHD_UINT32_ALIGN); its value determines whether the alignment test can ever be true/false.\n- _MHD_PUT_32BIT_BE: macro/function used to store 32\u2011bit words in BE order; its definition may contain side effects or conditional code that affect reachability/behaviour of branches that call it (and may hide unreachable code inside the macro itself).\n- _MHD_PUT_64BIT_BE_SAFE: called to write the 64\u2011bit bit\u2011count; definition needed to confirm it does not contain control flow that affects reachability in the caller.\n- MHD_SHA256_update: the updater function governs how ctx->count and ctx->buffer are maintained across updates; to validate invariants (e.g. \"Buffer always have space at least for one byte\") you must inspect where/ how count is advanced so you can decide if some branches in finish are actually impossible.\n- memset: used to pad buffers/zero ctx; include its presence to reason about side effects and to ensure those calls are valid/used (not compile\u2011time removed) \u2014 also relevant when testing whether code paths that call memset are ever reached.\n- memcpy: used to copy aligned digest to destination; whether that call can be reached depends on alignment checks \u2014 include it to reason about the branch that uses a temporary buffer.\n- uintptr_t: the type used to compute digest address alignment; understanding its width and semantics is necessary to evaluate the alignment modulus expression and determine if the alignment test can be a compile\u2011time constant or always/never true.\n\nThese symbols allow the next analyzer to determine which #if/#ifdef conditions are active, whether runtime alignment tests can ever evaluate to a given boolean, and whether the buffer/length invariants make branches reachable or provably impossible (i.e. unreachable) under the project configuration."
}