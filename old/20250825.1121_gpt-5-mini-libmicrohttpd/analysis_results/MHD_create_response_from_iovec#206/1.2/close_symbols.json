{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_iovec (const struct MHD_IoVec *iov,\n                                unsigned int iovcnt,\n                                MHD_ContentReaderFreeCallback free_cb,\n                                void *cls)\n{\n  struct MHD_Response *response;\n  unsigned int i;\n  int i_cp = 0;   /**< Index in the copy of iov */\n  uint64_t total_size = 0;\n  const void *last_valid_buffer = NULL;\n\n  if ((NULL == iov) && (0 < iovcnt))\n    return NULL;\n\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n    return NULL;\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n  /* Calculate final size, number of valid elements, and check 'iov' */\n  for (i = 0; i < iovcnt; ++i)\n  {\n    if (0 == iov[i].iov_len)\n      continue;     /* skip zero-sized elements */\n    if (NULL == iov[i].iov_base)\n    {\n      i_cp = -1;     /* error */\n      break;\n    }\n    if ( (total_size > (total_size + iov[i].iov_len)) ||\n         (INT_MAX == i_cp) ||\n         (SSIZE_MAX < (total_size + iov[i].iov_len)) )\n    {\n      i_cp = -1;     /* overflow */\n      break;\n    }\n    last_valid_buffer = iov[i].iov_base;\n    total_size += iov[i].iov_len;\n#if defined(MHD_POSIX_SOCKETS) || ! defined(_WIN64)\n    i_cp++;\n#else  /* ! MHD_POSIX_SOCKETS && _WIN64 */\n    {\n      int64_t i_add;\n\n      i_add = (int64_t) (iov[i].iov_len / ULONG_MAX);\n      if (0 != iov[i].iov_len % ULONG_MAX)\n        i_add++;\n      if (INT_MAX < (i_add + i_cp))\n      {\n        i_cp = -1;   /* overflow */\n        break;\n      }\n      i_cp += (int) i_add;\n    }\n#endif /* ! MHD_POSIX_SOCKETS && _WIN64 */\n  }\n  if (-1 == i_cp)\n  {\n    /* Some error condition */\n    MHD_mutex_destroy_chk_ (&response->mutex);\n    free (response);\n    return NULL;\n  }\n  response->fd = -1;\n  response->reference_count = 1;\n  response->total_size = total_size;\n  response->crc_cls = cls;\n  response->crfc = free_cb;\n  if (0 == i_cp)\n  {\n    mhd_assert (0 == total_size);\n    return response;\n  }\n  if (1 == i_cp)\n  {\n    mhd_assert (NULL != last_valid_buffer);\n    response->data = last_valid_buffer;\n    response->data_size = (size_t) total_size;\n    return response;\n  }\n  mhd_assert (1 < i_cp);\n  if (1)\n  { /* for local variables local scope only */\n    MHD_iovec_ *iov_copy;\n    int num_copy_elements = i_cp;\n\n    iov_copy = MHD_calloc_ ((size_t) num_copy_elements, \\\n                            sizeof(MHD_iovec_));\n    if (NULL == iov_copy)\n    {\n      MHD_mutex_destroy_chk_ (&response->mutex);\n      free (response);\n      return NULL;\n    }\n    i_cp = 0;\n    for (i = 0; i < iovcnt; ++i)\n    {\n      size_t element_size = iov[i].iov_len;\n      const uint8_t *buf = (const uint8_t *) iov[i].iov_base;\n\n      if (0 == element_size)\n        continue;         /* skip zero-sized elements */\n#if defined(MHD_WINSOCK_SOCKETS) && defined(_WIN64)\n      while (MHD_IOV_ELMN_MAX_SIZE < element_size)\n      {\n        iov_copy[i_cp].iov_base = (char *) _MHD_DROP_CONST (buf);\n        iov_copy[i_cp].iov_len = ULONG_MAX;\n        buf += ULONG_MAX;\n        element_size -= ULONG_MAX;\n        i_cp++;\n      }\n#endif /* MHD_WINSOCK_SOCKETS && _WIN64 */\n      iov_copy[i_cp].iov_base = _MHD_DROP_CONST (buf);\n      iov_copy[i_cp].iov_len = (MHD_iov_size_) element_size;\n      i_cp++;\n    }\n    mhd_assert (num_copy_elements == i_cp);\n    mhd_assert (0 <= i_cp);\n    response->data_iov = iov_copy;\n    response->data_iovcnt = (unsigned int) i_cp;\n  }\n  return response;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_response_from_iovec': {'callees': ['__builtin_unreachable'], 'callers': []}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "__builtin_unreachable",
    "_MHD_DROP_CONST",
    "_MHD_EXTERN",
    "MHD_calloc_",
    "MHD_mutex_init_",
    "MHD_mutex_destroy_chk_",
    "MHD_iovec_",
    "MHD_iov_size_",
    "MHD_IoVec",
    "struct MHD_Response",
    "MHD_ContentReaderFreeCallback",
    "MHD_WINSOCK_SOCKETS",
    "MHD_POSIX_SOCKETS",
    "_WIN64"
  ],
  "explanation": "To determine whether this function violates the MISRA rule prohibiting compiler/language extensions we must inspect any macros, types or helpers that could themselves use compiler-specific extensions. For each symbol below we need its definition or expansion so the analyzer can detect uses of extensions (e.g. __builtin_*, __attribute__, typeof, statement-expressions, inline asm, compiler-specific storage-class specifiers such as __declspec, nested functions, etc.):\n\n- mhd_assert: likely a macro that may expand to compiler built-ins (e.g. __builtin_unreachable) or attributes; inspect expansion for extensions.\n- __builtin_unreachable: an explicit GCC/Clang builtin \u2014 presence indicates use of a compiler extension; check whether it is used directly or via macros.\n- _MHD_DROP_CONST: macro used to drop constness; its implementation may use casts or non-standard constructs (e.g. union/typeof tricks) that are extensions.\n- _MHD_EXTERN: linkage/storage-class macro \u2014 may expand to compiler-specific annotations (e.g. __declspec(dllexport), __attribute__((visibility))) and must be checked.\n- MHD_calloc_: allocator wrapper \u2014 may be a macro/function declared with compiler attributes (alloc_size, malloc, etc.) or inline extensions; inspect its declaration/definition.\n- MHD_mutex_init_: initialization helper/macro \u2014 may wrap platform APIs or use inline/attribute/extension constructs; check its definition.\n- MHD_mutex_destroy_chk_: destroy/check helper \u2014 same rationale as MHD_mutex_init_, could hide extensions.\n- MHD_iovec_: the local iovec struct/type used for copying \u2014 its definition may use non-standard type features or extensions (anonymous structs, compiler-specific packing, etc.).\n- MHD_iov_size_: typedef used for iov_len casts \u2014 could be defined via non-standard integer types or compiler-specific typedefs/attributes.\n- MHD_IoVec: the input iov element type \u2014 its definition needs checking for extensions (e.g. non-standard field types, attributes).\n- struct MHD_Response: response struct definition \u2014 may contain fields declared with compiler-specific attributes/annotations or use non-standard types.\n- MHD_ContentReaderFreeCallback: callback typedef \u2014 its declaration could use calling-convention attributes (e.g. __stdcall, __attribute__ ((...))) which are compiler extensions.\n- MHD_WINSOCK_SOCKETS and MHD_POSIX_SOCKETS: configuration macros that control alternative code paths; both code paths must be inspected because one may enable compiler-specific constructs.\n- _WIN64: platform macro that selects Windows-specific code path \u2014 the Windows-specific code may use Microsoft extensions (e.g. __declspec, WINAPI/ calling convention macros).\n\nOnly by examining the definitions/expansions of the above symbols can we detect any explicit use of documented compiler extensions. The remaining standard headers/macros (INT_MAX, SSIZE_MAX, ULONG_MAX, uint64_t, etc.) are standard C/C library symbols and do not by themselves indicate use of compiler extensions; they still may be affected by the above macros/types if those wrap or redefine them."
}