{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset2 (struct MHD_Daemon *daemon,\n                fd_set *read_fd_set,\n                fd_set *write_fd_set,\n                fd_set *except_fd_set,\n                MHD_socket *max_fd,\n                unsigned int fd_setsize)\n{\n  if ( (NULL == daemon) ||\n       (NULL == read_fd_set) ||\n       (NULL == write_fd_set) ||\n       MHD_D_IS_USING_THREADS_ (daemon) ||\n       MHD_D_IS_USING_POLL_ (daemon))\n    return MHD_NO;\n\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_get_fdset2() called with except_fd_set \"\n                 \"set to NULL. Such behavior is unsupported.\\n\"));\n  }\n#endif\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_get_fdset2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (daemon->shutdown)\n      return MHD_YES;\n\n    /* we're in epoll mode, use the epoll FD as a stand-in for\n       the entire event set */\n\n    return MHD_add_to_fd_set_ (daemon->epoll_fd,\n                               read_fd_set,\n                               max_fd,\n                               (int) fd_setsize) ? MHD_YES : MHD_NO;\n  }\n#endif\n\n  return internal_get_fdset2 (daemon,\n                              read_fd_set,\n                              write_fd_set,\n                              except_fd_set,\n                              max_fd,\n                              (int) fd_setsize);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_get_fdset': {'callees': ['MHD_get_fdset2'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_add_to_fd_set_ (definition/prototype or macro expansion)",
    "internal_get_fdset2 (definition/prototype or macro expansion)",
    "MHD_DLOG (definition/macro expansion)",
    "MHD_D_IS_USING_THREADS_ (macro definition)",
    "MHD_D_IS_USING_POLL_ (macro definition)",
    "MHD_D_IS_USING_EPOLL_ (macro definition)",
    "struct MHD_Daemon (full definition; at least epoll_fd, shutdown, fdset_size, fdset_size_set_by_app)",
    "typedef/definition of MHD_socket",
    "typedef/definition of fd_set",
    "Preprocessor flags: HAS_FD_SETSIZE_OVERRIDABLE, HAVE_MESSAGES, EPOLL_SUPPORT"
  ],
  "explanation": "To determine whether MHD_get_fdset2 violates the MISRA rule forbidding modification of function parameters (the pointer variables themselves), the next analyst must see any callees/macros that are expanded/instantiated in this function and the key type/struct definitions that these expansions reference: \n\n- MHD_add_to_fd_set_: must inspect its definition (function or macro) because if it is a macro that expands in-place it could assign to the local parameter identifiers (e.g. read_fd_set, max_fd) and thus modify the parameter variables inside MHD_get_fdset2. If it is a function, its prototype shows whether parameters are pointers-to-pointer (which could allow modification via indirection) or simple values.\n\n- internal_get_fdset2: same reasoning as MHD_add_to_fd_set_. If it is a macro it could perform assignments to the parameter names; if a function, its signature/implementation shows whether it modifies pointer parameters by assignment.\n\n- MHD_DLOG: usually a logging macro; need its expansion to ensure it does not reassign any parameter identifiers (daemon, etc.) when expanded in-place.\n\n- MHD_D_IS_USING_THREADS_, MHD_D_IS_USING_POLL_, MHD_D_IS_USING_EPOLL_: these are macros used in conditional expressions. Their definitions must be inspected to ensure they are simple predicates and do not perform assignments to the 'daemon' parameter name (a macro could conceivably expand to an expression with side effects that assign to or modify the parameter variable itself).\n\n- struct MHD_Daemon: the macros and calls reference fields (epoll_fd, shutdown, fdset_size, fdset_size_set_by_app). The struct definition is needed to understand whether any macro or inline function could take the 'daemon' identifier and perform assignments to it or its fields in a way that would modify the pointer variable itself when macros are expanded.\n\n- typedef/definition of MHD_socket: knowing the actual type helps determine whether any assignment to max_fd (or uses in macros) would be type-correct and therefore possible; also needed for examining callee prototypes.\n\n- typedef/definition of fd_set: similarly, to see whether macros/functions could legitimately assign to read_fd_set/write_fd_set/except_fd_set identifiers or expect pointer-to-pointer signatures.\n\n- Preprocessor flags (HAS_FD_SETSIZE_OVERRIDABLE, HAVE_MESSAGES, EPOLL_SUPPORT): these control which blocks of code are compiled. The analyst must know which of these are defined for the build under analysis so they can inspect the exact instantiation of MHD_get_fdset2 (e.g., whether the EPOLL_SUPPORT branch with MHD_add_to_fd_set_ is included, or whether message-logging code is present that uses MHD_DLOG macros).\n\nIn short: to prove no parameter (pointer) is reassigned inside MHD_get_fdset2 you must inspect any macro/function that could expand into assignments to the parameter identifiers and the relevant type/struct definitions so you can rule out legal assignments. The symbols above are the minimal set required to perform that inspection."
}