{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_fdset2 (struct MHD_Daemon *daemon,\n                fd_set *read_fd_set,\n                fd_set *write_fd_set,\n                fd_set *except_fd_set,\n                MHD_socket *max_fd,\n                unsigned int fd_setsize)\n{\n  if ( (NULL == daemon) ||\n       (NULL == read_fd_set) ||\n       (NULL == write_fd_set) ||\n       MHD_D_IS_USING_THREADS_ (daemon) ||\n       MHD_D_IS_USING_POLL_ (daemon))\n    return MHD_NO;\n\n#ifdef HAVE_MESSAGES\n  if (NULL == except_fd_set)\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_get_fdset2() called with except_fd_set \"\n                 \"set to NULL. Such behavior is unsupported.\\n\"));\n  }\n#endif\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  if (0 == fd_setsize)\n    return MHD_NO;\n  else if (((unsigned int) INT_MAX) < fd_setsize)\n    fd_setsize = (unsigned int) INT_MAX;\n#ifdef HAVE_MESSAGES\n  else if (daemon->fdset_size > ((int) fd_setsize))\n  {\n    if (daemon->fdset_size_set_by_app)\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than value set by MHD_OPTION_APP_FD_SETSIZE (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Use MHD_OPTION_APP_FD_SETSIZE with the correct value.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n    else\n    {\n      MHD_DLOG (daemon,\n                _ (\"%s() called with fd_setsize (%u) \" \\\n                   \"less than FD_SETSIZE used by MHD (%d). \" \\\n                   \"Some socket FDs may be not processed. \" \\\n                   \"Consider using MHD_OPTION_APP_FD_SETSIZE option.\\n\"),\n                \"MHD_get_fdset2\", fd_setsize, daemon->fdset_size);\n    }\n  }\n#endif /* HAVE_MESSAGES */\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n  if (((unsigned int) FD_SETSIZE) > fd_setsize)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"%s() called with fd_setsize (%u) \" \\\n                 \"less than fixed FD_SETSIZE value (%d) used on the \" \\\n                 \"platform.\\n\"),\n              \"MHD_get_fdset2\", fd_setsize, (int) FD_SETSIZE);\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  fd_setsize = (int) FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (daemon->shutdown)\n      return MHD_YES;\n\n    /* we're in epoll mode, use the epoll FD as a stand-in for\n       the entire event set */\n\n    return MHD_add_to_fd_set_ (daemon->epoll_fd,\n                               read_fd_set,\n                               max_fd,\n                               (int) fd_setsize) ? MHD_YES : MHD_NO;\n  }\n#endif\n\n  return internal_get_fdset2 (daemon,\n                              read_fd_set,\n                              write_fd_set,\n                              except_fd_set,\n                              max_fd,\n                              (int) fd_setsize);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_fdset2': {'callees': ['MHD_DLOG', 'MHD_add_to_fd_set_', 'internal_get_fdset2'], 'callers': ['MHD_get_fdset', 'main']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_add_to_fd_set_': {'callees': [], 'callers': ['internal_get_fdset2', 'MHD_get_fdset2', 'thread_main_handle_connection', 'MHD_select']}, 'internal_get_fdset2': {'callees': ['MHD_add_to_fd_set_'], 'callers': ['MHD_get_fdset2', 'MHD_select']}, 'MHD_get_fdset': {'callees': ['MHD_get_fdset2'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "enum MHD_Result",
    "struct MHD_Daemon",
    "fd_set",
    "MHD_socket",
    "MHD_D_IS_USING_THREADS_",
    "MHD_D_IS_USING_POLL_",
    "MHD_D_IS_USING_EPOLL_",
    "MHD_add_to_fd_set_",
    "internal_get_fdset2",
    "MHD_DLOG",
    "_",
    "EPOLL_SUPPORT",
    "HAVE_MESSAGES",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "FD_SETSIZE",
    "INT_MAX",
    "MHD_YES",
    "MHD_NO",
    "fdset_size",
    "fdset_size_set_by_app",
    "epoll_fd",
    "shutdown"
  ],
  "explanation": "For a MISRA check that only flags the use of language/compiler extensions, the next analyzer must be able to see any macro/type/function/field definitions that might expand to or hide such extensions. Brief reasons for each symbol:\n\n- _MHD_EXTERN: storage-class/visibility macro \u2014 may expand to compiler-specific keywords or attributes (e.g. __attribute__, __declspec) which are language extensions.\n- enum MHD_Result: enum declaration may use non-standard attributes or sized-enum extensions; need its definition.\n- struct MHD_Daemon: the daemon type may include anonymous unions/structs, bitfields, or other non-standard constructs; need full definition to spot extensions.\n- fd_set: platform type definition could be implemented with non-standard constructs; check definition.\n- MHD_socket: typedef for socket type may use compiler-specific types/attributes.\n- MHD_D_IS_USING_THREADS_, MHD_D_IS_USING_POLL_, MHD_D_IS_USING_EPOLL_: these macros/functions control flow and may themselves be implemented with statement-expressions, typeof, or other GCC/clang extensions \u2014 must inspect their definitions.\n- MHD_add_to_fd_set_, internal_get_fdset2: function declarations/definitions may be annotated with compiler-specific attributes (calling conventions, visibility, inline, format, nonnull, etc.) or use extensions in signatures \u2014 need prototypes/definitions.\n- MHD_DLOG: logging macro often wraps variadic macros or statement-expressions and may use attributes (format) or language extensions; inspect definition.\n- _: translation/gettext macro \u2014 often a macro that can be defined as a function-like or attribute-wrapped expression; definition may use extensions (variadic, attributes).\n- EPOLL_SUPPORT, HAVE_MESSAGES, HAS_FD_SETSIZE_OVERRIDABLE: these compile-time feature macros control conditional compilation; their presence/definitions determine which code paths (and potential extensions) are active.\n- FD_SETSIZE, INT_MAX: constants/macros used in comparisons and casts; while standard, their headers could include platform-specific types or macros \u2014 include to confirm no nonstandard behavior is introduced here.\n- MHD_YES, MHD_NO: return-value macros/enum constants \u2014 inspect their definitions (may be macros mapping to integer constants or expressions using extensions).\n- fdset_size, fdset_size_set_by_app, epoll_fd, shutdown: struct MHD_Daemon fields referenced in the function \u2014 their types/definitions may involve bitfields, anonymous members, or attributes that are language extensions.\n\nProviding these symbols (macros, type and function declarations/definitions and the specific struct fields) lets the next agent determine whether any of them (or their expansions) use compiler-specific language extensions (e.g. __attribute__, __asm__, typeof, statement-expressions, nested functions, __inline__ variants, anonymous aggregates, nonstandard bitfield usage, etc.) that would violate the MISRA rule."
}