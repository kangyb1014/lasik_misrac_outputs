{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_socket_nonblocking_:\n```c\nint\nMHD_socket_nonblocking_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFL);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | O_NONBLOCK) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFL,\n                    flags | O_NONBLOCK)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        (int) FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_socket_nonblocking_:\n#define MHD_POSIX_SOCKETS 1\n...\ntypedef int MHD_socket\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n...\nstatic enum MHD_Result\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n  struct sockaddr_storage addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  bool sk_cloexec;\n  enum MHD_tristate sk_non_ip;\n#if defined(_DEBUG) && defined (USE_ACCEPT4)\n  const bool use_accept4 = ! daemon->avoid_accept4;\n#elif defined (USE_ACCEPT4)\n  static const bool use_accept4 = true;\n#else  /* ! USE_ACCEPT4 && ! _DEBUG */\n  static const bool use_accept4 = false;\n#endif /* ! USE_ACCEPT4 && ! _DEBUG */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n\n  addrlen = (socklen_t) sizeof (addrstorage);\n  memset (&addrstorage,\n          0,\n          (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen;\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n  /* Initialise with default values to avoid compiler warnings */\n  sk_nonbl = false;\n  sk_spipe_supprs = false;\n  sk_cloexec = false;\n  s = MHD_INVALID_SOCKET;\n\n#ifdef USE_ACCEPT4\n  if (use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept4 (fd,\n                     (struct sockaddr *) &addrstorage,\n                     &addrlen,\n                     SOCK_CLOEXEC_OR_ZERO | SOCK_NONBLOCK_OR_ZERO\n                     | SOCK_NOSIGPIPE_OR_ZERO))))\n  {\n    sk_nonbl = (SOCK_NONBLOCK_OR_ZERO != 0);\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = (SOCK_CLOEXEC_OR_ZERO != 0);\n  }\n#endif /* USE_ACCEPT4 */\n#if defined(_DEBUG) || ! defined(USE_ACCEPT4)\n  if (! use_accept4 &&\n      (MHD_INVALID_SOCKET !=\n       (s = accept (fd,\n                    (struct sockaddr *) &addrstorage,\n                    &addrlen))))\n  {\n#ifdef MHD_ACCEPT_INHERIT_NONBLOCK\n    sk_nonbl = daemon->listen_nonblk;\n#else  /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n    sk_nonbl = false;\n#endif /* ! MHD_ACCEPT_INHERIT_NONBLOCK */\n#ifndef MHD_WINSOCK_SOCKETS\n    sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n    sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n    sk_cloexec = false;\n  }\n#endif /* _DEBUG || !USE_ACCEPT4 */\n\n  if (MHD_INVALID_SOCKET == s)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    /* This could be a common occurrence with multiple worker threads */\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EINVAL_))\n      return MHD_NO;   /* can happen during shutdown */\n    if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_ (err))\n      return MHD_NO;   /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n    if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n      MHD_DLOG (daemon,\n                _ (\"Error accepting connection: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n    {\n      /* system/process out of resources */\n      if (0 == daemon->connections)\n      {\n#ifdef HAVE_MESSAGES\n        /* Not setting 'at_limit' flag, as there is no way it\n           would ever be cleared.  Instead trying to produce\n           bit fat ugly warning. */\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at FIRST \" \\\n                     \"connection. This is really bad as there is no sane \" \\\n                     \"way to proceed. Will try busy waiting for system \" \\\n                     \"resources to become magically available.\\n\"));\n#endif\n      }\n      else\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n        daemon->at_limit = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Hit process or system resource limit at %u \" \\\n                     \"connections, temporarily suspending accept(). \" \\\n                     \"Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                  (unsigned int) daemon->connections);\n#endif\n      }\n    }\n    return MHD_NO;\n  }\n\n  sk_non_ip = daemon->listen_is_unix;\n  if (0 >= addrlen)\n  {\n#ifdef HAVE_MESSAGES\n    if (_MHD_NO != daemon->listen_is_unix)\n      MHD_DLOG (daemon,\n                _ (\"Accepted socket has zero-length address. \"\n                   \"Processing the new socket as a socket with \" \\\n                   \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses have non-zero length */\n  }\n  if (((socklen_t) sizeof (addrstorage)) < addrlen)\n  {\n    /* Should not happen as 'sockaddr_storage' must be large enough to\n     * store any address supported by the system. */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Accepted socket address is larger than expected by \" \\\n                 \"system headers. Processing the new socket as a socket with \" \\\n                 \"unknown type.\\n\"));\n#endif\n    addrlen = 0;\n    sk_non_ip = _MHD_YES; /* IP-type addresses must fit */\n  }\n\n  if (! sk_nonbl && ! MHD_socket_nonblocking_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n  else\n    sk_nonbl = true;\n\n  if (! sk_cloexec && ! MHD_socket_noninheritable_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on incoming connection \" \\\n                 \"socket.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n  }\n\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs && ! MHD_socket_nosignal_ (s))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on incoming connection \" \\\n                 \"socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      (void) MHD_socket_close_ (s);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n  else\n    sk_spipe_supprs = true;\n#endif /* MHD_socket_nosignal_ */\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n                                  &addrstorage,\n                                  addrlen,\n                                  false,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  sk_non_ip);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n                     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd = MHD_INVALID_SOCKET;\n  const struct sockaddr *pservaddr = NULL;\n  socklen_t addrlen;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n  struct MHD_InterimParams_ *interim_params;\n\n  MHD_check_global_init_ ();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n\n  if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n    *pflags |= MHD_USE_INTERNAL_POLLING_THREAD; /* Force enable, log warning later if needed */\n\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n  {\n#ifdef UPGRADE_SUPPORT\n    *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n    return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n#ifdef MHD_USE_THREADS\n  if ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD) ==\n      ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD)\n       & *pflags))\n    return NULL; /* Cannot be thread-unsafe with multiple threads */\n#else  /* ! MHD_USE_THREADS */\n  if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    return NULL;\n#endif /* ! MHD_USE_THREADS */\n\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_EPOLL)) &&\n      (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_POLL)) &&\n      (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD\n                        | MHD_USE_THREAD_PER_CONNECTION))))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_AUTO)) &&\n      (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))))\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n  {\n#if defined(EPOLL_SUPPORT) && defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_POLL;\n    else\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#elif defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n      *pflags |= MHD_USE_POLL; /* Including thread-per-connection */\n#elif defined(EPOLL_SUPPORT)\n    if (0 == (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#else\n    /* No choice: use select() for any mode - do not modify flags */\n#endif\n  }\n\n  if (0 != (*pflags & MHD_USE_NO_THREAD_SAFETY))\n    *pflags = (*pflags & ~((enum MHD_FLAG) MHD_USE_ITC)); /* useless in single-threaded environment */\n  else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n  {\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n    *pflags |= MHD_USE_ITC;       /* yes, must use ITC to signal thread */\n  }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n  interim_params = (struct MHD_InterimParams_ *) \\\n                   MHD_calloc_ (1, sizeof (struct MHD_InterimParams_));\n  if (NULL == interim_params)\n  {\n    int err_num = errno;\n    free (daemon);\n    errno = err_num;\n    return NULL;\n  }\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listen_is_unix = _MHD_NO;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->client_discipline = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ?\n                              1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout_ms = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&daemon->tid);\n#endif /* MHD_USE_THREADS */\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = &MHD_default_logger_;\n  daemon->custom_error_log_cls = stderr;\n#endif\n#ifndef MHD_WINSOCK_SOCKETS\n  daemon->sigpipe_blocked = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  /* There is no SIGPIPE on W32, nothing to block. */\n  daemon->sigpipe_blocked = true;\n#endif /* _WIN32 && ! __CYGWIN__ */\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  daemon->avoid_accept4 = false;\n#endif /* _DEBUG */\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  daemon->fdset_size = (int) FD_SETSIZE;\n  daemon->fdset_size_set_by_app = false;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n  daemon->dauth_def_nonce_timeout = MHD_DAUTH_DEF_TIMEOUT_;\n  daemon->dauth_def_max_nc = MHD_DAUTH_DEF_MAX_NC_;\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n  }\n#endif /* HTTPS_SUPPORT */\n\n  interim_params->num_opts = 0;\n  interim_params->fdset_size_set = false;\n  interim_params->fdset_size = 0;\n  interim_params->listen_fd_set = false;\n  interim_params->listen_fd = MHD_INVALID_SOCKET;\n  interim_params->pserver_addr_set = false;\n  interim_params->pserver_addr = NULL;\n  interim_params->server_addr_len_set = false;\n  interim_params->server_addr_len = 0;\n\n  if (MHD_NO == parse_options_va (daemon,\n                                  interim_params,\n                                  ap))\n  {\n#ifdef HTTPS_SUPPORT\n    if ( (0 != (*pflags & MHD_USE_TLS)) &&\n         (NULL != daemon->priority_cache) )\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  if (! process_interim_params (daemon,\n                                &pservaddr,\n                                &addrlen,\n                                interim_params))\n  {\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  free (interim_params);\n  interim_params = NULL;\n#ifdef HTTPS_SUPPORT\n  if ((0 != (*pflags & MHD_USE_TLS))\n      && (NULL == daemon->priority_cache)\n      && ! daemon_tls_priorities_init_default (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialise GnuTLS priorities.\\n\"));\n#endif /* HAVE_MESSAGES */\n    free (daemon);\n    return NULL;\n  }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (flags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used \" \\\n                 \"only with MHD_USE_INTERNAL_POLLING_THREAD. \" \\\n                 \"Flag MHD_USE_INTERNAL_POLLING_THREAD was added. \" \\\n                 \"Consider setting MHD_USE_INTERNAL_POLLING_THREAD \" \\\n                 \"explicitly.\\n\"));\n  }\n#endif\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)\n      && ((NULL != daemon->notify_completed)\n          || (NULL != daemon->notify_connection)) )\n    *pflags |= MHD_USE_ITC; /* requires ITC */\n\n#ifdef _DEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            _ (\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* _DEBUG */\n\n  if ( (0 != (*pflags & MHD_USE_ITC))\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n       && (0 == daemon->worker_pool_size)\n#endif\n       )\n  {\n    if (! MHD_itc_init_ (daemon->itc))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create inter-thread communication channel: %s\\n\"),\n                MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (daemon->itc), daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"file descriptor for inter-thread communication \" \\\n                   \"channel exceeds maximum value.\\n\"));\n#endif\n      MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#ifdef DAUTH_SUPPORT\n  if (NULL != daemon->digest_auth_random_copy)\n  {\n    mhd_assert (daemon == daemon->digest_auth_random_copy);\n    daemon->digest_auth_random_copy = malloc (daemon->digest_auth_rand_size);\n    if (NULL == daemon->digest_auth_random_copy)\n    {\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    memcpy (daemon->digest_auth_random_copy,\n            daemon->digest_auth_random,\n            daemon->digest_auth_rand_size);\n    daemon->digest_auth_random = daemon->digest_auth_random_copy;\n  }\n  if (daemon->nonce_nc_size > 0)\n  {\n    if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc)))\n         / sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Specified value for NC_SIZE too large.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n    daemon->nnc = MHD_calloc_ (daemon->nonce_nc_size,\n                               sizeof (struct MHD_NonceNc));\n    if (NULL == daemon->nnc)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize nonce-nc mutex.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n    if (0 != (*pflags & MHD_USE_TLS))\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n    free (daemon);\n    return NULL;\n  }\n#endif\n#endif\n\n  /* Thread polling currently works only with internal select thread mode */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! MHD_D_IS_USING_THREADS_ (daemon)) &&\n       (daemon->worker_pool_size > 0) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD thread polling only works with \" \\\n                 \"MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif\n    goto free_and_fail;\n  }\n#endif\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n  {\n    /* try to open listen socket */\n    struct sockaddr_in servaddr4;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 servaddr6;\n    const bool use_ipv6 = (0 != (*pflags & MHD_USE_IPv6));\n#else  /* ! HAVE_INET6 */\n    const bool use_ipv6 = false;\n#endif /* ! HAVE_INET6 */\n    int domain;\n\n    if (NULL != pservaddr)\n    {\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      const socklen_t sa_len = pservaddr->sa_len;\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#ifdef HAVE_INET6\n      if (use_ipv6 && (AF_INET6 != pservaddr->sa_family))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_USE_IPv6 is enabled, but 'struct sockaddr *' \" \\\n                     \"specified for MHD_OPTION_SOCK_ADDR_LEN or \" \\\n                     \"MHD_OPTION_SOCK_ADDR is not IPv6 address.\\n\"));\n#endif /* HAVE_MESSAGES */\n        goto free_and_fail;\n      }\n#endif /* HAVE_INET6 */\n      switch (pservaddr->sa_family)\n      {\n      case AF_INET:\n        if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;\n#ifdef HAVE_INET6\n      case AF_INET6:\n        if (1)\n        {\n          struct sockaddr_in6 sa6;\n          uint16_t sa6_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa6)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa6)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa6);\n          memcpy (&sa6, pservaddr, sizeof(sa6));  /* Required due to stronger alignment */\n          sa6_port = (uint16_t) ntohs (sa6.sin6_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa6_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa6_port;\n          domain = PF_INET6;\n          *pflags |= ((enum MHD_FLAG) MHD_USE_IPv6);\n        }\n        break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n#endif /* AF_UNIX */\n      default:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n        if (0 == addrlen)\n          addrlen = sa_len;\n        else if ((0 != sa_len) && (sa_len < addrlen))\n          addrlen = sa_len; /* Use smaller value for safety */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n        if (0 >= addrlen)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"The 'sa_family' of the 'struct sockaddr' provided \" \\\n                       \"via MHD_OPTION_SOCK_ADDR option is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n          goto free_and_fail;\n        }\n#ifdef AF_UNIX\n        if (AF_UNIX == pservaddr->sa_family)\n        {\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n#ifdef PF_UNIX\n          domain = PF_UNIX;\n#else /* ! PF_UNIX */\n          domain = AF_UNIX;\n#endif /* ! PF_UNIX */\n        }\n        else /* combined with the next 'if' */\n#endif /* AF_UNIX */\n        if (1)\n        {\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          /* Assumed the same values for AF_* and PF_* */\n          domain = pservaddr->sa_family;\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (! use_ipv6)\n      {\n        memset (&servaddr4,\n                0,\n                sizeof (struct sockaddr_in));\n        servaddr4.sin_family = AF_INET;\n        servaddr4.sin_port = htons (port);\n        if (0 != INADDR_ANY)\n          servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n        servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr4;\n        addrlen = (socklen_t) sizeof(servaddr4);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET;\n      }\n#ifdef HAVE_INET6\n      else\n      {\n#ifdef IN6ADDR_ANY_INIT\n        static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n        memset (&servaddr6,\n                0,\n                sizeof (struct sockaddr_in6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n        servaddr6.sin6_addr = static_in6any;\n#endif\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n        servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr6;\n        addrlen = (socklen_t) sizeof (servaddr6);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET6;\n      }\n#endif /* HAVE_INET6 */\n    }\n\n    listen_fd = MHD_socket_create_listen_ (domain);\n    if (MHD_INVALID_SOCKET == listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create socket for listening: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n\n    /* Apply the socket options according to listening_address_reuse. */\n    if (0 == daemon->listening_address_reuse)\n    {\n#ifndef MHD_WINSOCK_SOCKETS\n      /* No user requirement, use \"traditional\" default SO_REUSEADDR\n       * on non-W32 platforms, and do not fail if it doesn't work.\n       * Don't use it on W32, because on W32 it will allow multiple\n       * bind to the same address:port, like SO_REUSEPORT on others. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n    }\n    else if (daemon->listening_address_reuse > 0)\n    {\n      /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n      /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n       * it doesn't work. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n      /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n       * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n       */\n      /* SO_REUSEADDR on W32 has the same semantics\n         as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                          SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                          SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n      /* we're supposed to allow address:port re-use, but\n         on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot allow listening address reuse: \" \\\n                   \"SO_REUSEPORT not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n    }\n    else   /* if (daemon->listening_address_reuse < 0) */\n    {\n      /* User requested to disallow reusing listening address:port.\n       * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n       * is used and Solaris with SO_EXCLBIND.\n       * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n       * or setsockopt fails.\n       */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n      (defined(__sun) && defined(SO_EXCLBIND))\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                          SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                          SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot disallow listening address reuse: \" \\\n                   \"SO_EXCLUSIVEADDRUSE not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n\n    /* check for user supplied sockaddr */\n    daemon->listen_fd = listen_fd;\n\n    if (0 != (*pflags & MHD_USE_IPv6))\n    {\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n      /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n         (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n         and may also be missing on older POSIX systems; good luck if you have any of those,\n         your IPv6 socket may then also bind against IPv4 anyway... */\n      const MHD_SCKT_OPT_BOOL_ v6_only =\n        (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n      if (0 > setsockopt (listen_fd,\n                          IPPROTO_IPV6, IPV6_V6ONLY,\n                          (const void *) &v6_only,\n                          sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n    }\n    if (0 != bind (listen_fd, pservaddr, addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to bind to port %u: %s\\n\"),\n                (unsigned int) port,\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n#ifdef TCP_FASTOPEN\n    if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    {\n      if (0 == daemon->fastopen_queue_size)\n        daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n      if (0 != setsockopt (listen_fd,\n                           IPPROTO_TCP,\n                           TCP_FASTOPEN,\n                           (const void *) &daemon->fastopen_queue_size,\n                           sizeof (daemon->fastopen_queue_size)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n    }\n#endif\n    if (0 != listen (listen_fd,\n                     (int) daemon->listen_backlog_size))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to listen for connections: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n  }\n  else\n  {\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) daemon->listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      goto free_and_fail;\n    }\n    else\n    {\n#if defined(SOL_SOCKET) && (defined(SO_DOMAIN) || defined(SO_PROTOCOL_INFOW))\n      int af;\n      int opt_name;\n      void *poptval;\n      socklen_t optval_size;\n#ifdef SO_DOMAIN\n      opt_name = SO_DOMAIN;\n      poptval = &af;\n      optval_size = (socklen_t) sizeof (af);\n#else  /* SO_PROTOCOL_INFOW */\n      WSAPROTOCOL_INFOW prot_info;\n      opt_name = SO_PROTOCOL_INFOW;\n      poptval = &prot_info;\n      optval_size = (socklen_t) sizeof (prot_info);\n#endif /* SO_PROTOCOL_INFOW */\n\n      if (0 == getsockopt (daemon->listen_fd,\n                           SOL_SOCKET,\n                           opt_name,\n                           poptval,\n                           &optval_size))\n      {\n#ifndef SO_DOMAIN\n        af = prot_info.iAddressFamily;\n#endif /* SO_DOMAIN */\n        switch (af)\n        {\n        case AF_INET:\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#ifdef HAVE_INET6\n        case AF_INET6:\n          *pflags |= MHD_USE_IPv6;\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n        case AF_UNIX:\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n          break;\n#endif /* AF_UNIX */\n        default:\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          break;\n        }\n      }\n      else\n#endif /* SOL_SOCKET && (SO_DOMAIN || SO_PROTOCOL_INFOW)) */\n      daemon->listen_is_unix = _MHD_UNKNOWN;\n    }\n\n    listen_fd = daemon->listen_fd;\n#ifdef MHD_USE_GETSOCKNAME\n    daemon->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n  }\n\n#ifdef MHD_USE_GETSOCKNAME\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) &&\n       (_MHD_YES != daemon->listen_is_unix) )\n  {   /* Get port number. */\n    struct sockaddr_storage bindaddr;\n\n    memset (&bindaddr,\n            0,\n            sizeof (struct sockaddr_storage));\n    addrlen = sizeof (struct sockaddr_storage);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n    bindaddr.ss_len = (socklen_t) addrlen;\n#endif\n    if (0 != getsockname (listen_fd,\n                          (struct sockaddr *) &bindaddr,\n                          &addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef MHD_POSIX_SOCKETS\n    else if (sizeof (bindaddr) < addrlen)\n    {\n      /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number \" \\\n                   \"(`struct sockaddr_storage` too small!?).\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifndef __linux__\n    else if (0 == addrlen)\n    {\n      /* Many non-Linux-based platforms return zero addrlen\n       * for AF_UNIX sockets */\n      daemon->port = 0;     /* special value for UNIX domain sockets */\n      if (_MHD_UNKNOWN == daemon->listen_is_unix)\n        daemon->listen_is_unix = _MHD_YES;\n    }\n#endif /* __linux__ */\n#endif /* MHD_POSIX_SOCKETS */\n    else\n    {\n      switch (bindaddr.ss_family)\n      {\n      case AF_INET:\n        {\n          struct sockaddr_in *s4 = (struct sockaddr_in *) &bindaddr;\n\n          daemon->port = ntohs (s4->sin_port);\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n        }\n#ifdef HAVE_INET6\n      case AF_INET6:\n        {\n          struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &bindaddr;\n\n          daemon->port = ntohs (s6->sin6_port);\n          daemon->listen_is_unix = _MHD_NO;\n          mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n          break;\n        }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n        daemon->port = 0;     /* special value for UNIX domain sockets */\n        daemon->listen_is_unix = _MHD_YES;\n        break;\n#endif\n      default:\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Listen socket has unknown address family!\\n\"));\n#endif\n        daemon->port = 0;     /* ugh */\n        daemon->listen_is_unix = _MHD_UNKNOWN;\n        break;\n      }\n    }\n  }\n#endif /* MHD_USE_GETSOCKNAME */\n\n  if (MHD_INVALID_SOCKET != listen_fd)\n  {\n    mhd_assert (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    if (! MHD_socket_nonblocking_ (listen_fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          || (daemon->worker_pool_size > 0)\n#endif\n          )\n      {\n        /* Accept must be non-blocking. Multiple children may wake up\n         * to handle a new connection, but only one will win the race.\n         * The others must immediately return. */\n        MHD_socket_close_chk_ (listen_fd);\n        listen_fd = MHD_INVALID_SOCKET;\n        goto free_and_fail;\n      }\n      daemon->listen_nonblk = false;\n    }\n    else\n      daemon->listen_nonblk = true;\n  }\n  else\n  {\n    mhd_assert (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    daemon->listen_nonblk = false; /* Actually listen socket does not exist */\n  }\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      && (0 == daemon->worker_pool_size)\n#endif\n      )\n  {\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Combining MHD_USE_THREAD_PER_CONNECTION and \" \\\n                   \"MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_NO == setup_epoll_to_listen (daemon))\n      goto free_and_fail;\n  }\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize IP connection limit mutex.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    goto free_and_fail;\n  }\n#endif\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialize TLS support.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    goto free_and_fail;\n  }\n#endif /* HTTPS_SUPPORT */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Start threads if requested by parameters */\n  if (MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    /* Internal thread (or threads) is used.\n     * Make sure that MHD will be able to communicate with threads. */\n    /* If using a thread pool ITC will be initialised later\n     * for each individual worker thread. */\n#ifdef HAVE_LISTEN_SHUTDOWN\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)) || \\\n                (MHD_INVALID_SOCKET != daemon->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n    if (0 == daemon->worker_pool_size)\n    {\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_create_named_thread_ (&daemon->tid,\n                                      MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) ?\n                                      \"MHD-listen\" : \"MHD-single\",\n                                      daemon->thread_stack_size,\n                                      &MHD_polling_thread,\n                                      daemon) )\n      {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n        if (EAGAIN == errno)\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a new thread because it would have \" \\\n                       \"exceeded the system limit on the number of threads or \" \\\n                       \"no system resources available.\\n\"));\n        else\n#endif /* EAGAIN */\n        MHD_DLOG (daemon,\n                  _ (\"Failed to create listen thread: %s\\n\"),\n                  MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n        MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n    }\n    else   /* 0 < daemon->worker_pool_size */\n    {\n      /* Coarse-grained count of connections per thread (note error\n       * due to integer division). Also keep track of how many\n       * connections are leftover after an equal split. */\n      unsigned int conns_per_thread = daemon->connection_limit\n                                      / daemon->worker_pool_size;\n      unsigned int leftover_conns = daemon->connection_limit\n                                    % daemon->worker_pool_size;\n\n      mhd_assert (2 <= daemon->worker_pool_size);\n      i = 0;     /* we need this in case fcntl or malloc fails */\n\n      /* Allocate memory for pooled objects */\n      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                    * daemon->worker_pool_size);\n      if (NULL == daemon->worker_pool)\n        goto thread_failed;\n\n      /* Start the workers in the pool */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n      {\n        /* Create copy of the Daemon object for each worker */\n        struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n        memcpy (d, daemon, sizeof (struct MHD_Daemon));\n        /* Adjust polling params for worker daemons; note that memcpy()\n           has already copied MHD_USE_INTERNAL_POLLING_THREAD thread mode into\n           the worker threads. */\n        d->master = daemon;\n        d->worker_pool_size = 0;\n        d->worker_pool = NULL;\n        if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n          goto thread_failed;\n        }\n        if (! MHD_mutex_init_ (&d->new_connections_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise mutex.\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n        if (0 != (*pflags & MHD_USE_ITC))\n        {\n          if (! MHD_itc_init_ (d->itc))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create worker inter-thread \" \\\n                         \"communication channel: %s\\n\"),\n                      MHD_itc_last_strerror_ () );\n#endif\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n          if (MHD_D_IS_USING_SELECT_ (d) &&\n              (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (d->itc), daemon)) )\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"File descriptor for worker inter-thread \" \\\n                         \"communication channel exceeds maximum value.\\n\"));\n#endif\n            MHD_itc_destroy_chk_ (d->itc);\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n        }\n        else\n          MHD_itc_set_invalid_ (d->itc);\n\n#ifdef HAVE_LISTEN_SHUTDOWN\n        mhd_assert ((MHD_ITC_IS_VALID_ (d->itc)) || \\\n                    (MHD_INVALID_SOCKET != d->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (MHD_ITC_IS_VALID_ (d->itc));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n\n        /* Divide available connections evenly amongst the threads.\n         * Thread indexes in [0, leftover_conns) each get one of the\n         * leftover connections. */\n        d->connection_limit = conns_per_thread;\n        if (i < leftover_conns)\n          ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (d) &&\n            (MHD_NO == setup_epoll_to_listen (d)) )\n        {\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n#endif\n        /* Some members must be used only in master daemon */\n#if defined(MHD_USE_THREADS)\n        memset (&d->per_ip_connection_mutex, 0x7F,\n                sizeof(d->per_ip_connection_mutex));\n#endif /* MHD_USE_THREADS */\n#ifdef DAUTH_SUPPORT\n        d->nnc = NULL;\n        d->nonce_nc_size = 0;\n        d->digest_auth_random_copy = NULL;\n#if defined(MHD_USE_THREADS)\n        memset (&d->nnc_lock, 0x7F, sizeof(d->nnc_lock));\n#endif /* MHD_USE_THREADS */\n#endif /* DAUTH_SUPPORT */\n\n        /* Spawn the worker thread */\n        if (! MHD_create_named_thread_ (&d->tid,\n                                        \"MHD-worker\",\n                                        daemon->thread_stack_size,\n                                        &MHD_polling_thread,\n                                        d))\n        {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == errno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new pool thread because it would \" \\\n                         \"have exceeded the system limit on the number of \" \\\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create pool thread: %s\\n\"),\n                    MHD_strerror_ (errno));\n#endif\n          /* Free memory for this worker; cleanup below handles\n           * all previously-created workers. */\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n      }\n    }\n  }\n  else\n  { /* Daemon without internal threads */\n    if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n    if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  }\n#endif\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif\n\nfree_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        (int) FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The fragment is inside a preprocessor #elif defined(MHD_WINSOCK_SOCKETS) branch. In the supplied project configuration MHD_POSIX_SOCKETS is defined so this branch is not compiled, but that only makes it unreachable in that build \u2014 it is not executed. MISRA 2.2 defines dead code as operations that are executed yet removable without changing behaviour; unreachable or conditionally compiled code is not dead code. This Windows-specific code will be compiled and executed in a build where MHD_WINSOCK_SOCKETS is defined, so it is not dead code in the project as a whole."
}