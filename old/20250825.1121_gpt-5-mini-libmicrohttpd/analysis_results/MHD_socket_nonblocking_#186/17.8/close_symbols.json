{
  "user_message": "Target function code is:\n```c\nint\nMHD_socket_nonblocking_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFL);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | O_NONBLOCK) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFL,\n                    flags | O_NONBLOCK)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        (int) FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_nonblocking_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_start_daemon_va']}, 'MHD_add_connection': {'callees': ['MHD_cleanup_connections', 'MHD_DLOG', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection', '__builtin_unreachable'], 'callers': []}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket",
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "fcntl (prototype)",
    "F_GETFL",
    "F_SETFL",
    "O_NONBLOCK",
    "ioctlsocket (prototype)",
    "FIONBIO"
  ],
  "explanation": "- MHD_socket: the typedef/definition of the parameter type is needed to know whether `sock` is a scalar passed by value (e.g. int, SOCKET) or a pointer/type that could be modified indirectly. If it is a scalar passed by value, passing it to other functions cannot modify the parameter variable itself; if it were a pointer, the pointed object could be modified (allowed) but the pointer itself must not be assigned to.\n\n- MHD_POSIX_SOCKETS and MHD_WINSOCK_SOCKETS: these conditional-compilation macros determine which branch of the function is compiled. To judge whether the parameter is modified in the compiled code you must know which branch is active.\n\n- fcntl (prototype): the function signature (e.g. int fcntl(int fd, int cmd, ...)) is required to confirm that `sock` is passed by value (an integer file descriptor) and not by reference or via a macro expansion that could assign to `sock`.\n\n- F_GETFL, F_SETFL, O_NONBLOCK: these macros/constants are needed to ensure they are simple integer constants (flags) and do not expand to code that could modify `sock` (they should not, but the check is necessary for MISRA analysis).\n\n- ioctlsocket (prototype): the Winsock prototype (e.g. int ioctlsocket(SOCKET s, long cmd, u_long *argp)) is needed to confirm `sock` is passed by value and not modified by the call (only the pointed-to argument can be modified).\n\n- FIONBIO: the constant passed to ioctlsocket must be known to be a constant and not a macro that could hide side effects that modify `sock`.\n\nTogether these symbols let an analyst determine (1) which code is actually compiled, (2) the type/passing mechanism of the parameter, and (3) whether any called functions or macros could modify the parameter variable itself (a MISRA violation) rather than merely operating on the object it names (which is allowed)."
}