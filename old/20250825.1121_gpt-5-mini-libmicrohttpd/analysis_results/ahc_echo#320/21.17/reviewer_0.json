{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                  /* reset when done */\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                80,\n                                                &data_generator, NULL, NULL);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call strcmp(method, \"GET\") is made without checking that 'method' is a valid non-NULL, NUL-terminated string. If the caller supplies method == NULL (or a non NUL-terminated buffer), strcmp will dereference the pointer and read beyond the object bounds, causing undefined behaviour.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_echo:\nstatic enum MHD_Result\nanswer_to_connection (void *cls,\n                      struct MHD_Connection *connection,\n                      const char *url,\n                      const char *method,\n                      const char *version,\n                      const char *upload_data,\n                      size_t *upload_data_size,\n                      void **req_cls)\n{\n  const char *page = \"<html><body>Hello timeout!</body></html>\";\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n  (void) req_cls;           /* Unused. Silent compiler warning. */\n\n  response = MHD_create_response_from_buffer_static (strlen (page),\n                                                     (const void *) page);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               \"text/html\"))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef WINDOWS\n#ifdef HAVE_POLL\n  unsigned int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = MHD_D_IS_USING_POLL_ (daemon);\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(con->tid));\n\n  while ( (! daemon->shutdown) &&\n          (MHD_CONNECTION_CLOSED != con->state) )\n  {\n    bool use_zero_timeout;\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n    if ( (con->suspended) &&\n         (NULL == urh) )\n    {\n      /* Connection was suspended, wait for resume. */\n      was_suspended = true;\n      if (! use_poll)\n      {\n        FD_ZERO (&rs);\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  NULL,\n                                  FD_SETSIZE))\n        {\n  #ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Failed to add FD to fd_set.\\n\"));\n  #endif\n          goto exit;\n        }\n        if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                 &rs,\n                                 NULL,\n                                 NULL,\n                                 NULL))\n        {\n          const int err = MHD_socket_get_error_ ();\n\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during select (%d): `%s'\\n\"),\n                    err,\n                    MHD_socket_strerr_ (err));\n#endif\n          break;\n        }\n      }\n#ifdef HAVE_POLL\n      else     /* use_poll */\n      {\n        p[0].events = POLLIN;\n        p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[0].revents = 0;\n        if (0 > MHD_sys_poll_ (p,\n                               1,\n                               -1))\n        {\n          if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n            continue;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (con->daemon,\n                    _ (\"Error during poll: `%s'\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          break;\n        }\n      }\n#endif /* HAVE_POLL */\n      MHD_itc_clear_ (daemon->itc);\n      continue; /* Check again for resume. */\n    }           /* End of \"suspended\" branch. */\n\n    if (was_suspended)\n    {\n      MHD_update_last_activity_ (con);     /* Reset timeout timer. */\n      /* Process response queued during suspend and update states. */\n      MHD_connection_handle_idle (con);\n      was_suspended = false;\n    }\n\n    use_zero_timeout =\n      (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n       || ( (con->tls_read_ready) &&\n            (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n#endif /* HTTPS_SUPPORT */\n      );\n    if (! use_poll)\n    {\n      /* use select */\n      bool err_state = false;\n      struct timeval tv;\n      struct timeval *tvp;\n      if (use_zero_timeout)\n      {\n        tv.tv_sec = 0;\n        tv.tv_usec = 0;\n        tvp = &tv;\n      }\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC\n        if (mseconds_left / 1000 > TIMEVAL_TV_SEC_MAX)\n          tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n        else\n#endif /* (SIZEOF_UINT64_T - 2) >= SIZEOF_STRUCT_TIMEVAL_TV_SEC */\n        tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) mseconds_left / 1000;\n\n        tv.tv_usec = ((uint16_t) (mseconds_left % 1000)) * ((int32_t) 1000);\n        tvp = &tv;\n      }\n      else\n        tvp = NULL;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      maxsock = MHD_INVALID_SOCKET;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &ws,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                  &es,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = true;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      if (MHD_ITC_IS_VALID_ (daemon->itc) )\n      {\n        if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE))\n          err_state = 1;\n      }\n#endif\n      if (err_state)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Failed to add FD to fd_set.\\n\"));\n#endif\n        goto exit;\n      }\n\n      num_ready = MHD_SYS_select_ (maxsock + 1,\n                                   &rs,\n                                   &ws,\n                                   &es,\n                                   tvp);\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger select() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                      &rs)) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         FD_ISSET (con->socket_fd,\n                                   &rs),\n                         FD_ISSET (con->socket_fd,\n                                   &ws),\n                         FD_ISSET (con->socket_fd,\n                                   &es)) )\n        goto exit;\n    }\n#ifdef HAVE_POLL\n    else\n    {\n      int timeout_val;\n      /* use poll */\n      if (use_zero_timeout)\n        timeout_val = 0;\n      else if (con->connection_timeout_ms > 0)\n      {\n        const uint64_t mseconds_left = connection_get_wait (con);\n#if SIZEOF_UINT64_T >= SIZEOF_INT\n        if (mseconds_left >= INT_MAX)\n          timeout_val = INT_MAX;\n        else\n#endif /* SIZEOF_UINT64_T >= SIZEOF_INT */\n        timeout_val = (int) mseconds_left;\n      }\n      else\n        timeout_val = -1;\n      memset (&p,\n              0,\n              sizeof (p));\n      p[0].fd = con->socket_fd;\n      switch (con->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        /* how did we get here!? */\n        goto exit;\n      }\n#ifdef WINDOWS\n      extra_slot = 0;\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        p[1].events |= POLLIN;\n        p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n        p[1].revents = 0;\n        extra_slot = 1;\n      }\n#endif\n      if (MHD_sys_poll_ (p,\n#ifdef WINDOWS\n                         1 + extra_slot,\n#else\n                         1,\n#endif\n                         timeout_val) < 0)\n      {\n        if (MHD_SCKT_LAST_ERR_IS_ (MHD_SCKT_EINTR_))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        break;\n      }\n#ifdef WINDOWS\n      /* Clear ITC before other processing so additional\n       * signals will trigger poll() again */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n        MHD_itc_clear_ (daemon->itc);\n#endif\n      if (MHD_NO ==\n          call_handlers (con,\n                         (0 != (p[0].revents & POLLIN)),\n                         (0 != (p[0].revents & POLLOUT)),\n                         (0 != (p[0].revents & MHD_POLL_REVENTS_ERR_DISC)) ))\n        goto exit;\n    }\n#endif\n#ifdef UPGRADE_SUPPORT\n    if (MHD_CONNECTION_UPGRADE == con->state)\n    {\n      /* Normal HTTP processing is finished,\n       * notify application. */\n      if ( (NULL != daemon->notify_completed) &&\n           (con->rq.client_aware) )\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  con,\n                                  &con->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      con->rq.client_aware = false;\n\n      thread_main_connection_upgrade (con);\n      /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n      /* \"Upgraded\" data will not be used in this thread from this point. */\n      con->urh->clean_ready = true;\n      /* If 'urh->was_closed' set to true, connection will be\n       * moved immediately to cleanup list. Otherwise connection\n       * will stay in suspended list until 'urh' will be marked\n       * with 'was_closed' by application. */\n      MHD_resume_connection (con);\n\n      /* skip usual clean up  */\n      return (MHD_THRD_RTRN_TYPE_) 0;\n    }\n#endif /* UPGRADE_SUPPORT */\n  }\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (con->daemon,\n            _ (\"Processing thread terminating. Closing connection.\\n\"));\n#endif\n#endif\n  if (MHD_CONNECTION_CLOSED != con->state)\n    MHD_connection_close_ (con,\n                           (daemon->shutdown) ?\n                           MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN :\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n  MHD_connection_handle_idle (con);\nexit:\n  if (NULL != con->rp.response)\n  {\n    MHD_destroy_response (con->rp.response);\n    con->rp.response = NULL;\n  }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n  {\n    shutdown (con->socket_fd,\n              SHUT_WR);\n    /* 'socket_fd' can be used in other thread to signal shutdown.\n     * To avoid data races, do not close socket here. Daemon will\n     * use more connections only after cleanup anyway. */\n  }\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"t\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal thread termination via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n...\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon (unsigned int flags,\n                  uint16_t port,\n                  MHD_AcceptPolicyCallback apc,\n                  void *apc_cls,\n                  MHD_AccessHandlerCallback dh,\n                  void *dh_cls,\n                  ...)\n{\n  struct MHD_Daemon *daemon;\n  va_list ap;\n\n  va_start (ap,\n            dh_cls);\n  daemon = MHD_start_daemon_va (flags,\n                                port,\n                                apc,\n                                apc_cls,\n                                dh,\n                                dh_cls,\n                                ap);\n  va_end (ap);\n  return daemon;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The call strcmp(method, \"GET\") will read through the characters of *method until it finds a NUL byte and dereferences the pointer. If 'method' were NULL or pointed to a buffer that is not NUL-terminated, this call can read out of bounds (or dereference NULL) and thus would violate MISRA C:2023 Rule 21.17. The ahc_echo implementation does not perform any local check that 'method' is non-NULL and NUL-terminated. Whether this is actually a defect in practice depends on the calling contract: if the surrounding library/API that invokes this callback guarantees that it always supplies a valid, NUL-terminated string for 'method', then the use of strcmp is safe and there is no violation. However, absent an explicit, verifiable precondition in the code or documentation available here, the use of strcmp without a defensive check does not satisfy the MISRA requirement to prevent out\u2011of\u2011bounds accesses. Therefore agent A\u2019s report is correct (unless a documented non\u2011NULL/NUL\u2011terminated precondition is known)."
}