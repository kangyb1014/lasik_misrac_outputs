{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_update_last_activity_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (0 == connection->connection_timeout_ms)\n    return;  /* Skip update of activity for connections\n               without timeout timer. */\n  if (connection->suspended)\n    return;  /* no activity on suspended connections */\n\n  connection->last_activity = MHD_monotonic_msec_counter ();\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    return; /* each connection has personal timeout */\n\n  if (connection->connection_timeout_ms != daemon->connection_timeout_ms)\n    return; /* custom timeout, no need to move it in \"normal\" DLL */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  /* move connection to head of timeout list (by remove + add operation) */\n  XDLL_remove (daemon->normal_timeout_head,\n               daemon->normal_timeout_tail,\n               connection);\n  XDLL_insert (daemon->normal_timeout_head,\n               daemon->normal_timeout_tail,\n               connection);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "XDLL_remove",
    "XDLL_insert",
    "struct MHD_Connection (definition)",
    "struct MHD_Daemon (definition)",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "MHD_mutex_lock_chk_",
    "MHD_mutex_unlock_chk_",
    "MHD_monotonic_msec_counter",
    "mhd_assert"
  ],
  "explanation": "You must confirm that the pointer parameter 'connection' itself is not assigned to or otherwise modified (MISRA: \"A function parameter should not be modified\"). The listed symbols are needed because:\n\n- XDLL_remove: This macro/function is called with the identifier 'connection' as an argument. If XDLL_remove is a macro it might expand to code that assigns to that identifier (e.g. `connection = ...`). Inspecting its definition/signature shows whether the parameter variable itself could be modified.\n\n- XDLL_insert: Same reason as XDLL_remove \u2014 a macro expansion or function signature could reassign the passed identifier; check its definition/signature to ensure it only operates on the object pointed to, not on the local pointer variable.\n\n- struct MHD_Connection (definition): The actual type/definition is needed to verify whether 'connection' is indeed a simple pointer variable, whether any unusual typedefs/macros change its meaning, and to check whether fields accessed (->last_activity, ->connection_timeout_ms, ->suspended, ->daemon) could hide macro expansions that rebind the identifier.\n\n- struct MHD_Daemon (definition): Required to examine types of daemon->normal_timeout_head/tail and cleanup_connection_mutex to see what XDLL_* and mutex macros accept (pointer vs pointer-to-pointer) and to ensure no indirect passing of &connection occurs via those fields or macros.\n\n- MHD_D_IS_USING_THREAD_PER_CONN_: This is used in a control expression; if it is a macro it may expand in a way that references or modifies 'connection' (unlikely but possible). Inspect definition to be sure it does not reassign the parameter identifier.\n\n- MHD_mutex_lock_chk_: This macro/function is invoked with &daemon->cleanup_connection_mutex; if it is a macro it could expand in ways that capture/modify local identifiers. Confirm its definition/signature to ensure it cannot modify the 'connection' parameter variable.\n\n- MHD_mutex_unlock_chk_: Same reason as lock; inspect definition/signature for possible macro side-effects that could alter the local parameter.\n\n- MHD_monotonic_msec_counter: Although this is a simple callee returning a time value, check its prototype to ensure it does not take/modify the 'connection' parameter (it should not) and to rule out unexpected macro expansion that could touch local identifiers.\n\n- mhd_assert: Present under conditional compilation; if defined as a macro it could expand to code that references or (improperly) assigns to local identifiers. Inspect its definition only if MHD_USE_THREADS is enabled.\n\nIn short: focus first on the definitions/signatures of XDLL_remove and XDLL_insert and any macros used in the function (MHD_D_IS_USING_THREAD_PER_CONN_, mutex macros, assertions). Also review the struct definitions to determine the parameter's real type and whether any of the passed/used fields could cause the local pointer variable to be modified by macro expansions or indirect address-taking. Verifying these symbols is sufficient to determine whether the function assigns to the parameter variable 'connection' (a MISRA violation) or only mutates the object it points to (allowed)."
}