{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTPS_SUPPORT",
    "HAVE_POLL",
    "HAVE_MESSAGES",
    "struct MHD_Connection",
    "struct MHD_UpgradeResponseHandle",
    "struct MHD_Daemon",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "mhd_assert",
    "MHD_D_IS_USING_THREADS_",
    "MHD_thread_handle_ID_is_current_thread_",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "MHD_connection_finish_forward_",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_socket_strerr_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_DLOG",
    "fd_set",
    "FD_ZERO",
    "FD_SETSIZE",
    "struct timeval",
    "struct pollfd"
  ],
  "explanation": "To determine whether thread_main_connection_upgrade uses any compiler language extensions we must inspect the definitions of every macro, type and wrapper it uses because such definitions may themselves employ extensions (GNU statement-expressions, typeof, __attribute__, inline assembly, nested functions, non-standard keywords, compiler-specific builtins, etc.). Brief reasons for each symbol:\n\n- HTTPS_SUPPORT, HAVE_POLL, HAVE_MESSAGES: preprocessor conditionals control which code is compiled; their definitions (or absence) determine whether extension-using alternate code paths are present.\n- struct MHD_Connection, struct MHD_UpgradeResponseHandle, struct MHD_Daemon: the structs' field declarations could use extensions (bit-fields with unusual types, unnamed bit-fields, attributes, packed pragmas, flexible-array members in nonstandard ways, or compiler-specific types). Need their full definitions.\n- MHD_socket, MHD_INVALID_SOCKET: typedefs/constants for socket type may map to platform-specific types or macros that use extensions; check their definitions.\n- mhd_assert: assertion macro could expand to compiler-specific constructs (statement expressions, typeof, __builtin_expect, __attribute__); inspect definition.\n- MHD_D_IS_USING_THREADS_, MHD_thread_handle_ID_is_current_thread_: these macros/functions are used in a compound expression with logical operators; their implementations might use extensions or inline asm\u2014need to verify.\n- urh_to_fdset, urh_from_fdset, urh_update_pollfd, urh_from_pollfd, process_urh, MHD_connection_finish_forward_: these functions/macros implement core behavior. Macros in particular may hide extensions (e.g., statement-expressions or typeof). Even functions can be implemented with inline assembly or nonstandard attributes \u2014 inspect their declarations/definitions.\n- MHD_SYS_select_, MHD_sys_poll_: wrappers around system calls; they may be implemented as macros that call platform-specific variants or use compiler extensions. Verify their implementations.\n- MHD_socket_get_error_, MHD_socket_strerr_, MHD_SCKT_ERR_IS_EINTR_: error-handling helpers or macros could use compiler extensions or nonstandard constructs; check their definitions.\n- MHD_DLOG: logging macro often uses variadic macros or statement-expressions; these are language extensions in some compilers (or standard C99 features), so inspect definition to ensure only standard constructs are used.\n- fd_set, FD_ZERO, FD_SETSIZE, struct timeval, struct pollfd: the system types/macros come from platform headers. Although normally standard/POSIX, different platforms or wrapper headers could provide nonstandard implementations or macros that rely on extensions. To be safe, inspect these headers if the MISRA check must ensure no language extensions are used.\n\nIn short: any macro, typedef or function referenced by the target function can hide language extensions in its definition; the listed symbols are the minimal set whose definitions must be checked to conclude whether the target function (as compiled in the project) uses any language extensions."
}