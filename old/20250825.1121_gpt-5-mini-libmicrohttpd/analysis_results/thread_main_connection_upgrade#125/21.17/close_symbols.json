{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "memset",
    "struct pollfd",
    "p (local array: struct pollfd p[2])",
    "sizeof (as used in sizeof(p))",
    "struct MHD_UpgradeResponseHandle and fields: in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection, mhd",
    "urh->connection->socket_fd",
    "urh->mhd.socket",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "FD_SETSIZE",
    "MHD_socket (type) and MHD_INVALID_SOCKET",
    "MHD_SYS_select_",
    "MHD_sys_poll_"
  ],
  "explanation": "For checking MISRA C rule about bounds when using <string.h> functions in this target function you must be able to reason about every site where a string/memory function could operate or where buffer sizes and object sizes determining safe use are computed: \n\n- memset: The target calls memset(p, 0, sizeof(p)). You must inspect the memset usage itself (prototype and semantics) and ensure the size argument matches the actual storage. \n\n- struct pollfd and p (struct pollfd p[2]): sizeof(p) depends on the definition of struct pollfd and the array dimension. To prove memset cannot write out of bounds you need the exact object layout and the fact that p is an array of two pollfd objects. \n\n- sizeof (as used in sizeof(p)): Clarifies what byte count is being passed to memset; combined with struct pollfd and the array size this demonstrates the target object length. \n\n- struct MHD_UpgradeResponseHandle and its fields (in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection, mhd): The control flow (the while loop) and decisions about whether to wait/use zero-timeout depend on these fields. Although these are not string functions, their sizes/values affect whether buffer-manipulating helper functions are invoked and whether any memory operations occur. Knowing their types and ranges is necessary to reason about potential out-of-bounds accesses elsewhere triggered by this function. \n\n- urh->connection->socket_fd and urh->mhd.socket: These are stored into p[].fd before memset/usage; you must ensure these assignments and later poll/select usage do not cause writes beyond p's valid memory or rely on invalid fds. \n\n- urh_to_fdset and urh_from_fdset: These are called with FD_SETSIZE and fd_set pointers; while they are external functions, they prepare/consume fd_sets passed from this function. If those helpers use string.h functions (memcpy/memmove/memset) internally, or assume particular sizes, you must inspect them to ensure they do not access beyond bounds of fd_set or other objects prepared here. \n\n- urh_update_pollfd and urh_from_pollfd: These modify/read the p[] pollfd array. To demonstrate memset(p,0,...) is correct and that subsequent accesses are safe you must inspect these functions' expectations about the array length, indexing, and any memory operations they perform (they might use memcpy/memmove/etc.). \n\n- process_urh: This may modify urh buffers (in/out) and could call string.h functions internally; knowing what it does is required to reason about whether combined behavior leads to out-of-bounds accesses of buffers tracked here. \n\n- FD_SETSIZE: Passed into urh_to_fdset/urh_from_fdset as a size argument; you must know its value to reason about array bounds and any memcpy/memset uses that depend on it. \n\n- MHD_socket (type) and MHD_INVALID_SOCKET: The code compares max_fd to MHD_INVALID_SOCKET and uses max_fd + 1 in select. You need the socket type/representation and INVALID value to ensure select arguments and any fd-set manipulations won't cause buffer overrun in fd_sets. \n\n- MHD_SYS_select_ and MHD_sys_poll_: These system wrappers operate on fd_set / pollfd arrays created/filled here. To show the target function does not itself cause string.h violations you must ensure the fd_set/pollfd arguments passed are appropriately sized/initialized (memset of p and FD_ZERO on fd_sets) and that the semantics/expected sizes of these system calls match the objects supplied.\n\nIn short: memset and the exact target object (p) plus its element type are essential to validate the single direct string.h use in this function. The urh structure, its buffer size fields, and the helper functions that read or write the fd_set/pollfd or urh buffers are required because they determine how memory is used after memset and whether any of the helpers (or later calls) use string.h routines on those objects in a way that could go out of bounds. FD_SETSIZE, MHD_socket and the system-select/poll wrappers are required to verify that fd_set/pollfd sizes and indices are within bounds for later operations."
}