{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_D_IS_USING_THREADS_",
    "MHD_thread_handle_ID_is_current_thread_",
    "MHD_D_IS_USING_SELECT_",
    "MHD_USE_TLS",
    "MHD_DLOG",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "MHD_connection_finish_forward_",
    "struct MHD_Connection",
    "struct MHD_UpgradeResponseHandle",
    "struct MHD_Daemon"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d we must be sure the parameter variable 'con' is never assigned to inside thread_main_connection_upgrade \u2014 including via any macro expansions that inline code. The listed symbols are those referenced in the function whose definitions could affect that determination: \n\n- mhd_assert: a macro \u2014 its expansion might contain statements that assign to identifiers; need its definition to ensure it does not modify the local parameter variable 'con'.\n- MHD_D_IS_USING_THREADS_: macro \u2014 could expand to expressions or statements; verify it does not modify 'con'.\n- MHD_thread_handle_ID_is_current_thread_: function/macro \u2014 used in the assert expression; if a macro, its expansion might modify identifiers; check definition.\n- MHD_D_IS_USING_SELECT_: macro \u2014 used in control flow; if a macro with side effects it could modify local names; need to confirm.\n- MHD_USE_TLS: compile-time option / macro \u2014 needed to understand which branches are compiled and whether any macro-based code that could modify 'con' is present.\n- MHD_DLOG: logging macro \u2014 often a macro that can expand to complex code; must ensure it does not perform an assignment to 'con'.\n- urh_to_fdset, urh_from_fdset, urh_update_pollfd, urh_from_pollfd: these are functions or macros that are invoked in the body; if any is implemented as a macro they could expand to code that assigns to 'con' (or reuse the identifier 'con'); need their definitions.\n- process_urh: called routine or macro \u2014 if a macro with inline statements it could reassign 'con'; verify.\n- MHD_SYS_select_, MHD_sys_poll_: platform wrappers (macros or inline functions) around select/poll \u2014 need their definitions in case they are macros introducing assignments.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: macros/functions used in error handling; if any is a macro expanding to statements, check they do not modify 'con'.\n- MHD_connection_finish_forward_: called at the end \u2014 if implemented as a macro it might reassign the local parameter variable; confirm actual implementation (function vs macro).\n- struct MHD_Connection, struct MHD_UpgradeResponseHandle, struct MHD_Daemon: the type/field definitions are required to confirm whether any of the field accesses (con->urh, con->daemon, con->tid, con->tls_read_ready) are actually macroed lvalues or accessors that could hide assignments to the parameter variable. Also needed to confirm that operations visible in this function are only reads of the parameter pointer (or permitted mutations of the pointed-to object) rather than reassignments of the parameter itself.\n\nIn short: obtain the definitions of these macros, inline functions and the relevant struct/type declarations so you can prove no macro expansion or inline code within these symbols assigns to the parameter variable 'con' inside thread_main_connection_upgrade."
}