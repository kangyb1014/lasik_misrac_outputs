{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nFunctions shall not call themselves, either directly or indirectly. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "urh_to_fdset",
    "urh_from_fdset",
    "process_urh",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "MHD_connection_finish_forward_",
    "MHD_thread_handle_ID_is_current_thread_",
    "MHD_D_IS_USING_THREADS_",
    "MHD_D_IS_USING_SELECT_",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "MHD_DLOG",
    "thread_main_handle_connection",
    "MHD_add_to_fd_set_",
    "MHD_update_last_activity_",
    "MHD_connection_handle_idle",
    "connection_get_wait",
    "call_handlers",
    "MHD_resume_connection",
    "MHD_connection_close_",
    "MHD_destroy_response"
  ],
  "explanation": "To determine whether thread_main_connection_upgrade participates in direct or indirect recursion you must inspect the transitive call graph reachable from it and from callers that already call it. Each listed symbol either is called directly by thread_main_connection_upgrade (so its callees could lead back to the target) or is a caller/related callee of thread_main_handle_connection (which already calls the target). For each symbol: \n- urh_to_fdset, urh_from_fdset, process_urh, urh_update_pollfd, urh_from_pollfd, MHD_connection_finish_forward_: called directly by the target; their bodies may invoke other functions that could (directly or indirectly) call thread_main_connection_upgrade. \n- MHD_thread_handle_ID_is_current_thread_, MHD_D_IS_USING_THREADS_, MHD_D_IS_USING_SELECT_, MHD_SYS_select_, MHD_sys_poll_, MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_, MHD_DLOG: runtime/utility functions called by the target (or used in its control flow). Their implementations may call other functions that could create a cycle, so they must be inspected. \n- thread_main_handle_connection: explicit caller of thread_main_connection_upgrade (present in the static graph). To rule out indirect recursion we must inspect this function and everything it calls. \n- MHD_add_to_fd_set_, MHD_update_last_activity_, MHD_connection_handle_idle, connection_get_wait, call_handlers, MHD_resume_connection, MHD_connection_close_, MHD_destroy_response: callees of thread_main_handle_connection; any of these (or functions they call, e.g., call_handlers) might call back into thread_main_connection_upgrade, forming an indirect recursion. \nIn short: obtain the full definitions/call targets (the transitive call graph) of every symbol above to prove whether any path leads back to thread_main_connection_upgrade (which would violate the MISRA rule)."
}