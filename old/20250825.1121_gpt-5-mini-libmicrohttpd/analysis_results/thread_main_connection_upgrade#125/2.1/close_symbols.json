{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTPS_SUPPORT",
    "HAVE_POLL",
    "HAVE_MESSAGES",
    "MHD_USE_TLS",
    "MHD_D_IS_USING_SELECT_",
    "MHD_D_IS_USING_THREADS_",
    "MHD_thread_handle_ID_is_current_thread_",
    "struct MHD_Connection (fields: urh, daemon, tid, tls_read_ready)",
    "struct MHD_UpgradeResponseHandle (fields: in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection, mhd)",
    "struct MHD_Daemon (fields: options, shutdown)",
    "MHD_INVALID_SOCKET",
    "FD_SETSIZE",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "MHD_DLOG",
    "MHD_connection_finish_forward_"
  ],
  "explanation": "To decide whether any portion of thread_main_connection_upgrade is statically or effectively unreachable you must know which compile-time branches exist, which runtime guards can be true, and which called routines/fields can change control flow or loop termination. Brief reasons: \n\n- HTTPS_SUPPORT: controls inclusion of almost the entire body; if undefined the large blocks are compile-time removed (clear unreachable code otherwise).\n- HAVE_POLL: controls presence of the poll-based branch; affects whether that entire else-if block is compiled (reachability).\n- HAVE_MESSAGES: controls logging blocks under #ifdef; needed to determine whether those log statements are compiled (reachability of those statements).\n- MHD_USE_TLS: daemon->options & MHD_USE_TLS gates both select/poll branches; its value (compile-time constant bitmask definition) is needed to see if those branches can ever be taken.\n- MHD_D_IS_USING_SELECT_: macro/function selects the select-based path; its definition/semantics determines which branch is reachable.\n- MHD_D_IS_USING_THREADS_: used in the assertion; its definition (and whether assertions are active) can affect whether assertion code exists (unreachable or not).\n- MHD_thread_handle_ID_is_current_thread_: used in the assert condition; inclusion/semantics matter for whether the assert can create unreachable code in builds where asserts have side effects.\n- struct MHD_Connection (urh, daemon, tid, tls_read_ready): the function reads these fields to decide flow (which branches to enter, whether to short-circuit select/poll wait). Their types/values affect runtime reachability.\n- struct MHD_UpgradeResponseHandle (in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection, mhd): the while-loop condition and fd/poll setup depend on these fields; their possible values determine whether the loop body is ever entered or can be left (unreachable code after loop).\n- struct MHD_Daemon (options, shutdown): options influences TLS/branch selection; shutdown is checked to force zero timeout \u2014 affects whether waiting or loop iterations occur.\n- MHD_INVALID_SOCKET: compared with max_fd to decide if select() should be called; if always equal or never equal that changes reachability of the enclosed select code.\n- FD_SETSIZE: passed to urh_to_fdset/urh_from_fdset and used in casts; its value can affect urh_to_fdset behavior and thus whether particular code is reachable.\n- urh_to_fdset: returns boolean and sets max_fd; its semantics determine whether select/poll branches proceed, whether max_fd can be MHD_INVALID_SOCKET and thus whether inner select path executes.\n- urh_from_fdset: counterpart that is invoked after select; needed to understand side effects and whether subsequent process_urh call can be reached/affect loop termination.\n- urh_update_pollfd / urh_from_pollfd: similar for poll path \u2014 needed to reason about whether the poll path is reachable and can change urh state.\n- process_urh: called each loop iteration; it may change urh buffer counters so is essential to determine whether the while-loop can terminate (reach code after the loop).\n- MHD_SYS_select_ / MHD_sys_poll_: their return semantics (and whether they are available/compiled) affect error handling, continue/break behavior and thus reachability of downstream code.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: used in error-path handling after select/poll; their semantics determine whether error branches cause continue or break (affects reachability of remaining loop and trailing code).\n- MHD_DLOG: logging calls inside error branches \u2014 include to decide whether those blocks are compiled (HAVE_MESSAGES) and thus reachable.\n- MHD_connection_finish_forward_: function called at the end; whether control can reach this call depends on the loop/branch behavior, so its presence is relevant to determine if this call is reachable.\n\nIn short: to determine unreachable code you must know (a) which #ifdef/#else branches are compiled (HTTPS_SUPPORT, HAVE_POLL, HAVE_MESSAGES), (b) which branch-selection macros and daemon->options values can be true at runtime (MHD_USE_TLS, MHD_D_IS_USING_SELECT_), (c) the structure fields read/updated inside the loop which govern loop entrance/exit (fields in MHD_Connection, MHD_UpgradeResponseHandle, MHD_Daemon), and (d) the behavior/semantics of helper functions that set fd/poll state and mutate urh (urh_to_fdset, urh_from_fdset, urh_update_pollfd, urh_from_pollfd, process_urh) and system wrappers/error helpers (MHD_SYS_select_, MHD_sys_poll_, MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_). Without these symbols you cannot soundly claim any part of the function is unreachable under MISRA C."
}