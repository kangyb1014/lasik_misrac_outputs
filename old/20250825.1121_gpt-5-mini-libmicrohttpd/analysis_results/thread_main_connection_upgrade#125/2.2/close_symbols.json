{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTPS_SUPPORT",
    "HAVE_POLL",
    "MHD_USE_TLS",
    "MHD_D_IS_USING_SELECT_",
    "MHD_D_IS_USING_THREADS_",
    "MHD_thread_handle_ID_is_current_thread_",
    "struct MHD_Connection::urh",
    "struct MHD_Connection::daemon",
    "struct MHD_Connection::tls_read_ready",
    "struct MHD_Connection::tid",
    "struct MHD_Daemon::options",
    "struct MHD_Daemon::shutdown",
    "struct MHD_UpgradeResponseHandle::in_buffer_size",
    "struct MHD_UpgradeResponseHandle::out_buffer_size",
    "struct MHD_UpgradeResponseHandle::in_buffer_used",
    "struct MHD_UpgradeResponseHandle::out_buffer_used",
    "struct MHD_UpgradeResponseHandle::connection->socket_fd",
    "struct MHD_UpgradeResponseHandle::mhd.socket",
    "MHD_INVALID_SOCKET",
    "FD_SETSIZE",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_socket_strerr_",
    "MHD_DLOG",
    "MHD_connection_finish_forward_"
  ],
  "explanation": "For deciding whether any statements in thread_main_connection_upgrade are dead (i.e. can be removed without changing program behavior) you must know both compile-time inclusion and the runtime conditions and side-effects that control execution. The listed symbols are the minimal set whose definitions/semantics affect whether the large TLS/select/poll blocks execute or have observable effects:\n\n- HTTPS_SUPPORT (compile-time): if undefined the entire TLS forwarding region is not compiled; that would make most of the function body effectively absent (dead code). Must know to determine compile-time deadness.\n- HAVE_POLL (compile-time): selects whether the poll() branch is compiled; needed to know which code paths exist.\n- MHD_USE_TLS (flag): daemon->options & MHD_USE_TLS gates whether TLS-specific forwarding runs. If the flag is never set, the TLS code may be dead.\n- MHD_D_IS_USING_SELECT_ (macro/function): runtime predicate selecting select() vs other IO model; determines which branch executes and whether select-specific code is live.\n- MHD_D_IS_USING_THREADS_ and MHD_thread_handle_ID_is_current_thread_ : used only in the assertion, but the threading mode predicate may affect whether the assertion is meaningful; include because threading model can affect whether preceding code is relevant for dead-code reasoning (and whether assertion removal would change behavior in debug builds).\n\nConnection and daemon fields (struct MHD_Connection::urh, ::daemon, ::tls_read_ready, ::tid; struct MHD_Daemon::options, ::shutdown): these fields control loop entry/exit (options & MHD_USE_TLS), the loop timeout logic (tls_read_ready, shutdown) and the loop condition (urh in/out buffer sizes and used counters). To decide if the while-loop and its body are ever executed or are redundant you must know how these fields are initialized and modified.\n\nUpgrade-response handle fields (in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection->socket_fd, mhd.socket): the while-loop condition and the file descriptors used by select()/poll() depend on these. If, for example, buffer sizes are zero and never change, the loop may be dead.\n\nConstants FD_SETSIZE and MHD_INVALID_SOCKET: they influence the urh_to_fdset/FD handling and whether select() is called; needed to know if the select path is reachable.\n\nurh_to_fdset, urh_from_fdset, urh_update_pollfd, urh_from_pollfd, process_urh: these functions implement the forward-loop behavior and have side effects on urh buffers and sockets. To determine whether removing the loop or calls is behavior-preserving you must know their semantics (do they change buffers, close sockets, block, or are they no-ops?).\n\nMHD_SYS_select_, MHD_sys_poll_, MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_: the select/poll wrappers and error helpers determine whether the code blocks can block, loop, or break on errors; their behavior affects observable timing and error-reporting side effects \u2014 relevant because MISRA's dead-code notion considers changes to timing/observable behavior.\n\nMHD_DLOG: logging calls can have observable side effects (I/O); if they always do nothing or are compiled out, code containing them may be dead \u2014 otherwise removal changes behavior.\n\nMHD_connection_finish_forward_: called unconditionally at function end and performs cleanup; to judge whether earlier code is required for correct final cleanup (and thus not dead), you need this routine's semantics.\n\nIn summary: these symbols determine (1) whether the TLS-forward code is compiled in at all, (2) whether the runtime checks make the while-loop and its branches reachable, and (3) whether the called routines have side effects that make the loop and helper calls required for correct observable behavior. Any missing definitions for these symbols prevents a sound determination of whether parts of thread_main_connection_upgrade are dead code under the MISRA rule."
}