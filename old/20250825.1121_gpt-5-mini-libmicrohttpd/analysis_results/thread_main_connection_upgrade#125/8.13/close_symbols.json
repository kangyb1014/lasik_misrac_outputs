{
  "user_message": "Target function code is:\n```c\nstatic void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (con->tid) );\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n       MHD_D_IS_USING_SELECT_ (daemon))\n  {\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      /* use select */\n      fd_set rs;\n      fd_set ws;\n      fd_set es;\n      MHD_socket max_fd;\n      int num_ready;\n      bool result;\n\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = MHD_INVALID_SOCKET;\n      result = urh_to_fdset (urh,\n                             &rs,\n                             &ws,\n                             &es,\n                             &max_fd,\n                             FD_SETSIZE);\n      if (! result)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error preparing select.\\n\"));\n#endif\n        break;\n      }\n      /* FIXME: does this check really needed? */\n      if (MHD_INVALID_SOCKET != max_fd)\n      {\n        struct timeval *tvp;\n        struct timeval tv;\n        if (((con->tls_read_ready) &&\n             (urh->in_buffer_used < urh->in_buffer_size)) ||\n            (daemon->shutdown))\n        {         /* No need to wait if incoming data is already pending in TLS buffers. */\n          tv.tv_sec = 0;\n          tv.tv_usec = 0;\n          tvp = &tv;\n        }\n        else\n          tvp = NULL;\n        num_ready = MHD_SYS_select_ (max_fd + 1,\n                                     &rs,\n                                     &ws,\n                                     &es,\n                                     tvp);\n      }\n      else\n        num_ready = 0;\n      if (num_ready < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during select (%d): `%s'\\n\"),\n                  err,\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_fdset (urh,\n                      &rs,\n                      &ws,\n                      &es,\n                      (int) FD_SETSIZE);\n      process_urh (urh);\n    }\n  }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    /* use poll() */\n    struct pollfd p[2];\n    memset (p,\n            0,\n            sizeof (p));\n    p[0].fd = urh->connection->socket_fd;\n    p[1].fd = urh->mhd.socket;\n\n    while ( (0 != urh->in_buffer_size) ||\n            (0 != urh->out_buffer_size) ||\n            (0 != urh->in_buffer_used) ||\n            (0 != urh->out_buffer_used) )\n    {\n      int timeout;\n\n      urh_update_pollfd (urh, p);\n\n      if (((con->tls_read_ready) &&\n           (urh->in_buffer_used < urh->in_buffer_size)) ||\n          (daemon->shutdown))\n        timeout = 0;     /* No need to wait if incoming data is already pending in TLS buffers. */\n      else\n        timeout = -1;\n\n      if (MHD_sys_poll_ (p,\n                         2,\n                         timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\n        if (MHD_SCKT_ERR_IS_EINTR_ (err))\n          continue;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (con->daemon,\n                  _ (\"Error during poll: `%s'\\n\"),\n                  MHD_socket_strerr_ (err));\n#endif\n        break;\n      }\n      urh_from_pollfd (urh,\n                       p);\n      process_urh (urh);\n    }\n  }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'thread_main_connection_upgrade': {'callees': [], 'callers': ['thread_main_handle_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct MHD_UpgradeResponseHandle",
    "struct MHD_Daemon",
    "struct MHD_UpgradeResponseHandle::connection (type/definition)",
    "urh_to_fdset",
    "urh_from_fdset",
    "urh_update_pollfd",
    "urh_from_pollfd",
    "process_urh",
    "MHD_connection_finish_forward_",
    "MHD_thread_handle_ID_is_current_thread_",
    "mhd_assert",
    "MHD_SYS_select_",
    "MHD_sys_poll_",
    "MHD_socket_get_error_",
    "MHD_socket_strerr_",
    "MHD_DLOG",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_USE_TLS",
    "MHD_INVALID_SOCKET",
    "FD_SETSIZE",
    "fd_set / FD_ZERO / FD_* macros",
    "struct timeval",
    "MHD_socket (socket type)",
    "struct pollfd"
  ],
  "explanation": "For checking the MISRA rule about pointer const-qualification you need the declarations/definitions for every type, field and function that introduces or uses pointers in thread_main_connection_upgrade so you can determine whether each pointer could/should be to a const-qualified type. Short rationale for each symbol:\n\n- struct MHD_Connection: defines members accessed (con->urh, con->daemon, con->tid, con->tls_read_ready). You must see their types (pointer vs non-pointer) to decide if they can/should be const-qualified.\n\n- struct MHD_UpgradeResponseHandle: defines members (in_buffer_size, out_buffer_size, in_buffer_used, out_buffer_used, connection, mhd, etc.). Fields that are pointers (e.g. connection, mhd) must be inspected to see if they are mutated here or elsewhere and thus whether they can be const.\n\n- struct MHD_Daemon: defines daemon->options and daemon->shutdown and any pointer members; you need this to determine whether daemon pointers could be const.\n\n- struct MHD_UpgradeResponseHandle::connection (its concrete type/definition): urh->connection->socket_fd is used; the connection type definition is required to see pointer members and mutability.\n\n- urh_to_fdset, urh_from_fdset, urh_update_pollfd, urh_from_pollfd: prototypes are needed to know which parameters are pointer types and whether the callee mutates the pointed-to data. If a function does not modify the pointed data, the parameter should be const per MISRA.\n\n- process_urh: prototype/definition required to determine whether it mutates urh or other pointers passed through; if it does not modify some pointed data, those parameters (or members) could be const.\n\n- MHD_connection_finish_forward_: prototype needed because it is called with con; you must know whether it mutates the connection and whether its parameter could be const.\n\n- MHD_thread_handle_ID_is_current_thread_, mhd_assert: prototypes/macros are needed to see whether they accept pointer parameters and whether pointers passed could be marked const.\n\n- MHD_SYS_select_, MHD_sys_poll_: prototypes are required to check pointer parameter types (fd_set *, struct pollfd *) to ensure proper const qualification (these APIs typically modify the fd_set/pollfd so they must be non-const; documenting this avoids false positives).\n\n- MHD_socket_get_error_, MHD_socket_strerr_: prototypes show whether they return/accept pointer types (e.g. const char * for error string) so you can verify if const is already used or if it should be.\n\n- MHD_DLOG: prototype needed to see constness of format/arg pointers (e.g. const char * format) and whether any pointer parameters are appropriately const.\n\n- MHD_SCKT_ERR_IS_EINTR_: macro/function used to test socket error; include to know its signature if it takes pointers (usually not) and to fully understand error handling influence on pointer usage.\n\n- MHD_USE_TLS, MHD_INVALID_SOCKET, FD_SETSIZE, FD_ZERO / fd_set / FD_* macros, struct timeval, MHD_socket, struct pollfd: these constants/types/macros are referenced in pointer-manipulating context (fd_set pointers, pollfd array, timeval pointer). Their definitions confirm which parameters are modified by system wrappers and which are read-only; this is necessary to avoid incorrectly suggesting const qualification where mutation actually occurs.\n\nIn summary: you need the struct/type definitions for all structs whose members are dereferenced in the function (to see which members are pointers and whether they are modified here or in callees), plus the prototypes of all internal helpers and wrappers called from this function (so you can see whether pointer parameters are modified). With those symbols you can determine for each pointer usage whether it is eligible for a const qualifier under the MISRA rule."
}