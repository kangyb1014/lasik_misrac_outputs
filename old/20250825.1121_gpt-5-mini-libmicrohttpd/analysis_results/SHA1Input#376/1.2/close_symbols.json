{
  "user_message": "Target function code is:\n```c\nstatic enum SHA1_RESULT\nSHA1Input (struct SHA1Context *context, const unsigned char *message_array,\n           unsigned length)\n{\n  if (! length)\n  {\n    return SHA1_RESULT_SUCCESS;\n  }\n  if (! context || ! message_array)\n  {\n    return SHA1_RESULT_NULL;\n  }\n  if (context->computed)\n  {\n    context->corrupted = 1;\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  if (context->corrupted)\n  {\n    return SHA1_RESULT_STATE_ERROR;\n  }\n  while (length-- && ! context->corrupted)\n  {\n    context->message_block[context->message_block_index++]\n      = (*message_array & 0xFF);\n    context->length_low += 8;\n    if (context->length_low == 0)\n    {\n      context->length_high++;\n      if (context->length_high == 0)\n      {\n        context->corrupted = 1;\n      }\n    }\n    if (context->message_block_index == 64)\n    {\n      SHA1ProcessMessageBlock (context);\n    }\n    message_array++;\n  }\n  return SHA1_RESULT_SUCCESS;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'SHA1Input': {'callees': ['SHA1ProcessMessageBlock'], 'callers': ['ws_get_accept_value']}, 'SHA1ProcessMessageBlock': {'callees': [], 'callers': ['SHA1PadMessage', 'SHA1Input']}, 'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct SHA1Context",
    "enum SHA1_RESULT",
    "SHA1ProcessMessageBlock (declaration/definition)",
    "NULL macro (header that defines NULL)",
    "typedefs/macros used by SHA1Context fields (e.g. uint32_t, size_t, any typedefs for message_block_index/length_* types)",
    "translation-unit-level attributes/pragmas/macros (any __attribute__, #pragma, compiler-specific macros in the same source/header)"
  ],
  "explanation": "For verifying the MISRA rule \u201cLanguage extensions should not be used\u201d you must inspect any types, declarations or attributes referenced by the target function because extensions can appear there rather than in the function body itself. Reasoning for each symbol:\n\n- struct SHA1Context: The function reads/writes many members of this struct (computed, corrupted, message_block, message_block_index, length_low, length_high). The struct definition can contain compiler extensions (packed/aligned attributes, zero-length arrays, flexible-array members used in non-standard ways, unnamed/implementation-specific bitfields, or non-standard typedefs). Inspecting the full struct definition is required to detect such extensions.\n\n- enum SHA1_RESULT: The function returns and uses enumerators such as SHA1_RESULT_SUCCESS, SHA1_RESULT_NULL, SHA1_RESULT_STATE_ERROR. The enum declaration might use compiler-specific extensions (attributes on the enum, explicit underlying-type extensions, or non-standard enum syntax). You must inspect the enum definition.\n\n- SHA1ProcessMessageBlock (declaration/definition): The function calls this routine. Its prototype/definition may carry function-level extensions (GCC/Clang __attribute__ annotations, asm, nonstandard calling conventions, or non-standard inline semantics). Even if the call site looks standard, the callee\u2019s declaration can introduce language extensions affecting conformance.\n\n- NULL macro (header that defines NULL): The function tests pointers against NULL. Some projects redefine NULL or use non-standard definitions/macros; to be certain no compiler-specific macro/extension is used you should check where NULL is defined in the translation unit.\n\n- typedefs/macros used by SHA1Context fields (e.g. uint32_t, size_t, or any typedef for message_block/message_block_index/length_*): The concrete types of those fields could be typedefs or macros that expand to compiler-extended types (compiler-specific integer types, bitfield-width typedefs, or macros invoking attributes). Inspect those typedefs/macros to ensure they are standard C and not compiler extensions.\n\n- translation-unit-level attributes/pragmas/macros (any __attribute__, #pragma, compiler-specific macros in the same source/header): Language extensions are frequently introduced as file- or declaration-level attributes or pragmas. You must check the surrounding translation unit (includes and top-level declarations) for any such extensions that the target function depends on.\n\nCollecting these symbols (definitions/declarations and the headers they come from) allows a correct determination whether the target function uses any language extensions directly or indirectly."
}