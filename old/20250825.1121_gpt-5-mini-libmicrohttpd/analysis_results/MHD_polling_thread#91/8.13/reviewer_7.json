{
  "user_message": "An agent A claimed that the following MHD_polling_thread code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_polling_thread.\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf MHD_strerror_ is declared to return a non-const char * (e.g. char *MHD_strerror_(int)) but actually yields a pointer to static/read-only error text, this is a violation: the pointer should be const-qualified (const char *) since the data is not intended to be modified. Passing that non-const pointer into the variadic MHD_DLOG (with \"%s\") does not remove the need for the returned pointer to be const-qualified.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct provided the actual declaration of MHD_strerror_ is non-const (e.g. char *MHD_strerror_(int)). MISRA C 2023 Rule 8.13 requires that pointers refer to const-qualified types whenever the pointed-to object is not intended to be modified. If MHD_strerror_ returns a pointer to static/read-only error text but is declared to return char * (non-const), that is a violation \u2014 the function should return const char *.\n\nPassing that pointer to a variadic logging function with \"%s\" does not negate the need for the return type to be const-qualified; the call site does not justify a non-const return. (Note: historical C APIs such as strerror() often return char * for compatibility, which can conflict with MISRA guidance, but that is an API design exception rather than justification that Rule 8.13 is not violated.)\n\nIf, however, MHD_strerror_ is already declared to return const char *, then there is no violation in the shown code."
}