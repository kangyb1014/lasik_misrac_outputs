{
  "user_message": "Target function code is:\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n#ifdef HAVE_PTHREAD_SIGMASK\n  sigset_t s_mask;\n  int err;\n#endif /* HAVE_PTHREAD_SIGMASK */\n\n  MHD_thread_handle_ID_set_current_thread_ID_ (&(daemon->tid));\n#ifdef HAVE_PTHREAD_SIGMASK\n  if ((0 == sigemptyset (&s_mask)) &&\n      (0 == sigaddset (&s_mask, SIGPIPE)))\n  {\n    err = pthread_sigmask (SIG_BLOCK, &s_mask, NULL);\n  }\n  else\n    err = errno;\n  if (0 == err)\n    daemon->sigpipe_blocked = true;\n#ifdef HAVE_MESSAGES\n  else\n    MHD_DLOG (daemon,\n              _ (\"Failed to block SIGPIPE on daemon thread: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n#endif /* HAVE_PTHREAD_SIGMASK */\n  while (! daemon->shutdown)\n  {\n#ifdef HAVE_POLL\n    if (MHD_D_IS_USING_POLL_ (daemon))\n      MHD_poll (daemon, MHD_YES);\n    else\n#endif /* HAVE_POLL */\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n      MHD_epoll (daemon, -1);\n    else\n#endif\n    MHD_select (daemon, -1);\n    MHD_cleanup_connections (daemon);\n  }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    resume_suspended_connections (daemon);\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_poll': {'callees': ['MHD_poll_all', 'MHD_poll_listen_socket'], 'callers': ['MHD_polling_thread']}, 'MHD_epoll': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'resume_suspended_connections', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'MHD_connection_handle_idle', 'call_handlers'], 'callers': ['MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'MHD_cleanup_connections': {'callees': ['__builtin_unreachable', 'cleanup_upgraded_connection', 'MHD_pool_destroy', 'MHD_ip_limit_del', 'MHD_destroy_response'], 'callers': ['MHD_add_connection', 'internal_run_from_select', 'MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread', 'close_all_connections', 'MHD_get_daemon_info']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'close_all_connections': {'callees': ['__builtin_unreachable', 'new_connection_close_', 'resume_suspended_connections', 'MHD_DLOG', 'close_connection', 'MHD_cleanup_connections'], 'callers': ['MHD_polling_thread', 'MHD_stop_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "MHD_thread_handle_ID_set_current_thread_ID_",
    "MHD_D_IS_USING_POLL_",
    "MHD_poll",
    "MHD_D_IS_USING_EPOLL_",
    "MHD_epoll",
    "MHD_select",
    "MHD_cleanup_connections",
    "resume_suspended_connections",
    "close_all_connections",
    "MHD_TEST_ALLOW_SUSPEND_RESUME",
    "MHD_DLOG",
    "MHD_strerror_",
    "sigemptyset",
    "sigaddset",
    "pthread_sigmask",
    "errno",
    "MHD_YES"
  ],
  "explanation": "You must confirm that the function does not modify its parameter variable (void *cls). The following symbols are needed for that check:\n\n- struct MHD_Daemon: to see the layout and names of members (tid, shutdown, sigpipe_blocked, options, etc.) and confirm that daemon is a pointer to data (so modifying members is allowed by the MISRA rule) and that no unexpected aliasing/overlapping members could cause modification of the parameter variable itself.\n\n- MHD_thread_handle_ID_set_current_thread_ID_: first operation uses &(daemon->tid); inspect this function to ensure it only writes to the pointed-to member and does not somehow obtain the address of the local parameter variable cls or otherwise modify the local pointer variable.\n\n- MHD_D_IS_USING_POLL_ and MHD_D_IS_USING_EPOLL_: these macros/inline predicates are evaluated with daemon as argument; examine their definitions to ensure they have no side-effects that would modify the pointer parameter variable (e.g., by assigning to their argument) or create aliases to cls.\n\n- MHD_poll, MHD_epoll, MHD_select: these callees receive the daemon pointer. Inspect their prototypes/definitions to verify they do not (directly or indirectly) modify the caller's parameter variable (which in C would require taking &cls; verify they only modify the pointed-to object, which is allowed).\n\n- MHD_cleanup_connections, resume_suspended_connections, close_all_connections: these are called with daemon; inspect them to ensure they do not perform any operation that could result in modification of the local parameter variable (e.g., through taking the address of the local parameter via an undocumented mechanism). Also these functions may manipulate daemon members \u2014 allowed \u2014 but should be checked.\n\n- MHD_TEST_ALLOW_SUSPEND_RESUME: to understand the options bitmask test (daemon->options & flag) and confirm it only reads members and does not expand to something that assigns to the parameter.\n\n- MHD_DLOG and MHD_strerror_: logging calls that use daemon/errno; check they do not have unexpected side-effects that modify the parameter variable.\n\n- sigemptyset, sigaddset, pthread_sigmask, errno: these symbols appear in the signal-blocking block; examine them to confirm they cannot lead to modification of the local parameter variable cls.\n\n- MHD_YES: macro/constant passed to MHD_poll; included to resolve any macro expansions that might have side-effects.\n\nRationale: MISRA rule prohibits modifying the function parameter variable itself. In C this would require assignment to the parameter identifier or an operation by a callee that has access to the caller's stack variable (very unusual). To be certain the rule is not violated we must (1) inspect the struct type used for the pointer to confirm member accesses are to the pointed-to object (permitted), (2) inspect any macros and callees receiving the pointer to ensure none perform assignments to the parameter variable or create aliases to it via non-standard means, and (3) verify no macro expansion or inline function in the code reassigns cls. The symbols above are the minimal set needed to perform that analysis."
}