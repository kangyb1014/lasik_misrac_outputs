{
  "user_message": "An agent A claimed that the following internal_suspend_connection_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of internal_suspend_connection_.\n```c\nvoid\ninternal_suspend_connection_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  mhd_assert (NULL == daemon->worker_pool);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if (connection->resuming)\n  {\n    /* suspending again while we didn't even complete resuming yet */\n    connection->resuming = false;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    return;\n  }\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n      XDLL_remove (daemon->normal_timeout_head,\n                   daemon->normal_timeout_tail,\n                   connection);\n    else\n      XDLL_remove (daemon->manual_timeout_head,\n                   daemon->manual_timeout_tail,\n                   connection);\n  }\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              connection);\n  mhd_assert (! connection->suspended);\n  DLL_insert (daemon->suspended_connections_head,\n              daemon->suspended_connections_tail,\n              connection);\n  connection->suspended = true;\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n    {\n      EDLL_remove (daemon->eready_head,\n                   daemon->eready_tail,\n                   connection);\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n    }\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET))\n    {\n      if (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          connection->socket_fd,\n                          NULL))\n        MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EPOLL_SET);\n    }\n    connection->epoll_state |= MHD_EPOLL_STATE_SUSPENDED;\n  }\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf either the translation macro '_' or the MHD_PANIC macro/function is declared to accept a non-const char * (for example: void MHD_PANIC(char *msg) or #define _(...) ((char *)gettext(__VA_ARGS__))), then a non-const pointer is being used where a const-qualified pointer would be appropriate. Passing a string literal (\"Failed to remove FD from epoll set.\\n\") or the result of '_' to a non-const parameter violates MISRA C 2023 Rule 8.13. To fix, declare the parameter(s) as const char * (e.g. void MHD_PANIC(const char *msg) and ensure _ returns const char *).\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is conditional and not proven by the code snippet alone. Rule 8.13 recommends that pointer types should be const-qualified where possible, so passing string literals or translation results to an API declared to take a non-const char * would be undesirable and would indicate the API should use const char *. However, the snippet does not show the declarations of _ or MHD_PANIC. If both are declared to accept/return const char * (which is the usual and correct choice), there is no violation in this call. Only if either _ or MHD_PANIC is actually declared to take/return non-const char * would the code exercise the problematic non-const pointer and thus reveal a Rule 8.13 issue. In short: the scenario described by agent A is possible, but the report as stated is not proven by the provided code \u2014 you need to inspect the declarations of '_' and MHD_PANIC. Recommended fix (if those APIs currently use non-const char *): change their signatures to use const char * (and avoid casting away const)."
}