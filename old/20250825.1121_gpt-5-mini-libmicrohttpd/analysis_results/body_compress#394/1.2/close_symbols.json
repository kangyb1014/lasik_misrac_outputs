{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nbody_compress (void **buf,\n               size_t *buf_size)\n{\n  Bytef *cbuf;\n  uLongf cbuf_size;\n  int ret;\n\n  cbuf_size = compressBound ((uLong) * buf_size);\n  cbuf = malloc (cbuf_size);\n  if (NULL == cbuf)\n    return MHD_NO;\n  ret = compress (cbuf,\n                  &cbuf_size,\n                  (const Bytef *) *buf,\n                  (uLong) * buf_size);\n  if ((Z_OK != ret) ||\n      (cbuf_size >= *buf_size))\n  {\n    /* compression failed */\n    free (cbuf);\n    return MHD_NO;\n  }\n  free (*buf);\n  *buf = (void *) cbuf;\n  *buf_size = (size_t) cbuf_size;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'body_compress': {'callees': [], 'callers': ['ahc_echo']}, 'ahc_echo': {'callees': ['MHD_queue_response', 'MHD_create_response_from_callback', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_create_response_empty', 'MHD_lookup_connection_value', 'MHD_create_response_from_buffer_with_free_callback', 'MHD_create_response_from_fd64', 'MHD_create_response_from_buffer', 'MHD_create_response_from_buffer_copy', 'MHD_suspend_connection', 'MHD_digest_auth_check3', 'MHD_queue_auth_required_response3', 'MHD_basic_auth_get_username_password3', 'MHD_queue_basic_auth_required_response3', 'MHD_free', 'MHD_create_response_for_upgrade', 'can_compress', 'body_compress'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "Bytef",
    "uLongf",
    "uLong",
    "compressBound",
    "compress",
    "Z_OK",
    "malloc",
    "free",
    "size_t",
    "NULL",
    "enum MHD_Result (including MHD_NO and MHD_YES)"
  ],
  "explanation": "For checking MISRA C rule 'Language extensions should not be used' we must inspect the actual declarations/definitions of every non-built-in symbol and type used by body_compress to ensure none are implemented using compiler-specific extensions (e.g. __attribute__, __declspec, builtins, nonstandard keywords or macros that expand to extensions). Reason for each symbol: \n- Bytef: typedef for the buffer pointer type \u2014 might be a typedef that uses extensions. \n- uLongf: typedef for compressed-size type \u2014 could hide attributes or nonstandard width specifiers. \n- uLong: typedef used in casts and compressBound prototype \u2014 must verify it is a standard typedef, not an extension. \n- compressBound: macro or function that computes bound \u2014 macro definitions often use compiler builtins or extensions; need its definition. \n- compress: external (zlib) function prototype/definition \u2014 may include nonstandard attributes or extensions. \n- Z_OK: status macro/constant \u2014 could be an enum or macro with unusual definition. \n- malloc: runtime allocation prototype \u2014 some C libraries annotate malloc with __attribute__ or other extensions; need its prototype. \n- free: deallocation prototype \u2014 check for extensions/annotations. \n- size_t: standard type used in the function signature and assignments \u2014 need to confirm its origin and that it is the standard typedef, not an extension. \n- NULL: macro used in the null check \u2014 its definition could be something nonstandard in some environments. \n- enum MHD_Result (including MHD_NO and MHD_YES): the function return type and constants \u2014 must inspect the enum/definition to ensure it is a plain standard enum (not using language extensions such as enum bitfields, attributes, or nonstandard storage-class annotations).\n\nProvide the actual declarations/headers for these symbols to the next analyzer so it can detect any compiler-specific language extensions in their definitions."
}