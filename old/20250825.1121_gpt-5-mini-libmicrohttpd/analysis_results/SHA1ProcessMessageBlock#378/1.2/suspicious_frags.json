{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of SHA1ProcessMessageBlock:\n```c\nstatic void\nSHA1ProcessMessageBlock (struct SHA1Context *context)\n{\n  const uint32_t K[] = { 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6 };\n  int i;\n  uint32_t temp;\n  uint32_t W[80];\n  uint32_t A, B, C, D, E;\n\n  for (i = 0; i < 16; i++)\n  {\n    W[i] = ((uint32_t) context->message_block[i * 4]) << 24;\n    W[i] |= ((uint32_t) context->message_block[i * 4 + 1]) << 16;\n    W[i] |= ((uint32_t) context->message_block[i * 4 + 2]) << 8;\n    W[i] |= context->message_block[i * 4 + 3];\n  }\n  for (i = 16; i < 80; i++)\n  {\n    W[i]\n      = SHA1CircularShift (1, W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);\n  }\n  A = context->intermediate_hash[0];\n  B = context->intermediate_hash[1];\n  C = context->intermediate_hash[2];\n  D = context->intermediate_hash[3];\n  E = context->intermediate_hash[4];\n  for (i = 0; i < 20; i++)\n  {\n    temp = SHA1CircularShift (5, A) + ((B & C) | ((~B) & D)) + E + W[i]\n           + K[0];\n    E = D;\n    D = C;\n    C = SHA1CircularShift (30, B);\n    B = A;\n    A = temp;\n  }\n  for (i = 20; i < 40; i++)\n  {\n    temp = SHA1CircularShift (5, A) + (B ^ C ^ D) + E + W[i] + K[1];\n    E = D;\n    D = C;\n    C = SHA1CircularShift (30, B);\n    B = A;\n    A = temp;\n  }\n  for (i = 40; i < 60; i++)\n  {\n    temp = SHA1CircularShift (5, A) + ((B & C) | (B & D) | (C & D)) + E\n           + W[i] + K[2];\n    E = D;\n    D = C;\n    C = SHA1CircularShift (30, B);\n    B = A;\n    A = temp;\n  }\n  for (i = 60; i < 80; i++)\n  {\n    temp = SHA1CircularShift (5, A) + (B ^ C ^ D) + E + W[i] + K[3];\n    E = D;\n    D = C;\n    C = SHA1CircularShift (30, B);\n    B = A;\n    A = temp;\n  }\n  context->intermediate_hash[0] += A;\n  context->intermediate_hash[1] += B;\n  context->intermediate_hash[2] += C;\n  context->intermediate_hash[3] += D;\n  context->intermediate_hash[4] += E;\n  context->message_block_index = 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function SHA1ProcessMessageBlock:\nstruct SHA1Context\n{\n  uint32_t intermediate_hash[SHA1HashSize / 4];\n  uint32_t length_low;\n  uint32_t length_high;\n  int_least16_t message_block_index;\n  unsigned char message_block[64];\n  int computed;\n  int corrupted;\n}\n...\n#define SHA1CircularShift(bits, word) (((word)<<(bits))|((word)>>(32-(bits))))\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I examined all code shown for SHA1ProcessMessageBlock, the related struct snippet, and the SHA1CircularShift macro. I did not find any compiler-specific language extensions (no __attribute__, __asm, __builtin_*, typeof, statement-expressions ({ ... }), inline assembler, Microsoft __declspec, GCC __extension__, compiler pragmas, or other vendor-specific keywords). The code uses only standard C constructs and standard fixed-width integer types (uint32_t, int_least16_t) from <stdint.h>, ordinary macros, structs, arrays, bitwise and shift operators, and function definitions \u2014 none of which are compiler extensions.\n\nNote: the additional code shown contains an ellipsis (...) indicating omitted code; if that omitted portion contains compiler-specific extensions, it was not available for review. Based on the provided fragments, there are no language extensions to report under MISRA C 2023 Rule 1.2."
}