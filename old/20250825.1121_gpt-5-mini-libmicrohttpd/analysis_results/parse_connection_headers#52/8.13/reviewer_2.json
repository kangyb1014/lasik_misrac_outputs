{
  "user_message": "An agent A claimed that the following parse_connection_headers code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of parse_connection_headers.\n```c\nstatic void\nparse_connection_headers (struct MHD_Connection *connection)\n{\n  const char *clen;\n  const char *enc;\n  size_t val_len;\n\n#ifdef COOKIE_SUPPORT\n  if (MHD_PARSE_COOKIE_NO_MEMORY == parse_cookie_header (connection))\n  {\n    handle_req_cookie_no_space (connection);\n    return;\n  }\n#endif /* COOKIE_SUPPORT */\n  if ( (-3 < connection->daemon->client_discipline) &&\n       (MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver)) &&\n       (MHD_NO ==\n        MHD_lookup_connection_value_n (connection,\n                                       MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_HOST,\n                                       MHD_STATICSTR_LEN_ (\n                                         MHD_HTTP_HEADER_HOST),\n                                       NULL,\n                                       NULL)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Received HTTP/1.1 request without `Host' header.\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_BAD_REQUEST,\n                                    REQUEST_LACKS_HOST);\n    return;\n  }\n\n  /* The presence of the request body is indicated by \"Content-Length:\" or\n     \"Transfer-Encoding:\" request headers.\n     Unless one of these two headers is used, the request has no request body.\n     See RFC9112, Section 6, paragraph 4. */\n  connection->rq.remaining_upload_size = 0;\n  if (MHD_NO !=\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_TRANSFER_ENCODING),\n                                     &enc,\n                                     NULL))\n  {\n    if (! MHD_str_equal_caseless_ (enc,\n                                   \"chunked\"))\n    {\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_UNSUPPORTED_TR_ENCODING);\n      return;\n    }\n    else if (MHD_NO !=\n             MHD_lookup_connection_value_n (connection,\n                                            MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                            MHD_STATICSTR_LEN_ ( \\\n                                              MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                            NULL,\n                                            NULL))\n    {\n      /* TODO: add individual settings */\n      if (1 <= connection->daemon->client_discipline)\n      {\n        transmit_error_response_static (connection,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_LENGTH_WITH_TR_ENCODING);\n        return;\n      }\n      else\n      {\n        /* Must close connection after reply to prevent potential attack */\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The 'Content-Length' request header is ignored \"\n                     \"as chunked Transfer-Encoding is used \"\n                     \"for this request.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n    }\n    connection->rq.have_chunked_upload = true;\n    connection->rq.remaining_upload_size = MHD_SIZE_UNKNOWN;\n  }\n  else if (MHD_NO !=\n           MHD_lookup_connection_value_n (connection,\n                                          MHD_HEADER_KIND,\n                                          MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          MHD_STATICSTR_LEN_ (\n                                            MHD_HTTP_HEADER_CONTENT_LENGTH),\n                                          &clen,\n                                          &val_len))\n  {\n    size_t num_digits;\n\n    num_digits = MHD_str_to_uint64_n_ (clen,\n                                       val_len,\n                                       &connection->rq.remaining_upload_size);\n\n    if (((0 == num_digits) &&\n         (0 != val_len) &&\n         ('0' <= clen[0]) && ('9' >= clen[0]))\n        || (MHD_SIZE_UNKNOWN == connection->rq.remaining_upload_size))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Too large value of 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_CONTENT_TOO_LARGE,\n                                      REQUEST_CONTENTLENGTH_TOOLARGE);\n    }\n    else if ((val_len != num_digits) ||\n             (0 == num_digits))\n    {\n      connection->rq.remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to parse 'Content-Length' header. \" \\\n                   \"Closing connection.\\n\"));\n#endif\n      transmit_error_response_static (connection,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_CONTENTLENGTH_MALFORMED);\n    }\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code compares and passes pos->header to functions that take const char* (e.g. (key == pos->header) and MHD_str_equal_caseless_bin_n_(key, pos->header, key_size)). If the struct member pos->header is declared as a plain char * (non-const) while it is only used for read-only operations, Rule 8.13 is violated: the pointer member should be declared as const char * to reflect that it points to immutable data.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function parse_connection_headers:\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n...\nstatic void\nhandle_req_cookie_no_space (struct MHD_Connection *c)\n{\n  unsigned int err_code;\n\n  err_code = get_no_space_err_status_code (c,\n                                           MHD_PROC_RECV_COOKIE,\n                                           NULL,\n                                           0);\n  transmit_error_response_static (c,\n                                  err_code,\n                                  ERR_MSG_REQUEST_HEADER_WITH_COOKIES_TOO_BIG);\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n...\nint\nMHD_str_equal_caseless_ (const char *str1,\n                         const char *str2)\n{\n  while (0 != (*str1))\n  {\n    const char c1 = *str1;\n    const char c2 = *str2;\n    if (charsequalcaseless (c1, c2))\n    {\n      str1++;\n      str2++;\n    }\n    else\n      return 0;\n  }\n  return 0 == (*str2);\n}\n...\nsize_t\nMHD_str_to_uint64_n_ (const char *str,\n                      size_t maxlen,\n                      uint64_t *out_val)\n{\n  uint64_t res;\n  size_t i;\n\n  if (! str || ! maxlen || ! out_val || ! isasciidigit (str[0]))\n    return 0;\n\n  res = 0;\n  i = 0;\n  do\n  {\n    const int digit = (unsigned char) str[i] - '0';\n\n    if ( (res > (UINT64_MAX / 10)) ||\n         ( (res == (UINT64_MAX / 10)) &&\n           ((uint64_t) digit > (UINT64_MAX % 10)) ) )\n      return 0;\n\n    res *= 10;\n    res += (unsigned int) digit;\n    i++;\n  } while ( (i < maxlen) &&\n            isasciidigit (str[i]) );\n\n  *out_val = res;\n  return i;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s claim cannot be confirmed from the excerpts alone. MISRA C:2023 Rule 8.13 requires pointers to be declared to point to const-qualified types when they are only used for read-only access. In the shown code, pos->header is only read: it is compared against key, tested for NULL, and passed to functions that take const char * (so read-only uses are visible). That means, from these snippets, pos->header could be declared as const char * and doing so would satisfy Rule 8.13.\n\nHowever, the report asserts a violation based on the presumed declaration of pos->header as plain char *; the struct definition of MHD_HTTP_Req_Header and any other code that might modify pos->header are not provided. If pos->header is modified elsewhere (written to, used as a mutable buffer, or assigned from non-const APIs that later mutate it), then it must remain a non-const pointer and Rule 8.13 would not be violated. Conversely, if pos->header is never modified anywhere, then the current non-const declaration (if it exists) would indeed be a violation.\n\nTherefore the claim is plausible but not proven by the provided code. To conclude definitively you must inspect the definition of struct MHD_HTTP_Req_Header and all code that assigns to or modifies pos->header. If that member is declared as char * and never written through, then the report is correct; without that evidence the report cannot be confirmed."
}