{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_ConnKeepAlive\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response;  /**< a short alias */\n\n  mhd_assert (NULL != r);\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n    return MHD_CONN_MUST_CLOSE;\n\n#ifdef UPGRADE_SUPPORT\n  /* TODO: Move below the next check when MHD stops closing connections\n   * when response is queued in first callback */\n  if (NULL != r->upgrade_handler)\n  {\n    /* No \"close\" token is enforced by 'add_response_header_connection()' */\n    mhd_assert (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    /* Valid HTTP version is enforced by 'MHD_queue_response()' */\n    mhd_assert (MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver));\n    mhd_assert (! c->stop_with_error);\n    return MHD_CONN_MUST_UPGRADE;\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert ( (! c->stop_with_error) || (c->discard_request));\n  if ((c->read_closed) || (c->discard_request))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (0 != (r->flags & MHD_RF_HTTP_1_0_COMPATIBLE_STRICT))\n    return MHD_CONN_MUST_CLOSE;\n  if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (! MHD_IS_HTTP_VER_SUPPORTED (c->rq.http_ver))\n    return MHD_CONN_MUST_CLOSE;\n\n  if (MHD_lookup_header_s_token_ci (c,\n                                    MHD_HTTP_HEADER_CONNECTION,\n                                    \"close\"))\n    return MHD_CONN_MUST_CLOSE;\n\n  if ((MHD_HTTP_VER_1_0 == connection->rq.http_ver) ||\n      (0 != (connection->rp.response->flags & MHD_RF_HTTP_1_0_SERVER)))\n  {\n    if (MHD_lookup_header_s_token_ci (connection,\n                                      MHD_HTTP_HEADER_CONNECTION,\n                                      \"Keep-Alive\"))\n      return MHD_CONN_USE_KEEPALIVE;\n\n    return MHD_CONN_MUST_CLOSE;\n  }\n\n  if (MHD_IS_HTTP_VER_1_1_COMPAT (c->rq.http_ver))\n    return MHD_CONN_USE_KEEPALIVE;\n\n  return MHD_CONN_MUST_CLOSE;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'keepalive_possible': {'callees': ['MHD_lookup_header_token_ci'], 'callers': ['setup_reply_properties']}, 'MHD_lookup_header_token_ci': {'callees': [], 'callers': ['keepalive_possible']}, 'setup_reply_properties': {'callees': ['keepalive_possible', 'is_reply_body_needed'], 'callers': ['build_header_response']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct MHD_Response",
    "enum MHD_ConnKeepAlive",
    "MHD_CONN_MUST_CLOSE",
    "MHD_CONN_MUST_UPGRADE",
    "MHD_CONN_USE_KEEPALIVE",
    "MHD_lookup_header_s_token_ci",
    "mhd_assert",
    "UPGRADE_SUPPORT",
    "MHD_RF_HTTP_1_0_COMPATIBLE_STRICT",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_RF_HTTP_1_0_SERVER",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_IS_HTTP_VER_SUPPORTED",
    "MHD_IS_HTTP_VER_1_1_COMPAT",
    "MHD_HTTP_VER_1_0"
  ],
  "explanation": "For checking whether the function uses any compiler language extensions you must inspect the definitions and declarations referenced by the function to see if they employ extensions (attributes, statement expressions, typeof, inline asm, compiler-specific keywords, nonstandard pragmas, etc.). Brief rationale for each symbol:\n\n- struct MHD_Connection: contains all fields accessed (keepalive, read_closed, discard_request, rq.http_ver, rp) \u2014 its definition must be checked for nonstandard type declarations, bitfields using extension syntax, anonymous structs/unions, or GCC/clang attributes.\n- struct MHD_Response: contains fields accessed (flags, flags_auto, upgrade_handler) \u2014 inspect for extensions in its definition.\n- enum MHD_ConnKeepAlive: the return type; check enum definition for any compiler-specific extension usage (e.g., explicit underlying type, attributes).\n- MHD_CONN_MUST_CLOSE / MHD_CONN_MUST_UPGRADE / MHD_CONN_USE_KEEPALIVE: enum constants or macros used as return values \u2014 need their origin (enum or #define) to ensure no extension (e.g., nonstandard large integer suffixes).\n- MHD_lookup_header_s_token_ci: declaration/definition of this function must be checked for language extensions in its prototype or implementation (attributes, nonstandard calling conventions, inline asm, custom qualifiers).\n- mhd_assert: macro/function used for assertions \u2014 macros commonly hide compiler extensions (statement expressions, __builtin_expect, __attribute__, typeof). Its definition is required to detect such extensions.\n- UPGRADE_SUPPORT: preprocessor macro controlling conditional compilation \u2014 must be known because presence/absence changes code path; its definition may be compiler-provided or use extension-specific macros.\n- MHD_RF_HTTP_1_0_COMPATIBLE_STRICT, MHD_RAF_HAS_CONNECTION_CLOSE, MHD_RF_HTTP_1_0_SERVER: flag macros used in bitwise expressions \u2014 need to see if they are plain integer macros or use extensions (e.g., hex suffixes, types, casts, compound literals in macros).\n- MHD_HTTP_HEADER_CONNECTION: header-name macro/constant passed to lookup function \u2014 inspect definition to ensure no extension (e.g., GCC string literal attributes, concatenation using extension syntax).\n- MHD_IS_HTTP_VER_SUPPORTED / MHD_IS_HTTP_VER_1_1_COMPAT: macros or inline functions used to test HTTP version \u2014 their definitions might use inline functions, macros with statement expressions, typeof, or attributes; must be checked.\n- MHD_HTTP_VER_1_0: HTTP-version constant used in comparisons \u2014 its definition (enum or macro) should be inspected for nonstandard constructs.\n\nThese symbols cover all types, macros, and functions directly referenced by keepalive_possible whose definitions could hide language extensions. Inspecting them allows a thorough determination whether the target function relies on any compiler-specific language extensions."
}