{
  "user_message": "An agent A claimed that the following MHD_create_response_from_buffer_with_free_callback_cls code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_response_from_buffer_with_free_callback_cls.\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback_cls (size_t size,\n                                                        const void *buffer,\n                                                        MHD_ContentReaderFreeCallback\n                                                        crfc,\n                                                        void *crfc_cls)\n{\n  struct MHD_Response *r;\n\n  if ((NULL == buffer) && (size > 0))\n    return NULL;\n#if SIZEOF_SIZE_T >= SIZEOF_UINT64_T\n  if (MHD_SIZE_UNKNOWN == size)\n    return NULL;\n#endif /* SIZEOF_SIZE_T >= SIZEOF_UINT64_T */\n  r = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == r)\n    return NULL;\n#if defined(MHD_USE_THREADS)\n  if (! MHD_mutex_init_ (&r->mutex))\n  {\n    free (r);\n    return NULL;\n  }\n#endif\n  r->fd = -1;\n  r->reference_count = 1;\n  r->total_size = size;\n  r->data = buffer;\n  r->data_size = size;\n  r->crfc = crfc;\n  r->crc_cls = crfc_cls;\n  return r;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter crfc_cls is declared as void * but is not modified in MHD_create_response_from_buffer_with_free_callback_cls (it is only stored into r->crc_cls). According to Rule 8.13 the pointer should be to a const-qualified type when possible, so this should be declared as const void * (and the stored field r->crc_cls should likewise be const-qualified) unless the callback actually needs to modify the object. Therefore, as shown, the non-const void * parameter violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_response_from_buffer_with_free_callback_cls:\ntypedef void\n(*MHD_ContentReaderFreeCallback) (void *cls)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct. MISRA C 2023 Rule 8.13 asks that pointers be to const-qualified types when possible, but \u201cpossible\u201d must be judged in the context of how the pointer is used. Here crfc_cls is a context pointer that is stored in r->crc_cls and is intended to be supplied later to the free callback whose typedef is\n\ttypedef void (*MHD_ContentReaderFreeCallback)(void *cls);\nThe callback expects a void * (non-const) and may legally modify or free the pointed-to object. Even though MHD_create_response_from_buffer_with_free_callback_cls itself does not modify the pointer or the pointee, the wider API contract requires a non-const pointer. Changing crfc_cls (and r->crc_cls) to const void * would be incompatible with the callback type and the intended usage. Therefore the current declaration does not violate Rule 8.13."
}