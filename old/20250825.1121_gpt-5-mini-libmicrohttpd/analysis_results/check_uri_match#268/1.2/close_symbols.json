{
  "user_message": "Target function code is:\n```c\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'check_uri_match': {'callees': ['MHD_DLOG', 'check_argument_match'], 'callers': ['digest_auth_check_all_inner']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'check_argument_match': {'callees': ['MHD_parse_arguments_'], 'callers': ['check_uri_match']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon (full definition)",
    "struct MHD_Connection (full definition)",
    "type/definition of connection->rq (the struct that contains url and url_len)",
    "daemon->unescape_callback (declaration/type of this function-pointer member)",
    "daemon->unescape_callback_cls (type of this member)",
    "check_argument_match (prototype and/or macro/definition)",
    "MHD_DLOG (macro or function definition/expansion)",
    "HAVE_MESSAGES (preprocessor macro definition)",
    "_ (underscore) macro/function (often gettext) used inside MHD_DLOG",
    "memchr prototype (from <string.h>)",
    "size_t typedef (from <stddef.h> or equivalent)"
  ],
  "explanation": "To determine whether check_uri_match uses any compiler/language extensions we must inspect not only the visible source lines but the types and macros it references because extensions frequently appear in declarations or macro expansions. Specifically:\n\n- struct MHD_Daemon (full definition): contains the unescape_callback member. Its declaration may use extension features (e.g., unusual attributes, GCC function-pointer attributes, or nonstandard calling conventions) that would make the call in check_uri_match rely on an extension.\n\n- struct MHD_Connection (full definition): to verify that the way connection->daemon is accessed and the type qualifiers (e.g., use of const placement) are standard C and to check for any extension annotations on the struct or its members.\n\n- type/definition of connection->rq (the struct that contains url and url_len): the code compares uri_len and does memcmp using connection->rq.url and url_len; the rq type declaration may include attributes or nonstandard extensions affecting how these members behave.\n\n- daemon->unescape_callback (declaration/type of this function-pointer member): the call daemon->unescape_callback(...) could be using an extension if the function-pointer type uses varargs, nonstandard prototypes, calling-convention attributes, or other extensions. We must see its exact prototype to decide.\n\n- daemon->unescape_callback_cls (type of this member): its type may be a nonstandard type or use attributes that indicate extensions (for example, a GCC-specific pointer attribute).\n\n- check_argument_match (prototype and/or macro/definition): the call site is simple, but if check_argument_match is a macro that expands to code using extensions (statement expressions, typeof, inline assembly, GCC builtins) that would mean the target function indirectly uses extensions via the call.\n\n- MHD_DLOG (macro or function definition/expansion): MHD_DLOG is invoked inside the function (under HAVE_MESSAGES). It is commonly a macro; macros can expand to compiler extensions (variadic macro syntax is standard in C99 but some projects use GCC variadic extensions, statement-expression ({}) extensions, or __attribute__ annotations). We must inspect the macro expansion to determine if check_uri_match, when compiled, relies on any language extensions.\n\n- HAVE_MESSAGES (preprocessor macro definition): controls whether MHD_DLOG is used. Knowing how it's defined can reveal conditional compilation that may include extension-using code paths.\n\n- _ (underscore) macro/function (often gettext): used inside MHD_DLOG. Its definition could be a macro that uses language extensions; we must inspect it to be sure no extensions are pulled into check_uri_match via message formatting.\n\n- memchr prototype (from <string.h>): memchr is standard C; including its declaration ensures the use here is standard. We include it to confirm no project-specific replacement macro or inline with extensions shadows the standard declaration.\n\n- size_t typedef (from <stddef.h> or equivalent): used by uri_len and the return of unescape_callback. Confirming the typedef ensures no nonstandard redefinition or extension of size_t is in effect.\n\nCollecting these symbols (struct/type definitions, function-pointer prototypes, macro expansions) lets the next analyzer see whether any nonstandard language features (GCC attributes, statement expressions, inline assembly, compiler builtins used as extensions, nonstandard calling conventions, or other documented compiler extensions) are present and used in or injected into check_uri_match."
}