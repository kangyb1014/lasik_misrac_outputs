{
  "user_message": "Target function code is:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}, 'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_INVALID_SOCKET",
    "SOCK_CLOEXEC_OR_ZERO",
    "SOCK_NOSIGPIPE_OR_ZERO",
    "MSG_NOSIGNAL_OR_ZERO",
    "MHD_socket_nosignal_",
    "MHD_POSIX_SOCKETS",
    "SOCK_CLOEXEC",
    "SOCK_NOSIGPIPE",
    "MHD_WINSOCK_SOCKETS",
    "WSA_FLAG_NO_HANDLE_INHERIT"
  ],
  "explanation": "Explain why each symbol is required to decide whether any controlling expression in MHD_socket_create_listen_ is invariant:\n\n- MHD_INVALID_SOCKET\n  - The function uses if (MHD_INVALID_SOCKET == fd) twice. To judge whether those tests can be invariant you must know the value/meaning of MHD_INVALID_SOCKET (and how fd is initialized/assigned relative to that constant).\n\n- SOCK_CLOEXEC_OR_ZERO\n  - cloexec_set is assigned from (SOCK_CLOEXEC_OR_ZERO != 0). If that macro is a compile-time constant the resulting cloexec_set is effectively invariant for the compiled binary and makes the later controlling expression if (! cloexec_set) invariant. You must know this macro value.\n\n- SOCK_NOSIGPIPE_OR_ZERO\n  - nosigpipe_set is assigned from (SOCK_NOSIGPIPE_OR_ZERO != 0). If this macro is nonzero the expression (! nosigpipe_set) in the big if-condition will always be false; if zero it will be true. Its value determines whether that whole controlling expression can be invariant.\n\n- MSG_NOSIGNAL_OR_ZERO\n  - The condition uses (0 == MSG_NOSIGNAL_OR_ZERO). If MSG_NOSIGNAL_OR_ZERO is a compile-time nonzero constant the comparison is always false; if zero it is always true. This macro therefore affects invariance of the combined condition in the MHD_socket_nosignal_ block.\n\n- MHD_socket_nosignal_\n  - The big controlling expression ( (! nosigpipe_set) && (0 == MHD_socket_nosignal_ (fd)) && (0 == MSG_NOSIGNAL_OR_ZERO) ) contains a call to MHD_socket_nosignal_. Whether that call can vary at run-time (and thus make the overall expression non-invariant) depends on the function's existence and behavior; the symbol (prototype/implementation/possible return values) is required to decide invariance.\n\n- MHD_POSIX_SOCKETS, SOCK_CLOEXEC, SOCK_NOSIGPIPE, MHD_WINSOCK_SOCKETS, WSA_FLAG_NO_HANDLE_INHERIT\n  - These preprocessor macros control which blocks of code are compiled. Whether the code paths that contain the controlling expressions (e.g. the blocks that set cloexec_set/nosigpipe_set or that call WSASocketW) are present depends on these defines. To know which runtime controlling expressions actually exist in the compiled function you must know which of these macros are defined for the build.\n\n(Other functions called inside the error-handling branch \u2014 MHD_socket_get_error_, MHD_socket_close_, MHD_socket_fset_error_ \u2014 do not affect whether the controlling expression itself is invariant and therefore are not required for the MISRA invariance decision.)"
}