{
  "user_message": "An agent A claimed that the following MHD_socket_create_listen_ code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_socket_create_listen_.\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf MHD_socket_nosignal_ is defined (so the #if block is compiled in), but SOCK_NOSIGPIPE is not defined (so nosigpipe_set is assigned the constant 0 because SOCK_NOSIGPIPE_OR_ZERO == 0) and MSG_NOSIGNAL_OR_ZERO expands to a non\u2011zero macro (typical POSIX systems where MSG_NOSIGNAL is non\u2011zero), then the test (0 == MSG_NOSIGNAL_OR_ZERO) is a compile\u2011time false constant. Given nosigpipe_set is also deterministically 0, the whole if condition can never be true and the body is unreachable. With the provided definitions (SOCK_NOSIGPIPE_OR_ZERO == 0 and MSG_NOSIGNAL_OR_ZERO == MSG_NOSIGNAL which is non\u2011zero), this fragment therefore contains unreachable code.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_socket_create_listen_:\n#define MHD_POSIX_SOCKETS 1\n...\n#define SOCK_CLOEXEC_OR_ZERO SOCK_CLOEXEC\n...\n#define SOCK_NOSIGPIPE_OR_ZERO 0\n...\n#define MSG_NOSIGNAL_OR_ZERO MSG_NOSIGNAL\n...\n#define MHD_INVALID_SOCKET (-1)\n...\n#define MHD_socket_get_error_ (errno)\n...\n#define MHD_socket_close_(fd) ((0==close((fd)))||(EBADF!=errno))\n...\n#define MHD_socket_fset_error_(err) (errno=(err))\n...\nint\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE) sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. Given the provided macro definitions (SOCK_NOSIGPIPE_OR_ZERO == 0 so nosigpipe_set becomes 0, and MSG_NOSIGNAL_OR_ZERO expands to a non\u2011zero token so (0 == MSG_NOSIGNAL_OR_ZERO) is a compile\u2011time false), the if condition\n    if ( (! nosigpipe_set) && (0 == MHD_socket_nosignal_(fd)) && (0 == MSG_NOSIGNAL_OR_ZERO) )\ncontains a conjunct that is a constant false. Regardless of the runtime result of the function call, the conjunction is always false, so the body of that if can never be executed in the shown project configuration. That is unreachable code and thus a violation of MISRA C 2023 Rule 2.1 under the stated macro definitions."
}