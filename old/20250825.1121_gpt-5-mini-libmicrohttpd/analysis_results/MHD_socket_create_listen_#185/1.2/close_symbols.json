{
  "user_message": "Target function code is:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}, 'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "SOCK_CLOEXEC",
    "SOCK_NOSIGPIPE",
    "SOCK_CLOEXEC_OR_ZERO",
    "SOCK_NOSIGPIPE_OR_ZERO",
    "SOCK_STREAM",
    "MSG_NOSIGNAL_OR_ZERO",
    "MHD_socket_nosignal_",
    "MHD_socket_get_error_",
    "MHD_socket_close_",
    "MHD_socket_fset_error_",
    "MHD_socket_noninheritable_",
    "socket",
    "WSASocketW",
    "WSA_FLAG_NO_HANDLE_INHERIT",
    "WSA_FLAG_OVERLAPPED"
  ],
  "explanation": "To decide whether MHD_socket_create_listen_ uses language/compiler extensions you must inspect the definitions of all types, macros and functions referenced or used to control compilation paths and behavior. For each symbol: \n\n- MHD_socket: its typedef/definition may be a platform typedef or macro that uses compiler-specific types or attributes (e.g. typedef to a compiler intrinsic or use of __int64, __declspec, etc.).\n- MHD_INVALID_SOCKET: macro/constant may be defined using compiler-specific expressions or cast macros.\n- MHD_POSIX_SOCKETS / MHD_WINSOCK_SOCKETS: build-control macros determine code paths; their definitions or how they are set can reveal use of nonstandard compiler features.\n- SOCK_CLOEXEC / SOCK_NOSIGPIPE: these platform socket-flag macros may themselves be defined via compiler/system headers and could expand to compiler-specific constructs.\n- SOCK_CLOEXEC_OR_ZERO / SOCK_NOSIGPIPE_OR_ZERO: project macros that may expand to expressions or builtins (e.g. use of typeof, statement-expressions, __extension__, etc.).\n- SOCK_STREAM: standard flag but its header definition should be checked for unusual extensions.\n- MSG_NOSIGNAL_OR_ZERO: macro may hide platform differences via compiler-specific tricks.\n- MHD_socket_nosignal_: declared either as function or macro; macro wrappers often use extensions (inline asm, attributes, __builtin_*, or statement expressions). Must inspect its definition.\n- MHD_socket_get_error_, MHD_socket_close_, MHD_socket_fset_error_, MHD_socket_noninheritable_: these helper functions/macros may be implemented as macros or inline functions using compiler extensions (attributes, nonstandard linkage specifiers, builtin calls). Their declarations/definitions are required.\n- socket: system call/prototype from system headers may be declared with nonstandard annotations on some platforms; inspect the header for extensions.\n- WSASocketW: Windows API function declaration can include calling-convention annotations (WINAPI, __stdcall, __declspec) \u2014 these are compiler-specific and must be checked.\n- WSA_FLAG_NO_HANDLE_INHERIT / WSA_FLAG_OVERLAPPED: flag macros may be defined in headers; definitions could include compiler-specific constructs.\n\nExamining these symbols' declarations/definitions (headers and any project macro definitions) is necessary to determine if the code relies on language extensions (e.g. compiler-specific keywords, attributes, builtins, statement-expressions, typeof, nonstandard calling conventions) and thus whether the MISRA rule is violated."
}