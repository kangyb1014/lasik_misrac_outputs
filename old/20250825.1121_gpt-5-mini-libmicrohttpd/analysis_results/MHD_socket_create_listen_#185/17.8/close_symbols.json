{
  "user_message": "Target function code is:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}, 'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "socket",
    "WSASocketW",
    "SOCK_STREAM",
    "SOCK_CLOEXEC",
    "SOCK_NOSIGPIPE_OR_ZERO",
    "SOCK_CLOEXEC_OR_ZERO",
    "MSG_NOSIGNAL_OR_ZERO",
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "WSA_FLAG_NO_HANDLE_INHERIT"
  ],
  "explanation": "To determine whether the parameter 'pf' is ever modified (violating the MISRA rule), the analysis must see the actual definitions/expansions used at compile time. In particular:\n\n- socket: Could be either a function or a macro. If it is a macro it might expand to code that assigns to or otherwise modifies the local variable 'pf' (macro expansion occurs in the caller scope). Therefore the exact definition is needed to rule out hidden modifications.\n\n- WSASocketW: Same rationale as 'socket' for the Windows branch \u2014 if WSASocketW is a macro it could modify 'pf' via expansion. The concrete definition (macro vs function) must be checked.\n\n- SOCK_STREAM, SOCK_CLOEXEC, SOCK_NOSIGPIPE_OR_ZERO, SOCK_CLOEXEC_OR_ZERO, MSG_NOSIGNAL_OR_ZERO: These are macros/constants used as arguments in the calls that include 'pf'. If any of these macros expand to comma expressions or contain code referencing/assigning the identifier 'pf', they could indirectly modify the parameter. Their definitions must be inspected.\n\n- MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS, WSA_FLAG_NO_HANDLE_INHERIT: These preprocessor configuration symbols determine which compilation branch is active. The analysis must know which branch is compiled (POSIX vs WinSock vs fallback) so it can inspect the relevant socket/WSA call site and corresponding macro/function definitions for potential modification of 'pf'.\n\n(Other functions called in the body operate on 'fd' or other objects; they cannot modify the integer parameter 'pf' unless they are macros expanded in this function scope \u2014 which is already covered by checking the listed symbols.)"
}