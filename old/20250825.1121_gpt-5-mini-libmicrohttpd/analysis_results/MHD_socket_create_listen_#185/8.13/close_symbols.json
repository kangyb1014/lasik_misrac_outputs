{
  "user_message": "Target function code is:\n```c\nMHD_socket\nMHD_socket_create_listen_ (int pf)\n{\n  MHD_socket fd;\n  int cloexec_set;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  int nosigpipe_set;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n\n#if defined(MHD_POSIX_SOCKETS) && (defined(SOCK_CLOEXEC) || \\\n  defined(SOCK_NOSIGPIPE) )\n\n  fd = socket (pf,\n               SOCK_STREAM | SOCK_CLOEXEC | SOCK_NOSIGPIPE_OR_ZERO,\n               0);\n  cloexec_set = (SOCK_CLOEXEC_OR_ZERO != 0);\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = (SOCK_NOSIGPIPE_OR_ZERO != 0);\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#elif defined(MHD_WINSOCK_SOCKETS) && defined(WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (pf,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = ! 0;\n#else  /* No special socket init function / flags */\n  fd = MHD_INVALID_SOCKET;\n  cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n  nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n#endif /* No special socket init function / flags */\n  if (MHD_INVALID_SOCKET == fd)\n  {\n    fd = socket (pf,\n                 SOCK_STREAM,\n                 0);\n    cloexec_set = 0;\n#if defined(SOCK_NOSIGPIPE) || defined(MHD_socket_nosignal_)\n    nosigpipe_set = 0;\n#endif /* SOCK_NOSIGPIPE ||  MHD_socket_nosignal_ */\n  }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n\n#if defined(MHD_socket_nosignal_)\n  if ( (! nosigpipe_set) &&\n       (0 == MHD_socket_nosignal_ (fd)) &&\n       (0 == MSG_NOSIGNAL_OR_ZERO) )\n  {\n    /* SIGPIPE disable is possible on this platform\n     * (so application expect that it will be disabled),\n     * but failed to be disabled here and it is not\n     * possible to disable SIGPIPE by MSG_NOSIGNAL. */\n    const int err = MHD_socket_get_error_ ();\n    (void) MHD_socket_close_ (fd);\n    MHD_socket_fset_error_ (err);\n    return MHD_INVALID_SOCKET;\n  }\n#endif /* defined(MHD_socket_nosignal_) */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_socket_create_listen_': {'callees': ['MHD_socket_noninheritable_'], 'callers': ['MHD_start_daemon_va']}, 'MHD_socket_noninheritable_': {'callees': [], 'callers': ['MHD_add_connection', 'MHD_accept_connection', 'MHD_socket_create_listen_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket (typedef)",
    "MHD_INVALID_SOCKET (macro / constant)",
    "socket (function prototype)",
    "WSASocketW (function prototype)",
    "LPWSAPROTOCOL_INFO / LPWSAPROTOCOL_INFOW (pointer typedef used by WSASocketW)",
    "NULL (macro)",
    "MHD_socket_nosignal_ (declaration/prototype or macro)",
    "MHD_socket_noninheritable_ (declaration/prototype)",
    "MHD_socket_close_ (declaration/prototype)",
    "MHD_socket_get_error_ (declaration/prototype)",
    "MHD_socket_fset_error_ (declaration/prototype)",
    "MHD_POSIX_SOCKETS (compile-time macro)",
    "MHD_WINSOCK_SOCKETS (compile-time macro)",
    "SOCK_CLOEXEC, SOCK_NOSIGPIPE, SOCK_STREAM (socket-related macros)",
    "SOCK_CLOEXEC_OR_ZERO, SOCK_NOSIGPIPE_OR_ZERO, MSG_NOSIGNAL_OR_ZERO (macros that affect compiled branches)",
    "WSA_FLAG_NO_HANDLE_INHERIT, WSA_FLAG_OVERLAPPED (winsock flag macros)"
  ],
  "explanation": "For MISRA C pointer-to-const analysis we must know the actual pointer types and function parameter declarations used in the compiled code paths. Brief reasons: \n- MHD_socket (typedef): to know whether MHD_socket is a pointer type (and if so whether it should be const-qualified) or an integer-like type (then MISRA pointer rule does not apply).\n- MHD_INVALID_SOCKET: its type/value clarifies whether MHD_socket is integral or pointer and which branches execute.\n- socket (prototype): to confirm its return type and parameter types (to see if any pointer parameters or pointer returns are involved).\n- WSASocketW (prototype) and LPWSAPROTOCOL_INFO (pointer typedef): WSASocketW has a pointer parameter (protocol info). We must inspect its const-qualification to decide if passing NULL or other arguments violates the pointer-to-const recommendation.\n- NULL (macro): its definition can affect type compatibility when passing(NULL) to non-const vs const pointer parameters.\n- MHD_socket_nosignal_, MHD_socket_noninheritable_, MHD_socket_close_, MHD_socket_get_error_, MHD_socket_fset_error_: declarations/prototypes are required to see whether any of these take or return pointer types that should be const-qualified.\n- MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS, SOCK_CLOEXEC, SOCK_NOSIGPIPE, SOCK_STREAM and the *_OR_ZERO and MSG_NOSIGNAL_OR_ZERO macros, plus WSA flags: these compile-time macros and flag macros determine which branches of the function are actually compiled and therefore which function calls and pointer usages need to be checked. Knowing their definitions/values is necessary to identify the active code paths and the exact types used in those paths.\n\nProvide these symbol/type/prototype definitions so the next analyzer can determine whether any pointer parameter or variable in the active code paths ought to be const-qualified per the MISRA rule."
}