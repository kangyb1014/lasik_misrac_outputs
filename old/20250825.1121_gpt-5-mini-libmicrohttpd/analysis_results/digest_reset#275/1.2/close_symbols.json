{
  "user_message": "Target function code is:\n```c\n_MHD_static_inline void\ndigest_reset (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (! da->hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    mhd_assert (! da->ready_for_hashing);\n#else  /* ! MHD_MD5_HAS_FINISH */\n    mhd_assert (da->ready_for_hashing);\n#endif /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_reset (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    mhd_assert (! da->ready_for_hashing);\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    mhd_assert (da->ready_for_hashing);\n#endif /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_reset (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    mhd_assert (! da->ready_for_hashing);\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif\n    mhd_assert (0); /* May not happen, bad algorithm */\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'digest_reset': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_MD5_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'MHD_SHA256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'MHD_SHA512_256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_static_inline",
    "mhd_assert",
    "struct DigestAlgorithm",
    "MHD_DIGEST_BASE_ALGO_MD5",
    "MHD_DIGEST_BASE_ALGO_SHA256",
    "MHD_DIGEST_BASE_ALGO_SHA512_256",
    "MHD_MD5_reset",
    "MHD_SHA256_reset",
    "MHD_SHA512_256_init",
    "MHD_MD5_SUPPORT",
    "MHD_MD5_HAS_FINISH",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA256_HAS_FINISH",
    "MHD_SHA512_256_SUPPORT",
    "_DEBUG",
    "MHD_MD5_CTX",
    "MHD_SHA256_CTX",
    "MHD_SHA512_256_CTX",
    "bool/true/false (stdbool.h or equivalents)"
  ],
  "explanation": "For checking MISRA rule about language compiler extensions you must inspect any macros, typedefs or function definitions used by digest_reset because extensions (e.g. __attribute__, __inline__, __asm__, GCC builtins, statement-expressions, compiler-specific keywords) can be hidden there. Brief rationale for each symbol:\n\n- _MHD_static_inline: This macro prefixes the function. It may expand to compiler-specific constructs (e.g. __inline__, __attribute__((...))) \u2014 essential to detect extension usage.\n- mhd_assert: Usually a macro; its definition may use compiler extensions (__builtin__, statement-expression, __attribute__, or non-standard diagnostics). Verify its implementation.\n- struct DigestAlgorithm: The full type/definition is required to see member types/aliases and whether reserved identifiers or implementation-specific extensions are used in the struct (bit-fields with non-standard widths, anonymous structs/unions, attributes on members, etc.).\n- MHD_DIGEST_BASE_ALGO_MD5 / MHD_DIGEST_BASE_ALGO_SHA256 / MHD_DIGEST_BASE_ALGO_SHA512_256: These macros or enum values control the conditional checks. Their definitions may be macros that expand to expressions using extensions (or use reserved identifiers).\n- MHD_MD5_reset / MHD_SHA256_reset / MHD_SHA512_256_init: The called functions/macros must be inspected for extension usage in their declarations or definitions (inline definitions, attributes, builtins, asm, statement-expressions).\n- MHD_MD5_SUPPORT, MHD_MD5_HAS_FINISH, MHD_SHA256_SUPPORT, MHD_SHA256_HAS_FINISH, MHD_SHA512_256_SUPPORT, _DEBUG: These configuration macros control which code paths are compiled. Their definitions may themselves be compiler-specific or enable code that contains extensions; you must know their values to determine which code actually compiles and inspect those branches.\n- MHD_MD5_CTX, MHD_SHA256_CTX, MHD_SHA512_256_CTX: The concrete context types used in the DigestAlgorithm ctx union/fields; their definitions may use extensions (e.g. packed attributes, alignment attributes, or non-standard types).\n- bool/true/false (stdbool.h or equivalents): The function uses literal true/false; the underlying definition (stdbool.h or custom macros) should be checked in case non-standard boolean implementations or compiler extensions are employed.\n\nCollecting these symbol definitions (macros, typedefs, prototypes and the DigestAlgorithm type) allows the next analyzer to determine whether any compiler-specific language extensions are used in code paths taken by digest_reset."
}