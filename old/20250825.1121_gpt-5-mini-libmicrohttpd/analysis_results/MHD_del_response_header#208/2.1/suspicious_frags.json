{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_del_response_header:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  struct MHD_HTTP_Res_Header *pos;\n  size_t header_len;\n  size_t content_len;\n\n  if ( (NULL == header) ||\n       (NULL == content) )\n    return MHD_NO;\n  header_len = strlen (header);\n\n  if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);\n\n  content_len = strlen (content);\n  pos = response->first_header;\n  while (NULL != pos)\n  {\n    if ((header_len == pos->header_size) &&\n        (content_len == pos->value_size) &&\n        (0 == memcmp (header,\n                      pos->header,\n                      header_len)) &&\n        (0 == memcmp (content,\n                      pos->value,\n                      content_len)))\n    {\n      _MHD_remove_header (response, pos);\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n      if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);\n      else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }\n      return MHD_YES;\n    }\n    pos = pos->next;\n  }\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_del_response_header:\nstatic enum MHD_Result\ndel_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n\n  hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;\n\n  if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;\n  if (0 == hdr->value_size)\n  {\n    _MHD_remove_header (response, hdr);\n    free (hdr->value);\n    free (hdr->header);\n    free (hdr);\n    response->flags_auto &=\n      ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_HDR\n        | (enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n  }\n  else\n  {\n    hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }\n  }\n  return MHD_YES;\n}\n...\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n...\nbool\nMHD_str_equal_caseless_bin_n_ (const char *const str1,\n                               const char *const str2,\n                               size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; ++i)\n  {\n    const char c1 = str1[i];\n    const char c2 = str2[i];\n    if (charsequalcaseless (c1, c2))\n      continue;\n    else\n      return 0;\n  }\n  return ! 0;\n}\n...\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n...\n#define MHD_HTTP_HEADER_CONNECTION \"Connection\"\n...\n#define MHD_HTTP_HEADER_TRANSFER_ENCODING \"Transfer-Encoding\"\n...\n#define MHD_HTTP_HEADER_DATE \"Date\"\n...\n#define MHD_HTTP_HEADER_CONTENT_LENGTH \"Content-Length\"\n...\nenum MHD_ResponseAutoFlags\n{\n  MHD_RAF_NO_FLAGS = 0,                   /**< No auto flags */\n  MHD_RAF_HAS_CONNECTION_HDR = 1 << 0,    /**< Has \"Connection\" header */\n  MHD_RAF_HAS_CONNECTION_CLOSE = 1 << 1,  /**< Has \"Connection: close\" */\n  MHD_RAF_HAS_TRANS_ENC_CHUNKED = 1 << 2, /**< Has \"Transfer-Encoding: chunked\" */\n  MHD_RAF_HAS_CONTENT_LENGTH = 1 << 3,    /**< Has \"Content-Length\" header */\n  MHD_RAF_HAS_DATE_HDR = 1 << 4           /**< Has \"Date\" header */\n}\n...\n#define _MHD_remove_header(presponse, phdr) do{mhd_assert(NULL!=presponse->first_header);mhd_assert(NULL!=presponse->last_header);if(NULL==phdr->prev){mhd_assert(phdr==presponse->first_header);presponse->first_header=phdr->next;}else{mhd_assert(phdr!=presponse->first_header);mhd_assert(phdr==phdr->prev->next);phdr->prev->next=phdr->next;}if(NULL==phdr->next){mhd_assert(phdr==presponse->last_header);presponse->last_header=phdr->prev;}else{mhd_assert(phdr!=presponse->last_header);mhd_assert(phdr==phdr->next->prev);phdr->next->prev=phdr->prev;}\\\n}while(0)\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (! MHD_str_remove_tokens_caseless_ (hdr->value, &hdr->value_size, value,\n                                         strlen (value)))\n    return MHD_NO;",
    "hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONNECTION,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_CONNECTION));\n  if (NULL == hdr)\n    return MHD_NO;",
    "if ((0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR)) &&\n      (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION) == header_len) &&\n      MHD_str_equal_caseless_bin_n_ (header, MHD_HTTP_HEADER_CONNECTION,\n                                     header_len))\n    return del_response_header_connection (response, content);",
    "hdr->value[hdr->value_size] = 0; /* Null-terminate the result */\n    if (0 != (response->flags_auto\n              & ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE)))\n    {\n      if (MHD_STATICSTR_LEN_ (\"close\") == hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close\", MHD_STATICSTR_LEN_ (\"close\")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else if (MHD_STATICSTR_LEN_ (\"close, \") < hdr->value_size)\n      {\n        if (0 != memcmp (hdr->value, \"close, \",\n                         MHD_STATICSTR_LEN_ (\"close, \")))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n      }\n      else\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONNECTION_CLOSE);\n    }",
    "#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)",
    "else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_DATE) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_DATE,\n                                               header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_DATE_HDR);",
    "else if ( (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n                 header_len) &&\n                MHD_str_equal_caseless_bin_n_ (header,\n                                               MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                               header_len) )\n      {\n        if (NULL == MHD_get_response_element_n_ (response,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                                 header_len))\n          response->flags_auto &=\n            ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_CONTENT_LENGTH);\n      }",
    "_MHD_remove_header (response, pos);",
    "if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n            header_len) &&\n           MHD_str_equal_caseless_bin_n_ (header,\n                                          MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          header_len) )\n        response->flags_auto &=\n          ~((enum MHD_ResponseAutoFlags) MHD_RAF_HAS_TRANS_ENC_CHUNKED);"
  ],
  "explanation": "I have reported all code fragments that present conditional early returns, bitmask/negation tests, or string-length based branching which can commonly make code paths unreachable (or appear so) and therefore merit inspection under MISRA C Rule 2.1. Specifically I included: the special-case early return that delegates to del_response_header_connection (this changes control flow and may render other code paths unreachable in that case); each of the flag-clearing branches (Transfer-Encoding, Date, Content-Length) after header removal; the calls and returns in del_response_header_connection that can short-circuit the function; the block that null-terminates hdr->value combined with a bitmask-negated test and multiple mutually exclusive size-based branches comparing to \"close\" and \"close, \"; the call to _MHD_remove_header (macro) which changes the linked list and may affect subsequent searches; and the MHD_STATICSTR_LEN_ macro which produces compile-time constants used in the branching. These fragments are the locations most likely to contain (or mask) unreachable code and should be inspected further.\n\nOther parts of the provided functions were not listed because they are straightforward control-flow elements that are dynamically governed by runtime data (e.g. the main while loop iteration, basic NULL checks at the top, standard memcmp checks using computed lengths). Those constructs are not, by themselves, statically unreachable and do not contain unconditional code after a return or constant-false/constant-true conditions evident from the provided code. Consequently they do not require investigation specific to MISRA Rule 2.1 based on the supplied code alone."
}