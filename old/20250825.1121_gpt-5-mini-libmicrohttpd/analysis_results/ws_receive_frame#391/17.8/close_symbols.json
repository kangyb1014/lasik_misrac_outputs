{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "NULL",
    "malloc",
    "ssize_t",
    "size_t",
    "frame (identifier)",
    "length (identifier)",
    "type (identifier)"
  ],
  "explanation": "For MISRA rule analysis we must be sure that nothing used inside ws_receive_frame implicitly modifies the function parameter variables (the pointer parameters) via macro expansions, hidden side\u2011effects, or unusual typedefs. Each listed symbol must be inspected/available to the analyser for the reasons below:\n\n- WS_FIN: often a macro/constant used in the frame[0] tests. If it were a macro with side effects (or a complex expression) it could alter tokens or perform assignments \u2014 verify it is a plain integer constant.\n- WS_OPCODE_TEXT_FRAME: same reason as WS_FIN \u2014 ensure it is a simple constant (no side effects) so the comparisons do not modify parameters.\n- WS_OPCODE_CON_CLOSE_FRAME: same as above for the other opcode test.\n- NULL: the test (NULL != msg) must be a pure comparison; a nonstandard NULL macro could conceivably expand to something with side effects \u2014 verify it is the usual null pointer constant.\n- malloc: allocation call must be checked in case malloc is #defined to something with unexpected side effects (rare but possible in embedded code). Confirm it does not modify the pointer parameters.\n- ssize_t: the definition/typedef of ssize_t (and how casts to/from it behave) is needed to ensure assignments like *length = (ssize_t) data_length do not imply modification of the pointer variable itself (they modify the pointee, which is allowed) and to ensure no macro tricks are hiding assignments to the parameter variable.\n- size_t: same rationale where size_t appears (data_length) to ensure no unexpected macro/type aliasing.\n- frame (identifier): ensure the token \"frame\" is not defined as a preprocessor macro that would change occurrences of the parameter name into something that performs assignments or other side effects.\n- length (identifier): ensure the token \"length\" is not a macro; if it were, uses like *length or assignment to *length could be transformed into other code that modifies the function parameter variable rather than only the pointee.\n- type (identifier): same check for the token \"type\" to ensure assignments *type = ... are not macro-expanded into code that reassigns the parameter variable itself.\n\nIf all of the above are normal (simple constants, standard macros/typedefs, and the parameter names are not preprocessor macros), then ws_receive_frame does not reassign the pointer parameters themselves (it only writes to the objects they point to), and therefore does not violate the cited MISRA rule."
}