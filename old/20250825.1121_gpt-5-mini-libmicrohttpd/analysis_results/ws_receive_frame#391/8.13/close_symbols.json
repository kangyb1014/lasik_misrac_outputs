{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "run_usock (full definition/source including the ws_receive_frame call-site)",
    "the variable(s) passed as the 'frame' argument at that call-site (their declarations and any casts/qualifiers)",
    "the variable passed as the 'length' argument at that call-site (declaration and qualifiers)",
    "the variable passed as the 'type' argument at that call-site (declaration and qualifiers)",
    "all use-sites in run_usock of the pointer returned from ws_receive_frame (how the returned msg buffer is subsequently used/read/written)",
    "definitions of WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME (macros or enum values)"
  ],
  "explanation": "1) run_usock (definition + call-site): The MISRA question of whether 'frame' (and the returned msg) could be const depends on the caller context. The full run_usock source (where ws_receive_frame is invoked) is required to see how the parameters are prepared, whether the caller expects to modify the buffer, and how the returned pointer is used.\n\n2) Declaration(s) of the variable(s) passed as 'frame' at the call-site: You must inspect the actual declaration (e.g. unsigned char buf[], unsigned char *buf, const unsigned char *buf, any casts) to determine if the buffer is inherently mutable or already const-qualified. A cast at the call-site could defeat adding const to the callee.\n\n3) Declaration of the variable passed as 'length': Knowing whether the length argument is a modifiable storage location or tied to const data (and whether its address is reused) helps decide if ssize_t * could/should be const-qualified (e.g. pointing-to-const length is unusual but the qualifier of the pointee may matter for API design).\n\n4) Declaration of the variable passed as 'type': Similar rationale as (3) \u2014 the pointee's intended mutability at the call-site affects whether the callee's parameter should be non-const.\n\n5) Use-sites of the returned msg in run_usock (and any subsequent code): To decide if the returned unsigned char * could be const-qualified, you must see whether callers write into or free/modify the buffer. If callers only read it, the return type could be const.\n\n6) WS_FIN / WS_OPCODE_* definitions: These constants do not directly change const-qualification, but they are part of the protocol logic that determines which branches execute. Knowing their values and intended use can help confirm that ws_receive_frame only reads from 'frame' (no code path that modifies the buffer), supporting const qualification of the input pointer."
}