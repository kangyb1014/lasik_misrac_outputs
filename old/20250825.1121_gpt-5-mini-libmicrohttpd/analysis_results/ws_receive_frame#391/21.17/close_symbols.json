{
  "user_message": "Target function code is:\n```c\nstatic unsigned char *\nws_receive_frame (unsigned char *frame, ssize_t *length, int *type)\n{\n  unsigned char masks[4];\n  unsigned char mask;\n  unsigned char *msg;\n  unsigned char flength;\n  unsigned char idx_first_mask;\n  unsigned char idx_first_data;\n  size_t data_length;\n  int i;\n  int j;\n\n  msg = NULL;\n  if (frame[0] == (WS_FIN | WS_OPCODE_TEXT_FRAME))\n  {\n    *type = WS_OPCODE_TEXT_FRAME;\n    idx_first_mask = 2;\n    mask = frame[1];\n    flength = mask & 0x7F;\n    if (flength == 126)\n    {\n      idx_first_mask = 4;\n    }\n    else if (flength == 127)\n    {\n      idx_first_mask = 10;\n    }\n    idx_first_data = (unsigned char) (idx_first_mask + 4);\n    data_length = (size_t) *length - idx_first_data;\n    masks[0] = frame[idx_first_mask + 0];\n    masks[1] = frame[idx_first_mask + 1];\n    masks[2] = frame[idx_first_mask + 2];\n    masks[3] = frame[idx_first_mask + 3];\n    msg = malloc (data_length + 1);\n    if (NULL != msg)\n    {\n      for (i = idx_first_data, j = 0; i < *length; i++, j++)\n      {\n        msg[j] = frame[i] ^ masks[j % 4];\n      }\n      *length = (ssize_t) data_length;\n      msg[j] = '\\0';\n    }\n  }\n  else if (frame[0] == (WS_FIN | WS_OPCODE_CON_CLOSE_FRAME))\n  {\n    *type = WS_OPCODE_CON_CLOSE_FRAME;\n  }\n  else\n  {\n    *type = frame[0] & 0x0F;\n  }\n  return msg;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "run_usock (full function source)",
    "WS_FIN (macro/constant)",
    "WS_OPCODE_TEXT_FRAME (macro/constant)",
    "WS_OPCODE_CON_CLOSE_FRAME (macro/constant)",
    "Definition/origin of the 'frame' buffer and its length as used by run_usock (e.g. buffer variable, BUFSIZE, recv/read call site)",
    "ssize_t and size_t typedefs / relevant headers",
    "ws_send_frame (full function source)"
  ],
  "explanation": "Why each symbol is needed:\n\n- run_usock (full function source): ws_receive_frame is only called from run_usock. The caller determines the values passed in frame and *length, whether *length can be negative or smaller than the header, and what is done with the returned msg. To determine if any string.h functions are later invoked on msg/frame (and whether those could access out-of-bounds memory) you must inspect run_usock\u2019s code.\n\n- WS_FIN, WS_OPCODE_TEXT_FRAME, WS_OPCODE_CON_CLOSE_FRAME (macros/constants): These constants control which branch of ws_receive_frame is executed and thus how idx_first_mask and idx_first_data are computed. Correct interpretation of these macros is required to compute the mask/data offsets and validate frame indexing against the available buffer.\n\n- Definition/origin of the 'frame' buffer and its length as used by run_usock (e.g. buffer variable, BUFSIZE, recv/read call site): To prove that accesses like frame[idx_first_mask + 0..3] and frame[i] (for i in [idx_first_data, *length)) are within bounds, you must know how big the frame buffer actually is and how many bytes were read into it. This includes where frame is allocated/declared and how *length is initialized/populated in run_usock.\n\n- ssize_t and size_t typedefs / relevant headers: The function mixes signed ssize_t (via *length) and unsigned size_t; casts and arithmetic (e.g. (size_t) *length - idx_first_data) can underflow or produce very large values. You need the exact typedefs to reason about these conversions and integer-wrap/underflow behavior.\n\n- ws_send_frame (full function source): run_usock may pass the msg returned by ws_receive_frame to ws_send_frame (or other functions). If those functions use any <string.h> routines (memcpy/strlen/strcpy/etc.) on msg or frame, they could cause the MISRA violation by accessing beyond the allocated/object bounds. Inspecting ws_send_frame (and any other callees referenced by run_usock that operate on msg/frame) is necessary to conclude compliance.\n\n(Collecting these symbols/source snippets lets the analyst: (1) compute exact index arithmetic in ws_receive_frame, (2) verify that frame[] and msg[] accesses stay within the originating buffers and the malloc'ed block, and (3) check whether any subsequent use invokes <string.h> functions that could access out-of-bounds memory.)"
}