{
  "user_message": "An agent A claimed that the following MHD_digest_auth_calc_userhash code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_calc_userhash.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the prototype of calc_userhash does not use const for input string parameters (for example: void calc_userhash(struct DigestAlgorithm *da, char *username, size_t username_len, char *realm, size_t realm_len, void *userhash_bin); ), then this call discards const by passing const char *username and const char *realm to non-const parameters. That violates MISRA C 2023 Rule 8.13 \u2014 the pointer parameters for the input strings should be declared as const char *. The userhash_bin parameter is an output buffer and should remain non-const.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct in the scenario described. The function shown (MHD_digest_auth_calc_userhash) correctly declares its username and realm parameters as const char *. If the prototype of calc_userhash instead declares its corresponding parameters as plain char * (i.e. non-const), then the call calc_userhash(..., username, ..., realm, ...) would attempt to pass const-qualified pointers to non-const parameters, which discards the const qualifier. MISRA C:2023 Rule 8.13 requires that pointer types be const-qualified whenever possible, so the calc_userhash prototype should accept const char * for input strings if those strings are not modified. The userhash_bin parameter is an output buffer and should remain non-const, as Agent A stated. If calc_userhash truly needs to modify those string buffers, then the prototype should remain non-const and the caller must not pass const data; otherwise change calc_userhash to use const. In short: yes \u2014 under the given condition (calc_userhash prototype lacks const for input strings) there is a violation of Rule 8.13."
}