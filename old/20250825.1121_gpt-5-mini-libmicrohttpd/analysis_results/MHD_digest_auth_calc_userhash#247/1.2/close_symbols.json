{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_calc_userhash': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userhash'], 'callers': ['MHD_digest_auth_calc_userhash_hex', 'add_new_user_entry']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'get_base_digest_algo': {'callees': [], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calc_userhash': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner']}, 'MHD_digest_auth_calc_userhash_hex': {'callees': ['digest_get_hash_size', 'MHD_digest_auth_calc_userhash', 'MHD_bin_to_hex_z'], 'callers': []}, 'add_new_user_entry': {'callees': ['MHD_digest_auth_calc_userhash', 'MHD_digest_auth_calc_userdigest'], 'callers': ['add_new_users']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "MHD_DIGEST_HAS_EXT_ERROR",
    "digest_ext_error",
    "digest_init_one_time",
    "get_base_digest_algo",
    "digest_get_size",
    "calc_userhash",
    "digest_deinit",
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "enum MHD_DigestAuthAlgo3",
    "struct DigestAlgorithm"
  ],
  "explanation": "Explain why each symbol is needed to decide if the target function uses compiler/language extensions:\n\n- _MHD_EXTERN: Macro expanding the function storage-class/visibility; may expand to compiler-specific extensions (e.g. __attribute__, __declspec) \u2014 must inspect its definition to determine use of language extensions.\n\n- MHD_DIGEST_HAS_EXT_ERROR: Conditional compilation macro that enables an extra branch. Its definition (or absence) controls whether digest_ext_error is present in this translation unit; required to know if extension-bearing code is compiled.\n\n- digest_ext_error: If the MHD_DIGEST_HAS_EXT_ERROR branch is active, this symbol\u2019s declaration must be checked for attributes or compiler-specific qualifiers (e.g. __attribute__, calling-convention specifiers) that would constitute language extensions.\n\n- digest_init_one_time: Called at start; its prototype may carry compiler-specific attributes or nonstandard calling conventions. Inspecting it ensures the call site does not rely on extensions.\n\n- get_base_digest_algo: Prototype could use extensions; also needed to determine whether passing enum MHD_DigestAuthAlgo3 to it relies on nonstandard behavior.\n\n- digest_get_size: Prototype/definition may include attributes or nonstandard types; its declaration ensures the size check uses only standard language features.\n\n- calc_userhash: Large call with several parameters \u2014 its prototype may contain attributes (nonnull, format, etc.), nonstandard parameter types or inline/extern inline semantics that are extensions; must inspect.\n\n- digest_deinit: Called at end; its declaration may include extensions (attributes, inline/extern variants) relevant to MISRA rule.\n\n- enum MHD_Result: Definition required to confirm MHD_YES/MHD_NO are standard enum constants (not macros or extension constructs) and to check for any compiler-specific enum extensions.\n\n- MHD_YES and MHD_NO: Ensure they are plain enum constants (or standard macros) and not defined via compiler-specific constructs.\n\n- enum MHD_DigestAuthAlgo3: Its definition is needed to confirm it is a standard enum type (no compiler-specific extensions in its declaration).\n\n- struct DigestAlgorithm: The local variable da is of this type; the struct definition may include compiler-specific extensions (packed, aligned, attributes, bit-field widths or anonymous structs/unions extensions). Inspecting it is necessary to detect language extensions used in its declaration.\n\n(These symbols cover macros, type and function declarations and the struct used directly by the target function \u2014 the places where compiler-specific attributes or extensions would appear and thus are necessary to determine compliance with the MISRA rule.)"
}