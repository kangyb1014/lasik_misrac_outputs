{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_calc_userhash': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userhash'], 'callers': ['MHD_digest_auth_calc_userhash_hex', 'add_new_user_entry']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'get_base_digest_algo': {'callees': [], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calc_userhash': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner']}, 'MHD_digest_auth_calc_userhash_hex': {'callees': ['digest_get_hash_size', 'MHD_digest_auth_calc_userhash', 'MHD_bin_to_hex_z'], 'callers': []}, 'add_new_user_entry': {'callees': ['MHD_digest_auth_calc_userhash', 'MHD_digest_auth_calc_userdigest'], 'callers': ['add_new_users']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "calc_userhash (prototype)",
    "digest_init_one_time (prototype)",
    "get_base_digest_algo (prototype)",
    "digest_get_size (prototype)",
    "digest_deinit (prototype)",
    "digest_ext_error (prototype)",
    "struct DigestAlgorithm (definition)",
    "enum MHD_DigestAuthAlgo3 (definition)",
    "enum MHD_Result (definition) and values MHD_YES/MHD_NO",
    "strlen (declaration)",
    "MHD_DIGEST_HAS_EXT_ERROR (macro definition)"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d we must be sure none of the called routines or macros cause the target function's parameter variables (algo3, username, realm, userhash_bin, bin_buf_size) to be modified. The following symbols are required and why:\n\n- calc_userhash (prototype): to confirm its parameter types (especially the last parameter). If calc_userhash took a pointer-to-pointer or the address of the caller's parameter were passed, that could enable modification of the caller's parameter variable. The prototype shows whether userhash_bin is passed by value (void *) or by reference (void **).\n\n- digest_init_one_time (prototype): to verify it does not accept addresses of any of the target function's parameters (it is called with &da and a value). Ensure it cannot indirectly modify the function parameters by, e.g., expecting pointer-to-caller data.\n\n- get_base_digest_algo (prototype): to show it takes algo3 by value and returns a base-algo value; confirms algo3 is not passed by reference and thus cannot be modified by the call.\n\n- digest_get_size (prototype): to confirm its signature and that it does not accept or mutate any of the target's parameters.\n\n- digest_deinit (prototype): to confirm its signature and that calling it does not modify any of the function parameters.\n\n- digest_ext_error (prototype): guarded by MHD_DIGEST_HAS_EXT_ERROR; if enabled, we need its prototype to ensure it does not take addresses of the target's parameters.\n\n- struct DigestAlgorithm (definition): the target creates a local struct DigestAlgorithm da and passes &da to digest_* functions. Knowing the structure can help determine whether the callee(s) could store pointers into da that alias the function parameters (unlikely but relevant for aliasing analysis).\n\n- enum MHD_DigestAuthAlgo3 (definition): to confirm the enum is passed by value (not some macroed reference) and cannot be modified by the callee.\n\n- enum MHD_Result (definition) and values MHD_YES/MHD_NO: to understand return-value handling (not directly about parameter modification, but needed to reason about control flow and the #ifdef path that could change ret).\n\n- strlen (declaration): to confirm the standard signature (const char *) so calling strlen(username) and strlen(realm) does not modify those pointer parameters.\n\n- MHD_DIGEST_HAS_EXT_ERROR (macro definition): to know whether the digest_ext_error call is compiled in; if it is, include digest_ext_error prototype in the analysis.\n\nThese symbols let the analyzer determine whether any callees are being given addresses of the target function's parameters or otherwise have the capability to assign to the parameter variables themselves. If all prototypes show parameters are passed by value (or pointers to pointees only), then the target function does not violate the MISRA rule (writes to memory pointed to are allowed; assignment to parameter variables would be the violation)."
}