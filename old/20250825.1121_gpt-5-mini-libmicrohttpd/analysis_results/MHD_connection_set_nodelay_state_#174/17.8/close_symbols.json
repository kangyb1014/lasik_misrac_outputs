{
  "user_message": "Target function code is:\n```c\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_connection_set_nodelay_state_': {'callees': ['MHD_DLOG'], 'callers': []}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "_MHD_YES",
    "_MHD_UNKNOWN",
    "MHD_SCKT_OPT_BOOL_",
    "setsockopt",
    "IPPROTO_TCP",
    "TCP_NODELAY",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ENOPROTOOPT_",
    "MHD_SCKT_ENOTSOCK_",
    "HAVE_MESSAGES",
    "MHD_DLOG",
    "MHD_socket_strerr_",
    "bool (stdbool.h)"
  ],
  "explanation": "For checking whether this function modifies its parameters (i.e. reassigns the parameter variables) you must know which referenced symbols could alter the parameter objects or hide modifications by macro expansion or conditional compilation. Brief reasons per symbol:\n\n- struct MHD_Connection: Needed to know the layout and types of fields (is_nonip, sk_nodelay, socket_fd, daemon). Modifying fields of the object pointed to by 'connection' is allowed by the MISRA rule; reassigning the 'connection' parameter itself is not. The struct definition lets you distinguish field writes from pointer reassignments or aliasing.\n\n- _MHD_YES and _MHD_UNKNOWN: These macros/enum values are used in comparisons and assignments to connection->is_nonip; you need their definitions to see whether these expand to expressions that could reassign the parameter itself (unlikely) or have side effects.\n\n- MHD_SCKT_OPT_BOOL_: Typedef/macro for the on_val/off_val type. Included to check whether any unusual macro/typedef hides modifications of parameters (e.g. if it expands to something with side effects).\n\n- setsockopt: External function called with connection->socket_fd and pointer to on_val/off_val. You need its prototype/behavior to ensure it cannot modify the parameter variables (it cannot reassign the local parameter variables, but verifying signature clarifies that).\n\n- IPPROTO_TCP and TCP_NODELAY: Constants/macros used in the setsockopt call and the compile-time TCP_NODELAY guard. TCP_NODELAY in particular controls whether the entire implementation is compiled; you must consider both branches (when TCP_NODELAY is undefined the function contains only (void) casts) to determine if parameters are modified.\n\n- MHD_socket_get_error_: Returns the error code after setsockopt fails; include to verify it has no side effects on the parameters.\n\n- MHD_SCKT_ERR_IS_, MHD_SCKT_EINVAL_, MHD_SCKT_ENOPROTOOPT_, MHD_SCKT_ENOTSOCK_: Error-test macros/constants used in the conditional that leads to assignment to connection->is_nonip. Their definitions are needed to ensure they are pure tests (no hidden assignments to parameters) and to understand the branching that causes writes to the pointed-to object.\n\n- HAVE_MESSAGES: Conditional compilation macro controlling inclusion of MHD_DLOG branches. The presence or absence of logging code affects whether MHD_DLOG (below) is invoked; you must analyze both variants.\n\n- MHD_DLOG: Logging macro/function invoked when HAVE_MESSAGES is set. You need its definition to ensure the logging call does not perform assignments to the function parameters (for example if it's a macro that does unexpected expansions that rebind or modify 'connection' or 'nodelay_state').\n\n- MHD_socket_strerr_: Used to convert an error code to a string in logging. Included to check for side effects (should be none) and to see whether it could modify parameters via macros.\n\n- bool (stdbool.h): The type of the second parameter (nodelay_state). Include to confirm it is a scalar and to check whether any macros typedefs replace 'bool' with e.g. a macro that could be misused.\n\nIn short, include the struct and the macros/ functions used in conditionals, assignments, logging and the compile-time guards. Those symbols let an analyst verify that only fields of *connection are written (permitted) and that neither the pointer parameter 'connection' nor the scalar parameter 'nodelay_state' is reassigned or modified by hidden macro expansions or side effects."
}