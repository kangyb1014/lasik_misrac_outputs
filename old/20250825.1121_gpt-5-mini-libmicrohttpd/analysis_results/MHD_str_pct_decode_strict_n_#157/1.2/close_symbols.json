{
  "user_message": "Target function code is:\n```c\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  if (broken)\n    return 0;\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  if (buf_size >= pct_encoded_len)\n  {\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n          return 0;\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n            return 0;\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          decoded[w] = (char) out;\n        }\n      }\n      else\n        decoded[w] = chr;\n      ++r;\n      ++w;\n    }\n    return w;\n  }\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    if (w >= buf_size)\n      return 0;\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n        return 0;\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        if ((0 > h) || (0 > l))\n          return 0;\n        out =\n          (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)));\n        decoded[w] = (char) out;\n      }\n    }\n    else\n      decoded[w] = chr;\n    ++r;\n    ++w;\n  }\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'toxdigitvalue': {'callees': [], 'callers': ['MHD_strx_to_uint32_', 'MHD_strx_to_uint32_n_', 'MHD_strx_to_uint64_', 'MHD_strx_to_uint64_n_', 'MHD_hex_to_bin', 'MHD_str_pct_decode_strict_n_', 'MHD_str_pct_decode_lenient_n_', 'MHD_str_pct_decode_in_place_strict_', 'MHD_str_pct_decode_in_place_lenient_']}, 'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_FAVOR_SMALL_CODE (preprocessor macro)",
    "toxdigitvalue (function)",
    "MHD_str_pct_decode_lenient_n_ (function)",
    "size_t (type / <stddef.h>)",
    "bool (type / <stdbool.h> or typedef)",
    "uint8_t (type / <stdint.h>)"
  ],
  "explanation": "For checking whether the target function uses compiler language extensions you must know which externally-provided symbols and macros/types are in scope and how they are defined. Each listed symbol is required for the following reasons:\n\n- MHD_FAVOR_SMALL_CODE (preprocessor macro): Controls which branch of the function is compiled. Whether the small-code branch or the main branch is used can change the presence of constructs that might be considered extensions; you must know if this macro is defined in the compilation environment.\n\n- toxdigitvalue (function): The function is called and its prototype/definition may use non-standard attributes, calling conventions, or extension-specific declarations (e.g. GCC attributes, inline variants). Inspecting its declaration/definition is necessary to determine if any language-extension usage propagates into this function\u2019s code or prototypes.\n\n- MHD_str_pct_decode_lenient_n_ (function): Used in the MHD_FAVOR_SMALL_CODE branch; its prototype/definition may introduce extension-specific types or attributes (or use non-standard parameters like implicit bool handling). Knowing its declaration is required to judge whether the compiled branch relies on extensions.\n\n- size_t (type / <stddef.h>): The function signature and internal variables use size_t. You need to confirm that size_t is the standard definition from the C standard headers rather than a compiler-specific typedef or extension.\n\n- bool (type / <stdbool.h> or typedef): The code uses bool (in the small-code branch). Whether this is the standard C99 _Bool/stdbool.h symbol or a project/compiler-specific typedef affects whether a language extension is used.\n\n- uint8_t (type / <stdint.h>): The implementation uses uint8_t casts. You must confirm that uint8_t comes from the standard header (C99) rather than a compiler extension or nonstandard typedef; presence/absence of stdint.h or custom typedefs can affect conformity.\n\n(If you can show standard headers provide size_t/bool/uint8_t and that the two called functions and the macro are standard-project symbols without compiler-specific attributes, then no compiler language extensions are being used in this function.)"
}