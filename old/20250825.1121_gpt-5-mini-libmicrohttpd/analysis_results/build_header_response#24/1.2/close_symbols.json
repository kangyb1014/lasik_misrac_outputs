{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  mhd_assert (c->rp.props.set);\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          ! c->rp.props.chunked,\n                          (! c->rp.props.use_reply_body_headers) &&\n                          (0 ==\n                           (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)),\n                          use_conn_close,\n                          use_conn_k_alive))\n    return MHD_NO;\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}, 'setup_reply_properties': {'callees': ['keepalive_possible', 'is_reply_body_needed'], 'callers': ['build_header_response']}, 'check_connection_reply': {'callees': ['MHD_DLOG'], 'callers': ['build_header_response']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'buffer_append': {'callees': [], 'callers': ['build_header_response']}, 'MHD_uint16_to_str': {'callees': [], 'callers': ['get_date_str', 'build_header_response']}, 'MHD_get_reason_phrase_len_for': {'callees': [], 'callers': ['build_header_response']}, 'MHD_get_reason_phrase_for': {'callees': [], 'callers': ['build_header_response']}, 'get_date_header': {'callees': ['get_date_str'], 'callers': ['build_header_response']}, 'add_user_headers': {'callees': [], 'callers': ['build_header_response']}, 'MHD_uint64_to_str': {'callees': [], 'callers': ['build_header_response']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "setup_reply_properties",
    "check_connection_reply",
    "connection_maximize_write_buffer",
    "buffer_append_s",
    "buffer_append",
    "MHD_uint16_to_str",
    "MHD_uint64_to_str",
    "MHD_get_reason_phrase_len_for",
    "MHD_get_reason_phrase_for",
    "get_date_header",
    "add_user_headers",
    "struct MHD_Connection",
    "struct MHD_Response",
    "c->rp",
    "c->rp.props",
    "c->rp.response",
    "c->rp.responseIcy",
    "c->rp.responseCode",
    "c->rp.props.set",
    "c->rp.props.chunked",
    "c->rp.props.use_reply_body_headers",
    "c->rp.props.use_reply_body_headers",
    "c->rp.props.use_reply_body_headers",
    "c->write_buffer",
    "c->write_buffer_append_offset",
    "c->write_buffer_size",
    "c->keepalive",
    "c->rq.http_ver",
    "c->daemon",
    "c->daemon->options",
    "r->flags",
    "r->flags_auto",
    "r->flags_auto & MHD_RAF_HAS_DATE_HDR",
    "r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR",
    "r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED",
    "r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH",
    "r->total_size",
    "MHD_CONN_MUST_CLOSE",
    "MHD_CONN_USE_KEEPALIVE",
    "MHD_CONN_MUST_UPGRADE",
    "MHD_HTTP_VER_1_0",
    "MHD_HTTP_VERSION_1_1",
    "MHD_HTTP_VERSION_1_0",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_HTTP_HEADER_TRANSFER_ENCODING",
    "MHD_HTTP_HEADER_CONTENT_LENGTH",
    "MHD_RF_SEND_KEEP_ALIVE_HEADER",
    "MHD_RF_HTTP_1_0_SERVER",
    "MHD_RF_INSANITY_HEADER_CONTENT_LENGTH",
    "MHD_RF_HEAD_ONLY_RESPONSE",
    "MHD_RAF_HAS_DATE_HDR",
    "MHD_USE_SUPPRESS_DATE_NO_CLOCK",
    "MHD_SIZE_UNKNOWN",
    "MHD_YES",
    "MHD_NO"
  ],
  "explanation": "To determine whether the target function uses compiler language extensions (violating the MISRA rule), the next analyzer must inspect the definitions and implementations of all macros, functions, types and constants referenced by the function. Any of those definitions may themselves use compiler-specific extensions (e.g. __attribute__, __builtin_..., statement-expressions, typeof, inline asm, alloca, GCC/Clang-specific pragmas or keywords).\n\nWhy each group is required:\n- mhd_assert: a macro; assertions often expand to compiler builtins or use extension-specific constructs. Must inspect its definition.\n- setup_reply_properties, check_connection_reply, connection_maximize_write_buffer, buffer_append_s, buffer_append, MHD_uint16_to_str, MHD_uint64_to_str, MHD_get_reason_phrase_len_for, MHD_get_reason_phrase_for, get_date_header, add_user_headers: these callees may be implemented using language extensions (inline assembly, builtins, compiler-specific attributes, statement-expressions, VLA usage, etc.). Their source or prototypes are needed.\n- struct MHD_Connection, struct MHD_Response and all accessed fields (c->rp, c->rp.props, c->rp.response, c->rp.responseIcy, c->rp.responseCode, c->rp.props.set, c->rp.props.chunked, c->rp.props.use_reply_body_headers, c->write_buffer, c->write_buffer_append_offset, c->write_buffer_size, c->keepalive, c->rq.http_ver, c->daemon, c->daemon->options, r->flags, r->flags_auto, r->total_size): these type and field definitions are required because macros or bit-field definitions, packed attributes, anonymous structs/unions, or other extension uses can appear in struct declarations or field attributes. Also implementation-dependent integer type aliases could hide extensions.\n- All symbolic constants and macros used in conditionals and formatting (MHD_CONN_MUST_CLOSE, MHD_CONN_USE_KEEPALIVE, MHD_CONN_MUST_UPGRADE, MHD_HTTP_VER_1_0, MHD_HTTP_VERSION_1_1, MHD_HTTP_VERSION_1_0, MHD_HTTP_HEADER_CONNECTION, MHD_HTTP_HEADER_TRANSFER_ENCODING, MHD_HTTP_HEADER_CONTENT_LENGTH, MHD_RF_SEND_KEEP_ALIVE_HEADER, MHD_RF_HTTP_1_0_SERVER, MHD_RF_INSANITY_HEADER_CONTENT_LENGTH, MHD_RF_HEAD_ONLY_RESPONSE, MHD_RAF_HAS_DATE_HDR, MHD_USE_SUPPRESS_DATE_NO_CLOCK, MHD_SIZE_UNKNOWN, MHD_YES, MHD_NO): macros/constants may be defined using compiler extensions (complex macro tricks, __extension__, or platform-specific attributes) or be typedefs that hide extensions.\n\nBy supplying the above symbols (their declarations/definitions), the next agent can inspect each definition for explicit compiler extension usage and thus decide whether build_header_response and its dependencies use language extensions."
}