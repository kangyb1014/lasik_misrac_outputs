{
  "user_message": "An agent A claimed that the following MHD_set_connection_option code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_connection_option.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_option (struct MHD_Connection *connection,\n                           enum MHD_CONNECTION_OPTION option,\n                           ...)\n{\n  va_list ap;\n  struct MHD_Daemon *daemon;\n  unsigned int ui_val;\n\n  daemon = connection->daemon;\n  switch (option)\n  {\n  case MHD_CONNECTION_OPTION_TIMEOUT:\n    if (0 == connection->connection_timeout_ms)\n      connection->last_activity = MHD_monotonic_msec_counter ();\n    va_start (ap, option);\n    ui_val = va_arg (ap, unsigned int);\n    va_end (ap);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n    if ((UINT64_MAX / 4000 - 1) < ui_val)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The specified connection timeout (%u) is too \" \\\n                   \"large. Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                   \"instead.\\n\"),\n                ui_val,\n                (UINT64_MAX / 4000 - 1));\n#endif\n      ui_val = UINT64_MAX / 4000 - 1;\n    }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n      if (! connection->suspended)\n      {\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_remove (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_remove (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n        connection->connection_timeout_ms = ((uint64_t) ui_val) * 1000;\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n      }\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    }\n    return MHD_YES;\n  default:\n    return MHD_NO;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe format string is passed through the translation macro '_' (gettext), which in common gettext declarations returns char * (non-const). A format/diagnostic logging API should take a pointer to const char (const-qualified). Using a non-const char * for an immutable string literal/translated message means the pointer is not const-qualified where it could/should be \u2014 this violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_connection_option:\n#define MHD_mutex_lock_chk_(pmutex) do{if(!MHD_mutex_lock_(pmutex))MHD_PANIC(_(\"Failed to lock mutex.\\n\"));\\\n}while(0)\n...\n#define MHD_mutex_unlock_chk_(pmutex) do{if(!MHD_mutex_unlock_(pmutex))MHD_PANIC(_(\"Failed to unlock mutex.\\n\"));\\\n}while(0)\n...\n#define XDLL_remove(head, tail, element) do{mhd_assert((NULL!=(element)->nextX)||((element)==(tail)));mhd_assert((NULL!=(element)->prevX)||((element)==(head)));if(NULL==(element)->prevX){(head)=(element)->nextX;}else{(element)->prevX->nextX=(element)->nextX;}if(NULL==(element)->nextX){(tail)=(element)->prevX;}else{(element)->nextX->prevX=(element)->prevX;}(element)->nextX=NULL;(element)->prevX=NULL;}while(0)\n...\n#define XDLL_insert(head, tail, element) do{mhd_assert(NULL==(element)->nextX);mhd_assert(NULL==(element)->prevX);(element)->nextX=(head);(element)->prevX=NULL;if(NULL==(tail)){(tail)=element;}else{(head)->prevX=element;}(head)=(element);}while(0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is about the types used in declarations \u2014 pointers should point to const-qualified types wherever that is possible. The code you posted does not itself declare any pointer parameter that obviously could be const-qualified: MHD_set_connection_option accepts struct MHD_Connection * and clearly mutates the pointed-to object, so it cannot be const.\n\nThe alleged issue rests on the translation macro _() (gettext) and the logging/panic APIs (MHD_DLOG, MHD_PANIC) rather than on the shown function. Historically gettext() returns char *; that alone does not prove a Rule 8.13 violation in this code. If the logging APIs are declared to take const char * then passing the result of _() (a char *) is fine (adding const is allowed). If, however, the logging APIs are declared to take char * (non-const) when they could/should take const char *, then those declarations would indeed be non-compliant with Rule 8.13. You have not provided the declarations/definitions of MHD_DLOG or MHD_PANIC, so there is no evidence in the snippet that a pointer declaration in this codebase violates Rule 8.13.\n\nConclusion: the report is not supported by the provided code. To confirm or refute definitively, inspect the prototypes of the logging APIs (MHD_DLOG, MHD_PANIC) \u2014 if they use char * for immutable format strings, change them to take const char * to comply with Rule 8.13 (or document an allowable deviation if constrained by external APIs like gettext)."
}