{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_option (struct MHD_Connection *connection,\n                           enum MHD_CONNECTION_OPTION option,\n                           ...)\n{\n  va_list ap;\n  struct MHD_Daemon *daemon;\n  unsigned int ui_val;\n\n  daemon = connection->daemon;\n  switch (option)\n  {\n  case MHD_CONNECTION_OPTION_TIMEOUT:\n    if (0 == connection->connection_timeout_ms)\n      connection->last_activity = MHD_monotonic_msec_counter ();\n    va_start (ap, option);\n    ui_val = va_arg (ap, unsigned int);\n    va_end (ap);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n    if ((UINT64_MAX / 4000 - 1) < ui_val)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The specified connection timeout (%u) is too \" \\\n                   \"large. Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                   \"instead.\\n\"),\n                ui_val,\n                (UINT64_MAX / 4000 - 1));\n#endif\n      ui_val = UINT64_MAX / 4000 - 1;\n    }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n      if (! connection->suspended)\n      {\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_remove (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_remove (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n        connection->connection_timeout_ms = ((uint64_t) ui_val) * 1000;\n        if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       connection);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       connection);\n      }\n#if defined(MHD_USE_THREADS)\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    }\n    return MHD_YES;\n  default:\n    return MHD_NO;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_set_connection_option': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': []}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "enum MHD_Result (definition)",
    "enum MHD_CONNECTION_OPTION (definition)",
    "struct MHD_Connection (definition) and its fields (daemon, connection_timeout_ms, last_activity, suspended, ...)",
    "struct MHD_Daemon (definition) and its fields (connection_timeout_ms, normal_timeout_head, normal_timeout_tail, manual_timeout_head, manual_timeout_tail, cleanup_connection_mutex, ...)",
    "MHD_monotonic_msec_counter (definition)",
    "MHD_D_IS_USING_THREAD_PER_CONN_ (macro/definition)",
    "MHD_mutex_lock_chk_ (macro or function definition)",
    "MHD_mutex_unlock_chk_ (macro or function definition)",
    "XDLL_remove (macro or function definition)",
    "XDLL_insert (macro or function definition)",
    "MHD_DLOG (macro or function definition)",
    "_ (gettext) macro/definition (used inside MHD_DLOG)",
    "PRIu64 (macro from <inttypes.h> or project header)",
    "UINT64_MAX (macro from <stdint.h> or project header)",
    "SIZEOF_UINT64_T and SIZEOF_UNSIGNED_INT (configuration macros)",
    "HAVE_MESSAGES (configuration macro)",
    "MHD_USE_THREADS (configuration macro)",
    "MHD_YES and MHD_NO (enum constant definitions)",
    "__builtin_unreachable (builtin) \u2014 check whether any macro expands to this or other compiler builtins"
  ],
  "explanation": "To decide whether MHD_set_connection_option uses any compiler language extensions you must inspect every macro, typedef, enum and function used or expanded in the function body because extensions are commonly hidden there. Specifically:\n\n- _MHD_EXTERN: may expand to compiler-specific storage/attribute specifiers (e.g. __attribute__, visibility) \u2014 need its definition.\n- enum MHD_Result and MHD_YES/MHD_NO: confirm these are plain standard enums and not implemented with compiler-specific attributes.\n- enum MHD_CONNECTION_OPTION: needed to verify no extension used in its definition.\n- struct MHD_Connection and struct MHD_Daemon (and the named fields): types of fields (e.g. connection_timeout_ms, last_activity, mutex type) may use non\u2011standard integer types, bitfields, or attributes; their definitions can hide extensions (packed, aligned, __attribute__, anonymous structs/unions, etc.).\n- MHD_monotonic_msec_counter: its implementation might call compiler builtins or use extensions (e.g. __builtin_*), so its body must be checked.\n- MHD_D_IS_USING_THREAD_PER_CONN_: macro \u2014 could use GCC extensions (statement expressions, typeof, __builtin_constant_p, etc.).\n- MHD_mutex_lock_chk_ and MHD_mutex_unlock_chk_: often macros wrapping pthread APIs; macros might use extension features or attributes.\n- XDLL_remove and XDLL_insert: could be macros that use statement expressions, typeof, container_of-style nonstandard constructs \u2014 inspect their definitions.\n- MHD_DLOG and _ (gettext): logging macros frequently expand to complex expressions that can use variadic macros or attributes \u2014 need to verify no compiler extensions are used (variadic macros are standard since C99, but other constructs might be used).\n- PRIu64 and UINT64_MAX: standard macros \u2014 included so you can verify they come from standard headers, not redefined with extensions.\n- SIZEOF_UINT64_T, SIZEOF_UNSIGNED_INT, HAVE_MESSAGES, MHD_USE_THREADS: build/configuration macros can change code paths and may be defined to extension-using constructs; need to see their definitions/uses to know which code is active.\n- __builtin_unreachable: explicitly list the builtin because many project macros expand to compiler builtins; if any macro used in the function expands to __builtin_unreachable or other __builtin_* items, that's a violation under this MISRA rule. (The static call graph already shows __builtin_unreachable as reachable; confirm whether that occurs via a macro used here.)\n\nIn short: inspect the above macros, function definitions and type/enum/struct declarations to ensure none expand to or are implemented with compiler-specific language extensions (builtins, __attribute__, inline assembly, statement expressions, typeof, anonymous vendor keywords, etc.)."
}