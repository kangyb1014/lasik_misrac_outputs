{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_run:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run (struct MHD_Daemon *daemon)\n{\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  (void) MHD_run_wait (daemon, 0);\n  return MHD_YES;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n(void) MHD_run_wait (daemon, 0);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.8 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the fragment calls MHD_run_wait(daemon, 0) which passes the pointer value but does not assign to or alter the parameter variable 'daemon' itself. This is allowed \u2014 the object pointed to may be modified by the callee, but the pointer parameter is not changed. A violating scenario would be if the function assigned to the parameter (e.g. daemon = NULL;) or if the code passed &daemon to a callee that modifies the pointer (e.g. MHD_run_wait(&daemon, 0) where the callee takes struct MHD_Daemon ** and writes through it)."
}