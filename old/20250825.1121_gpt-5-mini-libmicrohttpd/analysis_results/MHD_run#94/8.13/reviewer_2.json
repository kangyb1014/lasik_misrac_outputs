{
  "user_message": "An agent A claimed that the following MHD_run code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_run.\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_run (struct MHD_Daemon *daemon)\n{\n  if ( (daemon->shutdown) ||\n       MHD_D_IS_USING_THREADS_ (daemon) )\n    return MHD_NO;\n\n  (void) MHD_run_wait (daemon, 0);\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis fragment may violate Rule 8.13 when MHD_run_wait does not need to modify the daemon object but its parameter is a non-const pointer. For example, if MHD_run_wait is declared as\n\n  enum MHD_Result MHD_run_wait(struct MHD_Daemon *daemon, unsigned int timeout);\n\nand the implementation only reads from *daemon (does not modify it), then the pointer parameter should be declared as const struct MHD_Daemon *daemon and the call (void) MHD_run_wait(daemon, 0); would violate Rule 8.13 because a pointer that can be to const-qualified data is not const-qualified. If, however, MHD_run_wait legitimately modifies the daemon, then no violation occurs.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 requires pointer types to be const-qualified where possible. In the shown MHD_run implementation the daemon parameter is only read (daemon->shutdown and a read-only macro) and MHD_run does not itself modify *daemon, so MHD_run could legitimately take a const struct MHD_Daemon * parameter. Agent A\u2019s scenario about MHD_run_wait is also correct: if MHD_run_wait is declared to take struct MHD_Daemon *daemon but its implementation only reads from *daemon, then that declaration should use const, and the current non-const prototype/usage would be a violation. Conversely, if either MHD_run or MHD_run_wait (or any called macro) legitimately modifies the daemon, then no violation occurs. Thus the agent\u2019s report is correct as a potential/conditional violation \u2014 it depends on the actual declarations/implementations. Action: inspect the prototypes/implementations; if they do not modify *daemon, change parameters to const to comply with Rule 8.13."
}