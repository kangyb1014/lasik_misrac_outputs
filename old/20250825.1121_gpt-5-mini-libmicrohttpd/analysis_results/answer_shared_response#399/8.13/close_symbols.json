{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nanswer_shared_response (void *cls,\n                        struct MHD_Connection *connection,\n                        const char *url,\n                        const char *method,\n                        const char *version,\n                        const char *upload_data,\n                        size_t *upload_data_size,\n                        void **req_cls)\n{\n  static int marker = 0;\n  unsigned int resp_index;\n  static volatile unsigned int last_index = 0;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n  /* This kind of operation does not guarantee that numbers are not reused\n     in parallel threads, when processed simultaneously, but this should not\n     be a big problem, as it just slow down replies a bit due to\n     responses locking. */\n  resp_index = (last_index++) % num_resps;\n  return MHD_queue_response (connection, MHD_HTTP_OK, resps[resp_index]);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'answer_shared_response': {'callees': ['MHD_queue_response'], 'callers': []}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_queue_response (prototype)",
    "struct MHD_Connection (type/definition)",
    "struct MHD_Response (type/definition)",
    "resps (declaration and element type)",
    "num_resps (declaration)",
    "MHD_AccessHandlerCallback (request-handler callback typedef / expected function prototype)"
  ],
  "explanation": "For applying the MISRA rule \u201ca pointer should point to a const-qualified type whenever possible\u201d to answer_shared_response you must know whether each pointer parameter and each object the function uses must be mutable (so cannot be const) or may be const. The listed symbols are required for that judgement:\n\n- MHD_queue_response (prototype): determines the exact parameter types that MHD_queue_response expects (in particular whether it requires a non-const struct MHD_Connection* and whether the response argument is a mutable pointer). If MHD_queue_response requires non-const pointers, the corresponding parameters in answer_shared_response cannot be safely changed to point-to-const.\n\n- struct MHD_Connection (type/definition): needed to know whether the connection object is modified by downstream APIs or must remain mutable; this impacts whether the connection parameter could legally be declared to point to const data.\n\n- struct MHD_Response (type/definition): to determine whether response objects (the elements of resps) are mutable or should be treated as const when passed to MHD_queue_response (affects whether resps elements can be const-qualified).\n\n- resps (declaration and element type): the code indexes resps and passes resps[resp_index] to MHD_queue_response. You need the declaration to know the element pointer type and whether those elements are already const-qualified or are expected to be mutable.\n\n- num_resps (declaration): confirms the relationship and lifetime of the resps array (size and mutability context). While not directly about pointer constness, it is required to fully understand resps usage and whether resps are shared/immutable resources.\n\n- MHD_AccessHandlerCallback (request-handler callback typedef / expected function prototype): the library-defined callback typedef that answer_shared_response must match. This tells you whether parameters such as cls and req_cls are required by the API to be non-const (i.e. the library will call handlers with non-const types or will mutate the pointed-to values). If the API requires specific (non-const) types, the function signature cannot be changed to use const-qualified pointees.\n\nWith these symbols you can determine whether parameters like cls, connection, req_cls and the resps elements could/should be declared to point to const-qualified types without violating the API or causing type mismatches."
}