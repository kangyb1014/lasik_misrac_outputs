{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nanswer_shared_response (void *cls,\n                        struct MHD_Connection *connection,\n                        const char *url,\n                        const char *method,\n                        const char *version,\n                        const char *upload_data,\n                        size_t *upload_data_size,\n                        void **req_cls)\n{\n  static int marker = 0;\n  unsigned int resp_index;\n  static volatile unsigned int last_index = 0;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n  /* This kind of operation does not guarantee that numbers are not reused\n     in parallel threads, when processed simultaneously, but this should not\n     be a big problem, as it just slow down replies a bit due to\n     responses locking. */\n  resp_index = (last_index++) % num_resps;\n  return MHD_queue_response (connection, MHD_HTTP_OK, resps[resp_index]);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'answer_shared_response': {'callees': ['MHD_queue_response'], 'callers': []}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "num_resps",
    "resps",
    "MHD_queue_response",
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "MHD_HTTP_METHOD_GET",
    "MHD_HTTP_METHOD_HEAD",
    "MHD_HTTP_OK",
    "strcmp",
    "NULL",
    "size_t",
    "struct MHD_Connection"
  ],
  "explanation": "For checking whether answer_shared_response uses any compiler language extensions you must inspect the definitions/declarations of all externally referenced symbols and macros that the function depends on. Each listed symbol is required for the following reasons:\n\n- num_resps: global used in the modulus expression. Its definition could be a macro or computed via an extension (e.g. statement-expression macros, GCC builtins) or be a nonstandard object (VLA, special attributes).\n\n- resps: array/indexed response object used as the final argument to MHD_queue_response. Its declaration could be a macro, a flexible/VLA, or have attributes/extension that change how it behaves; it may also be a macro expanding to an expression using compiler extensions.\n\n- MHD_queue_response: the call target. It may be a plain function or a macro/inline function that uses compiler extensions (statement expressions, attributes, inline asm, typeof, etc.). You must examine its definition/prototype to ensure the call site does not rely on extensions.\n\n- enum MHD_Result: the return type of the function. Its definition must be checked for nonstandard extensions (compiler-specific enum layout attributes or nonportable constructs) or macro redefinitions.\n\n- MHD_YES and MHD_NO: return values used by the function. They might be enum constants or macros \u2014 macros could be implemented with compiler extensions (complex macros, statement expressions, or casts that rely on extensions).\n\n- MHD_HTTP_METHOD_GET and MHD_HTTP_METHOD_HEAD: used with strcmp; these are usually macros or string constants. Their definitions could use extension constructs (e.g. GCC string-literal concatenation tricks, statement expressions, or nonstandard token-pasting macros) so must be inspected.\n\n- MHD_HTTP_OK: status code passed to MHD_queue_response. Check its definition (macro/enum) for any extension use.\n\n- strcmp: standard library function used here. Confirm the declaration included (string.h) is standard and not replaced by a macro or extension in this codebase/build environment.\n\n- NULL: used implicitly via pointer comparisons. NULL can be a macro or compiler-provided token; verify it is the standard definition and not an extension.\n\n- size_t: type of upload_data_size parameter. Ensure the typedef comes from a standard header and is not redefined via extensions.\n\n- struct MHD_Connection: the connection type used in the signature. Its definition should be checked for any nonstandard language extensions (compiler-specific attributes, bit-field hacks, embedded assembly, or nonstandard extensions in the struct declaration).\n\nIn summary: to determine whether the target function uses language extensions you must inspect the declarations/definitions of these symbols/macros/types because any of them could hide compiler extensions even though the function's own code appears standard C."
}