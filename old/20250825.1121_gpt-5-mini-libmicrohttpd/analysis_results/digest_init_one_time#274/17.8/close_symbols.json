{
  "user_message": "Target function code is:\n```c\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'MHD_MD5_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'MHD_SHA256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'MHD_SHA512_256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'MHD_digest_auth_calc_userdigest': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userdigest'], 'callers': ['add_new_user_entry']}, 'MHD_digest_auth_calc_userhash': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userhash'], 'callers': ['MHD_digest_auth_calc_userhash_hex', 'add_new_user_entry']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}, 'queue_auth_required_response3_inner': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'digest_init_one_time', 'get_base_digest_algo', 'MHD_get_master', 'digest_get_size', 'MHD_str_quote', 'calculate_add_nonce_with_retry', 'MHD_queue_response'], 'callers': ['MHD_queue_auth_required_response3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct DigestAlgorithm",
    "enum MHD_DigestBaseAlgo",
    "MHD_DIGEST_BASE_ALGO_MD5",
    "MHD_DIGEST_BASE_ALGO_SHA256",
    "MHD_DIGEST_BASE_ALGO_SHA512_256",
    "MHD_DIGEST_BASE_ALGO_INVALID",
    "MHD_MD5_init_one_time",
    "MHD_SHA256_init_one_time",
    "MHD_SHA512_256_init",
    "MHD_MD5_init",
    "MHD_SHA256_init",
    "MHD_SHA512_256_init",
    "MHD_MD5_SUPPORT",
    "MHD_SHA256_SUPPORT",
    "MHD_SHA512_256_SUPPORT",
    "_DEBUG"
  ],
  "explanation": "- struct DigestAlgorithm: needed to know the types of the parameters (that da is a pointer) and the exact members being written (da->algo, da->uninitialised, da->algo_selected, da->ready_for_hashing, da->hashing, da->ctx). This shows whether the function only modifies the object pointed to (allowed) or attempts to modify the pointer itself (disallowed).\n- enum MHD_DigestBaseAlgo: required to verify the type of the parameter 'algo' and to check whether any assignment to the parameter variable could occur or whether constants comparisons are type-correct.\n- MHD_DIGEST_BASE_ALGO_MD5, MHD_DIGEST_BASE_ALGO_SHA256, MHD_DIGEST_BASE_ALGO_SHA512_256, MHD_DIGEST_BASE_ALGO_INVALID: the enum/constants used in comparisons and assignments; inspect their definitions to ensure no macro magic redefines them in a way that could alter or assign the parameter variable.\n- MHD_MD5_init_one_time, MHD_SHA256_init_one_time, MHD_SHA512_256_init: prototypes/definitions are needed to confirm their signatures and bodies (or whether they are macros). If they are macros or contain code, they could potentially modify local parameters (e.g., by referencing 'da' or 'algo') or perform assignments to the parameter variables via macro expansion\u2014so we must inspect them to ensure they do not reassign 'da' or 'algo' or otherwise violate the rule.\n- MHD_MD5_init, MHD_SHA256_init, MHD_SHA512_256_init: the static call graph lists these names (possible alternate macros/aliases). Include them to catch any indirection where the called symbol is an alias that expands to code that might modify parameters.\n- MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, MHD_SHA512_256_SUPPORT: the conditional compilation macros control which branches are compiled. To determine whether parameter-modifying code is present in the actual build, the defined/undefined state of these symbols is required.\n- _DEBUG: controls writes to debug-only fields (da->uninitialised, da->algo_selected, da->ready_for_hashing, da->hashing). Knowing whether _DEBUG is defined tells whether those assignments are compiled; also ensures no assignment to the parameter variables themselves is hidden in debug macros.\n\nIn short: inspect the struct/enum definitions, the constant values/macros, and the called-init functions (and any macro aliases) plus the conditional macros to be certain the function does not reassign the parameter variables (da or algo) either directly or via macro/inline expansion."
}