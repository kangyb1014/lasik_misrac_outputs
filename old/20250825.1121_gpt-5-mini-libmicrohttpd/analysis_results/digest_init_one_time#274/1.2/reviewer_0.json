{
  "user_message": "An agent A claimed that the following digest_init_one_time code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of digest_init_one_time.\n```c\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function is prefixed by the macro _MHD_static_inline, which is defined as a compiler-specific attribute: static inline __attribute__((always_inline)). The use of __attribute__((always_inline)) is a GCC/Clang language extension (documented as such) and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function digest_init_one_time:\n#define _MHD_static_inline staticinline__attribute__((always_inline))\n...\nstruct DigestAlgorithm\n{\n  /**\n   * A context for the digest algorithm, already initialized to be\n   * useful for @e init, @e update and @e digest.\n   */\n  union DigestCtx ctx;\n\n  /**\n   * The hash calculation algorithm.\n   */\n  enum MHD_DigestBaseAlgo algo;\n\n  /**\n   * Buffer for hex-print of the final digest.\n   */\n#ifdef _DEBUG\n  bool uninitialised; /**< The structure has been not set-up */\n  bool algo_selected; /**< The algorithm has been selected */\n  bool ready_for_hashing; /**< The structure is ready to hash data */\n  bool hashing; /**< Some data has been hashed, but the digest has not finalised yet */\n#endif /* _DEBUG */\n}\n...\nenum MHD_DigestBaseAlgo\n{\n  /**\n   * Invalid hash algorithm value\n   */\n  MHD_DIGEST_BASE_ALGO_INVALID = 0,\n\n  /**\n   * MD5 hash algorithm.\n   * As specified by RFC1321\n   */\n  MHD_DIGEST_BASE_ALGO_MD5 = (1 << 0),\n\n  /**\n   * SHA-256 hash algorithm.\n   * As specified by FIPS PUB 180-4\n   */\n  MHD_DIGEST_BASE_ALGO_SHA256 = (1 << 1),\n\n  /**\n   * SHA-512/256 hash algorithm.\n   * As specified by FIPS PUB 180-4\n   */\n  MHD_DIGEST_BASE_ALGO_SHA512_256 = (1 << 2)\n}\n...\n#define MHD_MD5_init_one_time(ctx) MHD_MD5_init(ctx)\n...\nvoid\nMHD_MD5_init (struct Md5Ctx *ctx)\n{\n  /* Initial hash values, see RFC 1321, Clause 3.3 (step 3). */\n  /* Note: values specified in RFC by bytes and should be loaded in\n           little-endian mode, therefore hash values here are initialised with\n           original bytes used in little-endian order. */\n  ctx->H[0] = UINT32_C (0x67452301);\n  ctx->H[1] = UINT32_C (0xefcdab89);\n  ctx->H[2] = UINT32_C (0x98badcfe);\n  ctx->H[3] = UINT32_C (0x10325476);\n\n  /* Initialise the number of bytes. */\n  ctx->count = 0;\n}\n...\n#define MHD_SHA256_init_one_time(ctx) MHD_SHA256_init(ctx)\n...\nvoid\nMHD_SHA256_init (struct Sha256Ctx *ctx)\n{\n  /* Initial hash values, see FIPS PUB 180-4 paragraph 5.3.3 */\n  /* First thirty-two bits of the fractional parts of the square\n   * roots of the first eight prime numbers: 2, 3, 5, 7, 11, 13,\n   * 17, 19.\" */\n  ctx->H[0] = UINT32_C (0x6a09e667);\n  ctx->H[1] = UINT32_C (0xbb67ae85);\n  ctx->H[2] = UINT32_C (0x3c6ef372);\n  ctx->H[3] = UINT32_C (0xa54ff53a);\n  ctx->H[4] = UINT32_C (0x510e527f);\n  ctx->H[5] = UINT32_C (0x9b05688c);\n  ctx->H[6] = UINT32_C (0x1f83d9ab);\n  ctx->H[7] = UINT32_C (0x5be0cd19);\n\n  /* Initialise number of bytes. */\n  ctx->count = 0;\n}\n...\nvoid\nMHD_SHA512_256_init (struct Sha512_256Ctx *ctx)\n{\n  /* Initial hash values, see FIPS PUB 180-4 clause 5.3.6.2 */\n  /* Values generated by \"IV Generation Function\" as described in\n   * clause 5.3.6 */\n  ctx->H[0] = UINT64_C (0x22312194FC2BF72C);\n  ctx->H[1] = UINT64_C (0x9F555FA3C84C64C2);\n  ctx->H[2] = UINT64_C (0x2393B86B6F53B151);\n  ctx->H[3] = UINT64_C (0x963877195940EABD);\n  ctx->H[4] = UINT64_C (0x96283EE2A88EFFE3);\n  ctx->H[5] = UINT64_C (0xBE5E1E2553863992);\n  ctx->H[6] = UINT64_C (0x2B0199FC2C85B8AA);\n  ctx->H[7] = UINT64_C (0x0EB72DDC81C52CA2);\n\n  /* Initialise number of bytes and high part of number of bits. */\n  ctx->count = 0;\n  ctx->count_bits_hi = 0;\n}\n...\n#define MHD_MD5_SUPPORT 1\n...\n#define MHD_SHA256_SUPPORT 1\n...\n#define MHD_SHA512_256_SUPPORT 1\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The function is declared via the macro _MHD_static_inline which expands to a compiler-specific attribute (__attribute__((always_inline))) together with static inline. The GCC/Clang __attribute__((...)) facility is a documented compiler extension; using it therefore constitutes use of a language/compiler extension and contravenes MISRA C 2023 Rule 1.2. To comply, remove or conditionally guard the use of __attribute__ (e.g. provide an empty definition when building for strictly conforming toolchains) or rely on standard 'inline' only, or formally document and justify a deviation."
}