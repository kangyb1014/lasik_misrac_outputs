{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_timeout_millisec_:\n```c\nstatic int64_t\nget_timeout_millisec_ (struct MHD_Daemon *daemon,\n                       int32_t max_timeout)\n{\n  uint64_t d_timeout;\n  mhd_assert (0 <= max_timeout || -1 == max_timeout);\n  if (0 == max_timeout)\n    return 0;\n\n  if (MHD_NO == MHD_get_timeout64 (daemon, &d_timeout))\n    return max_timeout;\n\n  if ((0 < max_timeout) && ((uint64_t) max_timeout < d_timeout))\n    return max_timeout;\n\n  if (INT64_MAX <= d_timeout)\n    return INT64_MAX;\n\n  return (int64_t) d_timeout;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_timeout_millisec_:\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif ((0 < max_timeout) && ((uint64_t) max_timeout < d_timeout))\n    return max_timeout;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The branch is reachable. Example: max_timeout = 100, MHD_get_timeout64(daemon,&d_timeout) succeeds and sets d_timeout = 200. The earlier checks (max_timeout == 0 or MHD_get_timeout64() failure) do not trigger, so the condition ((0 < max_timeout) && ((uint64_t) max_timeout < d_timeout)) is true and the return max_timeout; is executed. Note mhd_assert is a no-op, so it does not make the code unreachable."
}