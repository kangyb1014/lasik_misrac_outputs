{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_timeout_millisec_:\n```c\nstatic int64_t\nget_timeout_millisec_ (struct MHD_Daemon *daemon,\n                       int32_t max_timeout)\n{\n  uint64_t d_timeout;\n  mhd_assert (0 <= max_timeout || -1 == max_timeout);\n  if (0 == max_timeout)\n    return 0;\n\n  if (MHD_NO == MHD_get_timeout64 (daemon, &d_timeout))\n    return max_timeout;\n\n  if ((0 < max_timeout) && ((uint64_t) max_timeout < d_timeout))\n    return max_timeout;\n\n  if (INT64_MAX <= d_timeout)\n    return INT64_MAX;\n\n  return (int64_t) d_timeout;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_timeout_millisec_:\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MHD_NO == MHD_get_timeout64 (daemon, &d_timeout))\n    return max_timeout;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated: the 'return max_timeout;' is reachable when MHD_get_timeout64(daemon,&d_timeout) returns MHD_NO, and there is no definition provided that makes that impossible. This would only violate Rule 2.1 if MHD_get_timeout64 were guaranteed never to return MHD_NO (for example if it were a macro expanding to a constant value != MHD_NO), which would make the branch statically unreachable."
}