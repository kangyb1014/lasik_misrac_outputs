{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_timeout_millisec_:\n```c\nstatic int64_t\nget_timeout_millisec_ (struct MHD_Daemon *daemon,\n                       int32_t max_timeout)\n{\n  uint64_t d_timeout;\n  mhd_assert (0 <= max_timeout || -1 == max_timeout);\n  if (0 == max_timeout)\n    return 0;\n\n  if (MHD_NO == MHD_get_timeout64 (daemon, &d_timeout))\n    return max_timeout;\n\n  if ((0 < max_timeout) && ((uint64_t) max_timeout < d_timeout))\n    return max_timeout;\n\n  if (INT64_MAX <= d_timeout)\n    return INT64_MAX;\n\n  return (int64_t) d_timeout;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_timeout_millisec_:\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout64 (struct MHD_Daemon *daemon,\n                   uint64_t *timeout64)\n{\n  uint64_t earliest_deadline;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *earliest_tmot_conn; /**< the connection with earliest timeout */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Illegal call to MHD_get_timeout.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  if (daemon->data_already_pending\n      || (NULL != daemon->cleanup_head)\n      || daemon->resuming\n      || daemon->have_new\n      || daemon->shutdown)\n  {\n    /* Some data or connection statuses already waiting to be processed. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n       || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n      ) )\n  {\n    /* Some connection(s) already have some data pending. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#endif /* EPOLL_SUPPORT */\n\n  earliest_tmot_conn = NULL;\n  earliest_deadline = 0; /* mute compiler warning */\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout_ms) )\n  {\n    earliest_tmot_conn = pos;\n    earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n  }\n\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n  {\n    if (0 != pos->connection_timeout_ms)\n    {\n      if ( (NULL == earliest_tmot_conn) ||\n           (earliest_deadline - pos->last_activity >\n            pos->connection_timeout_ms) )\n      {\n        earliest_tmot_conn = pos;\n        earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n      }\n    }\n  }\n\n  if (NULL != earliest_tmot_conn)\n  {\n    *timeout64 = connection_get_wait (earliest_tmot_conn);\n    return MHD_YES;\n  }\n  return MHD_NO;\n}\n...\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  mhd_assert (0 != timeout);\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  return mseconds_left;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic int\nget_timeout_millisec_int (struct MHD_Daemon *daemon,\n                          int32_t max_timeout)\n{\n  int64_t res;\n\n  res = get_timeout_millisec_ (daemon, max_timeout);\n#if SIZEOF_INT < SIZEOF_INT64_T\n  if (INT_MAX <= res)\n    return INT_MAX;\n#endif /* SIZEOF_INT < SIZEOF_INT64_T */\n  return (int) res;\n}\n...\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nMHD_epoll (struct MHD_Daemon *daemon,\n           int32_t millisec)\n{\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  static const char *const upgrade_marker = \"upgrade_ptr\";\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n  struct epoll_event events[MAX_EVENTS];\n  struct epoll_event event;\n  int timeout_ms;\n  int num_events;\n  unsigned int i;\n  MHD_socket ls;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  bool run_upgraded = false;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  bool need_to_accept;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO; /* we're down! */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (daemon->connections < daemon->connection_limit) &&\n       (! daemon->listen_socket_in_epoll) &&\n       (! daemon->at_limit) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n  if ( (daemon->was_quiesced) &&\n       (daemon->listen_socket_in_epoll) )\n  {\n    if ( (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          ls,\n                          NULL)) &&\n         (ENOENT != errno) )   /* ENOENT can happen due to race with\n                                  #MHD_quiesce_daemon() */\n      MHD_PANIC (\"Failed to remove listen FD from epoll set.\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if ( ( (! daemon->upgrade_fd_in_epoll) &&\n         (-1 != daemon->epoll_upgrade_fd) ) )\n  {\n    event.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (upgrade_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        daemon->epoll_upgrade_fd,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->upgrade_fd_in_epoll = true;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (daemon->listen_socket_in_epoll) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ||\n         (daemon->was_quiesced) ) )\n  {\n    /* we're at the connection limit, disable listen socket\n for event loop for now */\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        ls,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove listen FD from epoll set.\\n\"));\n    daemon->listen_socket_in_epoll = false;\n  }\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  timeout_ms = get_timeout_millisec_int (daemon, millisec);\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: Used mostly for uniformity here as same situation is\n   * signaled in epoll mode by non-empty eready DLL. */\n  daemon->data_already_pending = false;\n\n  need_to_accept = false;\n  /* drain 'epoll' event queue; need to iterate as we get at most\n     MAX_EVENTS in one system call here; in practice this should\n     pretty much mean only one round, but better an extra loop here\n     than unfair behavior... */\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n  {\n    /* update event masks */\n    num_events = epoll_wait (daemon->epoll_fd,\n                             events,\n                             MAX_EVENTS,\n                             timeout_ms);\n    if (-1 == num_events)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_YES;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_wait failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n    for (i = 0; i < (unsigned int) num_events; i++)\n    {\n      /* First, check for the values of `ptr` that would indicate\n         that this event is not about a normal connection. */\n      if (NULL == events[i].data.ptr)\n        continue;     /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if (upgrade_marker == events[i].data.ptr)\n      {\n        /* activity on an upgraded connection, we process\n           those in a separate epoll() */\n        run_upgraded = true;\n        continue;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n      if (epoll_itc_marker == events[i].data.ptr)\n      {\n        /* It's OK to clear ITC here as all external\n           conditions will be processed later. */\n        MHD_itc_clear_ (daemon->itc);\n        continue;\n      }\n      if (daemon == events[i].data.ptr)\n      {\n        /* Check for error conditions on listen socket. */\n        /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n        if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n          need_to_accept = true;\n        continue;\n      }\n      /* this is an event relating to a 'normal' connection,\n         remember the event and if appropriate mark the\n         connection as 'eready'. */\n      pos = events[i].data.ptr;\n      /* normal processing: update read/write data */\n      if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n      {\n        pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n        if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_insert (daemon->eready_head,\n                       daemon->eready_tail,\n                       pos);\n          pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      }\n      else\n      {\n        if (0 != (events[i].events & EPOLLIN))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n          if ( ( (0 != (MHD_EVENT_LOOP_INFO_READ & pos->event_loop_info)) ||\n                 (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n        if (0 != (events[i].events & EPOLLOUT))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n          if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n      }\n    }\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if (need_to_accept)\n  {\n    unsigned int series_length = 0;\n\n    /* Run 'accept' until it fails or daemon at limit of connections.\n     * Do not accept more then 10 connections at once. The rest will\n     * be accepted on next turn (level trigger is used for listen\n     * socket). */\n    while ( (MHD_NO != MHD_accept_connection (daemon)) &&\n            (series_length < 10) &&\n            (daemon->connections < daemon->connection_limit) &&\n            (! daemon->at_limit) )\n      series_length++;\n  }\n\n  /* Handle timed-out connections; we need to do this here\n     as the epoll mechanism won't call the 'MHD_connection_handle_idle()' on everything,\n     as the other event loops do.  As timeouts do not get an explicit\n     event, we need to find those connections that might have timed out\n     here.\n\n     Connections with custom timeouts must all be looked at, as we\n     do not bother to sort that (presumably very short) list. */\n  prev = daemon->manual_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n  }\n  /* Connections with the default timeout are sorted by prepending\n     them to the head of the list whenever we touch the connection;\n     thus it suffices to iterate from the tail until the first\n     connection is NOT timed out */\n  prev = daemon->normal_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n    if (MHD_CONNECTION_CLOSED != pos->state)\n      break; /* sorted by timeout, no need to visit the rest! */\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (run_upgraded || (NULL != daemon->eready_urh_head))\n    run_epoll_for_upgrade (daemon);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* process events for connections */\n  prev = daemon->eready_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevE;\n    call_handlers (pos,\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_READ_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_ERROR));\n    if (MHD_EPOLL_STATE_IN_EREADY_EDLL ==\n        (pos->epoll_state & (MHD_EPOLL_STATE_SUSPENDED\n                             | MHD_EPOLL_STATE_IN_EREADY_EDLL)))\n    {\n      if ( ((MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_READ_READY)) ) ||\n           ((MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY)) ) ||\n           (MHD_EVENT_LOOP_INFO_CLEANUP == pos->event_loop_info) )\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n    }\n  }\n\n  return MHD_YES;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#if SIZEOF_INT < SIZEOF_INT64_T\n  if (INT_MAX <= res)\n    return INT_MAX;\n#endif /* SIZEOF_INT < SIZEOF_INT64_T */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The conditional compile (#if SIZEOF_INT < SIZEOF_INT64_T) ensures the check exists only when int is smaller than int64_t (typical: int 32-bit, int64_t 64-bit). In that case res (int64_t) can be >= INT_MAX (for example get_timeout_millisec_ can return INT64_MAX), so the runtime test if (INT_MAX <= res) return INT_MAX; can execute and clamps the value before casting to int. Removing this check would change behaviour (possible overflow/truncation), so this is not dead code."
}