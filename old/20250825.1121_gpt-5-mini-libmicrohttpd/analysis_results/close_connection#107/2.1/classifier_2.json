{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of close_connection:\n```c\nstatic void\nclose_connection (struct MHD_Connection *pos)\n{\n  struct MHD_Daemon *daemon = pos->daemon;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    MHD_connection_mark_closed_ (pos);\n    return;   /* must let thread to do the rest */\n  }\n  MHD_connection_close_ (pos,\n                         MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  mhd_assert (! pos->suspended);\n  mhd_assert (! pos->resuming);\n  if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n    XDLL_remove (daemon->normal_timeout_head,\n                 daemon->normal_timeout_tail,\n                 pos);\n  else\n    XDLL_remove (daemon->manual_timeout_head,\n                 daemon->manual_timeout_tail,\n                 pos);\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              pos);\n  DLL_insert (daemon->cleanup_head,\n              daemon->cleanup_tail,\n              pos);\n  daemon->data_already_pending = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function close_connection:\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The mutex lock/unlock lines are conditionally compiled (presence depends on MHD_USE_POSIX_THREADS or MHD_USE_W32_THREADS) and, when present, are reachable at runtime whenever the function does not take the earlier return (the MHD_D_IS_USING_THREAD_PER_CONN_ check is a runtime condition on the daemon). The code fragment therefore is not unreachable in the source; it will be executed in threaded builds and in paths where the early return is not taken. (If the lines are absent because the thread macros are not defined, they simply do not exist in the translation unit \u2014 not an unreachable-code violation.)"
}