{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTPS_SUPPORT",
    "MHD_USE_TLS",
    "struct MHD_Connection (fields: socket_fd, state, daemon, tls_session, epoll_state)",
    "struct MHD_Daemon::options",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "SSIZE_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "EPOLL_SUPPORT",
    "MHD_USE_MSG_MORE",
    "gnutls_record_send (symbol/behavior)",
    "GNUTLS_E_* error codes referenced (e.g. GNUTLS_E_AGAIN, GNUTLS_E_INTERRUPTED, GNUTLS_E_MEMORY_ERROR, GNUTLS_E_PREMATURE_TERMINATION / GNUTLS_E_UNEXPECTED_PACKET_LENGTH, GNUTLS_E_* other codes used)",
    "MHD_send4_ (symbol/behavior)",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_* macros and related errno constants (e.g. MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_ERR_IS_, and the constants passed to it: MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, MHD_SCKT_ENOTCONN_, MHD_SCKT_EINVAL_, MHD_SCKT_EBADF_, and low-resource indicator)"
  ],
  "explanation": "To decide whether any controlling expression in MHD_send_data_ is invariant you must know which tests are compile-time fixed, which depend on (compile-time) macro presence, and which depend on run-time values. The listed symbols are needed for that reasoning:\n\n- HTTPS_SUPPORT: controls whether the code sets tls_conn from daemon->options or forces tls_conn to false. If HTTPS_SUPPORT is not defined then the runtime test if (tls_conn) is an invariant false (possible MISRA issue).\n\n- MHD_USE_TLS: the bitmask flag tested against daemon->options; needed to know whether tls_conn can vary at runtime or is effectively constant.\n\n- struct MHD_Connection (socket_fd, state, daemon, tls_session, epoll_state): the function tests connection->socket_fd and connection->state and uses daemon and tls_session. Knowledge of these fields and their mutability/typical initialization is required to determine whether comparisons such as (MHD_INVALID_SOCKET == s) or (MHD_CONNECTION_CLOSED == connection->state) can ever change at runtime (i.e. might be invariant).\n\n- struct MHD_Daemon::options: contains the options bitmask tested to compute tls_conn; needed to determine whether the options field (and hence tls_conn) can vary at runtime.\n\n- MHD_INVALID_SOCKET and MHD_CONNECTION_CLOSED: the constants compared against connection fields; you need their definitions/values to reason about the comparisons and whether any caller always supplies the matching value.\n\n- SSIZE_MAX and MHD_SCKT_SEND_MAX_SIZE_: used in buffer_size bounds checks that lead to push_data being cleared; these constants determine whether the related if-tests can be invariant for typical/allowed buffer_size ranges.\n\n- EPOLL_SUPPORT: presence/absence controls compilation of epoll-related code paths. Whether those blocks are present changes which controlling expressions exist (and whether they are invariant).\n\n- MHD_USE_MSG_MORE: controls which flags are passed to MHD_send4_; its presence changes which branch is compiled and therefore which tests/arguments occur.\n\n- gnutls_record_send and GNUTLS_E_* error codes referenced: the TLS branch contains many if (GNUTLS_X == ret) checks. To know whether any of those controlling expressions are invariant you must know which GNUTLS error-code identifiers are defined (some tests are conditionally compiled) and that gnutls_record_send can return varying values at runtime.\n\n- MHD_send4_: the plaintext send wrapper whose return value (ret) drives many subsequent if-tests. To argue that tests depending on ret are not invariant you need its semantics (it can return negative errors, partial sends, or full sends).\n\n- MHD_socket_get_error_ and MHD_SCKT_ERR_IS_* macros and the errno constants they reference (MHD_SCKT_EPIPE_, MHD_SCKT_EOPNOTSUPP_, etc.): the post-send error-handling tests are of the form MHD_SCKT_ERR_IS_ (err, X). To show those controlling expressions are not invariant you must know these macros/values and that MHD_socket_get_error_ can return differing errno values.\n\nIn short: to determine if any controlling expression in MHD_send_data_ is invariant you must know (a) which branches are compiled in (HTTPS_SUPPORT, EPOLL_SUPPORT, MHD_USE_MSG_MORE, GNUTLS presence), (b) the definitions of the constants tested (MHD_INVALID_SOCKET, MHD_CONNECTION_CLOSED, SSIZE_MAX, MHD_SCKT_SEND_MAX_SIZE_, GNUTLS error codes, socket errno constants), and (c) whether the runtime values compared (connection fields, daemon->options, return values of gnutls_record_send / MHD_send4_ / MHD_socket_get_error_) can vary. The symbols above cover those compile-time and runtime pieces of information."
}