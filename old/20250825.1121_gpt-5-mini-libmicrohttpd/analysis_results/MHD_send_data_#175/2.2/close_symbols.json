{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (fields: socket_fd, state, daemon, tls_session, epoll_state)",
    "struct MHD_Daemon (field: options)",
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT",
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_DLOG",
    "gnutls_record_send",
    "GNUTLS_E_AGAIN",
    "GNUTLS_E_INTERRUPTED",
    "GNUTLS_E_ENCRYPTION_FAILED",
    "GNUTLS_E_INVALID_SESSION",
    "GNUTLS_E_COMPRESSION_FAILED",
    "GNUTLS_E_EXPIRED",
    "GNUTLS_E_HASH_FAILED",
    "GNUTLS_E_PUSH_ERROR",
    "GNUTLS_E_INTERNAL_ERROR",
    "GNUTLS_E_CRYPTODEV_IOCTL_ERROR",
    "GNUTLS_E_CRYPTODEV_DEVICE_ERROR",
    "GNUTLS_E_PREMATURE_TERMINATION",
    "GNUTLS_E_UNEXPECTED_PACKET_LENGTH",
    "GNUTLS_E_MEMORY_ERROR",
    "MHD_send4_",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_EBADF_",
    "MHD_socket error codes / errno mapping used by the above macros",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_TLS_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_BADF_",
    "EPOLL_SUPPORT",
    "enum MHD_EpollState (symbol MHD_EPOLL_STATE_WRITE_READY)",
    "MHD_USE_MSG_MORE",
    "MSG_MORE",
    "SSIZE_MAX"
  ],
  "explanation": "To decide whether any executed operation in MHD_send_data_ is actually dead (i.e. its removal would not change program behaviour) the analyzer must know the definitions, semantics and side-effects of all relevant types, macros, functions, constants and fields that affect control flow or produce side-effects. Brief reasons by symbol group: \n\n- struct MHD_Connection / struct MHD_Daemon / MHD_socket / MHD_INVALID_SOCKET / MHD_CONNECTION_CLOSED: these define the runtime checks at the top of the function (socket validity and connection state). Whether those checks are ever true/false (and whether related operations are therefore executed) depends on the structures and their possible values.\n\n- MHD_USE_TLS / HTTPS_SUPPORT: determine tls_conn (compile-time and runtime). Whether the entire TLS branch is present or absent (and hence whether its operations are potentially dead) depends on these macros.\n\n- pre_send_setopt / post_send_setopt / MHD_DLOG: these functions are called and may have side-effects (socket options, logging, state changes). To decide if their calls are removable (dead) you must know whether they change observable program behaviour.\n\n- gnutls_record_send and GNUTLS_* error codes: the TLS send path and its many error-specific return/side-effect behaviours hinge on gnutls_record_send semantics and which error codes can occur. Removing TLS-path error handling (or calls) could change behaviour unless these calls are proven to be effect-free.\n\n- MHD_send4_ and MHD_SCKT_SEND_MAX_SIZE_: the plaintext send path uses MHD_send4_ and may truncate buffer_size. The function's return semantics (amount sent, error codes) are critical to determine whether later branches (error handling, epoll_state changes, post_send_setopt calls) are meaningful.\n\n- MHD_socket_get_error_ and the MHD_SCKT_ERR_IS_* macros plus associated MHD_SCKT_* error constants / errno mapping: these determine which error-handling branches run after a failing send. Whether those checks (and subsequent returns/state changes) are dead requires knowing how error values map and whether the macros have side-effects.\n\n- MHD_ERR_* return constants: these are the externally observable return values from the function. To know if a returned value/path is removable (dead), the exact meaning and use of these constants in the rest of the system must be known.\n\n- EPOLL_SUPPORT / enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY / epoll_state field: code clears/write-ready bits when certain send results occur. These bit changes are observable (affect event loop). To decide if those bit-manipulations are dead, the analyzer must know the epoll semantics and the epoll_state field layout.\n\n- MHD_USE_MSG_MORE / MSG_MORE: affect flags to the send call; this can change network behaviour (when data is pushed), so their semantics matter for dead-code reasoning.\n\n- SSIZE_MAX: truncation to SSIZE_MAX affects buffer_size and push_data flow; needed to reason if truncation branch or subsequent post_send_setopt calls are necessary.\n\nIn short, all listed symbols can affect control-flow, observable side-effects, or return values of MHD_send_data_. The analyzer needs their definitions and semantics to prove that a particular executed operation within MHD_send_data_ can be removed without changing program behaviour (i.e. to establish dead code under MISRA C)."
}