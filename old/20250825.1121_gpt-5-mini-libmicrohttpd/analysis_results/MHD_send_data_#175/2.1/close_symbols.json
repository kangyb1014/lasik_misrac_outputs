{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (fields: socket_fd, daemon, state, tls_session, epoll_state)",
    "struct MHD_Daemon (field: options)",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT",
    "EPOLL_SUPPORT",
    "MHD_USE_MSG_MORE",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "SSIZE_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "pre_send_setopt",
    "post_send_setopt",
    "gnutls_record_send",
    "GNUTLS_E_AGAIN",
    "GNUTLS_E_INTERRUPTED",
    "GNUTLS_E_ENCRYPTION_FAILED",
    "GNUTLS_E_INVALID_SESSION",
    "GNUTLS_E_COMPRESSION_FAILED",
    "GNUTLS_E_EXPIRED",
    "GNUTLS_E_HASH_FAILED",
    "GNUTLS_E_PUSH_ERROR",
    "GNUTLS_E_INTERNAL_ERROR",
    "GNUTLS_E_CRYPTODEV_IOCTL_ERROR",
    "GNUTLS_E_CRYPTODEV_DEVICE_ERROR",
    "GNUTLS_E_PREMATURE_TERMINATION",
    "GNUTLS_E_UNEXPECTED_PACKET_LENGTH",
    "GNUTLS_E_MEMORY_ERROR",
    "MHD_send4_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_ (generic socket-error matcher)",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EBADF_",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_TLS_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_BADF_",
    "enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY",
    "MSG_MORE",
    "ssize_t / size_t"
  ],
  "explanation": "For determining unreachable code you must know which branches and returns can ever be taken and which conditional/compile-time constants make blocks dead. Brief reasons: \n\n- struct MHD_Connection (fields: socket_fd, daemon, state, tls_session, epoll_state): the function reads these fields to decide early return, TLS path, and to mutate epoll_state. Knowledge of their types/values is required to see if branches (early return, TLS branch, epoll clears) are ever reachable.\n- struct MHD_Daemon (field: options): daemon->options is inspected to compute tls_conn; its layout and possible values determine whether tls_conn can be true at runtime.\n- MHD_USE_TLS: bitmask tested against daemon->options; required to know if tls_conn can be non-zero when HTTPS_SUPPORT is enabled.\n- HTTPS_SUPPORT: controls compilation of the TLS code and the tls_conn initialization (when undefined tls_conn is set to false at compile time). Required to decide whether the entire TLS branch is compile-time or effectively unreachable.\n- EPOLL_SUPPORT: surrounds several blocks that clear epoll_state; needed to know whether those blocks exist in the compiled code (affects reachability of those statements).\n- MHD_USE_MSG_MORE: selects which call to MHD_send4_ is used (with MSG_MORE argument or not); affects control-flow and which lines remain in the compilation unit.\n- MHD_INVALID_SOCKET / MHD_CONNECTION_CLOSED: compared early to decide immediate return; must know their definitions/values to determine if the early return path is feasible.\n- SSIZE_MAX: used to clamp buffer_size and to set push_data=false; needed to check whether that branch can trigger and thus whether subsequent code using ret is reachable.\n- MHD_SCKT_SEND_MAX_SIZE_: similar to SSIZE_MAX for plaintext path; necessary to know if the non-TLS size-clamp branch is reachable.\n- pre_send_setopt / post_send_setopt: called in both paths \u2014 if either is a noreturn function (or can longjmp/exit), they would make subsequent code unreachable. Their semantics must be known.\n- gnutls_record_send and GNUTLS_E_* macros (all listed): the TLS branch heavily depends on the return semantics and error codes of gnutls_record_send; to decide which returns/exits are possible and whether some post-checks are reachable you must know these constants and the function prototype/return type.\n- GNUTLS_E_PREMATURE_TERMINATION / GNUTLS_E_UNEXPECTED_PACKET_LENGTH: these compile-time defines gate additional error checks; they change whether some checks/returns exist \u2014 relevant to reachability.\n- GNUTLS_E_MEMORY_ERROR: checked to return NOMEM; needed to determine that error path reachability.\n- MHD_send4_: plaintext send call; its return semantics (negative on error, value meaning) control which error-handling branches are reachable.\n- MHD_socket_get_error_ and the set of MHD_SCKT_ERR_IS_* / MHD_SCKT_E* macros: the negative-return error-handling cascade depends entirely on these macros and the error codes produced by MHD_socket_get_error_. To know which of those many branches are reachable you must know the error-code domain and macros.\n- MHD_ERR_* return symbols: these constants are used at many exit points; needed to map each branch to an actual return (and to recognize duplicates or unreachable duplicates).\n- enum MHD_EpollState / MHD_EPOLL_STATE_WRITE_READY: epoll_state masking/unmasking is guarded by EPOLL_SUPPORT; you must know the enum and macro to understand the epoll-related statements' presence.\n- MSG_MORE: used as an argument when MHD_USE_MSG_MORE is defined; required to know variant of the call present.\n- ssize_t / size_t: types for ret and buffer_size; needed to reason about comparisons (e.g., ret < 0, buffer_size == (size_t) ret) and whether casts can make branches constant/unreachable.\n\nIn short: these symbols determine which conditional blocks exist at compile time (#ifdefs), whether runtime conditions (tls_conn, error codes, socket values) can evaluate true/false, and whether callees can abort/longjmp \u2014 all necessary to decide whether any source statement in MHD_send_data_ is unreachable under the project's configuration and runtime semantics."
}