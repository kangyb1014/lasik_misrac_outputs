{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ncall_handlers (struct MHD_Connection *con,\n               bool read_ready,\n               bool write_ready,\n               bool force_close)\n{\n  enum MHD_Result ret;\n  bool states_info_processed = false;\n  /* Fast track flag */\n  bool on_fasttrack = (con->state == MHD_CONNECTION_INIT);\n  ret = MHD_YES;\n\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 != (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (con->tid)));\n\n#ifdef HTTPS_SUPPORT\n  if (con->tls_read_ready)\n    read_ready = true;\n#endif /* HTTPS_SUPPORT */\n  if ( (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) &&\n       (read_ready || (force_close && con->sk_nonblck)) )\n  {\n    MHD_connection_handle_read (con, force_close);\n    mhd_assert (! force_close || MHD_CONNECTION_CLOSED == con->state);\n    ret = MHD_connection_handle_idle (con);\n    if (force_close)\n      return ret;\n    states_info_processed = true;\n  }\n  if (! force_close)\n  {\n    /* No need to check value of 'ret' here as closed connection\n     * cannot be in MHD_EVENT_LOOP_INFO_WRITE state. */\n    if ( (MHD_EVENT_LOOP_INFO_WRITE == con->event_loop_info) &&\n         write_ready)\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n      states_info_processed = true;\n    }\n  }\n  else\n  {\n    MHD_connection_close_ (con,\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return MHD_connection_handle_idle (con);\n  }\n\n  if (! states_info_processed)\n  {   /* Connection is not read or write ready, but external conditions\n       * may be changed and need to be processed. */\n    ret = MHD_connection_handle_idle (con);\n  }\n  /* Fast track for fast connections. */\n  /* If full request was read by single read_handler() invocation\n     and headers were completely prepared by single MHD_connection_handle_idle()\n     then try not to wait for next sockets polling and send response\n     immediately.\n     As writeability of socket was not checked and it may have\n     some data pending in system buffers, use this optimization\n     only for non-blocking sockets. */\n  /* No need to check 'ret' as connection is always in\n   * MHD_CONNECTION_CLOSED state if 'ret' is equal 'MHD_NO'. */\n  else if (on_fasttrack && con->sk_nonblck)\n  {\n    if (MHD_CONNECTION_HEADERS_SENDING == con->state)\n    {\n      MHD_connection_handle_write (con);\n      /* Always call 'MHD_connection_handle_idle()' after each read/write. */\n      ret = MHD_connection_handle_idle (con);\n    }\n    /* If all headers were sent by single write_handler() and\n     * response body is prepared by single MHD_connection_handle_idle()\n     * call - continue. */\n    if ((MHD_CONNECTION_NORMAL_BODY_READY == con->state) ||\n        (MHD_CONNECTION_CHUNKED_BODY_READY == con->state))\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n    }\n  }\n\n  /* All connection's data and states are processed for this turn.\n   * If connection already has more data to be processed - use\n   * zero timeout for next select()/poll(). */\n  /* Thread-per-connection do not need global zero timeout as\n   * connections are processed individually. */\n  /* Note: no need to check for read buffer availability for\n   * TLS read-ready connection in 'read info' state as connection\n   * without space in read buffer will be marked as 'info block'. */\n  if ( (! con->daemon->data_already_pending) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (con->daemon)) )\n  {\n    if (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info))\n      con->daemon->data_already_pending = true;\n#ifdef HTTPS_SUPPORT\n    else if ( (con->tls_read_ready) &&\n              (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n      con->daemon->data_already_pending = true;\n#endif /* HTTPS_SUPPORT */\n  }\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}, 'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'MHD_poll_all': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'call_handlers'], 'callers': ['MHD_poll', 'MHD_run_wait']}, 'MHD_epoll': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'resume_suspended_connections', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'MHD_connection_handle_idle', 'call_handlers'], 'callers': ['MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_thread_handle_ID_is_valid_ID_",
    "MHD_thread_handle_ID_is_current_thread_",
    "HTTPS_SUPPORT",
    "struct MHD_Connection",
    "daemon (type of con->daemon) and its fields: options, data_already_pending",
    "con->tid (type of tid)",
    "con->tls_read_ready",
    "con->sk_nonblck",
    "con->event_loop_info",
    "MHD_EVENT_LOOP_INFO_READ",
    "MHD_EVENT_LOOP_INFO_WRITE",
    "MHD_EVENT_LOOP_INFO_PROCESS",
    "MHD_USE_SELECT_INTERNALLY",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "enum MHD_Result (definition) and values MHD_YES, MHD_NO",
    "MHD_CONNECTION_INIT",
    "MHD_CONNECTION_HEADERS_SENDING",
    "MHD_CONNECTION_NORMAL_BODY_READY",
    "MHD_CONNECTION_CHUNKED_BODY_READY",
    "MHD_CONNECTION_CLOSED",
    "MHD_connection_handle_read (declaration/definition)",
    "MHD_connection_handle_write (declaration/definition)",
    "MHD_connection_handle_idle (declaration/definition)",
    "MHD_connection_close_ (declaration/definition)"
  ],
  "explanation": "For determining whether call_handlers violates the MISRA rule prohibiting compiler language extensions we must inspect any macros, types or callees that could introduce compiler-specific extensions into the code path of call_handlers. Explanation for each symbol:\n\n- mhd_assert: This macro appears in call_handlers and could expand to compiler-specific builtins, statement-expressions, attributes or asm \u2014 inspect its definition to see if it uses any documented compiler extensions.\n- MHD_thread_handle_ID_is_valid_ID_: Might be a macro or inline function that uses compiler intrinsics or extensions (e.g. __builtin_*, asm, attributes). The assertions call it, so its implementation could introduce extensions into call_handlers.\n- MHD_thread_handle_ID_is_current_thread_: Same rationale as above \u2014 its definition may use compiler-specific facilities.\n- HTTPS_SUPPORT: Preprocessor conditional alters compiled code; when defined the function uses con->tls_read_ready. The TLS-related code (enabled only when HTTPS_SUPPORT is defined) could rely on non-standard extensions \u2014 need to check how HTTPS_SUPPORT is defined and what code it exposes.\n- struct MHD_Connection: The layout and field types (and any attributes on the struct or fields) must be inspected for use of compiler extensions (e.g. __attribute__, packed, bit-field extensions, flexible array usage that relies on extensions).\n- daemon (type of con->daemon) and its fields: options and data_already_pending: The code reads daemon->options and assigns data_already_pending. The daemon type and those fields could be declared using extensions (attributes, bitfields, nonstandard types) that would make the usage in call_handlers depend on extensions.\n- con->tid (type of tid): The tid type and its related helper functions/macros might use platform-specific thread primitives or extensions \u2014 inspect definition to ensure no compiler extensions used.\n- con->tls_read_ready: This field is used under HTTPS_SUPPORT; verify its declaration for extensions.\n- con->sk_nonblck: Used to decide fasttrack behavior; inspect declaration for attributes/extensions.\n- con->event_loop_info: Bitwise ops are used; the type or constants could be defined via extensions (e.g. enum with explicit width via compiler extension) \u2014 need its definition.\n- MHD_EVENT_LOOP_INFO_READ / MHD_EVENT_LOOP_INFO_WRITE / MHD_EVENT_LOOP_INFO_PROCESS: These macros/constants control conditional logic in call_handlers. Their definitions might use non-standard constructs (e.g. computed expressions using typeof, statement expressions) \u2014 inspect them.\n- MHD_USE_SELECT_INTERNALLY: This option flag is bit-tested in assertions; its definition (macro/enum) should be checked for extensions.\n- MHD_D_IS_USING_THREAD_PER_CONN_: This macro or inline function is used in a conditional; its definition could expand to compiler-specific constructs \u2014 inspect it.\n- enum MHD_Result and values MHD_YES, MHD_NO: The return type and constants must be checked to ensure they are standard C (no compiler-specific underlying type specifier or attributes on the enum or constants).\n- MHD_CONNECTION_* state constants: (MHD_CONNECTION_INIT, MHD_CONNECTION_HEADERS_SENDING, MHD_CONNECTION_NORMAL_BODY_READY, MHD_CONNECTION_CHUNKED_BODY_READY, MHD_CONNECTION_CLOSED) \u2014 their definitions may be enums or macros that use extensions; inspect to ensure no language extensions are present.\n- MHD_connection_handle_read / MHD_connection_handle_write / MHD_connection_handle_idle / MHD_connection_close_: The called functions may be declared with compiler-specific attributes (e.g. __attribute__((noreturn)), inline assembly, or use GCC builtins in their prototypes or macros). Even if the extension lives in the callee, it may be introduced into the translation unit visible at the call site via macros/inline definitions. To be safe, inspect their declarations/definitions for use of documented compiler extensions.\n\nCollectively, these symbols cover all macros, types, fields and callees used directly in call_handlers that could cause the function to rely on compiler language extensions. Inspecting their definitions will allow a precise determination whether call_handlers \u2014 as written and as expanded by macros \u2014 uses any compiler-documented language extensions."
}