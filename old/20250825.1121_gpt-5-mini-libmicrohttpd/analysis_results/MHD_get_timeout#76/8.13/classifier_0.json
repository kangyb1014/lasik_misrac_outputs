{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_timeout:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout (struct MHD_Daemon *daemon,\n                 MHD_UNSIGNED_LONG_LONG *timeout)\n{\n  uint64_t t64;\n  if (MHD_NO == MHD_get_timeout64 (daemon, &t64))\n    return MHD_NO;\n\n#if SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG\n  if (ULLONG_MAX <= t64)\n    *timeout = ULLONG_MAX;\n  else\n#endif /* SIZEOF_UINT64_T > SIZEOF_UNSIGNED_LONG_LONG */\n  *timeout = (MHD_UNSIGNED_LONG_LONG) t64;\n  return MHD_YES;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MHD_NO == MHD_get_timeout64 (daemon, &t64))\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: &t64 is being passed as an output parameter to MHD_get_timeout64 and therefore must be a pointer to a non-const uint64_t so the function can store the timeout value. Rule 8.13 recommends using const for pointers that could be read-only, but here the object is intended to be written. (If, contrary to intent, MHD_get_timeout64 actually does not modify the pointed object, then the function signature \u2014 not this call site \u2014 would need const qualification.)"
}