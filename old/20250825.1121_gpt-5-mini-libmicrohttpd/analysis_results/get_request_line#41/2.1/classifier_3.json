{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_request_line:\n```c\nstatic bool\nget_request_line (struct MHD_Connection *c)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Parse whitespace in URI, special parsing of the request line */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n\n  if (! get_request_line_inner (c))\n  {\n    /* End of the request line has not been found yet */\n    mhd_assert ((! wsp_in_uri) || NULL == c->rq.version);\n    if ((NULL != c->rq.version) &&\n        (HTTP_VER_LEN <\n         (c->rq.hdrs.rq_line.proc_pos\n          - (size_t) (c->rq.version - c->read_buffer))))\n    {\n      c->rq.http_ver = MHD_HTTP_VER_INVALID;\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_MALFORMED);\n      return true; /* Error in the request */\n    }\n    return false;\n  }\n  if (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state)\n    return true; /* Error in the request */\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  if (0 != c->rq.hdrs.rq_line.num_ws_in_uri)\n  {\n    if (! wsp_in_uri)\n    {\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      RQ_TARGET_INVALID_CHAR);\n      return true; /* Error in the request */\n    }\n    if (! wsp_in_uri_keep)\n    {\n      send_redirect_fixed_rq_target (c);\n      return true; /* Error in the request */\n    }\n  }\n  if (! process_request_target (c))\n    return true; /* Error in processing */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVED;\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_request_line:\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_Daemon\n{\n\n  /**\n   * Callback function for all requests.\n   */\n  MHD_AccessHandlerCallback default_handler;\n\n  /**\n   * Closure argument to default_handler.\n   */\n  void *default_handler_cls;\n\n  /**\n   * Daemon's flags (bitfield).\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  enum MHD_FLAG options;\n\n  /**\n   * Head of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_head;\n\n  /**\n   * Tail of doubly-linked list of new, externally added connections.\n   */\n  struct MHD_Connection *new_connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current, active connections.\n   */\n  struct MHD_Connection *connections_tail;\n\n  /**\n   * Head of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_head;\n\n  /**\n   * Tail of doubly-linked list of our current but suspended connections.\n   */\n  struct MHD_Connection *suspended_connections_tail;\n\n  /**\n   * Head of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_head;\n\n  /**\n   * Tail of doubly-linked list of connections to clean up.\n   */\n  struct MHD_Connection *cleanup_tail;\n\n  /**\n   * _MHD_YES if the @e listen_fd socket is a UNIX domain socket.\n   */\n  enum MHD_tristate listen_is_unix;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Head of EDLL of connections ready for processing (in epoll mode).\n   */\n  struct MHD_Connection *eready_head;\n\n  /**\n   * Tail of EDLL of connections ready for processing (in epoll mode)\n   */\n  struct MHD_Connection *eready_tail;\n\n  /**\n   * File descriptor associated with our epoll loop.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  int epoll_fd;\n\n  /**\n   * true if the @e listen_fd socket is in the 'epoll' set,\n   * false if not.\n   */\n  bool listen_socket_in_epoll;\n\n#ifdef UPGRADE_SUPPORT\n#ifdef HTTPS_SUPPORT\n  /**\n   * File descriptor associated with the #run_epoll_for_upgrade() loop.\n   * Only available if #MHD_USE_HTTPS_EPOLL_UPGRADE is set.\n   */\n  int epoll_upgrade_fd;\n\n  /**\n   * true if @e epoll_upgrade_fd is in the 'epoll' set,\n   * false if not.\n   */\n  bool upgrade_fd_in_epoll;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Head of EDLL of upgraded connections ready for processing (in epoll mode).\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_head;\n\n  /**\n   * Tail of EDLL of upgraded connections ready for processing (in epoll mode)\n   */\n  struct MHD_UpgradeResponseHandle *eready_urh_tail;\n#endif /* UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * Head of the XDLL of ALL connections with a default ('normal')\n   * timeout, sorted by timeout (earliest at the tail, most recently\n   * used connection at the head).  MHD can just look at the tail of\n   * this list to determine the timeout for all of its elements;\n   * whenever there is an event of a connection, the connection is\n   * moved back to the tail of the list.\n   *\n   * All connections by default start in this list; if a custom\n   * timeout that does not match @e connection_timeout_ms is set, they\n   * are moved to the @e manual_timeout_head-XDLL.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode as each thread\n   * needs only one connection-specific timeout.\n   */\n  struct MHD_Connection *normal_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a default timeout,\n   * sorted by timeout (earliest timeout at the tail).\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *normal_timeout_tail;\n\n  /**\n   * Head of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.  MHD will do a O(n) scan over this list to\n   * determine the current timeout.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_head;\n\n  /**\n   * Tail of the XDLL of ALL connections with a non-default/custom\n   * timeout, unsorted.\n   * Not used in MHD_USE_THREAD_PER_CONNECTION mode.\n   */\n  struct MHD_Connection *manual_timeout_tail;\n\n  /**\n   * Function to call to check if we should accept or reject an\n   * incoming request.  May be NULL.\n   */\n  MHD_AcceptPolicyCallback apc;\n\n  /**\n   * Closure argument to apc.\n   */\n  void *apc_cls;\n\n  /**\n   * Function to call when we are done processing\n   * a particular request.  May be NULL.\n   */\n  MHD_RequestCompletedCallback notify_completed;\n\n  /**\n   * Closure argument to @e notify_completed.\n   */\n  void *notify_completed_cls;\n\n  /**\n   * Function to call when we are starting/stopping\n   * a connection.  May be NULL.\n   */\n  MHD_NotifyConnectionCallback notify_connection;\n\n  /**\n   * Closure argument to @e notify_connection.\n   */\n  void *notify_connection_cls;\n\n  /**\n   * Function to call with the full URI at the\n   * beginning of request processing.  May be NULL.\n   * <p>\n   * Returns the initial pointer to internal state\n   * kept by the client for the request.\n   */\n  LogCallback uri_log_callback;\n\n  /**\n   * Closure argument to @e uri_log_callback.\n   */\n  void *uri_log_callback_cls;\n\n  /**\n   * Function to call when we unescape escape sequences.\n   */\n  UnescapeCallback unescape_callback;\n\n  /**\n   * Closure for @e unescape_callback.\n   */\n  void *unescape_callback_cls;\n\n  /**\n   * Listen port.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  uint16_t port;\n\n#ifdef HAVE_MESSAGES\n  /**\n   * Function for logging error messages (if we\n   * support error reporting).\n   */\n  MHD_LogCallback custom_error_log;\n\n  /**\n   * Closure argument to @e custom_error_log.\n   */\n  void *custom_error_log_cls;\n#endif\n\n  /**\n   * Pointer to master daemon (NULL if this is the master)\n   */\n  struct MHD_Daemon *master;\n\n  /**\n   * Listen socket.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  MHD_socket listen_fd;\n\n  /**\n   * Listen socket is non-blocking.\n   */\n  bool listen_nonblk;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Worker daemons (one per thread)\n   */\n  struct MHD_Daemon *worker_pool;\n#endif\n\n  /**\n   * Table storing number of connections per IP\n   */\n  void *per_ip_connection_count;\n\n  /**\n   * Number of active parallel connections.\n   *\n   * @remark Keep this member after pointer value to keep it\n   * properly aligned as it will be used as member of union MHD_DaemonInfo.\n   */\n  unsigned int connections;\n\n  /**\n   * Size of the per-connection memory pools.\n   */\n  size_t pool_size;\n\n  /**\n   * Increment for growth of the per-connection memory pools.\n   */\n  size_t pool_increment;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Size of threads created by MHD.\n   */\n  size_t thread_stack_size;\n\n  /**\n   * Number of worker daemons\n   */\n  unsigned int worker_pool_size;\n\n  /**\n   * The select thread handle (if we have internal select)\n   */\n  MHD_thread_handle_ID_ tid;\n\n  /**\n   * Mutex for per-IP connection counts.\n   */\n  MHD_mutex_ per_ip_connection_mutex;\n\n  /**\n   * Mutex for (modifying) access to the \"cleanup\", \"normal_timeout\" and\n   * \"manual_timeout\" DLLs.\n   */\n  MHD_mutex_ cleanup_connection_mutex;\n\n  /**\n   * Mutex for any access to the \"new connections\" DL-list.\n   */\n  MHD_mutex_ new_connections_mutex;\n#endif\n\n  /**\n   * Our #MHD_OPTION_SERVER_INSANITY level, bits indicating\n   * which sanity checks are off.\n   */\n  enum MHD_DisableSanityCheck insanity_level;\n\n  /**\n   * Whether to allow/disallow/ignore reuse of listening address.\n   * The semantics is the following:\n   * 0: ignore (user did not ask for neither allow/disallow, use SO_REUSEADDR\n   *    except W32)\n   * >0: allow (use SO_REUSEPORT on most platforms, SO_REUSEADDR on Windows)\n   * <0: disallow (mostly no action, SO_EXCLUSIVEADDRUSE on Windows or SO_EXCLBIND\n   *     on Solaris)\n   */\n  int listening_address_reuse;\n\n\n  /**\n   * Inter-thread communication channel (also used to unblock\n   * select() in non-threaded code).\n   */\n  struct MHD_itc_ itc;\n\n  /**\n   * Are we shutting down?\n   */\n  volatile bool shutdown;\n\n  /**\n   * Has this daemon been quiesced via #MHD_quiesce_daemon()?\n   * If so, we should no longer use the @e listen_fd (including\n   * removing it from the @e epoll_fd when possible).\n   */\n  volatile bool was_quiesced;\n\n  /**\n   * Did we hit some system or process-wide resource limit while\n   * trying to accept() the last time? If so, we don't accept new\n   * connections until we close an existing one.  This effectively\n   * temporarily lowers the \"connection_limit\" to the current\n   * number of connections.\n   */\n  bool at_limit;\n\n  /*\n   * Do we need to process resuming connections?\n   */\n  volatile bool resuming;\n\n  /**\n   * Indicate that new connections in @e new_connections_head list\n   * need to be processed.\n   */\n  volatile bool have_new;\n\n  /**\n   * 'True' if some data is already waiting to be processed.\n   * If set to 'true' - zero timeout for select()/poll*()\n   * is used.\n   * Should be reset each time before processing connections\n   * and raised by any connection which require additional\n   * immediately processing (application does not provide\n   * data for response, data waiting in TLS buffers etc.)\n   */\n  bool data_already_pending;\n\n  /**\n   * Limit on the number of parallel connections.\n   */\n  unsigned int connection_limit;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Maximum number of connections per IP, or 0 for\n   * unlimited.\n   */\n  unsigned int per_ip_connection_limit;\n\n  /**\n   * The strictness level for parsing of incoming data.\n   * @see #MHD_OPTION_CLIENT_DISCIPLINE_LVL\n   */\n  int client_discipline;\n\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  /**\n   * The value of FD_SETSIZE used by the daemon.\n   * For external sockets polling this is the value provided by the application\n   * via MHD_OPTION_APP_FD_SETSIZE or current FD_SETSIZE value.\n   * For internal threads modes this is always current FD_SETSIZE value.\n   */\n  int fdset_size;\n\n  /**\n   * Indicates whether @a fdset_size value was set by application.\n   * 'false' if default value is used.\n   */\n  bool fdset_size_set_by_app;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /**\n   * True if SIGPIPE is blocked\n   */\n  bool sigpipe_blocked;\n\n#ifdef HTTPS_SUPPORT\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Head of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_head;\n\n  /**\n   * Tail of DLL of upgrade response handles we are processing.\n   * Used for upgraded TLS connections when thread-per-connection\n   * is not used.\n   */\n  struct MHD_UpgradeResponseHandle *urh_tail;\n#endif /* UPGRADE_SUPPORT */\n\n  /**\n   * Desired cipher algorithms.\n   */\n  gnutls_priority_t priority_cache;\n\n  /**\n   * What kind of credentials are we offering\n   * for SSL/TLS?\n   */\n  gnutls_credentials_type_t cred_type;\n\n  /**\n   * Server x509 credentials\n   */\n  gnutls_certificate_credentials_t x509_cred;\n\n  /**\n   * Diffie-Hellman parameters\n   */\n  gnutls_dh_params_t dh_params;\n\n  /**\n   * Server PSK credentials\n   */\n  gnutls_psk_server_credentials_t psk_cred;\n\n#if GNUTLS_VERSION_MAJOR >= 3\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for SNI support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK.\n   */\n  gnutls_certificate_retrieve_function2 *cert_callback;\n\n  /**\n   * Function that can be used to obtain the shared key.\n   */\n  MHD_PskServerCredentialsCallback cred_callback;\n\n  /**\n   * Closure for @e cred_callback.\n   */\n  void *cred_callback_cls;\n#endif\n\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  /**\n   * Function that can be used to obtain the certificate.  Needed\n   * for OCSP stapling support.  See #MHD_OPTION_HTTPS_CERT_CALLBACK2.\n   */\n  gnutls_certificate_retrieve_function3 *cert_callback2;\n#endif\n\n  /**\n   * Pointer to our SSL/TLS key (in ASCII) in memory.\n   */\n  const char *https_mem_key;\n\n  /**\n   * Pointer to our SSL/TLS certificate (in ASCII) in memory.\n   */\n  const char *https_mem_cert;\n\n  /**\n   * Pointer to 0-terminated HTTPS passphrase in memory.\n   */\n  const char *https_key_password;\n\n  /**\n   * Pointer to our SSL/TLS certificate authority (in ASCII) in memory.\n   */\n  const char *https_mem_trust;\n\n  /**\n   * Our Diffie-Hellman parameters in memory.\n   */\n  gnutls_dh_params_t https_mem_dhparams;\n\n  /**\n   * true if we have initialized @e https_mem_dhparams.\n   */\n  bool have_dhparams;\n\n  /**\n   * true if ALPN is disabled.\n   */\n  bool disable_alpn;\n\n  #endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n\n  /**\n   * Character array of random values.\n   */\n  const char *digest_auth_random;\n\n  /**\n   * Size of @a digest_auth_random.\n   */\n  size_t digest_auth_rand_size;\n\n  /**\n   * The malloc'ed copy of the @a digest_auth_random.\n   */\n  void *digest_auth_random_copy;\n\n  /**\n   * An array that contains the map nonce-nc.\n   */\n  struct MHD_NonceNc *nnc;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * A rw-lock for synchronizing access to @e nnc.\n   */\n  MHD_mutex_ nnc_lock;\n#endif\n\n  /**\n   * Size of the nonce-nc array.\n   */\n  unsigned int nonce_nc_size;\n\n  /**\n   * Nonce bind type.\n   */\n  unsigned int dauth_bind_type;\n\n  /**\n   * Default nonce validity length.\n   */\n  unsigned int dauth_def_nonce_timeout;\n\n  /**\n   * Default maximum nc (nonce count) value.\n   */\n  uint32_t dauth_def_max_nc;\n#endif\n\n#ifdef TCP_FASTOPEN\n  /**\n   * The queue size for incoming SYN + DATA packets.\n   */\n  unsigned int fastopen_queue_size;\n#endif\n\n  /**\n   * The size of queue for listen socket.\n   */\n  unsigned int listen_backlog_size;\n\n  /* TODO: replace with a single member */\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_listen_fd;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_epoll_fd;\n#endif /* EPOLL_SUPPORT */\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_num_connections;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_flags;\n\n  /**\n   * The value to be returned by #MHD_get_daemon_info()\n   */\n  union MHD_DaemonInfo daemon_info_dummy_port;\n\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  /**\n   * If set to 'true', accept() function will be used instead of accept4() even\n   * if accept4() is available.\n   * This is a workaround for zzuf, which does not support sockets created\n   * by accept4() function.\n   * There is no API to change the value of this member, it can be flipped\n   * only by direct access to the struct member.\n   */\n  bool avoid_accept4;\n#endif /* _DEBUG */\n}\n...\nstatic bool\nget_request_line_inner (struct MHD_Connection *c)\n{\n  size_t p; /**< The current processing position */\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Allow to skip one or more empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_empty_lines = (1 >= discp_lvl);\n  /* Allow to skip more then one empty line before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_several_empty_lines = (skip_empty_lines && (0 >= discp_lvl));\n  /* Allow to skip number of unlimited empty lines before the request line.\n     RFC 9112, section 2.2 */\n  const bool skip_unlimited_empty_lines =\n    (skip_empty_lines && (-3 >= discp_lvl));\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2 */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Treat tab as whitespace delimiter.\n     RFC 9112, section 3 */\n  const bool tab_as_wsp = (0 >= discp_lvl);\n  /* Treat VT (vertical tab) and FF (form feed) as whitespace delimiters.\n     RFC 9112, section 3 */\n  const bool other_wsp_as_wsp = (-1 >= discp_lvl);\n  /* Treat continuous whitespace block as a single space.\n     RFC 9112, section 3 */\n  const bool wsp_blocks = (-1 >= discp_lvl);\n  /* Parse whitespace in URI, special parsing of the request line.\n     RFC 9112, section 3.2 */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI.\n     Violates RFC 9112, section 3.2 */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2 */\n  const bool bare_cr_keep = (wsp_in_uri_keep && (-3 >= discp_lvl));\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n\n  mhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n\n  if (0 == c->read_buffer_offset)\n  {\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    return false; /* No data to process */\n  }\n  p = c->rq.hdrs.rq_line.proc_pos;\n  mhd_assert (p <= c->read_buffer_offset);\n\n  /* Skip empty lines, if any (and if allowed) */\n  /* See RFC 9112, section 2.2 */\n  if ((0 == p)\n      && (skip_empty_lines))\n  {\n    /* Skip empty lines before the request line.\n       See RFC 9112, section 2.2 */\n    bool is_empty_line;\n    mhd_assert (MHD_CONNECTION_INIT == c->state);\n    mhd_assert (NULL == c->rq.method);\n    mhd_assert (NULL == c->rq.url);\n    mhd_assert (0 == c->rq.url_len);\n    mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n    mhd_assert (0 == c->rq.req_target_len);\n    mhd_assert (NULL == c->rq.version);\n    do\n    {\n      is_empty_line = false;\n      if ('\\r' == c->read_buffer[0])\n      {\n        if (1 == c->read_buffer_offset)\n          return false; /* Not enough data yet */\n        if ('\\n' == c->read_buffer[1])\n        {\n          is_empty_line = true;\n          c->read_buffer += 2;\n          c->read_buffer_size -= 2;\n          c->read_buffer_offset -= 2;\n          c->rq.hdrs.rq_line.skipped_empty_lines++;\n        }\n      }\n      else if (('\\n' == c->read_buffer[0]) &&\n               (bare_lf_as_crlf))\n      {\n        is_empty_line = true;\n        c->read_buffer += 1;\n        c->read_buffer_size -= 1;\n        c->read_buffer_offset -= 1;\n        c->rq.hdrs.rq_line.skipped_empty_lines++;\n      }\n      if (is_empty_line)\n      {\n        if ((! skip_unlimited_empty_lines) &&\n            (((unsigned int) ((skip_several_empty_lines) ?\n                              MHD_MAX_EMPTY_LINES_SKIP : 1)) <\n             c->rq.hdrs.rq_line.skipped_empty_lines))\n        {\n          connection_close_error (c,\n                                  _ (\"Too many meaningless extra empty lines \" \\\n                                     \"received before the request\"));\n          return true; /* Process connection closure */\n        }\n        if (0 == c->read_buffer_offset)\n          return false;  /* No more data to process */\n      }\n    } while (is_empty_line);\n  }\n  /* All empty lines are skipped */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVING;\n  /* Read and parse the request line */\n  mhd_assert (1 <= c->read_buffer_offset);\n\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n    /*\n       The processing logic is different depending on the configured strictness:\n\n       When whitespace BLOCKS are NOT ALLOWED, the end of the whitespace is\n       processed BEFORE processing of the current character.\n       When whitespace BLOCKS are ALLOWED, the end of the whitespace is\n       processed AFTER processing of the current character.\n\n       When space char in the URI is ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed only at the END of the line.\n       When space in the URI is NOT ALLOWED, the delimiter between the URI and\n       the HTTP version string is processed as soon as the FIRST whitespace is\n       found after URI start.\n     */\n\n    end_of_line = false;\n\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                (c->rq.hdrs.rq_line.last_ws_end > \\\n                 c->rq.hdrs.rq_line.last_ws_start));\n    mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_start) || \\\n                (0 != c->rq.hdrs.rq_line.last_ws_end));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (p + 1 == c->read_buffer_offset)\n      {\n        c->rq.hdrs.rq_line.proc_pos = p;\n        return false; /* Not enough data yet */\n      }\n      else if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          /* A quick simple check whether this line looks like an HTTP request */\n          if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n              (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n          {\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          }\n          else\n            connection_close_error (c,\n                                    _ (\"Bare CR characters are not allowed \" \\\n                                       \"in the request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2 */\n      if (bare_lf_as_crlf)\n        end_of_line = true;\n      else\n      {\n        /* While RFC does not enforce error for bare LF character,\n           if this char is not treated as a line delimiter, it should be\n           rejected to avoid any security weakness due to request smuggling. */\n        /* A quick simple check whether this line looks like an HTTP request */\n        if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n            (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n        {\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        }\n        else\n          connection_close_error (c,\n                                  _ (\"Bare LF characters are not allowed \" \\\n                                     \"in the request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    if (end_of_line)\n    {\n      /* Handle the end of the request line */\n\n      if (NULL != c->rq.method)\n      {\n        if (wsp_in_uri)\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be determined now. */\n          mhd_assert (NULL == c->rq.version);\n          mhd_assert (0 == c->rq.req_target_len);\n          if (0 != c->rq.hdrs.rq_line.last_ws_end)\n          {\n            /* Determine the end and the length of the URI */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->read_buffer [c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.req_target_len =\n                c->rq.hdrs.rq_line.last_ws_start\n                - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else if ((c->rq.hdrs.rq_line.last_ws_start + 1 <\n                      c->rq.hdrs.rq_line.last_ws_end) &&\n                     (HTTP_VER_LEN == (p - c->rq.hdrs.rq_line.last_ws_end)))\n            {\n              /* Found only HTTP method and HTTP version and more than one\n                 whitespace between them. Assume zero-length URI. */\n              mhd_assert (wsp_blocks);\n              c->rq.hdrs.rq_line.last_ws_start++;\n              c->read_buffer[c->rq.hdrs.rq_line.last_ws_start] = 0; /* Zero terminate the URI */\n              c->rq.hdrs.rq_line.rq_tgt =\n                c->read_buffer + c->rq.hdrs.rq_line.last_ws_start;\n              c->rq.req_target_len = 0;\n              c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n              c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n            }\n            /* Determine the start of the HTTP version string */\n            if (NULL != c->rq.hdrs.rq_line.rq_tgt)\n            {\n              c->rq.version = c->read_buffer + c->rq.hdrs.rq_line.last_ws_end;\n            }\n          }\n        }\n        else\n        {\n          /* The end of the URI and the start of the HTTP version string\n             should be already known. */\n          if ((NULL == c->rq.version)\n              && (NULL != c->rq.hdrs.rq_line.rq_tgt)\n              && (HTTP_VER_LEN == p - (size_t) (c->rq.hdrs.rq_line.rq_tgt\n                                                - c->read_buffer))\n              && (0 != c->read_buffer[(size_t)\n                                      (c->rq.hdrs.rq_line.rq_tgt\n                                       - c->read_buffer) - 1]))\n          {\n            /* Found only HTTP method and HTTP version and more than one\n               whitespace between them. Assume zero-length URI. */\n            size_t uri_pos;\n            mhd_assert (wsp_blocks);\n            mhd_assert (0 == c->rq.req_target_len);\n            uri_pos = (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer) - 1;\n            mhd_assert (uri_pos < p);\n            c->rq.version = c->rq.hdrs.rq_line.rq_tgt;\n            c->read_buffer[uri_pos] = 0;  /* Zero terminate the URI */\n            c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + uri_pos;\n            c->rq.req_target_len = 0;\n            c->rq.hdrs.rq_line.num_ws_in_uri = 0;\n            c->rq.hdrs.rq_line.rq_tgt_qmark = NULL;\n          }\n        }\n\n        if (NULL != c->rq.version)\n        {\n          mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n          if (! parse_http_version (c, c->rq.version,\n                                    p\n                                    - (size_t) (c->rq.version\n                                                - c->read_buffer)))\n          {\n            mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state);\n            return true; /* Unsupported / broken HTTP version */\n          }\n          c->read_buffer[p] = 0; /* Zero terminate the HTTP version strings */\n          if ('\\r' == chr)\n          {\n            p++; /* Consume CR */\n            mhd_assert (p < c->read_buffer_offset); /* The next character has been already checked */\n          }\n          p++; /* Consume LF */\n          c->read_buffer += p;\n          c->read_buffer_size -= p;\n          c->read_buffer_offset -= p;\n          mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n                      c->rq.req_target_len);\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (0 != c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      ((size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                                 - c->rq.hdrs.rq_line.rq_tgt) < \\\n                       c->rq.req_target_len));\n          mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt_qmark >= \\\n                       c->rq.hdrs.rq_line.rq_tgt));\n          return true; /* The request line is successfully parsed */\n        }\n      }\n      /* Error in the request line */\n\n      /* A quick simple check whether this line looks like an HTTP request */\n      if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n          (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n      {\n        transmit_error_response_static (c,\n                                        MHD_HTTP_BAD_REQUEST,\n                                        REQUEST_MALFORMED);\n      }\n      else\n        connection_close_error (c,\n                                _ (\"The request line is malformed.\\n\"));\n\n      return true;\n    }\n\n    /* Process possible end of the previously found whitespace delimiter */\n    if ((! wsp_blocks) &&\n        (p == c->rq.hdrs.rq_line.last_ws_end) &&\n        (0 != c->rq.hdrs.rq_line.last_ws_end))\n    {\n      /* Previous character was a whitespace char and whitespace blocks\n         are not allowed. */\n      /* The current position is the next character after\n         a whitespace delimiter */\n      if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n      {\n        /* The current position is the start of the URI */\n        mhd_assert (0 == c->rq.req_target_len);\n        mhd_assert (NULL == c->rq.version);\n        c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n        /* Reset the whitespace marker */\n        c->rq.hdrs.rq_line.last_ws_start = 0;\n        c->rq.hdrs.rq_line.last_ws_end = 0;\n      }\n      else\n      {\n        /* It was a whitespace after the start of the URI */\n        if (! wsp_in_uri)\n        {\n          mhd_assert ((0 != c->rq.req_target_len) || \\\n                      (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n          mhd_assert (NULL == c->rq.version); /* Too many whitespaces? This error is handled at whitespace start */\n          c->rq.version = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n      }\n    }\n\n    /* Process the current character.\n       Is it not the end of the line.  */\n    if ((' ' == chr)\n        || (('\\t' == chr) && (tab_as_wsp))\n        || ((other_wsp_as_wsp) && ((0xb == chr) || (0xc == chr))))\n    {\n      /* A whitespace character */\n      if ((0 == c->rq.hdrs.rq_line.last_ws_end) ||\n          (p != c->rq.hdrs.rq_line.last_ws_end) ||\n          (! wsp_blocks))\n      {\n        /* Found first whitespace char of the new whitespace block */\n        if (NULL == c->rq.method)\n        {\n          /* Found the end of the HTTP method string */\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_start);\n          mhd_assert (0 == c->rq.hdrs.rq_line.last_ws_end);\n          mhd_assert (NULL == c->rq.hdrs.rq_line.rq_tgt);\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          if (0 == p)\n          {\n            connection_close_error (c,\n                                    _ (\"The request line starts with \"\n                                       \"a whitespace.\\n\"));\n            return true; /* Error in the request */\n          }\n          c->read_buffer[p] = 0; /* Zero-terminate the request method string */\n          c->rq.method = c->read_buffer;\n          parse_http_std_method (c, c->rq.method, p);\n        }\n        else\n        {\n          /* A whitespace after the start of the URI */\n          if (! wsp_in_uri)\n          {\n            /* Whitespace in URI is not allowed to be parsed */\n            if (NULL == c->rq.version)\n            {\n              mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n              /* This is a delimiter between URI and HTTP version string */\n              c->read_buffer[p] = 0; /* Zero-terminate request URI string */\n              mhd_assert (((size_t) (c->rq.hdrs.rq_line.rq_tgt   \\\n                                     - c->read_buffer)) <= p);\n              c->rq.req_target_len =\n                p - (size_t) (c->rq.hdrs.rq_line.rq_tgt - c->read_buffer);\n            }\n            else\n            {\n              /* This is a delimiter AFTER version string */\n\n              /* A quick simple check whether this line looks like an HTTP request */\n              if ((MHD_HTTP_MTHD_GET <= c->rq.http_mthd) &&\n                  (MHD_HTTP_MTHD_DELETE >= c->rq.http_mthd))\n              {\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                RQ_LINE_TOO_MANY_WSP);\n              }\n              else\n                connection_close_error (c,\n                                        _ (\"The request line has more than \"\n                                           \"two whitespaces.\\n\"));\n              return true; /* Error in the request */\n            }\n          }\n          else\n          {\n            /* Whitespace in URI is allowed to be parsed */\n            if (0 != c->rq.hdrs.rq_line.last_ws_end)\n            {\n              /* The whitespace after the start of the URI has been found already */\n              c->rq.hdrs.rq_line.num_ws_in_uri +=\n                c->rq.hdrs.rq_line.last_ws_end\n                - c->rq.hdrs.rq_line.last_ws_start;\n            }\n          }\n        }\n        c->rq.hdrs.rq_line.last_ws_start = p;\n        c->rq.hdrs.rq_line.last_ws_end = p + 1; /* Will be updated on the next char parsing */\n      }\n      else\n      {\n        /* Continuation of the whitespace block */\n        mhd_assert (0 != c->rq.hdrs.rq_line.last_ws_end);\n        mhd_assert (0 != p);\n        c->rq.hdrs.rq_line.last_ws_end = p + 1;\n      }\n    }\n    else\n    {\n      /* Non-whitespace char, not the end of the line */\n      mhd_assert ((0 == c->rq.hdrs.rq_line.last_ws_end) || \\\n                  (c->rq.hdrs.rq_line.last_ws_end == p) || \\\n                  wsp_in_uri);\n\n      if ((p == c->rq.hdrs.rq_line.last_ws_end) &&\n          (0 != c->rq.hdrs.rq_line.last_ws_end) &&\n          (wsp_blocks))\n      {\n        /* The end of the whitespace block */\n        if (NULL == c->rq.hdrs.rq_line.rq_tgt)\n        {\n          /* This is the first character of the URI */\n          mhd_assert (0 == c->rq.req_target_len);\n          mhd_assert (NULL == c->rq.version);\n          c->rq.hdrs.rq_line.rq_tgt = c->read_buffer + p;\n          /* Reset the whitespace marker */\n          c->rq.hdrs.rq_line.last_ws_start = 0;\n          c->rq.hdrs.rq_line.last_ws_end = 0;\n        }\n        else\n        {\n          if (! wsp_in_uri)\n          {\n            /* This is the first character of the HTTP version */\n            mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n            mhd_assert ((0 != c->rq.req_target_len) || \\\n                        (c->rq.hdrs.rq_line.rq_tgt + 1 == c->read_buffer + p));\n            mhd_assert (NULL == c->rq.version); /* Handled at whitespace start */\n            c->rq.version = c->read_buffer + p;\n            /* Reset the whitespace marker */\n            c->rq.hdrs.rq_line.last_ws_start = 0;\n            c->rq.hdrs.rq_line.last_ws_end = 0;\n          }\n        }\n      }\n\n      /* Handle other special characters */\n      if ('?' == chr)\n      {\n        if ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) &&\n            (NULL != c->rq.hdrs.rq_line.rq_tgt))\n        {\n          c->rq.hdrs.rq_line.rq_tgt_qmark = c->read_buffer + p;\n        }\n      }\n      else if ((0xb == chr) || (0xc == chr))\n      {\n        /* VT or LF characters */\n        mhd_assert (! other_wsp_as_wsp);\n        if ((NULL != c->rq.hdrs.rq_line.rq_tgt) &&\n            (NULL == c->rq.version) &&\n            (wsp_in_uri))\n        {\n          c->rq.hdrs.rq_line.num_ws_in_uri++;\n        }\n        else\n        {\n          connection_close_error (c,\n                                  _ (\"Invalid character is in the \"\n                                     \"request line.\\n\"));\n          return true; /* Error in the request */\n        }\n      }\n      else if (0 == chr)\n      {\n        /* NUL character */\n        connection_close_error (c,\n                                _ (\"The NUL character is in the \"\n                                   \"request line.\\n\"));\n        return true; /* Error in the request */\n      }\n    }\n\n    p++;\n  }\n\n  c->rq.hdrs.rq_line.proc_pos = p;\n  return false; /* Not enough data yet */\n}\n...\n#define transmit_error_response_static(c, code, msg) transmit_error_response_len(c,code,msg,MHD_STATICSTR_LEN_(msg),NULL,0,NULL,0)\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\nstatic void\nsend_redirect_fixed_rq_target (struct MHD_Connection *c)\n{\n  char *b;\n  size_t fixed_uri_len;\n  size_t i;\n  size_t o;\n  char *hdr_name;\n  size_t hdr_name_len;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (0 != c->rq.hdrs.rq_line.num_ws_in_uri);\n  mhd_assert (c->rq.hdrs.rq_line.num_ws_in_uri <= \\\n              c->rq.req_target_len);\n  fixed_uri_len = c->rq.req_target_len\n                  + 2 * c->rq.hdrs.rq_line.num_ws_in_uri;\n  if ( (fixed_uri_len + 200 > c->daemon->pool_size) ||\n       (fixed_uri_len > MHD_MAX_FIXED_URI_LEN) ||\n       (NULL == (b = malloc (fixed_uri_len + 1))) )\n  {\n    connection_close_error (c,\n                            _ (\"The request has whitespace character is \" \\\n                               \"in the URI and the URI is too large to \" \\\n                               \"send automatic redirect to fixed URI.\\n\"));\n    return;\n  }\n  i = 0;\n  o = 0;\n\n  do\n  {\n    const char chr = c->rq.hdrs.rq_line.rq_tgt[i++];\n\n    mhd_assert ('\\r' != chr); /* Replaced during request line parsing */\n    mhd_assert ('\\n' != chr); /* Rejected during request line parsing */\n    mhd_assert (0 != chr); /* Rejected during request line parsing */\n    switch (chr)\n    {\n    case ' ':\n      b[o++] = '%';\n      b[o++] = '2';\n      b[o++] = '0';\n      break;\n    case '\\t':\n      b[o++] = '%';\n      b[o++] = '0';\n      b[o++] = '9';\n      break;\n    case 0x0B:   /* VT (vertical tab) */\n      b[o++] = '%';\n      b[o++] = '0';\n      b[o++] = 'B';\n      break;\n    case 0x0C:   /* FF (form feed) */\n      b[o++] = '%';\n      b[o++] = '0';\n      b[o++] = 'C';\n      break;\n    default:\n      b[o++] = chr;\n      break;\n    }\n  } while (i < c->rq.req_target_len);\n  mhd_assert (fixed_uri_len == o);\n  b[o] = 0; /* Zero-terminate the result */\n\n  hdr_name_len = MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_LOCATION);\n  hdr_name = malloc (hdr_name_len + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name,\n            MHD_HTTP_HEADER_LOCATION,\n            hdr_name_len + 1);\n    /* hdr_name and b are free()d within this call */\n    transmit_error_response_header (c,\n                                    MHD_HTTP_MOVED_PERMANENTLY,\n                                    RQ_TARGET_INVALID_CHAR,\n                                    hdr_name,\n                                    hdr_name_len,\n                                    b,\n                                    o);\n    return;\n  }\n  free (b);\n  connection_close_error (c,\n                          _ (\"The request has whitespace character is in the \" \\\n                             \"URI.\\n\"));\n  return;\n}\n...\nstatic bool\nprocess_request_target (struct MHD_Connection *c)\n{\n#ifdef _DEBUG\n  size_t params_len;\n#endif /* _DEBUG */\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.hdrs.rq_line.rq_tgt <= c->rq.hdrs.rq_line.rq_tgt_qmark));\n  mhd_assert ((NULL == c->rq.hdrs.rq_line.rq_tgt_qmark) || \\\n              (c->rq.req_target_len > \\\n               (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark \\\n                         - c->rq.hdrs.rq_line.rq_tgt)));\n\n  /* Log callback before the request-target is modified/decoded */\n  if (NULL != c->daemon->uri_log_callback)\n  {\n    c->rq.client_aware = true;\n    c->rq.client_context =\n      c->daemon->uri_log_callback (c->daemon->uri_log_callback_cls,\n                                   c->rq.hdrs.rq_line.rq_tgt,\n                                   c);\n  }\n\n  if (NULL != c->rq.hdrs.rq_line.rq_tgt_qmark)\n  {\n#ifdef _DEBUG\n    params_len =\n      c->rq.req_target_len\n      - (size_t) (c->rq.hdrs.rq_line.rq_tgt_qmark - c->rq.hdrs.rq_line.rq_tgt);\n#endif /* _DEBUG */\n    c->rq.hdrs.rq_line.rq_tgt_qmark[0] = 0; /* Replace '?' with zero termination */\n    if (MHD_NO == MHD_parse_arguments_ (c,\n                                        MHD_GET_ARGUMENT_KIND,\n                                        c->rq.hdrs.rq_line.rq_tgt_qmark + 1,\n                                        &connection_add_header,\n                                        c))\n    {\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING != c->state);\n      return false;\n    }\n  }\n#ifdef _DEBUG\n  else\n    params_len = 0;\n#endif /* _DEBUG */\n\n  mhd_assert (strlen (c->rq.hdrs.rq_line.rq_tgt) == \\\n              c->rq.req_target_len - params_len);\n\n  /* Finally unescape URI itself */\n  c->rq.url_len =\n    c->daemon->unescape_callback (c->daemon->unescape_callback_cls,\n                                  c,\n                                  c->rq.hdrs.rq_line.rq_tgt);\n  c->rq.url = c->rq.hdrs.rq_line.rq_tgt;\n\n  return true;\n}\n...\nstatic void\nconnection_close_error (struct MHD_Connection *connection,\n                        const char *emsg)\n{\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              \"%s\\n\",\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void) emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}\n...\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define HTTP_VER_LEN (MHD_STATICSTR_LEN_(MHD_HTTP_VERSION_1_1))\n...\n#define MHD_HTTP_BAD_REQUEST 400\n...\n#define REQUEST_MALFORMED \"<html><head><title>Request malformed</title></head>\"\"<body>HTTP request is syntactically incorrect.</body></html>\"\n...\n#define RQ_TARGET_INVALID_CHAR \"<html>\"\"<head><title>Request broken</title></head>\"\"<body>HTTP request has invalid characters in \"\"the request-target.</body>\"\"</html>\"\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (MHD_CONNECTION_INIT == c->state || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.method || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd || \\\n              0 != c->rq.hdrs.rq_line.proc_pos);\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the fragment only contains calls to mhd_assert which is defined as ((void)0) so they expand to no-ops and do not introduce any unreachable code paths. There is no code that cannot be executed (no statements after unconditional returns, no if (0) blocks, etc.)."
}