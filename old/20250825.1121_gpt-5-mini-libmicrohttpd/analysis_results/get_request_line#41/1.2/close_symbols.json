{
  "user_message": "Target function code is:\n```c\nstatic bool\nget_request_line (struct MHD_Connection *c)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Parse whitespace in URI, special parsing of the request line */\n  const bool wsp_in_uri = (0 >= discp_lvl);\n  /* Keep whitespace in URI, give app URI with whitespace instead of\n     automatic redirect to fixed URI */\n  const bool wsp_in_uri_keep = (-2 >= discp_lvl);\n\n  if (! get_request_line_inner (c))\n  {\n    /* End of the request line has not been found yet */\n    mhd_assert ((! wsp_in_uri) || NULL == c->rq.version);\n    if ((NULL != c->rq.version) &&\n        (HTTP_VER_LEN <\n         (c->rq.hdrs.rq_line.proc_pos\n          - (size_t) (c->rq.version - c->read_buffer))))\n    {\n      c->rq.http_ver = MHD_HTTP_VER_INVALID;\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      REQUEST_MALFORMED);\n      return true; /* Error in the request */\n    }\n    return false;\n  }\n  if (MHD_CONNECTION_REQ_LINE_RECEIVING < c->state)\n    return true; /* Error in the request */\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING == c->state);\n  mhd_assert (NULL == c->rq.url);\n  mhd_assert (0 == c->rq.url_len);\n  mhd_assert (NULL != c->rq.hdrs.rq_line.rq_tgt);\n  if (0 != c->rq.hdrs.rq_line.num_ws_in_uri)\n  {\n    if (! wsp_in_uri)\n    {\n      transmit_error_response_static (c,\n                                      MHD_HTTP_BAD_REQUEST,\n                                      RQ_TARGET_INVALID_CHAR);\n      return true; /* Error in the request */\n    }\n    if (! wsp_in_uri_keep)\n    {\n      send_redirect_fixed_rq_target (c);\n      return true; /* Error in the request */\n    }\n  }\n  if (! process_request_target (c))\n    return true; /* Error in processing */\n\n  c->state = MHD_CONNECTION_REQ_LINE_RECEIVED;\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_request_line': {'callees': ['get_request_line_inner', 'transmit_error_response_len', 'send_redirect_fixed_rq_target', 'process_request_target'], 'callers': ['MHD_connection_handle_idle']}, 'get_request_line_inner': {'callees': ['connection_close_error', 'transmit_error_response_len', 'parse_http_version', 'parse_http_std_method'], 'callers': ['get_request_line']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'send_redirect_fixed_rq_target': {'callees': ['connection_close_error', 'transmit_error_response_len'], 'callers': ['get_request_line']}, 'process_request_target': {'callees': ['MHD_parse_arguments_'], 'callers': ['get_request_line']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "transmit_error_response_static",
    "transmit_error_response_len",
    "send_redirect_fixed_rq_target",
    "process_request_target",
    "get_request_line_inner",
    "struct MHD_Connection (full definition including nested structs/fields: rq, daemon, read_buffer, state, hdrs)",
    "MHD_CONNECTION_REQ_LINE_RECEIVING",
    "MHD_CONNECTION_REQ_LINE_RECEIVED",
    "HTTP_VER_LEN",
    "MHD_HTTP_VER_INVALID",
    "MHD_HTTP_BAD_REQUEST",
    "REQUEST_MALFORMED",
    "RQ_TARGET_INVALID_CHAR",
    "bool definition/header (e.g. <stdbool.h> or project typedef)"
  ],
  "explanation": "For checking the MISRA rule on language extensions we must inspect any macros, function declarations/definitions and type definitions referenced by get_request_line because extensions are commonly hidden there. Brief reasons:\n\n- mhd_assert: often a macro; may expand to compiler-specific extensions (statement expressions, __builtin_*, attributes). Need its definition to detect such extensions.\n- transmit_error_response_static: called directly; may be a macro wrapper or inline that uses extensions. Inspect its definition.\n- transmit_error_response_len: present in the call graph and likely related to the static wrapper; its implementation or prototype may use attributes or compiler builtins \u2014 inspect it.\n- send_redirect_fixed_rq_target: called from this function; its prototype/definition may contain compiler-specific attributes or use extensions in macros it relies on.\n- process_request_target: called from this function; its definition or macros it uses could contain extensions (e.g. statement expressions, typeof, inline asm).\n- get_request_line_inner: called and possibly a macro or inline function; its expansion/definition may introduce extensions affecting analysis.\n- struct MHD_Connection (full definition): the struct and its nested members (rq, daemon, read_buffer, hdrs, state, etc.) must be checked for anonymous structs/unions, bit-field usage, GCC attributes on members, flexible-array usage or other extensions that affect how the target code accesses fields.\n- MHD_CONNECTION_REQ_LINE_RECEIVING / MHD_CONNECTION_REQ_LINE_RECEIVED: these constants/macros may be defined using non-standard constructs or macros that expand to expressions using extensions; check definitions.\n- HTTP_VER_LEN: verify it is a plain constant and not defined via an extension (complex macro, statement expression, typeof, etc.).\n- MHD_HTTP_VER_INVALID, MHD_HTTP_BAD_REQUEST, REQUEST_MALFORMED, RQ_TARGET_INVALID_CHAR: check these macros/constants for non-standard definitions or use of extension constructs.\n- bool definition/header: confirm whether `bool`/`true`/`false` come from standard <stdbool.h> or a project typedef/macro possibly using non-standard constructs.\n\nCollectively these symbols cover macros, function prototypes/definitions and type/layouts that are the only places language extensions could be hidden while still affecting the semantics of get_request_line. Inspecting their definitions will allow a reliable determination of whether any compiler language extensions are used in code that the target function depends on."
}