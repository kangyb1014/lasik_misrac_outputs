{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout64 (struct MHD_Daemon *daemon,\n                   uint64_t *timeout64)\n{\n  uint64_t earliest_deadline;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *earliest_tmot_conn; /**< the connection with earliest timeout */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Illegal call to MHD_get_timeout.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  if (daemon->data_already_pending\n      || (NULL != daemon->cleanup_head)\n      || daemon->resuming\n      || daemon->have_new\n      || daemon->shutdown)\n  {\n    /* Some data or connection statuses already waiting to be processed. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n       || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n      ) )\n  {\n    /* Some connection(s) already have some data pending. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#endif /* EPOLL_SUPPORT */\n\n  earliest_tmot_conn = NULL;\n  earliest_deadline = 0; /* mute compiler warning */\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout_ms) )\n  {\n    earliest_tmot_conn = pos;\n    earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n  }\n\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n  {\n    if (0 != pos->connection_timeout_ms)\n    {\n      if ( (NULL == earliest_tmot_conn) ||\n           (earliest_deadline - pos->last_activity >\n            pos->connection_timeout_ms) )\n      {\n        earliest_tmot_conn = pos;\n        earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n      }\n    }\n  }\n\n  if (NULL != earliest_tmot_conn)\n  {\n    *timeout64 = connection_get_wait (earliest_tmot_conn);\n    return MHD_YES;\n  }\n  return MHD_NO;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'MHD_get_timeout': {'callees': ['MHD_get_timeout64'], 'callers': []}, 'MHD_get_timeout64s': {'callees': ['MHD_get_timeout64'], 'callers': ['MHD_get_timeout_i']}, 'get_timeout_millisec_': {'callees': ['MHD_get_timeout64'], 'callers': ['get_timeout_millisec_int']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "struct MHD_Daemon",
    "struct MHD_Connection",
    "mhd_assert",
    "MHD_D_IS_USING_THREADS_",
    "MHD_thread_handle_ID_is_current_thread_",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "HAVE_MESSAGES",
    "MHD_DLOG",
    "_ (gettext macro)",
    "EPOLL_SUPPORT",
    "MHD_D_IS_USING_EPOLL_",
    "UPGRADE_SUPPORT",
    "HTTPS_SUPPORT",
    "connection_get_wait",
    "uint64_t"
  ],
  "explanation": "For checking MISRA rule \u201cLanguage extensions should not be used\u201d you must inspect any macro expansions, storage-class/attribute annotations, or nonstandard constructs referenced by this function. Each listed symbol is needed because it can introduce compiler extensions when defined elsewhere:\n\n- _MHD_EXTERN: Likely expands in the function declaration; may contain compiler-specific storage-class specifiers or attributes (e.g. __attribute__, __declspec). Must inspect its definition for extensions.\n\n- MHD_Result / MHD_YES / MHD_NO: The result enum/type used by the function. Enum or its definition might use nonstandard extensions (attributes, underlying-type annotations). Need the enum/type definition to verify no extensions.\n\n- struct MHD_Daemon: The daemon pointer type \u2014 its definition (and the definitions of members used below) may include bitfields, attributes, anonymous structs/unions or other extensions. Inspect the struct to ensure no language extensions are used.\n\n- struct MHD_Connection: The connection type whose members (connection_timeout_ms, last_activity, prevX, etc.) are read. Its declaration may use extensions (e.g. flexible array members in nonstandard ways, anonymous fields, attributes, compiler-specific qualifiers) so its definition is required.\n\n- mhd_assert: Macro/function used in the thread-safety check. Its expansion could use compiler builtins, statement-expressions (GCC extension), __extension__ pragmas, or other nonstandard constructs.\n\n- MHD_D_IS_USING_THREADS_: Macro used inside the assert. Macro expansion could use typeof, statement-expr, or other extensions \u2014 must inspect.\n\n- MHD_thread_handle_ID_is_current_thread_: Function/macro called inside the assert. Its declaration/definition might use calling-convention attributes or other extensions.\n\n- MHD_D_IS_USING_THREAD_PER_CONN_: Macro used to gate behavior. Its expansion could hide extensions; needed to check what code becomes active.\n\n- HAVE_MESSAGES: Conditional compilation flag that enables MHD_DLOG usage. The code path guarded by this flag contains a call to MHD_DLOG and the _() macro; you must inspect those definitions when the flag is set.\n\n- MHD_DLOG: Logging macro/function invoked in the function. Logging macros frequently use variadic macros, GCC statement expressions, or attributes. Inspect its definition for extensions (variadic macro forms, __attribute__, etc.).\n\n- _ (gettext macro): The _(...) usage is a macro (or function) that may be defined in various ways; check its definition to ensure it isn\u2019t an implementation that uses language extensions.\n\n- EPOLL_SUPPORT / MHD_D_IS_USING_EPOLL_ / UPGRADE_SUPPORT / HTTPS_SUPPORT: Conditional macros that enable additional code paths (eready_head, eready_urh_head). These conditionals change which code is compiled; to verify absence of extensions in the target, you must examine the code enabled under these flags and any macros they expand to.\n\n- connection_get_wait: The function called to compute the timeout. Its prototype or definition might include attributes or nonstandard calling conventions. While the call itself is standard, the declaration could use extensions that affect this translation unit.\n\n- uint64_t: The integer type used for the timeout. Usually from <stdint.h>, but the typedef could be platform-provided or use compiler-specific typedefs; include to confirm standard type usage.\n\nIn short: inspect all macros, typedefs, structs and called-function declarations reachable from MHD_get_timeout64 because any of their definitions can introduce compiler-specific extensions (attributes, builtin usage, statement-expressions, typeof, inline-assembly, nonstandard linkage, variadic macro extensions, etc.). The listed symbols are the minimal set required to examine those definitions and determine compliance with the language-extension prohibition."
}