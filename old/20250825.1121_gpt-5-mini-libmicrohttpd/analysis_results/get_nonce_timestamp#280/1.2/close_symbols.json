{
  "user_message": "Target function code is:\n```c\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_nonce_timestamp': {'callees': ['MHD_strx_to_uint64_n_'], 'callers': ['check_nonce_nc', 'is_slot_available', 'digest_auth_check_all_inner']}, 'MHD_strx_to_uint64_n_': {'callees': ['toxdigitvalue'], 'callers': ['process_request_body', 'get_nonce_timestamp', 'get_rq_nc', 'digest_auth_check_all_inner']}, 'check_nonce_nc': {'callees': ['MHD_get_master', 'get_nonce_nc_idx', '__builtin_unreachable', 'get_nonce_timestamp'], 'callers': ['digest_auth_check_all_inner']}, 'is_slot_available': {'callees': ['get_nonce_timestamp'], 'callers': ['calculate_add_nonce']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "NONCE_STD_LEN (macro)",
    "TIMESTAMP_CHARS_LEN (macro)",
    "MD5_DIGEST_SIZE (macro)",
    "SHA256_SHA512_256_DIGEST_SIZE (macro)",
    "MHD_strx_to_uint64_n_ (declaration/definition)",
    "MHD_MD5_SUPPORT (preprocessor flag)",
    "MHD_SHA256_SUPPORT (preprocessor flag)",
    "MHD_SHA512_256_SUPPORT (preprocessor flag)",
    "stdbool.h (or the project typedef/defines for bool/true/false)",
    "stdint.h (or the project typedef for uint64_t)",
    "stddef.h (or the project typedef for size_t)",
    "string.h (prototype for strlen)"
  ],
  "explanation": "To determine whether get_nonce_timestamp uses any compiler language extensions you must inspect any macros, flags and external symbols that affect syntactic constructs in the function and any non\u2011standard definitions of basic types. Specifically:\n\n- NONCE_STD_LEN (macro): The code uses NONCE_STD_LEN(...) in a compile\u2011time expression. Its definition may use compiler extensions (e.g. GNU statement expressions, typeof, attributes) or produce non\u2011standard syntax when expanded.\n\n- TIMESTAMP_CHARS_LEN (macro): Used to compute pointer arithmetic and as an argument to MHD_strx_to_uint64_n_. Its definition could use extensions or unusual token pasting that would make the function rely on extensions.\n\n- MD5_DIGEST_SIZE and SHA256_SHA512_256_DIGEST_SIZE (macros): These are passed into NONCE_STD_LEN; if their definitions are non\u2011trivial macros or use extensions, the conditional expression in the function could rely on extensions.\n\n- MHD_strx_to_uint64_n_ (declaration/definition): The call site could be a macro or an inline function that itself uses compiler extensions (builtins, attributes, statement expressions). If it is a macro, expansion could introduce extension syntax into the target function.\n\n- MHD_MD5_SUPPORT, MHD_SHA256_SUPPORT, MHD_SHA512_256_SUPPORT (preprocessor flags): The presence or absence of these flags changes which code is compiled. You must see how they are defined (or not) to be sure no extension\u2011only code path is enabled in the compiled function.\n\n- stdbool.h / bool/true/false definitions: The function uses bool, true and false. Verify these come from the standard header (or safe typedefs) and are not redefined with compiler extensions.\n\n- stdint.h / uint64_t: Verify uint64_t is the standard typedef and not a project alias that relies on extensions.\n\n- stddef.h / size_t: Ensure size_t is the standard typedef and not an extension usage.\n\n- string.h / strlen prototype: Confirm strlen is the standard library function and that no macro overrides or replacements introduce extensions.\n\nCollecting these symbol definitions lets the next agent see whether any macro expansions, type definitions, or called/conditional symbols introduce non\u2011standard/implementation\u2011specific language extensions that would violate the MISRA rule. Only by inspecting these nearby symbols (macros, flags and external declarations/definitions) can you be confident the target function itself does not rely on compiler extensions."
}