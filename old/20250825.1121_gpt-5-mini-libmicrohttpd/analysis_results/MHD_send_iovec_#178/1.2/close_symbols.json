{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_iovec_ (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  bool use_iov_send = true;\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert (NULL != connection->rp.resp_iov.iov);\n  mhd_assert (NULL != connection->rp.response->data_iov);\n  mhd_assert (connection->rp.resp_iov.cnt > connection->rp.resp_iov.sent);\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n#ifdef HTTPS_SUPPORT\n  use_iov_send = use_iov_send &&\n                 (0 == (connection->daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT */\n#ifdef _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED\n  use_iov_send = use_iov_send && (connection->daemon->sigpipe_blocked ||\n                                  connection->sk_spipe_suppress);\n#endif /* _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  if (use_iov_send)\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  return send_iov_nontls (connection, r_iov, push_data);\n#endif /* MHD_VECT_SEND */\n\n#if ! defined(MHD_VECT_SEND) || defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  return send_iov_emu (connection, r_iov, push_data);\n#endif /* !MHD_VECT_SEND || HTTPS_SUPPORT\n          || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}, 'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_VECT_SEND",
    "HTTPS_SUPPORT",
    "_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED",
    "MHD_USE_TLS",
    "mhd_assert",
    "send_iov_nontls",
    "send_iov_emu",
    "struct MHD_Connection",
    "struct MHD_iovec_track_",
    "ssize_t",
    "bool",
    "connection->rp.resp_iov.iov",
    "connection->rp.response->data_iov",
    "connection->rp.resp_iov.cnt",
    "connection->rp.resp_iov.sent",
    "connection->daemon->options",
    "connection->daemon->sigpipe_blocked",
    "connection->sk_spipe_suppress"
  ],
  "explanation": "For determining whether MHD_send_iovec_ uses any compiler language extensions you must inspect any macros, types, or called functions that can introduce extensions when expanded or defined. Brief reasons: \n\n- MHD_VECT_SEND, HTTPS_SUPPORT, _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED: these preprocessor symbols control which code is compiled; their presence/absence changes which code path (and therefore which constructs) are compiled. Their definitions may also be macros that expand to extension-bearing constructs.\n\n- MHD_USE_TLS: used in an expression against daemon->options; its definition (macro/constant) must be inspected to ensure it does not use extensions (e.g., GCC attributes, unusual constants).\n\n- mhd_assert: likely a macro \u2014 must inspect its expansion for compiler extensions (e.g., __builtin_printf, __attribute__, __extension__, __builtin_trap, statement expressions).\n\n- send_iov_nontls, send_iov_emu: called functions. Their declarations/definitions may use compiler extensions in prototypes (attributes like __attribute__((...))), inline definitions, or use builtins; if they are macros or static inline in the same translation unit they could introduce extensions into the compiled code path.\n\n- struct MHD_Connection, struct MHD_iovec_track_: the type definitions and member declarations must be checked for any use of compiler-specific extensions (bitfields with implementation-defined types, anonymous structs/unions, attributes on members, flexible array members if non-standard, etc.).\n\n- ssize_t, bool: underlying typedefs/macros must be checked (e.g., if bool is a custom macro or typedef using compiler extensions).\n\n- connection->rp.resp_iov.iov, connection->rp.response->data_iov, connection->rp.resp_iov.cnt, connection->rp.resp_iov.sent: the types of these members (e.g., iovec pointer type, integer types) must be inspected for extensions (packed/aligned attributes, non-standard types).\n\n- connection->daemon->options, connection->daemon->sigpipe_blocked, connection->sk_spipe_suppress: member types/definitions and any macros used in expressions with them must be inspected for extensions (bitfield definitions, attributes, use of compiler builtin helpers).\n\nIn short: inspect the macros that control compilation and any macros/function/type definitions referenced by this function; those are the places where compiler-specific extensions are most likely to appear and would make MHD_send_iovec_ violate the MISRA rule."
}