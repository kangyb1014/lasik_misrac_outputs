{
  "user_message": "An agent A claimed that the following MHD_send_iovec_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_send_iovec_.\n```c\nssize_t\nMHD_send_iovec_ (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  bool use_iov_send = true;\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert (NULL != connection->rp.resp_iov.iov);\n  mhd_assert (NULL != connection->rp.response->data_iov);\n  mhd_assert (connection->rp.resp_iov.cnt > connection->rp.resp_iov.sent);\n#ifdef MHD_VECT_SEND\n#if defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n#ifdef HTTPS_SUPPORT\n  use_iov_send = use_iov_send &&\n                 (0 == (connection->daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT */\n#ifdef _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED\n  use_iov_send = use_iov_send && (connection->daemon->sigpipe_blocked ||\n                                  connection->sk_spipe_suppress);\n#endif /* _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  if (use_iov_send)\n#endif /* HTTPS_SUPPORT || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n  return send_iov_nontls (connection, r_iov, push_data);\n#endif /* MHD_VECT_SEND */\n\n#if ! defined(MHD_VECT_SEND) || defined(HTTPS_SUPPORT) || \\\n  defined(_MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED)\n  return send_iov_emu (connection, r_iov, push_data);\n#endif /* !MHD_VECT_SEND || HTTPS_SUPPORT\n          || _MHD_VECT_SEND_NEEDS_SPIPE_SUPPRESSED */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe parameter r_iov is declared as 'struct MHD_iovec_track_ *const r_iov' (the pointer is const, the pointed-to type is not). In this function r_iov is only asserted and forwarded to send_iov_nontls without being modified, so the pointed-to type could and should be const-qualified. If send_iov_nontls also does not modify the pointed-to object it should accept a 'const struct MHD_iovec_track_ *' (or the caller should pass a const-qualified pointer). As written, the code fails to qualify the pointee as const and therefore violates Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's observation that the function does not modify the object via r_iov is correct: within MHD_send_iovec_ r_iov is only asserted and forwarded to send_iov_nontls/send_iov_emu. MISRA C:2023 Rule 8.13, however, requires the pointee to be const-qualified only when that is actually possible across the relevant API boundary. You cannot conclude a definite violation from this translation unit alone because the forwarded functions (send_iov_nontls / send_iov_emu) may legitimately modify the pointed-to object; in that case the non-const pointee type is required and no violation occurs. If those callee functions (and all other users) in fact do not modify the pointee, then the API should be changed to accept a pointer-to-const (and MHD_send_iovec_ should be declared to take const struct MHD_iovec_track_ * const r_iov) and the current code would be a valid Rule 8.13 non\u2011conformance. In summary: the report is plausible but not verifiable from the snippet; without inspecting the callee signatures/behavior you cannot claim a definite violation."
}