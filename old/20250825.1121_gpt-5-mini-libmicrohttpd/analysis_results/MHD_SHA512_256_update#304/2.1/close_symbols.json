{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_FAVOR_SMALL_CODE",
    "SIZEOF_SIZE_T",
    "SHA512_256_BLOCK_SIZE",
    "struct Sha512_256Ctx",
    "mhd_assert"
  ],
  "explanation": "To determine whether any statements in MHD_SHA512_256_update are statically unreachable we must know the compile-time configuration and the exact types/layout used by the function. The following symbols are required and why: \n\n- MHD_FAVOR_SMALL_CODE: The code contains a #ifndef MHD_FAVOR_SMALL_CODE block that conditionally compiles an early \"if (0 == length) return;\" shortcut. Whether that code exists (and thus whether the subsequent statements could be unreachable in that configuration) depends directly on this macro.\n\n- SIZEOF_SIZE_T: There is a preprocessor conditional #if SIZEOF_SIZE_T > 7 that controls inclusion of an overflow-wrap check (if (length > ctx->count) ...). Whether that branch exists in the compiled translation unit depends on this macro. Also, SIZEOF_SIZE_T is needed to reason about the width of ctx->count and whether later shifts (>> 61) can ever produce nonzero values.\n\n- SHA512_256_BLOCK_SIZE: The function uses this constant in several places (masking count, computing bytes_have, the while loop condition SHA512_256_BLOCK_SIZE <= length, and bytes_left calculation). Its compile-time value can make the while loop and the block-copy branches impossible or always taken; therefore it is required to decide if those code regions can be reached.\n\n- struct Sha512_256Ctx: The exact definition (types and widths of ctx->count, ctx->count_bits_hi, buffer and H) is required. In particular the type and width of ctx->count determine whether expressions like (ctx->count & (SHA512_256_BLOCK_SIZE - 1)), ctx->count >> 61, and the wrap-handling code can ever be nonzero. If ctx->count is narrower (e.g. 32-bit) some branches (the count_hi != 0 block) may be impossible and thus unreachable.\n\n- mhd_assert: The assert macro/function may be configured to compile to nothing (or to abort/terminate on failure). Whether the initial assertion produces code that could prevent reaching subsequent statements (or is compiled out entirely) affects reachability analysis of the remainder of the function.\n\n(Other standard functions called, e.g. memcpy or sha512_256_transform, do not influence whether branches or blocks in this function are statically present or unreachable \u2014 they are ordinary calls and do not affect compile-time reachability.)"
}