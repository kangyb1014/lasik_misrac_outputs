{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx (full definition \u2014 types of members: count, count_bits_hi, buffer, H)",
    "SHA512_256_BLOCK_SIZE",
    "SIZEOF_SIZE_T (or equivalent sizeof(size_t) compile-time value)",
    "MHD_FAVOR_SMALL_CODE (preprocessor macro)"
  ],
  "explanation": "For deciding whether any controlling expression in MHD_SHA512_256_update is invariant (MISRA C rule), the analyzer needs the following symbols and why:\n\n1) struct Sha512_256Ctx (full definition \u2014 types of members: count, count_bits_hi, buffer, H)\n   - The controlling expressions depend on ctx->count and ctx->count_bits_hi (e.g. bytes_have = (unsigned int)(ctx->count & (SHA512_256_BLOCK_SIZE - 1)), count_hi = ctx->count >> 61, and subsequent if (0 != count_hi)). Whether these expressions can be constant/always false or whether a right shift is undefined depends on the exact type and width of ctx->count and ctx->count_bits_hi. Knowing buffer and H types is also useful to ensure called functions cannot modify those fields in ways that affect loop conditions.\n\n2) SHA512_256_BLOCK_SIZE\n   - Used in multiple controlling expressions (bytes_have calculation, bytes_left, tests like while (SHA512_256_BLOCK_SIZE <= length)). If this macro had an unusual value (e.g. 1 or 0) some conditions could become invariant. The concrete value is needed to determine if those expressions can ever evaluate true/false or be constant.\n\n3) SIZEOF_SIZE_T (or equivalent sizeof(size_t) compile-time value)\n   - The #if SIZEOF_SIZE_T > 7 controls inclusion of the branch if (length > ctx->count). Also the width of size_t interacts with shifts and wrap detection logic; the possibility that ctx->count >> 61 is always zero (or undefined if shift >= width) depends on size_t width. The compile-time size information is required to determine whether those conditions are active and whether they could be invariant.\n\n4) MHD_FAVOR_SMALL_CODE (preprocessor macro)\n   - Controls whether the early shortcut if (0 == length) return; is present. Presence/absence of that check changes whether that controlling expression exists in the compiled function; the macro value is therefore required to assess invariance in the actual build.\n\n(Notes: Standard typedefs like size_t, uint64_t and basic functions like memcpy/sha512_256_transform are not requested here because the primary question is invariance of controlling expressions; however, the exact type of ctx->count (hence the struct definition) and compile-time macros above are essential to determine whether any of the if/while conditions are compile-time or runtime invariants.)"
}