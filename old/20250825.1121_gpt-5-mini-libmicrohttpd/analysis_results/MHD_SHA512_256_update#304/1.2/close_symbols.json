{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "sha512_256_transform",
    "__builtin_rotateright64",
    "__builtin_bswap64",
    "mhd_assert",
    "SIZEOF_SIZE_T",
    "MHD_FAVOR_SMALL_CODE",
    "SHA512_256_BLOCK_SIZE",
    "UINT64_C",
    "Sha512_256Ctx",
    "memcpy"
  ],
  "explanation": "For checking MISRA rule 'Language extensions should not be used' the analyzer must see any symbols/macros/functions that the target function relies on and that could hide use of compiler-specific language extensions.\n\n- sha512_256_transform: The target calls this function; its implementation may use compiler builtins or other extensions. If that callee uses extensions, the overall behaviour violates the rule even if the update wrapper does not.\n- __builtin_rotateright64 and __builtin_bswap64: These are compiler builtins (GCC/Clang extensions). They appear in the static call graph as callees of sha512_256_transform. The analyzer must inspect their usage (or replacements) to decide if an extension is used.\n- mhd_assert: A macro or function used in the first line. Assertion macros often expand to compiler-specific constructs (e.g. __extension__, __builtin_trap, statement expressions). Inspecting its definition is required to ensure it does not use extensions.\n- SIZEOF_SIZE_T: Controls a conditional compilation branch in the function. Its definition may be provided by build-config headers and could be computed using nonstandard means; examining it ensures no extension is hidden in conditional compilation.\n- MHD_FAVOR_SMALL_CODE: Controls an #ifndef/#endif code path. Its definition can change whether code using extensions is compiled; include it so the analyzer can determine if the early-return path (or the alternative) introduces extensions.\n- SHA512_256_BLOCK_SIZE: A macro used extensively for buffer arithmetic and loop bounds. Its definition might use nonstandard constructs or type suffixes; check to ensure no extension is introduced through it.\n- UINT64_C: Standard macro for integer constants, but implementations may use compiler-specific suffixes or extensions. Inspecting its definition ensures constants are standard-compliant.\n- Sha512_256Ctx: The structure type of ctx. Its definition is needed to check for any nonstandard language features (bit-fields wider than implementation limits, anonymous structs/unions, flexible array members in a nonstandard way, or compiler-specific attributes) used in the context layout that would count as language extensions.\n- memcpy: Standard library function used for copying. While itself is standard, some projects replace or wrap memcpy with inline/ builtin versions or macros that use compiler extensions; include it so an analyzer can verify the actual symbol used in the build.\n\nThese symbols give the next analyst the necessary definitions and callees to determine whether any compiler-specific builtins, attributes, statement-expression macros, or other language extensions are used either directly in MHD_SHA512_256_update or indirectly through its callees/macros."
}