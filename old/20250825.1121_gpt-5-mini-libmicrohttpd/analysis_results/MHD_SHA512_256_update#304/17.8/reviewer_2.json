{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'length -= SHA512_256_BLOCK_SIZE;' modifies the function parameter 'length'. MISRA C 2023 Rule 17.8 states a function parameter shall not be modified, so changing 'length' (a parameter) violates the rule. (Similarly the code also modifies 'data' elsewhere, which would also violate the rule.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_SHA512_256_update:\nstruct Sha512_256Ctx\n{\n  uint64_t H[SHA512_256_HASH_SIZE_WORDS];       /**< Intermediate hash value  */\n  uint64_t buffer[SHA512_256_BLOCK_SIZE_WORDS]; /**< SHA512_256 input data buffer */\n  /**\n   * The number of bytes, lower part\n   */\n  uint64_t count;\n  /**\n   * The number of bits, high part.\n   * Unlike lower part, this counts the number of bits, not bytes.\n   */\n  uint64_t count_bits_hi;\n}\n...\n#define SHA512_256_BLOCK_SIZE (SHA512_256_BLOCK_SIZE_BITS/8)\n...\n#define SIZEOF_SIZE_T 8\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters. In this function both the value parameter 'length' and the pointer parameter 'data' are modified (e.g. 'length -= SHA512_256_BLOCK_SIZE;' and 'data += SHA512_256_BLOCK_SIZE;' as well as other similar adjustments). Modifying a value parameter (length) violates the rule, and modifying the pointer parameter itself (data) also violates the rule \u2014 only the object pointed to may be modified, not the pointer. Note that modifying the object pointed to by 'ctx' (ctx->...) is permitted, but the pointer parameters themselves must not be reassigned; hence the code as written violates Rule 17.8. A common remediation is to copy parameters to local variables (e.g. size_t len = length; const uint8_t *p = data;) and work on those locals."
}