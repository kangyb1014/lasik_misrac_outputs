{
  "user_message": "An agent A claimed that the following MHD_SHA512_256_update code violates the MISRA C 2023 rule 17.8.\n<misra_rule>\nMISRA C 2023 Rule 17.8 is A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA512_256_update.\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe statement 'length -= bytes_left;' directly modifies the value of the function parameter 'length'. Under MISRA C 2023 Rule 17.8 a function parameter shall not be modified, so this assignment (and the other updates to 'length' in the function) violates the rule. A compliant fix is to copy 'length' into a local variable (e.g. 'size_t remaining = length;') and update that instead.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_SHA512_256_update:\nstruct Sha512_256Ctx\n{\n  uint64_t H[SHA512_256_HASH_SIZE_WORDS];       /**< Intermediate hash value  */\n  uint64_t buffer[SHA512_256_BLOCK_SIZE_WORDS]; /**< SHA512_256 input data buffer */\n  /**\n   * The number of bytes, lower part\n   */\n  uint64_t count;\n  /**\n   * The number of bits, high part.\n   * Unlike lower part, this counts the number of bits, not bytes.\n   */\n  uint64_t count_bits_hi;\n}\n...\n#define SHA512_256_BLOCK_SIZE (SHA512_256_BLOCK_SIZE_BITS/8)\n...\n#define SIZEOF_SIZE_T 8\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 17.8 forbids modifying function parameters. In this function the non\u2011pointer parameter 'length' is modified (e.g. 'length -= bytes_left;' and 'length -= SHA512_256_BLOCK_SIZE;'), which violates the rule. Additionally the pointer parameter 'data' is reassigned ('data += bytes_left;' and 'data += SHA512_256_BLOCK_SIZE;'), and Rule 17.8 explicitly disallows modifying the pointer itself (though the object it points to may be modified). Modifying ctx->members is allowed because the object pointed to by the pointer parameter may be modified, but that does not excuse the reassignment of the pointer or the scalar parameter. The suggested compliant fix (copy parameters into local variables and update those) is appropriate."
}