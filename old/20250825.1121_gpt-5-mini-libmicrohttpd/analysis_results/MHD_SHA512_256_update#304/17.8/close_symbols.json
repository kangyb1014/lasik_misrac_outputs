{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx",
    "sha512_256_transform (prototype)",
    "SHA512_256_BLOCK_SIZE",
    "MHD_FAVOR_SMALL_CODE",
    "SIZEOF_SIZE_T",
    "memcpy",
    "mhd_assert"
  ],
  "explanation": "struct Sha512_256Ctx: needed to know the types and names of fields (count, count_bits_hi, buffer, H) so we can prove that statements like ctx->count += length and ctx->count &= ... modify the object pointed to by the parameter (which MISRA allows) rather than reassigning the parameter pointer itself (which would violate the rule). sha512_256_transform (prototype): needed to confirm its parameter types/signature so we can be sure its call cannot modify the caller's parameter variables (e.g. it does not take a pointer-to-pointer that could change the caller's 'data' or 'length' variables) and to check const correctness of the data argument. SHA512_256_BLOCK_SIZE: needed to understand the loop/branch structure that drives the data += ... and length -= ... operations (i.e. to reason whether those parameter-modifying statements are actually reachable under typical block sizes). MHD_FAVOR_SMALL_CODE: affects compilation of the early-return shortcut; knowing whether this macro is defined determines whether the early return is present and thus whether some code paths that modify parameters can be omitted at build time. SIZEOF_SIZE_T: controls the conditional overflow-handling block; knowing its value determines whether extra operations (and potential effects on parameters or context fields) are compiled in. memcpy: include to confirm its semantics (it copies memory to the destination and does not alter the pointer parameter variables themselves), which helps distinguish allowed modifications of pointed-to objects from forbidden reassignment of pointer parameters. mhd_assert: include to confirm it is a diagnostic/no-op in production (i.e. it does not perform hidden side-effects that could modify function parameters)."
}