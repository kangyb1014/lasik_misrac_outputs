{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx (full definition)",
    "SHA512_256_BLOCK_SIZE (macro/value)",
    "sha512_256_transform (prototype and expected input block size)",
    "memcpy (declaration/semantics from <string.h>)",
    "SIZEOF_SIZE_T (macro)",
    "UINT64_C and the 0x1FFFFFFFFFFFFFFF mask constant",
    "typedefs: uint8_t, uint64_t, size_t"
  ],
  "explanation": "Explain why each symbol is required for checking the memcpy calls for out\u2011of\u2011bounds accesses:\n\n- struct Sha512_256Ctx (full definition): The code copies into ((uint8_t *) ctx->buffer) + bytes_have and uses ctx->count. To decide whether those memcpy calls can write past the object bounds you must know the precise type, element size and allocated length of ctx->buffer, and the type and width of ctx->count/count_bits_hi. The buffer capacity (number of bytes) is the primary determinant whether bytes_have + copied_length stays within bounds.\n\n- SHA512_256_BLOCK_SIZE (macro/value): bytes_have is computed relative to (SHA512_256_BLOCK_SIZE - 1) and the algorithm assumes buffer space at least SHA512_256_BLOCK_SIZE. Knowing the numeric value lets you prove bytes_have < block_size, bytes_left = block_size - bytes_have, and that the second memcpy copies fewer than block_size bytes; it also lets you check that any required buffer size is satisfied by ctx->buffer.\n\n- sha512_256_transform (prototype and expected input block size): The code passes ctx->buffer to this transform after filling a full block. To justify the invariant that ctx->buffer holds exactly SHA512_256_BLOCK_SIZE valid bytes when transform is called and that earlier memcpy produced a full block, you need the transform signature/contract (that it consumes SHA512_256_BLOCK_SIZE bytes). This helps tie the block-size semantics to the buffer sizing.\n\n- memcpy (declaration/semantics from <string.h>): The MISRA rule targets standard string.h functions. For a formal check you should reference memcpy semantics (number of bytes copied, no internal bounds checking) and parameter order to reason about the destination object and source object sizes and to show whether a call can write past the destination.\n\n- SIZEOF_SIZE_T (macro): The code contains an #if SIZEOF_SIZE_T > 7 conditional that affects the overflow/wrap handling of ctx->count. To reason whether ctx->count (and thus bytes_have = ctx->count & (block_size-1)) has the intended range and whether wrap-around could make bytes_have larger than expected, you must know the macro value used at compile time.\n\n- UINT64_C and the 0x1FFFFFFFFFFFFFFF mask constant: The code masks ctx->count with UINT64_C(0x1FFFFFFFFFFFFFFF) when count_hi != 0. To prove the bound bytes_have < block_size after masking/wrap handling you need the mask and understanding of UINT64_C (width) to see how ctx->count is constrained.\n\n- typedefs: uint8_t, uint64_t, size_t: The sizes/widths of these types (and their signedness where relevant) are necessary to compute numeric ranges (e.g., max ctx->count value, size of buffer pointers, arithmetic on length) and to ensure expressions like (unsigned int) (ctx->count & (block_size-1)) behave as expected and produce a bytes_have < block_size.\n\nProviding these symbols (struct layout and sizes, macros, function prototype and standard memcpy semantics) gives the necessary information to determine whether each memcpy invocation can access beyond the bounds of the destination object and thus whether the MISRA rule is violated."
}