{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx (full definition)",
    "SHA512_256_BLOCK_SIZE",
    "SIZEOF_SIZE_T",
    "MHD_FAVOR_SMALL_CODE",
    "mhd_assert (macro/function implementation)",
    "sha512_256_transform (definition/behaviour)",
    "memcpy (implementation/semantics)",
    "digest_update (caller wrapper)",
    "digest_update_str",
    "digest_update_with_colon",
    "calculate_nonce",
    "calc_userdigest",
    "calc_userhash",
    "digest_auth_check_all_inner"
  ],
  "explanation": "For each listed symbol: \n\n- struct Sha512_256Ctx (full definition): The function reads and writes fields of ctx (count, count_bits_hi, buffer, H). Their types, widths and semantics determine whether branches (count wrap handling, count_hi test, buffer/H updates) can ever be taken and whether assignments are observable; these determine if statements are dead. \n\n- SHA512_256_BLOCK_SIZE: Used in several control tests and loop bounds (bytes_have computation, bytes_left, while loop). Its value (e.g. 128) directly affects branch/loop reachability and whether copying versus direct transform code is ever executed. \n\n- SIZEOF_SIZE_T: Controls conditional compilation of the overflow-detection block (#if SIZEOF_SIZE_T > 7). Knowing this value decides whether that code is present and therefore whether it can be dead. \n\n- MHD_FAVOR_SMALL_CODE: Controls inclusion of the early-return shortcut for length==0 (#ifndef MHD_FAVOR_SMALL_CODE). Its definition decides whether that branch exists; necessary to know if the early-return code could be dead or not. \n\n- mhd_assert (macro/function implementation): The assert may be a no-op in some builds or perform checks/side-effects in others. To decide if the mhd_assert call is meaningful (non-dead) we must know its expansion/side-effects. \n\n- sha512_256_transform (definition/behaviour): Called for each full block. To determine whether calls to it (and the surrounding code that prepares/dispatches blocks) are necessary, we must know whether the transform has observable side-effects (updates H, alters state used elsewhere). Its behaviour makes the surrounding code non-removable. \n\n- memcpy (implementation/semantics): Used to copy remaining partial-block bytes into ctx->buffer; if memcpy can be optimized away or has side-effects, or if buffer contents are never used, that affects dead-code judgement. Knowledge of memcpy semantics and whether it is the standard version is required. \n\n- digest_update (caller wrapper) and its callers (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner): To judge whether parts of MHD_SHA512_256_update are ever executed in the deployed program (and thus whether they are dead), you need to know how the function is called in practice and what argument ranges are passed (particularly length and data). Examining these callers and their call-sites can show whether e.g. length==0, length<block size, or large lengths occur in real usage, which affects reachability of branches and loops in the target function.\n\n(Other standard typedefs like uint8_t, size_t, uint64_t and the UINT64_C macro are assumed available from standard headers; include them only if your environment might redefine them.)"
}