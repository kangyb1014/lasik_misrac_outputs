{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_update': {'callees': ['sha512_256_transform'], 'callers': ['digest_update']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "memcpy",
    "memcmp",
    "sha512_256_transform",
    "struct Sha512_256Ctx (definition)",
    "SHA512_256_BLOCK_SIZE",
    "mhd_assert",
    "SIZEOF_SIZE_T",
    "UINT64_C",
    "ctx->buffer type/definition",
    "ctx->H field definition (type)",
    "uint8_t",
    "size_t",
    "uint64_t"
  ],
  "explanation": "- memcpy: The function calls memcpy; need its definition/aliasing to ensure it is not a macro or wrapper that actually calls or maps to memcmp (which would violate the rule).\n- memcmp: Explicitly check for any use of memcmp either directly in this translation unit or indirectly in callees (e.g. sha512_256_transform) to determine if memcmp is used to compare null-terminated strings.\n- sha512_256_transform: Called by the target; examine its implementation to ensure it does not call memcmp (or otherwise compare null-terminated strings with memcmp).\n- struct Sha512_256Ctx (definition): Field types and buffer layout (count, count_bits_hi, buffer, H) are needed to see whether any pointer arithmetic or buffer contents could be treated as C strings, which would be relevant if memcmp were applied to them.\n- SHA512_256_BLOCK_SIZE: Value and semantics are needed to reason about buffer sizes and whether any memcpy/memcmp usage might be operating on string data vs binary blocks.\n- mhd_assert: Macro/function that might expand into code that uses memcmp or string comparisons; its definition is needed to rule that out.\n- SIZEOF_SIZE_T: Preprocessor-controlled branch affects code paths; its value is needed to see whether code that could involve memcmp is compiled in.\n- UINT64_C: Macro used for count masking; include to verify no surprising side effects or macros that reference string functions.\n- ctx->buffer type/definition: To determine whether the buffer holds binary data or a null-terminated string and whether copying it could later cause a memcmp-on-string.\n- ctx->H field definition (type): To inspect callees (sha512_256_transform) usage and confirm no memcmp on digest/state treated as strings.\n- uint8_t, size_t, uint64_t: Type definitions to fully understand the code and any casts that might cause string interpretation.\n\nThese symbols let the analyzer determine whether any memcmp use exists in this function or its callees, and whether any memcmp calls (direct or indirect) are comparing null-terminated strings (the MISRA rule concern)."
}