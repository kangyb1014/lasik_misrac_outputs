{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'read_cb': {'callees': ['compress_buf'], 'callers': []}, 'compress_buf': {'callees': [], 'callers': ['read_cb']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Holder",
    "compress_buf (declaration/definition)",
    "MHD_CONTENT_READER_END_WITH_ERROR",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "MHD_YES",
    "SSIZE_MAX",
    "ssize_t",
    "uint64_t",
    "size_t",
    "FILE",
    "fread",
    "malloc",
    "free",
    "memcpy",
    "ferror",
    "NULL"
  ],
  "explanation": "For checking whether the target function uses compiler/language extensions you must inspect the definitions of identifiers/types/macros that could themselves be implemented as or rely on extensions. Brief reasons for each: \n\n- struct Holder: The function dereferences holder->file, holder->stream and holder->buf. The Holder definition may use non\u2011standard attributes, compiler extensions (packed, aligned, __attribute__, bitfields with implementation-defined behaviour), or contain members of nonstandard types \u2014 so the struct must be inspected. \n\n- compress_buf (declaration/definition): The call site depends on the prototype/definition to know whether it uses nonstandard calling conventions, GCC attributes, inline asm, varargs, or other extensions that could make the call invoke an extension. You need its signature/implementation to determine extension usage. \n\n- MHD_CONTENT_READER_END_WITH_ERROR and MHD_CONTENT_READER_END_OF_STREAM: These macros/constants determine the numeric return values and might be defined via extension constructs (e.g. statement expressions, complex macros, typeof, compiler attributes) or as types not compatible with standard ssize_t. Their definitions must be checked. \n\n- MHD_YES: This macro/constant controls the result of compress_buf; it may be a nonstandard enum or macro implemented using compiler extensions. Verify its definition. \n\n- SSIZE_MAX: This macro is used in the pos > SSIZE_MAX test. SSIZE_MAX is not defined by ISO C standard headers on all platforms (commonly POSIX). You must inspect where SSIZE_MAX comes from to determine whether its presence relies on POSIX or other extensions. \n\n- ssize_t: ssize_t is a POSIX type (not part of ISO C until some versions). You must confirm whether ssize_t is provided by a standard-compliant header or introduced via a platform/extension typedef. Its use might constitute use of a non\u2011standard type. \n\n- uint64_t: This is a C99/stdint type; check whether the project mandates C99 or whether uint64_t is provided by an extension or typedef on this platform. \n\n- size_t: Although standard, you should confirm its origin to ensure no nonstandard redefinition is in play. \n\n- FILE: The holder->file member is likely FILE*; inspect its definition/header to ensure no nonstandard redefinition or extension is used. \n\n- fread, malloc, free, memcpy, ferror, NULL: These library symbols are standard C, but their declarations/macros may be shadowed or redefined in the codebase (or implemented via wrappers that use extensions). Inspect their declarations in the build to ensure no use of compiler extensions (e.g. inline asm, attributes, nonstandard prototypes, complex macros) that would violate the MISRA rule. \n\nIn short: inspect the Holder struct, the compress_buf routine, and the macros and types used in the function (SSIZE_MAX, ssize_t, uint64_t, the MHD_* symbols) and the actual declarations/wrappers of the standard library calls to determine if any of those symbols are defined using compiler/language extensions that would make the target function violate the MISRA rule."
}