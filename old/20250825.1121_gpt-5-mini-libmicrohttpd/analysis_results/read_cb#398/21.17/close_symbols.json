{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'read_cb': {'callees': ['compress_buf'], 'callers': []}, 'compress_buf': {'callees': [], 'callers': ['read_cb']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Holder (full definition)",
    "compress_buf (prototype and behavioral contract / postconditions)",
    "holder->buf (type and allocated capacity / semantics)",
    "MHD_YES (value) and the return codes: MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM",
    "read_cb API contract (caller guarantees for mem and size)",
    "fread and ferror semantics / prototype",
    "malloc / free semantics (prototype) and behavior of malloc(size)",
    "SSIZE_MAX definition"
  ],
  "explanation": "Explain why each symbol is required to decide if memcpy(mem, buf, size) can access out of bounds:\n\n- struct Holder (full definition): read_cb dereferences holder->file, holder->stream and passes holder->buf to compress_buf. To reason about buffer lifetimes and capacities you must know Holder's fields and types (in particular the type and allocation/size of holder->buf and the type of holder->stream). If holder->buf is a fixed-size buffer and compress_buf can point buf into it, its capacity constrains safe copy length.\n\n- compress_buf (prototype and behavioral contract / postconditions): this is the most important symbol. The function is called with &offset, &buf, &size and must document (a) whether it writes a new value into the size parameter and what that new value means (bytes available in buf), (b) whether it can increase size beyond the input value, (c) whether it allocates or returns a pointer into holder->buf (ownership and minimum buffer length guarantees), and (d) whether buf is valid when compress_buf returns MHD_YES. Without this contract you cannot determine whether memcpy(mem, buf, size) will read more bytes from buf than buf actually contains or will copy more bytes into mem than mem can hold.\n\n- holder->buf (type and allocated capacity / semantics): compress_buf receives holder->buf as its last parameter and may return buf pointing into it. To know whether buf has at least 'size' bytes after compress_buf returns you need the capacity and usage policy of holder->buf.\n\n- MHD_YES and return codes (MHD_CONTENT_READER_END_WITH_ERROR, MHD_CONTENT_READER_END_OF_STREAM): the code executes memcpy only when compress_buf returns MHD_YES. Knowing the exact value of MHD_YES and the semantics of the other codes is necessary to determine which control-flow paths actually reach the memcpy and under what success conditions compress_buf must guarantee its postconditions.\n\n- read_cb API contract (caller guarantees for mem and size): the safety of memcpy also depends on the caller's guarantees for the mem buffer and the meaning of the size parameter at entry. You must know whether the caller guarantees that mem points to a buffer of exactly (or at least) the initial input 'size' bytes and whether the read_cb implementation is permitted to change the local size variable. If the API requires that the function copy at most the initial size, compress_buf must not increase size beyond that. This contract is essential to determine if memcpy could write beyond mem.\n\n- fread and ferror semantics / prototype: read_cb allocates src with malloc(size) and then calls fread(src, 1, size, holder->file) and passes r_size to compress_buf. To ensure that src accesses are in-bounds, you must know the standard guarantees from fread (that it reads at most the requested count and returns the number of items read). This ensures src is large enough for r_size bytes passed to compress_buf.\n\n- malloc / free semantics (prototype) and behavior of malloc(size): to reason about src buffer validity you need the usual guarantee that malloc(size) returns a block of at least 'size' bytes (or NULL). This supports the claim that fread writes within src and that free(src) is valid.\n\n- SSIZE_MAX definition: pos is compared against SSIZE_MAX and then cast to size_t into offset. For completeness of bounds reasoning (especially if pos could be large and affect offset/size logic in compress_buf), you need the numeric value/limits semantics of SSIZE_MAX on the target platform.\n\nTogether these symbols provide the necessary type, allocation, API and postcondition information to determine whether memcpy(mem, buf, size) can read or write past the bounds of buf or mem (the MISRA string-handling/bounds rule)."
}