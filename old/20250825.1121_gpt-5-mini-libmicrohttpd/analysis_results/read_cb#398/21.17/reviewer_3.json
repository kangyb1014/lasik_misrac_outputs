{
  "user_message": "An agent A claimed that the following read_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of read_cb.\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\ncompress_buf is passed &size and &buf and may modify size to a value larger than the capacity of the 'mem' buffer passed into read_cb. If compress_buf increases size (for example sets size to N where N > original buffer length) and returns success, the subsequent call memcpy(mem, buf, size) will copy more than the caller-provided 'mem' buffer can hold, resulting in an out-of-bounds access of 'mem' (a string.h function use). Therefore the call as written can lead to a Rule 21.17 violation unless compress_buf is guaranteed to never set size larger than the original capacity of mem and to ensure buf points to at least size bytes.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function read_cb:\n#define MHD_CONTENT_READER_END_OF_STREAM ((ssize_t)-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct. The memcpy(mem, buf, size) call can copy more bytes into the caller-supplied mem buffer than it can hold because compress_buf is called with &size and &buf and is free to modify size. The function makes no check that the (potentially modified) size is <= the original capacity of mem (the initial size parameter passed into read_cb). MISRA C 2023 Rule 21.17 requires that use of string.h functions must not result in accesses beyond object bounds; here that cannot be proven from the code shown. (The only way this would be safe is if compress_buf is specified/implemented to guarantee it never increases size beyond the original capacity and that buf points to at least size bytes \u2014 but no such guarantee appears in the code snippet.)"
}