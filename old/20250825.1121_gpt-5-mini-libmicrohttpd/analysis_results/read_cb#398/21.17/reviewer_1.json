{
  "user_message": "An agent A claimed that the following read_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of read_cb.\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memcpy(mem, buf, size) can copy more bytes than the buffer pointed to by mem (and can also read beyond buf) because compress_buf is passed &size and may modify size independently of the actual capacity of mem. If compress_buf increases size (e.g. compression expands data) or returns a buf shorter than size, memcpy will access out-of-bounds memory. Therefore the use of memcpy can result in accesses beyond the bounds of the objects referenced by its pointer parameters.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function read_cb:\n#define MHD_CONTENT_READER_END_OF_STREAM ((ssize_t)-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The call memcpy(mem, buf, size) uses the variable size after it was passed by address to compress_buf (&size). Nothing in the shown code guarantees compress_buf will preserve the original value of size or that it will not increase it. If compress_buf sets size to a value greater than the capacity of mem (the caller-provided buffer) or makes buf smaller than the new size, memcpy may write beyond mem or read beyond buf, which is exactly the out-of-bounds scenario MISRA C 2023 Rule 21.17 forbids. \n\nThis function is only safe if compress_buf has a documented/verified contract that (a) it will not increase size beyond the original value passed in and (b) it returns a buf that is at least size bytes long. Absent that contract or an explicit bounds check before memcpy (e.g. cap size to the original mem capacity), the code violates Rule 21.17."
}