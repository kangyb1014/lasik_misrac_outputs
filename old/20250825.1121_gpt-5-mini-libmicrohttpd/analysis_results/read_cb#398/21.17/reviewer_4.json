{
  "user_message": "An agent A claimed that the following read_cb code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of read_cb.\n```c\nstatic ssize_t\nread_cb (void *cls, uint64_t pos, char *mem, size_t size)\n{\n  struct Holder *holder = cls;\n  void *src;\n  void *buf;\n  ssize_t ret;\n  size_t offset;\n  size_t r_size;\n\n  if (pos > SSIZE_MAX)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  offset = (size_t) pos;\n  src = malloc (size);\n  if (NULL == src)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  r_size = fread (src, 1, size, holder->file);\n  if (0 == r_size)\n  {\n    ret = (0 != ferror (holder->file)) ?\n          MHD_CONTENT_READER_END_WITH_ERROR : MHD_CONTENT_READER_END_OF_STREAM;\n    goto done;\n  }\n  if (MHD_YES != compress_buf (&holder->stream, src, r_size, &offset, &buf,\n                               &size, holder->buf))\n    ret = MHD_CONTENT_READER_END_WITH_ERROR;\n  else\n  {\n    memcpy (mem, buf, size);\n    ret = (ssize_t) size;\n  }\n  free (buf); /* Buf may be set even on error return. */\ndone:\n  free (src);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memcpy(mem, buf, size) uses the (possibly modified) variable 'size' without verifying that 'mem' points to at least 'size' bytes or that 'buf' contains at least 'size' bytes. In this function 'size' is passed by address to compress_buf(&..., &buf, &size, ...), so compress_buf could increase size (or otherwise set a value larger than the caller-provided buffer length) or provide a buf smaller than size. If compress_buf returns success with size larger than the original/requested destination buffer length, memcpy will write beyond the bounds of mem (or read beyond the bounds of buf), violating MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function read_cb:\n#define MHD_CONTENT_READER_END_OF_STREAM ((ssize_t)-1)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. Rule 21.17 forbids calls to functions such as memcpy that may access beyond the bounds of the objects referenced by their pointer parameters. In the shown code memcpy(mem, buf, size) uses the variable size that was passed by address to compress_buf (&..., &size, ...). compress_buf is free to modify size (increase it) and to set buf to point to any buffer; the caller performs no check after compress_buf returns to ensure that mem points to at least size bytes or that buf contains at least size bytes. Therefore, unless there is an external, provable contract for compress_buf that guarantees size will never exceed the original destination buffer length and that buf points to a buffer of at least size bytes, the memcpy can read or write out of bounds and thus violates MISRA C 2023 Rule 21.17. Because no such guarantee is visible in the provided code, the agent A report is correct."
}