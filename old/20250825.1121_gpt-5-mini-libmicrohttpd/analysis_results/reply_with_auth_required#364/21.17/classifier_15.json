{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of reply_with_auth_required:\n```c\nstatic enum MHD_Result\nreply_with_auth_required (struct MHD_Connection *c,\n                          int stale,\n                          int wrong_cred)\n{\n  static const char auth_required_content[] =\n    \"<html><head><title>Authentication required</title></head>\" \\\n    \"<body>The requested page needs authentication.</body></html>\";\n  static const size_t auth_required_content_len =\n    (sizeof(auth_required_content) / sizeof(char)) - 1;\n  static const char wrong_creds_content[] =\n    \"<html><head><title>Wrong credentials</title></head>\" \\\n    \"<body>The provided credentials are incorrect.</body></html>\";\n  static const size_t wrong_creds_content_len =\n    (sizeof(wrong_creds_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  if (wrong_cred)\n    stale = 0; /* Force client to ask user for username and password */\n\n  if (! wrong_cred)\n    resp = MHD_create_response_from_buffer_static (auth_required_content_len,\n                                                   auth_required_content);\n  else\n    resp = MHD_create_response_from_buffer_static (wrong_creds_content_len,\n                                                   wrong_creds_content);\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE, \"text/html\");\n\n\n  ret = MHD_queue_auth_required_response3 (\n    c,\n    REALM,\n    OPAQUE_DATA, /* The \"opaque data\", not really useful */\n    SEC_AREA1_URL \" \" SEC_AREA2_URL, /* Space-separated list of URLs' initial parts */\n    resp,\n    stale,\n    get_m_QOP (),\n    get_m_algo (),\n    ! 0, /* Userhash support enabled */\n    ! 0 /* UTF-8 is preferred */);\n  MHD_destroy_response (resp);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function reply_with_auth_required:\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback_cls (size_t size,\n                                                        const void *buffer,\n                                                        MHD_ContentReaderFreeCallback\n                                                        crfc,\n                                                        void *crfc_cls)\n{\n  struct MHD_Response *r;\n\n  if ((NULL == buffer) && (size > 0))\n    return NULL;\n#if SIZEOF_SIZE_T >= SIZEOF_UINT64_T\n  if (MHD_SIZE_UNKNOWN == size)\n    return NULL;\n#endif /* SIZEOF_SIZE_T >= SIZEOF_UINT64_T */\n  r = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == r)\n    return NULL;\n#if defined(MHD_USE_THREADS)\n  if (! MHD_mutex_init_ (&r->mutex))\n  {\n    free (r);\n    return NULL;\n  }\n#endif\n  r->fd = -1;\n  r->reference_count = 1;\n  r->total_size = size;\n  r->data = buffer;\n  r->data_size = size;\n  r->crfc = crfc;\n  r->crc_cls = crfc_cls;\n  return r;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n...\nint\nMHD_str_equal_caseless_ (const char *str1,\n                         const char *str2)\n{\n  while (0 != (*str1))\n  {\n    const char c1 = *str1;\n    const char c2 = *str2;\n    if (charsequalcaseless (c1, c2))\n    {\n      str1++;\n      str2++;\n    }\n    else\n      return 0;\n  }\n  return 0 == (*str2);\n}\n...\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n...\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_required_response3 (struct MHD_Connection *connection,\n                                   const char *realm,\n                                   const char *opaque,\n                                   const char *domain,\n                                   struct MHD_Response *response,\n                                   int signal_stale,\n                                   enum MHD_DigestAuthMultiQOP mqop,\n                                   enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                   int userhash_support,\n                                   int prefer_utf8)\n{\n  struct DigestAlgorithm da;\n  char *buf_ptr;\n  enum MHD_Result ret;\n\n  buf_ptr = NULL;\n  digest_setup_zero (&da);\n  ret = queue_auth_required_response3_inner (connection,\n                                             realm,\n                                             opaque,\n                                             domain,\n                                             response,\n                                             signal_stale,\n                                             mqop,\n                                             malgo3,\n                                             userhash_support,\n                                             prefer_utf8,\n                                             &buf_ptr,\n                                             &da);\n  digest_deinit (&da);\n  if (NULL != buf_ptr)\n    free (buf_ptr);\n  return ret;\n}\n...\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo; /**< Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  if (0 == (((unsigned int) malgo3) & MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Only non-'session' algorithms are supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  malgo3 =\n    (enum MHD_DigestAuthMultiAlgo3)\n    (malgo3\n     & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    if (0 == (((unsigned int) malgo3)\n              & (MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_BASE_ALGO_SHA512_256\n                 | MHD_DIGEST_BASE_ALGO_SHA512_256)))\n      MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n    else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"No requested algorithm is supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC (_ (\"Wrong 'mqop' value, API violation\"));\n\n  mqop = (enum MHD_DigestAuthMultiQOP)\n         (mqop\n          & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n#ifdef HAVE_MESSAGES\n    if ((0 != userhash_support) || (0 != prefer_utf8))\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'userhash' and 'charset' ('prefer_utf8') parameters \" \\\n                   \"are not compatible with RFC2069 and ignored.\\n\"));\n    if (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n      MHD_DLOG (connection->daemon,\n                _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                   \"non-standard extension.\\n\"));\n#endif\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The nonce array size is zero.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_realm) + 3; /* 3 for '\", ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < realm_len)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'realm' is too large.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) ||\n      (NULL != memchr (realm, '\\n', realm_len)))\n    return MHD_NO;\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_qop) + 3; /* 3 for '\", ' */\n    buf_size += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_algo) + 2; /* 2 for ', ' */\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_nonce) + 3; /* 3 for '\", ' */\n  buf_size += NONCE_STD_LEN (digest_get_size (da)); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_opaque) + 3; /* 3 for '\", ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) ||\n        (NULL != memchr (opaque, '\\n', opaque_len)))\n      return MHD_NO;\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_domain) + 3; /* 3 for '\", ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) ||\n        (NULL != memchr (domain, '\\n', domain_len)))\n      return MHD_NO;\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += MHD_STATICSTR_LEN_ (str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += MHD_STATICSTR_LEN_ (str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += MHD_STATICSTR_LEN_ (str_stale) + 2; /* 2 for ', ' */\n\n  /* The calculated length is for string ended with \", \". One character will\n   * be used for zero-termination, the last one will not be used. */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE,\n          MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE));\n  p += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm,\n          MHD_STATICSTR_LEN_ (prefix_realm));\n  p += MHD_STATICSTR_LEN_ (prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  if (1)\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < quoted_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'realm' is too large after 'quoting'.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop,\n            MHD_STATICSTR_LEN_ (prefix_qop));\n    p += MHD_STATICSTR_LEN_ (prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_,\n            MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_));\n    p += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    }\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce,\n          MHD_STATICSTR_LEN_ (prefix_nonce));\n  p += MHD_STATICSTR_LEN_ (prefix_nonce);\n  mhd_assert ((buf_size - p) >= (NONCE_STD_LEN (digest_get_size (da))));\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"TLS library reported hash calculation error, nonce could \"\n                   \"not be generated.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Could not register nonce. Client's requests with this \"\n                 \"nonce will be always 'stale'. Probably clients' requests \"\n                 \"are too intensive.\\n\"));\n#endif /* HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning for builds without messages */\n  }\n  p += NONCE_STD_LEN (digest_get_size (da));\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque,\n            MHD_STATICSTR_LEN_ (prefix_opaque));\n    p += MHD_STATICSTR_LEN_ (prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain,\n            MHD_STATICSTR_LEN_ (prefix_domain));\n    p += MHD_STATICSTR_LEN_ (prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset,\n            MHD_STATICSTR_LEN_ (str_charset));\n    p += MHD_STATICSTR_LEN_ (str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash,\n            MHD_STATICSTR_LEN_ (str_userhash));\n    p += MHD_STATICSTR_LEN_ (str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale,\n            MHD_STATICSTR_LEN_ (str_stale));\n    p += MHD_STATICSTR_LEN_ (str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n            MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          MHD_STATICSTR_LEN_ ( \\\n                                            MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to add Digest auth header.\\n\"));\n    }\n#endif /* HAVE_MESSAGES */\n    free (hdr_name);\n  }\n  return MHD_NO;\n}\n...\nstatic enum MHD_DigestAuthMultiQOP\nget_m_QOP (void)\n{\n  if (allow_rfc2069)\n    return MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT;\n\n  return MHD_DIGEST_AUTH_MULT_QOP_AUTH;\n}\n...\nstatic enum MHD_DigestAuthMultiAlgo3\nget_m_algo (void)\n{\n  if (force_md5)\n    return MHD_DIGEST_AUTH_MULT_ALGO3_MD5;\n  else if (force_sha256)\n    return MHD_DIGEST_AUTH_MULT_ALGO3_SHA256;\n  else if (force_sha512_256)\n    return MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256;\n\n  /* No forced algorithm selection, let MHD to use default */\n  return MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION;\n}\n...\n#define REALM \"authenticated_users@thishost\"\n...\n#define OPAQUE_DATA \"ServerOpaqueData\"\n...\n#define SEC_AREA1_URL \"/secret_page/\"\n...\n#define SEC_AREA2_URL \"/super_secret_page/\"\n...\n#define MHD_HTTP_HEADER_CONTENT_TYPE \"Content-Type\"\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n    memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n    p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The code computes buf_size earlier to include MHD_STATICSTR_LEN_(prefix_algo) plus the selected algorithm token length and the following \", \" (two chars). The buffer is allocated to buf_size and p tracks the current write position; subsequent copies increment p accordingly. There are asserts and earlier checks that ensure adequate space (the size computation includes the token and comma/space), so the memcpy calls do not access beyond the bounds of buf or the source tokens. Therefore Rule 21.17 is not violated."
}