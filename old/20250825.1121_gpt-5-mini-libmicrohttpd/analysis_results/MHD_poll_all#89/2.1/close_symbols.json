{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_poll_all (struct MHD_Daemon *daemon,\n              int32_t millisec)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + (size_t) num_connections),\n                     sizeof (struct pollfd));\n    if (NULL == p)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      return MHD_NO;\n    }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n         (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n    {\n      /* only listen if we are not at the connection limit */\n      p[poll_server].fd = ls;\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_listen = (int) poll_server;\n      poll_server++;\n    }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n    {\n      p[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_server].events = POLLIN;\n      p[poll_server].revents = 0;\n      poll_itc_idx = (int) poll_server;\n      poll_server++;\n    }\n\n    timeout = get_timeout_millisec_int (daemon, millisec);\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      p[poll_server + i].fd = pos->socket_fd;\n      switch (pos->event_loop_info)\n      {\n      case MHD_EVENT_LOOP_INFO_READ:\n      case MHD_EVENT_LOOP_INFO_PROCESS_READ:\n        p[poll_server + i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_WRITE:\n        p[poll_server + i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_PROCESS:\n        p[poll_server + i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n        break;\n      case MHD_EVENT_LOOP_INFO_CLEANUP:\n        timeout = 0; /* clean up \"pos\" immediately */\n        break;\n      }\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n    {\n      urh_to_pollfd (urh, &(p[poll_server + i]));\n      i += 2;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n    {\n      free (p);\n      return MHD_YES;\n    }\n    if (MHD_sys_poll_ (p,\n                       poll_server + num_connections,\n                       timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free (p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      free (p);\n      return MHD_NO;\n    }\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n    {\n      free (p);\n      return MHD_NO;\n    }\n\n    /* Process externally added connection if any */\n    if (daemon->have_new)\n      new_connections_list_process_ (daemon);\n\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n         (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n    {\n      prev = pos->prev;\n      /* first, sanity checks */\n      if (i >= num_connections)\n        break;     /* connection list changed somehow, retry later ... */\n      if (p[poll_server + i].fd != pos->socket_fd)\n        continue;  /* fd mismatch, something else happened, retry later ... */\n      call_handlers (pos,\n                     0 != (p[poll_server + i].revents & POLLIN),\n                     0 != (p[poll_server + i].revents & POLLOUT),\n                     0 != (p[poll_server + i].revents\n                           & MHD_POLL_REVENTS_ERR_DISC));\n      i++;\n    }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      if (i >= num_connections)\n        break;   /* connection list changed somehow, retry later ... */\n\n      /* Get next connection here as connection can be removed\n       * from 'daemon->urh_head' list. */\n      urhn = urh->prev;\n      /* Check for fd mismatch. FIXME: required for safety? */\n      if ((p[poll_server + i].fd != urh->connection->socket_fd) ||\n          (p[poll_server + i + 1].fd != urh->mhd.socket))\n        break;\n      urh_from_pollfd (urh,\n                       &p[poll_server + i]);\n      i += 2;\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n      {\n        /* MHD_connection_finish_forward_() will remove connection from\n         * 'daemon->urh_head' list. */\n        MHD_connection_finish_forward_ (urh->connection);\n        urh->clean_ready = true;\n        /* If 'urh->was_closed' already was set to true, connection will be\n         * moved immediately to cleanup list. Otherwise connection\n         * will stay in suspended list until 'urh' will be marked\n         * with 'was_closed' by application. */\n        MHD_resume_connection (urh->connection);\n      }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n    free (p);\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_poll_all': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'call_handlers'], 'callers': ['MHD_poll', 'MHD_run_wait']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'get_timeout_millisec_int': {'callees': ['get_timeout_millisec_'], 'callers': ['MHD_poll_all', 'MHD_epoll']}, 'new_connections_list_process_': {'callees': ['__builtin_unreachable', 'new_connection_process_', 'MHD_DLOG'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}, 'MHD_poll': {'callees': ['MHD_poll_all', 'MHD_poll_listen_socket'], 'callers': ['MHD_polling_thread']}, 'MHD_run_wait': {'callees': ['MHD_poll_all', 'MHD_cleanup_connections', 'MHD_epoll', 'MHD_select'], 'callers': ['MHD_run']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon::options",
    "struct MHD_Daemon::tid",
    "struct MHD_Daemon::connections_head",
    "struct MHD_Daemon::connections_tail",
    "struct MHD_Daemon::urh_head",
    "struct MHD_Daemon::urh_tail",
    "struct MHD_Daemon::listen_fd",
    "struct MHD_Daemon::was_quiesced",
    "struct MHD_Daemon::connections",
    "struct MHD_Daemon::connection_limit",
    "struct MHD_Daemon::at_limit",
    "struct MHD_Daemon::itc",
    "struct MHD_Daemon::shutdown",
    "struct MHD_Daemon::have_new",
    "struct MHD_Daemon::data_already_pending",
    "MHD_USE_SELECT_INTERNALLY (flag)",
    "MHD_TEST_ALLOW_SUSPEND_RESUME (flag)",
    "MHD_NO / MHD_YES (return enumerators)",
    "MHD_INVALID_SOCKET (constant)",
    "resume_suspended_connections (function)",
    "MHD_thread_handle_ID_is_valid_ID_ (macro/function used by asserts)",
    "MHD_thread_handle_ID_is_current_thread_ (macro/function used by asserts)",
    "MHD_calloc_ (allocator) and free",
    "get_timeout_millisec_int and get_timeout_millisec_ (functions)",
    "MHD_ITC_IS_VALID_ (macro)",
    "MHD_itc_r_fd_ and MHD_itc_clear_ (ITC helpers)",
    "MHD_sys_poll_ (wrapping poll) and poll-related constants POLLIN, POLLOUT",
    "MHD_POLL_EVENTS_ERR_DISC and MHD_POLL_REVENTS_ERR_DISC (poll flag masks)",
    "MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_ (poll error helpers)",
    "new_connections_list_process_ (function)",
    "MHD_accept_connection (function)",
    "struct MHD_Connection::next, ::prev, ::socket_fd, ::event_loop_info",
    "enum/event codes: MHD_EVENT_LOOP_INFO_READ, MHD_EVENT_LOOP_INFO_PROCESS_READ, MHD_EVENT_LOOP_INFO_WRITE, MHD_EVENT_LOOP_INFO_PROCESS, MHD_EVENT_LOOP_INFO_CLEANUP",
    "call_handlers (function) and its callees: MHD_connection_handle_read, MHD_connection_handle_write, MHD_connection_handle_idle, MHD_connection_close_",
    "HTTPS_SUPPORT / UPGRADE_SUPPORT build symbols (if enabled): struct MHD_UpgradeResponseHandle and functions urh_to_pollfd, urh_from_pollfd, process_urh, MHD_connection_finish_forward_, MHD_resume_connection"
  ],
  "explanation": "To decide whether any code in MHD_poll_all is unreachable you must know which conditional expressions and switches can never be true or which code paths are impossible. That requires the daemon state fields and relevant flags (options, tid, listen_fd, was_quiesced, connection counts/limits, itc, shutdown, have_new, data_already_pending) because many if/loop entries depend on them. The flags MHD_USE_SELECT_INTERNALLY and MHD_TEST_ALLOW_SUSPEND_RESUME and the MHD_NO/MHD_YES and MHD_INVALID_SOCKET constants determine the truth of top-level conditionals. resume_suspended_connections is required because its possible return values (and side effects) control an early branch (millisec = 0). The assert helpers (MHD_thread_handle_ID_is_valid_ID_, MHD_thread_handle_ID_is_current_thread_) are included because assert conditions can affect compile-time/analysis assumptions. Memory-allocation helpers (MHD_calloc_, free) and get_timeout_millisec_int/get_timeout_millisec_ affect whether early returns or zero-timeout paths occur. ITC-related macros and functions (MHD_ITC_IS_VALID_, MHD_itc_r_fd_, MHD_itc_clear_) govern whether the ITC branch executes. MHD_sys_poll_ and the poll-related constants (POLLIN, POLLOUT, MHD_POLL_EVENTS_ERR_DISC, MHD_POLL_REVENTS_ERR_DISC) and the socket-error helpers (MHD_socket_get_error_, MHD_SCKT_ERR_IS_EINTR_, MHD_socket_strerr_) are needed to determine whether error-handling branches after poll can occur. The connection list structure (struct MHD_Connection fields and its event_loop_info enum values) is required to reason about which switch/case arms in the per-connection loop can be reached (e.g. CLEANUP forcing timeout=0). call_handlers and its callees can mutate connection lists or close connections; their semantics are necessary to determine whether later code is reachable after list mutation. Finally, HTTPS/UPGRADE-related types and helpers (urh struct and urh_to_pollfd/urh_from_pollfd/process_urh and the forwarding/finish/resume functions) are needed if those build-time options are enabled because they add extra poll entries and loops; their behavior (removal of connections, fd layout) affects whether related code is reachable. These symbols together let an analyzer determine whether any conditional/switch/loop in MHD_poll_all can never be true or whether code is only present for impossible states (i.e. truly unreachable)."
}