{
  "user_message": "An agent A claimed that the following get_rq_unames_size code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_unames_size.\n```c\n_MHD_static_inline size_t\nget_rq_unames_size (const struct MHD_RqDAuth *params,\n                    enum MHD_DigestAuthUsernameType uname_type)\n{\n  size_t s;\n\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  s = 0;\n  if ((MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type) ||\n      (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type) )\n  {\n    s += params->username.value.len + 1; /* Add one byte for zero-termination */\n    if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n      s += (params->username.value.len + 1) / 2;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n    s += params->username_ext.value.len\n         - MHD_DAUTH_EXT_PARAM_MIN_LEN + 1; /* Add one byte for zero-termination */\n  return s;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe test 'if (NULL == params->username_ext.value.str)' reads a pointer member of a const-qualified parameter. If the struct member 'username_ext.value.str' is declared as a non-const pointer (e.g. char *str), this violates MISRA C 2023 Rule 8.13 because the pointer points to a non-const type despite only being read. The pointer should be declared to point to a const-qualified type (e.g. const char *str) when the data is not modified.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_unames_size:\n_MHD_static_inline enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  if (NULL != params->username.value.str)\n  {\n    if (NULL == params->username_ext.value.str)\n      return params->userhash ?\n             MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH :\n             MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    else  /* Both 'username' and 'username*' are used */\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  else if (NULL != params->username_ext.value.str)\n  {\n    if (! params->username_ext.quoted && ! params->userhash &&\n        (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len) )\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\n...\n#define MHD_DAUTH_EXT_PARAM_MIN_LEN MHD_STATICSTR_LEN_(MHD_DAUTH_EXT_PARAM_PREFIX\"'\")\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 8.13 is a requirement about pointer declarations: a pointer type should be const-qualified when the pointed-to object is not modified through that pointer. The code shown only reads pointer members of a const-qualified struct parameter (checks for NULL and uses the length fields); it does not itself attempt to modify the characters pointed to. That usage alone does not prove a Rule 8.13 violation. To determine a definite violation you must inspect the declarations of the struct members (e.g. whether username.value.str / username_ext.value.str are declared as char * or const char *) and the rest of the program to see whether those pointers are ever used to modify the pointed-to data. If the members are declared as char * but the pointed-to data are never (and should never be) modified, then the members should be declared as const char * and a Rule 8.13 violation could be reported. However, from the provided snippets you cannot conclude that such a change is correct or that the rule is violated. Therefore the agent A report is not conclusive and is not correct as stated."
}