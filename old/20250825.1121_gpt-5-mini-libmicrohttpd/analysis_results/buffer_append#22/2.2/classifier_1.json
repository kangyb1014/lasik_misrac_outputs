{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of buffer_append:\n```c\nstatic bool\nbuffer_append (char *buf,\n               size_t *ppos,\n               size_t buf_size,\n               const char *append,\n               size_t append_size)\n{\n  mhd_assert (NULL != buf); /* Mute static analyzer */\n  if (buf_size < *ppos + append_size)\n    return false;\n  memcpy (buf + *ppos, append, append_size);\n  *ppos += append_size;\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function buffer_append:\nstatic enum MHD_Result\nbuild_header_response (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Response *const r = c->rp.response; /**< a short alias */\n  char *buf;                                     /**< the output buffer */\n  size_t pos;                                    /**< append offset in the @a buf */\n  size_t buf_size;                               /**< the size of the @a buf */\n  size_t el_size;                                /**< the size of current element to be added to the @a buf */\n  unsigned rcode;                                /**< the response code */\n  bool use_conn_close;                           /**< Use \"Connection: close\" header */\n  bool use_conn_k_alive;                         /**< Use \"Connection: Keep-Alive\" header */\n\n  mhd_assert (NULL != r);\n\n  /* ** Adjust response properties ** */\n  setup_reply_properties (c);\n\n  mhd_assert (c->rp.props.set);\n  mhd_assert ((MHD_CONN_MUST_CLOSE == c->keepalive) || \\\n              (MHD_CONN_USE_KEEPALIVE == c->keepalive) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#ifdef UPGRADE_SUPPORT\n  mhd_assert ((NULL == r->upgrade_handler) || \\\n              (MHD_CONN_MUST_UPGRADE == c->keepalive));\n#else  /* ! UPGRADE_SUPPORT */\n  mhd_assert (MHD_CONN_MUST_UPGRADE != c->keepalive);\n#endif /* ! UPGRADE_SUPPORT */\n  mhd_assert ((! c->rp.props.chunked) || c->rp.props.use_reply_body_headers);\n  mhd_assert ((! c->rp.props.send_reply_body) || \\\n              c->rp.props.use_reply_body_headers);\n#ifdef UPGRADE_SUPPORT\n  mhd_assert (NULL == r->upgrade_handler || \\\n              ! c->rp.props.use_reply_body_headers);\n#endif /* UPGRADE_SUPPORT */\n\n  check_connection_reply (c);\n\n  rcode = (unsigned) c->rp.responseCode;\n  if (MHD_CONN_MUST_CLOSE == c->keepalive)\n  {\n    /* The closure of connection must be always indicated by header\n     * to avoid hung connections */\n    use_conn_close = true;\n    use_conn_k_alive = false;\n  }\n  else if (MHD_CONN_USE_KEEPALIVE == c->keepalive)\n  {\n    use_conn_close = false;\n    /* Add \"Connection: keep-alive\" if request is HTTP/1.0 or\n     * if reply is HTTP/1.0\n     * For HTTP/1.1 add header only if explicitly requested by app\n     * (by response flag), as \"Keep-Alive\" is default for HTTP/1.1. */\n    if ((0 != (r->flags & MHD_RF_SEND_KEEP_ALIVE_HEADER)) ||\n        (MHD_HTTP_VER_1_0 == c->rq.http_ver) ||\n        (0 != (r->flags & MHD_RF_HTTP_1_0_SERVER)))\n      use_conn_k_alive = true;\n    else\n      use_conn_k_alive = false;\n  }\n  else\n  {\n    use_conn_close = false;\n    use_conn_k_alive = false;\n  }\n\n  /* ** Actually build the response header ** */\n\n  /* Get all space available */\n  connection_maximize_write_buffer (c);\n  buf = c->write_buffer;\n  pos = c->write_buffer_append_offset;\n  buf_size = c->write_buffer_size;\n  if (0 == buf_size)\n    return MHD_NO;\n  mhd_assert (NULL != buf);\n\n  /* * The status line * */\n\n  /* The HTTP version */\n  if (! c->rp.responseIcy)\n  { /* HTTP reply */\n    if (0 == (r->flags & MHD_RF_HTTP_1_0_SERVER))\n    { /* HTTP/1.1 reply */\n      /* Use HTTP/1.1 responses for HTTP/1.0 clients.\n       * See https://datatracker.ietf.org/doc/html/rfc7230#section-2.6 */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_1))\n        return MHD_NO;\n    }\n    else\n    { /* HTTP/1.0 reply */\n      if (! buffer_append_s (buf, &pos, buf_size, MHD_HTTP_VERSION_1_0))\n        return MHD_NO;\n    }\n  }\n  else\n  { /* ICY reply */\n    if (! buffer_append_s (buf, &pos, buf_size, \"ICY\"))\n      return MHD_NO;\n  }\n\n  /* The response code */\n  if (buf_size < pos + 5) /* space + code + space */\n    return MHD_NO;\n  buf[pos++] = ' ';\n  pos += MHD_uint16_to_str ((uint16_t) rcode, buf + pos,\n                            buf_size - pos);\n  buf[pos++] = ' ';\n\n  /* The reason phrase */\n  el_size = MHD_get_reason_phrase_len_for (rcode);\n  if (0 == el_size)\n  {\n    if (! buffer_append_s (buf, &pos, buf_size, \"Non-Standard Status\"))\n      return MHD_NO;\n  }\n  else if (! buffer_append (buf, &pos, buf_size,\n                            MHD_get_reason_phrase_for (rcode),\n                            el_size))\n    return MHD_NO;\n\n  /* The linefeed */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  /* * The headers * */\n\n  /* Main automatic headers */\n\n  /* The \"Date:\" header */\n  if ( (0 == (r->flags_auto & MHD_RAF_HAS_DATE_HDR)) &&\n       (0 == (c->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) )\n  {\n    /* Additional byte for unused zero-termination */\n    if (buf_size < pos + 38)\n      return MHD_NO;\n    if (get_date_header (buf + pos))\n      pos += 37;\n  }\n  /* The \"Connection:\" header */\n  mhd_assert (! use_conn_close || ! use_conn_k_alive);\n  mhd_assert (! use_conn_k_alive || ! use_conn_close);\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    if (use_conn_close)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": close\\r\\n\"))\n        return MHD_NO;\n    }\n    else if (use_conn_k_alive)\n    {\n      if (! buffer_append_s (buf, &pos, buf_size,\n                             MHD_HTTP_HEADER_CONNECTION \": Keep-Alive\\r\\n\"))\n        return MHD_NO;\n    }\n  }\n\n  /* User-defined headers */\n\n  if (! add_user_headers (buf, &pos, buf_size, r,\n                          ! c->rp.props.chunked,\n                          (! c->rp.props.use_reply_body_headers) &&\n                          (0 ==\n                           (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)),\n                          use_conn_close,\n                          use_conn_k_alive))\n    return MHD_NO;\n\n  /* Other automatic headers */\n\n  if ( (c->rp.props.use_reply_body_headers) &&\n       (0 == (r->flags & MHD_RF_HEAD_ONLY_RESPONSE)) )\n  {\n    /* Body-specific headers */\n\n    if (c->rp.props.chunked)\n    { /* Chunked encoding is used */\n      if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      { /* No chunked encoding header set by user */\n        if (! buffer_append_s (buf, &pos, buf_size,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING \": \" \\\n                               \"chunked\\r\\n\"))\n          return MHD_NO;\n      }\n    }\n    else /* Chunked encoding is not used */\n    {\n      if (MHD_SIZE_UNKNOWN != r->total_size)\n      { /* The size is known */\n        if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n        { /* The response does not have \"Content-Length\" header */\n          if (! buffer_append_s (buf, &pos, buf_size,\n                                 MHD_HTTP_HEADER_CONTENT_LENGTH \": \"))\n            return MHD_NO;\n          el_size = MHD_uint64_to_str (r->total_size, buf + pos,\n                                       buf_size - pos);\n          if (0 == el_size)\n            return MHD_NO;\n          pos += el_size;\n\n          if (buf_size < pos + 2)\n            return MHD_NO;\n          buf[pos++] = '\\r';\n          buf[pos++] = '\\n';\n        }\n      }\n    }\n  }\n\n  /* * Header termination * */\n  if (buf_size < pos + 2)\n    return MHD_NO;\n  buf[pos++] = '\\r';\n  buf[pos++] = '\\n';\n\n  c->write_buffer_append_offset = pos;\n  return MHD_YES;\n}\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (NULL != buf); /* Mute static analyzer */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The statement mhd_assert (NULL != buf); is a no-op because mhd_assert is defined as ((void)0). It is executed at runtime but performs no action; removing it would not change program behaviour, so it constitutes dead code under MISRA C 2023 Rule 2.2 (the assert is only present to mute static analysers and has no effect at runtime)."
}