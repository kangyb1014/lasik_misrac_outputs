{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  if ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n\n  mhd_panic_cls = cls;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_set_panic_func': {'callees': [], 'callers': ['MHD_init']}, 'MHD_init': {'callees': ['MHD_set_panic_func', 'MHD_monotonic_sec_counter_init', 'MHD_send_init_static_vars_', 'MHD_init_mem_pools_'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "MHD_PanicCallback",
    "mhd_panic",
    "mhd_panic_std",
    "mhd_panic_cls",
    "NULL"
  ],
  "explanation": "To decide if MHD_set_panic_func uses any compiler-specific language extensions you must inspect the definitions of the identifiers/macros referenced by the function (they may expand to or be declared with non\u2011standard attributes or calling conventions):\n\n- _MHD_EXTERN: This macro may expand to storage-class/visibility annotations or compiler attributes (for example __attribute__((...)) or __declspec(...)). Such expansions are explicit compiler extensions and must be checked.\n\n- MHD_PanicCallback: The typedef/definition may include non\u2011standard calling conventions or attributes (e.g. __stdcall, __attribute__((__cdecl__)), function-pointer attributes). Also whether it is a function\u2011pointer type influences whether casting NULL to it is standard or not.\n\n- mhd_panic: The global variable assigned here may be declared with non\u2011standard qualifiers or attributes (visibility, section, alignment, etc.) or a non\u2011portable type; its declaration shows whether the assignment/cast uses any extensions.\n\n- mhd_panic_std: The address-of a default handler is used; its declaration/definition could contain attributes/extensions (inline, visibility, calling conv., or compiler-specific annotations) making the code non\u2011portable.\n\n- mhd_panic_cls: The class/context pointer assigned here could use non\u2011standard type/attributes; its declaration will show if any extension is involved.\n\n- NULL: The macro definition (0, ((void*)0), or compiler-provided symbol) must be inspected because some non\u2011standard definitions or uses (casting integer null to function pointer types) can interact with MISRA rules about extensions and pointer conversions.\n\nInspecting these symbols (their typedefs/macros/variable declarations) is sufficient to determine whether this function uses compiler language extensions."
}