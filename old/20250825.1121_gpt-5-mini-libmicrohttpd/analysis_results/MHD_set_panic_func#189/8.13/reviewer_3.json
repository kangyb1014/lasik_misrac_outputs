{
  "user_message": "An agent A claimed that the following MHD_set_panic_func code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_panic_func.\n```c\n_MHD_EXTERN void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  if ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n\n  mhd_panic_cls = cls;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'cls' and the global 'mhd_panic_cls' are plain void * even though the library code never modifies the pointed-to object (it merely stores and forwards it to the panic callback). The typedef MHD_PanicCallback uses void *cls as the first parameter; that could be const void *cls and both the parameter to MHD_set_panic_func and the global mhd_panic_cls could be const-qualified. Therefore the code does not qualify pointers with const where possible (file/reason are const char * already), so Rule 8.13 is violated.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_panic_func:\ntypedef void\n(*MHD_PanicCallback) (void *cls,\n                      const char *file,\n                      unsigned int line,\n                      const char *reason)\n...\nMHD_PanicCallback mhd_panic = (MHD_PanicCallback) NULL\n...\n_MHD_NORETURN static void\nmhd_panic_std (void *cls,\n               const char *file,\n               unsigned int line,\n               const char *reason)\n{\n  (void) cls; /* Mute compiler warning. */\n#ifdef HAVE_MESSAGES\n  fprintf (stderr,\n           _ (\"Fatal error in GNU libmicrohttpd %s:%u: %s\\n\"),\n           file,\n           line,\n           reason);\n#else  /* ! HAVE_MESSAGES */\n  (void) file;   /* Mute compiler warning. */\n  (void) line;   /* Mute compiler warning. */\n  (void) reason; /* Mute compiler warning. */\n#endif\n  abort ();\n}\n...\nvoid *mhd_panic_cls = NULL\n...\nMHD_PanicCallback mhd_panic = (MHD_PanicCallback) NULL\n...\nvoid *mhd_panic_cls = NULL\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A's claim is not correct. MISRA C 2023 Rule 8.13 recommends const-qualifying pointers where feasible, but it only applies when doing so is compatible with the code's required usage. Here the library stores the value in mhd_panic_cls and later forwards it unchanged to the panic callback whose typedef is\n\n    typedef void (*MHD_PanicCallback) (void *cls, const char *file, unsigned int line, const char *reason);\n\nThe callback parameter is deliberately a plain void * (non-const). Because the stored pointer is passed to a function that expects void *, making the parameter of MHD_set_panic_func or the global mhd_panic_cls const void * would be incompatible with the callback type (or would require casting away const when calling the callback, which would create a different MISRA issue). Thus it is not \u201cpossible\u201d to const-qualify these pointers without changing the public API (the typedef). The fact that the library's own default panic handler does not modify the pointer does not imply that all possible callbacks won't; the API must allow callers to pass a non-const context pointer. Therefore the reported violation of Rule 8.13 is not valid in this context."
}