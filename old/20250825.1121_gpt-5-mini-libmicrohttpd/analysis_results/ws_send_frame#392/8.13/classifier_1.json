{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of ws_send_frame:\n```c\nstatic ssize_t\nws_send_frame (MHD_socket sock, const char *msg, size_t length)\n{\n  unsigned char *response;\n  unsigned char frame[10];\n  unsigned char idx_first_rdata;\n  size_t idx_response;\n  size_t output;\n  MHD_socket isock;\n  size_t i;\n\n  frame[0] = (WS_FIN | WS_OPCODE_TEXT_FRAME);\n  if (length <= 125)\n  {\n    frame[1] = length & 0x7F;\n    idx_first_rdata = 2;\n  }\n#if SIZEOF_SIZE_T > 4\n  else if (0xFFFF < length)\n  {\n    frame[1] = 127;\n    frame[2] = (unsigned char) ((length >> 56) & 0xFF);\n    frame[3] = (unsigned char) ((length >> 48) & 0xFF);\n    frame[4] = (unsigned char) ((length >> 40) & 0xFF);\n    frame[5] = (unsigned char) ((length >> 32) & 0xFF);\n    frame[6] = (unsigned char) ((length >> 24) & 0xFF);\n    frame[7] = (unsigned char) ((length >> 16) & 0xFF);\n    frame[8] = (unsigned char) ((length >> 8) & 0xFF);\n    frame[9] = (unsigned char) (length & 0xFF);\n    idx_first_rdata = 10;\n  }\n#endif /* SIZEOF_SIZE_T > 4 */\n  else\n  {\n    frame[1] = 126;\n    frame[2] = (length >> 8) & 0xFF;\n    frame[3] = length & 0xFF;\n    idx_first_rdata = 4;\n  }\n  idx_response = 0;\n  response = malloc (idx_first_rdata + length + 1);\n  if (NULL == response)\n  {\n    return -1;\n  }\n  for (i = 0; i < idx_first_rdata; i++)\n  {\n    response[i] = frame[i];\n    idx_response++;\n  }\n  for (i = 0; i < length; i++)\n  {\n    response[idx_response] = (unsigned char) msg[i];\n    idx_response++;\n  }\n  response[idx_response] = '\\0';\n  output = 0;\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    isock = CLIENT_SOCKS[i];\n    if ((isock != MHD_INVALID_SOCKET) && (isock != sock))\n    {\n      output += send_all (isock, response, idx_response);\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (response);\n  return (ssize_t) output;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nfor (i = 0; i < length; i++)\n  {\n    response[idx_response] = (unsigned char) msg[i];\n    idx_response++;\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the given fragment. The function parameter is declared as const char *msg, so the pointer already points to a const-qualified type. A violation would occur if msg were declared as char * (non-const) even though the function only reads from it\u2014for example: ssize_t ws_send_frame(MHD_socket sock, char *msg, size_t length) { ... for (i = 0; i < length; i++) response[idx_response++] = (unsigned char) msg[i]; ... } \u2014 that would breach Rule 8.13 because the pointer could and should be const-qualified."
}