{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nws_send_frame (MHD_socket sock, const char *msg, size_t length)\n{\n  unsigned char *response;\n  unsigned char frame[10];\n  unsigned char idx_first_rdata;\n  size_t idx_response;\n  size_t output;\n  MHD_socket isock;\n  size_t i;\n\n  frame[0] = (WS_FIN | WS_OPCODE_TEXT_FRAME);\n  if (length <= 125)\n  {\n    frame[1] = length & 0x7F;\n    idx_first_rdata = 2;\n  }\n#if SIZEOF_SIZE_T > 4\n  else if (0xFFFF < length)\n  {\n    frame[1] = 127;\n    frame[2] = (unsigned char) ((length >> 56) & 0xFF);\n    frame[3] = (unsigned char) ((length >> 48) & 0xFF);\n    frame[4] = (unsigned char) ((length >> 40) & 0xFF);\n    frame[5] = (unsigned char) ((length >> 32) & 0xFF);\n    frame[6] = (unsigned char) ((length >> 24) & 0xFF);\n    frame[7] = (unsigned char) ((length >> 16) & 0xFF);\n    frame[8] = (unsigned char) ((length >> 8) & 0xFF);\n    frame[9] = (unsigned char) (length & 0xFF);\n    idx_first_rdata = 10;\n  }\n#endif /* SIZEOF_SIZE_T > 4 */\n  else\n  {\n    frame[1] = 126;\n    frame[2] = (length >> 8) & 0xFF;\n    frame[3] = length & 0xFF;\n    idx_first_rdata = 4;\n  }\n  idx_response = 0;\n  response = malloc (idx_first_rdata + length + 1);\n  if (NULL == response)\n  {\n    return -1;\n  }\n  for (i = 0; i < idx_first_rdata; i++)\n  {\n    response[i] = frame[i];\n    idx_response++;\n  }\n  for (i = 0; i < length; i++)\n  {\n    response[idx_response] = (unsigned char) msg[i];\n    idx_response++;\n  }\n  response[idx_response] = '\\0';\n  output = 0;\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    isock = CLIENT_SOCKS[i];\n    if ((isock != MHD_INVALID_SOCKET) && (isock != sock))\n    {\n      output += send_all (isock, response, idx_response);\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (response);\n  return (ssize_t) output;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "send_all",
    "run_usock",
    "SIZEOF_SIZE_T",
    "SIZE_MAX",
    "malloc",
    "CLIENT_SOCKS",
    "MAX_CLIENTS",
    "MHD_INVALID_SOCKET"
  ],
  "explanation": "send_all: The only function called with the response buffer. You must inspect its definition to see whether it uses any <string.h> routines (memcpy/strlen/etc.) or otherwise reads/writes the buffer beyond the supplied length (idx_response). If send_all reads until a NUL (strlen) rather than using the explicit length, that would be a violation.\n\nrun_usock: The direct caller of ws_send_frame. You need to see how it constructs the msg pointer and length arguments (origins, invariants). If run_usock can pass a length larger than the actual msg buffer, ws_send_frame's copy loop will read out-of-bounds; proving safety requires run_usock's behavior.\n\nSIZEOF_SIZE_T: The compile-time macro controls which length-encoding branch executes (2-byte, 4-byte or 10-byte header) and therefore the value of idx_first_rdata. Knowing which branch is compiled is necessary to compute the allocation size and to ensure frame[] index writes are in-bounds.\n\nSIZE_MAX: Needed to reason about potential integer overflow when computing allocation size (idx_first_rdata + length + 1) and when shifting/encoding length into frame bytes. If size_t arithmetic can overflow, the malloc size and subsequent copies may produce out-of-bounds accesses.\n\nmalloc: You must know the signature and semantics to reason about the returned pointer and failure modes. In particular, if an integer overflow causes a smaller allocation to be requested, knowing malloc behavior and whether the code checks its result is required to assess safety relative to buffer bounds.\n\nCLIENT_SOCKS / MAX_CLIENTS / MHD_INVALID_SOCKET: These globals determine how many times send_all is invoked and with which sockets, and may also reveal whether other threads/contexts could concurrently access or modify the response buffer via send_all or related code paths. Inspecting these symbols (and the code that manipulates them) helps determine whether the response buffer might be reused or accessed in ways that could trigger string.h usage outside the intended length.\n\nNote: Other local constants used to form the WebSocket header (WS_FIN, WS_OPCODE_TEXT_FRAME) and basic types (MHD_socket, ssize_t) are irrelevant for detecting misuse of <string.h> functions or bounds in the copy/allocation logic, so they were omitted to keep the symbol set minimal and focused on buffer-bounds and string-function usage."
}