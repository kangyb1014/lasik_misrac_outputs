{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nws_send_frame (MHD_socket sock, const char *msg, size_t length)\n{\n  unsigned char *response;\n  unsigned char frame[10];\n  unsigned char idx_first_rdata;\n  size_t idx_response;\n  size_t output;\n  MHD_socket isock;\n  size_t i;\n\n  frame[0] = (WS_FIN | WS_OPCODE_TEXT_FRAME);\n  if (length <= 125)\n  {\n    frame[1] = length & 0x7F;\n    idx_first_rdata = 2;\n  }\n#if SIZEOF_SIZE_T > 4\n  else if (0xFFFF < length)\n  {\n    frame[1] = 127;\n    frame[2] = (unsigned char) ((length >> 56) & 0xFF);\n    frame[3] = (unsigned char) ((length >> 48) & 0xFF);\n    frame[4] = (unsigned char) ((length >> 40) & 0xFF);\n    frame[5] = (unsigned char) ((length >> 32) & 0xFF);\n    frame[6] = (unsigned char) ((length >> 24) & 0xFF);\n    frame[7] = (unsigned char) ((length >> 16) & 0xFF);\n    frame[8] = (unsigned char) ((length >> 8) & 0xFF);\n    frame[9] = (unsigned char) (length & 0xFF);\n    idx_first_rdata = 10;\n  }\n#endif /* SIZEOF_SIZE_T > 4 */\n  else\n  {\n    frame[1] = 126;\n    frame[2] = (length >> 8) & 0xFF;\n    frame[3] = length & 0xFF;\n    idx_first_rdata = 4;\n  }\n  idx_response = 0;\n  response = malloc (idx_first_rdata + length + 1);\n  if (NULL == response)\n  {\n    return -1;\n  }\n  for (i = 0; i < idx_first_rdata; i++)\n  {\n    response[i] = frame[i];\n    idx_response++;\n  }\n  for (i = 0; i < length; i++)\n  {\n    response[idx_response] = (unsigned char) msg[i];\n    idx_response++;\n  }\n  response[idx_response] = '\\0';\n  output = 0;\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    isock = CLIENT_SOCKS[i];\n    if ((isock != MHD_INVALID_SOCKET) && (isock != sock))\n    {\n      output += send_all (isock, response, idx_response);\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (response);\n  return (ssize_t) output;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket",
    "WS_FIN",
    "WS_OPCODE_TEXT_FRAME",
    "SIZEOF_SIZE_T",
    "MAX_CLIENTS",
    "CLIENT_SOCKS",
    "MHD_INVALID_SOCKET",
    "MUTEX",
    "send_all",
    "make_blocking",
    "pthread_mutex_lock",
    "pthread_mutex_unlock",
    "malloc",
    "free",
    "abort"
  ],
  "explanation": "For each symbol below you must inspect its definition/declaration to detect use of compiler/language extensions (e.g. __attribute__, __inline__, typeof, statement-expressions, asm, nested functions, __thread, nonstandard storage-class specifiers, compiler-specific macros, etc.).\n\n- MHD_socket: typedef/definition may use platform-specific types or attributes (e.g. typedefs using compiler extensions).\n- WS_FIN: macro constant \u2014 could be defined using extension constructs or unusual token-pasting macros.\n- WS_OPCODE_TEXT_FRAME: macro constant \u2014 same reason as WS_FIN.\n- SIZEOF_SIZE_T: preprocessor symbol used for conditional compilation \u2014 its definition may rely on configure-generated constants or compiler-specific sizeof tricks or extension macros.\n- MAX_CLIENTS: macro/constant used to size loops/arrays \u2014 could be computed with extensions or defined via nonstandard constructs.\n- CLIENT_SOCKS: global array \u2014 its declaration could use attributes (section, alignment), nonstandard storage qualifiers or thread-local storage extensions.\n- MHD_INVALID_SOCKET: sentinel macro/constant \u2014 may be defined via casts or macros that use extensions.\n- MUTEX: mutex object name/macro \u2014 its definition may use pthread types or be a macro alias that uses extensions (e.g. __attribute__ or __thread).\n- send_all: called function \u2014 its prototype/definition must be checked for inline asm, nested functions, attribute((...)), or other compiler-specific constructs.\n- make_blocking: callee of send_all (appears in call graph) \u2014 inspect its definition because send_all may call it and extensions there could affect conformity.\n- pthread_mutex_lock / pthread_mutex_unlock: prototypes/macros \u2014 although POSIX, check for platform wrappers/aliases that may use extensions.\n- malloc / free / abort: standard library functions \u2014 inspect any project wrappers/macros around them (e.g. MALLOC macro) that may use extensions.\n\nThe target function itself uses many macros, typedefs and global objects whose own definitions may hide language extensions; verifying each listed symbol ensures no extension is introduced indirectly."
}