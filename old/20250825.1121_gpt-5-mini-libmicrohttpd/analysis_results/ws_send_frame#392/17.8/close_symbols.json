{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nws_send_frame (MHD_socket sock, const char *msg, size_t length)\n{\n  unsigned char *response;\n  unsigned char frame[10];\n  unsigned char idx_first_rdata;\n  size_t idx_response;\n  size_t output;\n  MHD_socket isock;\n  size_t i;\n\n  frame[0] = (WS_FIN | WS_OPCODE_TEXT_FRAME);\n  if (length <= 125)\n  {\n    frame[1] = length & 0x7F;\n    idx_first_rdata = 2;\n  }\n#if SIZEOF_SIZE_T > 4\n  else if (0xFFFF < length)\n  {\n    frame[1] = 127;\n    frame[2] = (unsigned char) ((length >> 56) & 0xFF);\n    frame[3] = (unsigned char) ((length >> 48) & 0xFF);\n    frame[4] = (unsigned char) ((length >> 40) & 0xFF);\n    frame[5] = (unsigned char) ((length >> 32) & 0xFF);\n    frame[6] = (unsigned char) ((length >> 24) & 0xFF);\n    frame[7] = (unsigned char) ((length >> 16) & 0xFF);\n    frame[8] = (unsigned char) ((length >> 8) & 0xFF);\n    frame[9] = (unsigned char) (length & 0xFF);\n    idx_first_rdata = 10;\n  }\n#endif /* SIZEOF_SIZE_T > 4 */\n  else\n  {\n    frame[1] = 126;\n    frame[2] = (length >> 8) & 0xFF;\n    frame[3] = length & 0xFF;\n    idx_first_rdata = 4;\n  }\n  idx_response = 0;\n  response = malloc (idx_first_rdata + length + 1);\n  if (NULL == response)\n  {\n    return -1;\n  }\n  for (i = 0; i < idx_first_rdata; i++)\n  {\n    response[i] = frame[i];\n    idx_response++;\n  }\n  for (i = 0; i < length; i++)\n  {\n    response[idx_response] = (unsigned char) msg[i];\n    idx_response++;\n  }\n  response[idx_response] = '\\0';\n  output = 0;\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    isock = CLIENT_SOCKS[i];\n    if ((isock != MHD_INVALID_SOCKET) && (isock != sock))\n    {\n      output += send_all (isock, response, idx_response);\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (response);\n  return (ssize_t) output;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "send_all (declaration/definition or macro expansion)",
    "MHD_socket (typedef / underlying type)",
    "CLIENT_SOCKS (declaration and element type)",
    "MHD_INVALID_SOCKET (macro/const definition)",
    "MUTEX (declaration)",
    "pthread_mutex_lock / pthread_mutex_unlock (declarations or macros)",
    "MAX_CLIENTS (macro/const)"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter shall not be modified\u201d for ws_send_frame you must be able to rule out any code path or macro that could change the formal parameters (sock, msg, length) inside this function. The symbols below are required and why:\n\n- send_all (declaration/definition or macro expansion): ws_send_frame calls send_all; if send_all is actually a macro or inline that textually manipulates identifiers (or expands into code that could reassign an identifier named sock, msg or length) that could modify a parameter variable. We must inspect the actual implementation or macro expansion to ensure no parameter is altered by expansion or side\u2011effects.\n\n- MHD_socket (typedef / underlying type): The parameter sock has type MHD_socket. Knowing whether this typedef is an integer type, pointer type, or a struct alias affects the interpretation of passing by value vs. reference and whether assignments or indirect operations could change the object or the pointer. It also helps determine whether comparisons (isock != sock) are simple value comparisons.\n\n- CLIENT_SOCKS (declaration and element type): The loop reads CLIENT_SOCKS[i] into a local isock and compares it against sock. If CLIENT_SOCKS is a macro with an unusual expansion, it might reference or modify the formal parameter name. Inspecting the declaration/macro ensures the comparison and read do not modify sock.\n\n- MHD_INVALID_SOCKET (macro/const definition): Used in comparisons against isock and sock. If this is a macro with side effects or complex expansion, it could affect whether a parameter is modified (rare but possible if macro uses parameter identifiers); verify its definition.\n\n- MUTEX (declaration): The address of MUTEX is taken and passed to pthread_mutex_lock/unlock. If MUTEX is a macro that expands in a way that references or shadows function parameters, it could cause unexpected modification. Also needed to ensure locking calls are standard and do not modify parameters.\n\n- pthread_mutex_lock / pthread_mutex_unlock (declarations or macros): These are called with &MUTEX; ensure they are the standard functions (or known wrappers) and not macros that might expand to code that modifies the function parameters (e.g., by using parameter names in their expansion).\n\n- MAX_CLIENTS (macro/const): Controls the loop bound. If MAX_CLIENTS is a macro with unusual expansion that references parameter names or produces code that assigns to parameters, it could violate the rule. Verify its definition.\n\nNote: The parameter msg is declared const char *; you should confirm that this constness is not circumvented by any macro or cast elsewhere (but in ws_send_frame itself msg is only read). The parameter length and sock are not assigned in the function source shown; the above symbols are required to rule out indirect or macro-driven modifications."
}