{
  "user_message": "Target function code is:\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'calculate_add_nonce': {'callees': ['MHD_get_master', 'digest_get_size', 'calculate_nonce', 'get_nonce_nc_idx', '__builtin_unreachable', 'is_slot_available'], 'callers': ['calculate_add_nonce_with_retry']}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calculate_nonce': {'callees': ['MHD_bin_to_hex', 'digest_get_size', 'digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['calculate_add_nonce', 'digest_auth_check_all_inner']}, 'get_nonce_nc_idx': {'callees': ['fast_simple_hash'], 'callers': ['check_nonce_nc', 'calculate_add_nonce']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'is_slot_available': {'callees': ['get_nonce_timestamp'], 'callers': ['calculate_add_nonce']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "NONCE_STD_LEN",
    "MAX_DIGEST_NONCE_LENGTH",
    "MAX_DIGEST",
    "digest_get_size",
    "calculate_nonce",
    "calculate_add_nonce_with_retry",
    "struct MHD_NonceNc",
    "struct MHD_Daemon",
    "get_nonce_nc_idx",
    "is_slot_available"
  ],
  "explanation": "Explain why each symbol is required to check memcpy usage and the MISRA <string.h> bounds rule:\n\n- NONCE_STD_LEN\n  - Determines nonce_size used as the third argument to memcpy and the index written (nonce[nonce_size] = 0). You must know how NONCE_STD_LEN maps digest sizes to byte counts (and whether it already accounts for a terminating zero) to confirm memcpy length and the subsequent terminating write are in-bounds.\n\n- MAX_DIGEST_NONCE_LENGTH\n  - Used in assertions in the function to bound nonce_size. You need its numeric value to verify the asserted invariant actually guarantees memcpy and the terminating write do not exceed the destination array.\n\n- MAX_DIGEST\n  - Appears in the assertion linking MAX_DIGEST_NONCE_LENGTH and NONCE_STD_LEN(MAX_DIGEST). Knowing MAX_DIGEST helps reason about the maximum possible nonce_size and ensure all derived bounds are correct.\n\n- digest_get_size\n  - Its return value is the input to NONCE_STD_LEN. You need to know the range of values digest_get_size can return for the given DigestAlgorithm instance(s) to compute the exact nonce_size and ensure it cannot exceed the destination buffer.\n\n- calculate_nonce\n  - This function writes into the provided nonce buffer before the memcpy is invoked. To be sure the source buffer passed to memcpy has at least nonce_size valid bytes (no underflows) you must inspect calculate_nonce\u2019s contract/implementation: how many bytes it writes and whether it might write more than nonce_size or rely on a different buffer size.\n\n- calculate_add_nonce_with_retry\n  - This is a known caller of calculate_add_nonce. The caller may allocate or provide the nonce buffer passed in (stack or heap) \u2014 you must examine that caller to confirm the source buffer passed into calculate_add_nonce is at least nonce_size bytes long. Without checking the caller, you cannot ensure the source operand of memcpy is valid for the requested size.\n\n- struct MHD_NonceNc\n  - The memcpy destination is nn->nonce and a terminating write is performed at nn->nonce[nonce_size]. You must know the declared size of the nonce member in MHD_NonceNc to verify the destination has room for nonce_size bytes plus the terminating zero.\n\n- struct MHD_Daemon\n  - calculate_add_nonce indexes into daemon->nnc using get_nonce_nc_idx and checks daemon->nonce_nc_size. You need the layout (fields) to confirm: (a) daemon->nnc points to an array of MHD_NonceNc of size nonce_nc_size, and (b) the field types/sizes used in bounds checks are consistent so that nn points to a valid MHD_NonceNc whose nonce member has the expected size.\n\n- get_nonce_nc_idx\n  - Returns the index used to select nn = daemon->nnc + idx. To ensure the memcpy destination is within allocated array bounds you must verify get_nonce_nc_idx yields an index strictly less than daemon->nonce_nc_size (or otherwise safe). Inspect its implementation and how it uses nonce/nonce_size to ensure it cannot produce an out-of-range index.\n\n- is_slot_available\n  - Called before modifying nn->nonce; it may read nn->nonce or the supplied nonce buffer (and accepts nonce_size). Its behavior may impose preconditions on nonce or nn->nonce (for example requiring a terminating zero or particular length). You must inspect it to ensure it does not itself read out-of-bounds and to confirm any assumptions it makes about buffer layout that affect safety of the subsequent memcpy and terminating write.\n\nCollectively, these symbols provide the information needed to determine the sizes and lifetimes of both source and destination buffers used in memcpy, the correctness of the index into the daemon->nnc array, and whether the terminating-byte write is valid \u2014 all necessary to assess compliance with the MISRA rule about string.h functions and out-of-bounds accesses."
}