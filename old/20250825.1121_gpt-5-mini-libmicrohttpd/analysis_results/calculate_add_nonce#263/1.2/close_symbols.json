{
  "user_message": "Target function code is:\n```c\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'calculate_add_nonce': {'callees': ['MHD_get_master', 'digest_get_size', 'calculate_nonce', 'get_nonce_nc_idx', '__builtin_unreachable', 'is_slot_available'], 'callers': ['calculate_add_nonce_with_retry']}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_get_size': {'callees': [], 'callers': ['calculate_nonce', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'calculate_nonce': {'callees': ['MHD_bin_to_hex', 'digest_get_size', 'digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['calculate_add_nonce', 'digest_auth_check_all_inner']}, 'get_nonce_nc_idx': {'callees': ['fast_simple_hash'], 'callers': ['check_nonce_nc', 'calculate_add_nonce']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'is_slot_available': {'callees': ['get_nonce_timestamp'], 'callers': ['calculate_add_nonce']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_get_master",
    "mhd_assert",
    "NONCE_STD_LEN",
    "digest_get_size",
    "calculate_nonce",
    "MHD_DIGEST_HAS_EXT_ERROR",
    "digest_ext_error",
    "MAX_DIGEST_NONCE_LENGTH",
    "MAX_DIGEST",
    "struct MHD_Daemon",
    "struct MHD_Connection",
    "struct DigestAlgorithm",
    "struct MHD_NonceNc",
    "get_nonce_nc_idx",
    "fast_simple_hash",
    "is_slot_available",
    "get_nonce_timestamp",
    "MHD_mutex_lock_chk_",
    "MHD_mutex_unlock_chk_"
  ],
  "explanation": "To determine whether calculate_add_nonce uses any compiler language extensions you must inspect the definitions of all called functions, macros and types that could themselves employ compiler-specific extensions or non\u2011standard constructs. Brief reasons: \n\n- MHD_get_master: called to obtain daemon pointer; its implementation could use compiler builtins/attributes or nonstandard calling conventions.\n- mhd_assert: macro used for assertions; likely implemented via builtins (e.g. __builtin_unreachable, __attribute__) or nonstandard constructs \u2014 must inspect.\n- NONCE_STD_LEN: macro used to compute nonce sizes; macro expansion could use extensions (compound statements in expressions, typeof, statement expressions, etc.).\n- digest_get_size: called and used inside NONCE_STD_LEN; its implementation could use inline asm, builtins or nonstandard attributes.\n- calculate_nonce: major helper that constructs nonce; may call many functions or use compiler intrinsics/attributes \u2014 must inspect for extensions.\n- MHD_DIGEST_HAS_EXT_ERROR: conditional compilation macro; must know if digest_ext_error is present and whether this macro or related code uses extensions.\n- digest_ext_error: called under conditional; implementation could use extensions.\n- MAX_DIGEST_NONCE_LENGTH and MAX_DIGEST: constants/macros used in assertions; macro definitions might use nonstandard constructs.\n- struct MHD_Daemon: the function accesses many fields (nnc, nnc_lock, digest_auth_random, nonce_nc_size, dauth_bind_type, etc.); the struct definition must be checked for extensions (anonymous structs/unions, attributes like packed/aligned, flexible array members vs compiler-specific VLA fields, bit\u2011fields with implementation-specific widths, or compiler-specific annotations).\n- struct MHD_Connection: used to access daemon, addr, addr_len, rq.*; must inspect for anonymous members, extensions or unusual type use.\n- struct DigestAlgorithm: member 'hashing' and any other members could be implemented with extensions (e.g. bitfields, attributes, function pointers with nonstandard calling conventions).\n- struct MHD_NonceNc: the code writes nn->nonce and sets nn->nonce[nonce_size]=0; the definition must be checked for flexible-array member vs GCC extension, anonymous members, or attribute usage.\n- get_nonce_nc_idx: used to compute index; its implementation (and any macros it uses) could use compiler-specific intrinsics or extensions.\n- fast_simple_hash: callee of get_nonce_nc_idx in the call graph; included because get_nonce_nc_idx may be a thin wrapper around it and the hash may use builtins/extensions.\n- is_slot_available: used to test slot; implementation may use extensions (e.g. builtin atomics, compiler intrinsics for time, or attributes).\n- get_nonce_timestamp: called by is_slot_available per call graph; timing routines often use compiler intrinsics or platform-specific builtins \u2014 inspect.\n- MHD_mutex_lock_chk_ and MHD_mutex_unlock_chk_: locking macros/wrappers may be implemented with compiler extensions (attributes, inline asm, builtins like __atomic or __sync, or statement-expression macros).\n\nInspecting these symbols (their headers/implementations) is sufficient to determine whether calculate_add_nonce or any transitive symbol it depends on makes use of compiler language extensions that would violate the MISRA rule. Only by viewing their definitions/macros can one detect use of __builtin_*, __attribute__ extensions, inline asm, statement-expressions, typeof, anonymous/nonstandard constructs, or other compiler-specific features."
}