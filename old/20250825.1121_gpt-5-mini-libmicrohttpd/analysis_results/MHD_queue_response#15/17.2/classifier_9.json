{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_queue_response:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_queue_response:\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n...\nstatic void\ncall_connection_handler (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t processed;\n\n  if (NULL != connection->rp.response)\n    return;                     /* already queued a response */\n  processed = 0;\n  connection->rq.client_aware = true;\n  connection->in_access_handler = true;\n  if (MHD_NO ==\n      daemon->default_handler (daemon->default_handler_cls,\n                               connection,\n                               connection->rq.url,\n                               connection->rq.method,\n                               connection->rq.version,\n                               NULL,\n                               &processed,\n                               &connection->rq.client_context))\n  {\n    connection->in_access_handler = false;\n    /* serious internal error, close connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Application reported internal error, \" \\\n                               \"closing connection.\"));\n    return;\n  }\n  connection->in_access_handler = false;\n}\n...\nstatic enum MHD_Result\ncall_handlers (struct MHD_Connection *con,\n               bool read_ready,\n               bool write_ready,\n               bool force_close)\n{\n  enum MHD_Result ret;\n  bool states_info_processed = false;\n  /* Fast track flag */\n  bool on_fasttrack = (con->state == MHD_CONNECTION_INIT);\n  ret = MHD_YES;\n\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 != (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (con->tid)));\n  mhd_assert ((0 == (con->daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (con->tid)));\n\n#ifdef HTTPS_SUPPORT\n  if (con->tls_read_ready)\n    read_ready = true;\n#endif /* HTTPS_SUPPORT */\n  if ( (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) &&\n       (read_ready || (force_close && con->sk_nonblck)) )\n  {\n    MHD_connection_handle_read (con, force_close);\n    mhd_assert (! force_close || MHD_CONNECTION_CLOSED == con->state);\n    ret = MHD_connection_handle_idle (con);\n    if (force_close)\n      return ret;\n    states_info_processed = true;\n  }\n  if (! force_close)\n  {\n    /* No need to check value of 'ret' here as closed connection\n     * cannot be in MHD_EVENT_LOOP_INFO_WRITE state. */\n    if ( (MHD_EVENT_LOOP_INFO_WRITE == con->event_loop_info) &&\n         write_ready)\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n      states_info_processed = true;\n    }\n  }\n  else\n  {\n    MHD_connection_close_ (con,\n                           MHD_REQUEST_TERMINATED_WITH_ERROR);\n    return MHD_connection_handle_idle (con);\n  }\n\n  if (! states_info_processed)\n  {   /* Connection is not read or write ready, but external conditions\n       * may be changed and need to be processed. */\n    ret = MHD_connection_handle_idle (con);\n  }\n  /* Fast track for fast connections. */\n  /* If full request was read by single read_handler() invocation\n     and headers were completely prepared by single MHD_connection_handle_idle()\n     then try not to wait for next sockets polling and send response\n     immediately.\n     As writeability of socket was not checked and it may have\n     some data pending in system buffers, use this optimization\n     only for non-blocking sockets. */\n  /* No need to check 'ret' as connection is always in\n   * MHD_CONNECTION_CLOSED state if 'ret' is equal 'MHD_NO'. */\n  else if (on_fasttrack && con->sk_nonblck)\n  {\n    if (MHD_CONNECTION_HEADERS_SENDING == con->state)\n    {\n      MHD_connection_handle_write (con);\n      /* Always call 'MHD_connection_handle_idle()' after each read/write. */\n      ret = MHD_connection_handle_idle (con);\n    }\n    /* If all headers were sent by single write_handler() and\n     * response body is prepared by single MHD_connection_handle_idle()\n     * call - continue. */\n    if ((MHD_CONNECTION_NORMAL_BODY_READY == con->state) ||\n        (MHD_CONNECTION_CHUNKED_BODY_READY == con->state))\n    {\n      MHD_connection_handle_write (con);\n      ret = MHD_connection_handle_idle (con);\n    }\n  }\n\n  /* All connection's data and states are processed for this turn.\n   * If connection already has more data to be processed - use\n   * zero timeout for next select()/poll(). */\n  /* Thread-per-connection do not need global zero timeout as\n   * connections are processed individually. */\n  /* Note: no need to check for read buffer availability for\n   * TLS read-ready connection in 'read info' state as connection\n   * without space in read buffer will be marked as 'info block'. */\n  if ( (! con->daemon->data_already_pending) &&\n       (! MHD_D_IS_USING_THREAD_PER_CONN_ (con->daemon)) )\n  {\n    if (0 != (MHD_EVENT_LOOP_INFO_PROCESS & con->event_loop_info))\n      con->daemon->data_already_pending = true;\n#ifdef HTTPS_SUPPORT\n    else if ( (con->tls_read_ready) &&\n              (0 != (MHD_EVENT_LOOP_INFO_READ & con->event_loop_info)) )\n      con->daemon->data_already_pending = true;\n#endif /* HTTPS_SUPPORT */\n  }\n  return ret;\n}\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\nstatic enum MHD_Result\nqueue_auth_required_response3_inner (struct MHD_Connection *connection,\n                                     const char *realm,\n                                     const char *opaque,\n                                     const char *domain,\n                                     struct MHD_Response *response,\n                                     int signal_stale,\n                                     enum MHD_DigestAuthMultiQOP mqop,\n                                     enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                     int userhash_support,\n                                     int prefer_utf8,\n                                     char **buf_ptr,\n                                     struct DigestAlgorithm *da)\n{\n  static const char prefix_realm[] = \"realm=\\\"\";\n  static const char prefix_qop[] = \"qop=\\\"\";\n  static const char prefix_algo[] = \"algorithm=\";\n  static const char prefix_nonce[] = \"nonce=\\\"\";\n  static const char prefix_opaque[] = \"opaque=\\\"\";\n  static const char prefix_domain[] = \"domain=\\\"\";\n  static const char str_charset[] = \"charset=UTF-8\";\n  static const char str_userhash[] = \"userhash=true\";\n  static const char str_stale[] = \"stale=true\";\n  enum MHD_DigestAuthAlgo3 s_algo; /**< Selected algorithm */\n  size_t realm_len;\n  size_t opaque_len;\n  size_t domain_len;\n  size_t buf_size;\n  char *buf;\n  size_t p; /* The position in the buffer */\n  char *hdr_name;\n\n  if (0 == (((unsigned int) malgo3) & MHD_DIGEST_AUTH_ALGO3_NON_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Only non-'session' algorithms are supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  malgo3 =\n    (enum MHD_DigestAuthMultiAlgo3)\n    (malgo3\n     & (~((enum MHD_DigestAuthMultiAlgo3) MHD_DIGEST_AUTH_ALGO3_NON_SESSION)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_MD5;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA256;\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n    s_algo = MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n    if (0 == (((unsigned int) malgo3)\n              & (MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_BASE_ALGO_SHA512_256\n                 | MHD_DIGEST_BASE_ALGO_SHA512_256)))\n      MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n    else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"No requested algorithm is supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_AUTH_INT == mqop)\n    MHD_PANIC (_ (\"Wrong 'mqop' value, API violation\"));\n\n  mqop = (enum MHD_DigestAuthMultiQOP)\n         (mqop\n          & (~((enum MHD_DigestAuthMultiQOP) MHD_DIGEST_AUTH_QOP_AUTH_INT)));\n\n  if (! digest_init_one_time (da, get_base_digest_algo (s_algo)))\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE == mqop)\n  {\n#ifdef HAVE_MESSAGES\n    if ((0 != userhash_support) || (0 != prefer_utf8))\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'userhash' and 'charset' ('prefer_utf8') parameters \" \\\n                   \"are not compatible with RFC2069 and ignored.\\n\"));\n    if (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n      MHD_DLOG (connection->daemon,\n                _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                   \"non-standard extension.\\n\"));\n#endif\n    userhash_support = 0;\n    prefer_utf8 = 0;\n  }\n\n  if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The nonce array size is zero.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n\n  /* Calculate required size */\n  buf_size = 0;\n  /* 'Digest ' */\n  buf_size += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE) + 1; /* 1 for ' ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_realm) + 3; /* 3 for '\", ' */\n  /* 'realm=\"xxxx\", ' */\n  realm_len = strlen (realm);\n  if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < realm_len)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'realm' is too large.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  if ((NULL != memchr (realm, '\\r', realm_len)) ||\n      (NULL != memchr (realm, '\\n', realm_len)))\n    return MHD_NO;\n\n  buf_size += realm_len * 2; /* Quoting may double the size */\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_qop) + 3; /* 3 for '\", ' */\n    buf_size += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_algo) + 2; /* 2 for ', ' */\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n      buf_size += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n  }\n  /* 'nonce=\"xxxx\", ' */\n  buf_size += MHD_STATICSTR_LEN_ (prefix_nonce) + 3; /* 3 for '\", ' */\n  buf_size += NONCE_STD_LEN (digest_get_size (da)); /* Escaping not needed */\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_opaque) + 3; /* 3 for '\", ' */\n    opaque_len = strlen (opaque);\n    if ((NULL != memchr (opaque, '\\r', opaque_len)) ||\n        (NULL != memchr (opaque, '\\n', opaque_len)))\n      return MHD_NO;\n\n    buf_size += opaque_len * 2; /* Quoting may double the size */\n  }\n  else\n    opaque_len = 0;\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    buf_size += MHD_STATICSTR_LEN_ (prefix_domain) + 3; /* 3 for '\", ' */\n    domain_len = strlen (domain);\n    if ((NULL != memchr (domain, '\\r', domain_len)) ||\n        (NULL != memchr (domain, '\\n', domain_len)))\n      return MHD_NO;\n\n    buf_size += domain_len * 2; /* Quoting may double the size */\n  }\n  else\n    domain_len = 0;\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n    buf_size += MHD_STATICSTR_LEN_ (str_charset) + 2; /* 2 for ', ' */\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n    buf_size += MHD_STATICSTR_LEN_ (str_userhash) + 2; /* 2 for ', ' */\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n    buf_size += MHD_STATICSTR_LEN_ (str_stale) + 2; /* 2 for ', ' */\n\n  /* The calculated length is for string ended with \", \". One character will\n   * be used for zero-termination, the last one will not be used. */\n\n  /* Allocate the buffer */\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  *buf_ptr = buf;\n\n  /* Build the challenge string */\n  p = 0;\n  /* 'Digest: ' */\n  memcpy (buf + p, _MHD_AUTH_DIGEST_BASE,\n          MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE));\n  p += MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  buf[p++] = ' ';\n  /* 'realm=\"xxxx\", ' */\n  memcpy (buf + p, prefix_realm,\n          MHD_STATICSTR_LEN_ (prefix_realm));\n  p += MHD_STATICSTR_LEN_ (prefix_realm);\n  mhd_assert ((buf_size - p) >= (realm_len * 2));\n  if (1)\n  {\n    size_t quoted_size;\n    quoted_size = MHD_str_quote (realm, realm_len, buf + p, buf_size - p);\n    if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < quoted_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"The 'realm' is too large after 'quoting'.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    p += quoted_size;\n  }\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'qop=\"xxxx\", ' */\n  if (MHD_DIGEST_AUTH_MULT_QOP_NONE != mqop)\n  {\n    memcpy (buf + p, prefix_qop,\n            MHD_STATICSTR_LEN_ (prefix_qop));\n    p += MHD_STATICSTR_LEN_ (prefix_qop);\n    memcpy (buf + p, MHD_TOKEN_AUTH_,\n            MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_));\n    p += MHD_STATICSTR_LEN_ (MHD_TOKEN_AUTH_);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'algorithm=\"xxxx\", ' */\n  if (((MHD_DIGEST_AUTH_MULT_QOP_NONE) != mqop) ||\n      (0 == (((unsigned int) s_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n  {\n    memcpy (buf + p, prefix_algo,\n            MHD_STATICSTR_LEN_ (prefix_algo));\n    p += MHD_STATICSTR_LEN_ (prefix_algo);\n#ifdef MHD_MD5_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_MD5 == s_algo)\n    {\n      memcpy (buf + p, _MHD_MD5_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_MD5_TOKEN);\n    }\n    else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n    if (MHD_DIGEST_AUTH_ALGO3_SHA512_256 == s_algo)\n    {\n      memcpy (buf + p, _MHD_SHA512_256_TOKEN,\n              MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN));\n      p += MHD_STATICSTR_LEN_ (_MHD_SHA512_256_TOKEN);\n    }\n    else\n#endif /* MHD_SHA512_256_SUPPORT */\n    mhd_assert (0);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'nonce=\"xxxx\", ' */\n  memcpy (buf + p, prefix_nonce,\n          MHD_STATICSTR_LEN_ (prefix_nonce));\n  p += MHD_STATICSTR_LEN_ (prefix_nonce);\n  mhd_assert ((buf_size - p) >= (NONCE_STD_LEN (digest_get_size (da))));\n  if (! calculate_add_nonce_with_retry (connection, realm, da, buf + p))\n  {\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"TLS library reported hash calculation error, nonce could \"\n                   \"not be generated.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Could not register nonce. Client's requests with this \"\n                 \"nonce will be always 'stale'. Probably clients' requests \"\n                 \"are too intensive.\\n\"));\n#endif /* HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning for builds without messages */\n  }\n  p += NONCE_STD_LEN (digest_get_size (da));\n  buf[p++] = '\\\"';\n  buf[p++] = ',';\n  buf[p++] = ' ';\n  /* 'opaque=\"xxxx\", ' */\n  if (NULL != opaque)\n  {\n    memcpy (buf + p, prefix_opaque,\n            MHD_STATICSTR_LEN_ (prefix_opaque));\n    p += MHD_STATICSTR_LEN_ (prefix_opaque);\n    mhd_assert ((buf_size - p) >= (opaque_len * 2));\n    p += MHD_str_quote (opaque, opaque_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'domain=\"xxxx\", ' */\n  if (NULL != domain)\n  {\n    memcpy (buf + p, prefix_domain,\n            MHD_STATICSTR_LEN_ (prefix_domain));\n    p += MHD_STATICSTR_LEN_ (prefix_domain);\n    mhd_assert ((buf_size - p) >= (domain_len * 2));\n    p += MHD_str_quote (domain, domain_len, buf + p, buf_size - p);\n    buf[p++] = '\\\"';\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'charset=UTF-8' */\n  if (MHD_NO != prefer_utf8)\n  {\n    memcpy (buf + p, str_charset,\n            MHD_STATICSTR_LEN_ (str_charset));\n    p += MHD_STATICSTR_LEN_ (str_charset);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'userhash=true' */\n  if (MHD_NO != userhash_support)\n  {\n    memcpy (buf + p, str_userhash,\n            MHD_STATICSTR_LEN_ (str_userhash));\n    p += MHD_STATICSTR_LEN_ (str_userhash);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  /* 'stale=true' */\n  if (MHD_NO != signal_stale)\n  {\n    memcpy (buf + p, str_stale,\n            MHD_STATICSTR_LEN_ (str_stale));\n    p += MHD_STATICSTR_LEN_ (str_stale);\n    buf[p++] = ',';\n    buf[p++] = ' ';\n  }\n  mhd_assert (buf_size >= p);\n  /* The built string ends with \", \". Replace comma with zero-termination. */\n  --p;\n  buf[--p] = 0;\n\n  hdr_name = malloc (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n  if (NULL != hdr_name)\n  {\n    memcpy (hdr_name, MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n            MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_WWW_AUTHENTICATE) + 1);\n    if (MHD_add_response_entry_no_alloc_ (response, MHD_HEADER_KIND,\n                                          hdr_name,\n                                          MHD_STATICSTR_LEN_ ( \\\n                                            MHD_HTTP_HEADER_WWW_AUTHENTICATE),\n                                          buf, p))\n    {\n      *buf_ptr = NULL; /* The buffer will be free()ed when the response is destroyed */\n      return MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n    }\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to add Digest auth header.\\n\"));\n    }\n#endif /* HAVE_MESSAGES */\n    free (hdr_name);\n  }\n  return MHD_NO;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n...\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n  (void) req_cls;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  return MHD_queue_response (connection, MHD_HTTP_OK, response);\n}\n...\nstatic enum MHD_Result\nanswer_to_connection (void *cls,\n                      struct MHD_Connection *connection,\n                      const char *url,\n                      const char *method,\n                      const char *version,\n                      const char *upload_data,\n                      size_t *upload_data_size,\n                      void **req_cls)\n{\n  const char *page = \"<html><body>Hello timeout!</body></html>\";\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) method;            /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n  (void) req_cls;           /* Unused. Silent compiler warning. */\n\n  response = MHD_create_response_from_buffer_static (strlen (page),\n                                                     (const void *) page);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_TYPE,\n                               \"text/html\"))\n  {\n    fprintf (stderr,\n             \"Failed to set content type header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nserve_simple_form (const void *cls,\n                   const char *mime,\n                   struct Session *session,\n                   struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer_static (strlen (form),\n                                                     (const void *) form);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nfill_v1_form (const void *cls,\n              const char *mime,\n              struct Session *session,\n              struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  size_t slen;\n  char *reply;\n  struct MHD_Response *response;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (MAIN_PAGE) + strlen (session->value_1);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            MAIN_PAGE,\n            session->value_1);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nfill_v1_v2_form (const void *cls,\n                 const char *mime,\n                 struct Session *session,\n                 struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void) cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1)\n         + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n            slen + 1,\n            SECOND_PAGE,\n            session->value_1,\n            session->value_2);\n  /* return static form */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (slen,\n                                                        (void *) reply,\n                                                        &free);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nnot_found_page (const void *cls,\n                const char *mime,\n                struct Session *session,\n                struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n  (void) cls;     /* Unused. Silent compiler warning. */\n  (void) session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (NOT_FOUND_ERROR),\n                                            (const void *) NOT_FOUND_ERROR);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_FOUND,\n                            response);\n  if (MHD_YES !=\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONTENT_ENCODING,\n                               mime))\n  {\n    fprintf (stderr,\n             \"Failed to set content encoding header!\\n\");\n  }\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\ncreate_response (void *cls,\n                 struct MHD_Connection *connection,\n                 const char *url,\n                 const char *method,\n                 const char *version,\n                 const char *upload_data,\n                 size_t *upload_data_size,\n                 void **req_cls)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  enum MHD_Result ret;\n  unsigned int i;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  request = *req_cls;\n  if (NULL == request)\n  {\n    request = calloc (1, sizeof (struct Request));\n    if (NULL == request)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return MHD_NO;\n    }\n    *req_cls = request;\n    if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor (connection, 1024,\n                                               &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n                 url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n  if (NULL == request->session)\n  {\n    request->session = get_session (connection);\n    if (NULL == request->session)\n    {\n      fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n               url);\n      return MHD_NO; /* internal error */\n    }\n  }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    if (MHD_YES !=\n        MHD_post_process (request->pp,\n                          upload_data,\n                          *upload_data_size))\n      return MHD_NO;\n    if (0 != *upload_data_size)\n    {\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor (request->pp);\n    request->pp = NULL;\n    method = MHD_HTTP_METHOD_GET;   /* fake 'GET' */\n    if (NULL != request->post_url)\n      url = request->post_url;\n  }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    /* find out which page to serve */\n    i = 0;\n    while ( (pages[i].url != NULL) &&\n            (0 != strcmp (pages[i].url, url)) )\n      i++;\n    ret = pages[i].handler (pages[i].handler_cls,\n                            pages[i].mime,\n                            session, connection);\n    if (ret != MHD_YES)\n      fprintf (stderr, \"Failed to create page for `%s'\\n\",\n               url);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response =\n    MHD_create_response_from_buffer_static (strlen (METHOD_ERROR),\n                                            (const void *) METHOD_ERROR);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_NOT_ACCEPTABLE,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}\n...\nstatic enum MHD_Result\nreturn_directory_response (struct MHD_Connection *connection)\n{\n  enum MHD_Result ret;\n\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL == cached_directory_response)\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_INTERNAL_SERVER_ERROR,\n                              internal_error_response);\n  else\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              cached_directory_response);\n  (void) pthread_mutex_unlock (&mutex);\n  return ret;\n}\n...\nstatic enum MHD_Result\ngenerate_page (void *cls,\n               struct MHD_Connection *connection,\n               const char *url,\n               const char *method,\n               const char *version,\n               const char *upload_data,\n               size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n  {\n    /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n    char file_data[MAGIC_HEADER_SIZE];\n    ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n    const char *mime;\n\n    if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n         (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n      return MHD_NO;    /* unexpected method (we're not polite...) */\n    fd = -1;\n    if ( (NULL == strstr (&url[1], \"..\")) &&\n         ('/' != url[1]) )\n    {\n      fd = open (&url[1], O_RDONLY);\n      if ( (-1 != fd) &&\n           ( (0 != fstat (fd, &buf)) ||\n             (! S_ISREG (buf.st_mode)) ) )\n      {\n        (void) close (fd);\n        fd = -1;\n      }\n    }\n    if (-1 == fd)\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_NOT_FOUND,\n                                 file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n    /* read beginning of the file to determine mime type  */\n    got = read (fd, file_data, sizeof (file_data));\n    (void) lseek (fd, 0, SEEK_SET);\n    if (0 < got)\n      mime = magic_buffer (magic, file_data, (size_t) got);\n    else\n#endif /* MHD_HAVE_LIBMAGIC */\n    mime = NULL;\n    {\n      /* Set mime-type by file-extension in some cases */\n      const char *ldot = strrchr (&url[1], '.');\n\n      if (NULL != ldot)\n      {\n        if (0 == strcasecmp (ldot,\n                             \".html\"))\n          mime = \"text/html\";\n        if (0 == strcasecmp (ldot,\n                             \".css\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".css3\"))\n          mime = \"text/css\";\n        if (0 == strcasecmp (ldot,\n                             \".js\"))\n          mime = \"application/javascript\";\n      }\n\n    }\n\n    if (NULL == (response = MHD_create_response_from_fd ((size_t) buf.st_size,\n                                                         fd)))\n    {\n      /* internal error (i.e. out of memory) */\n      (void) close (fd);\n      return MHD_NO;\n    }\n\n    /* add mime type if we had one */\n    if (NULL != mime)\n      (void) MHD_add_response_header (response,\n                                      MHD_HTTP_HEADER_CONTENT_TYPE,\n                                      mime);\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_OK,\n                              response);\n    MHD_destroy_response (response);\n    return ret;\n  }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n  {\n    /* upload! */\n    struct UploadContext *uc = *req_cls;\n\n    if (NULL == uc)\n    {\n      if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n        return MHD_NO; /* out of memory, close connection */\n      memset (uc, 0, sizeof (struct UploadContext));\n      uc->fd = -1;\n      uc->connection = connection;\n      uc->pp = MHD_create_post_processor (connection,\n                                          64 * 1024 /* buffer size */,\n                                          &process_upload_data, uc);\n      if (NULL == uc->pp)\n      {\n        /* out of memory, close connection */\n        free (uc);\n        return MHD_NO;\n      }\n      *req_cls = uc;\n      return MHD_YES;\n    }\n    if (0 != *upload_data_size)\n    {\n      if (NULL == uc->response)\n        (void) MHD_post_process (uc->pp,\n                                 upload_data,\n                                 *upload_data_size);\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n    /* end of upload, finish it! */\n    MHD_destroy_post_processor (uc->pp);\n    uc->pp = NULL;\n    if (-1 != uc->fd)\n    {\n      close (uc->fd);\n      uc->fd = -1;\n    }\n    if (NULL != uc->response)\n    {\n      return MHD_queue_response (connection,\n                                 MHD_HTTP_FORBIDDEN,\n                                 uc->response);\n    }\n    else\n    {\n      update_directory ();\n      return return_directory_response (connection);\n    }\n  }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n                             MHD_HTTP_FORBIDDEN,\n                             request_refused_response);\n}\n...\nstatic enum MHD_Result\nreply_with_page_not_found (struct MHD_Connection *c)\n{\n  static const char page_content[] =\n    \"<html><head><title>Page Not Found</title></head>\" \\\n    \"<body>The requested page not found.</body></html>\";\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                 page_content);\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_NOT_FOUND, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstatic enum MHD_Result\nreply_with_forbidden (struct MHD_Connection *c)\n{\n  static const char page_content[] =\n    \"<html><head><title>Forbidden</title></head>\" \\\n    \"<body>You do not have access to this page.</body></html>\";\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len, page_content)\n  ;\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_FORBIDDEN, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstatic enum MHD_Result\nreply_with_area1_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA1_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Restricted secret page</title></head>\" \\\n      \"<body>Welcome to the restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA1_URL \"some_path/some_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n...\nstatic enum MHD_Result\nreply_with_area2_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA2_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Very restricted secret page</title></head>\" \\\n      \"<body>Welcome to the super restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA2_URL \"other_path/other_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n...\nstatic enum MHD_Result\nreply_with_main_page (struct MHD_Connection *c)\n{\n  static const char page_content[] = MAIN_PAGE;\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len, page_content)\n  ;\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstatic enum MHD_Result\nreply_with_method_not_supported (struct MHD_Connection *c)\n{\n  static const char page_content[] =\n    \"<html><head><title>Requested HTTP Method Is Not Supported</title></head>\" \\\n    \"<body>The requested HTTP method is not supported.</body></html>\";\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len, page_content)\n  ;\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE, \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_NOT_IMPLEMENTED, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstatic enum MHD_Result\nsend_chat_page (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE),\n                                                (const void *) CHAT_PAGE);\n  ret = MHD_queue_response (con, MHD_HTTP_OK, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n...\nstatic enum MHD_Result\nsend_bad_request (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res =\n    MHD_create_response_from_buffer_static (strlen (BAD_REQUEST_PAGE),\n                                            (const void *) BAD_REQUEST_PAGE);\n  ret = MHD_queue_response (con, MHD_HTTP_BAD_REQUEST, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n...\nstatic enum MHD_Result\nsend_upgrade_required (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res =\n    MHD_create_response_from_buffer_static (strlen (UPGRADE_REQUIRED_PAGE),\n                                            (const void *)\n                                            UPGRADE_REQUIRED_PAGE);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION,\n                               WS_SEC_WEBSOCKET_VERSION))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_UPGRADE_REQUIRED, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n...\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n...\nstatic enum MHD_Result\nanswer_shared_response (void *cls,\n                        struct MHD_Connection *connection,\n                        const char *url,\n                        const char *method,\n                        const char *version,\n                        const char *upload_data,\n                        size_t *upload_data_size,\n                        void **req_cls)\n{\n  static int marker = 0;\n  unsigned int resp_index;\n  static volatile unsigned int last_index = 0;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n  /* This kind of operation does not guarantee that numbers are not reused\n     in parallel threads, when processed simultaneously, but this should not\n     be a big problem, as it just slow down replies a bit due to\n     responses locking. */\n  resp_index = (last_index++) % num_resps;\n  return MHD_queue_response (connection, MHD_HTTP_OK, resps[resp_index]);\n}\n...\nstatic enum MHD_Result\nanswer_single_response (void *cls,\n                        struct MHD_Connection *connection,\n                        const char *url,\n                        const char *method,\n                        const char *version,\n                        const char *upload_data,\n                        size_t *upload_data_size,\n                        void **req_cls)\n{\n  static int marker = 0;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n  return MHD_queue_response (connection, MHD_HTTP_OK, resp_single);\n}\n...\nstatic enum MHD_Result\nanswer_unique_empty_response (void *cls,\n                              struct MHD_Connection *connection,\n                              const char *url,\n                              const char *method,\n                              const char *version,\n                              const char *upload_data,\n                              size_t *upload_data_size,\n                              void **req_cls)\n{\n  static int marker = 0;\n  struct MHD_Response *r;\n  enum MHD_Result ret;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n#if MHD_VERSION >= 0x00097701\n  r = MHD_create_response_empty (MHD_RF_NONE);\n#else  /* MHD_VERSION < 0x00097701 */\n  r = MHD_create_response_from_buffer (0,\n                                       NULL,\n                                       MHD_RESPMEM_PERSISTENT);\n#endif /* MHD_VERSION < 0x00097701 */\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, r);\n  MHD_destroy_response (r);\n  return ret;\n}\n...\nstatic enum MHD_Result\nanswer_unique_tiny_response (void *cls,\n                             struct MHD_Connection *connection,\n                             const char *url,\n                             const char *method,\n                             const char *version,\n                             const char *upload_data,\n                             size_t *upload_data_size,\n                             void **req_cls)\n{\n  static int marker = 0;\n  struct MHD_Response *r;\n  enum MHD_Result ret;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n#if MHD_VERSION >= 0x00097701\n  r = MHD_create_response_from_buffer_static (MHD_STATICSTR_LEN_ (tiny_body),\n                                              tiny_body);\n#else  /* MHD_VERSION < 0x00097701 */\n  r = MHD_create_response_from_buffer (MHD_STATICSTR_LEN_ (tiny_body),\n                                       (void *) tiny_body,\n                                       MHD_RESPMEM_PERSISTENT);\n#endif /* MHD_VERSION < 0x00097701 */\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, r);\n  MHD_destroy_response (r);\n  return ret;\n}\n...\nstatic enum MHD_Result\nanswer_unique_dyn_response (void *cls,\n                            struct MHD_Connection *connection,\n                            const char *url,\n                            const char *method,\n                            const char *version,\n                            const char *upload_data,\n                            size_t *upload_data_size,\n                            void **req_cls)\n{\n  static int marker = 0;\n  struct MHD_Response *r;\n  enum MHD_Result ret;\n  (void) cls;  /* Unused */\n  (void) url; (void) version; /* Unused */\n  (void) upload_data; (void) upload_data_size; /* Unused */\n\n  if (NULL == *req_cls)\n  {\n    /* The fist call */\n    *req_cls = (void *) &marker;\n    /* Do not send reply yet. No error. */\n    return MHD_YES;\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n      (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)))\n    return MHD_NO; /* Unsupported method, close connection */\n\n#if MHD_VERSION >= 0x00097701\n  r = MHD_create_response_from_buffer_static (body_dyn_size,\n                                              body_dyn);\n#else  /* MHD_VERSION < 0x00097701 */\n  r = MHD_create_response_from_buffer (body_dyn_size,\n                                       (void *) body_dyn,\n                                       MHD_RESPMEM_PERSISTENT);\n#endif /* MHD_VERSION < 0x00097701 */\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, r);\n  MHD_destroy_response (r);\n  return ret;\n}\n...\nstatic enum MHD_Result\nsend_page (struct MHD_Connection *connection, const char *page)\n{\n  enum MHD_Result ret;\n  struct MHD_Response *response;\n\n\n  response = MHD_create_response_from_buffer_static (strlen (page), page);\n  if (! response)\n    return MHD_NO;\n\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            resps[resp_index]);\n\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call ret = MHD_queue_response(connection, MHD_HTTP_OK, resps[resp_index]); occurs inside an access handler (answer_shared_response) invoked via call_connection_handler while connection->in_access_handler and connection->in_idle are true. MHD_queue_response, when called with connection->in_idle == true, does not call MHD_connection_handle_idle (it only does that when !connection->in_idle). Also, when MHD_queue_response previously calls MHD_connection_handle_idle it sets connection->rp.response before doing so, and call_connection_handler immediately returns if connection->rp.response != NULL. Therefore there is no possible call chain that leads MHD_queue_response to call itself (directly or indirectly) in this scenario."
}