{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_unquoted_param_copy:\n```c\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function get_unquoted_param_copy:\nstatic char *\nget_buffer_for_size (char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                     char **ptmp2,\n                     size_t *ptmp2_size,\n                     size_t required_size)\n{\n  mhd_assert ((0 == *ptmp2_size) || (NULL != *ptmp2));\n  mhd_assert ((NULL != *ptmp2) || (0 == *ptmp2_size));\n  mhd_assert ((0 == *ptmp2_size) || \\\n              (_MHD_STATIC_UNQ_BUFFER_SIZE < *ptmp2_size));\n\n  if (required_size <= _MHD_STATIC_UNQ_BUFFER_SIZE)\n    return tmp1;\n\n  if (required_size <= *ptmp2_size)\n    return *ptmp2;\n\n  if (required_size > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE)\n    return NULL;\n  if (NULL != *ptmp2)\n    free (*ptmp2);\n  *ptmp2 = (char *) malloc (required_size);\n  if (NULL == *ptmp2)\n    *ptmp2_size = 0;\n  else\n    *ptmp2_size = required_size;\n  return *ptmp2;\n}\n...\nsize_t\nMHD_str_unquote (const char *quoted,\n                 size_t quoted_len,\n                 char *result)\n{\n  size_t r;\n  size_t w;\n\n  r = 0;\n  w = 0;\n\n  while (quoted_len > r)\n  {\n    if ('\\\\' == quoted[r])\n    {\n      ++r;\n      if (quoted_len == r)\n        return 0; /* Last backslash is not followed by char to unescape */\n    }\n    result[w++] = quoted[r++];\n  }\n  return w;\n}\n...\nstruct MHD_RqDAuthParam\n{\n  /**\n   * The string with length, NOT zero-terminated\n   */\n  struct _MHD_str_w_len value;\n  /**\n   * True if string must be \"unquoted\" before processing.\n   * This member is false if the string is used in DQUOTE marks, but no\n   * backslash-escape is used in the string.\n   */\n  bool quoted;\n}\n...\nstruct _MHD_mstr_w_len\n{\n  char *str;\n  size_t len;\n}\n...\n#define _MHD_AUTH_DIGEST_MAX_PARAM_SIZE (65535)\n...\n#define _MHD_STATIC_UNQ_BUFFER_SIZE 128\n...\n#define mhd_assert(ignore) ((void)0)\n...\nenum _MHD_GetUnqResult\n{\n  _MHD_UNQ_OK = 0,         /**< Got unquoted string */\n  _MHD_UNQ_TOO_LARGE = -7, /**< The string is too large to unquote */\n  _MHD_UNQ_OUT_OF_MEM = 3  /**< Out of memory error */\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no controlling expressions that are invariant. All conditional and loop controlling expressions depend on function parameters or variables that are modified within the function, so they are not constant/invariant as prohibited by MISRA C 2023 Rule 14.3. Specific points considered:\n\n- get_unquoted_param_copy:\n  - if (NULL == unquoted->str): depends on the result of get_buffer_for_size (allocation outcome) \u2014 not invariant.\n  - (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) in the ternary: depends on param->value.len \u2014 not invariant.\n  - if (! param->quoted): depends on runtime field param->quoted \u2014 not invariant.\n\n- get_buffer_for_size:\n  - The mhd_assert(...) invocations expand to ((void)0) in the provided code, so they are not controlling expressions.\n  - if (required_size <= _MHD_STATIC_UNQ_BUFFER_SIZE): depends on required_size \u2014 not invariant.\n  - if (required_size <= *ptmp2_size): depends on *ptmp2_size and required_size \u2014 not invariant.\n  - if (required_size > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE): depends on required_size \u2014 not invariant.\n  - if (NULL != *ptmp2) and if (NULL == *ptmp2): depend on *ptmp2 \u2014 not invariant.\n\n- MHD_str_unquote:\n  - while (quoted_len > r): r is modified inside the loop, so the condition is not invariant.\n  - if ('\\\\' == quoted[r]) and if (quoted_len == r): both depend on data/indices \u2014 not invariant.\n\nNo do/while with an essentially Boolean constant-false controlling expression or intentionally infinite-loop constant controlling expressions were found. Therefore there are no fragments that need investigation for Rule 14.3 in the provided code."
}