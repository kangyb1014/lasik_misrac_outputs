{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_sys_cpu_count_special_api_': {'callees': [], 'callers': ['mhd_tool_get_system_cpu_count']}, 'mhd_tool_get_system_cpu_count': {'callees': ['mhd_tool_get_sys_cpu_count_special_api_', 'mhd_tool_get_sys_cpu_count_sysctl_', 'mhd_tool_get_sys_cpu_count_sysconf_', 'mhd_tool_get_proc_cpu_count', 'mhd_tool_get_sys_cpu_count_sysctl_fallback_', 'mhd_tool_get_sys_cpu_count_sysconf_fallback_'], 'callers': ['detect_cpu_core_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_PSTAT_GETDYNAMIC",
    "pstat_getdynamic",
    "struct pst_dynamic",
    "psd_proc_cnt",
    "HAVE_VXCPUENABLEDGET",
    "vxCpuEnabledGet",
    "cpuset_t",
    "_WIN32",
    "__CYGWIN__",
    "HMODULE",
    "LoadLibraryA",
    "GetProcAddress",
    "FreeLibrary",
    "FARPROC",
    "WINAPI",
    "__stdcall",
    "GetActiveProcessorCount",
    "ALL_PROCESSOR_GROUPS",
    "DWORD",
    "WORD",
    "GAPC_PTR (typedef)",
    "SYSTEM_INFO",
    "GetNativeSystemInfo",
    "GetSystemInfo",
    "dwNumberOfProcessors",
    "memset",
    "NULL",
    "size_t"
  ],
  "explanation": "For deciding whether this function uses any compiler language extensions you must know the declarations/definitions and macro expansions that affect calling conventions, pointer casts, or non\u2011standard keywords. Each listed symbol is required for that check:\n\n- HAVE_PSTAT_GETDYNAMIC: controls inclusion of the HP\u2011UX branch; must know if that block is compiled.\n- pstat_getdynamic / struct pst_dynamic / psd_proc_cnt: the API and struct definitions can carry platform\u2011specific attributes or nonstandard storage/class specifiers; check whether any extension is used.\n\n- HAVE_VXCPUENABLEDGET: controls inclusion of the VxWorks branch.\n- vxCpuEnabledGet / cpuset_t: cpuset_t may be a platform typedef or intrinsic type and vxCpuEnabledGet could have nonstandard calling convention attributes; both can indicate compiler/platform extensions.\n\n- _WIN32 / __CYGWIN__: control inclusion of Windows code; required to know if Windows\u2011specific code (and its constructs) are compiled.\n- HMODULE / LoadLibraryA / GetProcAddress / FreeLibrary: declarations of these WinAPI functions determine return types and whether casts in code are between incompatible pointer types; GetProcAddress in particular is central to a questionable cast.\n- FARPROC (or PROC): the exact declared type returned by GetProcAddress is needed to see whether the code casts between function and object pointers in a way that relies on an extension.\n- WINAPI and __stdcall: WINAPI expands to a calling\u2011convention specifier (often __stdcall). Such calling\u2011convention keywords are commonly documented as compiler extensions; you must inspect their definitions to decide MISRA compliance.\n\n- GetActiveProcessorCount / GAPC_PTR (typedef) / ALL_PROCESSOR_GROUPS / DWORD / WORD: the prototype of GetActiveProcessorCount and the typedefs determine if nonstandard calling conventions or integer width/type aliases are used, and whether the code performs any implementation\u2011defined/extension behavior (casts/overflow checks).\n\n- SYSTEM_INFO / GetNativeSystemInfo / GetSystemInfo / dwNumberOfProcessors: the structure and these APIs determine types and calling conventions used in that branch and whether any platform\u2011specific attributes appear.\n\n- memset / NULL / size_t: standard symbols are included to confirm whether standard library functions/types are used correctly; also to rule out use of nonstandard replacement macros or extensions in their declarations.\n\nIn short: to decide if the function uses language/compiler extensions you must inspect the platform API/type/macro definitions (especially WINAPI/__stdcall and the exact GetProcAddress/FARPROC declaration and any platform typedefs) and know which conditional branches are active (the HAVE_*/_WIN32 macros). These symbols let the next analyst examine those definitions to determine whether any extension (calling convention keywords, pointer casting between data and function pointers documented as an extension, or other compiler\u2011specific attributes) is present."
}