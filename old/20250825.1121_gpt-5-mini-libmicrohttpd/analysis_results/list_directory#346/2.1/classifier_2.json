{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of list_directory:\n```c\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function list_directory:\nstruct ResponseDataContext\n{\n  /**\n   * Response data string.\n   */\n  char *buf;\n\n  /**\n   * Number of bytes allocated for 'buf'.\n   */\n  size_t buf_len;\n\n  /**\n   * Current position where we append to 'buf'. Must be smaller or equal to 'buf_len'.\n   */\n  size_t off;\n\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (rdc->off + 1024 > rdc->buf_len)\n  {\n    void *r;\n\n    if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n      break; /* more than SIZE_T _index_ size? Too big for us */\n    rdc->buf_len = 2 * rdc->buf_len + 1024;\n    if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n      break; /* out of memory */\n    rdc->buf = r;\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The two 'break' paths in the fragment are reachable: (1) if rdc->buf_len is so large that (2 * rdc->buf_len + 1024) wraps around (i.e. becomes < rdc->buf_len) the overflow-detection branch is taken and breaks out of the loop, and (2) if realloc fails (returns NULL) the realloc-failure branch breaks. If neither occurs the code continues and rdc->buf is updated. Therefore there is no unreachable code in this fragment."
}