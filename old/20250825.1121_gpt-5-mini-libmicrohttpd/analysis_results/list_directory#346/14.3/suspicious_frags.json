{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of list_directory:\n```c\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function list_directory:\nstruct ResponseDataContext\n{\n  /**\n   * Response data string.\n   */\n  char *buf;\n\n  /**\n   * Number of bytes allocated for 'buf'.\n   */\n  size_t buf_len;\n\n  /**\n   * Current position where we append to 'buf'. Must be smaller or equal to 'buf_len'.\n   */\n  size_t off;\n\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no controlling expressions that are compile-time or otherwise invariant under all program executions. Each conditional/loop control depends on runtime values or function results: \n\n- if (NULL == (dir = opendir (dirname))) \u2014 depends on filesystem state and dirname at runtime.\n- while (NULL != (de = readdir (dir))) \u2014 depends on the directory stream returned by readdir at runtime.\n- if ('.' == de->d_name[0]) \u2014 depends on the directory entry returned by readdir.\n- if (sizeof (fullname) <= (unsigned int) snprintf(...)) \u2014 snprintf() return is determined at runtime by dirname/de->d_name; sizeof(fullname) is constant but the comparison is not invariant because snprintf result is dynamic.\n- if (0 != stat (fullname, &sbuf)) \u2014 depends on filesystem state at runtime.\n- if (! S_ISREG (sbuf.st_mode)) \u2014 depends on st_mode returned by stat at runtime.\n- if (rdc->off + 1024 > rdc->buf_len) \u2014 depends on rdc fields at runtime.\n- if ( (2 * rdc->buf_len + 1024) < rdc->buf_len) \u2014 although this looks like it is normally false, it is a runtime check for unsigned wrap/overflow based on rdc->buf_len; it is not a compile-time invariant.\n- if (NULL == (r = realloc (rdc->buf, rdc->buf_len))) \u2014 depends on allocator state at runtime.\n- if (0 >= res) and if (rdc->buf_len - rdc->off <= (size_t) res) \u2014 both depend on snprintf()\u2019s runtime return and current rdc fields.\n\nNone of these controls are constant by construction; they all depend on runtime data or function results. Therefore, there are no fragments that obviously violate MISRA C 2023 Rule 14.3 (controlling expressions shall not be invariant) and no fragments need to be flagged for invariant-control investigation."
}