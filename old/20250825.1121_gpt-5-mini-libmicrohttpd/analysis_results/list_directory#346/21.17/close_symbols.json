{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'list_directory': {'callees': [], 'callers': ['update_directory']}, 'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct ResponseDataContext (full definition including types of buf, buf_len, off)",
    "PATH_MAX (macro value)",
    "struct dirent definition (layout of d_name, max length) and NAME_MAX/NAME_MAX macro",
    "snprintf prototype and C standard semantics (return value meaning on truncation and error, return type)",
    "realloc prototype/semantics (behaviour on NULL, failure, pointer validity)",
    "types and ranges of int and unsigned int on the target platform (for the cast (unsigned int) snprintf(...))",
    "type widths and signedness of buf_len and off (e.g., size_t)"
  ],
  "explanation": "Each symbol and why it is needed:\n\n- struct ResponseDataContext (full definition including types of buf, buf_len, off): the function writes into rdc->buf, uses rdc->buf_len and rdc->off for all buffer-bound checks and arithmetic (rdc->off + 1024, rdc->buf_len - rdc->off, resizing). To prove no out-of-bounds access you must know the exact types (signed/unsigned, width) and semantics of these members and whether buf is char * (null-terminated data) or some other type.\n\n- PATH_MAX (macro value): fullname is declared as char fullname[PATH_MAX]; the code uses sizeof(fullname) to limit snprintf into fullname. The numeric value of PATH_MAX (and whether it is defined) determines the actual buffer bound used in the check.\n\n- struct dirent definition (layout of d_name, max length) and NAME_MAX/NAME_MAX macro: de->d_name is concatenated into fullname and later copied into rdc->buf via snprintf. You must know whether d_name is always null-terminated, its maximal possible length (NAME_MAX or implementation detail) to reason about the maximum resulting string lengths and whether snprintf checks are sufficient.\n\n- snprintf prototype and C standard semantics (return value meaning on truncation and error, return type): the code relies on the numeric return value of snprintf both when creating fullname and when appending to rdc->buf. To conclude absence of string.h violations you must know that snprintf returns the number of characters that would have been written (excluding the trailing NUL) on conforming C99+ implementations, and how negative/error returns are reported, so the comparisons (<= sizeof(fullname) and <= rdc->buf_len - rdc->off) are valid.\n\n- realloc prototype/semantics (behaviour on NULL, failure, pointer validity): the code enlarges rdc->buf via realloc and updates rdc->buf on success. To check for potential UB or dangling-pointer scenarios that might lead to invalid buffer accesses, you need realloc behaviour (returning NULL on failure, preserving original pointer on failure, allowed pointer alignment, and effect when buf is NULL).\n\n- types and ranges of int and unsigned int on the target platform (for the cast (unsigned int) snprintf(...)): the code casts the int return of snprintf to unsigned int in the fullname length check. If snprintf can return values outside the target range of unsigned int or negative values that become large after cast, the comparison may be incorrect and permit an out-of-bounds write. Knowing int width and unsigned int width is necessary to reason about truncation/wrap and safety of that cast.\n\n- type widths and signedness of buf_len and off (e.g., size_t): arithmetic and overflow checks (rdc->off + 1024 > rdc->buf_len and (2 * rdc->buf_len + 1024) < rdc->buf_len) are used to avoid wrap/overflow. You must know the exact types and widths of these fields to prove these checks actually prevent integer overflow/wrap and so guarantee buffer-size invariants.\n\nThese symbols supply the required information about buffer sizes, string source lengths, integer widths, and function return semantics needed to determine whether any string handling in this function can access memory beyond the bounds of the referenced objects. Note: the MISRA rule quoted targets <string.h> functions; this function uses snprintf (stdio) and needs the above symbols to show snprintf and the buffer-management logic do not cause out-of-bounds accesses."
}