{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nlist_directory (struct ResponseDataContext *rdc,\n                const char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n  {\n    int res;\n    if ('.' == de->d_name[0])\n      continue;\n    if (sizeof (fullname) <= (unsigned int)\n        snprintf (fullname, sizeof (fullname),\n                  \"%s/%s\",\n                  dirname, de->d_name))\n      continue;  /* ugh, file too long? how can this be!? */\n    if (0 != stat (fullname, &sbuf))\n      continue;  /* ugh, failed to 'stat' */\n    if (! S_ISREG (sbuf.st_mode))\n      continue;  /* not a regular file, skip */\n    if (rdc->off + 1024 > rdc->buf_len)\n    {\n      void *r;\n\n      if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n        break; /* more than SIZE_T _index_ size? Too big for us */\n      rdc->buf_len = 2 * rdc->buf_len + 1024;\n      if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n        break; /* out of memory */\n      rdc->buf = r;\n    }\n    res = snprintf (&rdc->buf[rdc->off],\n                    rdc->buf_len - rdc->off,\n                    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n                    fullname,\n                    de->d_name);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc->buf_len - rdc->off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc->off += (size_t) res;\n  }\n  (void) closedir (dir);\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'list_directory': {'callees': [], 'callers': ['update_directory']}, 'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "PATH_MAX",
    "struct ResponseDataContext",
    "rdc->buf",
    "rdc->buf_len",
    "rdc->off",
    "struct stat",
    "stat",
    "S_ISREG",
    "DIR",
    "struct dirent",
    "de->d_name",
    "opendir",
    "readdir",
    "closedir",
    "snprintf",
    "realloc",
    "size_t",
    "NULL",
    "MHD_Result",
    "MHD_NO",
    "MHD_YES"
  ],
  "explanation": "For checking MISRA C rule about language extensions we must know which constructs here are ordinary standard C versus possible compiler-specific or newer-language features. Each listed symbol is required as follows:\n\n- PATH_MAX: The array char fullname[PATH_MAX] could be a fixed-size array (standard C) or, if PATH_MAX is not a compile-time constant, this usage may become a variable-length array (VLA). Knowing PATH_MAX definition (header and whether it is an integer constant expression) is necessary to determine if a VLA (C99 feature or extension in some compilers) is being used.\n\n- struct ResponseDataContext, rdc->buf, rdc->buf_len, rdc->off: The exact types of these fields (e.g., buf pointer type, buf_len and off being size_t or a signed type) affect unsigned arithmetic, overflow detection, realloc usage and casts. If these fields use nonstandard types or compiler-specific attributes (e.g., bit-fields, packed, or flexible array members), that could be a language-extension violation. We need the struct definition.\n\n- struct stat, stat, S_ISREG: To verify that use of stat() and the S_ISREG macro is standard POSIX/C usage and not relying on implementation-specific extensions (for example, nonstandard fields, bitfield layouts, or macros implemented via compiler extensions). Also needed to confirm types involved for portable behavior.\n\n- DIR, struct dirent, de->d_name, opendir, readdir, closedir: The code indexes de->d_name[0] and passes de->d_name to snprintf. The definition of struct dirent (in particular d_name \u2014 whether it is a flexible array member, a fixed-size array, or implemented specially) can involve C99 flexible array members or vendor extensions. We must inspect these declarations (and related API prototypes) from <dirent.h> to determine whether the code relies on any nonstandard extension.\n\n- snprintf: Its prototype and standard semantics (return type int, behavior on truncation and errors) must be known to confirm the uses and checks (casting to unsigned int, checks for <=, negative return handling) are standard C and not relying on implementation-specific behavior or nonstandard macro replacements.\n\n- realloc: Prototype and semantics (signature taking size_t, returning void*) are needed to validate the castless use and the resizable-buffer logic; to check whether any extension (e.g., custom realloc-like macro) is used.\n\n- size_t and NULL: Knowing the exact definitions of size_t and NULL (standard typedef/macro) is necessary to reason about unsigned arithmetic, comparisons, and the overflow-detection idiom ((2 * buf_len + 1024) < buf_len) \u2014 if buf_len is signed or uses a nonstandard type, the expression could rely on extension/undefined behaviour.\n\n- MHD_Result, MHD_NO, MHD_YES: These types/constants come from the Microhttpd (or similar) API. Their definitions must be checked to ensure they are plain enum/defines (standard C) and do not use compiler-specific extensions (attributes, unusual enum sizes, or macros that expand to vendor-specific constructs).\n\nIn short, these symbols provide the declarations and macro definitions required to determine whether the code uses VLAs, flexible array members, compiler-specific attributes/macros, or other nonstandard constructs that would violate the \u2018\u2018no language extensions\u2019\u2019 MISRA rule."
}