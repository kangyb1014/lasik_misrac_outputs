{
  "user_message": "Target function code is:\n```c\nstatic char *\nget_buffer_for_size (char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                     char **ptmp2,\n                     size_t *ptmp2_size,\n                     size_t required_size)\n{\n  mhd_assert ((0 == *ptmp2_size) || (NULL != *ptmp2));\n  mhd_assert ((NULL != *ptmp2) || (0 == *ptmp2_size));\n  mhd_assert ((0 == *ptmp2_size) || \\\n              (_MHD_STATIC_UNQ_BUFFER_SIZE < *ptmp2_size));\n\n  if (required_size <= _MHD_STATIC_UNQ_BUFFER_SIZE)\n    return tmp1;\n\n  if (required_size <= *ptmp2_size)\n    return *ptmp2;\n\n  if (required_size > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE)\n    return NULL;\n  if (NULL != *ptmp2)\n    free (*ptmp2);\n  *ptmp2 = (char *) malloc (required_size);\n  if (NULL == *ptmp2)\n    *ptmp2_size = 0;\n  else\n    *ptmp2_size = required_size;\n  return *ptmp2;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_buffer_for_size': {'callees': [], 'callers': ['get_unquoted_param', 'get_unquoted_param_copy', 'digest_auth_check_all_inner']}, 'get_unquoted_param': {'callees': ['get_buffer_for_size', 'MHD_str_unquote'], 'callers': ['digest_auth_check_all_inner']}, 'get_unquoted_param_copy': {'callees': ['get_buffer_for_size', 'MHD_str_unquote'], 'callers': ['digest_auth_check_all_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "_MHD_STATIC_UNQ_BUFFER_SIZE",
    "_MHD_AUTH_DIGEST_MAX_PARAM_SIZE",
    "malloc",
    "free",
    "NULL",
    "size_t"
  ],
  "explanation": "You must supply the following symbols/definitions so the next analyser can determine whether any function parameter (the pointer parameter itself) is modified inside get_buffer_for_size.\n\n- mhd_assert: This is invoked three times at function entry. mhd_assert might be a macro or function with side effects (it could modify parameters in non-standard builds). Provide its definition to prove it does not assign to any of the parameter variables (tmp1, ptmp2, ptmp2_size, required_size).\n\n- _MHD_STATIC_UNQ_BUFFER_SIZE: Used both as the array bound for tmp1 (parameter declared as char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE]) and in comparisons. The analyser needs its definition to confirm the parameter is indeed an array-to-pointer parameter and to understand the significance of comparisons (though the array-to-pointer adjustment rule is standard, the bound helps confirm intent and any unusual macro semantics).\n\n- _MHD_AUTH_DIGEST_MAX_PARAM_SIZE: Used in the upper-bound check for required_size. Provide its definition to confirm control-flow (early return versus allocation) does not cause indirect modification of pointer parameters.\n\n- malloc: The call '*ptmp2 = (char *) malloc (required_size);' assigns the returned pointer into *ptmp2. Provide the malloc prototype/semantics to show that the code modifies the object pointed-to by ptmp2 (allowed by MISRA) and does not reassign the ptmp2 parameter itself.\n\n- free: The call 'free(*ptmp2);' releases memory pointed to by *ptmp2. Provide free's prototype/semantics to show it operates on the pointee and does not modify the pointer parameter variable ptmp2.\n\n- NULL: The code compares pointers to NULL and returns NULL in one branch. Provide the NULL definition (macro) so the analyser can unambiguously interpret NULL comparisons/assignments.\n\n- size_t: Provide the typedef for size_t (usually from <stddef.h>/<stdint.h>) so the analyser can confirm that required_size and *ptmp2_size are value (not pointer) parameters and that ptmp2_size is a pointer-to-size_t (so writing '*ptmp2_size = required_size;' would be pointer-target modification and allowed).\n\nRationale summary: The MISRA rule under scrutiny forbids modifying a parameter variable itself; it allows modifying the object pointed to by pointer parameters. To prove compliance we must inspect any called/asserted symbols and macros that could themselves modify the parameter variables, and confirm that only the pointees (e.g., *ptmp2, *ptmp2_size) are written and not the parameter pointers (tmp1, ptmp2, ptmp2_size, required_size). The listed symbols are the minimal set needed to perform that verification."
}