{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of named_thread_starter:\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  MHD_set_cur_thread_name_ (param->name);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No \u2014 the single call MHD_set_cur_thread_name_(param->name) does not by itself violate MISRA C 2023 Rule 21.17. The rule targets direct uses of <string.h> functions (memcpy/strcpy/strlen/etc.) that can read or write past object bounds. The call here merely passes a pointer; whether a violation occurs depends on the implementation of MHD_set_cur_thread_name_ and the validity/contents of param->name. Specific violation scenario: if MHD_set_cur_thread_name_ uses strlen/strcpy/strncpy/strcat/strncat/etc. and param->name is not null\u2011terminated, shorter than the function assumes, or longer than the destination buffer used inside MHD_set_cur_thread_name_, then those internal string calls could read or write beyond the bounds (e.g. strlen(param->name) reads past the array, or strcpy into a fixed-size thread-name buffer overflows). In that case Rule 21.17 would be violated."
}