{
  "user_message": "Target function code is:\n```c\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'named_thread_starter': {'callees': ['MHD_set_thread_name_'], 'callers': []}, 'MHD_set_thread_name_': {'callees': [], 'callers': ['named_thread_starter']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_THRD_RTRN_TYPE_",
    "MHD_THRD_CALL_SPEC_",
    "MHD_THREAD_START_ROUTINE_",
    "struct MHD_named_helper_param_",
    "MHD_set_cur_thread_name_",
    "MHD_set_thread_name_"
  ],
  "explanation": "For checking MISRA C rule on language extensions we must inspect any macros/typedefs that can expand to compiler-specific extensions (calling conventions, attributes, non\u2011standard storage-class or types) and the struct that carries the function pointer:\n\n- MHD_THRD_RTRN_TYPE_: This macro names the function return type used by named_thread_starter. It may expand to a compiler-specific type or include attributes (e.g. __declspec, __attribute__) that are language extensions.\n\n- MHD_THRD_CALL_SPEC_: This macro is applied to the function signature (calling specification). It commonly encodes calling conventions or attributes (e.g. __stdcall, WINAPI, __attribute__((...))) which are non\u2011standard extensions that must be examined.\n\n- MHD_THREAD_START_ROUTINE_: The typedef for thr_func. The typedef may embed calling conventions or attributes (or a non\u2011standard prototype) and so must be checked for extensions.\n\n- struct MHD_named_helper_param_: Definition is needed to see the exact types of members (name, arg, start_routine). In particular, start_routine\u2019s type and any annotations on members could hide extensions.\n\n- MHD_set_cur_thread_name_: Declaration/definition (or macro) of the called routine used in the function. It could be a macro that expands to compiler extensions or be declared with attributes; the code calls it so its declaration must be checked.\n\n- MHD_set_thread_name_: The provided static call graph references this symbol; include it as well in case the actual symbol is an alias/macro to/from MHD_set_cur_thread_name_. Its declaration/definition must be checked for extensions.\n\n(Stdlib free/NULL need not be inspected for extensions as they are standard C; the focus is on project macros/typedefs and function declarations that commonly hide compiler extensions.)"
}