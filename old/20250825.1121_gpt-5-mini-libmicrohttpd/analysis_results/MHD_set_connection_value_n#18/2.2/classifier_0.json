{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_set_connection_value_n:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_connection_value_n (struct MHD_Connection *connection,\n                            enum MHD_ValueKind kind,\n                            const char *key,\n                            size_t key_size,\n                            const char *value,\n                            size_t value_size)\n{\n  if ( (MHD_GET_ARGUMENT_KIND != kind) &&\n       ( ((key ? strlen (key) : 0) != key_size) ||\n         ((value ? strlen (value) : 0) != value_size) ) )\n    return MHD_NO; /* binary zero is allowed only in GET arguments */\n\n  return MHD_set_connection_value_n_nocheck_ (connection,\n                                              kind,\n                                              key,\n                                              key_size,\n                                              value,\n                                              value_size);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_connection_value_n:\nstatic enum MHD_Result\nconnection_add_header (void *cls,\n                       const char *key,\n                       size_t key_size,\n                       const char *value,\n                       size_t value_size,\n                       enum MHD_ValueKind kind)\n{\n  struct MHD_Connection *connection = (struct MHD_Connection *) cls;\n  if (MHD_NO ==\n      MHD_set_connection_value_n (connection,\n                                  kind,\n                                  key,\n                                  key_size,\n                                  value,\n                                  value_size))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in pool to allocate header record!\\n\"));\n#endif\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                    ERR_MSG_REQUEST_TOO_BIG);\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n...\nenum MHD_ValueKind\n{\n\n  /**\n   * Response header\n   * @deprecated\n   */\n  MHD_RESPONSE_HEADER_KIND = 0,\n#define MHD_RESPONSE_HEADER_KIND \\\n  _MHD_DEPR_IN_MACRO ( \\\n    \"Value MHD_RESPONSE_HEADER_KIND is deprecated and not used\") \\\n  MHD_RESPONSE_HEADER_KIND\n\n  /**\n   * HTTP header (request/response).\n   */\n  MHD_HEADER_KIND = 1,\n\n  /**\n   * Cookies.  Note that the original HTTP header containing\n   * the cookie(s) will still be available and intact.\n   */\n  MHD_COOKIE_KIND = 2,\n\n  /**\n   * POST data.  This is available only if a content encoding\n   * supported by MHD is used (currently only URL encoding),\n   * and only if the posted content fits within the available\n   * memory pool.  Note that in that case, the upload data\n   * given to the #MHD_AccessHandlerCallback will be\n   * empty (since it has already been processed).\n   */\n  MHD_POSTDATA_KIND = 4,\n\n  /**\n   * GET (URI) arguments.\n   */\n  MHD_GET_ARGUMENT_KIND = 8,\n\n  /**\n   * HTTP footer (only for HTTP 1.1 chunked encodings).\n   */\n  MHD_FOOTER_KIND = 16\n}\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\npos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The assignments to pos->header, pos->header_size, pos->value, pos->value_size, pos->kind and pos->next initialize the newly allocated header node and are later relied on when the node is appended to the linked list; removing them would change program behaviour. The allocation and NULL check are also necessary. Therefore this fragment does not contain dead code and does not violate MISRA C 2023 Rule 2.2."
}