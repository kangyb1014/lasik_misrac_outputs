{
  "user_message": "An agent A claimed that the following init_rand_data code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of init_rand_data.\n```c\nstatic int\ninit_rand_data (void)\n{\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n  int fd;\n  ssize_t len;\n  size_t off;\n\n  fd = open (\"/dev/urandom\", O_RDONLY);\n  if (-1 == fd)\n  {\n    fprintf (stderr, \"Failed to open '%s': %s\\n\",\n             \"/dev/urandom\",\n             strerror (errno));\n    return 0;\n  }\n  for (off = 0; off < sizeof(rand_data); off += (size_t) len)\n  {\n    len = read (fd, rand_data, 8);\n    if (0 > len)\n    {\n      fprintf (stderr, \"Failed to read '%s': %s\\n\",\n               \"/dev/urandom\",\n               strerror (errno));\n      (void) close (fd);\n      return 0;\n    }\n  }\n  (void) close (fd);\n#else  /* Native W32 */\n  HCRYPTPROV cc;\n  BOOL b;\n\n  b = CryptAcquireContext (&cc,\n                           NULL,\n                           NULL,\n                           PROV_RSA_FULL,\n                           CRYPT_VERIFYCONTEXT);\n  if (FALSE == b)\n  {\n    fprintf (stderr,\n             \"Failed to acquire crypto provider context: %lu\\n\",\n             (unsigned long) GetLastError ());\n    return 0;\n  }\n  b = CryptGenRandom (cc, sizeof(rand_data), (BYTE *) rand_data);\n  if (FALSE == b)\n  {\n    fprintf (stderr,\n             \"Failed to generate 8 random bytes: %lu\\n\",\n             GetLastError ());\n  }\n  CryptReleaseContext (cc, 0);\n  if (FALSE == b)\n    return 0;\n#endif /* Native W32 */\n\n  return ! 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes two nul\u2011terminated strings as char pointers: the string literal \"/dev/urandom\" and the result of strerror(errno). Both are used as non\u2011const char * (via the %s varargs) even though they are not modified and should be treated as const. In particular strerror() returns char * (non\u2011const) but the pointed data is effectively read\u2011only \u2014 the pointer should be to const char. Thus the code violates MISRA C 2023 Rule 8.13. A fix is to use a const char * for the message(s), e.g. const char *msg = strerror(errno); and pass msg (or cast the literal to const char *), so pointers point to const\u2011qualified types where possible.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function init_rand_data:\nstatic uint8_t rand_data[8]\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. MISRA C 2023 Rule 8.13 concerns pointer declarations: a pointer type should be const-qualified when the pointed-to object is not modified. In the shown code there is no pointer variable declared that ought to be const-qualified \u2014 the expressions passed to fprintf are a string literal (which in C has type array of char and decays to char *) and the return value of strerror (whose prototype returns char *). You cannot change the intrinsic type of a string literal nor the prototype of strerror; these are API/language facts. Assigning the strerror result to a local const char * would be a defensive improvement, but its absence here is not a clear violation of Rule 8.13 (the rule applies to pointer declarations and is qualified by \u201cwhenever possible\u201d). Therefore the reported violation is not correct."
}