{
  "user_message": "Target function code is:\n```c\nstatic void\nupdate_directory (void)\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n  int res;\n  size_t len;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n  {\n    update_cached_response (NULL);\n    return;\n  }\n  len = strlen (INDEX_PAGE_HEADER);\n  if (rdc.buf_len <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_HEADER, len);\n  rdc.off = len;\n  for (language_idx = 0; NULL != languages[language_idx].dirname;\n       language_idx++)\n  {\n    language = &languages[language_idx];\n\n    if (0 != stat (language->dirname, &sbuf))\n      continue; /* empty */\n    /* we ensured always +1k room, filenames are ~256 bytes,\n       so there is always still enough space for the header\n       without need for an additional reallocation check. */\n    res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                    \"<h2>%s</h2>\\n\",\n                    language->longname);\n    if (0 >= res)\n      continue;  /* snprintf() error */\n    if (rdc.buf_len - rdc.off <= (size_t) res)\n      continue;  /* buffer too small?? */\n    rdc.off += (size_t) res;\n    for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n    {\n      category = categories[category_idx];\n      res = snprintf (dir_name, sizeof (dir_name),\n                      \"%s/%s\",\n                      language->dirname,\n                      category);\n      if ((0 >= res) || (sizeof (dir_name) <= (size_t) res))\n        continue;  /* cannot print dir name */\n      if (0 != stat (dir_name, &sbuf))\n        continue;  /* empty */\n\n      /* we ensured always +1k room, filenames are ~256 bytes,\n         so there is always still enough space for the header\n         without need for an additional reallocation check. */\n      res = snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n                      \"<h3>%s</h3>\\n\",\n                      category);\n      if (0 >= res)\n        continue;  /* snprintf() error */\n      if (rdc.buf_len - rdc.off <= (size_t) res)\n        continue;  /* buffer too small?? */\n      rdc.off += (size_t) res;\n\n      if (MHD_NO == list_directory (&rdc, dir_name))\n      {\n        free (rdc.buf);\n        update_cached_response (NULL);\n        return;\n      }\n    }\n  }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  len = strlen (INDEX_PAGE_FOOTER);\n  if (rdc.buf_len - rdc.off <= len)\n  { /* buffer too small */\n    free (rdc.buf);\n    update_cached_response (NULL);\n    return;\n  }\n  memcpy (rdc.buf, INDEX_PAGE_FOOTER, len);\n  rdc.off += len;\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response =\n    MHD_create_response_from_buffer_with_free_callback (rdc.off,\n                                                        rdc.buf,\n                                                        &free);\n  mark_as_html (response);\n#ifdef FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n                                  MHD_HTTP_HEADER_CONNECTION,\n                                  \"close\");\n#endif\n  update_cached_response (response);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'update_directory': {'callees': ['update_cached_response', 'list_directory', 'MHD_create_response_from_buffer_with_free_callback', 'mark_as_html'], 'callers': ['generate_page', 'main']}, 'update_cached_response': {'callees': ['MHD_destroy_response'], 'callers': ['update_directory', 'main']}, 'list_directory': {'callees': [], 'callers': ['update_directory']}, 'MHD_create_response_from_buffer_with_free_callback': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['ahc_echo', 'fill_v1_form', 'fill_v1_v2_form', 'update_directory']}, 'mark_as_html': {'callees': ['MHD_add_response_header'], 'callers': ['update_directory', 'main']}, 'generate_page': {'callees': ['MHD_queue_response', 'MHD_create_response_from_fd', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_create_post_processor', 'MHD_post_process', 'MHD_destroy_post_processor', 'update_directory', 'return_directory_response'], 'callers': []}, 'main': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_start_daemon', 'MHD_stop_daemon', 'MHD_destroy_response', 'MHD_get_fdset2', 'MHD_get_timeout64', 'MHD_run', 'MHD_get_daemon_info', 'MHD_get_timeout_i', 'MHD_resume_connection', 'expire_sessions', 'ignore_sigpipe', 'mark_as_html', 'update_directory', 'update_cached_response', 'check_params', 'add_new_users', 'init_rand_data', 'set_self_name', 'process_params', 'check_apply_params', 'init_data', 'run_mhd', 'deinit_data'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct ResponseDataContext",
    "struct MHD_Response",
    "struct Language",
    "languages",
    "categories",
    "INDEX_PAGE_HEADER",
    "INDEX_PAGE_FOOTER",
    "list_directory",
    "MHD_NO",
    "update_cached_response",
    "MHD_create_response_from_buffer_with_free_callback",
    "MHD_create_response_from_buffer_with_free_callback_cls",
    "mark_as_html",
    "MHD_add_response_header",
    "MHD_HTTP_HEADER_CONNECTION"
  ],
  "explanation": "For checking the MISRA rule about language extensions we must inspect not only the target function body but also the declarations/definitions of external symbols it uses, because language extensions (for example GCC __attribute__, __extension__, statement-expressions, asm, typeof, non\u2011standard calling conventions, or non\u2011portable macros) typically appear in those declarations/headers. Each listed symbol is required for the following reason:\n\n- struct ResponseDataContext: needed to see the exact member types (buf, buf_len, off) and any non\u2011standard attributes on the struct or members (e.g. packed, aligned, flexible-array with extensions).\n\n- struct MHD_Response: to verify its definition does not use compiler extensions or non\u2011standard storage/attribute decorations that would make using it an extension.\n\n- struct Language: to confirm field types (dirname, longname) and check for extensions in its declaration (bitfields with non\u2011portable width, attributes, etc.).\n\n- languages (the array): to examine its linkage/initializer (could use non\u2011standard compound literals or GCC extensions) and the type of its elements.\n\n- categories (the array): to inspect its definition/initializer (possible use of non\u2011standard syntax or extensions).\n\n- INDEX_PAGE_HEADER and INDEX_PAGE_FOOTER: macros or constants; macro definitions can hide compiler extensions (stringizing tricks, statement expressions, attribute annotations, use of GCC extension tokens) that would affect whether the code uses extensions.\n\n- list_directory (prototype and definition): to check its signature and any attributes or non\u2011standard calling conventions in its declaration (e.g. function pointer typedefs, attribute extensions) and to confirm its return constants (MHD_NO) are standard values.\n\n- MHD_NO: constant or macro used to compare list_directory result \u2014 its definition could be an enum or macro with extension usage.\n\n- update_cached_response (prototype and definition): to inspect parameter types (pointer to MHD_Response) and whether its declaration uses compiler extensions/attributes that propagate into update_directory usage.\n\n- MHD_create_response_from_buffer_with_free_callback (prototype): critical because it takes a function pointer/free-callback; its declaration may use non\u2011standard calling conventions, typedefs, or attributes (and the call passes &free without a cast), so we must inspect the exact declaration to ensure no extension is used.\n\n- MHD_create_response_from_buffer_with_free_callback_cls: the call graph shows this internal symbol; its presence/definition may reveal wrapper macros or extensions used by the MHD API; inspect it for attributes or extension usage.\n\n- mark_as_html (prototype/definition): may be a macro or inline function that could include compiler extensions (attributes, statement expressions); check its definition.\n\n- MHD_add_response_header (prototype/definition) and MHD_HTTP_HEADER_CONNECTION (macro): header-manipulation API and header-name macro may be defined with non\u2011standard constructs or attributes; the code conditionally calls this and the macro might be a non\u2011standard token.\n\nIn short: inspect the declarations/definitions of all externally referenced types, macros, arrays and functions used by update_directory. Any compiler-specific attributes or non\u2011standard constructs in those symbols' definitions would cause the target code to rely on language extensions; they must be available to the analyzer to determine MISRA compliance."
}