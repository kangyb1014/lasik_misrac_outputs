{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_rq_uname:\n```c\nstatic size_t\nget_rq_uname (const struct MHD_RqDAuth *params,\n              enum MHD_DigestAuthUsernameType uname_type,\n              struct MHD_DigestAuthUsernameInfo *uname_info,\n              uint8_t *buf,\n              size_t buf_size)\n{\n  size_t buf_used;\n\n  buf_used = 0;\n  mhd_assert (get_rq_uname_type (params) == uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type);\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type);\n\n  uname_info->username = NULL;\n  uname_info->username_len = 0;\n  uname_info->userhash_hex = NULL;\n  uname_info->userhash_hex_len = 0;\n  uname_info->userhash_bin = NULL;\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD == uname_type)\n  {\n    uname_info->username = (char *) (buf + buf_used);\n    uname_info->username_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->username);\n    buf_used += uname_info->username_len + 1;\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == uname_type)\n  {\n    size_t res;\n\n    uname_info->userhash_hex = (char *) (buf + buf_used);\n    uname_info->userhash_hex_len =\n      get_rq_param_unquoted_copy_z (&params->username,\n                                    uname_info->userhash_hex);\n    buf_used += uname_info->userhash_hex_len + 1;\n    uname_info->userhash_bin = (uint8_t *) (buf + buf_used);\n    res = MHD_hex_to_bin (uname_info->userhash_hex,\n                          uname_info->userhash_hex_len,\n                          uname_info->userhash_bin);\n    if (res != uname_info->userhash_hex_len / 2)\n    {\n      uname_info->userhash_bin = NULL;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    }\n    else\n    {\n      /* Avoid pointers outside allocated region when the size is zero */\n      if (0 == res)\n        uname_info->userhash_bin = (uint8_t *) uname_info->username;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH;\n      buf_used += res;\n    }\n  }\n  else if (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED == uname_type)\n  {\n    ssize_t res;\n    res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                        params->username_ext.value.len,\n                                        (char *) (buf + buf_used),\n                                        buf_size - buf_used);\n    if (0 > res)\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n    else\n    {\n      uname_info->username = (char *) (buf + buf_used);\n      uname_info->username_len = (size_t) res;\n      uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n      buf_used += uname_info->username_len + 1;\n    }\n  }\n  else\n  {\n    mhd_assert (0);\n    uname_info->uname_type = MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  mhd_assert (buf_size >= buf_used);\n  return buf_used;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function get_rq_uname:\nstatic size_t\nget_rq_param_unquoted_copy_z (const struct MHD_RqDAuthParam *param, char *buf)\n{\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  if (! param->quoted)\n  {\n    memcpy (buf, param->value.str, param->value.len);\n    buf [param->value.len] = 0;\n    return param->value.len;\n  }\n\n  len = MHD_str_unquote (param->value.str, param->value.len, buf);\n  mhd_assert (0 != len);\n  mhd_assert (len < param->value.len);\n  buf[len] = 0;\n  return len;\n}\n...\nsize_t\nMHD_str_unquote (const char *quoted,\n                 size_t quoted_len,\n                 char *result)\n{\n  size_t r;\n  size_t w;\n\n  r = 0;\n  w = 0;\n\n  while (quoted_len > r)\n  {\n    if ('\\\\' == quoted[r])\n    {\n      ++r;\n      if (quoted_len == r)\n        return 0; /* Last backslash is not followed by char to unescape */\n    }\n    result[w++] = quoted[r++];\n  }\n  return w;\n}\n...\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n...\nsize_t\nMHD_str_pct_decode_strict_n_ (const char *pct_encoded,\n                              size_t pct_encoded_len,\n                              char *decoded,\n                              size_t buf_size)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  bool broken;\n  size_t res;\n\n  res = MHD_str_pct_decode_lenient_n_ (pct_encoded, pct_encoded_len, decoded,\n                                       buf_size, &broken);\n  if (broken)\n    return 0;\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  r = 0;\n  w = 0;\n\n  if (buf_size >= pct_encoded_len)\n  {\n    while (r < pct_encoded_len)\n    {\n      const char chr = pct_encoded[r];\n      if ('%' == chr)\n      {\n        if (2 > pct_encoded_len - r)\n          return 0;\n        else\n        {\n          const int h = toxdigitvalue (pct_encoded[++r]);\n          const int l = toxdigitvalue (pct_encoded[++r]);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n            return 0;\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          decoded[w] = (char) out;\n        }\n      }\n      else\n        decoded[w] = chr;\n      ++r;\n      ++w;\n    }\n    return w;\n  }\n\n  while (r < pct_encoded_len)\n  {\n    const char chr = pct_encoded[r];\n    if (w >= buf_size)\n      return 0;\n    if ('%' == chr)\n    {\n      if (2 > pct_encoded_len - r)\n        return 0;\n      else\n      {\n        const int h = toxdigitvalue (pct_encoded[++r]);\n        const int l = toxdigitvalue (pct_encoded[++r]);\n        unsigned char out;\n        if ((0 > h) || (0 > l))\n          return 0;\n        out =\n          (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)));\n        decoded[w] = (char) out;\n      }\n    }\n    else\n      decoded[w] = chr;\n    ++r;\n    ++w;\n  }\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n...\nsize_t\nMHD_hex_to_bin (const char *hex,\n                size_t len,\n                void *bin)\n{\n  uint8_t *const out = (uint8_t *) bin;\n  size_t r;\n  size_t w;\n\n  if (0 == len)\n    return 0;\n  r = 0;\n  w = 0;\n  if (0 != len % 2)\n  {\n    /* Assume the first byte is encoded with single digit */\n    const int l = toxdigitvalue (hex[r++]);\n    if (0 > l)\n      return 0;\n    out[w++] = (uint8_t) ((unsigned int) l);\n  }\n  while (r < len)\n  {\n    const int h = toxdigitvalue (hex[r++]);\n    const int l = toxdigitvalue (hex[r++]);\n    if ((0 > h) || (0 > l))\n      return 0;\n    out[w++] = (uint8_t) ( ((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)) );\n  }\n  mhd_assert (len == r);\n  mhd_assert ((len + 1) / 2 == w);\n  return w;\n}\n...\n_MHD_static_inline int\ntoxdigitvalue (char c)\n{\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n  switch ((unsigned char) c)\n  {\n#if 0 /* Disabled to give the compiler a hint about low probability */\n  case 0x00U:    /* NUL */\n  case 0x01U:    /* SOH */\n  case 0x02U:    /* STX */\n  case 0x03U:    /* ETX */\n  case 0x04U:    /* EOT */\n  case 0x05U:    /* ENQ */\n  case 0x06U:    /* ACK */\n  case 0x07U:    /* BEL */\n  case 0x08U:    /* BS */\n  case 0x09U:    /* HT */\n  case 0x0AU:    /* LF */\n  case 0x0BU:    /* VT */\n  case 0x0CU:    /* FF */\n  case 0x0DU:    /* CR */\n  case 0x0EU:    /* SO */\n  case 0x0FU:    /* SI */\n  case 0x10U:    /* DLE */\n  case 0x11U:    /* DC1 */\n  case 0x12U:    /* DC2 */\n  case 0x13U:    /* DC3 */\n  case 0x14U:    /* DC4 */\n  case 0x15U:    /* NAK */\n  case 0x16U:    /* SYN */\n  case 0x17U:    /* ETB */\n  case 0x18U:    /* CAN */\n  case 0x19U:    /* EM */\n  case 0x1AU:    /* SUB */\n  case 0x1BU:    /* ESC */\n  case 0x1CU:    /* FS */\n  case 0x1DU:    /* GS */\n  case 0x1EU:    /* RS */\n  case 0x1FU:    /* US */\n  case 0x20U:    /* ' ' */\n  case 0x21U:    /* '!' */\n  case 0x22U:    /* '\"' */\n  case 0x23U:    /* '#' */\n  case 0x24U:    /* '$' */\n  case 0x25U:    /* '%' */\n  case 0x26U:    /* '&' */\n  case 0x27U:    /* '\\'' */\n  case 0x28U:    /* '(' */\n  case 0x29U:    /* ')' */\n  case 0x2AU:    /* '*' */\n  case 0x2BU:    /* '+' */\n  case 0x2CU:    /* ',' */\n  case 0x2DU:    /* '-' */\n  case 0x2EU:    /* '.' */\n  case 0x2FU:    /* '/' */\n    return -1;\n#endif\n  case 0x30U: /* '0' */\n    return 0;\n  case 0x31U: /* '1' */\n    return 1;\n  case 0x32U: /* '2' */\n    return 2;\n  case 0x33U: /* '3' */\n    return 3;\n  case 0x34U: /* '4' */\n    return 4;\n  case 0x35U: /* '5' */\n    return 5;\n  case 0x36U: /* '6' */\n    return 6;\n  case 0x37U: /* '7' */\n    return 7;\n  case 0x38U: /* '8' */\n    return 8;\n  case 0x39U: /* '9' */\n    return 9;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x3AU: /* ':' */\n  case 0x3BU: /* ';' */\n  case 0x3CU: /* '<' */\n  case 0x3DU: /* '=' */\n  case 0x3EU: /* '>' */\n  case 0x3FU: /* '?' */\n  case 0x40U: /* '@' */\n    return -1;\n#endif\n  case 0x41U: /* 'A' */\n    return 0xAU;\n  case 0x42U: /* 'B' */\n    return 0xBU;\n  case 0x43U: /* 'C' */\n    return 0xCU;\n  case 0x44U: /* 'D' */\n    return 0xDU;\n  case 0x45U: /* 'E' */\n    return 0xEU;\n  case 0x46U: /* 'F' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x47U: /* 'G' */\n  case 0x48U: /* 'H' */\n  case 0x49U: /* 'I' */\n  case 0x4AU: /* 'J' */\n  case 0x4BU: /* 'K' */\n  case 0x4CU: /* 'L' */\n  case 0x4DU: /* 'M' */\n  case 0x4EU: /* 'N' */\n  case 0x4FU: /* 'O' */\n  case 0x50U: /* 'P' */\n  case 0x51U: /* 'Q' */\n  case 0x52U: /* 'R' */\n  case 0x53U: /* 'S' */\n  case 0x54U: /* 'T' */\n  case 0x55U: /* 'U' */\n  case 0x56U: /* 'V' */\n  case 0x57U: /* 'W' */\n  case 0x58U: /* 'X' */\n  case 0x59U: /* 'Y' */\n  case 0x5AU: /* 'Z' */\n  case 0x5BU: /* '[' */\n  case 0x5CU: /* '\\' */\n  case 0x5DU: /* ']' */\n  case 0x5EU: /* '^' */\n  case 0x5FU: /* '_' */\n  case 0x60U: /* '`' */\n    return -1;\n#endif\n  case 0x61U: /* 'a' */\n    return 0xAU;\n  case 0x62U: /* 'b' */\n    return 0xBU;\n  case 0x63U: /* 'c' */\n    return 0xCU;\n  case 0x64U: /* 'd' */\n    return 0xDU;\n  case 0x65U: /* 'e' */\n    return 0xEU;\n  case 0x66U: /* 'f' */\n    return 0xFU;\n#if 0         /* Disabled to give the compiler a hint about low probability */\n  case 0x67U: /* 'g' */\n  case 0x68U: /* 'h' */\n  case 0x69U: /* 'i' */\n  case 0x6AU: /* 'j' */\n  case 0x6BU: /* 'k' */\n  case 0x6CU: /* 'l' */\n  case 0x6DU: /* 'm' */\n  case 0x6EU: /* 'n' */\n  case 0x6FU: /* 'o' */\n  case 0x70U: /* 'p' */\n  case 0x71U: /* 'q' */\n  case 0x72U: /* 'r' */\n  case 0x73U: /* 's' */\n  case 0x74U: /* 't' */\n  case 0x75U: /* 'u' */\n  case 0x76U: /* 'v' */\n  case 0x77U: /* 'w' */\n  case 0x78U: /* 'x' */\n  case 0x79U: /* 'y' */\n  case 0x7AU: /* 'z' */\n  case 0x7BU: /* '{' */\n  case 0x7CU: /* '|' */\n  case 0x7DU: /* '}' */\n  case 0x7EU: /* '~' */\n  case 0x7FU: /* DEL */\n  case 0x80U: /* EXT */\n  case 0x81U: /* EXT */\n  case 0x82U: /* EXT */\n  case 0x83U: /* EXT */\n  case 0x84U: /* EXT */\n  case 0x85U: /* EXT */\n  case 0x86U: /* EXT */\n  case 0x87U: /* EXT */\n  case 0x88U: /* EXT */\n  case 0x89U: /* EXT */\n  case 0x8AU: /* EXT */\n  case 0x8BU: /* EXT */\n  case 0x8CU: /* EXT */\n  case 0x8DU: /* EXT */\n  case 0x8EU: /* EXT */\n  case 0x8FU: /* EXT */\n  case 0x90U: /* EXT */\n  case 0x91U: /* EXT */\n  case 0x92U: /* EXT */\n  case 0x93U: /* EXT */\n  case 0x94U: /* EXT */\n  case 0x95U: /* EXT */\n  case 0x96U: /* EXT */\n  case 0x97U: /* EXT */\n  case 0x98U: /* EXT */\n  case 0x99U: /* EXT */\n  case 0x9AU: /* EXT */\n  case 0x9BU: /* EXT */\n  case 0x9CU: /* EXT */\n  case 0x9DU: /* EXT */\n  case 0x9EU: /* EXT */\n  case 0x9FU: /* EXT */\n  case 0xA0U: /* EXT */\n  case 0xA1U: /* EXT */\n  case 0xA2U: /* EXT */\n  case 0xA3U: /* EXT */\n  case 0xA4U: /* EXT */\n  case 0xA5U: /* EXT */\n  case 0xA6U: /* EXT */\n  case 0xA7U: /* EXT */\n  case 0xA8U: /* EXT */\n  case 0xA9U: /* EXT */\n  case 0xAAU: /* EXT */\n  case 0xABU: /* EXT */\n  case 0xACU: /* EXT */\n  case 0xADU: /* EXT */\n  case 0xAEU: /* EXT */\n  case 0xAFU: /* EXT */\n  case 0xB0U: /* EXT */\n  case 0xB1U: /* EXT */\n  case 0xB2U: /* EXT */\n  case 0xB3U: /* EXT */\n  case 0xB4U: /* EXT */\n  case 0xB5U: /* EXT */\n  case 0xB6U: /* EXT */\n  case 0xB7U: /* EXT */\n  case 0xB8U: /* EXT */\n  case 0xB9U: /* EXT */\n  case 0xBAU: /* EXT */\n  case 0xBBU: /* EXT */\n  case 0xBCU: /* EXT */\n  case 0xBDU: /* EXT */\n  case 0xBEU: /* EXT */\n  case 0xBFU: /* EXT */\n  case 0xC0U: /* EXT */\n  case 0xC1U: /* EXT */\n  case 0xC2U: /* EXT */\n  case 0xC3U: /* EXT */\n  case 0xC4U: /* EXT */\n  case 0xC5U: /* EXT */\n  case 0xC6U: /* EXT */\n  case 0xC7U: /* EXT */\n  case 0xC8U: /* EXT */\n  case 0xC9U: /* EXT */\n  case 0xCAU: /* EXT */\n  case 0xCBU: /* EXT */\n  case 0xCCU: /* EXT */\n  case 0xCDU: /* EXT */\n  case 0xCEU: /* EXT */\n  case 0xCFU: /* EXT */\n  case 0xD0U: /* EXT */\n  case 0xD1U: /* EXT */\n  case 0xD2U: /* EXT */\n  case 0xD3U: /* EXT */\n  case 0xD4U: /* EXT */\n  case 0xD5U: /* EXT */\n  case 0xD6U: /* EXT */\n  case 0xD7U: /* EXT */\n  case 0xD8U: /* EXT */\n  case 0xD9U: /* EXT */\n  case 0xDAU: /* EXT */\n  case 0xDBU: /* EXT */\n  case 0xDCU: /* EXT */\n  case 0xDDU: /* EXT */\n  case 0xDEU: /* EXT */\n  case 0xDFU: /* EXT */\n  case 0xE0U: /* EXT */\n  case 0xE1U: /* EXT */\n  case 0xE2U: /* EXT */\n  case 0xE3U: /* EXT */\n  case 0xE4U: /* EXT */\n  case 0xE5U: /* EXT */\n  case 0xE6U: /* EXT */\n  case 0xE7U: /* EXT */\n  case 0xE8U: /* EXT */\n  case 0xE9U: /* EXT */\n  case 0xEAU: /* EXT */\n  case 0xEBU: /* EXT */\n  case 0xECU: /* EXT */\n  case 0xEDU: /* EXT */\n  case 0xEEU: /* EXT */\n  case 0xEFU: /* EXT */\n  case 0xF0U: /* EXT */\n  case 0xF1U: /* EXT */\n  case 0xF2U: /* EXT */\n  case 0xF3U: /* EXT */\n  case 0xF4U: /* EXT */\n  case 0xF5U: /* EXT */\n  case 0xF6U: /* EXT */\n  case 0xF7U: /* EXT */\n  case 0xF8U: /* EXT */\n  case 0xF9U: /* EXT */\n  case 0xFAU: /* EXT */\n  case 0xFBU: /* EXT */\n  case 0xFCU: /* EXT */\n  case 0xFDU: /* EXT */\n  case 0xFEU: /* EXT */\n  case 0xFFU: /* EXT */\n    return -1;\n  default:\n    mhd_assert (0);\n    break;  /* Should be unreachable */\n#else\n  default:\n    break;\n#endif\n  }\n  return -1;\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (isasciidigit (c))\n    return (unsigned char) (c - '0');\n  if ( (c >= 'A') && (c <= 'F') )\n    return (unsigned char) (c - 'A' + 10);\n  if ( (c >= 'a') && (c <= 'f') )\n    return (unsigned char) (c - 'a' + 10);\n\n  return -1;\n#endif /* MHD_FAVOR_SMALL_CODE */\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n...\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n...\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return MHD_DAUTH_WRONG_HEADER;\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3)))\n    return MHD_DAUTH_WRONG_ALGO;\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop)))\n    return MHD_DAUTH_WRONG_QOP;\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  else if (params->userhash && (NULL == params->username.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  else if (params->userhash && (digest_size * 2 > params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  else if (params->userhash && (digest_size * 4 < params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n\n  if (NULL == params->realm.value.str)\n    return MHD_DAUTH_WRONG_REALM;\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len))\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->nc.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n      return MHD_DAUTH_WRONG_HEADER;\n\n    if (NULL == params->cnonce.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->cnonce.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len)\n      return MHD_DAUTH_TOO_LARGE;\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str)\n    return MHD_DAUTH_WRONG_URI;\n  else if (0 == params->uri.value.len)\n    return MHD_DAUTH_WRONG_URI;\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len)\n    return MHD_DAUTH_TOO_LARGE;\n\n  if (NULL == params->nonce.value.str)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (0 == params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n\n  if (NULL == params->response.value.str)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (0 == params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (digest_size * 4 < params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  if (! is_param_equal (&params->realm, realm, realm_len))\n    return MHD_DAUTH_WRONG_REALM;\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      if (! is_param_equal (&params->username, username, username_len))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname)\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      if (0 > res)\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size))\n      return MHD_DAUTH_WRONG_USERNAME;\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci))\n      return MHD_DAUTH_NONCE_STALE;    /* Too large 'nc' value */\n  }\n  else\n    nci = 1; /* Force 'nc' value */\n  /* Got 'nc' digital value */\n\n  /* Get 'nonce' with basic checks */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  if ((NONCE_STD_LEN (digest_size) != unquoted.len) ||\n      (! get_nonce_timestamp (unquoted.str, unquoted.len, &nonce_time)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, invalid nonce format.\\n\"));\n#endif\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (1)\n  {\n    uint64_t t;\n\n    t = MHD_monotonic_msec_counter ();\n    /*\n     * First level vetting for the nonce validity: if the timestamp\n     * attached to the nonce exceeds `nonce_timeout', then the nonce is\n     * stale.\n     */\n    if (TRIM_TO_TIMESTAMP (t - nonce_time) > (nonce_timeout * 1000))\n      return MHD_DAUTH_NONCE_STALE; /* too old */\n  }\n  if (1)\n  {\n    enum MHD_CheckNonceNC_ nonce_nc_check;\n    /*\n     * Checking if that combination of nonce and nc is sound\n     * and not a replay attack attempt. Refuse if nonce was not\n     * generated previously.\n     */\n    nonce_nc_check = check_nonce_nc (connection,\n                                     unquoted.str,\n                                     NONCE_STD_LEN (digest_size),\n                                     nonce_time,\n                                     nci);\n    if (MHD_CHECK_NONCENC_STALE == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. If this happens a lot, you should \"\n                     \"probably increase the size of the nonce array.\\n\"));\n      else\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. This is expected when client \" \\\n                     \"uses RFC2069-compatible mode and makes more than one \" \\\n                     \"request.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_STALE;\n    }\n    else if (MHD_CHECK_NONCENC_WRONG == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Received nonce that was not \"\n                   \"generated by MHD. This may indicate an attack attempt.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_WRONG;\n    }\n    mhd_assert (MHD_CHECK_NONCENC_OK == nonce_nc_check);\n  }\n  /* The nonce was generated by MHD, is not stale and nonce-nc combination was\n     not used before */\n\n  /* ** Build H(A2) and check URI match in the header and in the request ** */\n\n  /* Get 'uri' */\n  mhd_assert (! da->hashing);\n  digest_update_str (da, connection->rq.method);\n  digest_update_with_colon (da);\n#if 0\n  /* TODO: add support for \"auth-int\" */\n  digest_update_str (da, hentity);\n  digest_update_with_colon (da);\n#endif\n  unq_res = get_unquoted_param_copy (&params->uri, tmp1, ptmp2, &tmp2_size,\n                                     &unq_copy);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  digest_update (da, unq_copy.str, unq_copy.len);\n  /* The next check will modify copied URI string */\n  if (! check_uri_match (connection, unq_copy.str, unq_copy.len))\n    return MHD_DAUTH_WRONG_URI;\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  /* Skip digest calculation external error check, the next one checks both */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A2) */\n\n  /* ** Build H(A1) ** */\n  if (NULL == userdigest)\n  {\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calc_userdigest (da,\n                     username, username_len,\n                     realm, realm_len,\n                     password,\n                     hash1_bin);\n  }\n  /* TODO: support '-sess' versions */\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A1) */\n\n  /* **  Check 'response' ** */\n\n  mhd_assert (! da->hashing);\n  digest_reset (da);\n  /* Update digest with H(A1) */\n  mhd_assert (sizeof (tmp1) >= (digest_size * 2));\n  if (NULL == userdigest)\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n  else\n    MHD_bin_to_hex (userdigest, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A1) is not needed anymore, reuse the buffer.\n   * Use hash1_bin for the client's 'response' decoded to binary form. */\n  unq_res = get_unquoted_param (&params->response, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  if (digest_size != MHD_hex_to_bin (unquoted.str, unquoted.len, hash1_bin))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  /* Update digest with 'nonce' text value */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    /* Update digest with 'nc' text value */\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'cnonce' value */\n    unq_res = get_unquoted_param (&params->cnonce, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'qop' value */\n    unq_res = get_unquoted_param (&params->qop_raw, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n  }\n  /* Update digest with H(A2) */\n  MHD_bin_to_hex (hash2_bin, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A2) is not needed anymore, reuse the buffer.\n   * Use hash2_bin for the calculated response in binary form */\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 != memcmp (hash1_bin, hash2_bin, digest_size))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  if (MHD_DAUTH_BIND_NONCE_NONE != daemon->dauth_bind_type)\n  {\n    mhd_assert (sizeof(tmp1) >= (NONCE_STD_LEN (digest_size) + 1));\n    /* It was already checked that 'nonce' (including timestamp) was generated\n       by MHD. */\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calculate_nonce (nonce_time,\n                     connection->rq.http_mthd,\n                     connection->rq.method,\n                     daemon->digest_auth_random,\n                     daemon->digest_auth_rand_size,\n                     connection->addr,\n                     (size_t) connection->addr_len,\n                     connection->rq.url,\n                     connection->rq.url_len,\n                     connection->rq.headers_received,\n                     realm,\n                     realm_len,\n                     daemon->dauth_bind_type,\n                     da,\n                     tmp1);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (! is_param_equal (&params->nonce, tmp1,\n                          NONCE_STD_LEN (digest_size)))\n      return MHD_DAUTH_NONCE_OTHER_COND;\n    /* The 'nonce' was generated in the same conditions */\n  }\n\n  return MHD_DAUTH_OK;\n}\n...\nstruct MHD_RqDAuth\n{\n  struct MHD_RqDAuthParam nonce;\n  struct MHD_RqDAuthParam opaque;\n  struct MHD_RqDAuthParam response;\n  struct MHD_RqDAuthParam username;\n  struct MHD_RqDAuthParam username_ext;\n  struct MHD_RqDAuthParam realm;\n  struct MHD_RqDAuthParam uri;\n  /* The raw QOP value, used in the 'response' calculation */\n  struct MHD_RqDAuthParam qop_raw;\n  struct MHD_RqDAuthParam cnonce;\n  struct MHD_RqDAuthParam nc;\n\n  /* Decoded values are below */\n  bool userhash; /* True if 'userhash' parameter has value 'true'. */\n  enum MHD_DigestAuthAlgo3 algo3;\n  enum MHD_DigestAuthQOP qop;\n}\n...\nstruct MHD_DigestAuthUsernameInfo\n{\n  /**\n   * The algorithm as defined by client.\n   * Set automatically to MD5 if not specified by client.\n   * @warning Do not be confused with #MHD_DigestAuthAlgorithm,\n   *          which uses other values!\n   */\n  enum MHD_DigestAuthAlgo3 algo3;\n\n  /**\n   * The type of username used by client.\n   * The 'invalid' and 'missing' types are not used in this structure,\n   * instead NULL is returned by #MHD_digest_auth_get_username3().\n   */\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /**\n   * The username string.\n   * Used only if username type is standard or extended, always NULL otherwise.\n   * If extended notation is used, this string is pct-decoded string\n   * with charset and language tag removed (i.e. it is original username\n   * extracted from the extended notation).\n   * When userhash is used by the client, this member is NULL and\n   * @a userhash_hex and @a userhash_bin are set.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username.\n   * When the @a username is NULL, this member is always zero.\n   */\n  size_t username_len;\n\n  /**\n   * The userhash string.\n   * Valid only if username type is userhash.\n   * This is unqoted string without decoding of the hexadecimal\n   * digits (as provided by the client).\n   * The buffer pointed by the @a userhash_hex becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @sa #MHD_digest_auth_calc_userhash_hex()\n   */\n  char *userhash_hex;\n\n  /**\n   * The length of the @a userhash_hex in characters.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) * 2 characters.\n   * When the @a userhash_hex is NULL, this member is always zero.\n   */\n  size_t userhash_hex_len;\n\n  /**\n   * The userhash decoded to binary form.\n   * Used only if username type is userhash, always NULL otherwise.\n   * When not NULL, this points to binary sequence @a userhash_hex_len /2 bytes\n   * long.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) bytes.\n   * The buffer pointed by the @a userhash_bin becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @warning This is a binary data, no zero termination.\n   * @warning To avoid buffer overruns, always check the size of the data before\n   *          use, because @a userhash_bin can point even to zero-sized\n   *          data.\n   * @sa #MHD_digest_auth_calc_userhash()\n   */\n  uint8_t *userhash_bin;\n}\n...\nenum MHD_DigestAuthUsernameType\n{\n  /**\n   * No username parameter in in Digest Authorization header.\n   * This should be treated as an error.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_MISSING = 0,\n\n  /**\n   * The 'username' parameter is used to specify the username.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD = (1 << 2),\n\n  /**\n   * The username is specified by 'username*' parameter with\n   * the extended notation (see RFC 5987 #section-3.2.1).\n   * The only difference between standard and extended types is\n   * the way how username value is encoded in the header.\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED = (1 << 3),\n\n  /**\n   * The username provided in form of 'userhash' as\n   * specified by RFC 7616 #section-3.4.4.\n   * @sa #MHD_digest_auth_calc_userhash_hex(), #MHD_digest_auth_calc_userhash()\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH = (1 << 1),\n\n  /**\n   * The invalid combination of username parameters are used by client.\n   * Either:\n   * * both 'username' and 'username*' are used\n   * * 'username*' is used with 'userhash=true'\n   * * 'username*' used with invalid extended notation\n   * * 'username' is not hexadecimal string, while 'userhash' set to 'true'\n   */\n  MHD_DIGEST_AUTH_UNAME_TYPE_INVALID = (1 << 0)\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;"
  ],
  "explanation": "I found one use of memcmp that compares two null-terminated strings: 'username' (length obtained via strlen) and 'r_uname' (returned length from get_rq_extended_uname_copy_z which also zero-terminates the buffer). Using memcmp to compare null-terminated strings violates MISRA C 2023 Rule 21.14. Other memcmp usages in the provided code (for example the comparison of hash1_bin and hash2_bin) operate on binary digests with explicit lengths and are not comparisons of null-terminated strings, so they are not subject to Rule 21.14 and do not need investigation for this rule. No other memcmp calls that compare null-terminated strings are present in the supplied code fragments."
}