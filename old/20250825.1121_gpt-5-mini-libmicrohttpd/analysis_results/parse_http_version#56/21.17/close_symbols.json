{
  "user_message": "Target function code is:\n```c\nstatic bool\nparse_http_version (struct MHD_Connection *connection,\n                    const char *http_string,\n                    size_t len)\n{\n  const char *const h = http_string; /**< short alias */\n  mhd_assert (NULL != http_string);\n\n  /* String must start with 'HTTP/d.d', case-sensetive match.\n   * See https://www.rfc-editor.org/rfc/rfc9112#name-http-version */\n  if ((HTTP_VER_LEN != len) ||\n      ('H' != h[0]) || ('T' != h[1]) || ('T' != h[2]) || ('P' != h[3]) ||\n      ('/' != h[4])\n      || ('.' != h[6]) ||\n      (('0' > h[5]) || ('9' < h[5])) ||\n      (('0' > h[7]) || ('9' < h[7])))\n  {\n    connection->rq.http_ver = MHD_HTTP_VER_INVALID;\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_BAD_REQUEST,\n                                    REQUEST_MALFORMED);\n    return false;\n  }\n  if (1 == h[5] - '0')\n  {\n    /* HTTP/1.x */\n    if (1 == h[7] - '0')\n      connection->rq.http_ver = MHD_HTTP_VER_1_1;\n    else if (0 == h[7] - '0')\n      connection->rq.http_ver = MHD_HTTP_VER_1_0;\n    else\n      connection->rq.http_ver = MHD_HTTP_VER_1_2__1_9;\n\n    return true;\n  }\n\n  if (0 == h[5] - '0')\n  {\n    /* Too old major version */\n    connection->rq.http_ver = MHD_HTTP_VER_TOO_OLD;\n    transmit_error_response_static (connection,\n                                    MHD_HTTP_HTTP_VERSION_NOT_SUPPORTED,\n                                    REQ_HTTP_VER_IS_TOO_OLD);\n    return false;\n  }\n\n  connection->rq.http_ver = MHD_HTTP_VER_FUTURE;\n  transmit_error_response_static (connection,\n                                  MHD_HTTP_HTTP_VERSION_NOT_SUPPORTED,\n                                  REQ_HTTP_VER_IS_NOT_SUPPORTED);\n  return false;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'parse_http_version': {'callees': ['transmit_error_response_len'], 'callers': ['get_request_line_inner']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'get_request_line_inner': {'callees': ['connection_close_error', 'transmit_error_response_len', 'parse_http_version', 'parse_http_std_method'], 'callers': ['get_request_line']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HTTP_VER_LEN",
    "mhd_assert",
    "struct MHD_Connection (full definition, including type/size of connection->rq and rq.http_ver)",
    "transmit_error_response_static (implementation) / transmit_error_response_len",
    "MHD_create_response_from_buffer_static (implementation / prototype)",
    "build_header_response (implementation / prototype)",
    "MHD_queue_response (implementation / prototype)",
    "MHD_pool_deallocate (implementation / prototype)",
    "MHD_pool_reset (implementation / prototype)",
    "MHD_destroy_response (implementation / prototype)",
    "connection_close_error (implementation / prototype)",
    "MHD_DLOG (implementation / prototype)"
  ],
  "explanation": "Reason for each symbol:\n\n- HTTP_VER_LEN: parse_http_version compares len against HTTP_VER_LEN before indexing h[0]..h[7]. You must know the exact numeric value to prove the h[] accesses cannot go out-of-bounds (e.g. HTTP_VER_LEN must be 8 for h[0]..h[7] to be safe).\n\n- mhd_assert: ensures http_string is non-NULL at function start; the macro/implementation clarifies whether it can be compiled out or aborts at runtime, which affects whether null-pointer checks are guaranteed.\n\n- struct MHD_Connection (full definition, including connection->rq and rq.http_ver): needed to know what pointers/data the function writes into (connection->rq.http_ver) and whether those writes might alias buffers or trigger further code paths that pass pointers to string.h functions; also to confirm no hidden pointer arithmetic or bounds issues in the structure members.\n\n- transmit_error_response_static / transmit_error_response_len: parse_http_version calls this on error paths. To determine whether the overall call chain violates the string.h rule you must inspect this function for uses of string.h functions and the pointers/lengths it passes to them.\n\n- MHD_create_response_from_buffer_static: often accepts buffer pointers and lengths; its implementation may call memcpy/strlen/etc. You must inspect how buffers/lengths are computed to ensure no out-of-bounds access.\n\n- build_header_response: header building typically concatenates or copies strings; its implementation may call string.h functions (strncpy/strcat/memcpy). You must see what source/destination pointers and lengths it uses.\n\n- MHD_queue_response: may manipulate response buffers and pass them to lower-level functions that use string.h routines; check what pointers/lengths are forwarded.\n\n- MHD_pool_deallocate and MHD_pool_reset: memory-pool operations may reuse or discard buffers; their use can affect lifetimes and valid sizes of buffers passed to string functions in the call chain.\n\n- MHD_destroy_response: deallocation / cleanup may also call string.h functions or release buffers whose sizes/validity must be verified.\n\n- connection_close_error: error-path helper that may format or copy strings (e.g. logging, error messages); inspect for any string.h usages and the source pointers it receives.\n\n- MHD_DLOG: logging/format functions may call string handling functions internally; verify that any pointers/lengths passed to them are valid and not leading to OOB accesses.\n\nIn short: to determine compliance with the MISRA rule you must (1) confirm the numeric value of HTTP_VER_LEN and how len is derived to show h[0]..h[7] are in-bounds, (2) confirm mhd_assert behavior for null checks, (3) inspect the full definition of MHD_Connection for aliasing/lifetimes, and (4) inspect transmit_error_response_static and the listed callee implementations/prototypes because they are called from this function and may use string.h routines on buffers or pointers that could be out-of-bounds."
}