{
  "user_message": "Target function code is:\n```c\nstatic void\nconnection_reset (struct MHD_Connection *connection,\n                  bool reuse)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MHD_Daemon *const d = connection->daemon;\n\n  if (! reuse)\n  {\n    /* Next function will destroy response, notify client,\n     * destroy memory pool, and set connection state to \"CLOSED\" */\n    MHD_connection_close_ (c,\n                           c->stop_with_error ?\n                           MHD_REQUEST_TERMINATED_WITH_ERROR :\n                           MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    c->read_buffer = NULL;\n    c->read_buffer_size = 0;\n    c->read_buffer_offset = 0;\n    c->write_buffer = NULL;\n    c->write_buffer_size = 0;\n    c->write_buffer_send_offset = 0;\n    c->write_buffer_append_offset = 0;\n  }\n  else\n  {\n    /* Reset connection to process the next request */\n    size_t new_read_buf_size;\n    mhd_assert (! c->stop_with_error);\n    mhd_assert (! c->discard_request);\n\n    if ( (NULL != d->notify_completed) &&\n         (c->rq.client_aware) )\n      d->notify_completed (d->notify_completed_cls,\n                           c,\n                           &c->rq.client_context,\n                           MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    c->rq.client_aware = false;\n\n    if (NULL != c->rp.response)\n      MHD_destroy_response (c->rp.response);\n    c->rp.response = NULL;\n\n    c->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n    c->state = MHD_CONNECTION_INIT;\n    c->event_loop_info =\n      (0 == c->read_buffer_offset) ?\n      MHD_EVENT_LOOP_INFO_READ : MHD_EVENT_LOOP_INFO_PROCESS;\n\n    memset (&c->rq, 0, sizeof(c->rq));\n\n    /* iov (if any) will be deallocated by MHD_pool_reset */\n    memset (&c->rp, 0, sizeof(c->rp));\n\n    c->write_buffer = NULL;\n    c->write_buffer_size = 0;\n    c->write_buffer_send_offset = 0;\n    c->write_buffer_append_offset = 0;\n    c->continue_message_write_offset = 0;\n\n    /* Reset the read buffer to the starting size,\n       preserving the bytes we have already read. */\n    new_read_buf_size = c->daemon->pool_size / 2;\n    if (c->read_buffer_offset > new_read_buf_size)\n      new_read_buf_size = c->read_buffer_offset;\n\n    c->read_buffer\n      = MHD_pool_reset (c->pool,\n                        c->read_buffer,\n                        c->read_buffer_offset,\n                        new_read_buf_size);\n    c->read_buffer_size = new_read_buf_size;\n  }\n  c->rq.client_context = NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'connection_reset': {'callees': ['MHD_connection_close_', 'MHD_destroy_response', 'MHD_pool_reset'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_pool_reset': {'callees': [], 'callers': ['transmit_error_response_len', 'connection_reset']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (full definition, including nested rq, rp, pool and all fields accessed)",
    "struct MHD_Daemon (full definition, including notify_completed and its type)",
    "definition of bool (e.g. inclusion/definition from <stdbool.h> or project typedef)",
    "mhd_assert (macro or function definition)",
    "MHD_connection_close_ (prototype and implementation or macro)",
    "MHD_destroy_response (prototype and implementation or macro)",
    "MHD_pool_reset (prototype and implementation or macro body)",
    "definitions of the constants/enums used in the function: MHD_REQUEST_TERMINATED_WITH_ERROR, MHD_REQUEST_TERMINATED_COMPLETED_OK, MHD_CONN_KEEPALIVE_UNKOWN, MHD_CONNECTION_INIT, MHD_EVENT_LOOP_INFO_READ, MHD_EVENT_LOOP_INFO_PROCESS"
  ],
  "explanation": "To decide if this function uses any compiler language extensions you must inspect any symbols whose declarations/definitions could themselves contain extensions or expose non\u2011standard constructs. For each symbol above the reason is:\n\n- struct MHD_Connection (full definition): the structure declaration and its nested types (rq, rp, pool, etc.) may use anonymous structs/unions, GCC/Clang attributes, bit\u2011fields, flexible array members or other extensions; those are not visible from the function body and must be checked in the type definition.\n\n- struct MHD_Daemon (full definition): the daemon struct can contain function pointer types or fields declared with attributes or extension syntax (e.g. __attribute__, unusual calling conventions). The notify_completed member is called here, so its declaration may hide extensions.\n\n- definition of bool: the source uses the identifier bool. You must confirm whether bool comes from standard <stdbool.h> (C99) or from a compiler extension/typedef; if a nonstandard alias/extension is used it would violate the rule.\n\n- mhd_assert (macro or function definition): asserts are often macros that can use statement\u2011expressions, typeof, __extension__ or other compiler extensions. Inspect its definition to ensure it uses only standard C constructs.\n\n- MHD_connection_close_ (prototype/implementation): the called function's declaration or implementation may use attributes (noreturn, format, visibility), inline assembly, builtin intrinsics, statement\u2011expressions or other extensions. Since the target calls it, its declaration may affect whether extension syntax appears in code visible to analysis.\n\n- MHD_destroy_response (prototype/implementation): likewise can be a macro or function using extensions (macros using ({ ... }) or __builtin_*). Its declaration/definition must be checked.\n\n- MHD_pool_reset (prototype/implementation or macro body): this symbol is directly used to reallocate the read buffer and might be implemented as a macro using compiler extensions (statement expressions, typeof, inline assembly) or use nonstandard attributes/types \u2014 inspect its definition.\n\n- definitions of the constants/enums used in the function: numerical constants and enum values referenced here could be declared using nonstandard enum extensions or macros that expand to extension constructs. Verify the enum/macro definitions for use of extension syntax.\n\nChecking these symbols' declarations/definitions will reveal whether any language extensions are used by the target function (directly in its source text or indirectly via types/macros/called functions)."
}