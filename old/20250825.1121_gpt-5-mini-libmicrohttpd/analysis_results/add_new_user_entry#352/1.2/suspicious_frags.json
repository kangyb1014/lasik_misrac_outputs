{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 1.2 is: Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of add_new_user_entry:\n```c\nstatic int\nadd_new_user_entry (const char *const username,\n                    const char *const password,\n                    const char *const realm,\n                    int allow_area_1,\n                    int allow_area_2)\n{\n  struct UserEntry *entry;\n  enum MHD_Result res;\n\n  if ((sizeof(user_ids) / sizeof(user_ids[0])) <= user_ids_used)\n    return 0; /* No more space to add new entry */\n\n  entry = user_ids + user_ids_used;\n\n  entry->username = username;\n  entry->realm = realm;\n\n  res = MHD_YES;\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                         username,\n                                         realm,\n                                         entry->userhash_md5,\n                                         sizeof(entry->userhash_md5));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_MD5,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_md5,\n                                           sizeof(entry->userdigest_md5));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha256,\n                                         sizeof(entry->userhash_sha256));\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA256,\n                                           username,\n                                           realm,\n                                           password,\n                                           entry->userdigest_sha256,\n                                           sizeof(entry->userdigest_sha256));\n\n  if (MHD_NO != res)\n    res = MHD_digest_auth_calc_userhash (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                         username,\n                                         realm,\n                                         entry->userhash_sha512_256,\n                                         sizeof(entry->userhash_sha512_256));\n  if (MHD_NO != res)\n    res =\n      MHD_digest_auth_calc_userdigest (MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n                                       username,\n                                       realm,\n                                       password,\n                                       entry->userdigest_sha512_256,\n                                       sizeof(entry->userdigest_sha512_256));\n\n  if (MHD_NO == res)\n    return 0; /* Failure exit point */\n\n  entry->allow_area_1 = allow_area_1;\n  entry->allow_area_2 = allow_area_2;\n\n  user_ids_used++;\n\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function add_new_user_entry:\nstruct UserEntry\n{\n  /**\n   * The username.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *username;\n#if 0 /* Disabled code */\n  /* The cleartext password is not stored in the database.\n     The more secure \"userdigest\" is used instead. */\n  /**\n   * The password.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *password;\n#endif /* Disabled code */\n  /**\n   * The realm for this entry.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *realm;\n\n  /**\n   * The MD5 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_md5[MHD_MD5_DIGEST_SIZE];\n  /**\n   * The MD5 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_md5[MHD_MD5_DIGEST_SIZE];\n\n  /**\n   * The SHA-256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha256[MHD_SHA256_DIGEST_SIZE];\n  /**\n   * The SHA-256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha256[MHD_SHA256_DIGEST_SIZE];\n\n  /**\n   * The SHA-512/256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n  /**\n   * The SHA-512/256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n\n  /**\n   * User has access to \"area 1\" if non-zero\n   */\n  int allow_area_1;\n\n  /**\n   * User has access to \"area 2\" if non-zero\n   */\n  int allow_area_2;\n}\n...\nstatic struct UserEntry user_ids[2]\n...\nstatic size_t user_ids_used = 0\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I reviewed the function add_new_user_entry and the related struct and globals for use of compiler language extensions (e.g. GNU __attribute__, statement expressions ({ ... }), typeof, __asm__, nested functions, zero-length arrays, GCC/MSVC specific keywords like __inline or __fastcall, anonymous structures/unions as a compiler extension, designated initializer extensions, or other documented compiler extensions). None of those constructs appear in the provided code. Specific notes:\n\n- Pointer qualifiers (const char *const) are standard C, not a compiler extension.\n- The #if 0 / #endif disabled code is a standard preprocessor feature.\n- Use of fixed-size arrays (uint8_t userhash_md5[...]) and stdint types (uint8_t) are part of standard C (C99 and later), not compiler-specific extensions.\n- The expressions and control flow (if, assignments, pointer arithmetic, sizeof, comparisons) are all standard C.\n- Macros/constants and external library function calls (MHD_YES, MHD_NO, MHD_digest_auth_calc_userhash, etc.) may be library-specific but are not compiler language extensions themselves; their definitions would need review only if they use compiler-specific extension syntax, which is not shown here.\n- The odd-looking \"return ! 0;\" is valid standard C (returns 1) and is not a compiler extension.\n\nBecause no compiler-specific extension keywords or nonstandard language constructs are present in the supplied fragments, there are no code fragments to flag for investigation under MISRA C 2023 Rule 1.2."
}