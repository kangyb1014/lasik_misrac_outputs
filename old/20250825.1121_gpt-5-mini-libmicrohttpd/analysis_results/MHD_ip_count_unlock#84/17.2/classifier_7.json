{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_ip_count_unlock:\n```c\nstatic void\nMHD_ip_count_unlock (struct MHD_Daemon *daemon)\n{\n  mhd_assert (NULL == daemon->master);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->per_ip_connection_mutex);\n#else\n  (void) daemon;\n#endif\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_ip_count_unlock:\n#define MHD_mutex_unlock_chk_(pmutex) do{if(!MHD_mutex_unlock_(pmutex))MHD_PANIC(_(\"Failed to unlock mutex.\\n\"));\\\n}while(0)\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n...\nstatic void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n                              &daemon->per_ip_connection_count,\n                              &MHD_ip_addr_compare)))\n  {\n    /* Something's wrong if we couldn't find an IP address\n     * that was previously added */\n    MHD_PANIC (_ (\"Failed to find previously-added IP address.\\n\"));\n  }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n  {\n    MHD_PANIC (_ (\"Previously-added IP address had counter of zero.\\n\"));\n  }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n  {\n    tdelete (found_key,\n             &daemon->per_ip_connection_count,\n             &MHD_ip_addr_compare);\n    MHD_ip_count_unlock (daemon);\n    free (found_key);\n  }\n  else\n    MHD_ip_count_unlock (daemon);\n}\n...\nstatic void\nMHD_ip_count_lock (struct MHD_Daemon *daemon)\n{\n  mhd_assert (NULL == daemon->master);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->per_ip_connection_mutex);\n#else\n  (void) daemon;\n#endif\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: MHD_ip_limit_add does not call itself directly or indirectly. It calls MHD_get_master, MHD_ip_addr_to_key, MHD_ip_count_lock, tsearch, and MHD_ip_count_unlock (and via macros the mutex lock/unlock helpers), none of which call MHD_ip_limit_add. There is no direct recursion or mutual recursion involving MHD_ip_limit_add in the provided code."
}