{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of pre_send_setopt:\n```c\nstatic void\npre_send_setopt (struct MHD_Connection *connection,\n                 bool plain_send,\n                 bool push_data)\n{\n  /* Try to buffer data if not sending the final piece.\n   * Final piece is indicated by push_data == true. */\n  const bool buffer_data = (! push_data);\n\n  if (_MHD_YES == connection->is_nonip)\n    return;\n  /* The goal is to minimise the total number of additional sys-calls\n   * before and after send().\n   * The following tricky (over-)complicated algorithm typically use zero,\n   * one or two additional sys-calls (depending on OS) for each response. */\n\n  if (buffer_data)\n  {\n    /* Need to buffer data if possible. */\n#ifdef MHD_USE_MSG_MORE\n    if (plain_send)\n      return; /* Data is buffered by send() with MSG_MORE flag.\n               * No need to check or change anything. */\n#else  /* ! MHD_USE_MSG_MORE */\n    (void) plain_send; /* Mute compiler warning. */\n#endif /* ! MHD_USE_MSG_MORE */\n\n#ifdef MHD_TCP_CORK_NOPUSH\n    if (_MHD_ON == connection->sk_corked)\n      return; /* The connection was already corked. */\n\n    if (MHD_connection_set_cork_state_ (connection, true))\n      return; /* The connection has been corked. */\n\n    /* Failed to cork the connection.\n     * Really unlikely to happen on TCP connections. */\n#endif /* MHD_TCP_CORK_NOPUSH */\n    if (_MHD_OFF == connection->sk_nodelay)\n      return; /* TCP_NODELAY was not set for the socket.\n               * Nagle's algorithm will buffer some data. */\n\n    /* Try to reset TCP_NODELAY state for the socket.\n     * Ignore possible error as no other options exist to\n     * buffer data. */\n    MHD_connection_set_nodelay_state_ (connection, false);\n    /* TCP_NODELAY has been (hopefully) reset for the socket.\n     * Nagle's algorithm will buffer some data. */\n    return;\n  }\n\n  /* Need to push data after send() */\n  /* If additional sys-call is required prefer to make it after the send()\n   * as the next send() may consume only part of the prepared data and\n   * more send() calls will be used. */\n#ifdef MHD_TCP_CORK_NOPUSH\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n#ifdef _MHD_CORK_RESET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by uncorking socket regardless of\n   * cork state before. */\n  /* This is typical for Linux, no other kernel with\n   * such behavior are known so far. */\n\n  /* No need to check the current state of TCP_CORK / TCP_NOPUSH\n   * as reset of cork will push the data anyway. */\n  return; /* Data may be pushed by resetting of\n           * TCP_CORK / TCP_NOPUSH after send() */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n  /* Reset of TCP_CORK / TCP_NOPUSH will push the data\n   * only if socket is corked. */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by setting TCP_NODELAY regardless\n   * of TCP_NODDELAY or corking state before. */\n\n  /* Dead code currently, no known kernels with such behavior. */\n  return; /* Data may be pushed by setting of TCP_NODELAY after send().\n             No need to make extra sys-calls before send().*/\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* Setting of TCP_NODELAY will push the data only if\n   * both TCP_NODELAY and TCP_CORK / TCP_NOPUSH were not set. */\n\n  /* Data can be pushed immediately by uncorking socket if\n   * socket was corked before or by setting TCP_NODELAY if\n   * socket was not corked and TCP_NODELAY was not set before. */\n\n  /* Dead code currently as Linux is the only kernel that push\n   * data by setting of TCP_NODELAY and Linux push data always. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n  /* Data can be pushed immediately by uncorking socket or\n   * can be pushed by send() on uncorked socket if\n   * TCP_NODELAY was set *before*. */\n\n  /* This is typical FreeBSD behavior. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n  if (_MHD_ON == connection->sk_corked)\n    return; /* Socket is corked. Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  else if (_MHD_OFF == connection->sk_corked)\n  {\n    /* The socket is not corked. */\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* TCP_NODELAY was already set,\n               * data will be pushed automatically by the next send() */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n    else if (_MHD_UNKNOWN == connection->sk_nodelay)\n    {\n      /* Setting TCP_NODELAY may push data.\n       * Cork socket here and uncork after send(). */\n      if (MHD_connection_set_cork_state_ (connection, true))\n        return; /* The connection has been corked.\n                 * Data can be pushed by resetting of\n                 * TCP_CORK / TCP_NOPUSH after send() */\n      else\n      {\n        /* The socket cannot be corked.\n         * Really unlikely to happen on TCP connections */\n        /* Have to set TCP_NODELAY.\n         * If TCP_NODELAY real system state was OFF then\n         * already buffered data may be pushed here, but this is unlikely\n         * to happen as it is only a backup solution when corking has failed.\n         * Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_nodelay_state_ (connection, true);\n        /* TCP_NODELAY has been (hopefully) set for the socket.\n         * The data will be pushed by the next send(). */\n        return;\n      }\n    }\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n    else\n    {\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n      /* TCP_NODELAY was switched off and\n       * the socket is not corked. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n      /* Socket is not corked and TCP_NODELAY was not set or unknown. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n      /* At least one additional sys-call is required. */\n      /* Setting TCP_NODELAY is optimal here as data will be pushed\n       * automatically by the next send() and no additional\n       * sys-call are needed after the send(). */\n      if (MHD_connection_set_nodelay_state_ (connection, true))\n        return;\n      else\n      {\n        /* Failed to set TCP_NODELAY for the socket.\n         * Really unlikely to happen on TCP connections. */\n        /* Cork the socket here and make additional sys-call\n         * to uncork the socket after send(). */\n        /* Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_cork_state_ (connection, true);\n        /* The connection has been (hopefully) corked.\n         * Data can be pushed by resetting of TCP_CORK / TCP_NOPUSH\n         * after send() */\n        return;\n      }\n    }\n  }\n  /* Corked state is unknown. Need to make sys-call here otherwise\n   * data may not be pushed. */\n  if (MHD_connection_set_cork_state_ (connection, true))\n    return; /* The connection has been corked.\n             * Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  /* The socket cannot be corked.\n   * Really unlikely to happen on TCP connections */\n  if (_MHD_ON == connection->sk_nodelay)\n    return; /* TCP_NODELAY was already set,\n             * data will be pushed by the next send() */\n  /* Have to set TCP_NODELAY. */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* If TCP_NODELAY state was unknown (external connection) then\n   * already buffered data may be pushed here, but this is unlikely\n   * to happen as it is only a backup solution when corking has failed. */\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n  /* Ignore possible error here as no other options exist to\n   * push data. */\n  MHD_connection_set_nodelay_state_ (connection, true);\n  /* TCP_NODELAY has been (hopefully) set for the socket.\n   * The data will be pushed by the next send(). */\n  return;\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA */\n  /* Neither uncorking the socket or setting TCP_NODELAY\n   * push the data immediately. */\n  /* The only way to push the data is to use send() on uncorked\n   * socket with TCP_NODELAY switched on . */\n\n  /* This is a typical *BSD (except FreeBSD) and Darwin behavior. */\n\n  /* Uncork socket if socket wasn't uncorked. */\n  if (_MHD_OFF != connection->sk_corked)\n    MHD_connection_set_cork_state_ (connection, false);\n\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n\n  return;\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA */\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  /* Buffering of data is controlled only by\n   * Nagel's algorithm. */\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function pre_send_setopt:\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n...\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\n#define MHD_USE_MSG_MORE 1\n...\n#define MHD_TCP_CORK_NOPUSH TCP_CORK\n...\n#define _MHD_CORK_RESET_PUSH_DATA 1\n...\n#define _MHD_CORK_RESET_PUSH_DATA_ALWAYS 1\n...\n#define _MHD_NODELAY_SET_PUSH_DATA_ALWAYS 1\n...\n#define _MHD_NODELAY_SET_PUSH_DATA 1\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the provided function pre_send_setopt and the related code in the additional code block (MHD_connection_set_cork_state_, MHD_connection_set_nodelay_state_, struct MHD_Connection and the defined macros). There are no calls to memcmp, no macros that expand to memcmp, and no wrapper functions present that appear to perform a memcmp-based comparison of null-terminated strings. All string handling in the snippets is limited to string literals in logging calls (no comparisons), and socket option handling uses setsockopt and error-reporting helpers. Therefore there are no code fragments in the supplied code that need investigation for MISRA C 2023 Rule 21.14 (use of memcmp to compare null-terminated strings). If you have other source files or additional code that might contain memcmp usage, please provide them for review."
}