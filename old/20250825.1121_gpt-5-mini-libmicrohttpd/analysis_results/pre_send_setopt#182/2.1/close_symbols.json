{
  "user_message": "Target function code is:\n```c\nstatic void\npre_send_setopt (struct MHD_Connection *connection,\n                 bool plain_send,\n                 bool push_data)\n{\n  /* Try to buffer data if not sending the final piece.\n   * Final piece is indicated by push_data == true. */\n  const bool buffer_data = (! push_data);\n\n  if (_MHD_YES == connection->is_nonip)\n    return;\n  /* The goal is to minimise the total number of additional sys-calls\n   * before and after send().\n   * The following tricky (over-)complicated algorithm typically use zero,\n   * one or two additional sys-calls (depending on OS) for each response. */\n\n  if (buffer_data)\n  {\n    /* Need to buffer data if possible. */\n#ifdef MHD_USE_MSG_MORE\n    if (plain_send)\n      return; /* Data is buffered by send() with MSG_MORE flag.\n               * No need to check or change anything. */\n#else  /* ! MHD_USE_MSG_MORE */\n    (void) plain_send; /* Mute compiler warning. */\n#endif /* ! MHD_USE_MSG_MORE */\n\n#ifdef MHD_TCP_CORK_NOPUSH\n    if (_MHD_ON == connection->sk_corked)\n      return; /* The connection was already corked. */\n\n    if (MHD_connection_set_cork_state_ (connection, true))\n      return; /* The connection has been corked. */\n\n    /* Failed to cork the connection.\n     * Really unlikely to happen on TCP connections. */\n#endif /* MHD_TCP_CORK_NOPUSH */\n    if (_MHD_OFF == connection->sk_nodelay)\n      return; /* TCP_NODELAY was not set for the socket.\n               * Nagle's algorithm will buffer some data. */\n\n    /* Try to reset TCP_NODELAY state for the socket.\n     * Ignore possible error as no other options exist to\n     * buffer data. */\n    MHD_connection_set_nodelay_state_ (connection, false);\n    /* TCP_NODELAY has been (hopefully) reset for the socket.\n     * Nagle's algorithm will buffer some data. */\n    return;\n  }\n\n  /* Need to push data after send() */\n  /* If additional sys-call is required prefer to make it after the send()\n   * as the next send() may consume only part of the prepared data and\n   * more send() calls will be used. */\n#ifdef MHD_TCP_CORK_NOPUSH\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n#ifdef _MHD_CORK_RESET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by uncorking socket regardless of\n   * cork state before. */\n  /* This is typical for Linux, no other kernel with\n   * such behavior are known so far. */\n\n  /* No need to check the current state of TCP_CORK / TCP_NOPUSH\n   * as reset of cork will push the data anyway. */\n  return; /* Data may be pushed by resetting of\n           * TCP_CORK / TCP_NOPUSH after send() */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n  /* Reset of TCP_CORK / TCP_NOPUSH will push the data\n   * only if socket is corked. */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by setting TCP_NODELAY regardless\n   * of TCP_NODDELAY or corking state before. */\n\n  /* Dead code currently, no known kernels with such behavior. */\n  return; /* Data may be pushed by setting of TCP_NODELAY after send().\n             No need to make extra sys-calls before send().*/\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* Setting of TCP_NODELAY will push the data only if\n   * both TCP_NODELAY and TCP_CORK / TCP_NOPUSH were not set. */\n\n  /* Data can be pushed immediately by uncorking socket if\n   * socket was corked before or by setting TCP_NODELAY if\n   * socket was not corked and TCP_NODELAY was not set before. */\n\n  /* Dead code currently as Linux is the only kernel that push\n   * data by setting of TCP_NODELAY and Linux push data always. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n  /* Data can be pushed immediately by uncorking socket or\n   * can be pushed by send() on uncorked socket if\n   * TCP_NODELAY was set *before*. */\n\n  /* This is typical FreeBSD behavior. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n  if (_MHD_ON == connection->sk_corked)\n    return; /* Socket is corked. Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  else if (_MHD_OFF == connection->sk_corked)\n  {\n    /* The socket is not corked. */\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* TCP_NODELAY was already set,\n               * data will be pushed automatically by the next send() */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n    else if (_MHD_UNKNOWN == connection->sk_nodelay)\n    {\n      /* Setting TCP_NODELAY may push data.\n       * Cork socket here and uncork after send(). */\n      if (MHD_connection_set_cork_state_ (connection, true))\n        return; /* The connection has been corked.\n                 * Data can be pushed by resetting of\n                 * TCP_CORK / TCP_NOPUSH after send() */\n      else\n      {\n        /* The socket cannot be corked.\n         * Really unlikely to happen on TCP connections */\n        /* Have to set TCP_NODELAY.\n         * If TCP_NODELAY real system state was OFF then\n         * already buffered data may be pushed here, but this is unlikely\n         * to happen as it is only a backup solution when corking has failed.\n         * Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_nodelay_state_ (connection, true);\n        /* TCP_NODELAY has been (hopefully) set for the socket.\n         * The data will be pushed by the next send(). */\n        return;\n      }\n    }\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n    else\n    {\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n      /* TCP_NODELAY was switched off and\n       * the socket is not corked. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n      /* Socket is not corked and TCP_NODELAY was not set or unknown. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n      /* At least one additional sys-call is required. */\n      /* Setting TCP_NODELAY is optimal here as data will be pushed\n       * automatically by the next send() and no additional\n       * sys-call are needed after the send(). */\n      if (MHD_connection_set_nodelay_state_ (connection, true))\n        return;\n      else\n      {\n        /* Failed to set TCP_NODELAY for the socket.\n         * Really unlikely to happen on TCP connections. */\n        /* Cork the socket here and make additional sys-call\n         * to uncork the socket after send(). */\n        /* Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_cork_state_ (connection, true);\n        /* The connection has been (hopefully) corked.\n         * Data can be pushed by resetting of TCP_CORK / TCP_NOPUSH\n         * after send() */\n        return;\n      }\n    }\n  }\n  /* Corked state is unknown. Need to make sys-call here otherwise\n   * data may not be pushed. */\n  if (MHD_connection_set_cork_state_ (connection, true))\n    return; /* The connection has been corked.\n             * Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  /* The socket cannot be corked.\n   * Really unlikely to happen on TCP connections */\n  if (_MHD_ON == connection->sk_nodelay)\n    return; /* TCP_NODELAY was already set,\n             * data will be pushed by the next send() */\n  /* Have to set TCP_NODELAY. */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* If TCP_NODELAY state was unknown (external connection) then\n   * already buffered data may be pushed here, but this is unlikely\n   * to happen as it is only a backup solution when corking has failed. */\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n  /* Ignore possible error here as no other options exist to\n   * push data. */\n  MHD_connection_set_nodelay_state_ (connection, true);\n  /* TCP_NODELAY has been (hopefully) set for the socket.\n   * The data will be pushed by the next send(). */\n  return;\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA */\n  /* Neither uncorking the socket or setting TCP_NODELAY\n   * push the data immediately. */\n  /* The only way to push the data is to use send() on uncorked\n   * socket with TCP_NODELAY switched on . */\n\n  /* This is a typical *BSD (except FreeBSD) and Darwin behavior. */\n\n  /* Uncork socket if socket wasn't uncorked. */\n  if (_MHD_OFF != connection->sk_corked)\n    MHD_connection_set_cork_state_ (connection, false);\n\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n\n  return;\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA */\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  /* Buffering of data is controlled only by\n   * Nagel's algorithm. */\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'MHD_send_sendfile_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_USE_MSG_MORE",
    "MHD_TCP_CORK_NOPUSH",
    "_MHD_CORK_RESET_PUSH_DATA",
    "_MHD_CORK_RESET_PUSH_DATA_ALWAYS",
    "_MHD_NODELAY_SET_PUSH_DATA_ALWAYS",
    "_MHD_NODELAY_SET_PUSH_DATA",
    "_MHD_YES",
    "_MHD_ON",
    "_MHD_OFF",
    "_MHD_UNKNOWN",
    "struct MHD_Connection (fields: is_nonip, sk_corked, sk_nodelay)",
    "MHD_connection_set_cork_state_",
    "MHD_connection_set_nodelay_state_"
  ],
  "explanation": "To determine whether any portions of pre_send_setopt are unreachable you must know both which conditional compilation branches are present and the concrete values/semantics of the runtime symbols tested in the function. Each listed symbol is required for the following reasons:\n\n- MHD_USE_MSG_MORE: Controls the presence of the MSG_MORE path. If defined the early-return when plain_send==true exists; if not defined that code is absent. This decides whether the plain_send branch is reachable/compiled.\n\n- MHD_TCP_CORK_NOPUSH: Controls whether virtually the whole push-vs-buffer logic (cork/nodelay branches) is compiled. If undefined, large blocks are not present and many branches become unreachable at compile time.\n\n- _MHD_CORK_RESET_PUSH_DATA, _MHD_CORK_RESET_PUSH_DATA_ALWAYS, _MHD_NODELAY_SET_PUSH_DATA_ALWAYS, _MHD_NODELAY_SET_PUSH_DATA: These configuration macros select mutually exclusive strategies and enable/disable inner branches. Knowing which of these are defined is necessary to know which code blocks are compiled in and which are dead by preprocessor.\n\n- _MHD_YES: Value compared to connection->is_nonip at function start. Knowing its definition (value) and the possible values of is_nonip is needed to determine if the initial return is a constant/always-taken or not.\n\n- _MHD_ON, _MHD_OFF, _MHD_UNKNOWN: The function tests connection->sk_corked and connection->sk_nodelay against these constants in many places. To determine reachability of those branches you must know the concrete set of possible values for these fields and the numeric values (or enums) of these macros.\n\n- struct MHD_Connection (fields: is_nonip, sk_corked, sk_nodelay): The function reads these fields; their types, value ranges and initialization rules (e.g. whether is_nonip/sk_* can legally have only a subset of the symbolic constants) are required to decide if a particular branch or case can ever be reached at runtime.\n\n- MHD_connection_set_cork_state_: The function calls this and branches on its return value. You need its prototype and semantic contract (return type and meaning: which return indicates success/true) and whether it can fail deterministically for certain socket types to know if subsequent code after the call is reachable.\n\n- MHD_connection_set_nodelay_state_: Same as above: the function branches on the return value of this call or relies on it having side effects; you need its return semantics to assess whether following code/path can be executed.\n\nWith the above compile-time macro definitions and the runtime value domains/semantics for the connection fields and the two helper functions, an analyzer can determine which code blocks are never compiled in or are provably unreachable at runtime (and so assess compliance with the MISRA rule forbidding unreachable code)."
}