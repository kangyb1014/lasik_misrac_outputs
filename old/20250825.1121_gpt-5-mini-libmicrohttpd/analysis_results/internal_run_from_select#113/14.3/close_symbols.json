{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set,\n                          int fd_setsize)\n{\n  MHD_socket ds;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  mhd_assert (0 < fd_setsize);\n  (void) fd_setsize; /* Mute compiler warning */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize; /* Mute compiler warning */\n  mhd_assert (((int) FD_SETSIZE) <= fd_setsize);\n  fd_setsize = FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  { /* Have ITC */\n    bool need_to_clear_itc = true; /* ITC is always non-blocking, it is safe to clear even if ITC not activated */\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (MHD_itc_r_fd_ (daemon->itc),\n                                         NULL, fd_setsize))\n      need_to_clear_itc = FD_ISSET (MHD_itc_r_fd_ (daemon->itc), \\\n                                    (fd_set *) _MHD_DROP_CONST (read_fd_set)); /* Skip clearing, if not needed */\n    if (need_to_clear_itc)\n      MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  /* select connection thread handling type */\n  ds = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ds) &&\n       (! daemon->was_quiesced) )\n  {\n    bool need_to_accept;\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (ds, NULL, fd_setsize))\n      need_to_accept = FD_ISSET (ds,\n                                 (fd_set *) _MHD_DROP_CONST (read_fd_set));\n    else                                       /* Cannot check whether new connection are pending */\n      need_to_accept = daemon->listen_nonblk;  /* Try to accept if non-blocking */\n\n    if (need_to_accept)\n      (void) MHD_accept_connection (daemon);\n  }\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* do not have a thread per connection, process all connections now */\n    struct MHD_Connection *pos;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      MHD_socket cs;\n      bool r_ready;\n      bool w_ready;\n      bool has_err;\n\n      cs = pos->socket_fd;\n      if (MHD_INVALID_SOCKET == cs)\n        continue;\n\n      if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (cs, NULL, fd_setsize))\n      {\n        r_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (read_fd_set));\n        w_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (write_fd_set));\n        has_err = (NULL != except_fd_set) &&\n                  FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (except_fd_set));\n      }\n      else\n      { /* Cannot check the real readiness */\n        r_ready = pos->sk_nonblck;\n        w_ready = r_ready;\n        has_err = false;\n      }\n      call_handlers (pos,\n                     r_ready,\n                     w_ready,\n                     has_err);\n    }\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    urhn = urh->prev;\n    /* update urh state based on select() output */\n    urh_from_fdset (urh,\n                    read_fd_set,\n                    write_fd_set,\n                    except_fd_set,\n                    fd_setsize);\n    /* call generic forwarding function for passing data */\n    process_urh (urh);\n    /* Finished forwarding? */\n    if ( (0 == urh->in_buffer_size) &&\n         (0 == urh->out_buffer_size) &&\n         (0 == urh->in_buffer_used) &&\n         (0 == urh->out_buffer_used) )\n    {\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection (urh->connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'new_connections_list_process_': {'callees': ['__builtin_unreachable', 'new_connection_process_', 'MHD_DLOG'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}, 'MHD_cleanup_connections': {'callees': ['__builtin_unreachable', 'cleanup_upgraded_connection', 'MHD_pool_destroy', 'MHD_ip_limit_del', 'MHD_destroy_response'], 'callers': ['MHD_add_connection', 'internal_run_from_select', 'MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread', 'close_all_connections', 'MHD_get_daemon_info']}, 'MHD_run_from_select2': {'callees': ['MHD_DLOG', 'MHD_epoll', 'MHD_cleanup_connections', 'resume_suspended_connections', 'internal_run_from_select'], 'callers': ['MHD_run_from_select']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "MHD_USE_SELECT_INTERNALLY",
    "MHD_thread_handle_ID_is_valid_ID_",
    "MHD_thread_handle_ID_is_current_thread_",
    "mhd_assert",
    "MHD_ITC_IS_VALID_",
    "MHD_itc_r_fd_",
    "MHD_itc_clear_",
    "MHD_SCKT_FD_FITS_FDSET_SETSIZE_",
    "fd_set (type)",
    "FD_ISSET",
    "FD_SETSIZE",
    "_MHD_DROP_CONST",
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "MHD_INVALID_SOCKET",
    "typedef MHD_socket",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "struct MHD_Connection"
  ],
  "explanation": "For checking whether any controlling expression in internal_run_from_select is (compile-time) invariant you must know the definitions/semantics of the macros, fields and functions used in its conditionals. Each listed symbol is needed for the reasons below:\n\n- struct MHD_Daemon\n  - Provides the declarations of the fields referenced in conditionals (options, tid, itc, data_already_pending, have_new, listen_fd, was_quiesced, listen_nonblk, connections_tail, urh_tail). Knowing whether any of these fields are const or compile\u2011time fixed is required to determine if a condition is invariant.\n\n- MHD_USE_SELECT_INTERNALLY\n  - Flag tested in (daemon->options & MHD_USE_SELECT_INTERNALLY). You must know if this macro is a constant bitmask and whether daemon->options can be compile\u2011time constant to decide invariance.\n\n- MHD_thread_handle_ID_is_valid_ID_\n  - Used in mhd_assert(...) and affects those controlling expressions; need its definition to see if it is a macro constant or a runtime check.\n\n- MHD_thread_handle_ID_is_current_thread_\n  - Same as above \u2014 used in mhd_assert controls; must know whether it can be resolved at compile time.\n\n- mhd_assert\n  - The assertion macro may expand to nothing in non\u2011debug builds. Whether the controlling expression persists or is removed depends on mhd_assert expansion; therefore its definition is required to decide if an asserted condition is an active controlling expression.\n\n- MHD_ITC_IS_VALID_\n  - Used in the if (MHD_ITC_IS_VALID_(daemon->itc)) branch. Need its definition to know if it is a compile\u2011time constant or runtime test.\n\n- MHD_itc_r_fd_\n  - Returns the ITC read FD used in FD_ISSET tests. If this expands to a constant FD or inlined constant it could make the FD_ISSET check invariant; definition is needed.\n\n- MHD_itc_clear_\n  - Called when ITC present; not itself a controlling expression but relevant to semantics of the ITC test (knowing whether ITC is always valid/invariant requires it).\n\n- MHD_SCKT_FD_FITS_FDSET_SETSIZE_\n  - This macro/function guards many FD_ISSET calls. Its expansion determines whether the code takes the FD_ISSET path or the fallback (which uses stored boolean flags). If this macro is a compile\u2011time predicate then surrounding conditionals could be invariant.\n\n- fd_set (type) and FD_ISSET\n  - FD_ISSET is used extensively in readiness tests. You must know FD_ISSET semantics and whether its arguments can be resolved at compile time (and whether FD_ISSET is a macro that could be constant for some sockets).\n\n- FD_SETSIZE\n  - Used in assertions and in the HAS_FD_SETSIZE_OVERRIDABLE block to force fd_setsize = FD_SETSIZE. If FD_SETSIZE is a compile\u2011time constant (it normally is), that affects whether the FD_SETSIZE <= fd_setsize assertion or subsequent branches are invariant.\n\n- _MHD_DROP_CONST\n  - Casting macro used when passing fd_set pointers to FD_ISSET; its definition is needed to ensure it does not change semantics of the conditional (e.g., remove constness in a way that alters compile\u2011time evaluation).\n\n- HAS_FD_SETSIZE_OVERRIDABLE\n  - The #ifndef/#ifdef around FD_SETSIZE handling can alter control flow at compile time. Whether this macro is defined affects invariance of the FD_SETSIZE-related assertions and assignment.\n\n- MHD_INVALID_SOCKET\n  - Constant used to test if a socket is invalid: (MHD_INVALID_SOCKET != ds). Need its value/type to decide if that comparison can be constant in some builds.\n\n- typedef MHD_socket\n  - Type of socket variables used in comparisons and FD_ISSET. Its definition may affect whether comparisons or macros fold to constants.\n\n- MHD_D_IS_USING_THREAD_PER_CONN_\n  - Macro/function that selects the big connection\u2011processing branch. If this is a compile\u2011time constant then the entire branch selection becomes invariant.\n\n- struct MHD_Connection\n  - Definition is required to know whether fields referenced in conditionals (socket_fd, sk_nonblck, prev) are compile\u2011time fixed or mutable, and whether the loop for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev) could be invariant (e.g., empty list known at compile time).\n\nNote: functions that are merely called when a condition is true (new_connections_list_process_, MHD_accept_connection, call_handlers, MHD_cleanup_connections) are not required to decide whether the controlling expressions themselves are invariant; only the macros, types, fields and helper predicates used in the control expressions need to be known. The above symbols are the minimal set needed to determine if any controlling expression in internal_run_from_select is a compile\u2011time invariant (and thus potentially violates the MISRA rule)."
}