{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set,\n                          int fd_setsize)\n{\n  MHD_socket ds;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  mhd_assert (0 < fd_setsize);\n  (void) fd_setsize; /* Mute compiler warning */\n#ifndef HAS_FD_SETSIZE_OVERRIDABLE\n  (void) fd_setsize; /* Mute compiler warning */\n  mhd_assert (((int) FD_SETSIZE) <= fd_setsize);\n  fd_setsize = FD_SETSIZE; /* Help compiler to optimise */\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  { /* Have ITC */\n    bool need_to_clear_itc = true; /* ITC is always non-blocking, it is safe to clear even if ITC not activated */\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (MHD_itc_r_fd_ (daemon->itc),\n                                         NULL, fd_setsize))\n      need_to_clear_itc = FD_ISSET (MHD_itc_r_fd_ (daemon->itc), \\\n                                    (fd_set *) _MHD_DROP_CONST (read_fd_set)); /* Skip clearing, if not needed */\n    if (need_to_clear_itc)\n      MHD_itc_clear_ (daemon->itc);\n  }\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  /* select connection thread handling type */\n  ds = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ds) &&\n       (! daemon->was_quiesced) )\n  {\n    bool need_to_accept;\n    if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (ds, NULL, fd_setsize))\n      need_to_accept = FD_ISSET (ds,\n                                 (fd_set *) _MHD_DROP_CONST (read_fd_set));\n    else                                       /* Cannot check whether new connection are pending */\n      need_to_accept = daemon->listen_nonblk;  /* Try to accept if non-blocking */\n\n    if (need_to_accept)\n      (void) MHD_accept_connection (daemon);\n  }\n\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    /* do not have a thread per connection, process all connections now */\n    struct MHD_Connection *pos;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      MHD_socket cs;\n      bool r_ready;\n      bool w_ready;\n      bool has_err;\n\n      cs = pos->socket_fd;\n      if (MHD_INVALID_SOCKET == cs)\n        continue;\n\n      if (MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (cs, NULL, fd_setsize))\n      {\n        r_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (read_fd_set));\n        w_ready = FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (write_fd_set));\n        has_err = (NULL != except_fd_set) &&\n                  FD_ISSET (cs,\n                            (fd_set *) _MHD_DROP_CONST (except_fd_set));\n      }\n      else\n      { /* Cannot check the real readiness */\n        r_ready = pos->sk_nonblck;\n        w_ready = r_ready;\n        has_err = false;\n      }\n      call_handlers (pos,\n                     r_ready,\n                     w_ready,\n                     has_err);\n    }\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    urhn = urh->prev;\n    /* update urh state based on select() output */\n    urh_from_fdset (urh,\n                    read_fd_set,\n                    write_fd_set,\n                    except_fd_set,\n                    fd_setsize);\n    /* call generic forwarding function for passing data */\n    process_urh (urh);\n    /* Finished forwarding? */\n    if ( (0 == urh->in_buffer_size) &&\n         (0 == urh->out_buffer_size) &&\n         (0 == urh->in_buffer_used) &&\n         (0 == urh->out_buffer_used) )\n    {\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection (urh->connection);\n    }\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'internal_run_from_select': {'callees': ['new_connections_list_process_', 'MHD_accept_connection', 'call_handlers', 'MHD_cleanup_connections'], 'callers': ['MHD_run_from_select2', 'MHD_select']}, 'new_connections_list_process_': {'callees': ['__builtin_unreachable', 'new_connection_process_', 'MHD_DLOG'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'MHD_accept_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'MHD_socket_nonblocking_', 'MHD_socket_noninheritable_', 'internal_add_connection'], 'callers': ['internal_run_from_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll']}, 'call_handlers': {'callees': ['MHD_connection_handle_read', 'MHD_connection_handle_idle', 'MHD_connection_handle_write', 'MHD_connection_close_'], 'callers': ['thread_main_handle_connection', 'internal_run_from_select', 'MHD_poll_all', 'MHD_epoll']}, 'MHD_cleanup_connections': {'callees': ['__builtin_unreachable', 'cleanup_upgraded_connection', 'MHD_pool_destroy', 'MHD_ip_limit_del', 'MHD_destroy_response'], 'callers': ['MHD_add_connection', 'internal_run_from_select', 'MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread', 'close_all_connections', 'MHD_get_daemon_info']}, 'MHD_run_from_select2': {'callees': ['MHD_DLOG', 'MHD_epoll', 'MHD_cleanup_connections', 'resume_suspended_connections', 'internal_run_from_select'], 'callers': ['MHD_run_from_select']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAS_FD_SETSIZE_OVERRIDABLE",
    "FD_SETSIZE",
    "_MHD_DROP_CONST",
    "FD_ISSET",
    "MHD_SCKT_FD_FITS_FDSET_SETSIZE_",
    "fd_set (type/definition)",
    "struct MHD_Daemon (type/definition)"
  ],
  "explanation": "- HAS_FD_SETSIZE_OVERRIDABLE: controls the conditional compilation of the block that assigns to the parameter fd_setsize. To decide if the function can legally modify the parameter you must know whether that block can be compiled in.\n- FD_SETSIZE: the constant value assigned to fd_setsize in the conditional branch; needed to understand the effect and intent of the assignment.\n- _MHD_DROP_CONST: macro used to drop const from the fd_set pointer parameters before passing them on. Need its definition to confirm it only casts and does not perform any assignment to the parameter variables themselves.\n- FD_ISSET: the macro/function used on the (possibly cast) fd_set pointers. Its implementation/signature is needed to determine whether it could modify the fd_set object (allowed) or, in any non-standard case, have side effects that affect the pointer parameters.\n- MHD_SCKT_FD_FITS_FDSET_SETSIZE_: used to decide whether FD_ISSET is called. Its definition may reference fd_setsize; include it to understand whether any of these checks modify parameter values.\n- fd_set (type/definition): to know whether operations (FD_ISSET, etc.) could alter the object or rely on mutable state \u2014 distinguishing modification of the object (allowed) vs modification of the parameter variable (not allowed).\n- struct MHD_Daemon (type/definition): to confirm that writes like daemon->data_already_pending = false and other field assignments modify the object pointed to by the pointer parameter (which MISRA permits) rather than reassigning the parameter variable itself."
}