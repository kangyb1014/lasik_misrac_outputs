{
  "user_message": "An agent A claimed that the following run_mhd code violates the MISRA C 2023 rule 14.2.\n<misra_rule>\nMISRA C 2023 Rule 14.2 is A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<target_code>\nHere is the original code of run_mhd.\n```c\nstatic int\nrun_mhd (void)\n{\n  MHD_AccessHandlerCallback reply_func;\n  struct MHD_Daemon *d;\n  unsigned int use_num_threads;\n  unsigned int flags = MHD_NO_FLAG;\n  struct MHD_OptionItem opt_arr[16];\n  size_t opt_count = 0;\n  const union MHD_DaemonInfo *d_info;\n  const char *poll_mode;\n  uint16_t port;\n\n  if (tool_params.thread_per_conn)\n    use_num_threads = 0;\n  else\n    use_num_threads = get_num_threads ();\n  printf (\"\\n\");\n\n  print_perf_warnings ();\n\n  printf (\"Responses:\\n\");\n  printf (\"  Sharing:   \");\n  if (tool_params.shared)\n  {\n    reply_func = &answer_shared_response;\n    printf (\"pre-generated shared pool with %u objects\\n\", num_resps);\n  }\n  else if (tool_params.single)\n  {\n    reply_func = &answer_single_response;\n    printf (\"single pre-generated reused response object\\n\");\n  }\n  else\n  {\n    /* Unique responses */\n    if (tool_params.empty)\n      reply_func = &answer_unique_empty_response;\n    else if (tool_params.tiny)\n      reply_func = &answer_unique_tiny_response;\n    else\n      reply_func = &answer_unique_dyn_response;\n    printf (\"one-time response object generated for every request\\n\");\n  }\n  printf (\"  Body size: %s\\n\",\n          get_mhd_response_size ());\n\n  flags |= MHD_USE_ERROR_LOG;\n  flags |= MHD_USE_INTERNAL_POLLING_THREAD;\n  if (tool_params.epoll)\n    flags |= MHD_USE_EPOLL;\n  else if (tool_params.poll)\n    flags |= MHD_USE_POLL;\n  else if (tool_params.select)\n    (void) flags; /* No special additional flag */\n  else\n    flags |= MHD_USE_AUTO;\n\n  if (tool_params.thread_per_conn)\n    flags |= MHD_USE_THREAD_PER_CONNECTION;\n\n  if (! tool_params.date_header)\n    flags |= MHD_USE_SUPPRESS_DATE_NO_CLOCK;\n\n  if (0 != tool_params.connections)\n  {\n    opt_arr[opt_count].option = MHD_OPTION_CONNECTION_LIMIT;\n    opt_arr[opt_count].value = (intptr_t) tool_params.connections;\n    opt_arr[opt_count].ptr_value = NULL;\n    ++opt_count;\n  }\n  if (1 < use_num_threads)\n  {\n    opt_arr[opt_count].option = MHD_OPTION_THREAD_POOL_SIZE;\n    opt_arr[opt_count].value = (intptr_t) use_num_threads;\n    opt_arr[opt_count].ptr_value = NULL;\n    ++opt_count;\n  }\n  if (1)\n  {\n    opt_arr[opt_count].option = MHD_OPTION_CONNECTION_TIMEOUT;\n    opt_arr[opt_count].value = (intptr_t) tool_params.timeout;\n    opt_arr[opt_count].ptr_value = NULL;\n    ++opt_count;\n  }\n  if (1)\n  {\n    struct MHD_OptionItem option =\n    { MHD_OPTION_END, 0, NULL };\n    opt_arr[opt_count] = option;\n    if (opt_count >= (sizeof(opt_arr) / sizeof(opt_arr[0])))\n      abort ();\n  }\n  d = MHD_start_daemon (flags, mhd_port, NULL, NULL, reply_func, NULL,\n                        MHD_OPTION_ARRAY, opt_arr, MHD_OPTION_END);\n  if (NULL == d)\n  {\n    fprintf (stderr, \"Error starting MHD daemon.\\n\");\n    return 15;\n  }\n  d_info = MHD_get_daemon_info (d, MHD_DAEMON_INFO_FLAGS);\n  if (NULL == d_info)\n    abort ();\n  flags = (unsigned int) d_info->flags;\n  if (0 != (flags & MHD_USE_POLL))\n    poll_mode = \"poll()\";\n  else if (0 != (flags & MHD_USE_EPOLL))\n    poll_mode = \"epoll\";\n  else\n    poll_mode = \"select()\";\n  d_info = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n  if (NULL == d_info)\n    abort ();\n  port = d_info->port;\n  if (0 == port)\n    fprintf (stderr, \"Cannot detect port number. Consider specifying \"\n             \"port number explicitly.\\n\");\n\n  printf (\"MHD is running.\\n\");\n  printf (\"  Bind port:          %u\\n\", (unsigned int) port);\n  printf (\"  Polling function:   %s\\n\", poll_mode);\n  printf (\"  Threading:          \");\n  if (MHD_USE_THREAD_PER_CONNECTION == (flags & MHD_USE_THREAD_PER_CONNECTION))\n    printf (\"thread per connection\\n\");\n  else if (1 == get_num_threads ())\n    printf (\"one MHD thread\\n\");\n  else\n    printf (\"%u MHD threads in thread pool\\n\", get_num_threads ());\n  printf (\"  Connections limit:  %u\\n\", get_mhd_conn_limit (d));\n  printf (\"  Connection timeout: %u%s\\n\", tool_params.timeout,\n          0 == tool_params.timeout ? \" (no timeout)\" : \"\");\n  printf (\"  'Date:' header:     %s\\n\",\n          tool_params.date_header ? \"Yes\" : \"No\");\n  printf (\"To test with remote client use            \"\n          \"http://HOST_IP:%u/\\n\", (unsigned int) port);\n  printf (\"To test with client on the same host use  \"\n          \"http://127.0.0.1:%u/\\n\", (unsigned int) port);\n  printf (\"\\nPress ENTER to stop.\\n\");\n  if (1)\n  {\n    char buf[10];\n    (void) fgets (buf, sizeof(buf), stdin);\n  }\n  MHD_stop_daemon (d);\n  return 0;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe for loop initializes the loop counter urh in the first clause and tests NULL != urh in the second clause, but the iteration (third) clause is urh = urhn while urhn is assigned inside the loop body (urhn = urh->prev;). Rule 14.2 clause 3 prohibits the third clause from using objects that are modified in the loop body (and the loop body includes called functions), so this loop is not well-formed and violates Rule 14.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function run_mhd:\nstatic unsigned int\nget_num_threads (void)\n{\n#if 0  /* disalbed code */\n  static const unsigned int max_threads = 32;\n#endif /* disalbed code */\n  if (0 < num_threads)\n    return num_threads;\n\n  num_threads = get_cpu_core_count () / 2;\n  if (0 == num_threads)\n    num_threads = 1;\n  else\n  {\n    unsigned int num_proc_cpus;\n    num_proc_cpus = get_process_cpu_core_count ();\n    if (num_proc_cpus >= num_threads)\n    {\n      printf (\"Using half of all available CPU cores, assuming the other half \"\n              \"is used by client / requests generator.\\n\");\n    }\n    else\n    {\n      printf (\"Using all CPU cores available for this process as more than \"\n              \"half of CPU cores on this system are still available for use \"\n              \"by client / requests generator.\\n\");\n      num_threads = num_proc_cpus;\n    }\n  }\n#if 0  /* disalbed code */\n  if (max_threads < num_threads)\n  {\n    printf (\"Number of threads are limited to %u as more threads \"\n            \"are unlikely to improve the performance.\\n\", max_threads);\n    num_threads = max_threads;\n  }\n#endif /* disalbed code */\n\n  return num_threads;\n}\n...\nstatic unsigned int\nget_cpu_core_count (void)\n{\n  static unsigned int num_cpu_cores = 0;\n  if (0 == num_cpu_cores)\n    num_cpu_cores = detect_cpu_core_count ();\n  return num_cpu_cores;\n}\n...\nstatic unsigned int\nget_process_cpu_core_count (void)\n{\n  static unsigned int proc_num_cpu_cores = 0;\n  if (0 == proc_num_cpu_cores)\n    proc_num_cpu_cores = detect_process_cpu_core_count ();\n  return proc_num_cpu_cores;\n}\n...\nstatic void\nprint_perf_warnings (void)\n{\n  int newline_needed = 0;\n#if defined (_DEBUG)\n  fprintf (stderr, \"WARNING: Running with debug asserts enabled, \"\n           \"the performance is suboptimal.\\n\");\n  newline_needed |=  ! 0;\n#endif /* _DEBUG */\n#if defined(__GNUC__) && ! defined (__OPTIMIZE__)\n  fprintf (stderr, \"WARNING: The tools is compiled without enabled compiler \"\n           \"optimisations, the performance is suboptimal.\\n\");\n  newline_needed |=  ! 0;\n#endif /* __GNUC__ && ! __OPTIMIZE__ */\n#if defined(__GNUC__) && defined (__OPTIMIZE_SIZE__)\n  fprintf (stderr, \"WARNING: The tools is compiled with size-optimisations, \"\n           \"the performance is suboptimal.\\n\");\n#endif /* __GNUC__ && ! __OPTIMIZE__ */\n#if MHD_VERSION >= 0x00097701\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_DEBUG_BUILD))\n  {\n    fprintf (stderr, \"WARNING: The libmicrohttpd is compiled with \"\n             \"debug asserts enabled, the performance is suboptimal.\\n\");\n    newline_needed |=  ! 0;\n  }\n#endif /* MHD_VERSION >= 0x00097701 */\n  if (newline_needed)\n    printf (\"\\n\");\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_is_feature_supported (enum MHD_FEATURE feature)\n{\n  switch (feature)\n  {\n  case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n    return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n    return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n  case MHD_FEATURE_HTTPS_CERT_CALLBACK2:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030603\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030603 */\n  case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n    return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n  case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n    return MHD_YES;\n#elif defined(HAVE_PREAD)\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n    return MHD_YES;\n#else\n    return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n  case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE) || \\\n    ! defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_THREADS:\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_HTTPS_COOKIE_PARSING:\n#if defined(COOKIE_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_RFC2069:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_MD5:\n#if defined(DAUTH_SUPPORT) && defined(MHD_MD5_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_SHA512_256:\n#if defined(DAUTH_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_AUTH_INT:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_ALGO_SESSION:\n#ifdef DAUTH_SUPPORT\n    return MHD_NO;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DIGEST_AUTH_USERHASH:\n#ifdef DAUTH_SUPPORT\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_EXTERN_HASH:\n#if defined(MHD_MD5_TLSLIB) || defined(MHD_SHA256_TLSLIB)\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_DEBUG_BUILD:\n#ifdef _DEBUG\n    return MHD_YES;\n#else\n    return MHD_NO;\n#endif\n  case MHD_FEATURE_FLEXIBLE_FD_SETSIZE:\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n    return MHD_YES;\n#else  /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n    return MHD_NO;\n#endif /* ! HAS_FD_SETSIZE_OVERRIDABLE */\n\n  default:\n    break;\n  }\n  return MHD_NO;\n}\n...\nstatic const char *\nget_mhd_response_size (void)\n{\n  if (tool_params.empty)\n    return \"0 bytes (empty)\";\n  else if (tool_params.tiny)\n    return \"3 bytes (tiny)\";\n  else if (tool_params.medium)\n    return \"8 KB (medium)\";\n  else if (tool_params.large)\n    return \"1 MB (large)\";\n  return \"!!internal error!!\";\n}\n...\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon (unsigned int flags,\n                  uint16_t port,\n                  MHD_AcceptPolicyCallback apc,\n                  void *apc_cls,\n                  MHD_AccessHandlerCallback dh,\n                  void *dh_cls,\n                  ...)\n{\n  struct MHD_Daemon *daemon;\n  va_list ap;\n\n  va_start (ap,\n            dh_cls);\n  daemon = MHD_start_daemon_va (flags,\n                                port,\n                                apc,\n                                apc_cls,\n                                dh,\n                                dh_cls,\n                                ap);\n  va_end (ap);\n  return daemon;\n}\n...\n_MHD_EXTERN struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n                     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd = MHD_INVALID_SOCKET;\n  const struct sockaddr *pservaddr = NULL;\n  socklen_t addrlen;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n  struct MHD_InterimParams_ *interim_params;\n\n  MHD_check_global_init_ ();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n\n  if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n    *pflags |= MHD_USE_INTERNAL_POLLING_THREAD; /* Force enable, log warning later if needed */\n\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n  {\n#ifdef UPGRADE_SUPPORT\n    *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n    return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n#ifdef MHD_USE_THREADS\n  if ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD) ==\n      ((MHD_USE_NO_THREAD_SAFETY | MHD_USE_INTERNAL_POLLING_THREAD)\n       & *pflags))\n    return NULL; /* Cannot be thread-unsafe with multiple threads */\n#else  /* ! MHD_USE_THREADS */\n  if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    return NULL;\n#endif /* ! MHD_USE_THREADS */\n\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_EPOLL)) &&\n      (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_POLL)) &&\n      (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD\n                        | MHD_USE_THREAD_PER_CONNECTION))))\n    return NULL;\n  if ((0 != (*pflags & MHD_USE_AUTO)) &&\n      (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))))\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n  {\n#if defined(EPOLL_SUPPORT) && defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_POLL;\n    else\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#elif defined(HAVE_POLL)\n    if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n      *pflags |= MHD_USE_POLL; /* Including thread-per-connection */\n#elif defined(EPOLL_SUPPORT)\n    if (0 == (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n      *pflags |= MHD_USE_EPOLL; /* Including \"external select\" mode */\n#else\n    /* No choice: use select() for any mode - do not modify flags */\n#endif\n  }\n\n  if (0 != (*pflags & MHD_USE_NO_THREAD_SAFETY))\n    *pflags = (*pflags & ~((enum MHD_FLAG) MHD_USE_ITC)); /* useless in single-threaded environment */\n  else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n  {\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n    *pflags |= MHD_USE_ITC;       /* yes, must use ITC to signal thread */\n  }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n  interim_params = (struct MHD_InterimParams_ *) \\\n                   MHD_calloc_ (1, sizeof (struct MHD_InterimParams_));\n  if (NULL == interim_params)\n  {\n    int err_num = errno;\n    free (daemon);\n    errno = err_num;\n    return NULL;\n  }\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listen_is_unix = _MHD_NO;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->client_discipline = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ?\n                              1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout_ms = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&daemon->tid);\n#endif /* MHD_USE_THREADS */\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = &MHD_default_logger_;\n  daemon->custom_error_log_cls = stderr;\n#endif\n#ifndef MHD_WINSOCK_SOCKETS\n  daemon->sigpipe_blocked = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  /* There is no SIGPIPE on W32, nothing to block. */\n  daemon->sigpipe_blocked = true;\n#endif /* _WIN32 && ! __CYGWIN__ */\n#if defined(_DEBUG) && defined(HAVE_ACCEPT4)\n  daemon->avoid_accept4 = false;\n#endif /* _DEBUG */\n#ifdef HAS_FD_SETSIZE_OVERRIDABLE\n  daemon->fdset_size = (int) FD_SETSIZE;\n  daemon->fdset_size_set_by_app = false;\n#endif /* HAS_FD_SETSIZE_OVERRIDABLE */\n\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n  daemon->dauth_def_nonce_timeout = MHD_DAUTH_DEF_TIMEOUT_;\n  daemon->dauth_def_max_nc = MHD_DAUTH_DEF_MAX_NC_;\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n  }\n#endif /* HTTPS_SUPPORT */\n\n  interim_params->num_opts = 0;\n  interim_params->fdset_size_set = false;\n  interim_params->fdset_size = 0;\n  interim_params->listen_fd_set = false;\n  interim_params->listen_fd = MHD_INVALID_SOCKET;\n  interim_params->pserver_addr_set = false;\n  interim_params->pserver_addr = NULL;\n  interim_params->server_addr_len_set = false;\n  interim_params->server_addr_len = 0;\n\n  if (MHD_NO == parse_options_va (daemon,\n                                  interim_params,\n                                  ap))\n  {\n#ifdef HTTPS_SUPPORT\n    if ( (0 != (*pflags & MHD_USE_TLS)) &&\n         (NULL != daemon->priority_cache) )\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  if (! process_interim_params (daemon,\n                                &pservaddr,\n                                &addrlen,\n                                interim_params))\n  {\n    free (interim_params);\n    free (daemon);\n    return NULL;\n  }\n  free (interim_params);\n  interim_params = NULL;\n#ifdef HTTPS_SUPPORT\n  if ((0 != (*pflags & MHD_USE_TLS))\n      && (NULL == daemon->priority_cache)\n      && ! daemon_tls_priorities_init_default (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialise GnuTLS priorities.\\n\"));\n#endif /* HAVE_MESSAGES */\n    free (daemon);\n    return NULL;\n  }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (flags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used \" \\\n                 \"only with MHD_USE_INTERNAL_POLLING_THREAD. \" \\\n                 \"Flag MHD_USE_INTERNAL_POLLING_THREAD was added. \" \\\n                 \"Consider setting MHD_USE_INTERNAL_POLLING_THREAD \" \\\n                 \"explicitly.\\n\"));\n  }\n#endif\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)\n      && ((NULL != daemon->notify_completed)\n          || (NULL != daemon->notify_connection)) )\n    *pflags |= MHD_USE_ITC; /* requires ITC */\n\n#ifdef _DEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            _ (\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* _DEBUG */\n\n  if ( (0 != (*pflags & MHD_USE_ITC))\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n       && (0 == daemon->worker_pool_size)\n#endif\n       )\n  {\n    if (! MHD_itc_init_ (daemon->itc))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create inter-thread communication channel: %s\\n\"),\n                MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (daemon->itc), daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"file descriptor for inter-thread communication \" \\\n                   \"channel exceeds maximum value.\\n\"));\n#endif\n      MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n      if (NULL != daemon->priority_cache)\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#ifdef DAUTH_SUPPORT\n  if (NULL != daemon->digest_auth_random_copy)\n  {\n    mhd_assert (daemon == daemon->digest_auth_random_copy);\n    daemon->digest_auth_random_copy = malloc (daemon->digest_auth_rand_size);\n    if (NULL == daemon->digest_auth_random_copy)\n    {\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n    memcpy (daemon->digest_auth_random_copy,\n            daemon->digest_auth_random,\n            daemon->digest_auth_rand_size);\n    daemon->digest_auth_random = daemon->digest_auth_random_copy;\n  }\n  if (daemon->nonce_nc_size > 0)\n  {\n    if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc)))\n         / sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Specified value for NC_SIZE too large.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n    daemon->nnc = MHD_calloc_ (daemon->nonce_nc_size,\n                               sizeof (struct MHD_NonceNc));\n    if (NULL == daemon->nnc)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n        gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->digest_auth_random_copy);\n      free (daemon);\n      return NULL;\n    }\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize nonce-nc mutex.\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n    if (0 != (*pflags & MHD_USE_TLS))\n      gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n    free (daemon);\n    return NULL;\n  }\n#endif\n#endif\n\n  /* Thread polling currently works only with internal select thread mode */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! MHD_D_IS_USING_THREADS_ (daemon)) &&\n       (daemon->worker_pool_size > 0) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD thread polling only works with \" \\\n                 \"MHD_USE_INTERNAL_POLLING_THREAD.\\n\"));\n#endif\n    goto free_and_fail;\n  }\n#endif\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n  {\n    /* try to open listen socket */\n    struct sockaddr_in servaddr4;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 servaddr6;\n    const bool use_ipv6 = (0 != (*pflags & MHD_USE_IPv6));\n#else  /* ! HAVE_INET6 */\n    const bool use_ipv6 = false;\n#endif /* ! HAVE_INET6 */\n    int domain;\n\n    if (NULL != pservaddr)\n    {\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      const socklen_t sa_len = pservaddr->sa_len;\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#ifdef HAVE_INET6\n      if (use_ipv6 && (AF_INET6 != pservaddr->sa_family))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_USE_IPv6 is enabled, but 'struct sockaddr *' \" \\\n                     \"specified for MHD_OPTION_SOCK_ADDR_LEN or \" \\\n                     \"MHD_OPTION_SOCK_ADDR is not IPv6 address.\\n\"));\n#endif /* HAVE_MESSAGES */\n        goto free_and_fail;\n      }\n#endif /* HAVE_INET6 */\n      switch (pservaddr->sa_family)\n      {\n      case AF_INET:\n        if (1)\n        {\n          struct sockaddr_in sa4;\n          uint16_t sa4_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa4)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa4)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa4);\n          memcpy (&sa4, pservaddr, sizeof(sa4));  /* Required due to stronger alignment */\n          sa4_port = (uint16_t) ntohs (sa4.sin_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa4_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa4_port;\n          domain = PF_INET;\n        }\n        break;\n#ifdef HAVE_INET6\n      case AF_INET6:\n        if (1)\n        {\n          struct sockaddr_in6 sa6;\n          uint16_t sa6_port;\n          if ((0 != addrlen)\n              && (((socklen_t) sizeof(sa6)) > addrlen))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"The size specified for MHD_OPTION_SOCK_ADDR_LEN \" \\\n                         \"option is wrong.\\n\"));\n#endif /* HAVE_MESSAGES */\n            goto free_and_fail;\n          }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n          if (0 != sa_len)\n          {\n            if (((socklen_t) sizeof(sa6)) > sa_len)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"The value of 'struct sockaddr.sa_len' provided \" \\\n                           \"via MHD_OPTION_SOCK_ADDR_LEN option is not zero \" \\\n                           \"and does not match 'sa_family' value of the \" \\\n                           \"same structure.\\n\"));\n#endif /* HAVE_MESSAGES */\n              goto free_and_fail;\n            }\n            if ((0 == addrlen) || (sa_len < addrlen))\n              addrlen = sa_len; /* Use smaller value for safety */\n          }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n          if (0 == addrlen)\n            addrlen = sizeof(sa6);\n          memcpy (&sa6, pservaddr, sizeof(sa6));  /* Required due to stronger alignment */\n          sa6_port = (uint16_t) ntohs (sa6.sin6_port);\n#ifndef MHD_USE_GETSOCKNAME\n          if (0 != sa6_port)\n#endif /* ! MHD_USE_GETSOCKNAME */\n          daemon->port = sa6_port;\n          domain = PF_INET6;\n          *pflags |= ((enum MHD_FLAG) MHD_USE_IPv6);\n        }\n        break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n#endif /* AF_UNIX */\n      default:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n        if (0 == addrlen)\n          addrlen = sa_len;\n        else if ((0 != sa_len) && (sa_len < addrlen))\n          addrlen = sa_len; /* Use smaller value for safety */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n        if (0 >= addrlen)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"The 'sa_family' of the 'struct sockaddr' provided \" \\\n                       \"via MHD_OPTION_SOCK_ADDR option is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n          goto free_and_fail;\n        }\n#ifdef AF_UNIX\n        if (AF_UNIX == pservaddr->sa_family)\n        {\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n#ifdef PF_UNIX\n          domain = PF_UNIX;\n#else /* ! PF_UNIX */\n          domain = AF_UNIX;\n#endif /* ! PF_UNIX */\n        }\n        else /* combined with the next 'if' */\n#endif /* AF_UNIX */\n        if (1)\n        {\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          /* Assumed the same values for AF_* and PF_* */\n          domain = pservaddr->sa_family;\n        }\n        break;\n      }\n    }\n    else\n    {\n      if (! use_ipv6)\n      {\n        memset (&servaddr4,\n                0,\n                sizeof (struct sockaddr_in));\n        servaddr4.sin_family = AF_INET;\n        servaddr4.sin_port = htons (port);\n        if (0 != INADDR_ANY)\n          servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n        servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr4;\n        addrlen = (socklen_t) sizeof(servaddr4);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET;\n      }\n#ifdef HAVE_INET6\n      else\n      {\n#ifdef IN6ADDR_ANY_INIT\n        static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n        memset (&servaddr6,\n                0,\n                sizeof (struct sockaddr_in6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n        servaddr6.sin6_addr = static_in6any;\n#endif\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n        servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n        pservaddr = (struct sockaddr *) &servaddr6;\n        addrlen = (socklen_t) sizeof (servaddr6);\n        daemon->listen_is_unix = _MHD_NO;\n        domain = PF_INET6;\n      }\n#endif /* HAVE_INET6 */\n    }\n\n    listen_fd = MHD_socket_create_listen_ (domain);\n    if (MHD_INVALID_SOCKET == listen_fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to create socket for listening: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n\n    /* Apply the socket options according to listening_address_reuse. */\n    if (0 == daemon->listening_address_reuse)\n    {\n#ifndef MHD_WINSOCK_SOCKETS\n      /* No user requirement, use \"traditional\" default SO_REUSEADDR\n       * on non-W32 platforms, and do not fail if it doesn't work.\n       * Don't use it on W32, because on W32 it will allow multiple\n       * bind to the same address:port, like SO_REUSEPORT on others. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n    }\n    else if (daemon->listening_address_reuse > 0)\n    {\n      /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n      /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n       * it doesn't work. */\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n                          SO_REUSEADDR,\n                          (const void *) &on, sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n      /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n       * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n       */\n      /* SO_REUSEADDR on W32 has the same semantics\n         as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                          SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                          SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n      /* we're supposed to allow address:port re-use, but\n         on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot allow listening address reuse: \" \\\n                   \"SO_REUSEPORT not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n    }\n    else   /* if (daemon->listening_address_reuse < 0) */\n    {\n      /* User requested to disallow reusing listening address:port.\n       * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n       * is used and Solaris with SO_EXCLBIND.\n       * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n       * or setsockopt fails.\n       */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n      (defined(__sun) && defined(SO_EXCLBIND))\n      if (0 > setsockopt (listen_fd,\n                          SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                          SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                          SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                          (const void *) &on,\n                          sizeof (on)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        goto free_and_fail;\n      }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Cannot disallow listening address reuse: \" \\\n                   \"SO_EXCLUSIVEADDRUSE not defined.\\n\"));\n#endif\n      goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n\n    /* check for user supplied sockaddr */\n    daemon->listen_fd = listen_fd;\n\n    if (0 != (*pflags & MHD_USE_IPv6))\n    {\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n      /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n         (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n         and may also be missing on older POSIX systems; good luck if you have any of those,\n         your IPv6 socket may then also bind against IPv4 anyway... */\n      const MHD_SCKT_OPT_BOOL_ v6_only =\n        (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n      if (0 > setsockopt (listen_fd,\n                          IPPROTO_IPV6, IPV6_V6ONLY,\n                          (const void *) &v6_only,\n                          sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n    }\n    if (0 != bind (listen_fd, pservaddr, addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to bind to port %u: %s\\n\"),\n                (unsigned int) port,\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n#ifdef TCP_FASTOPEN\n    if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    {\n      if (0 == daemon->fastopen_queue_size)\n        daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n      if (0 != setsockopt (listen_fd,\n                           IPPROTO_TCP,\n                           TCP_FASTOPEN,\n                           (const void *) &daemon->fastopen_queue_size,\n                           sizeof (daemon->fastopen_queue_size)))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"setsockopt failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n      }\n    }\n#endif\n    if (0 != listen (listen_fd,\n                     (int) daemon->listen_backlog_size))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to listen for connections: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      listen_fd = MHD_INVALID_SOCKET;\n      goto free_and_fail;\n    }\n  }\n  else\n  {\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->listen_fd, daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Listen socket descriptor (%d) is not \" \\\n                   \"less than daemon FD_SETSIZE value (%d).\\n\"),\n                (int) daemon->listen_fd,\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      goto free_and_fail;\n    }\n    else\n    {\n#if defined(SOL_SOCKET) && (defined(SO_DOMAIN) || defined(SO_PROTOCOL_INFOW))\n      int af;\n      int opt_name;\n      void *poptval;\n      socklen_t optval_size;\n#ifdef SO_DOMAIN\n      opt_name = SO_DOMAIN;\n      poptval = &af;\n      optval_size = (socklen_t) sizeof (af);\n#else  /* SO_PROTOCOL_INFOW */\n      WSAPROTOCOL_INFOW prot_info;\n      opt_name = SO_PROTOCOL_INFOW;\n      poptval = &prot_info;\n      optval_size = (socklen_t) sizeof (prot_info);\n#endif /* SO_PROTOCOL_INFOW */\n\n      if (0 == getsockopt (daemon->listen_fd,\n                           SOL_SOCKET,\n                           opt_name,\n                           poptval,\n                           &optval_size))\n      {\n#ifndef SO_DOMAIN\n        af = prot_info.iAddressFamily;\n#endif /* SO_DOMAIN */\n        switch (af)\n        {\n        case AF_INET:\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#ifdef HAVE_INET6\n        case AF_INET6:\n          *pflags |= MHD_USE_IPv6;\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n        case AF_UNIX:\n          daemon->port = 0;     /* special value for UNIX domain sockets */\n          daemon->listen_is_unix = _MHD_YES;\n          break;\n#endif /* AF_UNIX */\n        default:\n          daemon->port = 0;     /* ugh */\n          daemon->listen_is_unix = _MHD_UNKNOWN;\n          break;\n        }\n      }\n      else\n#endif /* SOL_SOCKET && (SO_DOMAIN || SO_PROTOCOL_INFOW)) */\n      daemon->listen_is_unix = _MHD_UNKNOWN;\n    }\n\n    listen_fd = daemon->listen_fd;\n#ifdef MHD_USE_GETSOCKNAME\n    daemon->port = 0;  /* Force use of autodetection */\n#endif /* MHD_USE_GETSOCKNAME */\n  }\n\n#ifdef MHD_USE_GETSOCKNAME\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) &&\n       (_MHD_YES != daemon->listen_is_unix) )\n  {   /* Get port number. */\n    struct sockaddr_storage bindaddr;\n\n    memset (&bindaddr,\n            0,\n            sizeof (struct sockaddr_storage));\n    addrlen = sizeof (struct sockaddr_storage);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n    bindaddr.ss_len = (socklen_t) addrlen;\n#endif\n    if (0 != getsockname (listen_fd,\n                          (struct sockaddr *) &bindaddr,\n                          &addrlen))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef MHD_POSIX_SOCKETS\n    else if (sizeof (bindaddr) < addrlen)\n    {\n      /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to get listen port number \" \\\n                   \"(`struct sockaddr_storage` too small!?).\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifndef __linux__\n    else if (0 == addrlen)\n    {\n      /* Many non-Linux-based platforms return zero addrlen\n       * for AF_UNIX sockets */\n      daemon->port = 0;     /* special value for UNIX domain sockets */\n      if (_MHD_UNKNOWN == daemon->listen_is_unix)\n        daemon->listen_is_unix = _MHD_YES;\n    }\n#endif /* __linux__ */\n#endif /* MHD_POSIX_SOCKETS */\n    else\n    {\n      switch (bindaddr.ss_family)\n      {\n      case AF_INET:\n        {\n          struct sockaddr_in *s4 = (struct sockaddr_in *) &bindaddr;\n\n          daemon->port = ntohs (s4->sin_port);\n          daemon->listen_is_unix = _MHD_NO;\n          break;\n        }\n#ifdef HAVE_INET6\n      case AF_INET6:\n        {\n          struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &bindaddr;\n\n          daemon->port = ntohs (s6->sin6_port);\n          daemon->listen_is_unix = _MHD_NO;\n          mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n          break;\n        }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n      case AF_UNIX:\n        daemon->port = 0;     /* special value for UNIX domain sockets */\n        daemon->listen_is_unix = _MHD_YES;\n        break;\n#endif\n      default:\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Listen socket has unknown address family!\\n\"));\n#endif\n        daemon->port = 0;     /* ugh */\n        daemon->listen_is_unix = _MHD_UNKNOWN;\n        break;\n      }\n    }\n  }\n#endif /* MHD_USE_GETSOCKNAME */\n\n  if (MHD_INVALID_SOCKET != listen_fd)\n  {\n    mhd_assert (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    if (! MHD_socket_nonblocking_ (listen_fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          || (daemon->worker_pool_size > 0)\n#endif\n          )\n      {\n        /* Accept must be non-blocking. Multiple children may wake up\n         * to handle a new connection, but only one will win the race.\n         * The others must immediately return. */\n        MHD_socket_close_chk_ (listen_fd);\n        listen_fd = MHD_INVALID_SOCKET;\n        goto free_and_fail;\n      }\n      daemon->listen_nonblk = false;\n    }\n    else\n      daemon->listen_nonblk = true;\n  }\n  else\n  {\n    mhd_assert (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET));\n    daemon->listen_nonblk = false; /* Actually listen socket does not exist */\n  }\n\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon)\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      && (0 == daemon->worker_pool_size)\n#endif\n      )\n  {\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Combining MHD_USE_THREAD_PER_CONNECTION and \" \\\n                   \"MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n      goto free_and_fail;\n    }\n    if (MHD_NO == setup_epoll_to_listen (daemon))\n      goto free_and_fail;\n  }\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"MHD failed to initialize IP connection limit mutex.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    goto free_and_fail;\n  }\n#endif\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to initialize TLS support.\\n\"));\n#endif\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    goto free_and_fail;\n  }\n#endif /* HTTPS_SUPPORT */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Start threads if requested by parameters */\n  if (MHD_D_IS_USING_THREADS_ (daemon))\n  {\n    /* Internal thread (or threads) is used.\n     * Make sure that MHD will be able to communicate with threads. */\n    /* If using a thread pool ITC will be initialised later\n     * for each individual worker thread. */\n#ifdef HAVE_LISTEN_SHUTDOWN\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)) || \\\n                (MHD_INVALID_SOCKET != daemon->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n    mhd_assert ((1 < daemon->worker_pool_size) || \\\n                (MHD_ITC_IS_VALID_ (daemon->itc)));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n    if (0 == daemon->worker_pool_size)\n    {\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to initialise mutex.\\n\"));\n#endif\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n      if (! MHD_create_named_thread_ (&daemon->tid,\n                                      MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) ?\n                                      \"MHD-listen\" : \"MHD-single\",\n                                      daemon->thread_stack_size,\n                                      &MHD_polling_thread,\n                                      daemon) )\n      {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n        if (EAGAIN == errno)\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a new thread because it would have \" \\\n                       \"exceeded the system limit on the number of threads or \" \\\n                       \"no system resources available.\\n\"));\n        else\n#endif /* EAGAIN */\n        MHD_DLOG (daemon,\n                  _ (\"Failed to create listen thread: %s\\n\"),\n                  MHD_strerror_ (errno));\n#endif /* HAVE_MESSAGES */\n        MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n        if (MHD_INVALID_SOCKET != listen_fd)\n          MHD_socket_close_chk_ (listen_fd);\n        goto free_and_fail;\n      }\n    }\n    else   /* 0 < daemon->worker_pool_size */\n    {\n      /* Coarse-grained count of connections per thread (note error\n       * due to integer division). Also keep track of how many\n       * connections are leftover after an equal split. */\n      unsigned int conns_per_thread = daemon->connection_limit\n                                      / daemon->worker_pool_size;\n      unsigned int leftover_conns = daemon->connection_limit\n                                    % daemon->worker_pool_size;\n\n      mhd_assert (2 <= daemon->worker_pool_size);\n      i = 0;     /* we need this in case fcntl or malloc fails */\n\n      /* Allocate memory for pooled objects */\n      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                    * daemon->worker_pool_size);\n      if (NULL == daemon->worker_pool)\n        goto thread_failed;\n\n      /* Start the workers in the pool */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n      {\n        /* Create copy of the Daemon object for each worker */\n        struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n        memcpy (d, daemon, sizeof (struct MHD_Daemon));\n        /* Adjust polling params for worker daemons; note that memcpy()\n           has already copied MHD_USE_INTERNAL_POLLING_THREAD thread mode into\n           the worker threads. */\n        d->master = daemon;\n        d->worker_pool_size = 0;\n        d->worker_pool = NULL;\n        if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n          goto thread_failed;\n        }\n        if (! MHD_mutex_init_ (&d->new_connections_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Failed to initialise mutex.\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n        if (0 != (*pflags & MHD_USE_ITC))\n        {\n          if (! MHD_itc_init_ (d->itc))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create worker inter-thread \" \\\n                         \"communication channel: %s\\n\"),\n                      MHD_itc_last_strerror_ () );\n#endif\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n          if (MHD_D_IS_USING_SELECT_ (d) &&\n              (! MHD_D_DOES_SCKT_FIT_FDSET_ (MHD_itc_r_fd_ (d->itc), daemon)) )\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"File descriptor for worker inter-thread \" \\\n                         \"communication channel exceeds maximum value.\\n\"));\n#endif\n            MHD_itc_destroy_chk_ (d->itc);\n            MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n            MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n            goto thread_failed;\n          }\n        }\n        else\n          MHD_itc_set_invalid_ (d->itc);\n\n#ifdef HAVE_LISTEN_SHUTDOWN\n        mhd_assert ((MHD_ITC_IS_VALID_ (d->itc)) || \\\n                    (MHD_INVALID_SOCKET != d->listen_fd));\n#else  /* ! HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (MHD_ITC_IS_VALID_ (d->itc));\n#endif /* ! HAVE_LISTEN_SHUTDOWN */\n\n        /* Divide available connections evenly amongst the threads.\n         * Thread indexes in [0, leftover_conns) each get one of the\n         * leftover connections. */\n        d->connection_limit = conns_per_thread;\n        if (i < leftover_conns)\n          ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (d) &&\n            (MHD_NO == setup_epoll_to_listen (d)) )\n        {\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n#endif\n        /* Some members must be used only in master daemon */\n#if defined(MHD_USE_THREADS)\n        memset (&d->per_ip_connection_mutex, 0x7F,\n                sizeof(d->per_ip_connection_mutex));\n#endif /* MHD_USE_THREADS */\n#ifdef DAUTH_SUPPORT\n        d->nnc = NULL;\n        d->nonce_nc_size = 0;\n        d->digest_auth_random_copy = NULL;\n#if defined(MHD_USE_THREADS)\n        memset (&d->nnc_lock, 0x7F, sizeof(d->nnc_lock));\n#endif /* MHD_USE_THREADS */\n#endif /* DAUTH_SUPPORT */\n\n        /* Spawn the worker thread */\n        if (! MHD_create_named_thread_ (&d->tid,\n                                        \"MHD-worker\",\n                                        daemon->thread_stack_size,\n                                        &MHD_polling_thread,\n                                        d))\n        {\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == errno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new pool thread because it would \" \\\n                         \"have exceeded the system limit on the number of \" \\\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create pool thread: %s\\n\"),\n                    MHD_strerror_ (errno));\n#endif\n          /* Free memory for this worker; cleanup below handles\n           * all previously-created workers. */\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          if (MHD_ITC_IS_VALID_ (d->itc))\n            MHD_itc_destroy_chk_ (d->itc);\n          MHD_mutex_destroy_chk_ (&d->new_connections_mutex);\n          MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n          goto thread_failed;\n        }\n      }\n    }\n  }\n  else\n  { /* Daemon without internal threads */\n    if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise internal lists mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n    if (! MHD_mutex_init_ (&daemon->new_connections_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise mutex.\\n\"));\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  }\n#endif\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n  {\n    if (MHD_INVALID_SOCKET != listen_fd)\n      MHD_socket_close_chk_ (listen_fd);\n    listen_fd = MHD_INVALID_SOCKET;\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n    if (NULL != daemon->worker_pool)\n      free (daemon->worker_pool);\n    goto free_and_fail;\n  }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n#endif\n\nfree_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        daemon->epoll_upgrade_fd,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n    daemon->upgrade_fd_in_epoll = false;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->digest_auth_random_copy);\n  free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n  {\n    gnutls_priority_deinit (daemon->priority_cache);\n    if (daemon->x509_cred)\n      gnutls_certificate_free_credentials (daemon->x509_cred);\n    if (daemon->psk_cred)\n      gnutls_psk_free_server_credentials (daemon->psk_cred);\n  }\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  if (MHD_INVALID_SOCKET != listen_fd)\n    (void) MHD_socket_close_ (listen_fd);\n  if ((MHD_INVALID_SOCKET != daemon->listen_fd) &&\n      (listen_fd != daemon->listen_fd))\n    (void) MHD_socket_close_ (daemon->listen_fd);\n  free (daemon);\n  return NULL;\n}\n...\n_MHD_EXTERN const union MHD_DaemonInfo *\nMHD_get_daemon_info (struct MHD_Daemon *daemon,\n                     enum MHD_DaemonInfoType info_type,\n                     ...)\n{\n  if (NULL == daemon)\n    return NULL;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  switch (info_type)\n  {\n  case MHD_DAEMON_INFO_KEY_SIZE:\n    return NULL;   /* no longer supported */\n  case MHD_DAEMON_INFO_MAC_KEY_SIZE:\n    return NULL;   /* no longer supported */\n  case MHD_DAEMON_INFO_LISTEN_FD:\n    daemon->daemon_info_dummy_listen_fd.listen_fd = daemon->listen_fd;\n    return &daemon->daemon_info_dummy_listen_fd;\n  case MHD_DAEMON_INFO_EPOLL_FD:\n#ifdef EPOLL_SUPPORT\n    daemon->daemon_info_dummy_epoll_fd.epoll_fd = daemon->epoll_fd;\n    return &daemon->daemon_info_dummy_epoll_fd;\n#else  /* ! EPOLL_SUPPORT */\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n  case MHD_DAEMON_INFO_CURRENT_CONNECTIONS:\n    if (! MHD_D_IS_THREAD_SAFE_ (daemon))\n      MHD_cleanup_connections (daemon);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    else if (daemon->worker_pool)\n    {\n      unsigned int i;\n      /* Collect the connection information stored in the workers. */\n      daemon->connections = 0;\n      for (i = 0; i < daemon->worker_pool_size; i++)\n      {\n        /* FIXME: next line is thread-safe only if read is atomic. */\n        daemon->connections += daemon->worker_pool[i].connections;\n      }\n    }\n#endif\n    daemon->daemon_info_dummy_num_connections.num_connections\n      = daemon->connections;\n    return &daemon->daemon_info_dummy_num_connections;\n  case MHD_DAEMON_INFO_FLAGS:\n    daemon->daemon_info_dummy_flags.flags = daemon->options;\n    return &daemon->daemon_info_dummy_flags;\n  case MHD_DAEMON_INFO_BIND_PORT:\n    daemon->daemon_info_dummy_port.port = daemon->port;\n    return &daemon->daemon_info_dummy_port;\n  default:\n    return NULL;\n  }\n}\n...\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nstatic unsigned int\nget_mhd_conn_limit (struct MHD_Daemon *d)\n{\n  /* TODO: implement run-time detection */\n  (void) d; /* Unused */\n  if (0 != tool_params.connections)\n    return tool_params.connections;\n  return (unsigned int) MHD_MAX_CONNECTIONS_DEFAULT;\n}\n...\n_MHD_EXTERN void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n\n  if (NULL == daemon)\n    return;\n  if ( (daemon->shutdown) && (NULL == daemon->master) )\n    MHD_PANIC (_ (\"MHD_stop_daemon() was called twice.\"));\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (NULL != daemon->worker_pool) || \\\n              (MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n  mhd_assert (((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) &&\n               (NULL == daemon->worker_pool)) || \\\n              (! MHD_thread_handle_ID_is_valid_handle_ (daemon->tid)));\n\n  /* Slave daemons must be stopped by master daemon. */\n  mhd_assert ( (NULL == daemon->master) || (daemon->shutdown) );\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {   /* Master daemon with worker pool. */\n    mhd_assert (1 < daemon->worker_pool_size);\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n\n    /* Let workers shutdown in parallel. */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      daemon->worker_pool[i].shutdown = true;\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n        mhd_assert (MHD_INVALID_SOCKET != fd);\n    }\n#ifdef HAVE_LISTEN_SHUTDOWN\n    if (MHD_INVALID_SOCKET != fd)\n    {\n      (void) shutdown (fd,\n                       SHUT_RDWR);\n    }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      MHD_stop_daemon (&daemon->worker_pool[i]);\n    }\n    free (daemon->worker_pool);\n    mhd_assert (MHD_ITC_IS_INVALID_ (daemon->itc));\n#ifdef EPOLL_SUPPORT\n    mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n  }\n  else\n#endif\n  {   /* Worker daemon or single daemon. */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREADS_ (daemon))\n    {     /* Worker daemon or single daemon with internal thread(s). */\n      mhd_assert (0 == daemon->worker_pool_size);\n      /* Separate thread(s) is used for polling sockets. */\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n      {\n        if (! MHD_itc_activate_ (daemon->itc,\n                                 \"e\"))\n          MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n      else\n      {\n#ifdef HAVE_LISTEN_SHUTDOWN\n        if (MHD_INVALID_SOCKET != fd)\n        {\n          if (NULL == daemon->master)\n            (void) shutdown (fd,\n                             SHUT_RDWR);\n        }\n        else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n        mhd_assert (false); /* Should never happen */\n      }\n\n      if (! MHD_thread_handle_ID_join_thread_ (daemon->tid))\n      {\n        MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n      }\n      /* close_all_connections() was called in daemon thread. */\n    }\n    else\n#endif\n    {\n      /* No internal threads are used for polling sockets. */\n      close_all_connections (daemon);\n    }\n    mhd_assert (NULL == daemon->connections_head);\n    mhd_assert (NULL == daemon->cleanup_head);\n    mhd_assert (NULL == daemon->suspended_connections_head);\n    mhd_assert (NULL == daemon->new_connections_head);\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n    mhd_assert (NULL == daemon->urh_head);\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\n    if (MHD_ITC_IS_VALID_ (daemon->itc))\n      MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n        (-1 != daemon->epoll_upgrade_fd) )\n      MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    MHD_mutex_destroy_chk_ (&daemon->new_connections_mutex);\n#endif\n  }\n\n  if (NULL == daemon->master)\n  {   /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n    if (MHD_INVALID_SOCKET != fd)\n      MHD_socket_close_chk_ (fd);\n\n    /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n    if (daemon->have_dhparams)\n    {\n      gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n      daemon->have_dhparams = false;\n    }\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      gnutls_priority_deinit (daemon->priority_cache);\n      if (daemon->x509_cred)\n        gnutls_certificate_free_credentials (daemon->x509_cred);\n      if (daemon->psk_cred)\n        gnutls_psk_free_server_credentials (daemon->psk_cred);\n    }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n    free (daemon->digest_auth_random_copy);\n    free (daemon->nnc);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n#endif\n    free (daemon);\n  }\n}\n...\nstatic void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = MHD_D_IS_USING_THREAD_PER_CONN_ (daemon);\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (daemon->shutdown);\n\n#ifdef MHD_USE_THREADS\n/* Remove externally added new connections that are\n   * not processed by the daemon thread. */\n  MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n  while (NULL != (pos = daemon->new_connections_tail))\n  {\n    mhd_assert (MHD_D_IS_USING_THREADS_ (daemon));\n    DLL_remove (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                pos);\n    new_connection_close_ (daemon, pos);\n  }\n  MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n#endif /* MHD_USE_THREADS */\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n  {\n    mhd_assert (! used_thr_p_c);\n    urhn = urh->prev;\n    /* call generic forwarding function for passing data\n       with chance to detect that application is done. */\n    process_urh (urh);\n    MHD_connection_finish_forward_ (urh->connection);\n    urh->clean_ready = true;\n    /* Resuming will move connection to cleanup list. */\n    MHD_resume_connection (urh->connection);\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n  {\n    struct MHD_Connection *susp;\n\n    susp = daemon->suspended_connections_tail;\n    while (NULL != susp)\n    {\n      if (NULL == susp->urh)     /* \"Upgraded\" connection? */\n        MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                      \"suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n      else if (used_tls &&\n               used_thr_p_c &&\n               (! susp->urh->clean_ready) )\n        shutdown (susp->urh->app.socket,\n                  SHUT_RDWR);     /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n      else\n      {\n#ifdef HAVE_MESSAGES\n        if (! susp->urh->was_closed)\n          MHD_DLOG (daemon,\n                    _ (\"Initiated daemon shutdown while \\\"upgraded\\\" \" \\\n                       \"connection was not closed.\\n\"));\n#endif\n        susp->urh->was_closed = true;\n        /* If thread-per-connection is used, connection's thread\n         * may still processing \"upgrade\" (exiting). */\n        if (! used_thr_p_c)\n          MHD_connection_finish_forward_ (susp);\n        /* Do not use MHD_resume_connection() as mutex is\n         * already locked. */\n        susp->resuming = true;\n        daemon->resuming = true;\n      }\n      susp = susp->prev;\n    }\n  }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_ (\"MHD_stop_daemon() called while we have \" \\\n                  \"suspended connections.\\n\"));\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n#ifdef MHD_USE_THREADS\n  if (upg_allowed && used_tls && used_thr_p_c)\n  {\n    /* \"Upgraded\" threads may be running in parallel. Connection will not be\n     * moved to the \"cleanup list\" until connection's thread finishes.\n     * We must ensure that all \"upgraded\" connections are finished otherwise\n     * connection may stay in \"suspended\" list and will not be cleaned. */\n    for (pos = daemon->suspended_connections_tail; NULL != pos; pos = pos->prev)\n    {\n      /* Any connection found here is \"upgraded\" connection, normal suspended\n       * connections are already removed from this list. */\n      mhd_assert (NULL != pos->urh);\n      if (! pos->thread_joined)\n      {\n        /* While \"cleanup\" list is not manipulated by \"upgraded\"\n         * connection, \"cleanup\" mutex is required for call of\n         * MHD_resume_connection() during finishing of \"upgraded\"\n         * thread. */\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        pos->thread_joined = true;\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      }\n    }\n  }\n#endif /* MHD_USE_THREADS */\n#endif\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n  {\n    shutdown (pos->socket_fd,\n              SHUT_RDWR);\n#ifdef MHD_WINSOCK_SOCKETS\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n      MHD_PANIC (_ (\"Failed to signal shutdown via inter-thread \" \\\n                    \"communication channel.\\n\"));\n#endif\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n  {\n    pos = daemon->connections_tail;\n    while (NULL != pos)\n    {\n      if (! pos->thread_joined)\n      {\n        MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n        if (! MHD_thread_handle_ID_join_thread_ (pos->tid))\n          MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n        MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n        pos->thread_joined = true;\n        /* The thread may have concurrently modified the DLL,\n           need to restart from the beginning */\n        pos = daemon->connections_tail;\n        continue;\n      }\n      pos = pos->prev;\n    }\n  }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n  {\n    daemon->resuming = true;   /* Force check for pending resume. */\n    resume_suspended_connections (daemon);\n  }\n#endif /* UPGRADE_SUPPORT */\n\n  mhd_assert (NULL == daemon->suspended_connections_head);\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}\n...\nstatic unsigned int num_resps = 0\n...\nstatic uint16_t mhd_port = 0\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The loop in close_all_connections (and the scenario) uses the pattern: for (urh = daemon->urh_tail; NULL != urh; urh = urhn) { urhn = urh->prev; ... } Here urh is the loop counter and urhn is assigned (modified) inside the loop body. The for-statement\u2019s third clause (urh = urhn) reads urhn, which is an object modified in the loop body. MISRA C 2023 Rule 14.2 explicitly forbids the third clause from using objects that are modified in the for-loop body, so this construct violates Rule 14.2. (The second clause is fine; the violation is due to the update clause using urhn which is modified in the body.)"
}