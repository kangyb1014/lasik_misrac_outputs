{
  "user_message": "An agent A claimed that the following callback code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of callback.\n```c\nstatic ssize_t\ncallback (void *cls,\n          uint64_t pos,\n          char *buf,\n          size_t buf_size)\n{\n  size_t size_to_copy;\n  struct ResponseContentCallbackParam *const param =\n    (struct ResponseContentCallbackParam *) cls;\n\n  /* Note: 'pos' will never exceed size of transmitted data. */\n  /* You can use 'pos == param->response_size' in next check. */\n  if (pos >= param->response_size)\n  {   /* Whole response was sent. Signal end of response. */\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n\n  /* Pseudo code.        *\n  if (data_not_ready)\n    {\n      // Callback will be called again on next loop.\n      // Consider suspending connection until data will be ready.\n      return 0;\n    }\n   * End of pseudo code. */\n  if (buf_size < (param->response_size - pos))\n    size_to_copy = buf_size;\n  else\n    size_to_copy = (size_t) (param->response_size - pos);\n\n  memcpy (buf, param->response_data + pos, size_to_copy);\n\n  /* Pseudo code.        *\n  if (error_preparing_response)\n    {\n      // Close connection with error.\n      return MHD_CONTENT_READER_END_WITH_ERROR;\n    }\n   * End of pseudo code. */\n  /* Return amount of data copied to buffer. */\n  /* The 'buf_size' is always smaller than SSIZE_MAX therefore it's safe\n   * to cast 'size_to_copy' to 'ssize_t'. */\n  /* assert (size_to_copy <= buf_size); */\n  return (ssize_t) size_to_copy;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer 'param' is declared as a pointer to a non-const struct (struct ResponseContentCallbackParam *const) although the callback only reads the contents and the struct contains read-only data (response_data is const). Per MISRA C 2023 Rule 8.13 the pointer should point to a const-qualified type. The correct form would be, for example: const struct ResponseContentCallbackParam *const param = (const struct ResponseContentCallbackParam *) cls;\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function callback:\nstruct ResponseContentCallbackParam\n{\n  const char *response_data;\n  size_t response_size;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The local variable is declared as \"struct ResponseContentCallbackParam *const param\" \u2014 a const pointer to a non-const struct type. The callback only reads from the structure (reads response_size and response_data) and does not modify it, so per MISRA C:2023 Rule 8.13 the pointer should point to a const-qualified type. A straightforward fix is: \"const struct ResponseContentCallbackParam *const param = (const struct ResponseContentCallbackParam *) cls;\" (or without the explicit cast in plain C). If the code did need to modify the structure then the current declaration would be appropriate, but given the shown usage the report of a violation is correct."
}