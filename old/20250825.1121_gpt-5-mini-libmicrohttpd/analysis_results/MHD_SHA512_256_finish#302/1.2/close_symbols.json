{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, '__builtin_bswap64': {'callees': [], 'callers': ['sha512_256_transform', 'MHD_SHA512_256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "sha512_256_transform",
    "__builtin_bswap64",
    "__builtin_rotateright64",
    "_MHD_PUT_64BIT_BE",
    "_MHD_PUT_64BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT64_ALIGN",
    "struct Sha512_256Ctx",
    "SHA512_256_BLOCK_SIZE",
    "SHA512_256_SIZE_OF_LEN_ADD",
    "SHA512_256_BLOCK_SIZE_WORDS",
    "SHA512_256_DIGEST_SIZE_WORDS",
    "SHA512_256_BYTES_IN_WORD",
    "SHA512_256_DIGEST_SIZE",
    "memcpy",
    "memset"
  ],
  "explanation": "To determine whether MHD_SHA512_256_finish uses compiler language extensions you must inspect all symbols that can introduce such extensions or change which code is compiled: \n\n- sha512_256_transform: callee; its definition may itself use compiler builtins or inline asm (the static call graph shows it calls compiler builtins). If it uses extensions, the overall operation reachable from the target uses extensions. \n- __builtin_bswap64: a GCC/Clang builtin shown in the call graph and invoked (directly or via macros); this is an explicit compiler extension and must be checked where it is referenced or introduced by macros/inline code. \n- __builtin_rotateright64: shown as used by sha512_256_transform in the call graph; it is a compiler builtin/extension and must be inspected in the callee. \n- _MHD_PUT_64BIT_BE: macro/function used to store 64-bit words in big-endian form. Its expansion may use compiler builtins, unaligned accesses, or compiler-specific constructs \u2014 inspect its definition to detect extensions. \n- _MHD_PUT_64BIT_BE_UNALIGNED: conditional macro controlling how _MHD_PUT_64BIT_BE is implemented; different branches may introduce or avoid extensions. \n- MHD_FAVOR_SMALL_CODE: conditional compilation macro that changes which code path is used for storing the digest; different paths may avoid or rely on extensions. \n- _MHD_UINT64_ALIGN: alignment constant used in the alignment check; alignment handling may cause use of nonstandard constructs (e.g. unaligned accesses, compiler-specific pragmas) depending on its definition. \n- struct Sha512_256Ctx: the context layout (types of buffer, H, count, count_bits_hi, alignment of buffer) is needed to see whether any pointer casts, unaligned stores or assumptions rely on compiler-specific behavior. \n- SHA512_256_BLOCK_SIZE: block-size constant used for buffer math; its value affects which branches execute and whether padding code uses any special constructs. \n- SHA512_256_SIZE_OF_LEN_ADD: size of length field; affects branch decisions and padding; required to follow conditional branches that may be implemented with extensions. \n- SHA512_256_BLOCK_SIZE_WORDS: used as index into buffer for _MHD_PUT_64BIT_BE \u2014 needed to inspect exact addresses used by the macro that may expand to extension code. \n- SHA512_256_DIGEST_SIZE_WORDS: determines size of temporary aligned array used when alignment handling chooses that path; inspect code generated for that path. \n- SHA512_256_BYTES_IN_WORD: used for digest offsets in _MHD_PUT_64BIT_BE calls; needed to see macro parameterization and any potential extension use. \n- SHA512_256_DIGEST_SIZE: size passed to memcpy when copying the digest; need to confirm that memcpy is used and not a compiler-specific replacement. \n- memcpy / memset: standard library functions used here; they are normally not compiler extensions, but they can be implemented as macros or inlined with compiler builtins (or replaced by compiler-specific intrinsics). Their definitions/context should be checked for extension usage.\n\nInspecting these symbols (definitions and conditional compilation branches) is necessary to determine whether any compiler-specific builtins, intrinsics, inline asm, or other documented language extensions are actually used by the target function or by code paths it can take."
}