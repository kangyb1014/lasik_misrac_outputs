{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, '__builtin_bswap64': {'callees': [], 'callers': ['sha512_256_transform', 'MHD_SHA512_256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "sha512_256_transform",
    "__builtin_rotateright64",
    "__builtin_bswap64",
    "ROTR64 / rotate-right macro(s) used by sha512_256_transform",
    "CH/MAJ/SIGMA / small macros used by sha512_256_transform (e.g. Sigma0_64, Sigma1_64, sigma0_64, sigma1_64, CH, MAJ)",
    "K (round-constant) array used by sha512_256_transform",
    "struct Sha512_256Ctx (definition: fields buffer, count, count_bits_hi, H, etc.)",
    "_MHD_PUT_64BIT_BE (macro or function)",
    "_MHD_PUT_64BIT_BE_UNALIGNED (conditional macro)",
    "SHA512_256_BLOCK_SIZE",
    "SHA512_256_SIZE_OF_LEN_ADD",
    "SHA512_256_BLOCK_SIZE_WORDS",
    "SHA512_256_DIGEST_SIZE",
    "SHA512_256_DIGEST_SIZE_WORDS",
    "SHA512_256_BYTES_IN_WORD",
    "MHD_FAVOR_SMALL_CODE (compile-time flag)",
    "_MHD_UINT64_ALIGN (alignment macro)",
    "STORE/PUT 64-bit BE helper macros used by _MHD_PUT_64BIT_BE"
  ],
  "explanation": "Why each symbol is required to check MISRA 'well\u2011formed for loop' for MHD_SHA512_256_finish\n\n- sha512_256_transform\n  - Primary callee that the target invokes twice. It almost certainly contains the compression loop(s) (for rounds). To decide if any for loop reachable from the target is well\u2011formed we must inspect this function source (loop headers, counters, side effects and whether loop counters are modified in the body or by called functions).\n\n- __builtin_rotateright64\n  - Intrinsic used inside sha512_256_transform for bit rotations. We need its usage to understand the transform body; while the builtin itself does not introduce loops, it is part of the loop body behaviour and must be seen to determine whether it affects loop counters or has side effects (it should not, but confirmation is required for MISRA analysis).\n\n- __builtin_bswap64\n  - Used by the transform (and called directly by the target in some contexts). Confirming its usage ensures it does not modify loop counters or introduce side effects relevant to clause 2/3 of the rule.\n\n- ROTR64 / rotate-right macro(s)\n  - Many implementations wrap builtin rotates in macros (ROTR64). The macro definition must be inspected to ensure it contains no hidden state or side effects and does not violate the 'no persistent side effects' requirement when used in loop conditions or bodies.\n\n- CH/MAJ/SIGMA helper macros (Sigma0_64, Sigma1_64, sigma0_64, sigma1_64, CH, MAJ)\n  - Typical SHA\u2011512 code implements these as macros or inline functions used inside the round loop. Their definitions must be checked for side effects or hidden modifications of objects that could violate the rule (e.g. modifying global state or modifying the loop counter indirectly).\n\n- K (round-constant) array\n  - The round constants and any message-schedule arrays (W) are indexed inside the round loop. We must inspect them to ensure indexing uses only the loop counter and not other objects that are modified in the loop body (clause 2) and that the loop bounds are correctly derived.\n\n- struct Sha512_256Ctx (definition)\n  - The target manipulates ctx->buffer, ctx->count, ctx->H etc., and passes ctx->H and ctx->buffer to sha512_256_transform. The transform may use or modify fields of the struct (e.g. H, buffer). Knowing the exact fields is necessary to see whether any for loop in callees uses objects that are also modified in the loop body (disallowed by clause 2/3) or whether extra loop counters may be present.\n\n- _MHD_PUT_64BIT_BE (macro/function)\n  - Used in the target to store digest words and in some builds may be a small loop or use byte-wise stores. Its definition must be checked to ensure it does not contain for loops with improper loop counters or side effects that could affect the overall MISRA analysis (especially if it is invoked inside a for loop in a callee).\n\n- _MHD_PUT_64BIT_BE_UNALIGNED (conditional macro)\n  - Controls different code paths for writing the digest. Different implementations can introduce different code (including loops). We must inspect both variants to ensure none contain ill\u2011formed for loops.\n\n- SHA512_256_BLOCK_SIZE, SHA512_256_SIZE_OF_LEN_ADD, SHA512_256_BLOCK_SIZE_WORDS, SHA512_256_DIGEST_SIZE, SHA512_256_DIGEST_SIZE_WORDS, SHA512_256_BYTES_IN_WORD\n  - These compile\u2011time constants define buffer sizes, array indexes and offsets used both in the target and in sha512_256_transform. They determine loop bounds and indexing expressions; to check clause 1 and 2 (loop counter initialization and loop condition expressions) we need the actual numeric values or definitions.\n\n- MHD_FAVOR_SMALL_CODE (compile-time flag)\n  - Alters which code paths are compiled (the target uses #ifndef MHD_FAVOR_SMALL_CODE to select alternate implementations). Different code paths could contain different loops; the MISRA check must consider the actual compiled path(s), so the flag definition is required.\n\n- _MHD_UINT64_ALIGN (alignment macro)\n  - Used in a runtime alignment check that selects between two code paths (one of which copies via a temporary). That different code path may use different store implementations (and thus different macros/functions) potentially containing loops; we must inspect them.\n\n- STORE/PUT 64-bit BE helper macros used by _MHD_PUT_64BIT_BE\n  - If _MHD_PUT_64BIT_BE expands to helper macros such as STORE64_BE or byte-wise loops, those definitions must be inspected for loop headers and side effects.\n\nNote: Standard library calls used here (memset, memcpy) are invoked but are not examined for MISRA for\u2011loop structure in this analysis because they are external library functions; MISRA analysis for 'for loop shall be well\u2011formed' is focused on source code loops visible in target and its callees. The above list contains the source-level symbols and macros that can contain for loops or affect loop headers/conditions reachable from MHD_SHA512_256_finish and therefore are necessary to decide compliance."
}