{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, '__builtin_bswap64': {'callees': [], 'callers': ['sha512_256_transform', 'MHD_SHA512_256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx",
    "SHA512_256_BLOCK_SIZE",
    "SHA512_256_SIZE_OF_LEN_ADD",
    "SHA512_256_BLOCK_SIZE_WORDS",
    "SHA512_256_DIGEST_SIZE",
    "SHA512_256_DIGEST_SIZE_WORDS",
    "SHA512_256_BYTES_IN_WORD",
    "_MHD_PUT_64BIT_BE",
    "_MHD_PUT_64BIT_BE_UNALIGNED",
    "_MHD_UINT64_ALIGN",
    "MHD_FAVOR_SMALL_CODE",
    "memset",
    "memcpy",
    "sha512_256_transform",
    "digest_calc_hash"
  ],
  "explanation": "Why each symbol is needed to check the string.h uses (memset, memcpy) for out\u2011of\u2011bounds accesses:\n\n- struct Sha512_256Ctx\n  - Required to know the exact types, layout and declared sizes of members used in the function: ctx->buffer (type and number of elements), ctx->count, ctx->count_bits_hi and ctx->H. The memset calls and the _MHD_PUT_64BIT_BE writes target ctx->buffer, so you must know the buffer size and element type to determine whether the computed offsets and lengths stay within the object bounds.\n\n- SHA512_256_BLOCK_SIZE\n  - The memset length calculations and buffer bounds are expressed in terms of SHA512_256_BLOCK_SIZE. You need its numeric value to confirm that memset(...) sizes (e.g. SHA512_256_BLOCK_SIZE - bytes_have) do not exceed the actual buffer storage.\n\n- SHA512_256_SIZE_OF_LEN_ADD\n  - Used in the test for whether to pad the current block and in the second memset size (SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have). Its value is required to verify that the computed length is non\u2011negative and within buffer bounds.\n\n- SHA512_256_BLOCK_SIZE_WORDS\n  - Used when writing the length into ctx->buffer via _MHD_PUT_64BIT_BE(ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2, ...). You need this to translate the word index into a byte offset and confirm those writes fall inside ctx->buffer.\n\n- SHA512_256_DIGEST_SIZE\n  - memcpy copies SHA512_256_DIGEST_SIZE bytes into the caller-supplied digest pointer. To check that memcpy cannot write past digest, you must know this size.\n\n- SHA512_256_DIGEST_SIZE_WORDS\n  - Used to size the temporary aligned array alig_dgst[]; needed to ensure that alig_dgst is large enough for _MHD_PUT_64BIT_BE writes and that the subsequent memcpy size matches that array.\n\n- SHA512_256_BYTES_IN_WORD\n  - Used to compute pointer offsets when writing the final digest via _MHD_PUT_64BIT_BE((void *)(digest + X * SHA512_256_BYTES_IN_WORD), ...). Its value is needed to calculate the destination addresses and ensure they are within the digest buffer bounds.\n\n- _MHD_PUT_64BIT_BE\n  - This macro/function performs writes (8\u2011byte stores) into the provided pointer. You must inspect its definition to know how many bytes it writes, whether it uses byte pointers or uint64_t pointers, and whether it requires alignment \u2014 all relevant to whether these writes stay within the intended object and do not cause unaligned stores past bounds.\n\n- _MHD_PUT_64BIT_BE_UNALIGNED\n  - Controls conditional compilation and therefore whether the code path uses the aligned temporary buffer+memcpy or writes directly into digest. Knowing whether this macro is defined affects which memory writes actually occur and must be examined for bounds safety.\n\n- _MHD_UINT64_ALIGN\n  - The alignment test (using this value) determines whether the code enters the aligned-temp-buffer branch. Its numeric value (alignment requirement) and how it is used affect whether the direct writes to digest are executed and whether alignment constraints might cause use of the temp buffer+memcpy path.\n\n- MHD_FAVOR_SMALL_CODE\n  - This macro changes the conditional compilation of branches that affect whether aligned temporary buffer + memcpy are used or direct _MHD_PUT_64BIT_BE writes occur. The active code path depends on it; you must know its state to analyze the actual string.h calls made.\n\n- memset\n  - The rule under analysis concerns string.h functions: these specific uses of memset must be checked against the actual buffer address, offset (bytes_have), and length arguments. The standard semantics (fills n bytes starting at pointer) are used to verify no write past ctx->buffer.\n\n- memcpy\n  - The use memcpy(digest, alig_dgst, SHA512_256_DIGEST_SIZE) must be verified: the destination digest must be at least SHA512_256_DIGEST_SIZE bytes long. To ensure no out\u2011of\u2011bounds write, you need to inspect caller(s) and allocation of digest.\n\n- sha512_256_transform\n  - Although this is not a string.h function, it operates on ctx->buffer and ctx->H. To be thorough you should inspect its prototype/implementation to ensure it does not alter buffer sizes or reinterpret pointers in a way that changes assumptions used for the memset/macro writes (e.g. if it reuses or reallocates ctx->buffer). At minimum its prototype shows how ctx->buffer is typed (byte vs word array) and confirms expectations about buffer layout.\n\n- digest_calc_hash\n  - This function is a caller of MHD_SHA512_256_finish. To prove the memcpy(digest, ...) is safe you need to see how digest is allocated/passed by callers (digest_calc_hash and its callers) to ensure it points to a buffer of at least SHA512_256_DIGEST_SIZE bytes.\n\nNote: Standard typedefs (uint8_t, uint64_t, uintptr_t, size_t) and standard behavior of memset/memcpy are assumed; the symbols above are the additional project/local symbols/macros whose values/definitions are required to conclusively prove no out\u2011of\u2011bounds accesses for the string.h calls in MHD_SHA512_256_finish."
}