{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, '__builtin_bswap64': {'callees': [], 'callers': ['sha512_256_transform', 'MHD_SHA512_256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx (definition)",
    "_MHD_PUT_64BIT_BE (macro or function definition)",
    "_MHD_PUT_64BIT_BE_UNALIGNED (preprocessor macro)",
    "MHD_FAVOR_SMALL_CODE (preprocessor macro)",
    "_MHD_UINT64_ALIGN (macro or constant)",
    "sha512_256_transform (prototype/definition)",
    "memset (prototype/semantics)",
    "memcpy (prototype/semantics)",
    "SHA512_256_BLOCK_SIZE",
    "SHA512_256_SIZE_OF_LEN_ADD",
    "SHA512_256_BLOCK_SIZE_WORDS",
    "SHA512_256_DIGEST_SIZE",
    "SHA512_256_DIGEST_SIZE_WORDS",
    "SHA512_256_BYTES_IN_WORD"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d we must be able to prove that the formal parameters (ctx and digest) themselves are not assigned to inside MHD_SHA512_256_finish or by any callee/macros expanded in this function. The listed symbols are needed because:\n\n- struct Sha512_256Ctx (definition): needed to see exact types of ctx and its fields (buffer, count, H, count_bits_hi) and confirm ctx is a pointer parameter and whether any field access could be implemented as a hidden assignment to the parameter variable in macros/inline code.\n\n- _MHD_PUT_64BIT_BE (macro or function definition): this is invoked several times with (digest + ...) and with alig_dgst; if it is a macro it might expand to code that assigns to its pointer argument (e.g. an expression that could modify the pointer variable). You must inspect its definition to ensure it only writes through the pointer target and does not modify the pointer parameter itself.\n\n- _MHD_PUT_64BIT_BE_UNALIGNED (preprocessor macro) and MHD_FAVOR_SMALL_CODE (preprocessor macro): these control which branches are compiled. To know whether code paths that use temporaries or direct stores are present you must know the preprocessor configuration; different compiled paths could introduce code that assigns to a parameter variable (or that avoids doing so).\n\n- _MHD_UINT64_ALIGN (macro or constant): used in the runtime alignment test (modulo operation on (uintptr_t) digest). Knowing its value and semantics helps determine which conditional branch is taken and therefore which expansions of _MHD_PUT_64BIT_BE (and related code) will be used.\n\n- sha512_256_transform (prototype/definition): called with ctx->H and ctx->buffer. While callees cannot change the caller's pointer variable, you must inspect the transform implementation to ensure it is not a macro or inline function that manipulates the ctx parameter itself (or uses constructs that could expand to assignments to the ctx argument in this translation unit).\n\n- memset (prototype/semantics) and memcpy (prototype/semantics): these standard functions modify memory pointed to by their pointer arguments. To demonstrate compliance with the MISRA note (object referred to by a pointer parameter may be modified), you must confirm these are used only to modify the pointees and not to assign to the pointer variables themselves.\n\n- SHA512_256_BLOCK_SIZE, SHA512_256_SIZE_OF_LEN_ADD, SHA512_256_BLOCK_SIZE_WORDS, SHA512_256_DIGEST_SIZE, SHA512_256_DIGEST_SIZE_WORDS, SHA512_256_BYTES_IN_WORD (constants): these constants affect pointer arithmetic, buffer offsets and sizes used throughout the function and in macro expansions. Knowing their values ensures that buffer indexing/offset arithmetic cannot be compiled into constructs that assign to the parameter variables (for example, via macros that take word indices) and confirms that writes are to pointees within buffer bounds rather than to the parameter variables.\n\nIn short, to prove the function does not modify its parameter variables you must inspect the struct layout, conditional compilation macros, and the exact definitions of the macros/functions used to write data (particularly _MHD_PUT_64BIT_BE), plus the size/offset constants that influence pointer arithmetic and macro expansion."
}