{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_finish': {'callees': ['sha512_256_transform', '__builtin_bswap64'], 'callers': ['digest_calc_hash']}, 'sha512_256_transform': {'callees': ['__builtin_rotateright64', '__builtin_bswap64'], 'callers': ['MHD_SHA512_256_update', 'MHD_SHA512_256_finish']}, '__builtin_bswap64': {'callees': [], 'callers': ['sha512_256_transform', 'MHD_SHA512_256_finish']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha512_256Ctx",
    "SHA512_256_BLOCK_SIZE",
    "SHA512_256_SIZE_OF_LEN_ADD",
    "SHA512_256_BLOCK_SIZE_WORDS",
    "SHA512_256_DIGEST_SIZE",
    "SHA512_256_DIGEST_SIZE_WORDS",
    "SHA512_256_BYTES_IN_WORD",
    "_MHD_PUT_64BIT_BE",
    "_MHD_PUT_64BIT_BE_UNALIGNED",
    "MHD_FAVOR_SMALL_CODE",
    "_MHD_UINT64_ALIGN",
    "sha512_256_transform",
    "memset",
    "memcpy",
    "__builtin_bswap64",
    "uintptr_t"
  ],
  "explanation": "To determine whether any portion of MHD_SHA512_256_finish is compile-time or runtime unreachable you must know all macros, constants, types and callees that affect conditional compilation and conditional statements inside the function:\n\n- struct Sha512_256Ctx: needed to know types and ranges of fields used (ctx->count, ctx->buffer, ctx->H, ctx->count_bits_hi). The reachability of branches depends on how count and buffer types/alignments are defined.\n\n- SHA512_256_BLOCK_SIZE: used to compute bytes_have and buffer sizes; it determines the domain of bytes_have and whether the 'if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)' branch can ever be true.\n\n- SHA512_256_SIZE_OF_LEN_ADD: size of length field appended to final block; its relation to BLOCK_SIZE directly controls the conditional that selects an extra block \u2014 critical for reachability analysis.\n\n- SHA512_256_BLOCK_SIZE_WORDS: used for placement of the 64-bit length words in the buffer; needed to reason about pointer arithmetic and whether those writes are within bounds / compiled.\n\n- SHA512_256_DIGEST_SIZE, SHA512_256_DIGEST_SIZE_WORDS, SHA512_256_BYTES_IN_WORD: constants that determine how many _MHD_PUT_64BIT_BE calls are emitted and layout of the digest copies (affects which code paths and copies exist).\n\n- _MHD_PUT_64BIT_BE: macro/function doing big-endian 64-bit store; its definition may expand to different code (possibly calling __builtin_bswap64 or doing aligned writes) and can affect whether particular calls or builtins are present \u2014 therefore impacts reachability.\n\n- _MHD_PUT_64BIT_BE_UNALIGNED: conditional compilation macro that gates large portions of the aligned/unaligned store code. Whether it is defined determines which blocks are present in the compiled function (compile-time unreachable vs present).\n\n- MHD_FAVOR_SMALL_CODE: conditional compilation macro used together with the alignment checks to select alternate code paths. Its definition changes which 'if' / 'else' fragments are compiled in.\n\n- _MHD_UINT64_ALIGN: value used in the alignment test (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN). The numeric value and its presence affect whether the runtime alignment test can be true/false and whether the aligned-path code is reachable.\n\n- sha512_256_transform: called to process blocks. Knowing this callee is required to see whether the processing-call sites are reachable (they are inside branches whose reachability depends on constants/inputs).\n\n- memset, memcpy: standard library functions used in padding and final copy/erase. Their presence does not change reachability but are part of code paths whose inclusion must be considered when determining unreachable code.\n\n- __builtin_bswap64: shown in the call graph and potentially used inside _MHD_PUT_64BIT_BE; its use or absence may be conditional on macro definitions and affects which builtins appear in compiled code.\n\n- uintptr_t: the cast in the alignment test uses uintptr_t; understanding its size/alignment semantics is necessary to reason about the compile-time reducibility of the alignment expression.\n\nIn short: to decide if any if/else, #ifndef/#if blocks or branches in MHD_SHA512_256_finish are impossible (unreachable) you must know the struct layout and the values/definitions of the listed macros/constants and the definitions/expansions of the put/store macro and related builtins. These symbols are the minimal set that influence whether code is compiled in or whether a conditional can ever evaluate to true/false."
}