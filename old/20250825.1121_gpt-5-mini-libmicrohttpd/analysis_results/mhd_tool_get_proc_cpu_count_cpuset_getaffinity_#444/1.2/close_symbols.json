{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_cpuset_getaffinity_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_CPUSET_GETAFFINITY)\n  /* FreeBSD style */\n  if (0 >= ret)\n  {\n    cpuset_t cur_mask;\n    /* The should get \"anonymous\" mask/set. The anonymous mask is always\n       a subset of the assigned set (which is a subset of the root set). */\n    if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                 sizeof (cur_mask), &cur_mask))\n    {\n#ifdef HAVE_CPU_COUNT\n      ret = CPU_COUNT (&cur_mask);\n#else  /* ! HAVE_CPU_COUNT */\n      unsigned int i;\n      ret = 0;\n      for (i = 0; i < CPU_SETSIZE_SAFE; ++i)\n      {\n        if (CPU_ISSET (i, &cur_mask))\n          ++ret;\n      }\n      if (0 == ret)\n        ret = -1;\n#endif /* ! HAVE_CPU_COUNT */\n    }\n  }\n#ifdef HAVE_CPU_COUNT_S\n  if (0 >= ret)\n  {\n    /* Use 256 times larger size than size for default maximum CPU number.\n       Hopefully it would be enough even for exotic situations. */\n    static const unsigned int mask_size_cpus = 256 * CPU_SETSIZE;\n    const size_t mask_size_bytes = CPU_ALLOC_SIZE (mask_size_cpus);\n    cpuset_t *p_mask;\n\n    p_mask = CPU_ALLOC (mask_size_cpus);\n    if (NULL != p_mask)\n    {\n      if (0 == cpuset_getaffinity (CPU_LEVEL_WHICH, CPU_WHICH_PID, (id_t) -1,\n                                   mask_size_bytes, p_mask))\n      {\n#ifndef MHD_FUNC_CPU_COUNT_S_GETS_CPUS\n        ret = CPU_COUNT_S (mask_size_bytes, p_mask);\n#else  /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n        ret = CPU_COUNT_S (mask_size_cpus, p_mask);\n#endif /* MHD_FUNC_CPU_COUNT_S_GETS_CPUS */\n      }\n      CPU_FREE (p_mask);\n    }\n  }\n#endif /* HAVE_CPU_COUNT_S */\n#endif /* HAVE_CPUSET_GETAFFINITY */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CPUSET_GETAFFINITY",
    "HAVE_CPU_COUNT",
    "HAVE_CPU_COUNT_S",
    "MHD_FUNC_CPU_COUNT_S_GETS_CPUS",
    "cpuset_getaffinity",
    "cpuset_t",
    "CPU_LEVEL_WHICH",
    "CPU_WHICH_PID",
    "id_t",
    "CPU_COUNT",
    "CPU_COUNT_S",
    "CPU_SETSIZE_SAFE",
    "CPU_SETSIZE",
    "CPU_ISSET",
    "CPU_ALLOC_SIZE",
    "CPU_ALLOC",
    "CPU_FREE"
  ],
  "explanation": "For each symbol:\n- HAVE_CPUSET_GETAFFINITY, HAVE_CPU_COUNT, HAVE_CPU_COUNT_S, MHD_FUNC_CPU_COUNT_S_GETS_CPUS: Preprocessor feature macros determine which branches of the function are compiled. To decide if an extension is used you must know which code is active.\n- cpuset_getaffinity: The call site could reference a function with compiler-specific attributes or non\u2011standard linkage/variadic behavior. Its prototype/definition must be inspected for extensions (attributes, calling conventions, builtin usage).\n- cpuset_t: The type of cur_mask / p_mask may be an implementation type (macro typedef or struct) that itself uses compiler extensions (nonstandard layout, attributes, packed/bitfield extensions). Its definition is required.\n- CPU_LEVEL_WHICH, CPU_WHICH_PID: These macros/constants may be defined by system headers in a way that uses compiler extensions (enum macros, extension attributes); need to check their definitions.\n- id_t: The cast (id_t) -1 is used; id_t's underlying type and any nonstandard typedef/attributes must be known to judge if an extension is used.\n- CPU_COUNT: Usually a macro/function; its implementation may use compiler builtins or extension constructs (e.g., GCC __builtin_popcount, typeof, statement\u2011expressions). Inspecting it is required.\n- CPU_COUNT_S: Same rationale as CPU_COUNT \u2014 different variants may use compiler extensions or nonstandard parameter semantics.\n- CPU_SETSIZE_SAFE, CPU_SETSIZE: These constants control loop bounds and allocation sizes; their definitions may be implementation macros or computed using extensions.\n- CPU_ISSET: Typically a macro that may use extensions (statement expressions, typeof, inline assembly); must be checked for extension usage.\n- CPU_ALLOC_SIZE, CPU_ALLOC, CPU_FREE: These macros/functions allocate and size the cpuset buffer; their implementations (macros using typeof/statement expressions, inlines with attributes) may be compiler\u2011specific. They must be inspected.\n\nIn short: to determine whether this function violates the MISRA rule against language/compiler extensions you must know which compile-time branches are taken and whether any called macros, types or helper functions expand to or are implemented with compiler-specific extensions. The symbols above are the minimal set needed to make that determination."
}