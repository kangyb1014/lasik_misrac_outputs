{
  "user_message": "An agent A claimed that the following find_entry_by_username code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_username.\n```c\nstatic struct UserEntry *\nfind_entry_by_username (const char *const username)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n  {\n    struct UserEntry *entry;\n\n    entry = user_ids + i;\n    if (0 == strcmp (username, entry->username))\n      return entry;\n  }\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. The call strcmp(username, entry->username) can read beyond object bounds if either pointer is NULL or not NUL-terminated. The function does not validate username for NULL or termination before calling strcmp; username is sourced from external/auth code (username_info->username) and could be attacker-controlled or malformed. For example, if username_info->username is NULL or points to a non-terminated buffer, strcmp will perform out\u2011of\u2011bounds reads, violating MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_username:\nstatic struct UserEntry user_ids[2]\n...\nstruct UserEntry\n{\n  /**\n   * The username.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *username;\n#if 0 /* Disabled code */\n  /* The cleartext password is not stored in the database.\n     The more secure \"userdigest\" is used instead. */\n  /**\n   * The password.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *password;\n#endif /* Disabled code */\n  /**\n   * The realm for this entry.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *realm;\n\n  /**\n   * The MD5 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_md5[MHD_MD5_DIGEST_SIZE];\n  /**\n   * The MD5 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_md5[MHD_MD5_DIGEST_SIZE];\n\n  /**\n   * The SHA-256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha256[MHD_SHA256_DIGEST_SIZE];\n  /**\n   * The SHA-256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha256[MHD_SHA256_DIGEST_SIZE];\n\n  /**\n   * The SHA-512/256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n  /**\n   * The SHA-512/256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n\n  /**\n   * User has access to \"area 1\" if non-zero\n   */\n  int allow_area_1;\n\n  /**\n   * User has access to \"area 2\" if non-zero\n   */\n  int allow_area_2;\n}\n...\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n...\nstatic enum MHD_Result\nhandle_sec_areas_req (struct MHD_Connection *c, const char *url, unsigned int\n                      sec_area_num)\n{\n  struct MHD_DigestAuthUsernameInfo *username_info;\n  struct UserEntry *user_entry;\n  void *userdigest;\n  size_t userdigest_size;\n  enum MHD_DigestAuthResult auth_res;\n\n  username_info = MHD_digest_auth_get_username3 (c);\n\n  if (NULL == username_info)\n    return reply_with_auth_required (c, 0, 0);\n\n  user_entry = find_entry_by_userinfo (username_info);\n\n  if (NULL == user_entry)\n    return reply_with_auth_required (c, 0, 1);\n\n  switch (username_info->algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n    userdigest = user_entry->userdigest_md5;\n    userdigest_size = sizeof(user_entry->userdigest_md5);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n    userdigest = user_entry->userdigest_sha256;\n    userdigest_size = sizeof(user_entry->userdigest_sha256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n    userdigest = user_entry->userdigest_sha512_256;\n    userdigest_size = sizeof(user_entry->userdigest_sha512_256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION:\n    /* Not supported currently and not used by MHD.\n       The client incorrectly used algorithm not advertised by the server. */\n    return reply_with_auth_required (c, 0, 1);\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning */\n  default:\n    return MHD_NO; /* Should be unreachable */\n  }\n\n  auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM, /* Make sure to use the proper realm, not the realm provided by the client and returned by \"user_entry\" */\n    user_entry->username,\n    userdigest,\n    userdigest_size,\n    0, /* Use daemon's default value for nonce_timeout*/\n    0, /* Use daemon's default value for max_nc */\n    get_m_QOP (),\n    (enum MHD_DigestAuthMultiAlgo3) username_info->algo3 /* Direct cast from \"single algorithm\" to \"multi-algorithm\" is allowed */\n    );\n\n  if (MHD_DAUTH_OK != auth_res)\n  {\n    int need_just_refresh_nonce;\n    /* Actually MHD_DAUTH_NONCE_OTHER_COND should not be returned as\n       MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE is not used for the daemon.\n       To keep the code universal the MHD_DAUTH_NONCE_OTHER_COND is\n       still checked here. */\n    need_just_refresh_nonce =\n      (MHD_DAUTH_NONCE_STALE == auth_res)\n      || (MHD_DAUTH_NONCE_OTHER_COND == auth_res);\n    return reply_with_auth_required (c,\n                                     need_just_refresh_nonce,\n                                     ! need_just_refresh_nonce);\n  }\n\n  /* The user successfully authenticated */\n\n  /* Check whether access to the request area is allowed for the user */\n  if (1 == sec_area_num)\n  {\n    if (user_entry->allow_area_1)\n      return reply_with_area1_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n  else if (2 == sec_area_num)\n  {\n    if (user_entry->allow_area_2)\n      return reply_with_area2_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n\n  return MHD_NO; /* Should be unreachable */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C Rule 21.17 forbids invoking string.h functions in a way that can read beyond the bounds of the objects referenced by the pointer parameters (e.g. passing NULL or non\u2011NUL\u2011terminated char * to strcmp). The call strcmp(username, entry->username) would indeed be problematic if either pointer were NULL or pointed to a non\u2011NUL\u2011terminated buffer. However, in the provided code context there is no evidence that such invalid pointers can arise:\n\n- entry->username is part of a static user_ids table and is documented as static data (i.e. string literals / static buffers). Those are expected to be non\u2011NULL and NUL\u2011terminated.\n- find_entry_by_username is a static function used only via find_entry_by_userinfo. That caller ensures username_info is non\u2011NULL and only calls find_entry_by_username when uname_type indicates the \u201cstandard\u201d username form. The same username value is later passed to MHD_digest_auth_check_digest3 which also expects a valid NUL\u2011terminated username, so it is reasonable to conclude the library/userinfo API provides a valid, NUL\u2011terminated username pointer.\n\nBecause the function is internal (static) and all call sites in the translation unit enforce the preconditions, the use of strcmp does not demonstrably violate Rule 21.17 in this code as presented. If there were no such caller guarantees, the code would need to validate the pointers (or document the precondition) to comply with Rule 21.17. To be defensive (and satisfy MISRA without relying on external invariants) you could add an explicit non\u2011NULL check on username or assert the precondition.\n\nConclusion: the reported violation is not correct for the given code/context. If the external API did not guarantee NUL\u2011terminated/non\u2011NULL usernames, then the report would be correct, but that guarantee appears to exist here."
}