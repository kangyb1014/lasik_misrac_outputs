{
  "user_message": "Target function code is:\n```c\nstatic void\nsha256_transform (uint32_t H[SHA256_DIGEST_SIZE_WORDS],\n                  const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 paragraph 6.2. */\n  uint32_t a = H[0];\n  uint32_t b = H[1];\n  uint32_t c = H[2];\n  uint32_t d = H[3];\n  uint32_t e = H[4];\n  uint32_t f = H[5];\n  uint32_t g = H[6];\n  uint32_t h = H[7];\n\n  /* Data buffer, used as cyclic buffer.\n     See FIPS PUB 180-4 paragraphs 5.2.1, 6.2. */\n  uint32_t W[16];\n\n#ifndef _MHD_GET_32BIT_BE_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT32_ALIGN))\n  {\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, SHA256_BLOCK_SIZE);\n    /* The W[] buffer itself will be used as the source of the data,\n     * but data will be reloaded in correct bytes order during\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_32BIT_BE_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimization.\n     See FIPS PUB 180-4 formulae 4.2, 4.3. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.4, 4.5, 4.6, 4.7. */\n#define SIG0(x)  (_MHD_ROTR32 ((x), 2) ^ _MHD_ROTR32 ((x), 13) ^ \\\n                  _MHD_ROTR32 ((x), 22) )\n#define SIG1(x)  (_MHD_ROTR32 ((x), 6) ^ _MHD_ROTR32 ((x), 11) ^ \\\n                  _MHD_ROTR32 ((x), 25) )\n#define sig0(x)  (_MHD_ROTR32 ((x), 7) ^ _MHD_ROTR32 ((x), 18) ^ \\\n                  ((x) >> 3) )\n#define sig1(x)  (_MHD_ROTR32 ((x), 17) ^ _MHD_ROTR32 ((x),19) ^ \\\n                  ((x) >> 10) )\n\n  /* One step of SHA-256 computation,\n     see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n           second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in FIPS PUB 180-4 paragraph 6.2.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other data as well\n           every time when used. */\n#define SHA2STEP32(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer,\n     See FIPS PUB 180-4 paragraph 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 paragraph 3.1.2. */\n  /* Use cast to (const void*) to mute compiler alignment warning,\n   * data was already aligned in previous step */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_BE ((const void*)(((const uint8_t*) (buf)) + \\\n                                   (t) * SHA256_BYTES_IN_WORD))\n\n  /* 'W' generation and assignment for 16 <= t <= 63.\n     See FIPS PUB 180-4 paragraph 6.2.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as cyclic buffer.\n   * Note: ((t-16)&0xf) have same value as (t&0xf) */\n#define Wgen(w,t) ( (w)[(t - 16) & 0xf] + sig1 ((w)[((t) - 2) & 0xf])   \\\n                    + (w)[((t) - 7) & 0xf] + sig0 ((w)[((t) - 15) & 0xf]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP32(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP32(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7]);\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8]);\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9]);\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10]);\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11]);\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12]);\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13]);\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14]);\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x428a2f98), W[0] = \\\n                  GET_W_FROM_DATA (data, 0));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x71374491), W[1] = \\\n                  GET_W_FROM_DATA (data, 1));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb5c0fbcf), W[2] = \\\n                  GET_W_FROM_DATA (data, 2));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xe9b5dba5), W[3] = \\\n                  GET_W_FROM_DATA (data, 3));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x3956c25b), W[4] = \\\n                  GET_W_FROM_DATA (data, 4));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x59f111f1), W[5] = \\\n                  GET_W_FROM_DATA (data, 5));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x923f82a4), W[6] = \\\n                  GET_W_FROM_DATA (data, 6));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xab1c5ed5), W[7] = \\\n                  GET_W_FROM_DATA (data, 7));\n    SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xd807aa98), W[8] = \\\n                  GET_W_FROM_DATA (data, 8));\n    SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x12835b01), W[9] = \\\n                  GET_W_FROM_DATA (data, 9));\n    SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x243185be), W[10] = \\\n                  GET_W_FROM_DATA (data, 10));\n    SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x550c7dc3), W[11] = \\\n                  GET_W_FROM_DATA (data, 11));\n    SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x72be5d74), W[12] = \\\n                  GET_W_FROM_DATA (data, 12));\n    SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x80deb1fe), W[13] = \\\n                  GET_W_FROM_DATA (data, 13));\n    SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x9bdc06a7), W[14] = \\\n                  GET_W_FROM_DATA (data, 14));\n    SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc19bf174), W[15] = \\\n                  GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 48 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xe49b69c1), W[16 & 0xf] = \\\n                Wgen (W,16));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xefbe4786), W[17 & 0xf] = \\\n                Wgen (W,17));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x0fc19dc6), W[18 & 0xf] = \\\n                Wgen (W,18));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x240ca1cc), W[19 & 0xf] = \\\n                Wgen (W,19));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x2de92c6f), W[20 & 0xf] = \\\n                Wgen (W,20));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4a7484aa), W[21 & 0xf] = \\\n                Wgen (W,21));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5cb0a9dc), W[22 & 0xf] = \\\n                Wgen (W,22));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x76f988da), W[23 & 0xf] = \\\n                Wgen (W,23));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x983e5152), W[24 & 0xf] = \\\n                Wgen (W,24));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa831c66d), W[25 & 0xf] = \\\n                Wgen (W,25));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xb00327c8), W[26 & 0xf] = \\\n                Wgen (W,26));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xbf597fc7), W[27 & 0xf] = \\\n                Wgen (W,27));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xc6e00bf3), W[28 & 0xf] = \\\n                Wgen (W,28));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd5a79147), W[29 & 0xf] = \\\n                Wgen (W,29));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x06ca6351), W[30 & 0xf] = \\\n                Wgen (W,30));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x14292967), W[31 & 0xf] = \\\n                Wgen (W,31));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x27b70a85), W[32 & 0xf] = \\\n                Wgen (W,32));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x2e1b2138), W[33 & 0xf] = \\\n                Wgen (W,33));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x4d2c6dfc), W[34 & 0xf] = \\\n                Wgen (W,34));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x53380d13), W[35 & 0xf] = \\\n                Wgen (W,35));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x650a7354), W[36 & 0xf] = \\\n                Wgen (W,36));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x766a0abb), W[37 & 0xf] = \\\n                Wgen (W,37));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x81c2c92e), W[38 & 0xf] = \\\n                Wgen (W,38));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x92722c85), W[39 & 0xf] = \\\n                Wgen (W,39));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0xa2bfe8a1), W[40 & 0xf] = \\\n                Wgen (W,40));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0xa81a664b), W[41 & 0xf] = \\\n                Wgen (W,41));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0xc24b8b70), W[42 & 0xf] = \\\n                Wgen (W,42));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0xc76c51a3), W[43 & 0xf] = \\\n                Wgen (W,43));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0xd192e819), W[44 & 0xf] = \\\n                Wgen (W,44));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xd6990624), W[45 & 0xf] = \\\n                Wgen (W,45));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xf40e3585), W[46 & 0xf] = \\\n                Wgen (W,46));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x106aa070), W[47 & 0xf] = \\\n                Wgen (W,47));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x19a4c116), W[48 & 0xf] = \\\n                Wgen (W,48));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x1e376c08), W[49 & 0xf] = \\\n                Wgen (W,49));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x2748774c), W[50 & 0xf] = \\\n                Wgen (W,50));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x34b0bcb5), W[51 & 0xf] = \\\n                Wgen (W,51));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x391c0cb3), W[52 & 0xf] = \\\n                Wgen (W,52));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0x4ed8aa4a), W[53 & 0xf] = \\\n                Wgen (W,53));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0x5b9cca4f), W[54 & 0xf] = \\\n                Wgen (W,54));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0x682e6ff3), W[55 & 0xf] = \\\n                Wgen (W,55));\n  SHA2STEP32 (a, b, c, d, e, f, g, h, UINT32_C (0x748f82ee), W[56 & 0xf] = \\\n                Wgen (W,56));\n  SHA2STEP32 (h, a, b, c, d, e, f, g, UINT32_C (0x78a5636f), W[57 & 0xf] = \\\n                Wgen (W,57));\n  SHA2STEP32 (g, h, a, b, c, d, e, f, UINT32_C (0x84c87814), W[58 & 0xf] = \\\n                Wgen (W,58));\n  SHA2STEP32 (f, g, h, a, b, c, d, e, UINT32_C (0x8cc70208), W[59 & 0xf] = \\\n                Wgen (W,59));\n  SHA2STEP32 (e, f, g, h, a, b, c, d, UINT32_C (0x90befffa), W[60 & 0xf] = \\\n                Wgen (W,60));\n  SHA2STEP32 (d, e, f, g, h, a, b, c, UINT32_C (0xa4506ceb), W[61 & 0xf] = \\\n                Wgen (W,61));\n  SHA2STEP32 (c, d, e, f, g, h, a, b, UINT32_C (0xbef9a3f7), W[62 & 0xf] = \\\n                Wgen (W,62));\n  SHA2STEP32 (b, c, d, e, f, g, h, a, UINT32_C (0xc67178f2), W[63 & 0xf] = \\\n                Wgen (W,63));\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 paragraph 4.2.2 for K values. */\n    static const uint32_t K[80] =\n    { UINT32_C (0x428a2f98),  UINT32_C (0x71374491),  UINT32_C (0xb5c0fbcf),\n      UINT32_C (0xe9b5dba5),  UINT32_C (0x3956c25b),  UINT32_C (0x59f111f1),\n      UINT32_C (0x923f82a4),  UINT32_C (0xab1c5ed5),  UINT32_C (0xd807aa98),\n      UINT32_C (0x12835b01),  UINT32_C (0x243185be),  UINT32_C (0x550c7dc3),\n      UINT32_C (0x72be5d74),  UINT32_C (0x80deb1fe),  UINT32_C (0x9bdc06a7),\n      UINT32_C (0xc19bf174),  UINT32_C (0xe49b69c1),  UINT32_C (0xefbe4786),\n      UINT32_C (0x0fc19dc6),  UINT32_C (0x240ca1cc),  UINT32_C (0x2de92c6f),\n      UINT32_C (0x4a7484aa),  UINT32_C (0x5cb0a9dc),  UINT32_C (0x76f988da),\n      UINT32_C (0x983e5152),  UINT32_C (0xa831c66d),  UINT32_C (0xb00327c8),\n      UINT32_C (0xbf597fc7),  UINT32_C (0xc6e00bf3),  UINT32_C (0xd5a79147),\n      UINT32_C (0x06ca6351),  UINT32_C (0x14292967),  UINT32_C (0x27b70a85),\n      UINT32_C (0x2e1b2138),  UINT32_C (0x4d2c6dfc),  UINT32_C (0x53380d13),\n      UINT32_C (0x650a7354),  UINT32_C (0x766a0abb),  UINT32_C (0x81c2c92e),\n      UINT32_C (0x92722c85),  UINT32_C (0xa2bfe8a1),  UINT32_C (0xa81a664b),\n      UINT32_C (0xc24b8b70),  UINT32_C (0xc76c51a3),  UINT32_C (0xd192e819),\n      UINT32_C (0xd6990624),  UINT32_C (0xf40e3585),  UINT32_C (0x106aa070),\n      UINT32_C (0x19a4c116),  UINT32_C (0x1e376c08),  UINT32_C (0x2748774c),\n      UINT32_C (0x34b0bcb5),  UINT32_C (0x391c0cb3),  UINT32_C (0x4ed8aa4a),\n      UINT32_C (0x5b9cca4f),  UINT32_C (0x682e6ff3),  UINT32_C (0x748f82ee),\n      UINT32_C (0x78a5636f),  UINT32_C (0x84c87814),  UINT32_C (0x8cc70208),\n      UINT32_C (0x90befffa),  UINT32_C (0xa4506ceb),  UINT32_C (0xbef9a3f7),\n      UINT32_C (0xc67178f2) };\n    /* One step of SHA-256 computation with working variables rotation,\n       see FIPS PUB 180-4 paragraph 6.2.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP32RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n    uint32_t tmp_h_ = (vH);                                           \\\n    SHA2STEP32((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));  \\\n    (vH) = (vG);                                                      \\\n    (vG) = (vF);                                                      \\\n    (vF) = (vE);                                                      \\\n    (vE) = (vD);                                                      \\\n    (vD) = (vC);                                                      \\\n    (vC) = (vB);                                                      \\\n    (vB) = (vA);                                                      \\\n    (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from input data buffer as big-endian value and\n       stored in array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n\n    /* During last 48 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 64; ++t)\n    {\n      SHA2STEP32RV (a, b, c, d, e, f, g, h, K[t], W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n\n  /* Compute intermediate hash.\n     See FIPS PUB 180-4 paragraph 6.2.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, '__builtin_rotateright32': {'callees': [], 'callers': ['sha256_transform']}, '__builtin_bswap32': {'callees': [], 'callers': ['sha256_transform', 'MHD_SHA256_finish']}, 'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'MHD_SHA256_finish': {'callees': ['sha256_transform', '_MHD_PUT_64BIT_BE_SAFE', '__builtin_bswap32'], 'callers': ['digest_calc_hash']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_ROTR32",
    "_MHD_GET_32BIT_BE",
    "GET_W_FROM_DATA",
    "_MHD_GET_32BIT_BE_UNALIGNED",
    "_MHD_UINT32_ALIGN",
    "_MHD_BYTE_ORDER",
    "_MHD_BIG_ENDIAN",
    "MHD_FAVOR_SMALL_CODE",
    "__builtin_rotateright32",
    "__builtin_bswap32"
  ],
  "explanation": "To decide if sha256_transform violates the MISRA rule forbidding language/compiler extensions you must see how the macros and conditional flags used in the function are defined and whether they expand to compiler-specific builtins or intrinsics. The listed symbols are required because:\n\n- _MHD_ROTR32: SIG0/SIG1/sig0/sig1 use _MHD_ROTR32. Its definition determines whether a rotate is implemented in standard C or via a compiler intrinsic/extension (e.g. __builtin_rotateright32).\n\n- __builtin_rotateright32: a known compiler builtin/extension. If _MHD_ROTR32 maps to this, the function uses a language extension and thus would violate the rule.\n\n- _MHD_GET_32BIT_BE: GET_W_FROM_DATA expands to this. Its definition determines whether byteswapping/unaligned loads are done with portable C or via a builtin/extension (e.g. __builtin_bswap32 or other intrinsics).\n\n- GET_W_FROM_DATA: the macro used directly in the function; its expansion is needed to see whether it relies on extensions or intrinsics.\n\n- __builtin_bswap32: common builtin for byte-swap/endianness; if used by _MHD_GET_32BIT_BE (or other macros), that is a language extension.\n\n- _MHD_GET_32BIT_BE_UNALIGNED: this conditional macro controls the aligned/unaligned code path. Whether that symbol is defined changes whether the code will invoke memcpy-only portable code or use an unaligned-load builtin/extension; you must know which path is taken.\n\n- _MHD_UINT32_ALIGN: used in the alignment check ((uintptr_t)data % _MHD_UINT32_ALIGN). Its value and definition matter for the alignment logic and may indicate use of nonstandard alignment helpers.\n\n- _MHD_BYTE_ORDER and _MHD_BIG_ENDIAN: select the endian-specific code path. The big-endian path avoids GET_W_FROM_DATA and therefore might avoid or use different extensions; their definitions determine which code is compiled/used.\n\n- MHD_FAVOR_SMALL_CODE: selects the alternate implementation (loop + K array). The alternate path may use different macros or intrinsics; you must know its value to know which code is present and whether that code uses extensions.\n\nKnowing the exact definitions of these macros and whether they expand to standard-C expressions or to compiler builtins/intrinsics is necessary to conclude whether sha256_transform itself uses language extensions (and thus whether it violates the MISRA rule)."
}