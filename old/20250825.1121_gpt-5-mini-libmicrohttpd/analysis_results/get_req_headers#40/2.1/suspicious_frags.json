{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_req_headers:\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function get_req_headers:\nstatic enum MHD_HdrLineReadRes_\nget_req_header (struct MHD_Connection *c,\n                bool process_footers,\n                struct _MHD_str_w_len *hdr_name,\n                struct _MHD_str_w_len *hdr_value)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2-4 */\n  const bool bare_cr_keep = (-3 >= discp_lvl);\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2-4 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n  /* Treat NUL as space; replace it with space before processing.\n     RFC 9110, section 5.5-5 */\n  const bool nul_as_sp = (-1 >= discp_lvl);\n  /* Allow folded header lines.\n     RFC 9112, section 5.2-4 */\n  const bool allow_folded = (0 >= discp_lvl);\n  /* Do not reject headers with the whitespace at the start of the first line.\n     When allowed, the first line with whitespace character at the first\n     position is ignored (as well as all possible line foldings of the first\n     line).\n     RFC 9112, section 2.2-8 */\n  const bool allow_wsp_at_start = allow_folded && (-1 >= discp_lvl);\n  /* Allow whitespace in header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_wsp_in_name = (-2 >= discp_lvl);\n  /* Allow zero-length header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_empty_name = (-2 >= discp_lvl);\n  /* Allow whitespace before colon.\n     Violates RFC 9112, section 5.1-2 */\n  const bool allow_wsp_before_colon = (-3 >= discp_lvl);\n  /* Do not abort the request when header line has no colon, just skip such\n     bad lines.\n     RFC 9112, section 5-1 */\n  const bool allow_line_without_colon = (-2 >= discp_lvl);\n\n  size_t p; /**< The position of the currently processed character */\n\n#if ! defined (HAVE_MESSAGES) && ! defined(_DEBUG)\n  (void) process_footers; /* Unused parameter */\n#endif /* !HAVE_MESSAGES && !_DEBUG */\n\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n\n  p = c->rq.hdrs.hdr.proc_pos;\n\n  mhd_assert (p <= c->read_buffer_offset);\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_len < p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || (0 != p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_end_found));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.name_len < c->rq.hdrs.hdr.value_start));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (0 != c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (0 != p)\n      {\n        /* Line is not empty, need to check for possible line folding */\n        if (p + 2 >= c->read_buffer_offset)\n          break; /* Not enough data yet to check for folded line */\n      }\n      else\n      {\n        /* Line is empty, no need to check for possible line folding */\n        if (p + 2 > c->read_buffer_offset)\n          break; /* Not enough data yet to check for the end of the line */\n      }\n      if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2-4 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        end_of_line = false;\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2-3 */\n      if (bare_lf_as_crlf)\n      {\n        if (0 != p)\n        {\n          /* Line is not empty, need to check for possible line folding */\n          if (p + 1 >= c->read_buffer_offset)\n            break; /* Not enough data yet to check for folded line */\n        }\n        end_of_line = true;\n      }\n      else\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_FOOTER);\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n    }\n    else\n      end_of_line = false;\n\n    if (end_of_line)\n    {\n      /* Handle the end of the line */\n      /**\n       *  The full length of the line, including CRLF (or bare LF).\n       */\n      const size_t line_len = p + (('\\r' == chr) ? 2 : 1);\n      char next_line_char;\n      mhd_assert (line_len <= c->read_buffer_offset);\n\n      if (0 == p)\n      {\n        /* Zero-length header line. This is the end of the request header\n           section.\n           RFC 9112, Section 2.1-1 */\n        mhd_assert (! c->rq.hdrs.hdr.starts_with_ws);\n        mhd_assert (! c->rq.hdrs.hdr.name_end_found);\n        mhd_assert (0 == c->rq.hdrs.hdr.name_len);\n        mhd_assert (0 == c->rq.hdrs.hdr.ws_start);\n        mhd_assert (0 == c->rq.hdrs.hdr.value_start);\n        /* Consume the line with CRLF (or bare LF) */\n        c->read_buffer += line_len;\n        c->read_buffer_offset -= line_len;\n        c->read_buffer_size -= line_len;\n        return MHD_HDR_LINE_READING_GOT_END_OF_HEADER;\n      }\n\n      mhd_assert (line_len < c->read_buffer_offset);\n      mhd_assert (0 != line_len);\n      mhd_assert ('\\n' == c->read_buffer[line_len - 1]);\n      next_line_char = c->read_buffer[line_len];\n      if ((' ' == next_line_char) ||\n          ('\\t' == next_line_char))\n      {\n        /* Folded line */\n        if (! allow_folded)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD_FOOTER);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        /* Replace CRLF (or bare LF) character(s) with space characters.\n           See RFC 9112, Section 5.2-4 */\n        c->read_buffer[p] = ' ';\n        if ('\\r' == chr)\n          c->read_buffer[p + 1] = ' ';\n        continue; /* Re-start processing of the current character */\n      }\n      else\n      {\n        /* It is not a folded line, it's the real end of the non-empty line */\n        bool skip_line = false;\n        mhd_assert (0 != p);\n        if (c->rq.hdrs.hdr.starts_with_ws)\n        {\n          /* This is the first line and it starts with whitespace. This line\n             must be discarded completely.\n             See RFC 9112, Section 2.2-8 */\n          mhd_assert (allow_wsp_at_start);\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (c->daemon,\n                    _ (\"Whitespace-prefixed first header line \" \\\n                       \"has been skipped.\\n\"));\n#endif /* HAVE_MESSAGES */\n          skip_line = true;\n        }\n        else if (! c->rq.hdrs.hdr.name_end_found)\n        {\n          if (! allow_line_without_colon)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_HEADER_WITHOUT_COLON);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_FOOTER_WITHOUT_COLON);\n\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          /* Skip broken line completely */\n          c->rq.skipped_broken_lines++;\n          skip_line = true;\n        }\n        if (skip_line)\n        {\n          /* Skip the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          p = 0;\n          /* Reset processing state */\n          memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n          /* Start processing of the next line */\n          continue;\n        }\n        else\n        {\n          /* This line should be valid header line */\n          size_t value_len;\n          mhd_assert ((0 != c->rq.hdrs.hdr.name_len) || allow_empty_name);\n\n          hdr_name->str = c->read_buffer + 0; /* The name always starts at the first character */\n          hdr_name->len = c->rq.hdrs.hdr.name_len;\n          mhd_assert (0 == hdr_name->str[hdr_name->len]);\n\n          if (0 == c->rq.hdrs.hdr.value_start)\n          {\n            c->rq.hdrs.hdr.value_start = p;\n            c->read_buffer[p] = 0;\n            value_len = 0;\n          }\n          else if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            mhd_assert (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start);\n            c->read_buffer[c->rq.hdrs.hdr.ws_start] = 0;\n            value_len = c->rq.hdrs.hdr.ws_start - c->rq.hdrs.hdr.value_start;\n          }\n          else\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            c->read_buffer[p] = 0;\n            value_len = p - c->rq.hdrs.hdr.value_start;\n          }\n          hdr_value->str = c->read_buffer + c->rq.hdrs.hdr.value_start;\n          hdr_value->len = value_len;\n          mhd_assert (0 == hdr_value->str[hdr_value->len]);\n          /* Consume the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          return MHD_HDR_LINE_READING_GOT_HEADER;\n        }\n      }\n    }\n    else if ((' ' == chr) || ('\\t' == chr))\n    {\n      if (0 == p)\n      {\n        if (! allow_wsp_at_start)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        c->rq.hdrs.hdr.starts_with_ws = true;\n      }\n      else if ((! c->rq.hdrs.hdr.name_end_found) &&\n               (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Whitespace in header name / between header name and colon */\n        if (allow_wsp_in_name || allow_wsp_before_colon)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.ws_start = p;\n        }\n        else\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_HEADER_NAME);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_FOOTER_NAME);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n      }\n      else\n      {\n        /* Whitespace before/inside/after header (field) value */\n        if (0 == c->rq.hdrs.hdr.ws_start)\n          c->rq.hdrs.hdr.ws_start = p;\n      }\n    }\n    else if (0 == chr)\n    {\n      if (! nul_as_sp)\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_FOOTER);\n\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n      c->read_buffer[p] = ' ';\n      continue; /* Re-start processing of the current character */\n    }\n    else\n    {\n      /* Not a whitespace, not the end of the header line */\n      mhd_assert ('\\r' != chr);\n      mhd_assert ('\\n' != chr);\n      mhd_assert ('\\0' != chr);\n      if ((! c->rq.hdrs.hdr.name_end_found) &&\n          (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Processing the header (field) name */\n        if (':' == chr)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.name_len = p;\n          else\n          {\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_before_colon)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n            c->rq.hdrs.hdr.name_len = c->rq.hdrs.hdr.ws_start;\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n          if ((0 == c->rq.hdrs.hdr.name_len) && ! allow_empty_name)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_HEADER_NAME);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_FOOTER_NAME);\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          c->rq.hdrs.hdr.name_end_found = true;\n          c->read_buffer[c->rq.hdrs.hdr.name_len] = 0; /* Zero-terminate the name */\n        }\n        else\n        {\n          if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            /* End of the whitespace in header (field) name */\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_in_name)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n        }\n      }\n      else\n      {\n        /* Processing the header (field) value */\n        if (0 == c->rq.hdrs.hdr.value_start)\n          c->rq.hdrs.hdr.value_start = p;\n#ifndef MHD_FAVOR_SMALL_CODE\n        c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n      }\n#ifdef MHD_FAVOR_SMALL_CODE\n      c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* MHD_FAVOR_SMALL_CODE */\n    }\n    p++;\n  }\n  c->rq.hdrs.hdr.proc_pos = p;\n  return MHD_HDR_LINE_READING_NEED_MORE_DATA; /* Not enough data yet */\n}\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n...\n_MHD_static_inline void\nreset_rq_header_processing_state (struct MHD_Connection *c)\n{\n  memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n}\n...\nstatic void\nhandle_req_headers_no_space (struct MHD_Connection *c,\n                             const char *add_header,\n                             size_t add_header_size)\n{\n  unsigned int err_code;\n\n  err_code = get_no_space_err_status_code (c,\n                                           MHD_PROC_RECV_HEADERS,\n                                           add_header,\n                                           add_header_size);\n  transmit_error_response_static (c,\n                                  err_code,\n                                  ERR_MSG_REQUEST_HEADER_TOO_BIG);\n}\n...\nstatic void\nhandle_req_footers_no_space (struct MHD_Connection *c,\n                             const char *add_footer,\n                             size_t add_footer_size)\n{\n  (void) add_footer; (void) add_footer_size; /* Unused */\n  mhd_assert (c->rq.have_chunked_upload);\n\n  /* Footers should be optional */\n  transmit_error_response_static (c,\n                                  MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                  ERR_MSG_REQUEST_FOOTER_TOO_BIG);\n}\n...\n#define MHD_BUF_INC_SIZE 1500\n...\n#define HTTP_VER_LEN (MHD_STATICSTR_LEN_(MHD_HTTP_VERSION_1_1))\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */",
    "mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\nbreak;",
    "else\n  c->state = MHD_CONNECTION_FOOTERS_RECEIVED;",
    "if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n{\n  /* Try to re-use some of the last bytes of the request header */\n  /* Do this only if space in the read buffer is limited AND\n     amount of read ahead data is small. */\n  const char *last_elmnt_end;\n  size_t shift_back_size;\n  if (NULL != c->rq.headers_received_tail)\n    last_elmnt_end =\n      c->rq.headers_received_tail->value\n      + c->rq.headers_received_tail->value_size;\n  else\n    last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n  mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n  shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n  if (0 != c->read_buffer_offset)\n    memmove (c->read_buffer - shift_back_size,\n             c->read_buffer,\n             c->read_buffer_offset);\n  c->read_buffer -= shift_back_size;\n  c->read_buffer_size += shift_back_size;\n}"
  ],
  "explanation": "I selected the fragments above because they are places where control-flow assumptions or conditional guards make certain code paths suspicious with respect to reachability and therefore worth investigation for MISRA C Rule 2.1.\n\nWhy other fragments were not selected:\n- The main do/while loop body and the explicit handling of the get_req_header() return values (MHD_HDR_LINE_READING_GOT_HEADER, MHD_HDR_LINE_READING_NEED_MORE_DATA, MHD_HDR_LINE_READING_DATA_ERROR and the remaining else) directly correspond to the known enum results returned by get_req_header(); those branches are reachable and are explicitly handled, so they do not by themselves indicate unreachable code.\n- The numerous mhd_assert() calls are assertions for debugging/runtime checks; assertions themselves are not necessarily unreachable code (they may be compiled out) and do not constitute unreachable executable statements under normal compilation modes. I therefore did not flag every assert usage.\n- Conditional compilation blocks (#ifdef _DEBUG, #ifdef HAVE_MESSAGES, #ifndef MHD_FAVOR_SMALL_CODE, etc.) are normal compile-time variants. I only flagged the logging block under HAVE_MESSAGES because the logging conditions reference counters that could be always zero in some configurations, making the diagnostic branches suspicious for reachability analysis; other conditional sections are standard alternate implementations and not inherently unreachable.\n- Helper functions included in the additional code (get_req_header, MHD_set_connection_value_n_nocheck_, reset_rq_header_processing_state, handle_req_headers_no_space, handle_req_footers_no_space) contain control-flow consistent with their documented purposes; their internal returns map to the callers' checks, so no obvious unreachable code fragments were found inside them worth reporting separately.\n\nIf you want, I can provide a control-flow graph or step through specific execution scenarios (values of c->state, read buffer variables, and client_discipline) to try to prove reachability/unreachability of any of the flagged fragments more formally."
}