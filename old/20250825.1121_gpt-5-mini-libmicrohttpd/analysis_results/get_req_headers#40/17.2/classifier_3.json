{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_req_headers:\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_req_headers:\nstatic enum MHD_HdrLineReadRes_\nget_req_header (struct MHD_Connection *c,\n                bool process_footers,\n                struct _MHD_str_w_len *hdr_name,\n                struct _MHD_str_w_len *hdr_value)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2-4 */\n  const bool bare_cr_keep = (-3 >= discp_lvl);\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2-4 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n  /* Treat NUL as space; replace it with space before processing.\n     RFC 9110, section 5.5-5 */\n  const bool nul_as_sp = (-1 >= discp_lvl);\n  /* Allow folded header lines.\n     RFC 9112, section 5.2-4 */\n  const bool allow_folded = (0 >= discp_lvl);\n  /* Do not reject headers with the whitespace at the start of the first line.\n     When allowed, the first line with whitespace character at the first\n     position is ignored (as well as all possible line foldings of the first\n     line).\n     RFC 9112, section 2.2-8 */\n  const bool allow_wsp_at_start = allow_folded && (-1 >= discp_lvl);\n  /* Allow whitespace in header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_wsp_in_name = (-2 >= discp_lvl);\n  /* Allow zero-length header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_empty_name = (-2 >= discp_lvl);\n  /* Allow whitespace before colon.\n     Violates RFC 9112, section 5.1-2 */\n  const bool allow_wsp_before_colon = (-3 >= discp_lvl);\n  /* Do not abort the request when header line has no colon, just skip such\n     bad lines.\n     RFC 9112, section 5-1 */\n  const bool allow_line_without_colon = (-2 >= discp_lvl);\n\n  size_t p; /**< The position of the currently processed character */\n\n#if ! defined (HAVE_MESSAGES) && ! defined(_DEBUG)\n  (void) process_footers; /* Unused parameter */\n#endif /* !HAVE_MESSAGES && !_DEBUG */\n\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n\n  p = c->rq.hdrs.hdr.proc_pos;\n\n  mhd_assert (p <= c->read_buffer_offset);\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_len < p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || (0 != p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_end_found));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.name_len < c->rq.hdrs.hdr.value_start));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (0 != c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (0 != p)\n      {\n        /* Line is not empty, need to check for possible line folding */\n        if (p + 2 >= c->read_buffer_offset)\n          break; /* Not enough data yet to check for folded line */\n      }\n      else\n      {\n        /* Line is empty, no need to check for possible line folding */\n        if (p + 2 > c->read_buffer_offset)\n          break; /* Not enough data yet to check for the end of the line */\n      }\n      if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2-4 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        end_of_line = false;\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2-3 */\n      if (bare_lf_as_crlf)\n      {\n        if (0 != p)\n        {\n          /* Line is not empty, need to check for possible line folding */\n          if (p + 1 >= c->read_buffer_offset)\n            break; /* Not enough data yet to check for folded line */\n        }\n        end_of_line = true;\n      }\n      else\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_FOOTER);\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n    }\n    else\n      end_of_line = false;\n\n    if (end_of_line)\n    {\n      /* Handle the end of the line */\n      /**\n       *  The full length of the line, including CRLF (or bare LF).\n       */\n      const size_t line_len = p + (('\\r' == chr) ? 2 : 1);\n      char next_line_char;\n      mhd_assert (line_len <= c->read_buffer_offset);\n\n      if (0 == p)\n      {\n        /* Zero-length header line. This is the end of the request header\n           section.\n           RFC 9112, Section 2.1-1 */\n        mhd_assert (! c->rq.hdrs.hdr.starts_with_ws);\n        mhd_assert (! c->rq.hdrs.hdr.name_end_found);\n        mhd_assert (0 == c->rq.hdrs.hdr.name_len);\n        mhd_assert (0 == c->rq.hdrs.hdr.ws_start);\n        mhd_assert (0 == c->rq.hdrs.hdr.value_start);\n        /* Consume the line with CRLF (or bare LF) */\n        c->read_buffer += line_len;\n        c->read_buffer_offset -= line_len;\n        c->read_buffer_size -= line_len;\n        return MHD_HDR_LINE_READING_GOT_END_OF_HEADER;\n      }\n\n      mhd_assert (line_len < c->read_buffer_offset);\n      mhd_assert (0 != line_len);\n      mhd_assert ('\\n' == c->read_buffer[line_len - 1]);\n      next_line_char = c->read_buffer[line_len];\n      if ((' ' == next_line_char) ||\n          ('\\t' == next_line_char))\n      {\n        /* Folded line */\n        if (! allow_folded)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD_FOOTER);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        /* Replace CRLF (or bare LF) character(s) with space characters.\n           See RFC 9112, Section 5.2-4 */\n        c->read_buffer[p] = ' ';\n        if ('\\r' == chr)\n          c->read_buffer[p + 1] = ' ';\n        continue; /* Re-start processing of the current character */\n      }\n      else\n      {\n        /* It is not a folded line, it's the real end of the non-empty line */\n        bool skip_line = false;\n        mhd_assert (0 != p);\n        if (c->rq.hdrs.hdr.starts_with_ws)\n        {\n          /* This is the first line and it starts with whitespace. This line\n             must be discarded completely.\n             See RFC 9112, Section 2.2-8 */\n          mhd_assert (allow_wsp_at_start);\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (c->daemon,\n                    _ (\"Whitespace-prefixed first header line \" \\\n                       \"has been skipped.\\n\"));\n#endif /* HAVE_MESSAGES */\n          skip_line = true;\n        }\n        else if (! c->rq.hdrs.hdr.name_end_found)\n        {\n          if (! allow_line_without_colon)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_HEADER_WITHOUT_COLON);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_FOOTER_WITHOUT_COLON);\n\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          /* Skip broken line completely */\n          c->rq.skipped_broken_lines++;\n          skip_line = true;\n        }\n        if (skip_line)\n        {\n          /* Skip the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          p = 0;\n          /* Reset processing state */\n          memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n          /* Start processing of the next line */\n          continue;\n        }\n        else\n        {\n          /* This line should be valid header line */\n          size_t value_len;\n          mhd_assert ((0 != c->rq.hdrs.hdr.name_len) || allow_empty_name);\n\n          hdr_name->str = c->read_buffer + 0; /* The name always starts at the first character */\n          hdr_name->len = c->rq.hdrs.hdr.name_len;\n          mhd_assert (0 == hdr_name->str[hdr_name->len]);\n\n          if (0 == c->rq.hdrs.hdr.value_start)\n          {\n            c->rq.hdrs.hdr.value_start = p;\n            c->read_buffer[p] = 0;\n            value_len = 0;\n          }\n          else if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            mhd_assert (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start);\n            c->read_buffer[c->rq.hdrs.hdr.ws_start] = 0;\n            value_len = c->rq.hdrs.hdr.ws_start - c->rq.hdrs.hdr.value_start;\n          }\n          else\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            c->read_buffer[p] = 0;\n            value_len = p - c->rq.hdrs.hdr.value_start;\n          }\n          hdr_value->str = c->read_buffer + c->rq.hdrs.hdr.value_start;\n          hdr_value->len = value_len;\n          mhd_assert (0 == hdr_value->str[hdr_value->len]);\n          /* Consume the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          return MHD_HDR_LINE_READING_GOT_HEADER;\n        }\n      }\n    }\n    else if ((' ' == chr) || ('\\t' == chr))\n    {\n      if (0 == p)\n      {\n        if (! allow_wsp_at_start)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        c->rq.hdrs.hdr.starts_with_ws = true;\n      }\n      else if ((! c->rq.hdrs.hdr.name_end_found) &&\n               (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Whitespace in header name / between header name and colon */\n        if (allow_wsp_in_name || allow_wsp_before_colon)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.ws_start = p;\n        }\n        else\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_HEADER_NAME);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_FOOTER_NAME);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n      }\n      else\n      {\n        /* Whitespace before/inside/after header (field) value */\n        if (0 == c->rq.hdrs.hdr.ws_start)\n          c->rq.hdrs.hdr.ws_start = p;\n      }\n    }\n    else if (0 == chr)\n    {\n      if (! nul_as_sp)\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_FOOTER);\n\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n      c->read_buffer[p] = ' ';\n      continue; /* Re-start processing of the current character */\n    }\n    else\n    {\n      /* Not a whitespace, not the end of the header line */\n      mhd_assert ('\\r' != chr);\n      mhd_assert ('\\n' != chr);\n      mhd_assert ('\\0' != chr);\n      if ((! c->rq.hdrs.hdr.name_end_found) &&\n          (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Processing the header (field) name */\n        if (':' == chr)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.name_len = p;\n          else\n          {\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_before_colon)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n            c->rq.hdrs.hdr.name_len = c->rq.hdrs.hdr.ws_start;\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n          if ((0 == c->rq.hdrs.hdr.name_len) && ! allow_empty_name)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_HEADER_NAME);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_FOOTER_NAME);\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          c->rq.hdrs.hdr.name_end_found = true;\n          c->read_buffer[c->rq.hdrs.hdr.name_len] = 0; /* Zero-terminate the name */\n        }\n        else\n        {\n          if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            /* End of the whitespace in header (field) name */\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_in_name)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n        }\n      }\n      else\n      {\n        /* Processing the header (field) value */\n        if (0 == c->rq.hdrs.hdr.value_start)\n          c->rq.hdrs.hdr.value_start = p;\n#ifndef MHD_FAVOR_SMALL_CODE\n        c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n      }\n#ifdef MHD_FAVOR_SMALL_CODE\n      c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* MHD_FAVOR_SMALL_CODE */\n    }\n    p++;\n  }\n  c->rq.hdrs.hdr.proc_pos = p;\n  return MHD_HDR_LINE_READING_NEED_MORE_DATA; /* Not enough data yet */\n}\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n...\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\nstatic void\nhandle_req_headers_no_space (struct MHD_Connection *c,\n                             const char *add_header,\n                             size_t add_header_size)\n{\n  unsigned int err_code;\n\n  err_code = get_no_space_err_status_code (c,\n                                           MHD_PROC_RECV_HEADERS,\n                                           add_header,\n                                           add_header_size);\n  transmit_error_response_static (c,\n                                  err_code,\n                                  ERR_MSG_REQUEST_HEADER_TOO_BIG);\n}\n...\nstatic void\nhandle_req_footers_no_space (struct MHD_Connection *c,\n                             const char *add_footer,\n                             size_t add_footer_size)\n{\n  (void) add_footer; (void) add_footer_size; /* Unused */\n  mhd_assert (c->rq.have_chunked_upload);\n\n  /* Footers should be optional */\n  transmit_error_response_static (c,\n                                  MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                  ERR_MSG_REQUEST_FOOTER_TOO_BIG);\n}\n...\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n...\n_MHD_static_inline void\nreset_rq_header_processing_state (struct MHD_Connection *c)\n{\n  memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n}\n...\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nres = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the call is to the memory-pool allocator MHD_pool_try_alloc. In the provided code there is no indication that MHD_pool_try_alloc (or the other pool helpers used here) calls back into MHD_connection_alloc_memory_ (or into get_req_headers). A recursion scenario that would violate Rule 17.2 would require a cycle such as MHD_connection_alloc_memory_ -> MHD_pool_try_alloc -> ... -> MHD_connection_alloc_memory_, which is not present in the shown code."
}