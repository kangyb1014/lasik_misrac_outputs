{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of get_req_headers:\n```c\nstatic bool\nget_req_headers (struct MHD_Connection *c, bool process_footers)\n{\n  do\n  {\n    struct _MHD_str_w_len hdr_name;\n    struct _MHD_str_w_len hdr_value;\n    enum MHD_HdrLineReadRes_ res;\n\n    mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                 MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                c->state);\n\n    #ifdef _DEBUG\n    hdr_name.str = NULL;\n    hdr_value.str = NULL;\n#endif /* _DEBUG */\n    res = get_req_header (c, process_footers, &hdr_name, &hdr_value);\n    if (MHD_HDR_LINE_READING_GOT_HEADER == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      mhd_assert (NULL != hdr_name.str);\n      mhd_assert (NULL != hdr_value.str);\n      /* Values must be zero-terminated and must not have binary zeros */\n      mhd_assert (strlen (hdr_name.str) == hdr_name.len);\n      mhd_assert (strlen (hdr_value.str) == hdr_value.len);\n      /* Values must not have whitespaces at the start or at the end */\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != ' '));\n      mhd_assert ((hdr_name.len == 0) || (hdr_name.str[0] != '\\t'));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != ' '));\n      mhd_assert ((hdr_name.len == 0) || \\\n                  (hdr_name.str[hdr_name.len - 1] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != ' '));\n      mhd_assert ((hdr_value.len == 0) || (hdr_value.str[0] != '\\t'));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != ' '));\n      mhd_assert ((hdr_value.len == 0) || \\\n                  (hdr_value.str[hdr_value.len - 1] != '\\t'));\n\n      if (MHD_NO ==\n          MHD_set_connection_value_n_nocheck_ (c,\n                                               (! process_footers) ?\n                                               MHD_HEADER_KIND :\n                                               MHD_FOOTER_KIND,\n                                               hdr_name.str, hdr_name.len,\n                                               hdr_value.str, hdr_value.len))\n      {\n        size_t add_element_size;\n\n        mhd_assert (hdr_name.str < hdr_value.str);\n\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (c->daemon,\n                  _ (\"Failed to allocate memory in the connection memory \" \\\n                     \"pool to store %s.\\n\"),\n                  (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n#endif /* HAVE_MESSAGES */\n\n        add_element_size = hdr_value.len\n                           + (size_t) (hdr_value.str - hdr_name.str);\n\n        if (! process_footers)\n          handle_req_headers_no_space (c, hdr_name.str, add_element_size);\n        else\n          handle_req_footers_no_space (c, hdr_name.str, add_element_size);\n\n        mhd_assert (MHD_CONNECTION_FULL_REQ_RECEIVED < c->state);\n        return true;\n      }\n      /* Reset processing state */\n      reset_rq_header_processing_state (c);\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      /* Read the next header (field) line */\n      continue;\n    }\n    else if (MHD_HDR_LINE_READING_NEED_MORE_DATA == res)\n    {\n      mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n                  c->state);\n      return false;\n    }\n    else if (MHD_HDR_LINE_READING_DATA_ERROR == res)\n    {\n      mhd_assert ((process_footers ? \\\n                   MHD_CONNECTION_FOOTERS_RECEIVING : \\\n                   MHD_CONNECTION_REQ_HEADERS_RECEIVING) < c->state);\n      mhd_assert (c->stop_with_error);\n      mhd_assert (c->discard_request);\n      return true;\n    }\n    mhd_assert (MHD_HDR_LINE_READING_GOT_END_OF_HEADER == res);\n    break;\n  } while (1);\n\n#ifdef HAVE_MESSAGES\n  if (1 == c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One bare CR character has been replaced with space \" \\\n                 \"in %s.\\n\"),\n              (! process_footers) ?\n              _ (\"the request line or in the request headers\") :\n              _ (\"the request footers\"));\n  }\n  else if (0 != c->rq.num_cr_sp_replaced)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" bare CR characters have been replaced with \" \\\n                 \"spaces in the request line and/or in the request %s.\\n\"),\n              (uint64_t) c->rq.num_cr_sp_replaced,\n              (! process_footers) ? _ (\"headers\") : _ (\"footers\"));\n  }\n  if (1 == c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"One %s line without colon has been skipped.\\n\"),\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n  else if (0 != c->rq.skipped_broken_lines)\n  {\n    MHD_DLOG (c->daemon,\n              _ (\"%\" PRIu64 \" %s lines without colons has been skipped.\\n\"),\n              (uint64_t) c->rq.skipped_broken_lines,\n              (! process_footers) ? _ (\"header\") : _ (\"footer\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  mhd_assert (c->rq.method < c->read_buffer);\n  if (! process_footers)\n  {\n    c->rq.header_size = (size_t) (c->read_buffer - c->rq.method);\n    mhd_assert (NULL != c->rq.field_lines.start);\n    c->rq.field_lines.size =\n      (size_t) ((c->read_buffer - c->rq.field_lines.start) - 1);\n    if ('\\r' == *(c->read_buffer - 2))\n      c->rq.field_lines.size--;\n    c->state = MHD_CONNECTION_HEADERS_RECEIVED;\n\n    if (MHD_BUF_INC_SIZE > c->read_buffer_size)\n    {\n      /* Try to re-use some of the last bytes of the request header */\n      /* Do this only if space in the read buffer is limited AND\n         amount of read ahead data is small. */\n      /**\n       *  The position of the terminating NUL after the last character of\n       *  the last header element.\n       */\n      const char *last_elmnt_end;\n      size_t shift_back_size;\n      if (NULL != c->rq.headers_received_tail)\n        last_elmnt_end =\n          c->rq.headers_received_tail->value\n          + c->rq.headers_received_tail->value_size;\n      else\n        last_elmnt_end = c->rq.version + HTTP_VER_LEN;\n      mhd_assert ((last_elmnt_end + 1) < c->read_buffer);\n      shift_back_size = (size_t) (c->read_buffer - (last_elmnt_end + 1));\n      if (0 != c->read_buffer_offset)\n        memmove (c->read_buffer - shift_back_size,\n                 c->read_buffer,\n                 c->read_buffer_offset);\n      c->read_buffer -= shift_back_size;\n      c->read_buffer_size += shift_back_size;\n    }\n  }\n  else\n    c->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n\n  return true;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function get_req_headers:\nstatic enum MHD_HdrLineReadRes_\nget_req_header (struct MHD_Connection *c,\n                bool process_footers,\n                struct _MHD_str_w_len *hdr_name,\n                struct _MHD_str_w_len *hdr_value)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2-4 */\n  const bool bare_cr_keep = (-3 >= discp_lvl);\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2-4 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n  /* Treat NUL as space; replace it with space before processing.\n     RFC 9110, section 5.5-5 */\n  const bool nul_as_sp = (-1 >= discp_lvl);\n  /* Allow folded header lines.\n     RFC 9112, section 5.2-4 */\n  const bool allow_folded = (0 >= discp_lvl);\n  /* Do not reject headers with the whitespace at the start of the first line.\n     When allowed, the first line with whitespace character at the first\n     position is ignored (as well as all possible line foldings of the first\n     line).\n     RFC 9112, section 2.2-8 */\n  const bool allow_wsp_at_start = allow_folded && (-1 >= discp_lvl);\n  /* Allow whitespace in header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_wsp_in_name = (-2 >= discp_lvl);\n  /* Allow zero-length header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_empty_name = (-2 >= discp_lvl);\n  /* Allow whitespace before colon.\n     Violates RFC 9112, section 5.1-2 */\n  const bool allow_wsp_before_colon = (-3 >= discp_lvl);\n  /* Do not abort the request when header line has no colon, just skip such\n     bad lines.\n     RFC 9112, section 5-1 */\n  const bool allow_line_without_colon = (-2 >= discp_lvl);\n\n  size_t p; /**< The position of the currently processed character */\n\n#if ! defined (HAVE_MESSAGES) && ! defined(_DEBUG)\n  (void) process_footers; /* Unused parameter */\n#endif /* !HAVE_MESSAGES && !_DEBUG */\n\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n\n  p = c->rq.hdrs.hdr.proc_pos;\n\n  mhd_assert (p <= c->read_buffer_offset);\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_len < p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || (0 != p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_end_found));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.name_len < c->rq.hdrs.hdr.value_start));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (0 != c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (0 != p)\n      {\n        /* Line is not empty, need to check for possible line folding */\n        if (p + 2 >= c->read_buffer_offset)\n          break; /* Not enough data yet to check for folded line */\n      }\n      else\n      {\n        /* Line is empty, no need to check for possible line folding */\n        if (p + 2 > c->read_buffer_offset)\n          break; /* Not enough data yet to check for the end of the line */\n      }\n      if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2-4 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        end_of_line = false;\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2-3 */\n      if (bare_lf_as_crlf)\n      {\n        if (0 != p)\n        {\n          /* Line is not empty, need to check for possible line folding */\n          if (p + 1 >= c->read_buffer_offset)\n            break; /* Not enough data yet to check for folded line */\n        }\n        end_of_line = true;\n      }\n      else\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_FOOTER);\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n    }\n    else\n      end_of_line = false;\n\n    if (end_of_line)\n    {\n      /* Handle the end of the line */\n      /**\n       *  The full length of the line, including CRLF (or bare LF).\n       */\n      const size_t line_len = p + (('\\r' == chr) ? 2 : 1);\n      char next_line_char;\n      mhd_assert (line_len <= c->read_buffer_offset);\n\n      if (0 == p)\n      {\n        /* Zero-length header line. This is the end of the request header\n           section.\n           RFC 9112, Section 2.1-1 */\n        mhd_assert (! c->rq.hdrs.hdr.starts_with_ws);\n        mhd_assert (! c->rq.hdrs.hdr.name_end_found);\n        mhd_assert (0 == c->rq.hdrs.hdr.name_len);\n        mhd_assert (0 == c->rq.hdrs.hdr.ws_start);\n        mhd_assert (0 == c->rq.hdrs.hdr.value_start);\n        /* Consume the line with CRLF (or bare LF) */\n        c->read_buffer += line_len;\n        c->read_buffer_offset -= line_len;\n        c->read_buffer_size -= line_len;\n        return MHD_HDR_LINE_READING_GOT_END_OF_HEADER;\n      }\n\n      mhd_assert (line_len < c->read_buffer_offset);\n      mhd_assert (0 != line_len);\n      mhd_assert ('\\n' == c->read_buffer[line_len - 1]);\n      next_line_char = c->read_buffer[line_len];\n      if ((' ' == next_line_char) ||\n          ('\\t' == next_line_char))\n      {\n        /* Folded line */\n        if (! allow_folded)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD_FOOTER);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        /* Replace CRLF (or bare LF) character(s) with space characters.\n           See RFC 9112, Section 5.2-4 */\n        c->read_buffer[p] = ' ';\n        if ('\\r' == chr)\n          c->read_buffer[p + 1] = ' ';\n        continue; /* Re-start processing of the current character */\n      }\n      else\n      {\n        /* It is not a folded line, it's the real end of the non-empty line */\n        bool skip_line = false;\n        mhd_assert (0 != p);\n        if (c->rq.hdrs.hdr.starts_with_ws)\n        {\n          /* This is the first line and it starts with whitespace. This line\n             must be discarded completely.\n             See RFC 9112, Section 2.2-8 */\n          mhd_assert (allow_wsp_at_start);\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (c->daemon,\n                    _ (\"Whitespace-prefixed first header line \" \\\n                       \"has been skipped.\\n\"));\n#endif /* HAVE_MESSAGES */\n          skip_line = true;\n        }\n        else if (! c->rq.hdrs.hdr.name_end_found)\n        {\n          if (! allow_line_without_colon)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_HEADER_WITHOUT_COLON);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_FOOTER_WITHOUT_COLON);\n\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          /* Skip broken line completely */\n          c->rq.skipped_broken_lines++;\n          skip_line = true;\n        }\n        if (skip_line)\n        {\n          /* Skip the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          p = 0;\n          /* Reset processing state */\n          memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n          /* Start processing of the next line */\n          continue;\n        }\n        else\n        {\n          /* This line should be valid header line */\n          size_t value_len;\n          mhd_assert ((0 != c->rq.hdrs.hdr.name_len) || allow_empty_name);\n\n          hdr_name->str = c->read_buffer + 0; /* The name always starts at the first character */\n          hdr_name->len = c->rq.hdrs.hdr.name_len;\n          mhd_assert (0 == hdr_name->str[hdr_name->len]);\n\n          if (0 == c->rq.hdrs.hdr.value_start)\n          {\n            c->rq.hdrs.hdr.value_start = p;\n            c->read_buffer[p] = 0;\n            value_len = 0;\n          }\n          else if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            mhd_assert (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start);\n            c->read_buffer[c->rq.hdrs.hdr.ws_start] = 0;\n            value_len = c->rq.hdrs.hdr.ws_start - c->rq.hdrs.hdr.value_start;\n          }\n          else\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            c->read_buffer[p] = 0;\n            value_len = p - c->rq.hdrs.hdr.value_start;\n          }\n          hdr_value->str = c->read_buffer + c->rq.hdrs.hdr.value_start;\n          hdr_value->len = value_len;\n          mhd_assert (0 == hdr_value->str[hdr_value->len]);\n          /* Consume the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          return MHD_HDR_LINE_READING_GOT_HEADER;\n        }\n      }\n    }\n    else if ((' ' == chr) || ('\\t' == chr))\n    {\n      if (0 == p)\n      {\n        if (! allow_wsp_at_start)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        c->rq.hdrs.hdr.starts_with_ws = true;\n      }\n      else if ((! c->rq.hdrs.hdr.name_end_found) &&\n               (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Whitespace in header name / between header name and colon */\n        if (allow_wsp_in_name || allow_wsp_before_colon)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.ws_start = p;\n        }\n        else\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_HEADER_NAME);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_FOOTER_NAME);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n      }\n      else\n      {\n        /* Whitespace before/inside/after header (field) value */\n        if (0 == c->rq.hdrs.hdr.ws_start)\n          c->rq.hdrs.hdr.ws_start = p;\n      }\n    }\n    else if (0 == chr)\n    {\n      if (! nul_as_sp)\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_FOOTER);\n\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n      c->read_buffer[p] = ' ';\n      continue; /* Re-start processing of the current character */\n    }\n    else\n    {\n      /* Not a whitespace, not the end of the header line */\n      mhd_assert ('\\r' != chr);\n      mhd_assert ('\\n' != chr);\n      mhd_assert ('\\0' != chr);\n      if ((! c->rq.hdrs.hdr.name_end_found) &&\n          (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Processing the header (field) name */\n        if (':' == chr)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.name_len = p;\n          else\n          {\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_before_colon)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n            c->rq.hdrs.hdr.name_len = c->rq.hdrs.hdr.ws_start;\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n          if ((0 == c->rq.hdrs.hdr.name_len) && ! allow_empty_name)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_HEADER_NAME);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_FOOTER_NAME);\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          c->rq.hdrs.hdr.name_end_found = true;\n          c->read_buffer[c->rq.hdrs.hdr.name_len] = 0; /* Zero-terminate the name */\n        }\n        else\n        {\n          if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            /* End of the whitespace in header (field) name */\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_in_name)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n        }\n      }\n      else\n      {\n        /* Processing the header (field) value */\n        if (0 == c->rq.hdrs.hdr.value_start)\n          c->rq.hdrs.hdr.value_start = p;\n#ifndef MHD_FAVOR_SMALL_CODE\n        c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n      }\n#ifdef MHD_FAVOR_SMALL_CODE\n      c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* MHD_FAVOR_SMALL_CODE */\n    }\n    p++;\n  }\n  c->rq.hdrs.hdr.proc_pos = p;\n  return MHD_HDR_LINE_READING_NEED_MORE_DATA; /* Not enough data yet */\n}\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n...\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nstatic void\nhandle_req_headers_no_space (struct MHD_Connection *c,\n                             const char *add_header,\n                             size_t add_header_size)\n{\n  unsigned int err_code;\n\n  err_code = get_no_space_err_status_code (c,\n                                           MHD_PROC_RECV_HEADERS,\n                                           add_header,\n                                           add_header_size);\n  transmit_error_response_static (c,\n                                  err_code,\n                                  ERR_MSG_REQUEST_HEADER_TOO_BIG);\n}\n...\nstatic void\nhandle_req_footers_no_space (struct MHD_Connection *c,\n                             const char *add_footer,\n                             size_t add_footer_size)\n{\n  (void) add_footer; (void) add_footer_size; /* Unused */\n  mhd_assert (c->rq.have_chunked_upload);\n\n  /* Footers should be optional */\n  transmit_error_response_static (c,\n                                  MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                  ERR_MSG_REQUEST_FOOTER_TOO_BIG);\n}\n...\n_MHD_static_inline void\nreset_rq_header_processing_state (struct MHD_Connection *c)\n{\n  memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n}\n...\nstatic void\ntransmit_error_response_len (struct MHD_Connection *connection,\n                             unsigned int status_code,\n                             const char *message,\n                             size_t message_len,\n                             char *header_name,\n                             size_t header_name_len,\n                             char *header_value,\n                             size_t header_value_len)\n{\n  struct MHD_Response *response;\n  enum MHD_Result iret;\n\n  mhd_assert (! connection->stop_with_error); /* Do not send error twice */\n  if (connection->stop_with_error)\n  { /* Should not happen */\n    if (MHD_CONNECTION_CLOSED > connection->state)\n      connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Error processing request (HTTP response code is %u ('%s')). \" \\\n               \"Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (MHD_CONNECTION_START_REPLY < connection->state)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Too late to send an error response, \" \\\n                 \"response is being sent already.\\n\"),\n              status_code,\n              message);\n#endif\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Too late for error response.\"));\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  /* TODO: remove when special error queue function is implemented */\n  connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n  if (0 != connection->read_buffer_size)\n  {\n    /* Read buffer is not needed anymore, discard it\n     * to free some space for error response. */\n    MHD_pool_deallocate (connection->pool,\n                         connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer = NULL;\n    connection->read_buffer_size = 0;\n    connection->read_buffer_offset = 0;\n  }\n  if (NULL != connection->rp.response)\n  {\n    MHD_destroy_response (connection->rp.response);\n    connection->rp.response = NULL;\n  }\n  response = MHD_create_response_from_buffer_static (message_len,\n                                                     message);\n  if (NULL == response)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to create error response.\\n\"),\n              status_code,\n              message);\n#endif\n    /* can't even send a reply, at least close the connection */\n    connection->state = MHD_CONNECTION_CLOSED;\n    free (header_name);\n    free (header_value);\n    return;\n  }\n  mhd_assert ((0 == header_name_len) || (NULL != header_name));\n  mhd_assert ((NULL == header_name) || (0 != header_name_len));\n  mhd_assert ((0 == header_value_len) || (NULL != header_value));\n  mhd_assert ((NULL == header_value) || (0 != header_value_len));\n  mhd_assert ((NULL == header_name) || (NULL != header_value));\n  mhd_assert ((NULL != header_value) || (NULL == header_name));\n  if (NULL != header_name)\n  {\n    iret = MHD_add_response_entry_no_alloc_ (response,\n                                             MHD_HEADER_KIND,\n                                             header_name, header_name_len,\n                                             header_value, header_value_len);\n    if (MHD_NO == iret)\n    {\n      free (header_name);\n      free (header_value);\n    }\n  }\n  else\n    iret = MHD_YES;\n\n  if (MHD_NO != iret)\n  {\n    bool before = connection->in_access_handler;\n\n    /* Fake the flag for the internal call */\n    connection->in_access_handler = true;\n    iret = MHD_queue_response (connection,\n                               status_code,\n                               response);\n    connection->in_access_handler = before;\n  }\n  MHD_destroy_response (response);\n  if (MHD_NO == iret)\n  {\n    /* can't even send a reply, at least close the connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Closing connection \" \\\n                               \"(failed to queue error response).\"));\n    return;\n  }\n  mhd_assert (NULL != connection->rp.response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n  {\n    /* No memory. Release everything. */\n    connection->rq.version = NULL;\n    connection->rq.method = NULL;\n    connection->rq.url = NULL;\n    connection->rq.url_len = 0;\n    connection->rq.headers_received = NULL;\n    connection->rq.headers_received_tail = NULL;\n    connection->write_buffer = NULL;\n    connection->write_buffer_size = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_append_offset = 0;\n    connection->read_buffer\n      = MHD_pool_reset (connection->pool,\n                        NULL,\n                        0,\n                        0);\n    connection->read_buffer_size = 0;\n\n    /* Retry with empty buffer */\n    if (MHD_NO == build_header_response (connection))\n    {\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection \" \\\n                                 \"(failed to create error response header).\"));\n      return;\n    }\n  }\n  connection->state = MHD_CONNECTION_HEADERS_SENDING;\n}\n...\nstatic unsigned int\nget_no_space_err_status_code (struct MHD_Connection *c,\n                              enum MHD_ProcRecvDataStage stage,\n                              const char *add_element,\n                              size_t add_element_size)\n{\n  size_t method_size;\n  size_t uri_size;\n  size_t opt_headers_size;\n  size_t host_field_line_size;\n\n  mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED < c->state);\n  mhd_assert (MHD_PROC_RECV_HEADERS <= stage);\n  mhd_assert ((0 == add_element_size) || (NULL != add_element));\n\n  if (MHD_CONNECTION_HEADERS_RECEIVED > c->state)\n  {\n    mhd_assert (NULL != c->rq.field_lines.start);\n    opt_headers_size =\n      (size_t) ((c->read_buffer + c->read_buffer_offset)\n                - c->rq.field_lines.start);\n  }\n  else\n    opt_headers_size = c->rq.field_lines.size;\n\n  /* The read buffer is fully used by the request line, the field lines\n     (headers) and internal information.\n     The return status code works as a suggestion for the client to reduce\n     one of the request elements. */\n\n  if ((MHD_PROC_RECV_BODY_CHUNKED == stage) &&\n      (MHD_MIN_REASONABLE_REQ_CHUNK_LINE_LENGTH_ < add_element_size))\n  {\n    /* Request could be re-tried easily with smaller chunk sizes */\n    return MHD_HTTP_CONTENT_TOO_LARGE;\n  }\n\n  host_field_line_size = 0;\n  /* The \"Host:\" field line is mandatory.\n     The total size of the field lines (headers) cannot be smaller than\n     the size of the \"Host:\" field line. */\n  if ((MHD_PROC_RECV_HEADERS == stage)\n      && (0 != add_element_size))\n  {\n    static const size_t header_host_key_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    const bool is_host_header =\n      (header_host_key_len + 1 <= add_element_size)\n      && ( (0 == add_element[header_host_key_len])\n           || (':' == add_element[header_host_key_len]) )\n      && MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_HOST,\n                                        add_element,\n                                        header_host_key_len);\n    if (is_host_header)\n    {\n      const bool is_parsed = ! (\n        (MHD_CONNECTION_HEADERS_RECEIVED > c->state) &&\n        (add_element_size == c->read_buffer_offset) &&\n        (c->read_buffer == add_element) );\n      size_t actual_element_size;\n\n      mhd_assert (! is_parsed || (0 == add_element[header_host_key_len]));\n      /* The actual size should be larger due to CRLF or LF chars,\n         however the exact termination sequence is not known here and\n         as perfect precision is not required, to simplify the code\n         assume the minimal length. */\n      if (is_parsed)\n        actual_element_size = add_element_size + 1;  /* \"1\" for LF */\n      else\n        actual_element_size = add_element_size;\n\n      host_field_line_size = actual_element_size;\n      mhd_assert (opt_headers_size >= actual_element_size);\n      opt_headers_size -= actual_element_size;\n    }\n  }\n  if (0 == host_field_line_size)\n  {\n    static const size_t host_field_name_len =\n      MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_HOST);\n    size_t host_field_name_value_len;\n    if (MHD_NO != MHD_lookup_connection_value_n (c,\n                                                 MHD_HEADER_KIND,\n                                                 MHD_HTTP_HEADER_HOST,\n                                                 host_field_name_len,\n                                                 NULL,\n                                                 &host_field_name_value_len))\n    {\n      /* Calculate the minimal size of the field line: no space between\n         colon and the field value, line terminated by LR */\n      host_field_line_size =\n        host_field_name_len + host_field_name_value_len + 2; /* \"2\" for ':' and LF */\n\n      /* The \"Host:\" field could be added by application */\n      if (opt_headers_size >= host_field_line_size)\n      {\n        opt_headers_size -= host_field_line_size;\n        /* Take into account typical space after colon and CR at the end of the line */\n        if (opt_headers_size >= 2)\n          opt_headers_size -= 2;\n      }\n      else\n        host_field_line_size = 0; /* No \"Host:\" field line set by the client */\n    }\n  }\n\n  uri_size = c->rq.req_target_len;\n  if (MHD_HTTP_MTHD_OTHER != c->rq.http_mthd)\n    method_size = 0; /* Do not recommend shorter request method */\n  else\n  {\n    mhd_assert (NULL != c->rq.method);\n    method_size = strlen (c->rq.method);\n  }\n\n  if ((size_t) MHD_MAX_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Typically the easiest way to reduce request header size is\n       a removal of some optional headers. */\n    if (opt_headers_size > (uri_size / 8))\n    {\n      if ((opt_headers_size / 2) > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is MUCH larger than headers */\n      if ((uri_size / 16) > method_size)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MAX_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* If request target size if larger than maximum reasonable size\n       recommend client to reduce the request target size (length). */\n    if ((uri_size / 16) > method_size)\n      return MHD_HTTP_URI_TOO_LONG;     /* Request target is MUCH larger than headers */\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED;  /* The length of the HTTP request method is unreasonably large */\n  }\n\n  /* The read buffer is too small to handle reasonably large requests */\n\n  if ((size_t) MHD_MIN_REASONABLE_HEADERS_SIZE_ < opt_headers_size)\n  {\n    /* Recommend application to retry with minimal headers */\n    if ((opt_headers_size * 4) > uri_size)\n    {\n      if (opt_headers_size > method_size)\n        return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n    else\n    { /* Request target is significantly larger than headers */\n      if (uri_size > method_size * 4)\n        return MHD_HTTP_URI_TOO_LONG;\n      else\n        return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n    }\n  }\n  if ((size_t) MHD_MIN_REASONABLE_REQ_TARGET_SIZE_ < uri_size)\n  {\n    /* Recommend application to retry with a shorter request target */\n    if (uri_size > method_size * 4)\n      return MHD_HTTP_URI_TOO_LONG;\n    else\n      return MHD_HTTP_NOT_IMPLEMENTED; /* The length of the HTTP request method is unreasonably large */\n  }\n\n  if ((size_t) MHD_MIN_REASONABLE_REQ_METHOD_SIZE_ < method_size)\n  {\n    /* The request target (URI) and headers are (reasonably) very small.\n       Some non-standard long request method is used. */\n    /* The last resort response as it means \"the method is not supported\n       by the server for any URI\". */\n    return MHD_HTTP_NOT_IMPLEMENTED;\n  }\n\n  /* The almost impossible situation: all elements are small, but cannot\n     fit the buffer. The application set the buffer size to\n     critically low value? */\n\n  if ((1 < opt_headers_size) || (1 < uri_size))\n  {\n    if (opt_headers_size >= uri_size)\n      return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    else\n      return MHD_HTTP_URI_TOO_LONG;\n  }\n\n  /* Nothing to reduce in the request.\n     Reply with some status. */\n  if (0 != host_field_line_size)\n    return MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n\n  return MHD_HTTP_URI_TOO_LONG;\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\n#define MHD_BUF_INC_SIZE 1500\n...\n#define HTTP_VER_LEN (MHD_STATICSTR_LEN_(MHD_HTTP_VERSION_1_1))\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the provided get_req_headers function and all related code you included (get_req_header, MHD_set_connection_value_n_nocheck_, MHD_connection_alloc_memory_, transmit and error helpers, get_no_space_err_status_code, and the struct definitions). There are no for statements (no occurrences of the token \"for(\" or \"for (\" in the supplied fragments), only a do { ... } while (1) loop and several while loops. MISRA C 2023 Rule 14.2 applies specifically to for loops; the do-while and while constructs present are not in scope for this rule. No macros or helper functions shown expand to a for loop. Therefore there are no for-loop fragments to investigate for Rule 14.2 in the provided code."
}