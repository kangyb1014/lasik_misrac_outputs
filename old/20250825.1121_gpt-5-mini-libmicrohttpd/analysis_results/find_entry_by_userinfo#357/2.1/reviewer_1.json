{
  "user_message": "An agent A claimed that the following find_entry_by_userinfo code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userinfo.\n```c\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe second branch can be statically unreachable depending on the enum ordering. If the enum values are ordered such that MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH (e.g. STANDARD=0, EXTENDED=1, USERHASH=2), then the first test (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type) evaluates true for USERHASH as well, so the USERHASH-specific if is never reached and thus is unreachable code. This constitutes a violation of MISRA C 2023 Rule 2.1.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_userinfo:\nstruct MHD_DigestAuthUsernameInfo\n{\n  /**\n   * The algorithm as defined by client.\n   * Set automatically to MD5 if not specified by client.\n   * @warning Do not be confused with #MHD_DigestAuthAlgorithm,\n   *          which uses other values!\n   */\n  enum MHD_DigestAuthAlgo3 algo3;\n\n  /**\n   * The type of username used by client.\n   * The 'invalid' and 'missing' types are not used in this structure,\n   * instead NULL is returned by #MHD_digest_auth_get_username3().\n   */\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /**\n   * The username string.\n   * Used only if username type is standard or extended, always NULL otherwise.\n   * If extended notation is used, this string is pct-decoded string\n   * with charset and language tag removed (i.e. it is original username\n   * extracted from the extended notation).\n   * When userhash is used by the client, this member is NULL and\n   * @a userhash_hex and @a userhash_bin are set.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username.\n   * When the @a username is NULL, this member is always zero.\n   */\n  size_t username_len;\n\n  /**\n   * The userhash string.\n   * Valid only if username type is userhash.\n   * This is unqoted string without decoding of the hexadecimal\n   * digits (as provided by the client).\n   * The buffer pointed by the @a userhash_hex becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @sa #MHD_digest_auth_calc_userhash_hex()\n   */\n  char *userhash_hex;\n\n  /**\n   * The length of the @a userhash_hex in characters.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) * 2 characters.\n   * When the @a userhash_hex is NULL, this member is always zero.\n   */\n  size_t userhash_hex_len;\n\n  /**\n   * The userhash decoded to binary form.\n   * Used only if username type is userhash, always NULL otherwise.\n   * When not NULL, this points to binary sequence @a userhash_hex_len /2 bytes\n   * long.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) bytes.\n   * The buffer pointed by the @a userhash_bin becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @warning This is a binary data, no zero termination.\n   * @warning To avoid buffer overruns, always check the size of the data before\n   *          use, because @a userhash_bin can point even to zero-sized\n   *          data.\n   * @sa #MHD_digest_auth_calc_userhash()\n   */\n  uint8_t *userhash_bin;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The agent\u2019s scenario describes a real path to unreachable code, but it is not possible to conclude a MISRA Rule 2.1 violation from the shown snippet alone because reachability depends on the actual enum constant values in the project. MISRA 2.1 forbids code that cannot be executed given the program\u2019s actual semantics; if in this project MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH is true (e.g. STANDARD = 0, EXTENDED = 1, USERHASH = 2), then for uname_type == USERHASH the first if will always be taken and the USERHASH-specific branch will indeed be unreachable \u2014 that would be a Rule 2.1 violation. Conversely, if the enum values are arranged so that USERHASH is less than STANDARD (or otherwise the first condition does not cover USERHASH), then the second branch can be reached and there is no unreachable code here.\n\nTherefore the agent\u2019s claim can be correct in a project where the enum ordering makes the second branch impossible to reach, but you cannot assert the violation without inspecting the enum definitions used in the project. To make the code robust and avoid any risk of unreachable branches, prefer an explicit test (e.g. check for standard or extended explicitly, or use an explicit range test or a switch over the enum) so the intent is clear and no branch can become inadvertently unreachable due to enum reordering."
}