{
  "user_message": "An agent A claimed that the following find_entry_by_userinfo code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userinfo.\n```c\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWith the usual enum ordering (e.g. MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD = 0, EXTENDED = 1, USERHASH = 2), the condition 'MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type' is true for USERHASH as well. That causes the function to return from the first branch for the USERHASH case, making the later 'if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)' branch unreachable. This constitutes unreachable code and thus violates MISRA C 2023 Rule 2.1.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_userinfo:\nstruct MHD_DigestAuthUsernameInfo\n{\n  /**\n   * The algorithm as defined by client.\n   * Set automatically to MD5 if not specified by client.\n   * @warning Do not be confused with #MHD_DigestAuthAlgorithm,\n   *          which uses other values!\n   */\n  enum MHD_DigestAuthAlgo3 algo3;\n\n  /**\n   * The type of username used by client.\n   * The 'invalid' and 'missing' types are not used in this structure,\n   * instead NULL is returned by #MHD_digest_auth_get_username3().\n   */\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /**\n   * The username string.\n   * Used only if username type is standard or extended, always NULL otherwise.\n   * If extended notation is used, this string is pct-decoded string\n   * with charset and language tag removed (i.e. it is original username\n   * extracted from the extended notation).\n   * When userhash is used by the client, this member is NULL and\n   * @a userhash_hex and @a userhash_bin are set.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username.\n   * When the @a username is NULL, this member is always zero.\n   */\n  size_t username_len;\n\n  /**\n   * The userhash string.\n   * Valid only if username type is userhash.\n   * This is unqoted string without decoding of the hexadecimal\n   * digits (as provided by the client).\n   * The buffer pointed by the @a userhash_hex becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @sa #MHD_digest_auth_calc_userhash_hex()\n   */\n  char *userhash_hex;\n\n  /**\n   * The length of the @a userhash_hex in characters.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) * 2 characters.\n   * When the @a userhash_hex is NULL, this member is always zero.\n   */\n  size_t userhash_hex_len;\n\n  /**\n   * The userhash decoded to binary form.\n   * Used only if username type is userhash, always NULL otherwise.\n   * When not NULL, this points to binary sequence @a userhash_hex_len /2 bytes\n   * long.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) bytes.\n   * The buffer pointed by the @a userhash_bin becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @warning This is a binary data, no zero termination.\n   * @warning To avoid buffer overruns, always check the size of the data before\n   *          use, because @a userhash_bin can point even to zero-sized\n   *          data.\n   * @sa #MHD_digest_auth_calc_userhash()\n   */\n  uint8_t *userhash_bin;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. With the usual ascending enum ordering (STANDARD = 0, EXTENDED = 1, USERHASH = 2), the test\n  MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type\nwill be true for all defined username types (including USERHASH). As a result the first return is always taken and the subsequent\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n(and the final return NULL comment) can never be reached. That is unreachable code, which violates MISRA C 2023 Rule 2.1. (If the enum had a different, unusual ordering the code might behave differently, but with the typical ordering used here the report is correct.)"
}