{
  "user_message": "An agent A claimed that the following find_entry_by_userinfo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of find_entry_by_userinfo.\n```c\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf username is not NUL-terminated (e.g. the code that produces username provides username_len but does not append a terminating '\\0'), the call strcmp(username, entry->username) will read past the end of the username buffer and therefore access memory beyond the bounds of the object referenced by username. This constitutes a violation of MISRA C 2023 Rule 21.17. Note: entry->username is static and NUL-terminated, so the risk is with the username operand potentially lacking termination.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_userinfo:\nstatic struct UserEntry *\nfind_entry_by_username (const char *const username)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n  {\n    struct UserEntry *entry;\n\n    entry = user_ids + i;\n    if (0 == strcmp (username, entry->username))\n      return entry;\n  }\n  return NULL;\n}\n...\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n...\n_MHD_EXTERN size_t\nMHD_digest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n  return digest_get_hash_size (algo3);\n}\n...\nstruct MHD_DigestAuthUsernameInfo\n{\n  /**\n   * The algorithm as defined by client.\n   * Set automatically to MD5 if not specified by client.\n   * @warning Do not be confused with #MHD_DigestAuthAlgorithm,\n   *          which uses other values!\n   */\n  enum MHD_DigestAuthAlgo3 algo3;\n\n  /**\n   * The type of username used by client.\n   * The 'invalid' and 'missing' types are not used in this structure,\n   * instead NULL is returned by #MHD_digest_auth_get_username3().\n   */\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /**\n   * The username string.\n   * Used only if username type is standard or extended, always NULL otherwise.\n   * If extended notation is used, this string is pct-decoded string\n   * with charset and language tag removed (i.e. it is original username\n   * extracted from the extended notation).\n   * When userhash is used by the client, this member is NULL and\n   * @a userhash_hex and @a userhash_bin are set.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username.\n   * When the @a username is NULL, this member is always zero.\n   */\n  size_t username_len;\n\n  /**\n   * The userhash string.\n   * Valid only if username type is userhash.\n   * This is unqoted string without decoding of the hexadecimal\n   * digits (as provided by the client).\n   * The buffer pointed by the @a userhash_hex becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @sa #MHD_digest_auth_calc_userhash_hex()\n   */\n  char *userhash_hex;\n\n  /**\n   * The length of the @a userhash_hex in characters.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) * 2 characters.\n   * When the @a userhash_hex is NULL, this member is always zero.\n   */\n  size_t userhash_hex_len;\n\n  /**\n   * The userhash decoded to binary form.\n   * Used only if username type is userhash, always NULL otherwise.\n   * When not NULL, this points to binary sequence @a userhash_hex_len /2 bytes\n   * long.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) bytes.\n   * The buffer pointed by the @a userhash_bin becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @warning This is a binary data, no zero termination.\n   * @warning To avoid buffer overruns, always check the size of the data before\n   *          use, because @a userhash_bin can point even to zero-sized\n   *          data.\n   * @sa #MHD_digest_auth_calc_userhash()\n   */\n  uint8_t *userhash_bin;\n}\n...\nstruct UserEntry\n{\n  /**\n   * The username.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *username;\n#if 0 /* Disabled code */\n  /* The cleartext password is not stored in the database.\n     The more secure \"userdigest\" is used instead. */\n  /**\n   * The password.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *password;\n#endif /* Disabled code */\n  /**\n   * The realm for this entry.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *realm;\n\n  /**\n   * The MD5 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_md5[MHD_MD5_DIGEST_SIZE];\n  /**\n   * The MD5 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_md5[MHD_MD5_DIGEST_SIZE];\n\n  /**\n   * The SHA-256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha256[MHD_SHA256_DIGEST_SIZE];\n  /**\n   * The SHA-256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha256[MHD_SHA256_DIGEST_SIZE];\n\n  /**\n   * The SHA-512/256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n  /**\n   * The SHA-512/256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n\n  /**\n   * User has access to \"area 1\" if non-zero\n   */\n  int allow_area_1;\n\n  /**\n   * User has access to \"area 2\" if non-zero\n   */\n  int allow_area_2;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. find_entry_by_username() uses strcmp(username, entry->username), and strcmp requires both operands to be NUL-terminated. The struct shown provides a username pointer and a username_len field but the comments do not guarantee that the buffer pointed to by username is NUL-terminated. If a producer of username supplies a non-terminated buffer (only providing username_len), strcmp will read past the end of that buffer, causing an out-of-bounds access and thus violating MISRA C 2023 Rule 21.17. The userhash path uses memcmp with explicit sizes and is safe; the standard/extended path is not safe unless the API guarantees termination or the code is changed to use bounded comparisons (e.g. strncmp/explicit length checks or ensure a terminating NUL)."
}