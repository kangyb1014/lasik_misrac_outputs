{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of find_entry_by_userinfo:\n```c\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_userinfo:\nstatic struct UserEntry *\nfind_entry_by_username (const char *const username)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n  {\n    struct UserEntry *entry;\n\n    entry = user_ids + i;\n    if (0 == strcmp (username, entry->username))\n      return entry;\n  }\n  return NULL;\n}\n...\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n...\n_MHD_EXTERN size_t\nMHD_digest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n  return digest_get_hash_size (algo3);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic struct UserEntry *\nfind_entry_by_username (const char *const username)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n  {\n    struct UserEntry *entry;\n\n    entry = user_ids + i;\n    if (0 == strcmp (username, entry->username))\n      return entry;\n  }\n  return NULL;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the provided code. find_entry_by_username does not call find_entry_by_userinfo (directly or indirectly), and find_entry_by_userhash likewise does not call back into find_entry_by_userinfo or find_entry_by_username. A specific violation scenario would be, for example, if find_entry_by_username called find_entry_by_userinfo (directly) or if a helper function was introduced so that find_entry_by_username -> helper -> find_entry_by_userinfo (indirect mutual recursion), which would violate Rule 17.2."
}