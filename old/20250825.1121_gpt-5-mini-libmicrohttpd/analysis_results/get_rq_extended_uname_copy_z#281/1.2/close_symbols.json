{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_str_pct_decode_strict_n_",
    "toxdigitvalue",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_STATICSTR_LEN_",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "mhd_assert",
    "ssize_t",
    "SSIZE_MAX"
  ],
  "explanation": "For verifying whether the target function itself (and the identifiers it depends on) use any compiler language extensions you must inspect the definitions of all called functions, macros, typedefs and constants that can introduce such extensions. Each listed symbol is required for the following reasons:\n\n- MHD_str_pct_decode_strict_n_: The function performs percent-decoding used directly in get_rq_extended_uname_copy_z. Its implementation may use compiler extensions (inline functions, statement-expressions, GCC builtins, __attribute__s, nested functions, asm, typeof, etc.). You must inspect it to ensure no language extensions are used that would make the target function rely on extensions.\n\n- toxdigitvalue: This is a direct callee of MHD_str_pct_decode_strict_n_. If toxdigitvalue uses language extensions (e.g. as an inline helper, macro with statement-expression, or compiler builtins), that could cause the decoding code to rely on extensions; therefore inspect it as well.\n\n- MHD_str_equal_caseless_bin_n_: Called by the target to check the prefix. Its implementation might be a macro or function that uses extensions (compiler builtins, attributes, inline asm, GCC statement-expressions, etc.). Inspecting it is necessary to determine whether the call in the target introduces an extension dependency.\n\n- MHD_STATICSTR_LEN_: This macro is used in the call to MHD_str_equal_caseless_bin_n_ and to compute r. Macros are a common place for nonstandard constructs (e.g. sizeof tricks, typeof, statement-expression, token-pasting unusual uses). You must expand/inspect this macro definition to check for extensions.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: The macro/constant value passed to MHD_STATICSTR_LEN_ and MHD_str_equal_caseless_bin_n_. Its definition may be a compound macro or use nonstandard string literal extensions (concatenation tricks, wide/UTF8 literal suffixes, or compiler-specific prefixes). Inspect to ensure no language extensions are involved.\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: Used as a compile-time/constant bound. Its definition may be a macro expression that relies on extensions (e.g. typeof, statement-expression, complex macros). Check it to ensure no extensions are introduced.\n\n- mhd_assert: Assertion macros frequently expand to compiler builtin calls or attributes (__builtin_expect, __PRETTY_FUNCTION__, __attribute__((...))). Verify its definition to ensure it does not use language extensions.\n\n- ssize_t: The typedef for ssize_t may be provided by system headers or project headers. While ssize_t itself is a standard POSIX type (not a C standard type), you must verify how it is defined in the build (typedef, compiler alias) and whether that definition uses language extensions (compiler-specific attributes, __int128, or nonstandard typedefs). It matters because the return type of the function could depend on nonstandard typedefs.\n\n- SSIZE_MAX: The macro used for the range check. Its definition comes from limits headers and could be a macro expression or compiler-provided macro. Verify its origin/definition to ensure it is not a compiler-specific extension or macro relying on extensions.\n\nNote: size_t and basic C syntax inside the function are standard; they do not need separate listing unless the project headers redefine them. The focus is on functions/macros/typedefs/constants whose definitions might contain language extensions that would make the target function violate the MISRA prohibition on language extensions."
}