{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'get_rq_extended_uname_copy_z': {'callees': ['MHD_str_pct_decode_strict_n_'], 'callers': ['get_rq_uname', 'digest_auth_check_all_inner']}, 'MHD_str_pct_decode_strict_n_': {'callees': ['toxdigitvalue'], 'callers': ['get_rq_extended_uname_copy_z']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "SSIZE_MAX",
    "MHD_DAUTH_EXT_PARAM_MIN_LEN",
    "MHD_DAUTH_EXT_PARAM_PREFIX",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_str_pct_decode_strict_n_",
    "mhd_assert"
  ],
  "explanation": "MISRA rule under check: function parameters themselves must not be modified (pointer variables must not be reassigned). The target function uses the following macros/functions/constants whose definitions are needed to be sure none of them modify the parameter identifiers (uname_ext, uname_ext_len, buf, buf_size) via macro expansion or side effects:\n\n- SSIZE_MAX: used in a comparison with uname_ext_len. Include to confirm it is a simple constant macro/constant expression (no side effects or strange macro expansion that could assign to uname_ext_len).\n\n- MHD_DAUTH_EXT_PARAM_MIN_LEN: used in a comparison with uname_ext_len. Need its definition to ensure it is a plain constant and not a macro with side effects that could modify parameters.\n\n- MHD_DAUTH_EXT_PARAM_PREFIX: used as an argument to MHD_STATICSTR_LEN_. Include to confirm it is a static string/macro and that its expansion cannot alter uname_ext or other parameters.\n\n- MHD_STATICSTR_LEN_: used on the prefix macro. Its definition could be a macro that expands using its argument identifier; we must ensure it does not perform any assignment to any function parameter names.\n\n- MHD_str_equal_caseless_bin_n_: called with uname_ext (pointer parameter). If this is a macro (or a function-like macro) it might expand to code that assigns to its arguments; include its definition to ensure it does not reassign the uname_ext parameter identifier in this function.\n\n- MHD_str_pct_decode_strict_n_: called with (uname_ext + r), (uname_ext_len - r), buf and buf_size. If implemented as a macro it could reassign the names buf or buf_size or otherwise modify parameter identifiers by expansion; include its definition to ensure it does not reassign the caller's parameter variables. (Note: the called function writing through the buf pointer is allowed by the rule, but reassignment of the buf parameter itself would violate it.)\n\n- mhd_assert: typically a macro that can expand to code; include to ensure its expansion does not modify any parameter variables.\n\nNo deeper callees (e.g., toxdigitvalue) are required for this specific MISRA rule check because functions called normally cannot reassign the caller's parameter variables\u2014only macros expanding in this translation unit could. The listed symbols cover all macros/definitions in the target function that could, by expansion, modify parameter identifiers."
}