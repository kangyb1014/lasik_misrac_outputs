{
  "user_message": "Target function code is:\n```c\nstatic void\nsend_all (MHD_socket sock,\n          const char *buf,\n          size_t len)\n{\n  ssize_t ret;\n  size_t off;\n\n  make_blocking (sock);\n  for (off = 0; off < len; off += (size_t) ret)\n  {\n    ret = send (sock,\n                &buf[off],\n#if ! defined(_WIN32) || defined(__CYGWIN__)\n                len - off,\n#else  /* Native W32 */\n                (int) (len - off),\n#endif /* Native W32 */\n                0);\n    if (0 > ret)\n    {\n      if (EAGAIN == errno)\n      {\n        ret = 0;\n        continue;\n      }\n      break;\n    }\n    if (0 == ret)\n      break;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "send (declaration / prototype)",
    "ssize_t (type definition)",
    "MHD_socket (typedef / type definition)",
    "make_blocking (declaration)",
    "errno (macro / extern)",
    "EAGAIN (macro)",
    "_WIN32 (predefined compiler macro)",
    "__CYGWIN__ (predefined compiler macro)"
  ],
  "explanation": "To decide whether send_all uses any compiler language extensions you must inspect the declarations and platform macros it relies on:\n\n- send (declaration / prototype): The signature of send (return type and parameter types) can differ between platforms (ssize_t vs int, parameter types). If send's declaration in the included headers uses non\u2011standard attributes or non\u2011standard types (e.g. compiler-specific annotations or typedefs), that could be a language extension. You must see the exact prototype used when compiling this code.\n\n- ssize_t (type definition): ssize_t is a POSIX typedef (not part of ISO C). Its presence/definition may come from platform headers or project typedefs and could indicate use of a non\u2011standard type. Verify how ssize_t is provided (standard header, shim, or compiler/OS extension).\n\n- MHD_socket (typedef / type definition): This project-specific socket type may be defined in a way that uses platform or compiler extensions (e.g. as an alias to a compiler/OS specific handle type). You must inspect its definition to ensure it is standard C.\n\n- make_blocking (declaration): The prototype or attributes of make_blocking (e.g. non\u2011standard attributes, calling conventions, or inline/asm extensions) could introduce language extensions. Check its declaration/definition.\n\n- errno (macro / extern): errno and its related macros are provided by platform headers; some implementations provide errno as a macro to a thread-local or compiler-implemented entity (which might be a compiler extension). Verify how errno is provided in the target environment.\n\n- EAGAIN (macro): This error macro originates from POSIX. Its presence and use could indicate reliance on POSIX extensions. Check its definition/source header to confirm whether it comes from standard or extended headers.\n\n- _WIN32 and __CYGWIN__ (predefined compiler macros): These conditionals control which code path is compiled (casting length to int for native Win32). The compiler/target environment that defines these macros determines which variant is used. You must know which predefined macros are set (and any compiler-specific behavior tied to them) to judge whether the selected code path uses language extensions.\n\nTogether these symbols determine the exact types, prototypes and platform-specific mechanisms used by send_all. Inspecting their definitions/declarations is necessary to decide if the code depends on or uses any compiler/implementation language extensions that would violate the MISRA rule."
}