{
  "user_message": "An agent A claimed that the following MHD_connection_update_event_loop_info code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_update_event_loop_info.\n```c\nstatic void\nMHD_connection_update_event_loop_info (struct MHD_Connection *connection)\n{\n  /* Do not update states of suspended connection */\n  if (connection->suspended)\n    return; /* States will be updated after resume. */\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    switch (connection->tls_state)\n    {\n    case MHD_TLS_CONN_INIT:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      return;\n    case MHD_TLS_CONN_HANDSHAKING:\n    case MHD_TLS_CONN_WR_CLOSING:\n      if (0 == gnutls_record_get_direction (connection->tls_session))\n        connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      else\n        connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      return;\n    case MHD_TLS_CONN_CONNECTED:\n      break; /* Do normal processing */\n    case MHD_TLS_CONN_WR_CLOSED:\n    case MHD_TLS_CONN_TLS_FAILED:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n      return;\n    case MHD_TLS_CONN_TLS_CLOSING:  /* Not implemented yet */\n    case MHD_TLS_CONN_TLS_CLOSED:   /* Not implemented yet */\n    case MHD_TLS_CONN_INVALID_STATE:\n    case MHD_TLS_CONN_NO_TLS: /* Not possible */\n    default:\n      MHD_PANIC (_ (\"Invalid TLS state value.\\n\"));\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n  while (1)\n  {\n#if DEBUG_STATES\n    MHD_DLOG (connection->daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      if ((connection->rq.some_payload_processed) &&\n          has_unprocessed_upload_body_data_in_buffer (connection))\n      {\n        /* Some data was processed, the buffer must have some free space */\n        mhd_assert (connection->read_buffer_offset < \\\n                    connection->read_buffer_size);\n        if (! connection->rq.have_chunked_upload)\n        {\n          /* Not a chunked upload. Do not read more than necessary to\n             process the current request. */\n          if (connection->rq.remaining_upload_size >=\n              connection->read_buffer_offset)\n            connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS;\n          else\n            connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS_READ;\n        }\n        else\n        {\n          /* Chunked upload. The size of the current request is unknown.\n             Continue reading as the space in the read buffer is available. */\n          connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS_READ;\n        }\n      }\n      else\n        connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS;\n      break;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* headers in buffer, keep writing */\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS;\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS;\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      mhd_assert (0);\n      break;\n    case MHD_CONNECTION_CLOSED:\n      connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n      return;           /* do nothing, not even reading */\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      mhd_assert (0);\n      break;\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n    }\n\n    if (0 != (MHD_EVENT_LOOP_INFO_READ & connection->event_loop_info))\n    {\n      /* Check whether the space is available to receive data */\n      if (! check_and_grow_read_buffer_space (connection))\n      {\n        mhd_assert (connection->discard_request);\n        continue;\n      }\n    }\n    break; /* Everything was processed. */\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe mhd_assert(...) statement is a diagnostic check that is typically implemented as a macro that expands to a runtime check (and abort/report) in debug builds but to a no-op (e.g. ((void)0)) in release builds. In that configuration the assertion code has no effect on the released program, so the operation (the assertion invocation) is effectively dead: its presence or removal does not affect the program behaviour in the release build. This matches MISRA C 2023 Rule 2.2\u2019s definition of dead code.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_connection_update_event_loop_info:\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\n#define UPGRADE_SUPPORT 1\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct, subject to one important caveat. The function contains many calls to mhd_assert(...). Typical implementations of such assertion macros expand to a runtime check (possibly aborting) in debug builds but to a no-op (for example ((void)0)) in release builds. When mhd_assert becomes a no-op the assertion calls are executed but have no effect on program behaviour; removing them would not change behaviour of the release build. That exactly matches the definition of dead code in MISRA C 2023 Rule 2.2, so the project contains dead code in that configuration.\n\nCaveat: If in this particular project mhd_assert is implemented so that it still has observable behaviour or side\u2011effects in the release build (for example logging, altering state, or aborting), then the calls are not dead and there is no violation. The correctness of the report therefore depends on how mhd_assert is defined for the project build being assessed. Given the scenario described (mhd_assert is a no\u2011op in release), the report is correct."
}