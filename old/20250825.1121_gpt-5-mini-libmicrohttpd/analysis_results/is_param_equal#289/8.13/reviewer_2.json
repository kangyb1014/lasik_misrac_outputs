{
  "user_message": "An agent A claimed that the following is_param_equal code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal.\n```c\n_MHD_static_inline bool\nis_param_equal (const struct MHD_RqDAuthParam *param,\n                const char *const str,\n                const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis fragment violates MISRA C 2023 Rule 8.13 if the member param->value.str is declared as char * (i.e. pointer to non-const char). The function only reads the bytes (passes the pointer to MHD_str_equal_quoted_bin_n and memcmp, both taking const-qualified pointers), so the member should be declared as const char * (or equivalent) so that the pointer points to a const-qualified type. If value.str is already declared as const char * then there is no violation.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified targets wherever possible. In the shown function, param is a pointer to const struct MHD_RqDAuthParam, but that only prevents changing the struct object through param \u2014 it does not make the member value.str point to a const-qualified target. If value.str is declared as char * (pointer to non-const char) but is only read (passed to functions that take const pointers such as memcmp and MHD_str_equal_quoted_bin_n), then according to 8.13 it should instead be declared as const char * (or an equivalent const-qualified type). If value.str is already declared as const char * there is no violation. Note: if other code legitimately needs to modify the buffer pointed to by value.str, then making it const would be inappropriate; in that case the declaration is justified and no change should be made."
}