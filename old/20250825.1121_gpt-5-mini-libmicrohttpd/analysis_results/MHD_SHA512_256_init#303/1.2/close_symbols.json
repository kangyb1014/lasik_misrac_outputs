{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA512_256_init (struct Sha512_256Ctx *ctx)\n{\n  /* Initial hash values, see FIPS PUB 180-4 clause 5.3.6.2 */\n  /* Values generated by \"IV Generation Function\" as described in\n   * clause 5.3.6 */\n  ctx->H[0] = UINT64_C (0x22312194FC2BF72C);\n  ctx->H[1] = UINT64_C (0x9F555FA3C84C64C2);\n  ctx->H[2] = UINT64_C (0x2393B86B6F53B151);\n  ctx->H[3] = UINT64_C (0x963877195940EABD);\n  ctx->H[4] = UINT64_C (0x96283EE2A88EFFE3);\n  ctx->H[5] = UINT64_C (0xBE5E1E2553863992);\n  ctx->H[6] = UINT64_C (0x2B0199FC2C85B8AA);\n  ctx->H[7] = UINT64_C (0x0EB72DDC81C52CA2);\n\n  /* Initialise number of bytes and high part of number of bits. */\n  ctx->count = 0;\n  ctx->count_bits_hi = 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA512_256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_reset': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "UINT64_C",
    "struct Sha512_256Ctx",
    "uint64_t (and other integer typedefs used by Sha512_256Ctx)",
    "stdint.h (or project header that defines UINT64_C / integer typedefs)",
    "__STDC_VERSION__, __GNUC__, __GNUC_MINOR__, __clang__, _MSC_VER (compiler feature macros)"
  ],
  "explanation": "1) UINT64_C: The code uses the UINT64_C macro for the hex constants. To verify whether the code uses a language extension you must inspect the macro definition/expansion \u2014 it might expand to implementation-specific token pasting, use compiler-specific suffixes or __extension__ annotations.  \n\n2) struct Sha512_256Ctx: The exact struct definition (types and member declarations for H[], count and count_bits_hi) is required to ensure no nonstandard/extended constructs are used in the declaration (e.g. unnamed structs/unions, compiler attributes, bit-field widths using extensions, flexible array members, nonstandard storage-class specifiers). The initializer assignments in the function depend on the member types.  \n\n3) uint64_t (and other integer typedefs used by Sha512_256Ctx): The typedefs for the integer types used in the struct must be known to verify they are standard typedefs (from stdint.h) and that their definitions do not rely on compiler-specific extensions.  \n\n4) stdint.h (or the project header that defines UINT64_C / integer typedefs): The header that provides UINT64_C and the fixed-width integer typedefs must be inspected because many implementations provide compatibility wrappers or extension-heavy definitions; MISRA compliance depends on whether those headers use language extensions.  \n\n5) Compiler feature/preprocessor macros (__STDC_VERSION__, __GNUC__, __GNUC_MINOR__, __clang__, _MSC_VER, etc.): These macros determine how stdint.h (or the project headers) choose their definitions and whether they emit extension constructs (e.g. guarded use of __extension__). To determine whether any expansion or typedef uses a compiler extension you need the compiler/feature macros that affect header behaviour."
}