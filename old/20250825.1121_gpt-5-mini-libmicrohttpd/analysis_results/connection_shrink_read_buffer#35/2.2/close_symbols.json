{
  "user_message": "Target function code is:\n```c\nstatic void\nconnection_shrink_read_buffer (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  void *new_buf;\n\n  if ((NULL == c->read_buffer) || (0 == c->read_buffer_size))\n  {\n    mhd_assert (0 == c->read_buffer_size);\n    mhd_assert (0 == c->read_buffer_offset);\n    return;\n  }\n\n  mhd_assert (c->read_buffer_offset <= c->read_buffer_size);\n  if (0 == c->read_buffer_offset)\n  {\n    MHD_pool_deallocate (c->pool, c->read_buffer, c->read_buffer_size);\n    c->read_buffer = NULL;\n    c->read_buffer_size = 0;\n  }\n  else\n  {\n    mhd_assert (MHD_pool_is_resizable_inplace (c->pool, c->read_buffer, \\\n                                               c->read_buffer_size));\n    new_buf = MHD_pool_reallocate (c->pool, c->read_buffer, c->read_buffer_size,\n                                   c->read_buffer_offset);\n    mhd_assert (c->read_buffer == new_buf);\n    c->read_buffer = new_buf;\n    c->read_buffer_size = c->read_buffer_offset;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'MHD_pool_deallocate': {'callees': [], 'callers': ['connection_shrink_read_buffer', 'transmit_error_response_len']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'connection_switch_from_recv_to_send': {'callees': ['connection_shrink_read_buffer'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (definition and invariants for read_buffer, read_buffer_size, read_buffer_offset, pool)",
    "mhd_assert (macro/function and build-time behavior e.g. NDEBUG)",
    "MHD_pool_deallocate (implementation/contract and side effects)",
    "MHD_pool_reallocate (implementation/contract: whether it can return a different pointer or must return same pointer when shrinking)",
    "MHD_pool_is_resizable_inplace (contract: what it guarantees and when)",
    "MHD_Pool (type and allocator semantics used by the pool_* functions)",
    "connection_switch_from_recv_to_send (caller and call context / when connection_shrink_read_buffer is invoked)",
    "Functions that modify connection read-buffer state elsewhere: try_grow_read_buffer, MHD_connection_alloc_memory_, MHD_connection_handle_read, connection_maximize_write_buffer (to know possible values and transitions of the three fields)",
    "Build/configuration options that affect allocation/assert behaviour (e.g. compile-time options that make pool_* behave differently or disable asserts)"
  ],
  "explanation": "To decide whether any operation in connection_shrink_read_buffer is dead (i.e. executed but removable without changing program behaviour) you must know: - struct MHD_Connection: the layout and invariants of read_buffer, read_buffer_size, read_buffer_offset and pool are required to judge whether branches are ever taken and whether writes (setting pointer/size to 0/NULL) are necessary. - mhd_assert: assertions may be compiled out; if assertions are no-ops removal would not change runtime behaviour in release builds, affecting dead-code classification. - MHD_pool_deallocate: you must know what side effects deallocation has (does it free memory, modify pool state, require setting pointer to NULL afterwards?) to tell if the subsequent assignments are necessary. - MHD_pool_reallocate: essential to know whether it can return a different pointer or must preserve the original pointer when shrinking; if it always returns the same pointer, the assignment c->read_buffer = new_buf could be redundant. - MHD_pool_is_resizable_inplace: the assert uses this predicate; its contract determines whether the realloc path is guaranteed to be in-place and therefore whether some statements are provably redundant. - MHD_Pool/type semantics: allocator semantics (ownership, validity of pointer after deallocate/reallocate) affect whether clearing fields is required to preserve behaviour. - connection_switch_from_recv_to_send: the caller and call context (when and why this shrink is called) help establish whether the function is actually executed in normal operation and whether removal of its operations would affect behaviour. - Other functions that modify the same fields (try_grow_read_buffer, MHD_connection_alloc_memory_, MHD_connection_handle_read, connection_maximize_write_buffer): their behaviour determines the possible value-space and transitions of read_buffer/read_buffer_size/read_buffer_offset; this is needed to prove (or disprove) that branches or assignments in shrink are redundant. - Build/configuration options: allocator or assert behaviour can change between builds; these options can make code live or effectively dead and must be known to judge MISRA dead-code. Each listed symbol provides required semantic information to determine whether executed operations in the target function are removable without changing program behaviour."
}