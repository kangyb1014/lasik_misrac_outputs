{
  "user_message": "Target function code is:\n```c\nstatic void\nconnection_shrink_read_buffer (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  void *new_buf;\n\n  if ((NULL == c->read_buffer) || (0 == c->read_buffer_size))\n  {\n    mhd_assert (0 == c->read_buffer_size);\n    mhd_assert (0 == c->read_buffer_offset);\n    return;\n  }\n\n  mhd_assert (c->read_buffer_offset <= c->read_buffer_size);\n  if (0 == c->read_buffer_offset)\n  {\n    MHD_pool_deallocate (c->pool, c->read_buffer, c->read_buffer_size);\n    c->read_buffer = NULL;\n    c->read_buffer_size = 0;\n  }\n  else\n  {\n    mhd_assert (MHD_pool_is_resizable_inplace (c->pool, c->read_buffer, \\\n                                               c->read_buffer_size));\n    new_buf = MHD_pool_reallocate (c->pool, c->read_buffer, c->read_buffer_size,\n                                   c->read_buffer_offset);\n    mhd_assert (c->read_buffer == new_buf);\n    c->read_buffer = new_buf;\n    c->read_buffer_size = c->read_buffer_offset;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'MHD_pool_deallocate': {'callees': [], 'callers': ['connection_shrink_read_buffer', 'transmit_error_response_len']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'connection_switch_from_recv_to_send': {'callees': ['connection_shrink_read_buffer'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_pool_is_resizable_inplace",
    "MHD_pool_reallocate",
    "MHD_pool_deallocate",
    "struct MHD_Connection (definition)",
    "type of c->pool (pool type / struct/typedef)"
  ],
  "explanation": "For checking violations of the MISRA rule forbidding compiler language extensions you must inspect not only the target function body but the definitions/expansions it uses, because extensions are frequently introduced via macros, attributes or non\u2011standard declarations. For each listed symbol explain why it is required:\n\n- mhd_assert\n  - This is almost certainly a macro. Macros often hide GCC/Clang extensions (statement-expression ({ ... }), typeof, inline assembly, __extension__ or __attribute__ usage). Inspecting its definition is required to determine whether the assert expands to any non\u2011standard language extensions.\n\n- MHD_pool_is_resizable_inplace\n  - Could be a macro or inline function. If it is a macro it may use extensions (statement expressions, typeof, inline asm). If it is an inline/extern function its signature might use compiler attributes or non\u2011standard qualifiers. You must inspect its definition to rule out extensions.\n\n- MHD_pool_reallocate\n  - This is a called routine; its declaration/definition may include compiler-specific attributes (e.g. __attribute__((malloc)), __attribute__((nonnull)), custom calling conventions, or non\u2011standard return/type constructs). If it is a macro wrapper it could hide extensions. Its prototype/implementation must be checked.\n\n- MHD_pool_deallocate\n  - Same rationale as MHD_pool_reallocate: the symbol may be a macro or use attributes/extension constructs in its declaration or implementation.\n\n- struct MHD_Connection (definition)\n  - The function relies on the structure layout and field types (read_buffer, read_buffer_size, read_buffer_offset, pool). The struct definition might itself use language extensions: anonymous structs/unions, bit\u2011fields with implementation specific types, __attribute__ annotations, packed/aligned pragmas, or compiler\u2011specific keywords. You must inspect the type definition to ensure no extensions are used.\n\n- type of c->pool (pool type / struct/typedef)\n  - The object pointed to by c->pool may be of a type (struct or typedef) whose declaration uses extensions (attributes, non\u2011standard qualifiers, unusual calling conventions, or macros). Also pool\u2011related macros or inline helpers associated with this type could introduce extensions; check that type and its API.\n\nNote: Standard macros like NULL and standard types (size_t) are normally from the implementation, but to detect explicit use of language extensions you mainly need to inspect the above macros/functions and the struct/type definitions because they are the likely places where compiler extensions are hidden."
}