{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_sec_counter_init': {'callees': [], 'callers': ['MHD_init']}, 'MHD_init': {'callees': ['MHD_set_panic_func', 'MHD_monotonic_sec_counter_init', 'MHD_send_init_static_vars_', 'MHD_init_mem_pools_'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_monotonic_sec_counter_init (prototype)",
    "Feature/compile-time macros: HAVE_CLOCK_GETTIME, HAVE_CLOCK_GET_TIME, HAVE_CLOCK_GETTIME, HAVE_GETHRTIME, HAVE_TIMESPEC_GET, HAVE_GETTIMEOFDAY, _WIN32, _WIN32_WINNT",
    "CLOCK_* macros used in branches: CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_FAST, CLOCK_MONOTONIC_RAW_APPROX, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_MONOTONIC, CLOCK_UPTIME, CLOCK_HIGHRES",
    "Global variables written/read in the function: mono_clock_id, mono_clock_start, mono_clock_service, mono_clock_source, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start",
    "MHD-related enum/constant symbols: _MHD_CLOCK_NO_SOURCE, _MHD_UNWANTED_CLOCK, _MHD_INVALID_CLOCK_SERV, _MHD_CLOCK_GETTIME, _MHD_CLOCK_GET_TIME, _MHD_CLOCK_GETTICKCOUNT64, _MHD_CLOCK_PERFCOUNTER, _MHD_CLOCK_GETHRTIME",
    "External/system types referenced: struct timespec, mach_timespec_t, struct timeval, LARGE_INTEGER, enum _MHD_mono_clock_source",
    "External functions / system calls invoked: clock_gettime, host_get_clock_service, mach_host_self, clock_get_time, mach_port_deallocate, GetTickCount64, QueryPerformanceFrequency, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time"
  ],
  "explanation": "Why each symbol is needed for MISRA C Rule analysis (\"function parameter shall not be modified\"): \n\n- MHD_monotonic_sec_counter_init (prototype): needed to confirm the function signature (parameters). If the prototype shows no parameters (void) then the rule is trivially satisfied; if the declaration differs (macro expansion, different prototype), that must be known. \n\n- Feature/compile-time macros (HAVE_..., _WIN32, _WIN32_WINNT): these determine which blocks of code are actually compiled. To decide whether any parameter-modifying code exists you must know which branches are active in the build. \n\n- CLOCK_* macros used in branches: these macros control which clock_gettime calls are compiled. Knowing which CLOCK_* symbols exist affects which code (and which assignments) are present; some macros could also be defined as expressions or wrappers in the build environment. \n\n- Global variables written/read (mono_clock_id, mono_clock_start, mono_clock_service, mono_clock_source, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start): the function assigns to these names extensively. To determine whether assignments are to local variables, parameters, or globals (relevant because MISRA rule applies to parameters) you must know their declarations (storage class). If any of these names were actually macro aliases for a function parameter or expanded into parameter-modifying code, that would matter. \n\n- MHD-related enum/constant symbols (_MHD_CLOCK_... etc.): these are used as RHS/LHS values and to compare against variables (e.g., mono_clock_source). Their definitions (enum vs macro) help determine whether any of them hide or alias parameters or have side effects. \n\n- External/system types (struct timespec, mach_timespec_t, struct timeval, LARGE_INTEGER, enum _MHD_mono_clock_source): needed to understand whether objects passed by pointer are pointer parameters (allowed to have their pointee modified) or whether some variable names are actually function parameters of pointer type. Also required to check whether any assignment is actually modifying a pointer parameter vs the object pointed to. \n\n- External functions / system calls invoked (clock_gettime, host_get_clock_service, mach_host_self, clock_get_time, mach_port_deallocate, GetTickCount64, QueryPerformanceFrequency, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time): the prototypes and usual signatures tell whether the function calls take pointer parameters that could be modified by the callee (allowed) versus whether any of those calls are macros that might expand into code that assigns to a parameter of MHD_monotonic_sec_counter_init. Also needed to confirm these names are not macro-defined to something that would alter the function's own parameters. \n\nIn short: to verify the MISRA rule for this function you must confirm the function signature and which compilation branches and symbol definitions are active and ensure that every assignment in the compiled code targets globals or local objects (or pointees of pointer parameters) and not the function's own parameters. The listed symbols are those whose definitions or compile-time presence affect that determination."
}