{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n  {\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_COARSE;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_FAST;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW_APPROX\n  /* Darwin-specific clock */\n  /* Not affected by frequency adjustment, returns clock value cached at\n   * context switch. Can be \"milliseconds old\", but it's fast. */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW_APPROX,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW_APPROX;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux and Darwin clock */\n  /* Not affected by frequency adjustment,\n   * on Linux don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC_RAW;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Count time in suspend on Linux so it's real monotonic, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_BOOTTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_MONOTONIC;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_MONOTONIC */\n#ifdef CLOCK_UPTIME\n  /* non-Linux clock */\n  /* Doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_UPTIME,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_UPTIME;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self (),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n  {\n    mono_clock_start = cur_time.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GET_TIME;\n  }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n  {\n    tick_start = GetTickCount64 ();\n    mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n  }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n  {\n    LARGE_INTEGER freq;\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceFrequency (&freq);       /* never fail on XP and later */\n    QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n    perf_freq = (uint64_t) freq.QuadPart;\n    perf_start = (uint64_t) perf_counter.QuadPart;\n    mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n  }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n  {\n    mono_clock_id = CLOCK_HIGHRES;\n    mono_clock_start = ts.tv_sec;\n    mono_clock_source = _MHD_CLOCK_GETTIME;\n  }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n  {\n    hrtime_start = gethrtime ();\n    mono_clock_source = _MHD_CLOCK_GETHRTIME;\n  }\n  else\n#endif /* HAVE_GETHRTIME */\n  {\n    /* no suitable clock source was found */\n    mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n  }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n  {\n    /* clock service was initialised but clock_get_time failed */\n    mach_port_deallocate (mach_task_self (),\n                          mono_clock_service);\n    mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n  }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n#ifdef HAVE_TIMESPEC_GET\n  if (1)\n  {\n    struct timespec tsg;\n    if (TIME_UTC == timespec_get (&tsg, TIME_UTC))\n      gettime_start = tsg.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      gettime_start = tv.tv_sec;\n    else\n      gettime_start = 0;\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n  sys_clock_start = time (NULL);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_sec_counter_init': {'callees': [], 'callers': ['MHD_init']}, 'MHD_init': {'callees': ['MHD_set_panic_func', 'MHD_monotonic_sec_counter_init', 'MHD_send_init_static_vars_', 'MHD_init_mem_pools_'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GET_TIME",
    "HAVE_CLOCK_GETTIME",
    "HAVE_GETHRTIME",
    "HAVE_TIMESPEC_GET",
    "HAVE_GETTIMEOFDAY",
    "_WIN32",
    "_WIN32_WINNT",
    "CLOCK_MONOTONIC_COARSE",
    "CLOCK_MONOTONIC_FAST",
    "CLOCK_MONOTONIC_RAW_APPROX",
    "CLOCK_MONOTONIC_RAW",
    "CLOCK_BOOTTIME",
    "CLOCK_MONOTONIC",
    "CLOCK_UPTIME",
    "CLOCK_HIGHRES",
    "enum _MHD_mono_clock_source",
    "_MHD_CLOCK_NO_SOURCE",
    "_MHD_CLOCK_GETTIME",
    "_MHD_CLOCK_GET_TIME",
    "_MHD_CLOCK_GETTICKCOUNT64",
    "_MHD_CLOCK_PERFCOUNTER",
    "_MHD_CLOCK_GETHRTIME",
    "_MHD_UNWANTED_CLOCK",
    "_MHD_INVALID_CLOCK_SERV",
    "mono_clock_id",
    "mono_clock_start",
    "mono_clock_service",
    "tick_start",
    "perf_freq",
    "perf_start",
    "hrtime_start",
    "gettime_start",
    "sys_clock_start",
    "clock_gettime",
    "host_get_clock_service",
    "mach_host_self",
    "clock_get_time",
    "mach_port_deallocate",
    "mach_task_self",
    "GetTickCount64",
    "QueryPerformanceFrequency",
    "QueryPerformanceCounter",
    "gethrtime",
    "timespec_get",
    "gettimeofday",
    "time",
    "KERN_SUCCESS",
    "struct timespec",
    "mach_timespec_t",
    "struct timeval"
  ],
  "explanation": "Needed symbols and why:\n\n- Feature-test macros (HAVE_CLOCK_GET_TIME, HAVE_CLOCK_GETTIME, HAVE_GETHRTIME, HAVE_TIMESPEC_GET, HAVE_GETTIMEOFDAY, _WIN32, _WIN32_WINNT): control which blocks of code are compiled into MHD_monotonic_sec_counter_init. A different compilation configuration could expose code containing for-loops or change which expressions/functions execute; you must know which branches are present to judge MISRA compliance (a for loop anywhere in an included branch matters).\n\n- Clock-selection macros (CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_FAST, CLOCK_MONOTONIC_RAW_APPROX, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_MONOTONIC, CLOCK_UPTIME, CLOCK_HIGHRES): gate platform-specific branches. These are preprocessor/compile-time selectors; their presence/absence determines included code paths that must be inspected for for-loops or for-loop-related side effects.\n\n- Enum and clock-source constants (enum _MHD_mono_clock_source, _MHD_CLOCK_NO_SOURCE, _MHD_CLOCK_GETTIME, _MHD_CLOCK_GET_TIME, _MHD_CLOCK_GETTICKCOUNT64, _MHD_CLOCK_PERFCOUNTER, _MHD_CLOCK_GETHRTIME, _MHD_UNWANTED_CLOCK, _MHD_INVALID_CLOCK_SERV): used and assigned in the function. Knowing their definitions is necessary to determine whether any of these are macros or inline constructs that could hide loops, and to understand whether any assigned global could act as a loop counter or control flag referenced elsewhere.\n\n- Global variables written (mono_clock_id, mono_clock_start, mono_clock_service, tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start): these are modified by the function. MISRA forbids modifying a for-loop counter in the loop body; to check that, we must know whether any of these globals might be (or alias) a loop counter in a for loop inside this function or in code expanded into it (e.g., via macros). Also if any of these are used in loop control expressions they must be examined.\n\n- Called functions and related symbols (clock_gettime, host_get_clock_service, mach_host_self, clock_get_time, mach_port_deallocate, mach_task_self, GetTickCount64, QueryPerformanceFrequency, QueryPerformanceCounter, gethrtime, timespec_get, gettimeofday, time, KERN_SUCCESS): these are invoked (or their return values/constants are tested). According to the MISRA clause, the behaviour of functions called from within a for-statement counts as part of the for-loop body; therefore we must know whether any of these are macros, inline functions or otherwise expand to or contain for-loops or modify potential loop counters. Also some platform APIs could be #defined to different implementations on some platforms.\n\n- Types used by the calls (struct timespec, mach_timespec_t, struct timeval): presence/definitions may reveal inline helpers or macros in headers that contain loops. Knowing these types helps locate the headers/implementations to ensure no hidden for-loops are introduced via macros/inline functions.\n\nIn short: to determine compliance with the MISRA for-loop rule you must know exactly which conditional branches compile in and whether any macros/inline functions called or referenced (or globals written) introduce or participate in for-loops or loop counters. The symbols above are the compile-time guards, constants, globals and called routines whose definitions must be inspected to make that determination."
}