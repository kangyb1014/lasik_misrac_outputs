{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_get_username3': {'callees': ['MHD_get_rq_dauth_params_', 'get_rq_uname_type', 'get_rq_unames_size', 'get_rq_uname'], 'callers': ['handle_sec_areas_req']}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}, 'get_rq_uname_type': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_unames_size': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'handle_sec_areas_req': {'callees': ['MHD_digest_auth_get_username3', 'reply_with_auth_required', 'find_entry_by_userinfo', 'MHD_digest_auth_check_digest3', 'get_m_QOP', 'reply_with_area1_pages', 'reply_with_forbidden', 'reply_with_area2_pages'], 'callers': ['ahc_main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "MHD_get_rq_dauth_params_",
    "struct MHD_RqDAuth",
    "get_rq_uname_type",
    "get_rq_unames_size",
    "get_rq_uname",
    "struct MHD_DigestAuthUsernameInfo",
    "MHD_calloc_",
    "free",
    "mhd_assert",
    "MHD_DIGEST_AUTH_UNAME_TYPE_MISSING",
    "MHD_DIGEST_AUTH_UNAME_TYPE_INVALID"
  ],
  "explanation": "For checking the MISRA rule \u201ca function parameter shall not be modified\u201d for MHD_digest_auth_get_username3 you must be sure the parameter identifier 'connection' is not assigned to or otherwise altered by this function (or by macros called from it). Include the following symbols and why:\n\n- struct MHD_Connection: the parameter type. Needed to verify whether 'connection' could be a macro/typedef or have unusual semantics that allow modification of the caller\u2019s variable.\n\n- MHD_get_rq_dauth_params_: the function (or macro) called with 'connection'. Its declaration/definition is required to ensure it is not a macro expansion or inline code that assigns to the argument expression (which could modify the local parameter variable if implemented as a macro that performs an assignment). Even if a regular function cannot reassign the caller\u2019s local variable, a macro could.\n\n- struct MHD_RqDAuth: type returned by the above call (params). Needed to understand subsequent uses of params (noting that modifying the pointed-to object is allowed) and to confirm no aliasing back to 'connection' occurs via params.\n\n- get_rq_uname_type, get_rq_unames_size, get_rq_uname: callees used after obtaining params. Include their prototypes/definitions to rule out any macro expansions or side-effects that could alias and modify 'connection' (e.g. via global state or bizarre macro-based code). Also to confirm they only operate on params/uname_info and do not attempt to modify 'connection' itself.\n\n- struct MHD_DigestAuthUsernameInfo: the allocated result type. Needed to check whether any code writes back through pointers that could alias 'connection' (unlikely but must be ruled out).\n\n- MHD_calloc_, free: allocation/free functions used here. Include their definitions/macros to ensure they are regular allocators/macros and do not perform unexpected modifications of locals (e.g. some projects use wrapper macros that could expand to code touching other symbols).\n\n- mhd_assert: assertion macro \u2014 its expansion could contain assignments in some builds; include to ensure it does not modify 'connection'.\n\n- MHD_DIGEST_AUTH_UNAME_TYPE_MISSING, MHD_DIGEST_AUTH_UNAME_TYPE_INVALID: constants used in comparisons. Include to understand control flow but mainly to confirm no macro weirdness.\n\nIn short: any callee or macro invoked with or near the 'connection' parameter, and the type definitions of the parameter and proximate pointers, must be examined to be certain no macro expansion or other inlined code assigns to the parameter identifier. These are the minimal symbols to inspect for that purpose."
}