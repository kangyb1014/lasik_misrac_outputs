{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_get_username3': {'callees': ['MHD_get_rq_dauth_params_', 'get_rq_uname_type', 'get_rq_unames_size', 'get_rq_uname'], 'callers': ['handle_sec_areas_req']}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}, 'get_rq_uname_type': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_unames_size': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'handle_sec_areas_req': {'callees': ['MHD_digest_auth_get_username3', 'reply_with_auth_required', 'find_entry_by_userinfo', 'MHD_digest_auth_check_digest3', 'get_m_QOP', 'reply_with_area1_pages', 'reply_with_forbidden', 'reply_with_area2_pages'], 'callers': ['ahc_main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_EXTERN",
    "struct MHD_DigestAuthUsernameInfo",
    "struct MHD_RqDAuth",
    "enum MHD_DigestAuthUsernameType",
    "MHD_DIGEST_AUTH_UNAME_TYPE_MISSING",
    "MHD_DIGEST_AUTH_UNAME_TYPE_INVALID",
    "MHD_get_rq_dauth_params_",
    "get_rq_uname_type",
    "get_rq_unames_size",
    "get_rq_uname",
    "MHD_calloc_",
    "mhd_assert"
  ],
  "explanation": "For checking the MISRA rule about language extensions you must inspect any macros, attributes, non\u2011standard declarations or non\u2011portable struct layouts used by the target function. Each listed symbol is required for that inspection:\n\n- MHD_EXTERN: could expand to compiler-specific storage-class or attribute annotations (e.g. __declspec, __attribute__) \u2014 these are language extensions that must be checked.\n- struct MHD_DigestAuthUsernameInfo: the function performs allocation and pointer arithmetic relative to this struct (uname_info + 1). The struct definition may contain flexible array members, zero\u2011length arrays (a common GCC extension), unnamed/bitfield members or attribute annotations on members \u2014 all potential extensions.\n- struct MHD_RqDAuth: the function reads params->algo3 and passes params into helpers. The struct definition may use extension features (attributes, bitfields, zero-length arrays) that affect portability.\n- enum MHD_DigestAuthUsernameType: needed to verify whether the enum is a plain standard enum or uses compiler-specific backing types or extensions in its declaration.\n- MHD_DIGEST_AUTH_UNAME_TYPE_MISSING and MHD_DIGEST_AUTH_UNAME_TYPE_INVALID: these constants may be macros or enum values; if macros they could hide extensions, so their definitions must be seen.\n- MHD_get_rq_dauth_params_: the callee\u2019s declaration may carry attributes (nonnull, malloc, format, visibility) or use non\u2011standard linkage that are language extensions.\n- get_rq_uname_type: its prototype could include attributes or compiler extensions; also checking its return type declaration ensures no extension is used.\n- get_rq_unames_size: same rationale as above \u2014 prototype/definition might use extensions affecting portability.\n- get_rq_uname: this helper is used to fill buffers; its prototype/definition could use GCC extensions (statement expressions, nonstandard parameter annotations, attributes) or nonportable behavior that the caller relies on.\n- MHD_calloc_: allocation wrapper might be a macro/function with attributes (e.g. __attribute__((malloc, alloc_size))) or a nonstandard implementation \u2014 must inspect to see if compiler extensions are present.\n- mhd_assert: typically a macro; its expansion may use compiler builtins (__builtin_expect, __builtin_trap), inline assembly or other extensions; must inspect to ensure no language extension is used.\n\nCollecting these symbols (their declarations/definitions) is sufficient to determine whether the target function or any declarations it depends on use language/compiler extensions prohibited by the MISRA rule."
}