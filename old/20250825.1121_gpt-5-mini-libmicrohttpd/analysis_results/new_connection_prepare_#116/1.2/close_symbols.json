{
  "user_message": "Target function code is:\n```c\nstatic struct MHD_Connection *\nnew_connection_prepare_ (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n  int eno = 0;\n\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d.\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n  {\n    /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Server reached connection limit. \" \\\n                 \"Closing inbound connection.\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return NULL;\n  }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n                               (const struct sockaddr *) addr,\n                               addrlen)) )\n  {\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n#if defined(EACCESS) && (EACCESS + 0 != 0)\n    errno = EACCESS;\n#endif\n    return NULL;\n  }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n  {\n    eno = errno;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    errno = eno;\n    return NULL;\n  }\n\n  if (! external_add)\n  {\n    connection->sk_corked = _MHD_OFF;\n    connection->sk_nodelay = _MHD_OFF;\n  }\n  else\n  {\n    connection->sk_corked = _MHD_UNKNOWN;\n    connection->sk_nodelay = _MHD_UNKNOWN;\n  }\n\n  if (0 < addrlen)\n  {\n    if (NULL == (connection->addr = malloc ((size_t) addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n      errno = eno;\n      return NULL;\n    }\n    memcpy (connection->addr,\n            addr,\n            (size_t) addrlen);\n  }\n  else\n    connection->addr = NULL;\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->is_nonip = sk_is_nonip;\n  connection->sk_spipe_suppress = sk_spipe_supprs;\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&connection->tid);\n#endif /* MHD_USE_THREADS */\n  connection->daemon = daemon;\n  connection->connection_timeout_ms = daemon->connection_timeout_ms;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n  if (0 != connection->connection_timeout_ms)\n    connection->last_activity = MHD_monotonic_msec_counter ();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n  {\n    /* set default connection handlers  */\n    MHD_set_http_callbacks_ (connection);\n  }\n  else\n  {\n#ifdef HTTPS_SUPPORT\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030500)\n    gnutls_init_flags_t\n#else\n    unsigned int\n#endif\n    flags;\n\n    flags = GNUTLS_SERVER;\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030402)\n    flags |= GNUTLS_NO_SIGNAL;\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n    flags |= GNUTLS_NONBLOCK;\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030603)\n    if (0 != (daemon->options & MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT))\n      flags |= GNUTLS_POST_HANDSHAKE_AUTH;\n#endif\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030605)\n    if (0 != (daemon->options & MHD_USE_INSECURE_TLS_EARLY_DATA))\n      flags |= GNUTLS_ENABLE_EARLY_DATA;\n#endif\n    connection->tls_state = MHD_TLS_CONN_INIT;\n    MHD_set_https_callbacks (connection);\n    if ((GNUTLS_E_SUCCESS != gnutls_init (&connection->tls_session, flags)) ||\n        (GNUTLS_E_SUCCESS != gnutls_priority_set (connection->tls_session,\n                                                  daemon->priority_cache)))\n    {\n      if (NULL != connection->tls_session)\n        gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise TLS session.\\n\"));\n#endif\n#if defined(EPROTO) && (EPROTO + 0 != 0)\n      errno = EPROTO;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030200)\n    if (! daemon->disable_alpn)\n    {\n      static const char prt1[] = \"http/1.1\"; /* Registered code for HTTP/1.1 */\n      static const char prt2[] = \"http/1.0\"; /* Registered code for HTTP/1.0 */\n      static const gnutls_datum_t prts[2] =\n      { {_MHD_DROP_CONST (prt1), MHD_STATICSTR_LEN_ (prt1)},\n        {_MHD_DROP_CONST (prt2), MHD_STATICSTR_LEN_ (prt2)} };\n\n      if (GNUTLS_E_SUCCESS !=\n          gnutls_alpn_set_protocols (connection->tls_session,\n                                     prts,\n                                     sizeof(prts) / sizeof(prts[0]),\n                                     0 /* | GNUTLS_ALPN_SERVER_PRECEDENCE */))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to set ALPN protocols.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n        (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n      }\n    }\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030200 */\n    gnutls_session_set_ptr (connection->tls_session,\n                            connection);\n    switch (daemon->cred_type)\n    {\n    /* set needed credentials for certificate authentication. */\n    case GNUTLS_CRD_CERTIFICATE:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_CERTIFICATE,\n                              daemon->x509_cred);\n      break;\n    case GNUTLS_CRD_PSK:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_PSK,\n                              daemon->psk_cred);\n      gnutls_psk_set_server_credentials_function (daemon->psk_cred,\n                                                  &psk_gnutls_adapter);\n      break;\n    case GNUTLS_CRD_ANON:\n    case GNUTLS_CRD_SRP:\n    case GNUTLS_CRD_IA:\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to setup TLS credentials: \" \\\n                   \"unknown credential type %d.\\n\"),\n                daemon->cred_type);\n#endif\n      gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n      MHD_PANIC (_ (\"Unknown credential type.\\n\"));\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n      errno = EINVAL;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030109) && ! defined(_WIN64)\n    gnutls_transport_set_int (connection->tls_session,\n                              (int) (client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n    gnutls_transport_set_ptr (connection->tls_session,\n                              (gnutls_transport_ptr_t) \\\n                              (intptr_t) client_socket);\n#endif /* GnuTLS before 3.1.9 or Win x64 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n    gnutls_transport_set_push_function (connection->tls_session,\n                                        MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n    if (daemon->https_mem_trust)\n      gnutls_certificate_server_set_request (connection->tls_session,\n                                             GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    free (connection->addr);\n    free (connection);\n    MHD_PANIC (_ (\"TLS connection on non-TLS daemon.\\n\"));\n#if 0\n    /* Unreachable code */\n    eno = EINVAL;\n    return NULL;\n#endif\n#endif /* ! HTTPS_SUPPORT */\n  }\n\n  return connection;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'MHD_ip_limit_add': {'callees': ['MHD_get_master', 'MHD_ip_addr_to_key', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_DLOG'], 'callers': ['new_connection_prepare_']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_ip_limit_del': {'callees': ['MHD_get_master', 'MHD_ip_addr_to_key', 'MHD_ip_count_lock', '__builtin_unreachable', 'MHD_ip_count_unlock'], 'callers': ['new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'MHD_cleanup_connections']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_set_http_callbacks_': {'callees': [], 'callers': ['new_connection_prepare_']}, 'internal_add_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'new_connection_prepare_', 'new_connection_process_'], 'callers': ['MHD_add_connection', 'MHD_accept_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "__builtin_unreachable",
    "_MHD_DROP_CONST",
    "MHD_STATICSTR_LEN_",
    "MHD_PANIC",
    "MHD_DLOG",
    "gnutls_transport_set_ptr",
    "gnutls_transport_set_int",
    "gnutls_transport_ptr_t",
    "intptr_t"
  ],
  "explanation": "You must inspect the definitions of these symbols to decide whether the target function uses compiler or library language extensions: \n\n- __builtin_unreachable: a known GCC/clang builtin. If referenced or used (directly or via macros) it is an explicit compiler extension; its presence would violate the MISRA prohibition on language extensions.  \n\n- _MHD_DROP_CONST: used in the prts initializer to drop const from string literals. Its implementation might use non-standard casts or compiler builtins to discard const qualifiers. The exact macro expansion must be inspected to see if it uses compiler extensions (e.g. GCC-specific casts or builtins).  \n\n- MHD_STATICSTR_LEN_: macro used with string literals to get length; its definition could use sizeof-based tricks or compiler extensions (unlikely but must be checked).  \n\n- MHD_PANIC: a macro that likely terminates or annotates unreachable code; its definition may use compiler-specific attributes (noreturn), builtins or inline assembly \u2014 all potential language extensions.  \n\n- MHD_DLOG: logging macro used in conditional debug paths; logging macros commonly use variadic macros or compiler attributes (format) or builtins. Need its definition to ensure it does not rely on compiler-specific extensions.  \n\n- gnutls_transport_set_ptr and gnutls_transport_set_int: these GNUTLS APIs are used conditionally. Their prototypes and how they expect/typedef transport pointers may rely on non-standard pointer/int conversions or typedefs that are implementation-specific. Inspecting their declarations will show whether the code is performing implementation-defined or extension behavior.  \n\n- gnutls_transport_ptr_t: the GNUTLS transport pointer typedef; its underlying type (pointer, integer, opaque) must be checked because the code casts between socket integer and this type (possible implementation-defined behavior or reliance on non-standard typedefs).  \n\n- intptr_t: the code casts the socket value via (intptr_t). While intptr_t is standard C99, the use and availability should be confirmed; also casting integers to pointer types via intptr_t then to gnutls_transport_ptr_t can be implementation-defined and may rely on extensions on some platforms.  \n\nTogether these symbols cover the spots in the target function where non-standard builtins, pointer/int casts, macros that drop const or annotate unreachable code, or compiler-annotated macros could introduce language extensions. Inspecting their definitions (macros, typedefs, and function prototypes) is required to determine compliance with the MISRA rule forbidding language extensions."
}