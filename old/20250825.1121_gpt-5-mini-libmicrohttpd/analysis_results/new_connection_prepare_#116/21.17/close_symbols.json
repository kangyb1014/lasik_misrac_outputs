{
  "user_message": "Target function code is:\n```c\nstatic struct MHD_Connection *\nnew_connection_prepare_ (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n  int eno = 0;\n\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d.\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n  {\n    /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Server reached connection limit. \" \\\n                 \"Closing inbound connection.\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return NULL;\n  }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n                               (const struct sockaddr *) addr,\n                               addrlen)) )\n  {\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n#if defined(EACCESS) && (EACCESS + 0 != 0)\n    errno = EACCESS;\n#endif\n    return NULL;\n  }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n  {\n    eno = errno;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    errno = eno;\n    return NULL;\n  }\n\n  if (! external_add)\n  {\n    connection->sk_corked = _MHD_OFF;\n    connection->sk_nodelay = _MHD_OFF;\n  }\n  else\n  {\n    connection->sk_corked = _MHD_UNKNOWN;\n    connection->sk_nodelay = _MHD_UNKNOWN;\n  }\n\n  if (0 < addrlen)\n  {\n    if (NULL == (connection->addr = malloc ((size_t) addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n      errno = eno;\n      return NULL;\n    }\n    memcpy (connection->addr,\n            addr,\n            (size_t) addrlen);\n  }\n  else\n    connection->addr = NULL;\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->is_nonip = sk_is_nonip;\n  connection->sk_spipe_suppress = sk_spipe_supprs;\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&connection->tid);\n#endif /* MHD_USE_THREADS */\n  connection->daemon = daemon;\n  connection->connection_timeout_ms = daemon->connection_timeout_ms;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n  if (0 != connection->connection_timeout_ms)\n    connection->last_activity = MHD_monotonic_msec_counter ();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n  {\n    /* set default connection handlers  */\n    MHD_set_http_callbacks_ (connection);\n  }\n  else\n  {\n#ifdef HTTPS_SUPPORT\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030500)\n    gnutls_init_flags_t\n#else\n    unsigned int\n#endif\n    flags;\n\n    flags = GNUTLS_SERVER;\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030402)\n    flags |= GNUTLS_NO_SIGNAL;\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n    flags |= GNUTLS_NONBLOCK;\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030603)\n    if (0 != (daemon->options & MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT))\n      flags |= GNUTLS_POST_HANDSHAKE_AUTH;\n#endif\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030605)\n    if (0 != (daemon->options & MHD_USE_INSECURE_TLS_EARLY_DATA))\n      flags |= GNUTLS_ENABLE_EARLY_DATA;\n#endif\n    connection->tls_state = MHD_TLS_CONN_INIT;\n    MHD_set_https_callbacks (connection);\n    if ((GNUTLS_E_SUCCESS != gnutls_init (&connection->tls_session, flags)) ||\n        (GNUTLS_E_SUCCESS != gnutls_priority_set (connection->tls_session,\n                                                  daemon->priority_cache)))\n    {\n      if (NULL != connection->tls_session)\n        gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise TLS session.\\n\"));\n#endif\n#if defined(EPROTO) && (EPROTO + 0 != 0)\n      errno = EPROTO;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030200)\n    if (! daemon->disable_alpn)\n    {\n      static const char prt1[] = \"http/1.1\"; /* Registered code for HTTP/1.1 */\n      static const char prt2[] = \"http/1.0\"; /* Registered code for HTTP/1.0 */\n      static const gnutls_datum_t prts[2] =\n      { {_MHD_DROP_CONST (prt1), MHD_STATICSTR_LEN_ (prt1)},\n        {_MHD_DROP_CONST (prt2), MHD_STATICSTR_LEN_ (prt2)} };\n\n      if (GNUTLS_E_SUCCESS !=\n          gnutls_alpn_set_protocols (connection->tls_session,\n                                     prts,\n                                     sizeof(prts) / sizeof(prts[0]),\n                                     0 /* | GNUTLS_ALPN_SERVER_PRECEDENCE */))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to set ALPN protocols.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n        (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n      }\n    }\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030200 */\n    gnutls_session_set_ptr (connection->tls_session,\n                            connection);\n    switch (daemon->cred_type)\n    {\n    /* set needed credentials for certificate authentication. */\n    case GNUTLS_CRD_CERTIFICATE:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_CERTIFICATE,\n                              daemon->x509_cred);\n      break;\n    case GNUTLS_CRD_PSK:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_PSK,\n                              daemon->psk_cred);\n      gnutls_psk_set_server_credentials_function (daemon->psk_cred,\n                                                  &psk_gnutls_adapter);\n      break;\n    case GNUTLS_CRD_ANON:\n    case GNUTLS_CRD_SRP:\n    case GNUTLS_CRD_IA:\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to setup TLS credentials: \" \\\n                   \"unknown credential type %d.\\n\"),\n                daemon->cred_type);\n#endif\n      gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n      MHD_PANIC (_ (\"Unknown credential type.\\n\"));\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n      errno = EINVAL;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030109) && ! defined(_WIN64)\n    gnutls_transport_set_int (connection->tls_session,\n                              (int) (client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n    gnutls_transport_set_ptr (connection->tls_session,\n                              (gnutls_transport_ptr_t) \\\n                              (intptr_t) client_socket);\n#endif /* GnuTLS before 3.1.9 or Win x64 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n    gnutls_transport_set_push_function (connection->tls_session,\n                                        MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n    if (daemon->https_mem_trust)\n      gnutls_certificate_server_set_request (connection->tls_session,\n                                             GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    free (connection->addr);\n    free (connection);\n    MHD_PANIC (_ (\"TLS connection on non-TLS daemon.\\n\"));\n#if 0\n    /* Unreachable code */\n    eno = EINVAL;\n    return NULL;\n#endif\n#endif /* ! HTTPS_SUPPORT */\n  }\n\n  return connection;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'MHD_ip_limit_add': {'callees': ['MHD_get_master', 'MHD_ip_addr_to_key', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_DLOG'], 'callers': ['new_connection_prepare_']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_ip_limit_del': {'callees': ['MHD_get_master', 'MHD_ip_addr_to_key', 'MHD_ip_count_lock', '__builtin_unreachable', 'MHD_ip_count_unlock'], 'callers': ['new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'MHD_cleanup_connections']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_set_http_callbacks_': {'callees': [], 'callers': ['new_connection_prepare_']}, 'internal_add_connection': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'new_connection_prepare_', 'new_connection_process_'], 'callers': ['MHD_add_connection', 'MHD_accept_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "internal_add_connection",
    "MHD_add_connection",
    "MHD_accept_connection",
    "accept",
    "struct MHD_Connection",
    "struct sockaddr_storage",
    "socklen_t",
    "MHD_calloc_",
    "malloc",
    "memcpy"
  ],
  "explanation": "For checking MISRA rule about string.h functions (memcpy) we must ensure the memcpy invocation cannot read or write out-of-bounds. Each symbol is required for the following reason:\n\n- internal_add_connection: The static call graph shows this function calls new_connection_prepare_. Inspecting internal_add_connection is necessary to see how the addr and addrlen arguments are produced and passed (origin of source buffer and length).\n\n- MHD_add_connection: A higher-level caller of internal_add_connection; inspect to follow the full call chain and see how address/length values may be supplied or transformed before reaching new_connection_prepare_.\n\n- MHD_accept_connection: Another caller in the chain that frequently wraps accept()/socket accept semantics. It may be the site where addr and addrlen are obtained from the OS (e.g. via accept) and therefore determines the valid size of the source buffer.\n\n- accept: The POSIX accept(2) semantics determine how addr and addrlen are set (returned length, limits); knowing accept behavior is required to verify that addrlen does not exceed the actual bytes available in the sockaddr_storage passed as addr.\n\n- struct MHD_Connection: The definition reveals the type and size/semantics of the destination field connection->addr (pointer) and any related fields (addr_len). This is necessary to confirm that malloc((size_t)addrlen) allocates the intended object and that memcpy writes exactly addrlen bytes into that allocation.\n\n- struct sockaddr_storage: The source buffer type; knowing its definition/size and how it is used by callers helps determine whether the addr pointer actually points to an object at least addrlen bytes long (e.g. addrlen should normally be <= sizeof(struct sockaddr_storage)).\n\n- socklen_t: Knowing the type (signed/unsigned width and range) is necessary to reason about casts to size_t, comparisons with 0, and whether addrlen can be negative or overflow when converted to size_t for malloc/memcpy.\n\n- MHD_calloc_: Implementation/semantics of this allocator wrapper may affect memory allocation error handling and whether zero-size allocations are handled in a way that could make subsequent memcpy unsafe. Confirming its behavior shows that the code either returns NULL or a valid pointer for the requested size.\n\n- malloc: The standard allocator semantics (particularly for very large sizes and malloc(0) behavior) are relevant to ensure that the allocation of (size_t)addrlen yields a buffer at least addrlen bytes long when non-NULL, preventing out-of-bounds writes by memcpy.\n\n- memcpy: The actual function from <string.h> being used; its documented behavior and requirements (both source and destination must be valid for the requested size) are the central concern of the MISRA rule. The definition/contract must be consulted when proving safety.\n\nTogether these symbols let the next analyst trace the origin and validity of addr and addrlen, confirm allocation semantics for connection->addr, and therefore determine whether the memcpy((connection->addr, addr, (size_t) addrlen)) can legally access beyond the bounds of the referenced objects."
}