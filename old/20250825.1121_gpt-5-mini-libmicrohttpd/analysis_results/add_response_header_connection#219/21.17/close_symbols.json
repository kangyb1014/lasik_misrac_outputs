{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_response_header_connection': {'callees': ['MHD_get_response_element_n_'], 'callers': ['MHD_add_response_header']}, 'MHD_get_response_element_n_': {'callees': [], 'callers': ['add_response_header_connection', 'del_response_header_connection', 'MHD_add_response_header', 'MHD_del_response_header']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response",
    "struct MHD_HTTP_Res_Header",
    "MHD_get_response_element_n_",
    "MHD_str_remove_token_caseless_",
    "MHD_str_remove_tokens_caseless_",
    "MHD_STATICSTR_LEN_",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_HEADER_KIND",
    "SSIZE_MAX",
    "malloc",
    "free",
    "memcpy",
    "memmove",
    "memcmp",
    "strlen",
    "strchr",
    "MHD_calloc_",
    "_MHD_insert_header_first",
    "mhd_assert"
  ],
  "explanation": "Explain why each symbol is required to assess potential out-of-bounds string/memory accesses:\n\n- struct MHD_Response\n  - Needed to know layout and types of members used (flags_auto, upgrade_handler, any other semantics). The code reads/writes response->flags_auto and tests upgrade_handler; correctness of bounds reasoning depends on the exact types/sizes and meaning of these fields.\n\n- struct MHD_HTTP_Res_Header\n  - Required to know the meaning and units of hdr->value and hdr->value_size and hdr->header/header_size fields. The code uses hdr->value_size to compute buffer sizes and copies hdr->value; must know whether value_size equals strlen(value) or includes the terminator, and whether hdr->value points to a buffer of at least value_size bytes.\n\n- MHD_get_response_element_n_\n  - The function returns hdr pointers used for sizes/pointers. Its contract determines whether hdr, hdr->value and hdr->value_size are valid and consistent. To prove memcpy/memmove do not read past hdr->value or write past allocated buffers we must know what this function guarantees about returned objects.\n\n- MHD_str_remove_token_caseless_\n  - This function writes into the temporary buffer (buf + old_value_len) and updates norm_len_s. The exact prototype/contract (maximum bytes written, whether it NUL-terminates, behavior on given dest length) is essential to prove that the allocation buf_size is sufficient and that subsequent uses of norm_len are correct.\n\n- MHD_str_remove_tokens_caseless_\n  - Similar to the previous symbol: it mutates the buffer and norm_len. Its behavior (how many bytes it may remove/shift, whether it NUL-terminates, how it interprets norm_len) is required to ensure later memcpy/memmove/memcpy into buf do not overflow.\n\n- MHD_STATICSTR_LEN_\n  - Macro used to compute the lengths of string literals (e.g. MHD_HTTP_HEADER_CONNECTION, \"close\", \"close, \"). Correct values are required when the code uses key_len, when allocating/memcpy\u2019ing (key_len+1), and when asserting buffer size for inserting \"close\". Off-by-one errors here directly affect bounds checks.\n\n- MHD_HTTP_HEADER_CONNECTION\n  - The key string copied into new_hdr->header and its length (via MHD_STATICSTR_LEN_) affect the allocation and the memcpy(key_len+1). The exact string/length is needed to verify that copying key plus NUL is safe.\n\n- MHD_RAF_HAS_CONNECTION_HDR and MHD_RAF_HAS_CONNECTION_CLOSE\n  - Flags used to infer whether hdr exists and whether the existing header value is the token \"close\". The logic that sets/reads these flags determines old_value_len and already_has_close, which are used in buffer-size calculations and decisions to insert tokens.\n\n- MHD_HEADER_KIND\n  - Used when calling MHD_get_response_element_n_ and when setting new_hdr->kind. Knowing its intended semantics helps confirm that the correct header is returned and that hdr->value/hdr->value_size correspond to connection header semantics.\n\n- SSIZE_MAX\n  - The code compares value_len and norm_len against SSIZE_MAX to avoid overflow when converting to ssize_t. The precise value and intent matter to reason about later casts and allocations and to ensure malloc(buf_size) size calculations cannot wrap or exceed implementation limits.\n\n- malloc and free\n  - Standard allocation semantics are used (malloc(buf_size), free(buf)). To verify no out-of-bounds writes, we must reason about the amount of memory allocated and whether all subsequent writes (including NUL terminator) fit in the allocation.\n\n- memcpy\n  - Several memcpy calls copy key (key_len+1) and hdr->value (hdr->value_size). To prove compliance, we need to know the exact source and destination sizes/lengths and that memcpy will not read beyond the source or write beyond the destination.\n\n- memmove\n  - Used to shift existing normalized tokens when inserting \"close,\". Its safety depends on computed offsets (pos, old_value_len, norm_len) and the allocated buf_size; exact memmove semantics are standard but we must ensure the computed lengths and source/destination ranges are within allocated buffers.\n\n- memcmp\n  - Used in an assertion comparing hdr->value to \"close\"; to trust the assertion we must know the expected layout/length of hdr->value and that memcmp reads the number of bytes passed (5) from hdr->value safely.\n\n- strlen\n  - Used to compute value_len from value. Correctness depends on value being a valid NUL-terminated string; knowing how value is passed/allocated by callers (MHD_add_response_header, etc.) matters to ensure strlen won't read out-of-bounds.\n\n- strchr\n  - Called to search for '\\r' and '\\n' in value. Again requires the value pointer be a valid NUL-terminated string and of sufficient length; its behavior affects early return and prevents CRLF injection. Bounds reasoning must assume valid input or prove callers guarantee it.\n\n- MHD_calloc_\n  - Wrapper used to allocate the new header structure. If its semantics differ from calloc (e.g. zeroing, failure modes), it could affect later code paths and memory layout assumptions.\n\n- _MHD_insert_header_first\n  - Inserts new_hdr into the response. Not directly a string op, but necessary to understand ownership/transfer of new_hdr->header/new_hdr->value and guarantee no subsequent mutation invalidates assumptions used in string copies.\n\n- mhd_assert\n  - The code relies on asserts to document invariants (e.g. buffer size, equality of flags and header contents). To determine compliance we must know whether mhd_assert is a no-op in production (cannot be relied on to prevent OOB) or aborting; that affects whether the assert can be used to guarantee safety or is only a developer check.\n\nSummary: to prove that calls to memcpy/memmove/memcmp/strlen/strchr do not access beyond buffer bounds you must know (a) the exact sizes returned/represented by hdr->value_size and key_len, (b) how MHD_str_remove_token(s)_caseless_ modify and NUL-terminate the temporary buffer and update norm_len, (c) the precise values/macros used to compute allocations (MHD_STATICSTR_LEN_, SSIZE_MAX), and (d) that the response/value inputs are valid NUL-terminated strings. The symbols above supply those contracts/values and are therefore required for a sound MISRA C bounds analysis."
}