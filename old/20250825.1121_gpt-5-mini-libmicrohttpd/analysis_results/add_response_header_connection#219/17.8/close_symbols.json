{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nadd_response_header_connection (struct MHD_Response *response,\n                                const char *value)\n{\n  static const char *key = MHD_HTTP_HEADER_CONNECTION;\n  /** the length of the \"Connection\" key */\n  static const size_t key_len =\n    MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONNECTION);\n  size_t value_len; /**< the length of the @a value */\n  size_t old_value_len; /**< the length of the existing \"Connection\" value */\n  size_t buf_size;  /**< the size of the buffer */\n  size_t norm_len;  /**< the length of the normalised value */\n  char *buf;        /**< the temporal buffer */\n  struct MHD_HTTP_Res_Header *hdr; /**< existing \"Connection\" header */\n  bool value_has_close; /**< the @a value has \"close\" token */\n  bool already_has_close; /**< existing \"Connection\" header has \"close\" token */\n  size_t pos = 0;   /**< position of addition in the @a buf */\n\n  if ( (NULL != strchr (value, '\\r')) ||\n       (NULL != strchr (value, '\\n')) )\n    return MHD_NO;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                       key, key_len);\n    already_has_close =\n      (0 != (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n    mhd_assert (already_has_close == (0 == memcmp (hdr->value, \"close\", 5)));\n    mhd_assert (NULL != hdr);\n  }\n  else\n  {\n    hdr = NULL;\n    already_has_close = false;\n    mhd_assert (NULL == MHD_get_response_element_n_ (response,\n                                                     MHD_HEADER_KIND,\n                                                     key, key_len));\n    mhd_assert (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE));\n  }\n  if (NULL != hdr)\n    old_value_len = hdr->value_size + 2; /* additional size for \", \" */\n  else\n    old_value_len = 0;\n\n  value_len = strlen (value);\n  if (value_len >= SSIZE_MAX)\n    return MHD_NO;\n  /* Additional space for normalisation and zero-termination */\n  norm_len = value_len + value_len / 2 + 1;\n  if (norm_len >= SSIZE_MAX)\n    return MHD_NO;\n  buf_size = old_value_len + (size_t) norm_len;\n\n  buf = malloc (buf_size);\n  if (NULL == buf)\n    return MHD_NO;\n  if (1)\n  { /* local scope */\n    ssize_t norm_len_s = (ssize_t) norm_len;\n    /* Remove \"close\" token (if any), it will be moved to the front */\n    value_has_close = MHD_str_remove_token_caseless_ (value, value_len, \"close\",\n                                                      MHD_STATICSTR_LEN_ ( \\\n                                                        \"close\"),\n                                                      buf + old_value_len,\n                                                      &norm_len_s);\n    mhd_assert (0 <= norm_len_s);\n    if (0 > norm_len_s)\n    {\n      /* Must never happen with realistic sizes */\n      free (buf);\n      return MHD_NO;\n    }\n    else\n      norm_len = (size_t) norm_len_s;\n  }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) && value_has_close)\n  { /* The \"close\" token cannot be used with connection \"upgrade\" */\n    free (buf);\n    return MHD_NO;\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (0 != norm_len)\n    MHD_str_remove_tokens_caseless_ (buf + old_value_len, &norm_len,\n                                     \"keep-alive\",\n                                     MHD_STATICSTR_LEN_ (\"keep-alive\"));\n  if (0 == norm_len)\n  { /* New value is empty after normalisation */\n    if (! value_has_close)\n    { /* The new value had no tokens */\n      free (buf);\n      return MHD_NO;\n    }\n    if (already_has_close)\n    { /* The \"close\" token is already present, nothing to modify */\n      free (buf);\n      return MHD_YES;\n    }\n  }\n  /* Add \"close\" token if required */\n  if (value_has_close && ! already_has_close)\n  {\n    /* Need to insert \"close\" token at the first position */\n    mhd_assert (buf_size >= old_value_len + norm_len   \\\n                + MHD_STATICSTR_LEN_ (\"close, \") + 1);\n    if (0 != norm_len)\n      memmove (buf + MHD_STATICSTR_LEN_ (\"close, \") + old_value_len,\n               buf + old_value_len, norm_len + 1);\n    memcpy (buf, \"close\", MHD_STATICSTR_LEN_ (\"close\"));\n    pos += MHD_STATICSTR_LEN_ (\"close\");\n  }\n  /* Add old value tokens (if any) */\n  if (0 != old_value_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    memcpy (buf + pos, hdr->value,\n            hdr->value_size);\n    pos += hdr->value_size;\n  }\n  /* Add new value token (if any) */\n  if (0 != norm_len)\n  {\n    if (0 != pos)\n    {\n      buf[pos++] = ',';\n      buf[pos++] = ' ';\n    }\n    /* The new value tokens must be already at the correct position */\n    mhd_assert ((value_has_close && ! already_has_close) ? \\\n                (MHD_STATICSTR_LEN_ (\"close, \") + old_value_len == pos) : \\\n                (old_value_len == pos));\n    pos += norm_len;\n  }\n  mhd_assert (buf_size > pos);\n  buf[pos] = 0; /* Null terminate the result */\n\n  if (NULL == hdr)\n  {\n    struct MHD_HTTP_Res_Header *new_hdr; /**< new \"Connection\" header */\n    /* Create new response header entry */\n    new_hdr = MHD_calloc_ (1, sizeof (struct MHD_HTTP_Res_Header));\n    if (NULL != new_hdr)\n    {\n      new_hdr->header = malloc (key_len + 1);\n      if (NULL != new_hdr->header)\n      {\n        memcpy (new_hdr->header, key, key_len + 1);\n        new_hdr->header_size = key_len;\n        new_hdr->value = buf;\n        new_hdr->value_size = pos;\n        new_hdr->kind = MHD_HEADER_KIND;\n        if (value_has_close)\n          response->flags_auto = (MHD_RAF_HAS_CONNECTION_HDR\n                                  | MHD_RAF_HAS_CONNECTION_CLOSE);\n        else\n          response->flags_auto = MHD_RAF_HAS_CONNECTION_HDR;\n        _MHD_insert_header_first (response, new_hdr);\n        return MHD_YES;\n      }\n      free (new_hdr);\n    }\n    free (buf);\n    return MHD_NO;\n  }\n\n  /* Update existing header entry */\n  free (hdr->value);\n  hdr->value = buf;\n  hdr->value_size = pos;\n  if (value_has_close && ! already_has_close)\n    response->flags_auto |= MHD_RAF_HAS_CONNECTION_CLOSE;\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_response_header_connection': {'callees': ['MHD_get_response_element_n_'], 'callers': ['MHD_add_response_header']}, 'MHD_get_response_element_n_': {'callees': [], 'callers': ['add_response_header_connection', 'del_response_header_connection', 'MHD_add_response_header', 'MHD_del_response_header']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_STATICSTR_LEN_",
    "mhd_assert",
    "MHD_str_remove_token_caseless_",
    "MHD_str_remove_tokens_caseless_",
    "MHD_get_response_element_n_",
    "_MHD_insert_header_first",
    "MHD_calloc_",
    "malloc",
    "free",
    "memcpy",
    "memmove",
    "strchr",
    "strlen",
    "memcmp",
    "struct MHD_Response",
    "struct MHD_HTTP_Res_Header",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_HEADER_KIND",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE"
  ],
  "explanation": "For checking the MISRA rule \u201cA function parameter should not be modified\u201d you must be sure that none of the items used in the function (directly or via macro expansion) assign to the parameter variables (response or value). The following symbols are needed and why:\n\n- MHD_STATICSTR_LEN_: macro used repeatedly in the function. Macros can expand into statements; its definition is needed to ensure it does not perform assignments that could modify parameter variables.\n\n- mhd_assert: typically a macro. It appears several times and could expand into code that references or (rarely) assigns to local variables; its expansion must be inspected to ensure it does not modify the parameters.\n\n- MHD_str_remove_token_caseless_: called with value and value_len and a buffer pointer. Need its prototype/definition to know whether it could (via macro or function) assign to the local parameter 'value' (e.g. if implemented as a macro that reuses the identifier) or otherwise produce side effects that affect parameter variables.\n\n- MHD_str_remove_tokens_caseless_: same rationale as above for the normalization call \u2014 check whether it is a macro that could modify the parameter identifiers.\n\n- MHD_get_response_element_n_: called with response; its implementation (or macro) must be inspected to ensure it does not expand to code that assigns to the 'response' parameter variable in this function.\n\n- _MHD_insert_header_first: called with response and a new header. Its implementation may modify the response object (allowed) but must be checked to ensure it does not reassign the local parameter variable itself via macro expansion.\n\n- MHD_calloc_: wrapper used to allocate new header. If implemented as a macro it could contain expressions that reference/assign local identifiers \u2014 include to verify side effects.\n\n- malloc, free, memcpy, memmove, strchr, strlen, memcmp: standard library calls used in this function. Include their prototypes/behaviour to be explicit; while standard functions cannot reassign the caller's local parameter variables, if any are macro-wrapped in this codebase they must be checked for unexpected expansion. Also useful to confirm that only the pointees (not the pointer variables) are modified.\n\n- struct MHD_Response: definition is required to see which fields are written (response->flags_auto, response->upgrade_handler) and to confirm that only the object pointed to is modified (permitted) and that there is no aliasing that would imply the parameter variable itself is overwritten.\n\n- struct MHD_HTTP_Res_Header: definition is required to understand accesses to hdr->value, hdr->value_size and whether operations on these fields could indirectly cause assignment to the parameter variables.\n\n- MHD_HTTP_HEADER_CONNECTION, MHD_HEADER_KIND: constants/macros used as arguments. If they are macros, inspect definitions to ensure they do not expand into code that might reassign local variables.\n\n- MHD_RAF_HAS_CONNECTION_HDR, MHD_RAF_HAS_CONNECTION_CLOSE: flag macros used to read/modify response->flags_auto. Their definitions are needed to confirm they are simple constants/bitmasks and not macros with side effects that could assign to parameters.\n\nIn short: include all called functions and macros (and the involved struct/type definitions and flag macros) so you can verify none of their definitions (macro expansions or inlined wrappers) perform assignments to the local parameter variables 'response' or 'value'."
}