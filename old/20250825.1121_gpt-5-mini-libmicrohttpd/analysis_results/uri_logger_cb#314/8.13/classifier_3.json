{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of uri_logger_cb:\n```c\nstatic void *\nuri_logger_cb (void *cls,\n               const char *uri)\n{\n  struct timeval *tv = malloc (sizeof (struct timeval));\n  (void) cls; /* Unused. Silent compiler warning. */\n  (void) uri; /* Unused. Silent compiler warning. */\n\n  if (NULL != tv)\n    gettimeofday (tv, NULL);\n  return tv;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function uri_logger_cb:\nstatic ssize_t\ncallback (void *cls,\n          uint64_t pos,\n          char *buf,\n          size_t buf_size)\n{\n  size_t size_to_copy;\n  struct ResponseContentCallbackParam *const param =\n    (struct ResponseContentCallbackParam *) cls;\n\n  /* Note: 'pos' will never exceed size of transmitted data. */\n  /* You can use 'pos == param->response_size' in next check. */\n  if (pos >= param->response_size)\n  {   /* Whole response was sent. Signal end of response. */\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n\n  /* Pseudo code.        *\n  if (data_not_ready)\n    {\n      // Callback will be called again on next loop.\n      // Consider suspending connection until data will be ready.\n      return 0;\n    }\n   * End of pseudo code. */\n  if (buf_size < (param->response_size - pos))\n    size_to_copy = buf_size;\n  else\n    size_to_copy = (size_t) (param->response_size - pos);\n\n  memcpy (buf, param->response_data + pos, size_to_copy);\n\n  /* Pseudo code.        *\n  if (error_preparing_response)\n    {\n      // Close connection with error.\n      return MHD_CONTENT_READER_END_WITH_ERROR;\n    }\n   * End of pseudo code. */\n  /* Return amount of data copied to buffer. */\n  /* The 'buf_size' is always smaller than SSIZE_MAX therefore it's safe\n   * to cast 'size_to_copy' to 'ssize_t'. */\n  /* assert (size_to_copy <= buf_size); */\n  return (ssize_t) size_to_copy;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstruct timeval *tv = malloc (sizeof (struct timeval));\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The pointer tv is used as an output buffer passed to gettimeofday(tv, NULL), which writes into the struct; therefore it must be a pointer to a non-const struct timeval. Rule 8.13 would be violated if the object were only read (e.g. the code only inspected the allocated timeval) \u2014 in that case the pointer should be declared as const struct timeval * to comply with the rule."
}