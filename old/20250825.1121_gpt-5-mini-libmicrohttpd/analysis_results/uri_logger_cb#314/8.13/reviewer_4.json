{
  "user_message": "An agent A claimed that the following uri_logger_cb code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of uri_logger_cb.\n```c\nstatic void *\nuri_logger_cb (void *cls,\n               const char *uri)\n{\n  struct timeval *tv = malloc (sizeof (struct timeval));\n  (void) cls; /* Unused. Silent compiler warning. */\n  (void) uri; /* Unused. Silent compiler warning. */\n\n  if (NULL != tv)\n    gettimeofday (tv, NULL);\n  return tv;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe 'cls' parameter is declared as void * and is cast to 'struct ResponseContentCallbackParam *const param = (struct ResponseContentCallbackParam *) cls;'. The function only reads from the pointed-to object (param->response_size and param->response_data) and does not modify it, so the pointed-to type should be const-qualified (e.g. use 'const struct ResponseContentCallbackParam *const param' or 'const void *cls' if the API allows). Therefore Rule 8.13 is violated.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function uri_logger_cb:\nstatic ssize_t\ncallback (void *cls,\n          uint64_t pos,\n          char *buf,\n          size_t buf_size)\n{\n  size_t size_to_copy;\n  struct ResponseContentCallbackParam *const param =\n    (struct ResponseContentCallbackParam *) cls;\n\n  /* Note: 'pos' will never exceed size of transmitted data. */\n  /* You can use 'pos == param->response_size' in next check. */\n  if (pos >= param->response_size)\n  {   /* Whole response was sent. Signal end of response. */\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n\n  /* Pseudo code.        *\n  if (data_not_ready)\n    {\n      // Callback will be called again on next loop.\n      // Consider suspending connection until data will be ready.\n      return 0;\n    }\n   * End of pseudo code. */\n  if (buf_size < (param->response_size - pos))\n    size_to_copy = buf_size;\n  else\n    size_to_copy = (size_t) (param->response_size - pos);\n\n  memcpy (buf, param->response_data + pos, size_to_copy);\n\n  /* Pseudo code.        *\n  if (error_preparing_response)\n    {\n      // Close connection with error.\n      return MHD_CONTENT_READER_END_WITH_ERROR;\n    }\n   * End of pseudo code. */\n  /* Return amount of data copied to buffer. */\n  /* The 'buf_size' is always smaller than SSIZE_MAX therefore it's safe\n   * to cast 'size_to_copy' to 'ssize_t'. */\n  /* assert (size_to_copy <= buf_size); */\n  return (ssize_t) size_to_copy;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reported violation is not correct for the uri_logger_cb function as shown. uri_logger_cb takes (void *cls, const char *uri) but does not dereference or modify cls (it is unused) and uri is already const-qualified, so uri_logger_cb itself does not violate MISRA C 2023 Rule 8.13. \n\nHowever, the additional code you supplied (the callback function) does cast cls to a non-const pointee type: \n  struct ResponseContentCallbackParam *const param = (struct ResponseContentCallbackParam *) cls;\nand then only reads from param->response_size and param->response_data. That code would violate Rule 8.13 because the pointee is not const-qualified even though it is only read; it should be declared as\n  const struct ResponseContentCallbackParam *const param = (const struct ResponseContentCallbackParam *) cls;\n(or the API signature changed to accept a const void *cls if possible). In short: uri_logger_cb is fine; the real issue (if any) is in callback. The agent A misattributed the violation to uri_logger_cb."
}