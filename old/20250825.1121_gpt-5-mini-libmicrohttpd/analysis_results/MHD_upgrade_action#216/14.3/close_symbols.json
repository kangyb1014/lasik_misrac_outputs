{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n                    enum MHD_UpgradeAction action,\n                    ...)\n{\n  struct MHD_Connection *connection;\n  struct MHD_Daemon *daemon;\n\n  if (NULL == urh)\n    return MHD_NO;\n  connection = urh->connection;\n\n  /* Precaution checks on external data. */\n  if (NULL == connection)\n    return MHD_NO;\n  daemon = connection->daemon;\n  if (NULL == daemon)\n    return MHD_NO;\n\n  switch (action)\n  {\n  case MHD_UPGRADE_ACTION_CLOSE:\n    if (urh->was_closed)\n      return MHD_NO; /* Already closed. */\n\n    /* transition to special 'closed' state for start of cleanup */\n#ifdef HTTPS_SUPPORT\n    if (0 != (daemon->options & MHD_USE_TLS) )\n    {\n      /* signal that app is done by shutdown() of 'app' socket */\n      /* Application will not use anyway this socket after this command. */\n      shutdown (urh->app.socket,\n                SHUT_RDWR);\n    }\n#endif /* HTTPS_SUPPORT */\n    mhd_assert (MHD_CONNECTION_UPGRADE == connection->state);\n    /* The next function will mark the connection as closed by application\n     * by setting 'urh->was_closed'.\n     * As soon as connection will be marked with BOTH\n     * 'urh->was_closed' AND 'urh->clean_ready', it will\n     * be moved to cleanup list by MHD_resume_connection(). */\n    MHD_upgraded_connection_mark_app_closed_ (connection);\n    return MHD_YES;\n  case MHD_UPGRADE_ACTION_CORK_ON:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           true) ? MHD_YES : MHD_NO;\n  case MHD_UPGRADE_ACTION_CORK_OFF:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           false) ? MHD_YES : MHD_NO;\n  default:\n    /* we don't understand this one */\n    return MHD_NO;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'MHD_upgraded_connection_mark_app_closed_': {'callees': ['__builtin_unreachable', 'MHD_DLOG'], 'callers': ['MHD_upgrade_action']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'uh_cb': {'callees': ['MHD_upgrade_action'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "enum MHD_UpgradeAction (all enumerator values: MHD_UPGRADE_ACTION_CLOSE, MHD_UPGRADE_ACTION_CORK_ON, MHD_UPGRADE_ACTION_CORK_OFF)",
    "struct MHD_UpgradeResponseHandle (fields used: connection, was_closed, app.socket, clean_ready)",
    "struct MHD_Connection (fields used: daemon, state)",
    "struct MHD_Daemon (field: options)",
    "macro/constant MHD_USE_TLS",
    "constant MHD_CONNECTION_UPGRADE and the definition/behavior of mhd_assert",
    "caller function run_usock (definition and call sites that invoke MHD_upgrade_action)",
    "caller function uh_cb (definition and call sites that invoke MHD_upgrade_action)",
    "implementation of MHD_upgraded_connection_mark_app_closed_"
  ],
  "explanation": "For each symbol, why it is required for evaluating whether any controlling expression in MHD_upgrade_action is invariant under MISRA C:\n\n- enum MHD_UpgradeAction: The switch in MHD_upgrade_action uses the 'action' parameter. To decide whether the switch controlling expression can be an invariant you must know the full set of enum values and their semantics, and whether callers can only ever pass a single constant value.\n\n- struct MHD_UpgradeResponseHandle: The function branches on urh being NULL and on urh->was_closed; it also uses urh->app.socket for shutdown and relies on urh->clean_ready in comments. You need these field definitions to determine whether those tests/uses can be invariant at compile/run time.\n\n- struct MHD_Connection: The code reads connection->daemon and asserts on connection->state. To judge whether the mhd_assert or other checks are invariant you must know the contained fields and whether they are mutable.\n\n- struct MHD_Daemon and MHD_USE_TLS: The expression (daemon->options & MHD_USE_TLS) is a controlling expression in an #ifdef-protected if; determine whether that expression can be invariant requires the options field layout and the MHD_USE_TLS mask/definition.\n\n- MHD_CONNECTION_UPGRADE and mhd_assert: The assert compares connection->state against MHD_CONNECTION_UPGRADE; to assess whether that comparison is an invariant or a valid runtime check you need the state constant and the semantics of mhd_assert (does it compile out, does it affect control flow).\n\n- run_usock and uh_cb: They are the callers of MHD_upgrade_action (per the static call graph). If those callers always invoke MHD_upgrade_action with the same literal/constant enum value (or under an invariant context), then the switch(action) would be invariant \u2014 so you must inspect their code/paths to decide invariance.\n\n- MHD_upgraded_connection_mark_app_closed_: The function is called before return in the CLOSE case and (per its name and call graph) likely changes urh/connection state (e.g. urh->was_closed). To reason about whether subsequent calls or the runtime state make controlling expressions invariant you need to know what this function changes.\n\n(Other symbols in the file such as MHD_connection_set_cork_state_, MHD_YES/MHD_NO macros or shutdown() prototype are not necessary to decide whether the controlling expressions in MHD_upgrade_action are invariant, but could be inspected later for completeness.)"
}