{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_upgrade_action:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n                    enum MHD_UpgradeAction action,\n                    ...)\n{\n  struct MHD_Connection *connection;\n  struct MHD_Daemon *daemon;\n\n  if (NULL == urh)\n    return MHD_NO;\n  connection = urh->connection;\n\n  /* Precaution checks on external data. */\n  if (NULL == connection)\n    return MHD_NO;\n  daemon = connection->daemon;\n  if (NULL == daemon)\n    return MHD_NO;\n\n  switch (action)\n  {\n  case MHD_UPGRADE_ACTION_CLOSE:\n    if (urh->was_closed)\n      return MHD_NO; /* Already closed. */\n\n    /* transition to special 'closed' state for start of cleanup */\n#ifdef HTTPS_SUPPORT\n    if (0 != (daemon->options & MHD_USE_TLS) )\n    {\n      /* signal that app is done by shutdown() of 'app' socket */\n      /* Application will not use anyway this socket after this command. */\n      shutdown (urh->app.socket,\n                SHUT_RDWR);\n    }\n#endif /* HTTPS_SUPPORT */\n    mhd_assert (MHD_CONNECTION_UPGRADE == connection->state);\n    /* The next function will mark the connection as closed by application\n     * by setting 'urh->was_closed'.\n     * As soon as connection will be marked with BOTH\n     * 'urh->was_closed' AND 'urh->clean_ready', it will\n     * be moved to cleanup list by MHD_resume_connection(). */\n    MHD_upgraded_connection_mark_app_closed_ (connection);\n    return MHD_YES;\n  case MHD_UPGRADE_ACTION_CORK_ON:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           true) ? MHD_YES : MHD_NO;\n  case MHD_UPGRADE_ACTION_CORK_OFF:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           false) ? MHD_YES : MHD_NO;\n  default:\n    /* we don't understand this one */\n    return MHD_NO;\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_upgrade_action:\nvoid\nMHD_upgraded_connection_mark_app_closed_ (struct MHD_Connection *connection)\n{\n  /* Cache 'daemon' here to avoid data races */\n  struct MHD_Daemon *const daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n  mhd_assert (NULL != connection->urh);\n  mhd_assert (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME));\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  connection->urh->was_closed = true;\n  connection->resuming = true;\n  daemon->resuming = true;\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"r\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal resume via \" \\\n                 \"inter-thread communication channel.\\n\"));\n#endif\n  }\n}\n...\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\n_MHD_EXTERN void\nMHD_resume_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n#if defined(MHD_USE_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_ (\"Cannot resume connections without enabling \" \\\n                  \"MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  connection->resuming = true;\n  daemon->resuming = true;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"r\")) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to signal resume via inter-thread \" \\\n                 \"communication channel.\\n\"));\n#endif\n  }\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic void *\nrun_usock (void *cls)\n{\n  struct MyData *md = cls;\n  struct MHD_UpgradeResponseHandle *urh = md->urh;\n  char buf[128];\n  ssize_t got;\n\n  make_blocking (md->sock);\n  /* start by sending extra data MHD may have already read, if any */\n  if (0 != md->extra_in_size)\n  {\n    send_all (md->sock,\n              md->extra_in,\n              md->extra_in_size);\n    free (md->extra_in);\n  }\n  /* now echo in a loop */\n  while (1)\n  {\n    got = recv (md->sock,\n                buf,\n                sizeof (buf),\n                0);\n    if (0 >= got)\n      break;\n    send_all (md->sock,\n              buf,\n              (size_t) got);\n  }\n  free (md);\n  MHD_upgrade_action (urh,\n                      MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n...\nstatic void\nuh_cb (void *cls,\n       struct MHD_Connection *connection,\n       void *req_cls,\n       const char *extra_in,\n       size_t extra_in_size,\n       MHD_socket sock,\n       struct MHD_UpgradeResponseHandle *urh)\n{\n  struct MyData *md;\n  pthread_t pt;\n  (void) cls;         /* Unused. Silent compiler warning. */\n  (void) connection;  /* Unused. Silent compiler warning. */\n  (void) req_cls;     /* Unused. Silent compiler warning. */\n\n  md = malloc (sizeof (struct MyData));\n  if (NULL == md)\n    abort ();\n  memset (md, 0, sizeof (struct MyData));\n  if (0 != extra_in_size)\n  {\n    md->extra_in = malloc (extra_in_size);\n    if (NULL == md->extra_in)\n      abort ();\n    memcpy (md->extra_in,\n            extra_in,\n            extra_in_size);\n  }\n  md->extra_in_size = extra_in_size;\n  md->sock = sock;\n  md->urh = urh;\n  if (0 != pthread_create (&pt,\n                           NULL,\n                           &run_usock,\n                           md))\n    abort ();\n  /* Note that by detaching like this we make it impossible to ensure\n     a clean shutdown, as the we stop the daemon even if a worker thread\n     is still running. Alas, this is a simple example... */\n  pthread_detach (pt);\n\n  /* This callback must return as soon as possible. */\n\n  /* Data forwarding to \"upgraded\" socket will be started\n   * after return from this callback. */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "In the provided code there is no direct or indirect recursive call chain. MHD_connection_set_cork_state_ calls setsockopt, MHD_socket_get_error_, MHD_DLOG and MHD_socket_strerr_, none of which (as shown) call MHD_connection_set_cork_state_. Therefore the rule is not violated. (Hypothetical violating scenario: if daemon->custom_error_log, invoked via MHD_DLOG, were implemented to call MHD_connection_set_cork_state_ again, that would create an indirect recursion: MHD_connection_set_cork_state_ -> MHD_DLOG -> custom_error_log -> MHD_connection_set_cork_state_.)"
}