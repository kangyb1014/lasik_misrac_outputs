{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n                    enum MHD_UpgradeAction action,\n                    ...)\n{\n  struct MHD_Connection *connection;\n  struct MHD_Daemon *daemon;\n\n  if (NULL == urh)\n    return MHD_NO;\n  connection = urh->connection;\n\n  /* Precaution checks on external data. */\n  if (NULL == connection)\n    return MHD_NO;\n  daemon = connection->daemon;\n  if (NULL == daemon)\n    return MHD_NO;\n\n  switch (action)\n  {\n  case MHD_UPGRADE_ACTION_CLOSE:\n    if (urh->was_closed)\n      return MHD_NO; /* Already closed. */\n\n    /* transition to special 'closed' state for start of cleanup */\n#ifdef HTTPS_SUPPORT\n    if (0 != (daemon->options & MHD_USE_TLS) )\n    {\n      /* signal that app is done by shutdown() of 'app' socket */\n      /* Application will not use anyway this socket after this command. */\n      shutdown (urh->app.socket,\n                SHUT_RDWR);\n    }\n#endif /* HTTPS_SUPPORT */\n    mhd_assert (MHD_CONNECTION_UPGRADE == connection->state);\n    /* The next function will mark the connection as closed by application\n     * by setting 'urh->was_closed'.\n     * As soon as connection will be marked with BOTH\n     * 'urh->was_closed' AND 'urh->clean_ready', it will\n     * be moved to cleanup list by MHD_resume_connection(). */\n    MHD_upgraded_connection_mark_app_closed_ (connection);\n    return MHD_YES;\n  case MHD_UPGRADE_ACTION_CORK_ON:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           true) ? MHD_YES : MHD_NO;\n  case MHD_UPGRADE_ACTION_CORK_OFF:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           false) ? MHD_YES : MHD_NO;\n  default:\n    /* we don't understand this one */\n    return MHD_NO;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'MHD_upgraded_connection_mark_app_closed_': {'callees': ['__builtin_unreachable', 'MHD_DLOG'], 'callers': ['MHD_upgrade_action']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'uh_cb': {'callees': ['MHD_upgrade_action'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_UpgradeResponseHandle",
    "struct MHD_Connection",
    "struct MHD_Daemon",
    "enum MHD_Result (MHD_YES, MHD_NO)",
    "enum MHD_UpgradeAction (MHD_UPGRADE_ACTION_CLOSE, MHD_UPGRADE_ACTION_CORK_ON, MHD_UPGRADE_ACTION_CORK_OFF)",
    "MHD_connection_set_cork_state_",
    "MHD_upgraded_connection_mark_app_closed_",
    "MHD_resume_connection",
    "daemon->options initialization (e.g. MHD_start_daemon / MHD_create_daemon)",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT (compile-time macro)",
    "MHD_CONNECTION_UPGRADE",
    "mhd_assert",
    "shutdown (POSIX)",
    "run_usock",
    "uh_cb",
    "urh->app.socket (field of MHD_UpgradeResponseHandle)",
    "urh->was_closed (field of MHD_UpgradeResponseHandle)",
    "urh->clean_ready (field of MHD_UpgradeResponseHandle)",
    "connection->state (field of MHD_Connection)",
    "connection->daemon (field of MHD_Connection)",
    "daemon->options (field of MHD_Daemon)",
    "SHUT_RDWR"
  ],
  "explanation": "For a sound dead-code (MISRA) analysis we must know which operations in MHD_upgrade_action are actually reachable or have side effects that affect program behaviour. The listed symbols are required for that reasoning:\n\n- struct MHD_UpgradeResponseHandle: its layout and semantics (fields connection, was_closed, app.socket, clean_ready) determine whether checks/assignments (was_closed, use of app.socket) are observable; removing code that sets/reads these fields could change behaviour.\n\n- struct MHD_Connection: definition (fields daemon, state) is needed to determine reachability and side effects related to connection->state and connection->daemon accesses.\n\n- struct MHD_Daemon: its layout (options field) is needed because daemon->options guards the TLS shutdown path; knowing its type/values affects whether that block can ever execute.\n\n- enum MHD_Result (MHD_YES, MHD_NO): return semantics matter for observable behaviour; determining if a return can be removed requires knowing these values.\n\n- enum MHD_UpgradeAction (and the three values used): to know which switch arms are valid and whether any arm is unreachable from callers.\n\n- MHD_connection_set_cork_state_: called for CORK_ON/CORK_OFF arms; need its prototype and side effects/return semantics to decide whether that call is meaningful (removing it could change behaviour) or redundant.\n\n- MHD_upgraded_connection_mark_app_closed_: implementation is essential because the function comment claims it changes urh->was_closed and triggers cleanup; we must know its exact side effects to judge whether the call is required.\n\n- MHD_resume_connection: referenced in the comment as the operation that moves connections to cleanup once both flags are set; its behaviour affects whether marking was_closed is observable and so whether related code is dead.\n\n- daemon->options initialization sites (e.g. MHD_start_daemon / MHD_create_daemon): to determine whether MHD_USE_TLS can actually be set at runtime (or is always unset), which decides if the shutdown() call is ever reachable (dead or not).\n\n- MHD_USE_TLS: the option bit tested in the TLS branch; must know its meaning and how/where it can be set.\n\n- HTTPS_SUPPORT (compile-time macro): controls whether the TLS/shutdown code is compiled in at all; if disabled the code is not present and thus not dead code in that build.\n\n- MHD_CONNECTION_UPGRADE: used in the assert; knowing when connection->state equals this value affects whether the assert (and any behaviour tied to state) is meaningful.\n\n- mhd_assert: its definition (compile-time behaviour, side effects) matters: if asserts are disabled, the check is not executable and may affect reachability/side-effect reasoning.\n\n- shutdown (POSIX): its semantics on sockets (side effects visible to application/OS) must be known to judge whether that call is observable and thus not dead.\n\n- run_usock and uh_cb: the two callers in the static graph \u2014 need their call sites and which action values they pass to determine which switch cases are ever exercised at runtime; a case that is never passed by any caller is dead.\n\n- urh->app.socket, urh->was_closed, urh->clean_ready (fields): listed explicitly because their concrete types/uses determine whether operations touching them are observable.\n\n- connection->state, connection->daemon, daemon->options (fields): explicit field access semantics determine whether reads/writes are observable.\n\n- SHUT_RDWR: the shutdown argument; included so the exact system-call effect can be considered.\n\nCollectively these symbols let an analyst determine: which switch arms are reachable from callers; whether the TLS/shutdown block can be compiled-in and/or executed; whether calls have side effects that change global or observable state (so cannot be removed); and whether assertions or comments refer to additional mechanisms (resume/cleanup) that make operations observable. Without these symbols you cannot reliably decide whether code in MHD_upgrade_action is truly dead (removable without changing observable behaviour) or is required."
}