{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n                    enum MHD_UpgradeAction action,\n                    ...)\n{\n  struct MHD_Connection *connection;\n  struct MHD_Daemon *daemon;\n\n  if (NULL == urh)\n    return MHD_NO;\n  connection = urh->connection;\n\n  /* Precaution checks on external data. */\n  if (NULL == connection)\n    return MHD_NO;\n  daemon = connection->daemon;\n  if (NULL == daemon)\n    return MHD_NO;\n\n  switch (action)\n  {\n  case MHD_UPGRADE_ACTION_CLOSE:\n    if (urh->was_closed)\n      return MHD_NO; /* Already closed. */\n\n    /* transition to special 'closed' state for start of cleanup */\n#ifdef HTTPS_SUPPORT\n    if (0 != (daemon->options & MHD_USE_TLS) )\n    {\n      /* signal that app is done by shutdown() of 'app' socket */\n      /* Application will not use anyway this socket after this command. */\n      shutdown (urh->app.socket,\n                SHUT_RDWR);\n    }\n#endif /* HTTPS_SUPPORT */\n    mhd_assert (MHD_CONNECTION_UPGRADE == connection->state);\n    /* The next function will mark the connection as closed by application\n     * by setting 'urh->was_closed'.\n     * As soon as connection will be marked with BOTH\n     * 'urh->was_closed' AND 'urh->clean_ready', it will\n     * be moved to cleanup list by MHD_resume_connection(). */\n    MHD_upgraded_connection_mark_app_closed_ (connection);\n    return MHD_YES;\n  case MHD_UPGRADE_ACTION_CORK_ON:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           true) ? MHD_YES : MHD_NO;\n  case MHD_UPGRADE_ACTION_CORK_OFF:\n    /* Unportable API. TODO: replace with portable action. */\n    return MHD_connection_set_cork_state_ (connection,\n                                           false) ? MHD_YES : MHD_NO;\n  default:\n    /* we don't understand this one */\n    return MHD_NO;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'MHD_upgraded_connection_mark_app_closed_': {'callees': ['__builtin_unreachable', 'MHD_DLOG'], 'callers': ['MHD_upgrade_action']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'uh_cb': {'callees': ['MHD_upgrade_action'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "struct MHD_UpgradeResponseHandle",
    "struct MHD_Connection",
    "struct MHD_Daemon",
    "daemon->options",
    "MHD_USE_TLS",
    "HTTPS_SUPPORT",
    "SHUT_RDWR",
    "shutdown",
    "enum MHD_UpgradeAction",
    "MHD_UPGRADE_ACTION_CLOSE",
    "MHD_UPGRADE_ACTION_CORK_ON",
    "MHD_UPGRADE_ACTION_CORK_OFF",
    "MHD_CONNECTION_UPGRADE",
    "mhd_assert",
    "MHD_upgraded_connection_mark_app_closed_",
    "MHD_connection_set_cork_state_",
    "bool / true / false (stdbool.h or equivalent)",
    "__builtin_unreachable",
    "MHD_DLOG"
  ],
  "explanation": "For a correct MISRA C \"Language extensions should not be used\" assessment you must see definitions and implementations of every macro, type and callee that could introduce compiler-specific extensions or non\u2011standard language features (directly in this function or indirectly via called code or macros). Brief rationale for each symbol: \n\n- _MHD_EXTERN: may expand to compiler-specific storage-class or attribute (e.g. __attribute__, __declspec) \u2014 need its definition to see if an extension is used. \n- enum MHD_Result / MHD_YES / MHD_NO: return-type and return constants used by the function; their definitions may include nonstandard extensions or attributes. \n- struct MHD_UpgradeResponseHandle: function parameter type \u2014 its definition may contain extension usage (bitfields, packed, attributes). \n- struct MHD_Connection: used inside function (connection->daemon, state) \u2014 its definition may include extensions or nonstandard qualifiers. \n- struct MHD_Daemon and daemon->options: options is bitmasked and compared \u2014 the type/definition could use platform/compiler extensions or nonstandard integer types. \n- MHD_USE_TLS / HTTPS_SUPPORT: conditional/mask macros affect compiled code paths; their definitions may be compiler-provided or trigger use of extensions (and HTTPS_SUPPORT controls use of shutdown call). \n- SHUT_RDWR / shutdown: shutdown is a POSIX call; need its declaration to ensure no compiler-specific prototype/extension is used. \n- enum MHD_UpgradeAction and MHD_UPGRADE_ACTION_* / MHD_CONNECTION_UPGRADE: the action/state constants and enum definitions must be checked for any extension usage (e.g. compiler-specific enum sizing attributes). \n- mhd_assert: assertion macro may expand to compiler builtins (e.g. __builtin_trap, __assert_fail) or attributes \u2014 need its expansion. \n- MHD_upgraded_connection_mark_app_closed_: implementation must be inspected because callees can use compiler extensions; the static graph shows it calls __builtin_unreachable and MHD_DLOG. Even if the target does not call __builtin_unreachable directly, an indirect use in a called function is relevant to whether the target function (as compiled) relies on language extensions. \n- MHD_connection_set_cork_state_: implementation may contain system-/platform-specific nonstandard calls or attributes (e.g. use of TCP_CORK, nonportable APIs). \n- bool / true / false (stdbool.h or equivalent): the code uses true/false \u2014 need to know whether standard <stdbool.h> or a nonstandard substitute is used. \n- __builtin_unreachable: compiler builtin (explicit language extension) appears in the callee; include to verify whether any path reachable from the target uses this extension. \n- MHD_DLOG: logging macro used by the callee; could expand to compiler builtins or attributes (variadic macros, __attribute__ formats), so check its definition.\n\nProviding these symbols (definitions/implementations/macros) lets the next analyzer determine whether any compiler-specific extensions are used directly in the target or indirectly through macros/callees."
}