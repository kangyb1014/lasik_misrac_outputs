{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'post_process_multipart': {'callees': ['find_boundary', 'process_multipart_headers', 'MHD_str_equal_caseless_n_', 'process_value_to_boundary', 'free_unmarked', '__builtin_unreachable'], 'callers': ['MHD_post_process']}, 'find_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}, 'MHD_str_equal_caseless_n_': {'callees': ['charsequalcaseless'], 'callers': ['MHD_create_post_processor', 'try_match_header', 'process_multipart_headers', 'post_process_multipart', 'MHD_post_process']}, 'process_value_to_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'free_unmarked': {'callees': [], 'callers': ['post_process_multipart', 'MHD_destroy_post_processor']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_post_process': {'callees': ['MHD_str_equal_caseless_n_', 'post_process_urlencoded', 'post_process_multipart'], 'callers': ['create_response', 'generate_page', 'answer_to_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_PostProcessor (complete definition)",
    "enum (or typedef) for RN_* values (RN_Inactive, RN_OptN, RN_Dash, RN_Dash2, RN_Full) and the type of pp->skip_rn",
    "enum (or typedef) for PP_* state values (PP_Error, PP_Done, PP_Init, PP_NextBoundary, PP_ProcessEntryHeaders, PP_PerformCheckMultipart, PP_ProcessValueToBoundary, PP_PerformCleanup, PP_Nested_Init, PP_Nested_PerformMarking, PP_Nested_ProcessEntryHeaders, PP_Nested_ProcessValueToBoundary, PP_Nested_PerformCleanup, PP_ProcessKey, PP_ProcessValue, PP_Callback) and the type of pp->state",
    "definitions for NE_* flags (NE_none, NE_content_name, NE_content_type, NE_content_filename, NE_content_transfer_encoding) and the type of pp->have",
    "prototype of find_boundary (full parameter types)",
    "prototype of process_multipart_headers (full parameter types)",
    "prototype of process_value_to_boundary (full parameter types)",
    "prototype of MHD_str_equal_caseless_n_ (full parameter types and return type)",
    "prototype of free_unmarked (full parameter types)",
    "prototype/signature of strdup (char *strdup(const char *))",
    "prototype/signature of free (void free(void *))",
    "prototype/signature of strstr (char *strstr(const char *haystack, const char *needle))",
    "prototypes/signatures of memcpy, memmove, strlen (their parameter const-qualifications)",
    "definition/expansion of MHD_STATICSTR_LEN_ (macro or inline) and type it yields",
    "definition of enum MHD_Result and the macros/values MHD_YES / MHD_NO",
    "definition/signature of MHD_PANIC (macro/function) used in default switch"
  ],
  "explanation": "For determining whether pointers in post_process_multipart should be const-qualified, the analyzer must know which data objects are modified inside this function or passed to callees that may modify them, and which are only read. The required symbols and why:\n\n- struct MHD_PostProcessor (complete definition): shows the types of all pp fields (boundary, content_type, nested_boundary, buffer_pos, buffer_size, skip_rn, state, dash_state, have, nlen, value_offset, etc.). If a field is written (e.g. pp->buffer_pos, pp->state, pp->nested_boundary is assigned/freed), it cannot be a pointer-to-const. The full struct is essential to classify each pointer field as mutated or read-only.\n\n- RN_* enum and pp->skip_rn type: skip_rn is assigned to and tested; its exact type confirms whether code mutates it (so it cannot be const) and whether any pointer-to-enum conversions affect constness analysis.\n\n- PP_* enum and pp->state type: pp->state is repeatedly assigned and used to select behavior. Knowing the state enum confirms which code paths are active and which pointer fields are modified in those paths.\n\n- NE_* flags and pp->have type: pp->have is bitwise-updated from header pointers. Knowing this type confirms whether manipulating flags implies ownership/ modification of related pointer fields.\n\n- find_boundary prototype: called with pp->boundary/pp->blen. If find_boundary accepts const char *boundary (and does not modify the buffer), pp->boundary could be const; if it accepts char * or modifies the boundary buffer, it must be non-const. The prototype is therefore essential.\n\n- process_multipart_headers prototype: it takes pp and an offset and sets state; it may examine or modify header-related pointers (pp->content_type, content_name, etc.). Knowing its parameter types and whether it mutates the content_* fields is necessary to decide if those fields may be const.\n\n- process_value_to_boundary prototype: similar to find_boundary; it is called with pp->boundary or pp->nested_boundary. Its parameter constness determines whether those pointers must be mutable.\n\n- MHD_str_equal_caseless_n_ prototype: used to compare pp->content_type to a literal. If this function accepts const char * for both args (typical), then pp->content_type could be const if not otherwise modified\u2014unless other code frees or writes it. Knowing the function's declared parameter constness is needed for correct recommendation.\n\n- free_unmarked prototype: called to free or modify internal allocations. If it frees or alters pp->content_* pointers, those pointers cannot be const. Full prototype and semantics are needed.\n\n- strdup signature: returns char * from const char * input. The code uses strdup to allocate pp->nested_boundary; that implies nested_boundary is a mutable char * (and later freed). Knowing strdup's behavior confirms ownership and mutability.\n\n- free signature: free(pp->content_type) and free(pp->nested_boundary) appear; freeing a pointer implies ownership and mutable allocation (and that the pointer type in struct must allow free without casting). The signature confirms that the code treats these pointers as mutable.\n\n- strstr signature: used as nested_boundary = strstr(pp->content_type, \"boundary=\"). The const-qualification of strstr's parameters/return guides whether content_type could be const or not and whether nested_boundary points into original storage (affecting ownership/constness).\n\n- memcpy, memmove, strlen prototypes: these standard functions have const qualifiers on source parameters (e.g. memcpy(void *dest, const void *src, size_t)). Knowing these confirms that post_data which is passed as source is correctly declared const and whether other uses of buffers are consistent with const-correctness.\n\n- MHD_STATICSTR_LEN_ macro: yields a size_t length for static literal; needed to confirm that calls supplying literal lengths match the callee parameter types (size_t) and don't imply modification of literal pointers.\n\n- enum MHD_Result and MHD_YES / MHD_NO: return values and types; not directly about const-qualification, but needed to fully type-check function prototypes and control-flow for analysis.\n\n- MHD_PANIC definition/signature: used in default case; knowing if it accepts a const char * or modifies its argument is useful for determining whether the literal or pointer passed needs const qualification.\n\nIncluding these symbols (with exact types and prototypes) lets the next analyzer determine which pointer fields and parameters are actually mutated, which are only read, and whether any callees require mutable pointers. With that information one can decide whether any pointer declarations in the function (or in struct MHD_PostProcessor) should be const-qualified without breaking existing usage (free, strdup, mutation, or callee signatures)."
}