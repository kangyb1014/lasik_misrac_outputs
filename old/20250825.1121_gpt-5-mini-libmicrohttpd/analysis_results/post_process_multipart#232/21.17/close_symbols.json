{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'post_process_multipart': {'callees': ['find_boundary', 'process_multipart_headers', 'MHD_str_equal_caseless_n_', 'process_value_to_boundary', 'free_unmarked', '__builtin_unreachable'], 'callers': ['MHD_post_process']}, 'find_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}, 'MHD_str_equal_caseless_n_': {'callees': ['charsequalcaseless'], 'callers': ['MHD_create_post_processor', 'try_match_header', 'process_multipart_headers', 'post_process_multipart', 'MHD_post_process']}, 'process_value_to_boundary': {'callees': [], 'callers': ['post_process_multipart']}, 'free_unmarked': {'callees': [], 'callers': ['post_process_multipart', 'MHD_destroy_post_processor']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_post_process': {'callees': ['MHD_str_equal_caseless_n_', 'post_process_urlencoded', 'post_process_multipart'], 'callers': ['create_response', 'generate_page', 'answer_to_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_PostProcessor (full definition)",
    "MHD_PostProcessor.buffer_size",
    "MHD_PostProcessor.buffer_pos",
    "MHD_PostProcessor.skip_rn (enum values RN_Inactive,RN_OptN,RN_Dash,RN_Dash2,RN_Full)",
    "MHD_PostProcessor.dash_state",
    "MHD_PostProcessor.state (enum values PP_Error,PP_Done,PP_Init,PP_NextBoundary,PP_ProcessEntryHeaders,PP_PerformCheckMultipart,PP_ProcessValueToBoundary,PP_PerformCleanup,PP_Nested_Init,PP_Nested_PerformMarking,PP_Nested_ProcessEntryHeaders,PP_Nested_ProcessValueToBoundary,PP_Nested_PerformCleanup,PP_ProcessKey,PP_ProcessValue,PP_Callback)",
    "MHD_PostProcessor.boundary",
    "MHD_PostProcessor.blen",
    "MHD_PostProcessor.nested_boundary",
    "MHD_PostProcessor.nlen",
    "MHD_PostProcessor.content_type",
    "MHD_PostProcessor.content_name",
    "MHD_PostProcessor.content_filename",
    "MHD_PostProcessor.content_transfer_encoding",
    "MHD_PostProcessor.must_ikvi",
    "MHD_PostProcessor.have (NE_* bitflags)",
    "NE_* enum/bitflag definitions (including NE_none, NE_content_name, NE_content_type, NE_content_filename, NE_content_transfer_encoding)",
    "MHD_PostProcessor.value_offset",
    "MHD_create_post_processor (allocation / layout semantics \u2013 in particular how the buffer is allocated relative to the struct and what buffer_size is set to)",
    "find_boundary (prototype and precise side effects on ioff, pp->state, pp->buffer_pos and/or buffer contents)",
    "process_multipart_headers (prototype and precise side effects on ioff, pp->state, pp->buffer_pos and header-related fields)",
    "process_value_to_boundary (prototype and precise side effects on ioff, pp->state, pp->buffer_pos and buffer contents)",
    "free_unmarked (prototype and side effects; whether it changes pp->buffer_pos or buffer contents)",
    "MHD_str_equal_caseless_n_ (prototype / behavior)",
    "MHD_STATICSTR_LEN_ macro semantics",
    "strstr, strdup, strlen, free (standard string/memory helpers used)",
    "memcpy, memmove (standard semantics, but include prototypes for formal analysis)",
    "MHD_NO and MHD_YES (return/result constants)",
    "type size_t and bool/true/false definitions"
  ],
  "explanation": "To decide whether the memcpy / memmove calls in post_process_multipart can access out-of-bounds memory we must know the exact layout and invariants of the buffer and the side-effects of callees that update or consume that buffer. Concretely:\n\n- The full definition of struct MHD_PostProcessor and every field used is required because the function computes buf = (char *)&pp[1] (so the buffer lives immediately after the struct) and both memcpy and memmove index/length-check against pp->buffer_size and pp->buffer_pos. We need to know whether the allocation pattern and these fields guarantee the accessible region is at least buffer_size bytes at &pp[1].\n\n- The skip_rn and state enums (RN_* and PP_*) and dash_state are required because control flow and decisions (including early returns) determine when and how much of the buffer is read/consumed; some branches check pp->buffer_pos before accessing buf[1]. Knowing all enum values and their use ensures we can reason about which branches can be taken and when accesses to buf[0]/buf[1] are guarded.\n\n- Fields boundary/blen, nested_boundary/nlen, content_* fields, have/NE_* and value_offset, and must_ikvi are required because called helpers (find_boundary, process_multipart_headers, process_value_to_boundary, free_unmarked) read or modify these and that can influence state transitions that affect buffer consumption/production. For example, find_boundary/process_value_to_boundary may consume bytes from the internal buffer (via ioff) or change pp->buffer_pos; we must know their precise side effects to determine if subsequent memcpy/memmove uses correct lengths.\n\n- MHD_create_post_processor is required to know how the post-processor and its buffer are allocated and initialized (in particular buffer_size and initial buffer_pos). The function\u2019s assumption buf = &pp[1] is safe only if MHD_create_post_processor allocated a trailing buffer of at least buffer_size bytes.\n\n- The prototypes and precise side-effects of find_boundary, process_multipart_headers, process_value_to_boundary and free_unmarked are required because these callees are invoked repeatedly inside the loop and may update ioff and pp->buffer_pos, free or reassign strings, or set pp->state to PP_Error/PP_Done. Those side effects affect the values passed to memcpy/memmove (max, ioff, pp->buffer_pos) and therefore whether accesses remain in-bounds.\n\n- MHD_str_equal_caseless_n_, MHD_STATICSTR_LEN_, and standard functions used at runtime (strstr, strdup, strlen, free) are required to reason about possible allocations, null returns, and string lengths that alter control flow (e.g., nested_boundary creation) which in turn affect buffer handling.\n\n- memcpy and memmove semantics and prototypes are necessary to check that the computed source/destination pointers and lengths passed to them are valid given buffer layout and the dynamic values of pp->buffer_pos, ioff, pp->buffer_size and post_data_len.\n\n- MHD_NO and MHD_YES constants and the definition of size_t and bool complete the semantic model so we can determine when the function returns early versus continuing to update buffer indices.\n\nProviding these symbols (struct layout, enum values, allocation semantics, and callee side-effects) allows a precise, sound analysis of every memcpy/memmove call site in post_process_multipart to ensure no out-of-bounds accesses occur."
}