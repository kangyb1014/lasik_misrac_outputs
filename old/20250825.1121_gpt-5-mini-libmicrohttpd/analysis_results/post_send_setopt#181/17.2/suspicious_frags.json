{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of post_send_setopt:\n```c\nstatic void\npost_send_setopt (struct MHD_Connection *connection,\n                  bool plain_send_next,\n                  bool push_data)\n{\n  /* Try to buffer data if not sending the final piece.\n   * Final piece is indicated by push_data == true. */\n  const bool buffer_data = (! push_data);\n\n  if (_MHD_YES == connection->is_nonip)\n    return;\n  if (buffer_data)\n    return; /* Nothing to do after send(). */\n\n#ifndef MHD_USE_MSG_MORE\n  (void) plain_send_next; /* Mute compiler warning */\n#endif /* ! MHD_USE_MSG_MORE */\n\n  /* Need to push data. */\n#ifdef MHD_TCP_CORK_NOPUSH\n#ifdef _MHD_CORK_RESET_PUSH_DATA_ALWAYS\n#ifdef _MHD_NODELAY_SET_PUSH_DATA_ALWAYS\n#ifdef MHD_USE_MSG_MORE\n  if (_MHD_OFF == connection->sk_corked)\n  {\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* Data was already pushed by send(). */\n  }\n  /* This is Linux kernel. There are options:\n   * * Push the data by setting of TCP_NODELAY (without change\n   *   of the cork on the socket),\n   * * Push the data by resetting of TCP_CORK.\n   * The optimal choice depends on the next final send functions\n   * used on the same socket. If TCP_NODELAY wasn't set then push\n   * data by setting TCP_NODELAY (TCP_NODELAY will not be removed\n   * and is needed to push the data by send() without MSG_MORE).\n   * If send()/sendmsg() will be used next than push data by\n   * resetting of TCP_CORK so next send without MSG_MORE will push\n   * data to the network (without additional sys-call to push data).\n   * If next final send function will not support MSG_MORE (like\n   * sendfile() or TLS-connection) than push data by setting\n   * TCP_NODELAY so socket will remain corked (no additional\n   * sys-call before next send()). */\n  if ((_MHD_ON != connection->sk_nodelay) ||\n      (! plain_send_next))\n  {\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n      return; /* Data has been pushed by TCP_NODELAY. */\n    /* Failed to set TCP_NODELAY for the socket.\n     * Really unlikely to happen on TCP connections. */\n    if (MHD_connection_set_cork_state_ (connection, false))\n      return; /* Data has been pushed by uncorking the socket. */\n    /* Failed to uncork the socket.\n     * Really unlikely to happen on TCP connections. */\n\n    /* The socket cannot be uncorked, no way to push data */\n  }\n  else\n  {\n    if (MHD_connection_set_cork_state_ (connection, false))\n      return; /* Data has been pushed by uncorking the socket. */\n    /* Failed to uncork the socket.\n     * Really unlikely to happen on TCP connections. */\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n      return; /* Data has been pushed by TCP_NODELAY. */\n    /* Failed to set TCP_NODELAY for the socket.\n     * Really unlikely to happen on TCP connections. */\n\n    /* The socket cannot be uncorked, no way to push data */\n  }\n#else  /* ! MHD_USE_MSG_MORE */\n  /* Use setting of TCP_NODELAY here to avoid sys-call\n   * for corking the socket during sending of the next response. */\n  if (MHD_connection_set_nodelay_state_ (connection, true))\n    return; /* Data was pushed by TCP_NODELAY. */\n  /* Failed to set TCP_NODELAY for the socket.\n   * Really unlikely to happen on TCP connections. */\n  if (MHD_connection_set_cork_state_ (connection, false))\n    return; /* Data was pushed by uncorking the socket. */\n  /* Failed to uncork the socket.\n   * Really unlikely to happen on TCP connections. */\n\n  /* The socket remains corked, no way to push data */\n#endif /* ! MHD_USE_MSG_MORE */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n  if (MHD_connection_set_cork_state_ (connection, false))\n    return; /* Data was pushed by uncorking the socket. */\n  /* Failed to uncork the socket.\n   * Really unlikely to happen on TCP connections. */\n  return; /* Socket remains corked, no way to push data */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n  /* This is a typical *BSD or Darwin kernel. */\n\n  if (_MHD_OFF == connection->sk_corked)\n  {\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* Data was already pushed by send(). */\n\n    /* Unlikely to reach this code.\n     * TCP_NODELAY should be turned on before send(). */\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n    {\n      /* TCP_NODELAY has been set on uncorked socket.\n       * Use zero-send to push the data. */\n      if (zero_send_ (connection))\n        return; /* The data has been pushed by zero-send. */\n    }\n\n    /* Failed to push the data by all means. */\n    /* There is nothing left to try. */\n  }\n  else\n  {\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n    enum MHD_tristate old_cork_state = connection->sk_corked;\n#endif /* _MHD_CORK_RESET_PUSH_DATA */\n    /* The socket is corked or cork state is unknown. */\n\n    if (MHD_connection_set_cork_state_ (connection, false))\n    {\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n      /* FreeBSD kernel */\n      if (_MHD_OFF == old_cork_state)\n        return; /* Data has been pushed by uncorking the socket. */\n#endif /* _MHD_CORK_RESET_PUSH_DATA */\n\n      /* Unlikely to reach this code.\n       * The data should be pushed by uncorking (FreeBSD) or\n       * the socket should be uncorked before send(). */\n      if ((_MHD_ON == connection->sk_nodelay) ||\n          (MHD_connection_set_nodelay_state_ (connection, true)))\n      {\n        /* TCP_NODELAY is turned ON on uncorked socket.\n         * Use zero-send to push the data. */\n        if (zero_send_ (connection))\n          return; /* The data has been pushed by zero-send. */\n      }\n    }\n    /* The socket remains corked. Data cannot be pushed. */\n  }\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  /* Corking is not supported. Buffering is controlled\n   * by TCP_NODELAY only. */\n  mhd_assert (_MHD_ON != connection->sk_corked);\n  if (_MHD_ON == connection->sk_nodelay)\n    return; /* Data was already pushed by send(). */\n\n  /* Unlikely to reach this code.\n   * TCP_NODELAY should be turned on before send(). */\n  if (MHD_connection_set_nodelay_state_ (connection, true))\n  {\n    /* TCP_NODELAY has been set.\n     * Use zero-send to push the data. */\n    if (zero_send_ (connection))\n      return; /* The data has been pushed by zero-send. */\n  }\n\n  /* Failed to push the data. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Failed to push the data from buffers to the network. \"\n               \"Client may experience some delay \"\n               \"(usually in range 200ms - 5 sec).\\n\"));\n#endif /* HAVE_MESSAGES */\n  return;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function post_send_setopt:\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n...\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic void\npre_send_setopt (struct MHD_Connection *connection,\n                 bool plain_send,\n                 bool push_data)\n{\n  /* Try to buffer data if not sending the final piece.\n   * Final piece is indicated by push_data == true. */\n  const bool buffer_data = (! push_data);\n\n  if (_MHD_YES == connection->is_nonip)\n    return;\n  /* The goal is to minimise the total number of additional sys-calls\n   * before and after send().\n   * The following tricky (over-)complicated algorithm typically use zero,\n   * one or two additional sys-calls (depending on OS) for each response. */\n\n  if (buffer_data)\n  {\n    /* Need to buffer data if possible. */\n#ifdef MHD_USE_MSG_MORE\n    if (plain_send)\n      return; /* Data is buffered by send() with MSG_MORE flag.\n               * No need to check or change anything. */\n#else  /* ! MHD_USE_MSG_MORE */\n    (void) plain_send; /* Mute compiler warning. */\n#endif /* ! MHD_USE_MSG_MORE */\n\n#ifdef MHD_TCP_CORK_NOPUSH\n    if (_MHD_ON == connection->sk_corked)\n      return; /* The connection was already corked. */\n\n    if (MHD_connection_set_cork_state_ (connection, true))\n      return; /* The connection has been corked. */\n\n    /* Failed to cork the connection.\n     * Really unlikely to happen on TCP connections. */\n#endif /* MHD_TCP_CORK_NOPUSH */\n    if (_MHD_OFF == connection->sk_nodelay)\n      return; /* TCP_NODELAY was not set for the socket.\n               * Nagle's algorithm will buffer some data. */\n\n    /* Try to reset TCP_NODELAY state for the socket.\n     * Ignore possible error as no other options exist to\n     * buffer data. */\n    MHD_connection_set_nodelay_state_ (connection, false);\n    /* TCP_NODELAY has been (hopefully) reset for the socket.\n     * Nagle's algorithm will buffer some data. */\n    return;\n  }\n\n  /* Need to push data after send() */\n  /* If additional sys-call is required prefer to make it after the send()\n   * as the next send() may consume only part of the prepared data and\n   * more send() calls will be used. */\n#ifdef MHD_TCP_CORK_NOPUSH\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n#ifdef _MHD_CORK_RESET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by uncorking socket regardless of\n   * cork state before. */\n  /* This is typical for Linux, no other kernel with\n   * such behavior are known so far. */\n\n  /* No need to check the current state of TCP_CORK / TCP_NOPUSH\n   * as reset of cork will push the data anyway. */\n  return; /* Data may be pushed by resetting of\n           * TCP_CORK / TCP_NOPUSH after send() */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n  /* Reset of TCP_CORK / TCP_NOPUSH will push the data\n   * only if socket is corked. */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA_ALWAYS\n  /* Data can be pushed immediately by setting TCP_NODELAY regardless\n   * of TCP_NODDELAY or corking state before. */\n\n  /* Dead code currently, no known kernels with such behavior. */\n  return; /* Data may be pushed by setting of TCP_NODELAY after send().\n             No need to make extra sys-calls before send().*/\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* Setting of TCP_NODELAY will push the data only if\n   * both TCP_NODELAY and TCP_CORK / TCP_NOPUSH were not set. */\n\n  /* Data can be pushed immediately by uncorking socket if\n   * socket was corked before or by setting TCP_NODELAY if\n   * socket was not corked and TCP_NODELAY was not set before. */\n\n  /* Dead code currently as Linux is the only kernel that push\n   * data by setting of TCP_NODELAY and Linux push data always. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n  /* Data can be pushed immediately by uncorking socket or\n   * can be pushed by send() on uncorked socket if\n   * TCP_NODELAY was set *before*. */\n\n  /* This is typical FreeBSD behavior. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n  if (_MHD_ON == connection->sk_corked)\n    return; /* Socket is corked. Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  else if (_MHD_OFF == connection->sk_corked)\n  {\n    /* The socket is not corked. */\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* TCP_NODELAY was already set,\n               * data will be pushed automatically by the next send() */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n    else if (_MHD_UNKNOWN == connection->sk_nodelay)\n    {\n      /* Setting TCP_NODELAY may push data.\n       * Cork socket here and uncork after send(). */\n      if (MHD_connection_set_cork_state_ (connection, true))\n        return; /* The connection has been corked.\n                 * Data can be pushed by resetting of\n                 * TCP_CORK / TCP_NOPUSH after send() */\n      else\n      {\n        /* The socket cannot be corked.\n         * Really unlikely to happen on TCP connections */\n        /* Have to set TCP_NODELAY.\n         * If TCP_NODELAY real system state was OFF then\n         * already buffered data may be pushed here, but this is unlikely\n         * to happen as it is only a backup solution when corking has failed.\n         * Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_nodelay_state_ (connection, true);\n        /* TCP_NODELAY has been (hopefully) set for the socket.\n         * The data will be pushed by the next send(). */\n        return;\n      }\n    }\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n    else\n    {\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n      /* TCP_NODELAY was switched off and\n       * the socket is not corked. */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA */\n      /* Socket is not corked and TCP_NODELAY was not set or unknown. */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA */\n\n      /* At least one additional sys-call is required. */\n      /* Setting TCP_NODELAY is optimal here as data will be pushed\n       * automatically by the next send() and no additional\n       * sys-call are needed after the send(). */\n      if (MHD_connection_set_nodelay_state_ (connection, true))\n        return;\n      else\n      {\n        /* Failed to set TCP_NODELAY for the socket.\n         * Really unlikely to happen on TCP connections. */\n        /* Cork the socket here and make additional sys-call\n         * to uncork the socket after send(). */\n        /* Ignore possible error here as no other options exist to\n         * push data. */\n        MHD_connection_set_cork_state_ (connection, true);\n        /* The connection has been (hopefully) corked.\n         * Data can be pushed by resetting of TCP_CORK / TCP_NOPUSH\n         * after send() */\n        return;\n      }\n    }\n  }\n  /* Corked state is unknown. Need to make sys-call here otherwise\n   * data may not be pushed. */\n  if (MHD_connection_set_cork_state_ (connection, true))\n    return; /* The connection has been corked.\n             * Data can be pushed by resetting of\n             * TCP_CORK / TCP_NOPUSH after send() */\n  /* The socket cannot be corked.\n   * Really unlikely to happen on TCP connections */\n  if (_MHD_ON == connection->sk_nodelay)\n    return; /* TCP_NODELAY was already set,\n             * data will be pushed by the next send() */\n  /* Have to set TCP_NODELAY. */\n#ifdef _MHD_NODELAY_SET_PUSH_DATA\n  /* If TCP_NODELAY state was unknown (external connection) then\n   * already buffered data may be pushed here, but this is unlikely\n   * to happen as it is only a backup solution when corking has failed. */\n#endif /* _MHD_NODELAY_SET_PUSH_DATA */\n  /* Ignore possible error here as no other options exist to\n   * push data. */\n  MHD_connection_set_nodelay_state_ (connection, true);\n  /* TCP_NODELAY has been (hopefully) set for the socket.\n   * The data will be pushed by the next send(). */\n  return;\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA */\n  /* Neither uncorking the socket or setting TCP_NODELAY\n   * push the data immediately. */\n  /* The only way to push the data is to use send() on uncorked\n   * socket with TCP_NODELAY switched on . */\n\n  /* This is a typical *BSD (except FreeBSD) and Darwin behavior. */\n\n  /* Uncork socket if socket wasn't uncorked. */\n  if (_MHD_OFF != connection->sk_corked)\n    MHD_connection_set_cork_state_ (connection, false);\n\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n\n  return;\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA */\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  /* Buffering of data is controlled only by\n   * Nagel's algorithm. */\n  /* Set TCP_NODELAY if it wasn't set. */\n  if (_MHD_ON != connection->sk_nodelay)\n    MHD_connection_set_nodelay_state_ (connection, true);\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n}\n...\nssize_t\nMHD_send_data_ (struct MHD_Connection *connection,\n                const char *buffer,\n                size_t buffer_size,\n                bool push_data)\n{\n  MHD_socket s = connection->socket_fd;\n  ssize_t ret;\n#ifdef HTTPS_SUPPORT\n  const bool tls_conn = (connection->daemon->options & MHD_USE_TLS);\n#else  /* ! HTTPS_SUPPORT */\n  const bool tls_conn = false;\n#endif /* ! HTTPS_SUPPORT */\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  if (buffer_size > SSIZE_MAX)\n  {\n    buffer_size = SSIZE_MAX; /* Max return value */\n    push_data = false; /* Incomplete send */\n  }\n\n  if (tls_conn)\n  {\n#ifdef HTTPS_SUPPORT\n    pre_send_setopt (connection, (! tls_conn), push_data);\n    ret = gnutls_record_send (connection->tls_session,\n                              buffer,\n                              buffer_size);\n    if (GNUTLS_E_AGAIN == ret)\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n    if (GNUTLS_E_INTERRUPTED == ret)\n      return MHD_ERR_AGAIN_;\n    if ( (GNUTLS_E_ENCRYPTION_FAILED == ret) ||\n         (GNUTLS_E_INVALID_SESSION == ret) ||\n         (GNUTLS_E_COMPRESSION_FAILED == ret) ||\n         (GNUTLS_E_EXPIRED == ret) ||\n         (GNUTLS_E_HASH_FAILED == ret) )\n      return MHD_ERR_TLS_;\n    if ( (GNUTLS_E_PUSH_ERROR == ret) ||\n         (GNUTLS_E_INTERNAL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_IOCTL_ERROR == ret) ||\n         (GNUTLS_E_CRYPTODEV_DEVICE_ERROR == ret) )\n      return MHD_ERR_PIPE_;\n#if defined(GNUTLS_E_PREMATURE_TERMINATION)\n    if (GNUTLS_E_PREMATURE_TERMINATION == ret)\n      return MHD_ERR_CONNRESET_;\n#elif defined(GNUTLS_E_UNEXPECTED_PACKET_LENGTH)\n    if (GNUTLS_E_UNEXPECTED_PACKET_LENGTH == ret)\n      return MHD_ERR_CONNRESET_;\n#endif /* GNUTLS_E_UNEXPECTED_PACKET_LENGTH */\n    if (GNUTLS_E_MEMORY_ERROR == ret)\n      return MHD_ERR_NOMEM_;\n    if (ret < 0)\n    {\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    /* Unlike non-TLS connections, do not reset \"write-ready\" if\n     * sent amount smaller than provided amount, as TLS\n     * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n#else  /* ! HTTPS_SUPPORT  */\n    ret = MHD_ERR_NOTCONN_;\n#endif /* ! HTTPS_SUPPORT  */\n  }\n  else\n  {\n    /* plaintext transmission */\n    if (buffer_size > MHD_SCKT_SEND_MAX_SIZE_)\n    {\n      buffer_size = MHD_SCKT_SEND_MAX_SIZE_; /* send() return value limit */\n      push_data = false; /* Incomplete send */\n    }\n\n    pre_send_setopt (connection, (! tls_conn), push_data);\n#ifdef MHD_USE_MSG_MORE\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      push_data ? 0 : MSG_MORE);\n#else\n    ret = MHD_send4_ (s,\n                      buffer,\n                      buffer_size,\n                      0);\n#endif\n\n    if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n      {\n#ifdef EPOLL_SUPPORT\n        /* EAGAIN, no longer write-ready */\n        connection->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n        return MHD_ERR_AGAIN_;\n      }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n        return MHD_ERR_CONNRESET_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n        return MHD_ERR_PIPE_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n        return MHD_ERR_OPNOTSUPP_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n        return MHD_ERR_NOTCONN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n        return MHD_ERR_INVAL_;\n      if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n        return MHD_ERR_NOMEM_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* Treat any other error as a hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n    else if (buffer_size > (size_t) ret)\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n  }\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* If TLS connection is used then next final send() will be\n   * without MSG_MORE support. If non-TLS connection is used\n   * it's unknown whether sendfile() will be used or not so\n   * assume that next call will be the same, like this call. */\n  if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);\n\n  return ret;\n}\n...\nssize_t\nMHD_send_hdr_and_body_ (struct MHD_Connection *connection,\n                        const char *header,\n                        size_t header_size,\n                        bool never_push_hdr,\n                        const char *body,\n                        size_t body_size,\n                        bool complete_response)\n{\n  ssize_t ret;\n  bool push_hdr;\n  bool push_body;\n  MHD_socket s = connection->socket_fd;\n#ifndef _WIN32\n#define _MHD_SEND_VEC_MAX   MHD_SCKT_SEND_MAX_SIZE_\n#else  /* ! _WIN32 */\n#define _MHD_SEND_VEC_MAX   UINT32_MAX\n#endif /* ! _WIN32 */\n#ifdef MHD_VECT_SEND\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  struct iovec vector[2];\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#endif /* HAVE_SENDMSG */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  WSABUF vector[2];\n  DWORD vec_sent;\n#endif /* _WIN32 */\n  bool no_vec; /* Is vector-send() disallowed? */\n\n  no_vec = false;\n#ifdef HTTPS_SUPPORT\n  no_vec = no_vec || (connection->daemon->options & MHD_USE_TLS);\n#endif /* HTTPS_SUPPORT */\n#if (! defined(HAVE_SENDMSG) || ! defined(MSG_NOSIGNAL) ) && \\\n  defined(MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE) && \\\n  defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n  no_vec = no_vec || (! connection->daemon->sigpipe_blocked &&\n                      ! connection->sk_spipe_suppress);\n#endif /* (!HAVE_SENDMSG || ! MSG_NOSIGNAL) &&\n          MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE &&\n          MHD_SEND_SPIPE_SUPPRESS_NEEDED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert ( (NULL != body) || (0 == body_size) );\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  push_body = complete_response;\n\n  if (! never_push_hdr)\n  {\n    if (! complete_response)\n      push_hdr = true; /* Push the header as the client may react\n                        * on header alone while the body data is\n                        * being prepared. */\n    else\n    {\n      if (1400 > (header_size + body_size))\n        push_hdr = false;  /* Do not push the header as complete\n                           * reply is already ready and the whole\n                           * reply most probably will fit into\n                           * the single IP packet. */\n      else\n        push_hdr = true;   /* Push header alone so client may react\n                           * on it while reply body is being delivered. */\n    }\n  }\n  else\n    push_hdr = false;\n\n  if (complete_response && (0 == body_size))\n    push_hdr = true; /* The header alone is equal to the whole response. */\n\n  if (\n#ifdef MHD_VECT_SEND\n    (no_vec) ||\n    (0 == body_size) ||\n    ((size_t) SSIZE_MAX <= header_size) ||\n    ((size_t) _MHD_SEND_VEC_MAX < header_size)\n#ifdef _WIN32\n    || ((size_t) UINT_MAX < header_size)\n#endif /* _WIN32 */\n#else  /* ! MHD_VECT_SEND */\n    true\n#endif /* ! MHD_VECT_SEND */\n    )\n  {\n    ret = MHD_send_data_ (connection,\n                          header,\n                          header_size,\n                          push_hdr);\n\n    if ( (header_size == (size_t) ret) &&\n         ((size_t) SSIZE_MAX > header_size) &&\n         (0 != body_size) &&\n         (connection->sk_nonblck) )\n    {\n      ssize_t ret2;\n      /* The header has been sent completely.\n       * Try to send the reply body without waiting for\n       * the next round. */\n      /* Make sure that sum of ret + ret2 will not exceed SSIZE_MAX as\n       * function needs to return positive value if succeed. */\n      if ( (((size_t) SSIZE_MAX) - ((size_t) ret)) <  body_size)\n      {\n        body_size = (((size_t) SSIZE_MAX) - ((size_t) ret));\n        complete_response = false;\n        push_body = complete_response;\n      }\n\n      ret2 = MHD_send_data_ (connection,\n                             body,\n                             body_size,\n                             push_body);\n      if (0 < ret2)\n        return ret + ret2; /* Total data sent */\n      if (MHD_ERR_AGAIN_ == ret2)\n        return ret;\n\n      return ret2; /* Error code */\n    }\n    return ret;\n  }\n#ifdef MHD_VECT_SEND\n\n  if ( ((size_t) SSIZE_MAX <= body_size) ||\n       ((size_t) SSIZE_MAX < (header_size + body_size)) )\n  {\n    /* Return value limit */\n    body_size = SSIZE_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#if (SSIZE_MAX != _MHD_SEND_VEC_MAX) || (_MHD_SEND_VEC_MAX + 0 == 0)\n  if (((size_t) _MHD_SEND_VEC_MAX <= body_size) ||\n      ((size_t) _MHD_SEND_VEC_MAX < (header_size + body_size)))\n  {\n    /* Send total amount limit */\n    body_size = _MHD_SEND_VEC_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#endif /* SSIZE_MAX != _MHD_SEND_VEC_MAX */\n\n  pre_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                   true,\n#else  /* ! HAVE_SENDMSG */\n                   false,\n#endif /* ! HAVE_SENDMSG */\n                   push_hdr || push_body);\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  vector[0].iov_base = _MHD_DROP_CONST (header);\n  vector[0].iov_len = header_size;\n  vector[1].iov_base = _MHD_DROP_CONST (body);\n  vector[1].iov_len = body_size;\n\n#if defined(HAVE_SENDMSG)\n  memset (&msg, 0, sizeof(msg));\n  msg.msg_iov = vector;\n  msg.msg_iovlen = 2;\n\n  ret = sendmsg (s, &msg, MSG_NOSIGNAL_OR_ZERO);\n#elif defined(HAVE_WRITEV)\n  ret = writev (s, vector, 2);\n#endif /* HAVE_WRITEV */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  if ((size_t) UINT_MAX < body_size)\n  {\n    /* Send item size limit */\n    body_size = UINT_MAX;\n    complete_response = false;\n    push_body = complete_response;\n  }\n  vector[0].buf = (char *) _MHD_DROP_CONST (header);\n  vector[0].len = (unsigned long) header_size;\n  vector[1].buf = (char *) _MHD_DROP_CONST (body);\n  vector[1].len = (unsigned long) body_size;\n\n  ret = WSASend (s, vector, 2, &vec_sent, 0, NULL, NULL);\n  if (0 == ret)\n    ret = (ssize_t) vec_sent;\n  else\n    ret = -1;\n#endif /* _WIN32 */\n\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN, no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n#ifdef EPOLL_SUPPORT\n  else if ((header_size + body_size) > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  if ( (push_body) &&\n       ((header_size + body_size) == (size_t) ret) )\n  {\n    /* Complete reply has been sent. */\n    /* If TLS connection is used then next final send() will be\n     * without MSG_MORE support. If non-TLS connection is used\n     * it's unknown whether next 'send' will be plain send() / sendmsg() or\n     * sendfile() will be used so assume that next final send() will be\n     * the same, like for this response. */\n    post_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                      true,\n#else  /* ! HAVE_SENDMSG */\n                      false,\n#endif /* ! HAVE_SENDMSG */\n                      true);\n  }\n  else if ( (push_hdr) &&\n            (header_size <= (size_t) ret))\n  {\n    /* The header has been sent completely and there is a\n     * need to push the header data. */\n    /* Luckily the type of send function will be used next is known. */\n    post_send_setopt (connection,\n#if defined(_MHD_HAVE_SENDFILE)\n                      MHD_resp_sender_std == connection->rp.resp_sender,\n#else  /* ! _MHD_HAVE_SENDFILE */\n                      true,\n#endif /* ! _MHD_HAVE_SENDFILE */\n                      true);\n  }\n\n  return ret;\n#else  /* ! MHD_VECT_SEND */\n  mhd_assert (false);\n  return MHD_ERR_CONNRESET_; /* Unreachable. Mute warnings. */\n#endif /* ! MHD_VECT_SEND */\n}\n...\nssize_t\nMHD_send_sendfile_ (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  const int file_fd = connection->rp.response->fd;\n  uint64_t left;\n  uint64_t offsetu64;\n#ifndef HAVE_SENDFILE64\n  const uint64_t max_off_t = (uint64_t) OFF_T_MAX;\n#else  /* HAVE_SENDFILE64 */\n  const uint64_t max_off_t = (uint64_t) OFF64_T_MAX;\n#endif /* HAVE_SENDFILE64 */\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  off_t offset;\n#else  /* HAVE_SENDFILE64 */\n  off64_t offset;\n#endif /* HAVE_SENDFILE64 */\n#endif /* MHD_LINUX_SOLARIS_SENDFILE */\n#ifdef HAVE_FREEBSD_SENDFILE\n  off_t sent_bytes;\n  int flags = 0;\n#endif\n#ifdef HAVE_DARWIN_SENDFILE\n  off_t len;\n#endif /* HAVE_DARWIN_SENDFILE */\n  const bool used_thr_p_c =\n    MHD_D_IS_USING_THREAD_PER_CONN_ (connection->daemon);\n  const size_t chunk_size = used_thr_p_c ? MHD_SENFILE_CHUNK_THR_P_C_ :\n                            MHD_SENFILE_CHUNK_;\n  size_t send_size = 0;\n  bool push_data;\n  mhd_assert (MHD_resp_sender_sendfile == connection->rp.resp_sender);\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  offsetu64 = connection->rp.rsp_write_position\n              + connection->rp.response->fd_off;\n  if (max_off_t < offsetu64)\n  {   /* Retry to send with standard 'send()'. */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n\n  left = connection->rp.response->total_size\n         - connection->rp.rsp_write_position;\n\n  if ( (uint64_t) SSIZE_MAX < left)\n    left = SSIZE_MAX;\n\n  /* Do not allow system to stick sending on single fast connection:\n   * use 128KiB chunks (2MiB for thread-per-connection). */\n  if (chunk_size < left)\n  {\n    send_size = chunk_size;\n    push_data = false; /* No need to push data, there is more to send. */\n  }\n  else\n  {\n    send_size = (size_t) left;\n    push_data = true; /* Final piece of data, need to push to the network. */\n  }\n  pre_send_setopt (connection, false, push_data);\n\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  offset = (off_t) offsetu64;\n  ret = sendfile (connection->socket_fd,\n                  file_fd,\n                  &offset,\n                  send_size);\n#else  /* HAVE_SENDFILE64 */\n  offset = (off64_t) offsetu64;\n  ret = sendfile64 (connection->socket_fd,\n                    file_fd,\n                    &offset,\n                    send_size);\n#endif /* HAVE_SENDFILE64 */\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n#ifdef HAVE_LINUX_SENDFILE\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* sendfile() failed with EINVAL if mmap()-like operations are not\n       supported for FD or other 'unusual' errors occurred, so we should try\n       to fall back to 'SEND'; see also this thread for info on\n       odd libc/Linux behavior with sendfile:\n       http://lists.gnu.org/archive/html/libmicrohttpd/2011-02/msg00015.html */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n#else  /* HAVE_SOLARIS_SENDFILE */\n    if ( (EAFNOSUPPORT == err) ||\n         (EINVAL == err) ||\n         (EOPNOTSUPP == err) )\n    {     /* Retry with standard file reader. */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (ENOTCONN == err) ||\n         (EPIPE == err) )\n    {\n      return MHD_ERR_CONNRESET_;\n    }\n    return MHD_ERR_BADF_;   /* Fail hard */\n#endif /* HAVE_SOLARIS_SENDFILE */\n  }\n#ifdef EPOLL_SUPPORT\n  else if (send_size > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n#elif defined(HAVE_FREEBSD_SENDFILE)\n#ifdef SF_FLAGS\n  flags = used_thr_p_c ?\n          freebsd_sendfile_flags_thd_p_c_ : freebsd_sendfile_flags_;\n#endif /* SF_FLAGS */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     send_size,\n                     NULL,\n                     &sent_bytes,\n                     flags))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err) ||\n        (EBUSY == err) )\n    {\n      mhd_assert (SSIZE_MAX >= sent_bytes);\n      if (0 != sent_bytes)\n        return (ssize_t) sent_bytes;\n\n      return MHD_ERR_AGAIN_;\n    }\n    /* Some unrecoverable error. Possibly file FD is not suitable\n     * for sendfile(). Retry with standard send(). */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n  mhd_assert (0 < sent_bytes);\n  mhd_assert (SSIZE_MAX >= sent_bytes);\n  ret = (ssize_t) sent_bytes;\n#elif defined(HAVE_DARWIN_SENDFILE)\n  len = (off_t) send_size; /* chunk always fit */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     &len,\n                     NULL,\n                     0))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_assert (0 <= len);\n      mhd_assert (SSIZE_MAX >= len);\n      mhd_assert (send_size >= (size_t) len);\n      if (0 != len)\n        return (ssize_t) len;\n\n      return MHD_ERR_AGAIN_;\n    }\n    if ((ENOTCONN == err) ||\n        (EPIPE == err) )\n      return MHD_ERR_CONNRESET_;\n    if ((ENOTSUP == err) ||\n        (EOPNOTSUPP == err) )\n    {     /* This file FD is not suitable for sendfile().\n           * Retry with standard send(). */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    return MHD_ERR_BADF_;   /* Return hard error. */\n  }\n  mhd_assert (0 <= len);\n  mhd_assert (SSIZE_MAX >= len);\n  mhd_assert (send_size >= (size_t) len);\n  ret = (ssize_t) len;\n#endif /* HAVE_FREEBSD_SENDFILE */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* It's unknown whether sendfile() will be used in the next\n   * response so assume that next response will be the same. */\n  if ( (push_data) &&\n       (send_size == (size_t) ret) )\n    post_send_setopt (connection, false, push_data);\n\n  return ret;\n}\n...\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if ( (push_body) &&\n       ((header_size + body_size) == (size_t) ret) )\n{\n  post_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                    true,\n#else  /* ! HAVE_SENDMSG */\n                    false,\n#endif /* ! HAVE_SENDMSG */\n                    true);\n}",
    "if ( (push_data) &&\n       (buffer_size == (size_t) ret) )\n    post_send_setopt (connection, (! tls_conn), push_data);",
    "else if ( (push_hdr) &&\n          (header_size <= (size_t) ret))\n{\n  post_send_setopt (connection,\n#if defined(_MHD_HAVE_SENDFILE)\n                    MHD_resp_sender_std == connection->rp.resp_sender,\n#else  /* ! _MHD_HAVE_SENDFILE */\n                    true,\n#endif /* ! _MHD_HAVE_SENDFILE */\n                    true);\n}",
    "if (MHD_connection_set_cork_state_ (connection, false))\n      return; /* Data has been pushed by uncorking the socket. */",
    "#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Failed to push the data from buffers to the network. \"\n               \"Client may experience some delay \"\n               \"(usually in range 200ms - 5 sec).\\n\"));\n#endif /* HAVE_MESSAGES */",
    "if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);",
    "if ( (push_data) &&\n       (send_size == (size_t) ret) )\n  post_send_setopt (connection, false, push_data);",
    "if (MHD_connection_set_cork_state_ (connection, true))\n      return; /* The connection has been corked. */",
    "MHD_DLOG (connection->daemon,\n            _ (\"Setting %s option to %s state failed: %s\\n\"),\n            \"TCP_NODELAY\",\n            nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n            MHD_socket_strerr_ (err_code));",
    "if (zero_send_ (connection))\n        return; /* The data has been pushed by zero-send. */",
    "if (MHD_connection_set_nodelay_state_ (connection, true))\n      return; /* Data has been pushed by TCP_NODELAY. */"
  ],
  "explanation": "I selected fragments that either (a) call post_send_setopt (all call sites found in the provided code), or (b) are calls made by post_send_setopt to other functions that might themselves invoke sending logic or user callbacks (zero_send_, MHD_connection_set_nodelay_state_, MHD_connection_set_cork_state_, and MHD_DLOG). These are the places that could form a direct or indirect recursion cycle (e.g. post_send_setopt -> zero_send_ -> some send wrapper -> post_send_setopt, or any path involving user-supplied custom_error_log via MHD_DLOG that might call back into library send logic). Other fragments were not included because they do not contain calls that can reasonably lead back into the functions involved in send/post-send handling: for example, direct system calls (setsockopt, send, sendmsg, writev, sendfile) and simple state updates that do not call library-level send/post functions cannot form a recursion cycle within the shown code. Also, internal helpers that neither call post_send_setopt nor call user callbacks (or unknown functions like zero_send_) were omitted. If desired, I can expand the investigation to additional call sites or include more context (e.g. the full zero_send_ implementation) to determine any indirect recursion paths more precisely."
}