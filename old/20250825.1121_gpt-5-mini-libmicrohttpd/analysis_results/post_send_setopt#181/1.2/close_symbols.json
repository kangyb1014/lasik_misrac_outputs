{
  "user_message": "Target function code is:\n```c\nstatic void\npost_send_setopt (struct MHD_Connection *connection,\n                  bool plain_send_next,\n                  bool push_data)\n{\n  /* Try to buffer data if not sending the final piece.\n   * Final piece is indicated by push_data == true. */\n  const bool buffer_data = (! push_data);\n\n  if (_MHD_YES == connection->is_nonip)\n    return;\n  if (buffer_data)\n    return; /* Nothing to do after send(). */\n\n#ifndef MHD_USE_MSG_MORE\n  (void) plain_send_next; /* Mute compiler warning */\n#endif /* ! MHD_USE_MSG_MORE */\n\n  /* Need to push data. */\n#ifdef MHD_TCP_CORK_NOPUSH\n#ifdef _MHD_CORK_RESET_PUSH_DATA_ALWAYS\n#ifdef _MHD_NODELAY_SET_PUSH_DATA_ALWAYS\n#ifdef MHD_USE_MSG_MORE\n  if (_MHD_OFF == connection->sk_corked)\n  {\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* Data was already pushed by send(). */\n  }\n  /* This is Linux kernel. There are options:\n   * * Push the data by setting of TCP_NODELAY (without change\n   *   of the cork on the socket),\n   * * Push the data by resetting of TCP_CORK.\n   * The optimal choice depends on the next final send functions\n   * used on the same socket. If TCP_NODELAY wasn't set then push\n   * data by setting TCP_NODELAY (TCP_NODELAY will not be removed\n   * and is needed to push the data by send() without MSG_MORE).\n   * If send()/sendmsg() will be used next than push data by\n   * resetting of TCP_CORK so next send without MSG_MORE will push\n   * data to the network (without additional sys-call to push data).\n   * If next final send function will not support MSG_MORE (like\n   * sendfile() or TLS-connection) than push data by setting\n   * TCP_NODELAY so socket will remain corked (no additional\n   * sys-call before next send()). */\n  if ((_MHD_ON != connection->sk_nodelay) ||\n      (! plain_send_next))\n  {\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n      return; /* Data has been pushed by TCP_NODELAY. */\n    /* Failed to set TCP_NODELAY for the socket.\n     * Really unlikely to happen on TCP connections. */\n    if (MHD_connection_set_cork_state_ (connection, false))\n      return; /* Data has been pushed by uncorking the socket. */\n    /* Failed to uncork the socket.\n     * Really unlikely to happen on TCP connections. */\n\n    /* The socket cannot be uncorked, no way to push data */\n  }\n  else\n  {\n    if (MHD_connection_set_cork_state_ (connection, false))\n      return; /* Data has been pushed by uncorking the socket. */\n    /* Failed to uncork the socket.\n     * Really unlikely to happen on TCP connections. */\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n      return; /* Data has been pushed by TCP_NODELAY. */\n    /* Failed to set TCP_NODELAY for the socket.\n     * Really unlikely to happen on TCP connections. */\n\n    /* The socket cannot be uncorked, no way to push data */\n  }\n#else  /* ! MHD_USE_MSG_MORE */\n  /* Use setting of TCP_NODELAY here to avoid sys-call\n   * for corking the socket during sending of the next response. */\n  if (MHD_connection_set_nodelay_state_ (connection, true))\n    return; /* Data was pushed by TCP_NODELAY. */\n  /* Failed to set TCP_NODELAY for the socket.\n   * Really unlikely to happen on TCP connections. */\n  if (MHD_connection_set_cork_state_ (connection, false))\n    return; /* Data was pushed by uncorking the socket. */\n  /* Failed to uncork the socket.\n   * Really unlikely to happen on TCP connections. */\n\n  /* The socket remains corked, no way to push data */\n#endif /* ! MHD_USE_MSG_MORE */\n#else  /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n  if (MHD_connection_set_cork_state_ (connection, false))\n    return; /* Data was pushed by uncorking the socket. */\n  /* Failed to uncork the socket.\n   * Really unlikely to happen on TCP connections. */\n  return; /* Socket remains corked, no way to push data */\n#endif /* ! _MHD_NODELAY_SET_PUSH_DATA_ALWAYS */\n#else  /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n  /* This is a typical *BSD or Darwin kernel. */\n\n  if (_MHD_OFF == connection->sk_corked)\n  {\n    if (_MHD_ON == connection->sk_nodelay)\n      return; /* Data was already pushed by send(). */\n\n    /* Unlikely to reach this code.\n     * TCP_NODELAY should be turned on before send(). */\n    if (MHD_connection_set_nodelay_state_ (connection, true))\n    {\n      /* TCP_NODELAY has been set on uncorked socket.\n       * Use zero-send to push the data. */\n      if (zero_send_ (connection))\n        return; /* The data has been pushed by zero-send. */\n    }\n\n    /* Failed to push the data by all means. */\n    /* There is nothing left to try. */\n  }\n  else\n  {\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n    enum MHD_tristate old_cork_state = connection->sk_corked;\n#endif /* _MHD_CORK_RESET_PUSH_DATA */\n    /* The socket is corked or cork state is unknown. */\n\n    if (MHD_connection_set_cork_state_ (connection, false))\n    {\n#ifdef _MHD_CORK_RESET_PUSH_DATA\n      /* FreeBSD kernel */\n      if (_MHD_OFF == old_cork_state)\n        return; /* Data has been pushed by uncorking the socket. */\n#endif /* _MHD_CORK_RESET_PUSH_DATA */\n\n      /* Unlikely to reach this code.\n       * The data should be pushed by uncorking (FreeBSD) or\n       * the socket should be uncorked before send(). */\n      if ((_MHD_ON == connection->sk_nodelay) ||\n          (MHD_connection_set_nodelay_state_ (connection, true)))\n      {\n        /* TCP_NODELAY is turned ON on uncorked socket.\n         * Use zero-send to push the data. */\n        if (zero_send_ (connection))\n          return; /* The data has been pushed by zero-send. */\n      }\n    }\n    /* The socket remains corked. Data cannot be pushed. */\n  }\n#endif /* ! _MHD_CORK_RESET_PUSH_DATA_ALWAYS */\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  /* Corking is not supported. Buffering is controlled\n   * by TCP_NODELAY only. */\n  mhd_assert (_MHD_ON != connection->sk_corked);\n  if (_MHD_ON == connection->sk_nodelay)\n    return; /* Data was already pushed by send(). */\n\n  /* Unlikely to reach this code.\n   * TCP_NODELAY should be turned on before send(). */\n  if (MHD_connection_set_nodelay_state_ (connection, true))\n  {\n    /* TCP_NODELAY has been set.\n     * Use zero-send to push the data. */\n    if (zero_send_ (connection))\n      return; /* The data has been pushed by zero-send. */\n  }\n\n  /* Failed to push the data. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _ (\"Failed to push the data from buffers to the network. \"\n               \"Client may experience some delay \"\n               \"(usually in range 200ms - 5 sec).\\n\"));\n#endif /* HAVE_MESSAGES */\n  return;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'MHD_send_sendfile_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (definition, fields: is_nonip, sk_corked, sk_nodelay, daemon)",
    "enum MHD_tristate and constants (_MHD_YES, _MHD_ON, _MHD_OFF)",
    "MHD_connection_set_nodelay_state_ (declaration/definition or macro expansion)",
    "MHD_connection_set_cork_state_ (declaration/definition or macro expansion)",
    "zero_send_ (declaration/definition or macro expansion)",
    "mhd_assert (macro definition)",
    "MHD_DLOG (macro or function definition)",
    "_ (gettext) macro/function (definition)",
    "stdbool.h / bool / true / false (type definition)",
    "Preprocessor config macros that control compiled path: MHD_USE_MSG_MORE, MHD_TCP_CORK_NOPUSH, _MHD_CORK_RESET_PUSH_DATA_ALWAYS, _MHD_NODELAY_SET_PUSH_DATA_ALWAYS, _MHD_CORK_RESET_PUSH_DATA, HAVE_MESSAGES"
  ],
  "explanation": "To decide whether post_send_setopt uses any compiler/language extensions (MISRA: \"Language extensions should not be used\"), the analyzer must inspect all externally defined symbols and compile-time options that can introduce extensions in the compiled code paths or expand to extension constructs. Specifically:\n\n- struct MHD_Connection (definition, fields: is_nonip, sk_corked, sk_nodelay, daemon): the concrete type/field definitions may use implementation-specific attributes, packed/unaligned annotations, bit-fields, GCC/Clang extensions, anonymous structs/unions, or other non-standard constructs that would violate the MISRA prohibition on language extensions. The analyzer must see the type definition to confirm none are present.\n\n- enum MHD_tristate and constants (_MHD_YES, _MHD_ON, _MHD_OFF): these identifiers may be macros or enumerators. Their definitions determine whether non-standard constructs (e.g., macros using statement-expressions, typeof, or other extensions) are used when compared in code.\n\n- MHD_connection_set_nodelay_state_ and MHD_connection_set_cork_state_: these appear to be either functions or macros. If they are macros, their expansions could use compiler extensions (statement-expressions ({ ... }), gcc/clang builtins, inline assembly, attributes). If they are functions, their declarations could contain GCC/Clang attributes (e.g., __attribute__((...))) which are compiler extensions. The definitions/declarations must be checked.\n\n- zero_send_: same rationale as above (could be a macro using extensions or a function declared with attributes).\n\n- mhd_assert: assertion macros commonly expand to do{...}while(0) (standard) but may also use extension constructs. Must inspect the macro to ensure no extensions (e.g., use of __builtin_expect, statement-expression, or reserved compiler intrinsics).\n\n- MHD_DLOG and _ (gettext): logging and localization macros are often implemented as variadic macros, function-like macros, or wrappers that can include compiler-specific attributes (format checking, nonstandard variadic handling) or other extensions. Their definitions determine whether the compiled code uses language extensions.\n\n- stdbool.h / bool / true / false: the boolean type is standard in C99, but some projects typedef a custom boolean or use compiler-specific synonyms. Confirming the actual typedef (or use of _Bool) ensures no use of nonstandard boolean types or macros that are language extensions.\n\n- Preprocessor config macros (MHD_USE_MSG_MORE, MHD_TCP_CORK_NOPUSH, _MHD_CORK_RESET_PUSH_DATA_ALWAYS, _MHD_NODELAY_SET_PUSH_DATA_ALWAYS, _MHD_CORK_RESET_PUSH_DATA, HAVE_MESSAGES): which of these are defined selects different code paths. Some alternate branches may contain extensions while others do not. The analyzer needs the configuration (which macros are defined) and, where necessary, the definitions of those macros if they expand to non-standard constructs.\n\nIn short: inspect the concrete definitions (headers/source) of all called functions/macros, the connection type, the tristate constants, the assert/logging/localization macros, and the compile-time feature macros. Any of those can introduce language extensions even though post_send_setopt's surface code appears conventional."
}