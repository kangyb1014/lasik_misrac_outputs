{
  "user_message": "Target function code is:\n```c\nstatic int\nmhd_tool_get_proc_cpu_count_sched_getaffinity_np_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SCHED_GETAFFINITY_NP) && defined(HAVE_GETPID)\n  /* NetBSD style */\n  cpuset_t *cpuset_ptr;\n  cpuset_ptr = cpuset_create ();\n  if (NULL != cpuset_ptr)\n  {\n    if (0 == sched_getaffinity_np (getpid (), cpuset_size (cpuset_ptr),\n                                   cpuset_ptr))\n    {\n      cpuid_t cpu_num;\n#if defined(HAVE_SYSCONF) && defined(HAVE_DECL__SC_NPROCESSORS_CONF)\n      unsigned int max_num = 0;\n      long sc_value;\n      sc_value = sysconf (_SC_NPROCESSORS_ONLN);\n      if (0 < sc_value)\n        max_num = (unsigned int) sc_value;\n      if (0 < max_num)\n      {\n        ret = 0;\n        for (cpu_num = 0; cpu_num < max_num; ++cpu_num)\n          if (0 < cpuset_isset (cpu_num, cpuset_ptr))\n            ++ret;\n      }\n      else /* Combined with the next 'if' */\n#endif /* HAVE_SYSCONF && HAVE_DECL__SC_NPROCESSORS_CONF */\n      if (1)\n      {\n        int res;\n        cpu_num = 0;\n        ret = 0;\n        do\n        {\n          res = cpuset_isset (cpu_num++, cpuset_ptr);\n          if (0 < res)\n            ++ret;\n        } while (0 <= res);\n      }\n#ifdef __NetBSD__\n      if (0 == ret)\n      {\n        /* On NetBSD \"unset\" affinity (exactly zero CPUs) means\n           \"all CPUs are available\". */\n        ret = mhd_tool_get_sys_cpu_count_sysctl_ ();\n      }\n#endif /* __NetBSD__ */\n    }\n    cpuset_destroy (cpuset_ptr);\n  }\n#endif /* HAVE_SCHED_GETAFFINITY_NP && HAVE_GETPID */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_': {'callees': [], 'callers': ['mhd_tool_get_proc_cpu_count']}, 'mhd_tool_get_proc_cpu_count': {'callees': ['mhd_tool_get_proc_cpu_count_sched_getaffinity_', 'mhd_tool_get_proc_cpu_count_cpuset_getaffinity_', 'mhd_tool_get_proc_cpu_count_sched_getaffinity_np_', 'mhd_tool_get_proc_cpu_count_w32_'], 'callers': ['detect_cpu_core_count', 'detect_process_cpu_core_count', 'mhd_tool_get_system_cpu_count']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "cpuset_t",
    "cpuset_create",
    "cpuset_size",
    "cpuset_isset",
    "cpuset_destroy",
    "cpuid_t",
    "sched_getaffinity_np",
    "getpid",
    "sysconf",
    "_SC_NPROCESSORS_ONLN",
    "mhd_tool_get_sys_cpu_count_sysctl_",
    "HAVE_SCHED_GETAFFINITY_NP",
    "HAVE_GETPID",
    "HAVE_SYSCONF",
    "HAVE_DECL__SC_NPROCESSORS_CONF",
    "__NetBSD__"
  ],
  "explanation": "You must examine the declarations/definitions of all external types, functions, macros and build macros referenced by the target function to determine whether any of them (or their headers) employ compiler language extensions (e.g. GCC __attribute__, typeof, statement-expressions, inline asm, __extension__, nested functions, nonstandard storage-class specifiers, etc.). For each symbol:\n\n- cpuset_t: the underlying typedef/definition may use compiler-specific constructs or attributes; inspect to detect extensions in type declarations.\n- cpuset_create: may be a macro, inline function, or wrapper that uses compiler extensions; need its definition to check.\n- cpuset_size: commonly a macro that could use statement-expressions or typeof; inspect its expansion for extensions.\n- cpuset_isset: likely a macro or inline; its implementation could use compiler extensions (statement expressions, builtins); check it.\n- cpuset_destroy: function/macro; check its declaration/definition for extensions.\n- cpuid_t: type alias; its definition may involve extensions (e.g. unusual typedefs, attributes) so must be checked.\n- sched_getaffinity_np: nonstandard API; its prototype or wrapper may use attributes or compiler extensions\u2014inspect declaration.\n- getpid: may be a macro or inline wrapper on some platforms; check for attributes/extensions in its declaration.\n- sysconf: library function prototype may carry attributes (nonnull, etc.) or platform headers may use extensions\u2014check header.\n- _SC_NPROCESSORS_ONLN: macro constant from headers; its definition context can reveal platform-specific macros or extensions.\n- mhd_tool_get_sys_cpu_count_sysctl_: internal helper; its definition must be checked for any use of compiler extensions that would affect the analysis of this function (called when __NetBSD__ path taken).\n- HAVE_SCHED_GETAFFINITY_NP, HAVE_GETPID, HAVE_SYSCONF, HAVE_DECL__SC_NPROCESSORS_CONF: build-configuration macros determine which code is compiled; you must know their values to know which declarations/paths are active and therefore which external symbols to inspect for extensions.\n- __NetBSD__: platform macro controls NetBSD-specific block where semantics differ; its presence/absence affects control flow and which external symbol (mhd_tool_get_sys_cpu_count_sysctl_) is relevant.\n\nCollect the headers/definitions for these symbols to confirm whether any compiler-specific language extensions are used either in their declarations or in macros that expand into the target function's compiled code."
}