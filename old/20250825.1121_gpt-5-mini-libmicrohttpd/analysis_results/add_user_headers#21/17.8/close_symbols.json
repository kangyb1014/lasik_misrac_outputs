{
  "user_message": "Target function code is:\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_user_headers': {'callees': [], 'callers': ['build_header_response']}, 'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "memcpy",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_str_equal_caseless_n_",
    "MHD_HTTP_HEADER_TRANSFER_ENCODING",
    "MHD_HTTP_HEADER_CONTENT_LENGTH",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_HEADER_KIND",
    "struct MHD_Response (definition: fields flags_auto, flags, first_header)",
    "struct MHD_HTTP_Res_Header (definition: fields kind, header_size, header, value_size, value, next)",
    "MHD_RAF_HAS_TRANS_ENC_CHUNKED",
    "MHD_RAF_HAS_CONTENT_LENGTH",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_RF_INSANITY_HEADER_CONTENT_LENGTH"
  ],
  "explanation": "To decide whether add_user_headers violates the MISRA rule that a function parameter shall not be modified we must be sure that none of the listed external symbols (macros, functions, or struct fields) cause hidden modification of the formal parameters or change their semantics. Specific reasons:\n- mhd_assert: usually a macro; its expansion could evaluate or assign to subexpressions (e.g. it could be implemented with side-effects). Need its definition to ensure it does not modify any of the parameter identifiers (add_close/add_keep_alive etc.) when invoked.\n- memcpy: standard function used to write into the buffer pointed to by buf. We must distinguish modifications to the object pointed to by buf (permitted) from modifications to the pointer parameter buf itself (forbidden). Knowing memcpy semantics confirms it only modifies memory pointed to, not the pointer variable.\n- MHD_STATICSTR_LEN_, MHD_str_equal_caseless_bin_n_, MHD_str_equal_caseless_n_: these macros/functions are used in conditional checks and size computations. Their definitions must be checked to ensure they do not have side-effects that assign to function parameters (e.g. by expanding to code that writes into those identifiers).\n- MHD_HTTP_HEADER_TRANSFER_ENCODING, MHD_HTTP_HEADER_CONTENT_LENGTH, MHD_HTTP_HEADER_CONNECTION, MHD_HEADER_KIND: header-name macros/constants are compared against hdr->header; ensure they are pure constants (no side effects) so those comparisons do not alter parameters.\n- struct MHD_Response (definition: flags_auto, flags, first_header): the code reads r->flags_auto and r->flags and iterates r->first_header. We need the struct definition to ensure these are ordinary fields (no unusual macro tricks) and to confirm r was created from response without assigning back to the parameter 'response'. Also to confirm no write to response itself occurs.\n- struct MHD_HTTP_Res_Header (definition: kind, header_size, header, value_size, value, next): used throughout; need to confirm accessing hdr->... is field access (and that none of those fields are implemented as macros that could mutate the function parameters) and to confirm the code does not assign to hdr in a way that aliases a parameter.\n- MHD_RAF_HAS_TRANS_ENC_CHUNKED, MHD_RAF_HAS_CONTENT_LENGTH, MHD_RAF_HAS_CONNECTION_HDR, MHD_RAF_HAS_CONNECTION_CLOSE, MHD_RF_INSANITY_HEADER_CONTENT_LENGTH: these flag macros/constants are used in bit-tests. Their definitions are required to ensure they are simple bit masks (no side-effects) and to understand whether the boolean parameters are being set/reset because of those checks (but not being modified by them).\n\nWith these symbol definitions we can determine whether the code only modifies the objects pointed to by pointer parameters (allowed) and whether any of the formal parameters themselves (filter_transf_enc, filter_content_len, add_close, add_keep_alive, buf, ppos, buf_size, response) are being assigned to by the function or by expanded macros \u2014 the latter would be a MISRA violation. In particular be sure to verify the definitions of macros/functions listed to rule out hidden assignments to the formal parameter identifiers."
}