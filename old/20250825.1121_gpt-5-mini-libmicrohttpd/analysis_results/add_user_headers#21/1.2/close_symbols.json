{
  "user_message": "Target function code is:\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_user_headers': {'callees': [], 'callers': ['build_header_response']}, 'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_str_equal_caseless_n_",
    "struct MHD_Response (full definition)",
    "struct MHD_HTTP_Res_Header (full definition)",
    "MHD_RAF_HAS_TRANS_ENC_CHUNKED",
    "MHD_RAF_HAS_CONTENT_LENGTH",
    "MHD_RAF_HAS_CONNECTION_HDR",
    "MHD_RAF_HAS_CONNECTION_CLOSE",
    "MHD_HEADER_KIND",
    "MHD_HTTP_HEADER_TRANSFER_ENCODING",
    "MHD_HTTP_HEADER_CONTENT_LENGTH",
    "MHD_RF_INSANITY_HEADER_CONTENT_LENGTH",
    "MHD_HTTP_HEADER_CONNECTION",
    "memcpy (prototype / <string.h>)"
  ],
  "explanation": "Each listed symbol is needed to decide whether the target function uses a compiler/language extension (MISRA rule check):\n\n- mhd_assert: it is a macro; its definition must be inspected to detect use of GCC/clang extensions (statement-expressions, __attribute__, inline asm, __builtin_ helpers, etc.).\n- MHD_STATICSTR_LEN_: this macro is used repeatedly for compile-time string lengths; its expansion may rely on extensions (e.g. __builtin_constant_p, sizeof tricks, typeof, statement-expressions), so the exact macro body is required.\n- MHD_str_equal_caseless_bin_n_: this helper might be a macro or inline/function that could use compiler extensions (inline semantics, attributes, builtin functions). Its definition is needed to check for extensions.\n- MHD_str_equal_caseless_n_: same reason as above (different variant used in an assertion-like check).\n- struct MHD_Response (full definition): the function accesses many fields (flags_auto, flags, first_header); the struct definition must be checked for anonymous/unnamed members, compiler-specific bit-field width extensions, packed/aligned attributes, or other non-standard constructs.\n- struct MHD_HTTP_Res_Header (full definition): the function reads header_size, header, value_size, value, next and uses these in pointer/size arithmetic; the struct definition may include flexible array members, anonymous unions/structs, or compiler-specific extensions that violate MISRA.\n- MHD_RAF_HAS_TRANS_ENC_CHUNKED, MHD_RAF_HAS_CONTENT_LENGTH, MHD_RAF_HAS_CONNECTION_HDR, MHD_RAF_HAS_CONNECTION_CLOSE: these macros/enum values are used in bitmask tests; their definitions are needed to ensure they are standard integer constant macros/enum members and not defined via an extension.\n- MHD_HEADER_KIND: used to compare hdr->kind; its definition (enum or macro) must be checked for non-standard constructs.\n- MHD_HTTP_HEADER_TRANSFER_ENCODING, MHD_HTTP_HEADER_CONTENT_LENGTH, MHD_HTTP_HEADER_CONNECTION: these symbols are used as compile-time string tokens and as macro arguments; their definitions (likely string literals or macros) must be inspected to ensure they are not built using compiler-specific extensions.\n- MHD_RF_INSANITY_HEADER_CONTENT_LENGTH: used to compute filter flag behavior; definition must be checked to ensure it is a standard constant.\n- memcpy (prototype / <string.h>): the declaration/including header must be standard C; if the project replaced or wrapped memcpy with a macro using extensions, that would be relevant.\n\nSupplying these definitions/macros allows the next agent to determine whether any of those macros, types, or helper functions use compiler-specific language extensions (e.g. GCC statement-expressions, typeof, inline asm, attributes, unnamed fields, nonstandard declarators), which is required to decide compliance with the MISRA prohibition on language extensions."
}