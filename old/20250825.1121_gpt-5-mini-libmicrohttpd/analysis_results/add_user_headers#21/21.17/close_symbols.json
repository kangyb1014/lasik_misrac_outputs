{
  "user_message": "Target function code is:\n```c\nstatic bool\nadd_user_headers (char *buf,\n                  size_t *ppos,\n                  size_t buf_size,\n                  struct MHD_Response *response,\n                  bool filter_transf_enc,\n                  bool filter_content_len,\n                  bool add_close,\n                  bool add_keep_alive)\n{\n  struct MHD_Response *const r = response; /**< a short alias */\n  struct MHD_HTTP_Res_Header *hdr; /**< Iterates through User-specified headers */\n  size_t el_size; /**< the size of current element to be added to the @a buf */\n\n  mhd_assert (! add_close || ! add_keep_alive);\n\n  if (0 == (r->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n    filter_transf_enc = false;   /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n    filter_content_len = false;  /* No such header */\n  if (0 == (r->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n  {\n    add_close = false;          /* No such header */\n    add_keep_alive = false;     /* No such header */\n  }\n  else if (0 != (r->flags_auto & MHD_RAF_HAS_CONNECTION_CLOSE))\n    add_close = false;          /* \"close\" token was already set */\n\n  for (hdr = r->first_header; NULL != hdr; hdr = hdr->next)\n  {\n    size_t initial_pos = *ppos;\n    if (MHD_HEADER_KIND != hdr->kind)\n      continue;\n    if (filter_transf_enc)\n    { /* Need to filter-out \"Transfer-Encoding\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_TRANSFER_ENCODING) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_TRANSFER_ENCODING,\n                                          hdr->header, hdr->header_size)) )\n      {\n        filter_transf_enc = false; /* There is the only one such header */\n        continue; /* Skip \"Transfer-Encoding\" header */\n      }\n    }\n    if (filter_content_len)\n    { /* Need to filter-out \"Content-Length\" */\n      if ((MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_CONTENT_LENGTH) ==\n           hdr->header_size) &&\n          (MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_CONTENT_LENGTH,\n                                          hdr->header, hdr->header_size)) )\n      {\n        /* Reset filter flag if only one header is allowed */\n        filter_transf_enc =\n          (0 == (r->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH));\n        continue; /* Skip \"Content-Length\" header */\n      }\n    }\n\n    /* Add user header */\n    el_size = hdr->header_size + 2 + hdr->value_size + 2;\n    if (buf_size < *ppos + el_size)\n      return false;\n    memcpy (buf + *ppos, hdr->header, hdr->header_size);\n    (*ppos) += hdr->header_size;\n    buf[(*ppos)++] = ':';\n    buf[(*ppos)++] = ' ';\n    if (add_close || add_keep_alive)\n    {\n      /* \"Connection:\" header must be always the first one */\n      mhd_assert (MHD_str_equal_caseless_n_ (hdr->header, \\\n                                             MHD_HTTP_HEADER_CONNECTION, \\\n                                             hdr->header_size));\n\n      if (add_close)\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"close, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"close, \",\n                MHD_STATICSTR_LEN_ (\"close, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"close, \");\n      }\n      else\n      {\n        el_size += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n        if (buf_size < initial_pos + el_size)\n          return false;\n        memcpy (buf + *ppos, \"Keep-Alive, \",\n                MHD_STATICSTR_LEN_ (\"Keep-Alive, \"));\n        *ppos += MHD_STATICSTR_LEN_ (\"Keep-Alive, \");\n      }\n      add_close = false;\n      add_keep_alive = false;\n    }\n    if (0 != hdr->value_size)\n      memcpy (buf + *ppos, hdr->value, hdr->value_size);\n    *ppos += hdr->value_size;\n    buf[(*ppos)++] = '\\r';\n    buf[(*ppos)++] = '\\n';\n    mhd_assert (initial_pos + el_size == (*ppos));\n  }\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'add_user_headers': {'callees': [], 'callers': ['build_header_response']}, 'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response (definition: fields flags_auto, flags, first_header)",
    "struct MHD_HTTP_Res_Header (definition: fields kind, header_size, header, value_size, value, next)",
    "MHD_HEADER_KIND (macro/value)",
    "MHD_HTTP_HEADER_TRANSFER_ENCODING (static string / macro)",
    "MHD_HTTP_HEADER_CONTENT_LENGTH (static string / macro)",
    "MHD_HTTP_HEADER_CONNECTION (static string / macro)",
    "MHD_STATICSTR_LEN_ (macro) \u2014 exact expansion/semantics",
    "MHD_str_equal_caseless_bin_n_ (prototype & semantics)",
    "MHD_str_equal_caseless_n_ (prototype & semantics)",
    "flags in r->flags_auto: MHD_RAF_HAS_TRANS_ENC_CHUNKED, MHD_RAF_HAS_CONTENT_LENGTH, MHD_RAF_HAS_CONNECTION_HDR, MHD_RAF_HAS_CONNECTION_CLOSE (values/semantics)",
    "flag MHD_RF_INSANITY_HEADER_CONTENT_LENGTH (value/semantics used with r->flags)",
    "Invariant/contract that hdr->header points to a buffer of at least hdr->header_size bytes and hdr->value points to a buffer of at least hdr->value_size bytes (producer/allocator or initializer that creates/populates headers)",
    "Caller context: build_header_response (signature or excerpt showing how buf, ppos and buf_size are provided/initialized and any invariants on *ppos and buf_size)"
  ],
  "explanation": "To determine whether the memcpy uses in add_user_headers can access beyond object bounds we must know the exact layout, types and invariants of the objects and macros used in index/length computations and comparisons. Specifically:\n\n- struct MHD_Response: we need to know the type and bit-width of flags_auto/flags and how first_header is populated; those fields control filtering and which headers are iterated (affects whether code early-skips or injects extra data).\n\n- struct MHD_HTTP_Res_Header: header_size and value_size types and the guarantees that header and value point to at least header_size and value_size bytes are essential to prove memcpy source accesses are within bounds.\n\n- MHD_HEADER_KIND and the three HTTP header-name macros: the code branches on kind and compares header names against these static strings; we must know their exact values/formats to verify the comparison functions are called with correct lengths and do not cause any hidden over-reads.\n\n- MHD_STATICSTR_LEN_: add_user_headers uses this macro to compute lengths passed to memcpy and to add to el_size; we must know whether it returns length excluding or including a terminating NUL (and thus whether el_size and the memcpy length are correct and the size checks are correct).\n\n- MHD_str_equal_caseless_bin_n_ and MHD_str_equal_caseless_n_: their prototypes and semantics (particularly whether they read exactly n bytes from the second argument and whether they access beyond n) are required to ensure comparisons do not read past hdr->header or the compile-time string.\n\n- r->flags_auto / r->flags constants (MHD_RAF_* and MHD_RF_INSANITY_*): the control flow depends on these flags (disabling filters and add_close/add_keep_alive). Those affect whether the function will try to insert the extra \"close/Keep-Alive\" text into the buffer and thus affect required buffer space checks.\n\n- The allocator/producer invariants for MHD_HTTP_Res_Header instances: it must be shown that header_size/value_size correctly describe available bytes at hdr->header / hdr->value so that memcpy(src, hdr->header, hdr->header_size) and memcpy(src, hdr->value, hdr->value_size) are safe.\n\n- Caller context (build_header_response): the caller supplies buf, *ppos and buf_size; to prove memcpy destinations are safe we need the caller-side invariants (initial *ppos value, guaranteed buf_size, and whether buf points to at least buf_size bytes). The checks in add_user_headers compare buf_size and *ppos using el_size, but we must know the caller doesn't violate preconditions (e.g., *ppos <= buf_size) and how buf/ppos are used elsewhere.\n\nCollecting these symbols/definitions lets an analyzer (or reviewer) check: (1) memcpy source sizes (header_size/value_size) do not exceed the actual source object lengths; (2) memcpy destination ranges (buf + *ppos .. +length) are validated by the function's comparisons when combined with caller invariants and MHD_STATICSTR_LEN_ semantics; and (3) there are no hidden reads by the equality helpers that would cause out-of-bounds accesses."
}