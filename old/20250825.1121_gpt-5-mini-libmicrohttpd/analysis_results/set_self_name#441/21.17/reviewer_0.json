{
  "user_message": "An agent A claimed that the following set_self_name code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of set_self_name.\n```c\nstatic void\nset_self_name (int argc, char *const *argv)\n{\n  if ((argc >= 1) && (NULL != argv[0]))\n  {\n    const char *last_dir_sep;\n    last_dir_sep = strrchr (argv[0], '/');\n#ifdef _WIN32\n    if (1)\n    {\n      const char *last_w32_dir_sep;\n      last_w32_dir_sep = strrchr (argv[0], '\\\\');\n      if ((NULL == last_dir_sep) ||\n          ((NULL != last_w32_dir_sep) && (last_w32_dir_sep > last_dir_sep)))\n        last_dir_sep = last_w32_dir_sep;\n    }\n#endif /* _WIN32 */\n    if (NULL != last_dir_sep)\n    {\n      size_t name_len;\n      name_len = strlen (last_dir_sep + 1);\n      if ((0 != name_len) && ((sizeof(self_name) / sizeof(char)) > name_len))\n      {\n        strcpy (self_name, last_dir_sep + 1);\n        return;\n      }\n    }\n  }\n  /* Set default name */\n  strcpy (self_name, \"perf_replies\");\n  return;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code relies on sizeof(self_name) to determine the destination capacity. If self_name is not an array (e.g. declared as char *self_name or extern char *self_name) then sizeof(self_name) yields the pointer size, not the actual buffer length; the check ((sizeof(self_name) / sizeof(char)) > name_len) can therefore be incorrect and strcpy(self_name, last_dir_sep + 1) may write past the actual buffer. In that situation the use of strcpy can access beyond the bounds of the destination object, violating MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's report is correct. The code uses sizeof(self_name) to decide whether it is safe to call strcpy(self_name, ...). That check only works if self_name is an array with compile-time size; if self_name is declared as a pointer (e.g. char *self_name or extern char *self_name) sizeof(self_name) yields the size of the pointer, not the size of the destination buffer. In that case the test can be incorrect and strcpy can write beyond the bounds of the object referenced by self_name (including the unconditional strcpy(self_name, \"perf_replies\") at the end), which is exactly what MISRA C 2023 Rule 21.17 forbids. To fix: ensure self_name is an array with known size, or (better) use a bounds-aware copy (e.g. snprintf/strlcpy or memcpy with an explicit length computed from a separately maintained buffer size) and check for room for the terminating NUL. Also avoid relying on sizeof to get buffer capacity when the object may be accessed via a pointer."
}