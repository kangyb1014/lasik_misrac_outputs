{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_rq_uname_type:\n```c\n_MHD_static_inline enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  if (NULL != params->username.value.str)\n  {\n    if (NULL == params->username_ext.value.str)\n      return params->userhash ?\n             MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH :\n             MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    else  /* Both 'username' and 'username*' are used */\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  else if (NULL != params->username_ext.value.str)\n  {\n    if (! params->username_ext.quoted && ! params->userhash &&\n        (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len) )\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_uname_type:\nstruct MHD_RqDAuth\n{\n  struct MHD_RqDAuthParam nonce;\n  struct MHD_RqDAuthParam opaque;\n  struct MHD_RqDAuthParam response;\n  struct MHD_RqDAuthParam username;\n  struct MHD_RqDAuthParam username_ext;\n  struct MHD_RqDAuthParam realm;\n  struct MHD_RqDAuthParam uri;\n  /* The raw QOP value, used in the 'response' calculation */\n  struct MHD_RqDAuthParam qop_raw;\n  struct MHD_RqDAuthParam cnonce;\n  struct MHD_RqDAuthParam nc;\n\n  /* Decoded values are below */\n  bool userhash; /* True if 'userhash' parameter has value 'true'. */\n  enum MHD_DigestAuthAlgo3 algo3;\n  enum MHD_DigestAuthQOP qop;\n}\n...\n#define MHD_DAUTH_EXT_PARAM_MIN_LEN MHD_STATICSTR_LEN_(MHD_DAUTH_EXT_PARAM_PREFIX\"'\")\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nelse if (NULL != params->username_ext.value.str)\n  {\n    if (! params->username_ext.quoted && ! params->userhash &&\n        (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len) )\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. Both branches in the fragment are reachable depending on runtime values. For example: (1) To reach MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED: params->username_ext.value.str != NULL, params->username_ext.quoted == false, params->userhash == false, and params->username_ext.value.len >= MHD_DAUTH_EXT_PARAM_MIN_LEN. (2) To reach MHD_DIGEST_AUTH_UNAME_TYPE_INVALID: params->username_ext.value.str != NULL and either params->username_ext.quoted == true, or params->userhash == true, or params->username_ext.value.len < MHD_DAUTH_EXT_PARAM_MIN_LEN. Therefore there is no unreachable code in the shown fragment."
}