{
  "user_message": "An agent A claimed that the following get_rq_uname_type code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_uname_type.\n```c\n_MHD_static_inline enum MHD_DigestAuthUsernameType\nget_rq_uname_type (const struct MHD_RqDAuth *params)\n{\n  if (NULL != params->username.value.str)\n  {\n    if (NULL == params->username_ext.value.str)\n      return params->userhash ?\n             MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH :\n             MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD;\n    else  /* Both 'username' and 'username*' are used */\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n  else if (NULL != params->username_ext.value.str)\n  {\n    if (! params->username_ext.quoted && ! params->userhash &&\n        (MHD_DAUTH_EXT_PARAM_MIN_LEN <= params->username_ext.value.len) )\n      return MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED;\n    else\n      return MHD_DIGEST_AUTH_UNAME_TYPE_INVALID;\n  }\n\n  return MHD_DIGEST_AUTH_UNAME_TYPE_MISSING;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the member params->username.value.str is declared as a non-const pointer (e.g. char *), this is a violation: the function only reads the pointer (compares it to NULL) so the pointed-to type should be const-qualified (const char *) per MISRA C 2023 Rule 8.13. Change the declaration to const char *value.str to avoid the violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_uname_type:\nstruct MHD_RqDAuth\n{\n  struct MHD_RqDAuthParam nonce;\n  struct MHD_RqDAuthParam opaque;\n  struct MHD_RqDAuthParam response;\n  struct MHD_RqDAuthParam username;\n  struct MHD_RqDAuthParam username_ext;\n  struct MHD_RqDAuthParam realm;\n  struct MHD_RqDAuthParam uri;\n  /* The raw QOP value, used in the 'response' calculation */\n  struct MHD_RqDAuthParam qop_raw;\n  struct MHD_RqDAuthParam cnonce;\n  struct MHD_RqDAuthParam nc;\n\n  /* Decoded values are below */\n  bool userhash; /* True if 'userhash' parameter has value 'true'. */\n  enum MHD_DigestAuthAlgo3 algo3;\n  enum MHD_DigestAuthQOP qop;\n}\n...\n#define MHD_DAUTH_EXT_PARAM_MIN_LEN MHD_STATICSTR_LEN_(MHD_DAUTH_EXT_PARAM_PREFIX\"'\")\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C 2023 Rule 8.13 concerns pointer declarations: a pointer should point to a const-qualified type whenever it is possible to do so. The code shown does not declare the member types (it only reads params->username.value.str and params->username_ext.value.str). Simply reading/NULL-checking a pointer in a function is not itself a violation \u2014 the potential violation would be in the declaration of the struct member (e.g. if value.str is declared as char * but could safely be const char *). Whether that declaration can/should be changed is a project-wide design question (other code might legitimately need a non-const pointer). Thus the report as stated (that get_rq_uname_type violates Rule 8.13) is not correct: the function\u2019s use is read-only, and any Rule 8.13 non\u2011conformance would be located at the declaration site, not in this function. If, after global review, value.str is never used to modify the pointee, then changing the struct member to point to const would satisfy Rule 8.13."
}