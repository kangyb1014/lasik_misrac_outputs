{
  "user_message": "An agent A claimed that the following digest_get_hash_size code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of digest_get_hash_size.\n```c\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n#ifdef MHD_MD5_SUPPORT\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    return MHD_SHA256_DIGEST_SIZE;\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    return MHD_SHA512_256_DIGEST_SIZE;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  return 0; /* Wrong input or unsupported algorithm */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe mhd_assert macro is defined as ((void)0), so the statement mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE); expands to a no-op ((void)0). That no-op is executed but has no effect and could be removed without changing program behaviour, which meets the definition of dead code and thus violates MISRA C 2023 Rule 2.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function digest_get_hash_size:\n#define MHD_MD5_SUPPORT 1\n...\n#define MHD_SHA256_SUPPORT 1\n...\n#define MHD_SHA512_256_SUPPORT 1\n...\n#define MHD_MD5_DIGEST_SIZE 16\n...\n#define MD5_DIGEST_SIZE (MD5_DIGEST_SIZE_WORDS*MD5_BYTES_IN_WORD)\n...\n#define MHD_SHA256_DIGEST_SIZE 32\n...\n#define SHA256_DIGEST_SIZE (SHA256_DIGEST_SIZE_WORDS*SHA256_BYTES_IN_WORD)\n...\n#define MHD_SHA512_256_DIGEST_SIZE 32\n...\n#define SHA512_256_DIGEST_SIZE (SHA512_256_DIGEST_SIZE_WORDS*SHA512_256_BYTES_IN_WORD)\n...\n#define mhd_assert(ignore) ((void)0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct. Although mhd_assert is defined as ((void)0) so each mhd_assert(...) expands to a null expression-statement that performs no observable action in this build, MISRA Rule 2.2 is intended to catch genuine dead code (code whose execution and removal would not affect the intended behaviour). Assertion macros that are intentionally compiled out to ((void)0) are a standard, portable idiom and are not treated as coding errors in the same sense as unreachable/unused code or redundant assignments. In other words, the statements are intentionally no\u2011ops produced by a macro that may be active in other builds; they are not the kind of unintended dead code Rule 2.2 targets. If a project policy requires stricter handling, the assertions can be conditionally omitted at preprocessing or documented via a justified deviation, but the agent A report that this is a Rule 2.2 violation is not correct."
}