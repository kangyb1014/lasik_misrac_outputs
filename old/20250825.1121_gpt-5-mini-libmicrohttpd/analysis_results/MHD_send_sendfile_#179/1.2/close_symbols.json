{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_sendfile_ (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  const int file_fd = connection->rp.response->fd;\n  uint64_t left;\n  uint64_t offsetu64;\n#ifndef HAVE_SENDFILE64\n  const uint64_t max_off_t = (uint64_t) OFF_T_MAX;\n#else  /* HAVE_SENDFILE64 */\n  const uint64_t max_off_t = (uint64_t) OFF64_T_MAX;\n#endif /* HAVE_SENDFILE64 */\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  off_t offset;\n#else  /* HAVE_SENDFILE64 */\n  off64_t offset;\n#endif /* HAVE_SENDFILE64 */\n#endif /* MHD_LINUX_SOLARIS_SENDFILE */\n#ifdef HAVE_FREEBSD_SENDFILE\n  off_t sent_bytes;\n  int flags = 0;\n#endif\n#ifdef HAVE_DARWIN_SENDFILE\n  off_t len;\n#endif /* HAVE_DARWIN_SENDFILE */\n  const bool used_thr_p_c =\n    MHD_D_IS_USING_THREAD_PER_CONN_ (connection->daemon);\n  const size_t chunk_size = used_thr_p_c ? MHD_SENFILE_CHUNK_THR_P_C_ :\n                            MHD_SENFILE_CHUNK_;\n  size_t send_size = 0;\n  bool push_data;\n  mhd_assert (MHD_resp_sender_sendfile == connection->rp.resp_sender);\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  offsetu64 = connection->rp.rsp_write_position\n              + connection->rp.response->fd_off;\n  if (max_off_t < offsetu64)\n  {   /* Retry to send with standard 'send()'. */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n\n  left = connection->rp.response->total_size\n         - connection->rp.rsp_write_position;\n\n  if ( (uint64_t) SSIZE_MAX < left)\n    left = SSIZE_MAX;\n\n  /* Do not allow system to stick sending on single fast connection:\n   * use 128KiB chunks (2MiB for thread-per-connection). */\n  if (chunk_size < left)\n  {\n    send_size = chunk_size;\n    push_data = false; /* No need to push data, there is more to send. */\n  }\n  else\n  {\n    send_size = (size_t) left;\n    push_data = true; /* Final piece of data, need to push to the network. */\n  }\n  pre_send_setopt (connection, false, push_data);\n\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  offset = (off_t) offsetu64;\n  ret = sendfile (connection->socket_fd,\n                  file_fd,\n                  &offset,\n                  send_size);\n#else  /* HAVE_SENDFILE64 */\n  offset = (off64_t) offsetu64;\n  ret = sendfile64 (connection->socket_fd,\n                    file_fd,\n                    &offset,\n                    send_size);\n#endif /* HAVE_SENDFILE64 */\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n#ifdef HAVE_LINUX_SENDFILE\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* sendfile() failed with EINVAL if mmap()-like operations are not\n       supported for FD or other 'unusual' errors occurred, so we should try\n       to fall back to 'SEND'; see also this thread for info on\n       odd libc/Linux behavior with sendfile:\n       http://lists.gnu.org/archive/html/libmicrohttpd/2011-02/msg00015.html */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n#else  /* HAVE_SOLARIS_SENDFILE */\n    if ( (EAFNOSUPPORT == err) ||\n         (EINVAL == err) ||\n         (EOPNOTSUPP == err) )\n    {     /* Retry with standard file reader. */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (ENOTCONN == err) ||\n         (EPIPE == err) )\n    {\n      return MHD_ERR_CONNRESET_;\n    }\n    return MHD_ERR_BADF_;   /* Fail hard */\n#endif /* HAVE_SOLARIS_SENDFILE */\n  }\n#ifdef EPOLL_SUPPORT\n  else if (send_size > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n#elif defined(HAVE_FREEBSD_SENDFILE)\n#ifdef SF_FLAGS\n  flags = used_thr_p_c ?\n          freebsd_sendfile_flags_thd_p_c_ : freebsd_sendfile_flags_;\n#endif /* SF_FLAGS */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     send_size,\n                     NULL,\n                     &sent_bytes,\n                     flags))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err) ||\n        (EBUSY == err) )\n    {\n      mhd_assert (SSIZE_MAX >= sent_bytes);\n      if (0 != sent_bytes)\n        return (ssize_t) sent_bytes;\n\n      return MHD_ERR_AGAIN_;\n    }\n    /* Some unrecoverable error. Possibly file FD is not suitable\n     * for sendfile(). Retry with standard send(). */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n  mhd_assert (0 < sent_bytes);\n  mhd_assert (SSIZE_MAX >= sent_bytes);\n  ret = (ssize_t) sent_bytes;\n#elif defined(HAVE_DARWIN_SENDFILE)\n  len = (off_t) send_size; /* chunk always fit */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     &len,\n                     NULL,\n                     0))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_assert (0 <= len);\n      mhd_assert (SSIZE_MAX >= len);\n      mhd_assert (send_size >= (size_t) len);\n      if (0 != len)\n        return (ssize_t) len;\n\n      return MHD_ERR_AGAIN_;\n    }\n    if ((ENOTCONN == err) ||\n        (EPIPE == err) )\n      return MHD_ERR_CONNRESET_;\n    if ((ENOTSUP == err) ||\n        (EOPNOTSUPP == err) )\n    {     /* This file FD is not suitable for sendfile().\n           * Retry with standard send(). */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    return MHD_ERR_BADF_;   /* Return hard error. */\n  }\n  mhd_assert (0 <= len);\n  mhd_assert (SSIZE_MAX >= len);\n  mhd_assert (send_size >= (size_t) len);\n  ret = (ssize_t) len;\n#endif /* HAVE_FREEBSD_SENDFILE */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* It's unknown whether sendfile() will be used in the next\n   * response so assume that next response will be the same. */\n  if ( (push_data) &&\n       (send_size == (size_t) ret) )\n    post_send_setopt (connection, false, push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_sendfile_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "MHD_SENFILE_CHUNK_THR_P_C_",
    "MHD_SENFILE_CHUNK_",
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_DLOG",
    "MHD_resp_sender_sendfile",
    "MHD_resp_sender_std",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_BADF_",
    "MHD_ERR_CONNRESET_",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EBADF_",
    "OFF_T_MAX",
    "OFF64_T_MAX",
    "off_t",
    "off64_t",
    "sendfile",
    "sendfile64",
    "HAVE_SENDFILE64",
    "HAVE_FREEBSD_SENDFILE",
    "HAVE_DARWIN_SENDFILE",
    "HAVE_LINUX_SENDFILE",
    "HAVE_SOLARIS_SENDFILE",
    "EPOLL_SUPPORT",
    "MHD_EPOLL_STATE_WRITE_READY",
    "freebsd_sendfile_flags_",
    "freebsd_sendfile_flags_thd_p_c_",
    "SF_FLAGS",
    "struct MHD_Connection (fields: rp, response, rsp_write_position, response->fd, response->fd_off, response->total_size, resp_sender, daemon, socket_fd, epoll_state)",
    "MHD_USE_TLS",
    "ssize_t",
    "size_t",
    "uint64_t",
    "SSIZE_MAX",
    "bool"
  ],
  "explanation": "For checking whether the target function uses compiler/language extensions (MISRA rule about language extensions), the analyzer must expand and inspect each symbol that can hide or introduce extensions (macros, inline helpers, alternative types, platform-specific APIs or assertions). Brief reasons: \n\n- mhd_assert: assertion macro often implemented with compiler builtins (e.g. __builtin_unreachable, __assert_fail, __attribute__) \u2014 must inspect expansion for extensions.\n- MHD_D_IS_USING_THREAD_PER_CONN_: macro/function deciding chunk size; may be a macro that uses nonstandard constructs.\n- MHD_SENFILE_CHUNK_THR_P_C_, MHD_SENFILE_CHUNK_: configuration macros \u2014 could be defined via compiler-specific expressions or attributes.\n- pre_send_setopt, post_send_setopt: called functions that themselves may be macros or inline functions using compiler extensions (attributes, builtins); their definitions must be checked.\n- MHD_DLOG: logging macro/function, commonly a variadic macro or wrapper that may use GNU extensions (variadic macro features, __VA_ARGS__, __attribute__, __func__ usage); inspect its definition.\n- MHD_resp_sender_sendfile, MHD_resp_sender_std: enum/constant values or function-pointer markers \u2014 check their declarations for nonstandard attributes.\n- MHD_ERR_AGAIN_, MHD_ERR_BADF_, MHD_ERR_CONNRESET_: error-code macros/types \u2014 could be macros with extensions.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_, MHD_SCKT_EBADF_: socket error helpers/macros \u2014 may hide platform-specific or extension usage (inline functions, macros using GCC builtins).\n- OFF_T_MAX, OFF64_T_MAX: macros controlling use of 64-bit file offsets; their presence changes compile-time branches \u2014 need their definitions to know which code path is active and whether off64_t/related items are nonstandard.\n- off_t, off64_t: system types; off64_t in particular may be a nonstandard (platform-specific) typedef \u2014 inspect to see if vendor extension is used.\n- sendfile, sendfile64: platform-specific system calls; their prototypes or wrappers may use nonstandard attributes or calling conventions.\n- HAVE_SENDFILE64, HAVE_FREEBSD_SENDFILE, HAVE_DARWIN_SENDFILE, HAVE_LINUX_SENDFILE, HAVE_SOLARIS_SENDFILE: configuration macros controlling conditional compilation \u2014 must know which branch is active to inspect only the compiled code for extensions.\n- EPOLL_SUPPORT, MHD_EPOLL_STATE_WRITE_READY: epoll-related macros/types \u2014 epoll usage may pull in nonportable or extension constructs; need their definitions.\n- freebsd_sendfile_flags_, freebsd_sendfile_flags_thd_p_c_, SF_FLAGS: platform-specific flags/macros used in conditional compilation; may be defined using extensions.\n- struct MHD_Connection and its fields used by the function (rp, response, rsp_write_position, response->fd, response->fd_off, response->total_size, resp_sender, daemon, socket_fd, epoll_state): the structure/field types and any annotations/attributes on them (packed, aligned, attribute) can be extension sources; need to inspect definitions.\n- MHD_USE_TLS: option flag macro used in assertions; its definition may involve extension constructs.\n- ssize_t, size_t, uint64_t, SSIZE_MAX, bool: fundamental types/macros \u2014 verify whether they come from standard headers or are redefined using compiler-specific extensions.\n\nCollectively these symbols let the analyzer (a) determine which conditional compilation branches are taken, (b) expand macros to detect any compiler builtins or attributes, and (c) inspect typedefs and function/macro definitions for explicit language extensions. Only by examining these definitions can one reliably report MISRA violations for language-extension usage in the target function."
}