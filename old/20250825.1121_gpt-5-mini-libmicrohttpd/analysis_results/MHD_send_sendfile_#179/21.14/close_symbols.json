{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_sendfile_ (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  const int file_fd = connection->rp.response->fd;\n  uint64_t left;\n  uint64_t offsetu64;\n#ifndef HAVE_SENDFILE64\n  const uint64_t max_off_t = (uint64_t) OFF_T_MAX;\n#else  /* HAVE_SENDFILE64 */\n  const uint64_t max_off_t = (uint64_t) OFF64_T_MAX;\n#endif /* HAVE_SENDFILE64 */\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  off_t offset;\n#else  /* HAVE_SENDFILE64 */\n  off64_t offset;\n#endif /* HAVE_SENDFILE64 */\n#endif /* MHD_LINUX_SOLARIS_SENDFILE */\n#ifdef HAVE_FREEBSD_SENDFILE\n  off_t sent_bytes;\n  int flags = 0;\n#endif\n#ifdef HAVE_DARWIN_SENDFILE\n  off_t len;\n#endif /* HAVE_DARWIN_SENDFILE */\n  const bool used_thr_p_c =\n    MHD_D_IS_USING_THREAD_PER_CONN_ (connection->daemon);\n  const size_t chunk_size = used_thr_p_c ? MHD_SENFILE_CHUNK_THR_P_C_ :\n                            MHD_SENFILE_CHUNK_;\n  size_t send_size = 0;\n  bool push_data;\n  mhd_assert (MHD_resp_sender_sendfile == connection->rp.resp_sender);\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  offsetu64 = connection->rp.rsp_write_position\n              + connection->rp.response->fd_off;\n  if (max_off_t < offsetu64)\n  {   /* Retry to send with standard 'send()'. */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n\n  left = connection->rp.response->total_size\n         - connection->rp.rsp_write_position;\n\n  if ( (uint64_t) SSIZE_MAX < left)\n    left = SSIZE_MAX;\n\n  /* Do not allow system to stick sending on single fast connection:\n   * use 128KiB chunks (2MiB for thread-per-connection). */\n  if (chunk_size < left)\n  {\n    send_size = chunk_size;\n    push_data = false; /* No need to push data, there is more to send. */\n  }\n  else\n  {\n    send_size = (size_t) left;\n    push_data = true; /* Final piece of data, need to push to the network. */\n  }\n  pre_send_setopt (connection, false, push_data);\n\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  offset = (off_t) offsetu64;\n  ret = sendfile (connection->socket_fd,\n                  file_fd,\n                  &offset,\n                  send_size);\n#else  /* HAVE_SENDFILE64 */\n  offset = (off64_t) offsetu64;\n  ret = sendfile64 (connection->socket_fd,\n                    file_fd,\n                    &offset,\n                    send_size);\n#endif /* HAVE_SENDFILE64 */\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n#ifdef HAVE_LINUX_SENDFILE\n    if (MHD_SCKT_ERR_IS_ (err,\n                          MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* sendfile() failed with EINVAL if mmap()-like operations are not\n       supported for FD or other 'unusual' errors occurred, so we should try\n       to fall back to 'SEND'; see also this thread for info on\n       odd libc/Linux behavior with sendfile:\n       http://lists.gnu.org/archive/html/libmicrohttpd/2011-02/msg00015.html */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n#else  /* HAVE_SOLARIS_SENDFILE */\n    if ( (EAFNOSUPPORT == err) ||\n         (EINVAL == err) ||\n         (EOPNOTSUPP == err) )\n    {     /* Retry with standard file reader. */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    if ( (ENOTCONN == err) ||\n         (EPIPE == err) )\n    {\n      return MHD_ERR_CONNRESET_;\n    }\n    return MHD_ERR_BADF_;   /* Fail hard */\n#endif /* HAVE_SOLARIS_SENDFILE */\n  }\n#ifdef EPOLL_SUPPORT\n  else if (send_size > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n#elif defined(HAVE_FREEBSD_SENDFILE)\n#ifdef SF_FLAGS\n  flags = used_thr_p_c ?\n          freebsd_sendfile_flags_thd_p_c_ : freebsd_sendfile_flags_;\n#endif /* SF_FLAGS */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     send_size,\n                     NULL,\n                     &sent_bytes,\n                     flags))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err) ||\n        (EBUSY == err) )\n    {\n      mhd_assert (SSIZE_MAX >= sent_bytes);\n      if (0 != sent_bytes)\n        return (ssize_t) sent_bytes;\n\n      return MHD_ERR_AGAIN_;\n    }\n    /* Some unrecoverable error. Possibly file FD is not suitable\n     * for sendfile(). Retry with standard send(). */\n    connection->rp.resp_sender = MHD_resp_sender_std;\n    return MHD_ERR_AGAIN_;\n  }\n  mhd_assert (0 < sent_bytes);\n  mhd_assert (SSIZE_MAX >= sent_bytes);\n  ret = (ssize_t) sent_bytes;\n#elif defined(HAVE_DARWIN_SENDFILE)\n  len = (off_t) send_size; /* chunk always fit */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     &len,\n                     NULL,\n                     0))\n  {\n    const int err = MHD_socket_get_error_ ();\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err) ||\n        MHD_SCKT_ERR_IS_EINTR_ (err))\n    {\n      mhd_assert (0 <= len);\n      mhd_assert (SSIZE_MAX >= len);\n      mhd_assert (send_size >= (size_t) len);\n      if (0 != len)\n        return (ssize_t) len;\n\n      return MHD_ERR_AGAIN_;\n    }\n    if ((ENOTCONN == err) ||\n        (EPIPE == err) )\n      return MHD_ERR_CONNRESET_;\n    if ((ENOTSUP == err) ||\n        (EOPNOTSUPP == err) )\n    {     /* This file FD is not suitable for sendfile().\n           * Retry with standard send(). */\n      connection->rp.resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n    return MHD_ERR_BADF_;   /* Return hard error. */\n  }\n  mhd_assert (0 <= len);\n  mhd_assert (SSIZE_MAX >= len);\n  mhd_assert (send_size >= (size_t) len);\n  ret = (ssize_t) len;\n#endif /* HAVE_FREEBSD_SENDFILE */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  /* It's unknown whether sendfile() will be used in the next\n   * response so assume that next response will be the same. */\n  if ( (push_data) &&\n       (send_size == (size_t) ret) )\n    post_send_setopt (connection, false, push_data);\n\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_sendfile_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_DLOG",
    "memcmp"
  ],
  "explanation": "To determine whether MHD_send_sendfile_ (directly or indirectly) uses the Standard Library function memcmp to compare null-terminated strings, the analysis must inspect the implementations of all callees that could contain such uses and memcmp itself:\n\n- pre_send_setopt: This function is called by MHD_send_sendfile_. If pre_send_setopt contains any calls to memcmp (or to a wrapper that uses memcmp) the MISRA rule could be violated indirectly. We must inspect its body to find any memcmp usage and check the argument types/semantics (are they null-terminated strings?).\n\n- post_send_setopt: Likewise called by MHD_send_sendfile_. post_send_setopt might call memcmp or a wrapper, so its implementation must be checked for memcmp usage and whether the compared objects are null-terminated strings.\n\n- MHD_DLOG: post_send_setopt calls MHD_DLOG (per the call graph). If MHD_DLOG (or functions it calls) uses memcmp to compare strings, that would also constitute an indirect violation; therefore MHD_DLOG\u2019s implementation must be inspected.\n\n- memcmp: The actual Standard Library symbol must be considered so that any call sites found in the above functions can be recognized as calls to memcmp (or to wrappers that map to it). When a memcmp call is found, its argument types and how they are produced must be examined to decide whether it is being used to compare null-terminated strings (the MISRA violation)."
}