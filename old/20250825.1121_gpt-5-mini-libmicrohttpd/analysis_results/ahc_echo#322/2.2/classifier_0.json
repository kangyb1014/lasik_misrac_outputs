{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  const char *val;\n  char *me;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int resp_len;\n  size_t buf_size;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;  /* reset when done */\n  val = MHD_lookup_connection_value (connection, MHD_GET_ARGUMENT_KIND, \"q\");\n  if (NULL == val)\n    return MHD_NO;  /* No \"q\" argument was found */\n  resp_len = snprintf (NULL, 0, PAGE, \"q\", val);\n  if (0 >= resp_len)\n    return MHD_NO;  /* Error calculating response size */\n  buf_size = (size_t) resp_len + 1; /* Add one byte for zero-termination */\n  me = malloc (buf_size);\n  if (me == NULL)\n    return MHD_NO;  /* Error allocating memory */\n  if (resp_len != snprintf (me, buf_size, PAGE, \"q\", val))\n  {\n    free (me);\n    return MHD_NO;  /* Error forming the response body */\n  }\n  response =\n    MHD_create_response_from_buffer_with_free_callback (buf_size - 1,\n                                                        (void *) me,\n                                                        &free);\n  if (response == NULL)\n  {\n    free (me);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_echo:\n_MHD_EXTERN const char *\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)\n{\n  const char *value;\n\n  value = NULL;\n  (void) MHD_lookup_connection_value_n (connection,\n                                        kind,\n                                        key,\n                                        (NULL == key) ? 0 : strlen (key),\n                                        &value,\n                                        NULL);\n  return value;\n}\n...\n#define PAGE \"<html><head><title>libmicrohttpd demo</title></head><body>Query string for &quot;%s&quot; was &quot;%s&quot;</body></html>\"\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    MHD_ContentReaderFreeCallback\n                                                    crfc)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 crfc,\n                                                                 buffer);\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\n#define MHD_HTTP_OK 200\n...\nstruct MHD_Response\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic int aptr;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The local static object 'aptr' is used via its address (comparison &aptr and storing its address in *req_cls) to detect the first invocation of ahc_echo. Removing the declaration would change program behaviour (the &aptr reference would be invalid and the first-call detection would fail), so this is not dead code. (If, conversely, the static variable were never referenced anywhere in the project, then the declaration would be dead code and would violate Rule 2.2.)"
}