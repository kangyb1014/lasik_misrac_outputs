{
  "user_message": "Target function code is:\n```c\nenum MHD_Result\nMHD_response_execute_upgrade_ (struct MHD_Response *response,\n                               struct MHD_Connection *connection)\n{\n#if defined(HTTPS_SUPPORT) || defined(_DEBUG) || defined(HAVE_MESSAGES)\n  struct MHD_Daemon *const daemon = connection->daemon;\n#endif /* HTTPS_SUPPORT || _DEBUG || HAVE_MESSAGES */\n  struct MHD_UpgradeResponseHandle *urh;\n  size_t rbo;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n\n  /* \"Upgrade\" responses accepted only if MHD_ALLOW_UPGRADE is enabled */\n  mhd_assert (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n  /* The header was checked when response queued */\n  mhd_assert (NULL != \\\n              MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                           MHD_HTTP_HEADER_UPGRADE,\n                                           MHD_STATICSTR_LEN_ ( \\\n                                             MHD_HTTP_HEADER_UPGRADE)));\n\n  if (! connection->sk_nonblck)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Cannot execute \\\"upgrade\\\" as the socket is in \" \\\n                 \"the blocking mode.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  urh = MHD_calloc_ (1, sizeof (struct MHD_UpgradeResponseHandle));\n  if (NULL == urh)\n    return MHD_NO;\n  urh->connection = connection;\n  rbo = connection->read_buffer_offset;\n  connection->read_buffer_offset = 0;\n  MHD_connection_set_nodelay_state_ (connection, false);\n  MHD_connection_set_cork_state_ (connection, false);\n#ifdef HTTPS_SUPPORT\n  if (0 != (daemon->options & MHD_USE_TLS) )\n  {\n    MHD_socket sv[2];\n#if defined(MHD_socket_nosignal_) || ! defined(MHD_socket_pair_nblk_)\n    int res1;\n    int res2;\n#endif /* MHD_socket_nosignal_ || !MHD_socket_pair_nblk_ */\n\n#ifdef MHD_socket_pair_nblk_\n    if (! MHD_socket_pair_nblk_ (sv))\n    {\n      free (urh);\n      return MHD_NO;\n    }\n#else  /* !MHD_socket_pair_nblk_ */\n    if (! MHD_socket_pair_ (sv))\n    {\n      free (urh);\n      return MHD_NO;\n    }\n    res1 = MHD_socket_nonblocking_ (sv[0]);\n    res2 = MHD_socket_nonblocking_ (sv[1]);\n    if ( (! res1) || (! res2) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to make loopback sockets non-blocking.\\n\"));\n#endif\n      if (! res2)\n      {\n        /* Socketpair cannot be used. */\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n    }\n#endif /* !MHD_socket_pair_nblk_ */\n#ifdef MHD_socket_nosignal_\n    res1 = MHD_socket_nosignal_ (sv[0]);\n    res2 = MHD_socket_nosignal_ (sv[1]);\n    if ( (! res1) || (! res2) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set SO_NOSIGPIPE on loopback sockets.\\n\"));\n#endif\n#ifndef MSG_NOSIGNAL\n      if (! res2)\n      {\n        /* Socketpair cannot be used. */\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n#endif /* ! MSG_NOSIGNAL */\n    }\n#endif /* MHD_socket_nosignal_ */\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (sv[1], daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Socketpair descriptor is not less than FD_SETSIZE: \" \\\n                   \"%d >= %d\\n\"),\n                (int) sv[1],\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (sv[0]);\n      MHD_socket_close_chk_ (sv[1]);\n      free (urh);\n      return MHD_NO;\n    }\n    urh->app.socket = sv[0];\n    urh->app.urh = urh;\n    urh->app.celi = MHD_EPOLL_STATE_UNREADY;\n    urh->mhd.socket = sv[1];\n    urh->mhd.urh = urh;\n    urh->mhd.celi = MHD_EPOLL_STATE_UNREADY;\n#ifdef EPOLL_SUPPORT\n    /* Launch IO processing by the event loop */\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      /* We're running with epoll(), need to add the sockets\n         to the event set of the daemon's `epoll_upgrade_fd` */\n      struct epoll_event event;\n\n      mhd_assert (-1 != daemon->epoll_upgrade_fd);\n      /* First, add network socket */\n      event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n      event.data.ptr = &urh->app;\n      if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                          EPOLL_CTL_ADD,\n                          connection->socket_fd,\n                          &event))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Call to epoll_ctl failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n\n      /* Second, add our end of the UNIX socketpair() */\n      event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n      event.data.ptr = &urh->mhd;\n      if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                          EPOLL_CTL_ADD,\n                          urh->mhd.socket,\n                          &event))\n      {\n        event.events = EPOLLIN | EPOLLOUT | EPOLLPRI;\n        event.data.ptr = &urh->app;\n        if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                            EPOLL_CTL_DEL,\n                            connection->socket_fd,\n                            &event))\n          MHD_PANIC (_ (\"Error cleaning up while handling epoll error.\\n\"));\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Call to epoll_ctl failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n      EDLL_insert (daemon->eready_urh_head,\n                   daemon->eready_urh_tail,\n                   urh);\n      urh->in_eready_list = true;\n    }\n#endif /* EPOLL_SUPPORT */\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n      /* This takes care of further processing for most event loops:\n         simply add to DLL for bi-direcitonal processing */\n      DLL_insert (daemon->urh_head,\n                  daemon->urh_tail,\n                  urh);\n    }\n    /* In thread-per-connection mode, thread will switch to forwarding once\n     * connection.urh is not NULL and connection.state == MHD_CONNECTION_UPGRADE.\n     */\n  }\n  else\n  {\n    urh->app.socket = MHD_INVALID_SOCKET;\n    urh->mhd.socket = MHD_INVALID_SOCKET;\n    /* Non-TLS connection do not hold any additional resources. */\n    urh->clean_ready = true;\n  }\n#else  /* ! HTTPS_SUPPORT */\n  urh->clean_ready = true;\n#endif /* ! HTTPS_SUPPORT */\n  connection->urh = urh;\n  /* As far as MHD's event loops are concerned, this connection is\n     suspended; it will be resumed once application is done by the\n     #MHD_upgrade_action() function */\n  internal_suspend_connection_ (connection);\n\n  /* hand over socket to application */\n  response->upgrade_handler (response->upgrade_handler_cls,\n                             connection,\n                             connection->rq.client_context,\n                             connection->read_buffer,\n                             rbo,\n#ifdef HTTPS_SUPPORT\n                             (0 == (daemon->options & MHD_USE_TLS) ) ?\n                             connection->socket_fd : urh->app.socket,\n#else  /* ! HTTPS_SUPPORT */\n                             connection->socket_fd,\n#endif /* ! HTTPS_SUPPORT */\n                             urh);\n\n#ifdef HTTPS_SUPPORT\n  if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    struct MemoryPool *const pool = connection->pool;\n    size_t avail;\n    char *buf;\n\n    /* All data should be sent already */\n    mhd_assert (connection->write_buffer_send_offset == \\\n                connection->write_buffer_append_offset);\n    MHD_pool_deallocate (pool, connection->write_buffer,\n                         connection->write_buffer_size);\n    connection->write_buffer_append_offset = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_size = 0;\n    connection->write_buffer = NULL;\n\n    /* Extra read data should be processed already by the application */\n    MHD_pool_deallocate (pool, connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer_offset = 0;\n    connection->read_buffer_size = 0;\n    connection->read_buffer = NULL;\n\n    avail = MHD_pool_get_free (pool);\n    if (avail < RESERVE_EBUF_SIZE)\n    {\n      /* connection's pool is totally at the limit,\n         use our 'emergency' buffer of #RESERVE_EBUF_SIZE bytes. */\n      avail = RESERVE_EBUF_SIZE;\n      buf = urh->e_buf;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Memory shortage in connection's memory pool. \" \\\n                   \"The \\\"upgraded\\\" communication will be inefficient.\\n\"));\n#endif\n    }\n    else\n    {\n      /* Normal case: grab all remaining memory from the\n         connection's pool for the IO buffers; the connection\n         certainly won't need it anymore as we've upgraded\n         to another protocol. */\n      buf = MHD_pool_allocate (pool,\n                               avail,\n                               false);\n    }\n    /* use half the buffer for inbound, half for outbound */\n    urh->in_buffer_size = avail / 2;\n    urh->out_buffer_size = avail - urh->in_buffer_size;\n    urh->in_buffer = buf;\n    urh->out_buffer = buf + urh->in_buffer_size;\n  }\n#endif /* HTTPS_SUPPORT */\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_response_execute_upgrade_': {'callees': ['MHD_DLOG', 'internal_suspend_connection_'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'internal_suspend_connection_': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_suspend_connection', 'MHD_response_execute_upgrade_']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Response (definition)",
    "upgrade handler function pointer type / prototype (type of response->upgrade_handler)",
    "type of response->upgrade_handler_cls (its typedef)",
    "struct MHD_Connection (definition)",
    "type/struct of connection->rq and type of connection->rq.client_context",
    "struct MHD_Daemon (definition)",
    "struct MHD_UpgradeResponseHandle (definition)",
    "definition of urh->app and urh->mhd sub-structures (types of .socket, .urh, .celi)",
    "RESERVE_EBUF_SIZE (macro)",
    "struct MemoryPool (definition)",
    "MHD_pool_allocate prototype",
    "MHD_pool_deallocate prototype",
    "MHD_pool_get_free prototype",
    "MHD_get_response_element_n_ prototype and MHD_HTTP_HEADER_UPGRADE (header/name argument)",
    "MHD_calloc_ prototype",
    "MHD_socket type and MHD_INVALID_SOCKET macro",
    "prototypes for MHD_connection_set_nodelay_state_ and MHD_connection_set_cork_state_",
    "internal_suspend_connection_ prototype"
  ],
  "explanation": "To judge whether any pointer in MHD_response_execute_upgrade_ should be const-qualified (MISRA rule: pointer should point to const-qualified type whenever possible) the next analyzer must see the actual declarations and prototypes so it can tell (a) whether pointers are modified through these variables, (b) whether the pointed-to objects are intended to be mutable, and (c) whether the function is passing pointers to APIs that expect non-const. For that reason each listed symbol is required:\n\n- struct MHD_Response (definition): exposes the types of fields used in the function (notably response->upgrade_handler and response->upgrade_handler_cls). You must know whether those fields are declared as pointer-to-const or pointer-to-non-const.\n\n- upgrade handler function pointer type / prototype (type of response->upgrade_handler): the signature of the upgrade callback determines the constness required for parameters such as the buffer pointer, client context and socket argument. If the prototype declares const for buffer parameters, the function must respect that; if not, it may legally accept non-const.\n\n- type of response->upgrade_handler_cls: the concrete type of the class/context pointer passed to the upgrade handler is needed to see whether it should be const-qualified.\n\n- struct MHD_Connection (definition): this reveals types of many pointers used here (connection->read_buffer, connection->write_buffer, connection->pool, connection->daemon, connection->rq, connection->rq.client_context, connection->urh, connection->tid, etc.). Knowing those declarations is essential to decide whether any of those pointees could/should be const.\n\n- type/struct of connection->rq and type of connection->rq.client_context: client_context is forwarded to the application; its declared type determines whether it should be const-qualified when passed.\n\n- struct MHD_Daemon (definition): the local variable daemon is a pointer to this type. To decide whether it should be pointer-to-const we need to know whether fields of daemon are modified later (or by called helpers) and how daemon is declared elsewhere.\n\n- struct MHD_UpgradeResponseHandle (definition): the function allocates and initializes many fields of urh (in_buffer, out_buffer, e_buf, clean_ready, in_eready_list, etc.). Knowing the field types lets us determine whether any assigned pointer should have been declared const (for example, urh->in_buffer/out_buffer types and e_buf element type).\n\n- definition of urh->app and urh->mhd sub-structures: these contain socket, urh pointer and celi fields. You must know the urh pointer types (and whether they are declared const) to analyze pointer const-correctness where self-references occur.\n\n- RESERVE_EBUF_SIZE (macro): used to select urh->e_buf when pool lacks space; determining the type/size of e_buf (and whether it is char[] or const char[]) matters for const qualification of in/out buffers.\n\n- struct MemoryPool (definition) and MHD_pool_allocate / MHD_pool_deallocate / MHD_pool_get_free prototypes: these routines allocate and free buffers; their return types (char *, void *, const void *) determine whether buffers provided to urh->in_buffer/out_buffer are const-qualified or not and whether they are mutable.\n\n- MHD_get_response_element_n_ prototype and MHD_HTTP_HEADER_UPGRADE: the call to MHD_get_response_element_n_ checks for the Upgrade header using a header name constant; the prototype will show whether the header name parameter is const char * (and whether MHD_get_response_element_n_ promises not to modify it). This affects whether header-name constants should be const.\n\n- MHD_calloc_ prototype: the allocation function return type (void *, char *) matters for assignment to urh and whether the allocated memory is mutable.\n\n- MHD_socket type and MHD_INVALID_SOCKET macro: urh->app.socket and urh->mhd.socket are assigned socket values. The socket type and whether it is pointer or integer influences constness decisions for socket-related members.\n\n- prototypes for MHD_connection_set_nodelay_state_ and MHD_connection_set_cork_state_: these are called with connection pointer; knowing whether those APIs accept const pointers or modify the connection object helps to decide if connection should be pointer-to-const.\n\n- internal_suspend_connection_ prototype: this function is called with connection; its prototype shows whether it mutates the connection (thus preventing connection being const) and is necessary to determine if connection should be const-qualified.\n\nIn short: to decide whether any pointer declarations in this function (parameters, local alias 'daemon', fields of connection and urh, and the upgrade handler parameters) should be const-qualified, the analyzer must see the actual type and prototype declarations for the structures and functions that govern how those pointers are used and whether their pointees are modified."
}