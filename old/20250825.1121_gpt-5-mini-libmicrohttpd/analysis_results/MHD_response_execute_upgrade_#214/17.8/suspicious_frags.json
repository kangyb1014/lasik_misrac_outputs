{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_response_execute_upgrade_:\n```c\nenum MHD_Result\nMHD_response_execute_upgrade_ (struct MHD_Response *response,\n                               struct MHD_Connection *connection)\n{\n#if defined(HTTPS_SUPPORT) || defined(_DEBUG) || defined(HAVE_MESSAGES)\n  struct MHD_Daemon *const daemon = connection->daemon;\n#endif /* HTTPS_SUPPORT || _DEBUG || HAVE_MESSAGES */\n  struct MHD_UpgradeResponseHandle *urh;\n  size_t rbo;\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n\n  /* \"Upgrade\" responses accepted only if MHD_ALLOW_UPGRADE is enabled */\n  mhd_assert (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n  /* The header was checked when response queued */\n  mhd_assert (NULL != \\\n              MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                           MHD_HTTP_HEADER_UPGRADE,\n                                           MHD_STATICSTR_LEN_ ( \\\n                                             MHD_HTTP_HEADER_UPGRADE)));\n\n  if (! connection->sk_nonblck)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Cannot execute \\\"upgrade\\\" as the socket is in \" \\\n                 \"the blocking mode.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  urh = MHD_calloc_ (1, sizeof (struct MHD_UpgradeResponseHandle));\n  if (NULL == urh)\n    return MHD_NO;\n  urh->connection = connection;\n  rbo = connection->read_buffer_offset;\n  connection->read_buffer_offset = 0;\n  MHD_connection_set_nodelay_state_ (connection, false);\n  MHD_connection_set_cork_state_ (connection, false);\n#ifdef HTTPS_SUPPORT\n  if (0 != (daemon->options & MHD_USE_TLS) )\n  {\n    MHD_socket sv[2];\n#if defined(MHD_socket_nosignal_) || ! defined(MHD_socket_pair_nblk_)\n    int res1;\n    int res2;\n#endif /* MHD_socket_nosignal_ || !MHD_socket_pair_nblk_ */\n\n#ifdef MHD_socket_pair_nblk_\n    if (! MHD_socket_pair_nblk_ (sv))\n    {\n      free (urh);\n      return MHD_NO;\n    }\n#else  /* !MHD_socket_pair_nblk_ */\n    if (! MHD_socket_pair_ (sv))\n    {\n      free (urh);\n      return MHD_NO;\n    }\n    res1 = MHD_socket_nonblocking_ (sv[0]);\n    res2 = MHD_socket_nonblocking_ (sv[1]);\n    if ( (! res1) || (! res2) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to make loopback sockets non-blocking.\\n\"));\n#endif\n      if (! res2)\n      {\n        /* Socketpair cannot be used. */\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n    }\n#endif /* !MHD_socket_pair_nblk_ */\n#ifdef MHD_socket_nosignal_\n    res1 = MHD_socket_nosignal_ (sv[0]);\n    res2 = MHD_socket_nosignal_ (sv[1]);\n    if ( (! res1) || (! res2) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to set SO_NOSIGPIPE on loopback sockets.\\n\"));\n#endif\n#ifndef MSG_NOSIGNAL\n      if (! res2)\n      {\n        /* Socketpair cannot be used. */\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n#endif /* ! MSG_NOSIGNAL */\n    }\n#endif /* MHD_socket_nosignal_ */\n    if (MHD_D_IS_USING_SELECT_ (daemon) &&\n        (! MHD_D_DOES_SCKT_FIT_FDSET_ (sv[1], daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Socketpair descriptor is not less than FD_SETSIZE: \" \\\n                   \"%d >= %d\\n\"),\n                (int) sv[1],\n                (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n      MHD_socket_close_chk_ (sv[0]);\n      MHD_socket_close_chk_ (sv[1]);\n      free (urh);\n      return MHD_NO;\n    }\n    urh->app.socket = sv[0];\n    urh->app.urh = urh;\n    urh->app.celi = MHD_EPOLL_STATE_UNREADY;\n    urh->mhd.socket = sv[1];\n    urh->mhd.urh = urh;\n    urh->mhd.celi = MHD_EPOLL_STATE_UNREADY;\n#ifdef EPOLL_SUPPORT\n    /* Launch IO processing by the event loop */\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      /* We're running with epoll(), need to add the sockets\n         to the event set of the daemon's `epoll_upgrade_fd` */\n      struct epoll_event event;\n\n      mhd_assert (-1 != daemon->epoll_upgrade_fd);\n      /* First, add network socket */\n      event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n      event.data.ptr = &urh->app;\n      if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                          EPOLL_CTL_ADD,\n                          connection->socket_fd,\n                          &event))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Call to epoll_ctl failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n\n      /* Second, add our end of the UNIX socketpair() */\n      event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n      event.data.ptr = &urh->mhd;\n      if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                          EPOLL_CTL_ADD,\n                          urh->mhd.socket,\n                          &event))\n      {\n        event.events = EPOLLIN | EPOLLOUT | EPOLLPRI;\n        event.data.ptr = &urh->app;\n        if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                            EPOLL_CTL_DEL,\n                            connection->socket_fd,\n                            &event))\n          MHD_PANIC (_ (\"Error cleaning up while handling epoll error.\\n\"));\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Call to epoll_ctl failed: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n      EDLL_insert (daemon->eready_urh_head,\n                   daemon->eready_urh_tail,\n                   urh);\n      urh->in_eready_list = true;\n    }\n#endif /* EPOLL_SUPPORT */\n    if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    {\n      /* This takes care of further processing for most event loops:\n         simply add to DLL for bi-direcitonal processing */\n      DLL_insert (daemon->urh_head,\n                  daemon->urh_tail,\n                  urh);\n    }\n    /* In thread-per-connection mode, thread will switch to forwarding once\n     * connection.urh is not NULL and connection.state == MHD_CONNECTION_UPGRADE.\n     */\n  }\n  else\n  {\n    urh->app.socket = MHD_INVALID_SOCKET;\n    urh->mhd.socket = MHD_INVALID_SOCKET;\n    /* Non-TLS connection do not hold any additional resources. */\n    urh->clean_ready = true;\n  }\n#else  /* ! HTTPS_SUPPORT */\n  urh->clean_ready = true;\n#endif /* ! HTTPS_SUPPORT */\n  connection->urh = urh;\n  /* As far as MHD's event loops are concerned, this connection is\n     suspended; it will be resumed once application is done by the\n     #MHD_upgrade_action() function */\n  internal_suspend_connection_ (connection);\n\n  /* hand over socket to application */\n  response->upgrade_handler (response->upgrade_handler_cls,\n                             connection,\n                             connection->rq.client_context,\n                             connection->read_buffer,\n                             rbo,\n#ifdef HTTPS_SUPPORT\n                             (0 == (daemon->options & MHD_USE_TLS) ) ?\n                             connection->socket_fd : urh->app.socket,\n#else  /* ! HTTPS_SUPPORT */\n                             connection->socket_fd,\n#endif /* ! HTTPS_SUPPORT */\n                             urh);\n\n#ifdef HTTPS_SUPPORT\n  if (0 != (daemon->options & MHD_USE_TLS))\n  {\n    struct MemoryPool *const pool = connection->pool;\n    size_t avail;\n    char *buf;\n\n    /* All data should be sent already */\n    mhd_assert (connection->write_buffer_send_offset == \\\n                connection->write_buffer_append_offset);\n    MHD_pool_deallocate (pool, connection->write_buffer,\n                         connection->write_buffer_size);\n    connection->write_buffer_append_offset = 0;\n    connection->write_buffer_send_offset = 0;\n    connection->write_buffer_size = 0;\n    connection->write_buffer = NULL;\n\n    /* Extra read data should be processed already by the application */\n    MHD_pool_deallocate (pool, connection->read_buffer,\n                         connection->read_buffer_size);\n    connection->read_buffer_offset = 0;\n    connection->read_buffer_size = 0;\n    connection->read_buffer = NULL;\n\n    avail = MHD_pool_get_free (pool);\n    if (avail < RESERVE_EBUF_SIZE)\n    {\n      /* connection's pool is totally at the limit,\n         use our 'emergency' buffer of #RESERVE_EBUF_SIZE bytes. */\n      avail = RESERVE_EBUF_SIZE;\n      buf = urh->e_buf;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Memory shortage in connection's memory pool. \" \\\n                   \"The \\\"upgraded\\\" communication will be inefficient.\\n\"));\n#endif\n    }\n    else\n    {\n      /* Normal case: grab all remaining memory from the\n         connection's pool for the IO buffers; the connection\n         certainly won't need it anymore as we've upgraded\n         to another protocol. */\n      buf = MHD_pool_allocate (pool,\n                               avail,\n                               false);\n    }\n    /* use half the buffer for inbound, half for outbound */\n    urh->in_buffer_size = avail / 2;\n    urh->out_buffer_size = avail - urh->in_buffer_size;\n    urh->in_buffer = buf;\n    urh->out_buffer = buf + urh->in_buffer_size;\n  }\n#endif /* HTTPS_SUPPORT */\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_response_execute_upgrade_:\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct MHD_UpgradeResponseHandle\n{\n  /**\n   * The connection for which this is an upgrade handle.  Note that\n   * because a response may be shared over many connections, this may\n   * not be the only upgrade handle for the response of this connection.\n   */\n  struct MHD_Connection *connection;\n\n#ifdef HTTPS_SUPPORT\n  /**\n   * Kept in a DLL per daemon.\n   */\n  struct MHD_UpgradeResponseHandle *next;\n\n  /**\n   * Kept in a DLL per daemon.\n   */\n  struct MHD_UpgradeResponseHandle *prev;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing urhs that are epoll-ready.\n   */\n  struct MHD_UpgradeResponseHandle *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing urhs that are epoll-ready.\n   */\n  struct MHD_UpgradeResponseHandle *prevE;\n\n  /**\n   * Specifies whether urh already in EDLL list of ready connections.\n   */\n  bool in_eready_list;\n#endif\n\n  /**\n   * The buffer for receiving data from TLS to\n   * be passed to the application.  Contains @e in_buffer_size\n   * bytes (unless @e in_buffer_size is zero). Do not free!\n   */\n  char *in_buffer;\n\n  /**\n   * The buffer for receiving data from the application to\n   * be passed to TLS.  Contains @e out_buffer_size\n   * bytes (unless @e out_buffer_size is zero). Do not free!\n   */\n  char *out_buffer;\n\n  /**\n   * Size of the @e in_buffer.\n   * Set to 0 if the TLS connection went down for reading or socketpair\n   * went down for writing.\n   */\n  size_t in_buffer_size;\n\n  /**\n   * Size of the @e out_buffer.\n   * Set to 0 if the TLS connection went down for writing or socketpair\n   * went down for reading.\n   */\n  size_t out_buffer_size;\n\n  /**\n   * Number of bytes actually in use in the @e in_buffer.  Can be larger\n   * than @e in_buffer_size if and only if @a in_buffer_size is zero and\n   * we still have bytes that can be forwarded.\n   * Reset to zero if all data was forwarded to socketpair or\n   * if socketpair went down for writing.\n   */\n  size_t in_buffer_used;\n\n  /**\n   * Number of bytes actually in use in the @e out_buffer. Can be larger\n   * than @e out_buffer_size if and only if @a out_buffer_size is zero and\n   * we still have bytes that can be forwarded.\n   * Reset to zero if all data was forwarded to TLS connection or\n   * if TLS connection went down for writing.\n   */\n  size_t out_buffer_used;\n\n  /**\n   * The socket we gave to the application (r/w).\n   */\n  struct UpgradeEpollHandle app;\n\n  /**\n   * If @a app_sock was a socketpair, our end of it, otherwise\n   * #MHD_INVALID_SOCKET; (r/w).\n   */\n  struct UpgradeEpollHandle mhd;\n\n  /**\n   * Emergency IO buffer we use in case the memory pool has literally\n   * nothing left.\n   */\n  char e_buf[RESERVE_EBUF_SIZE];\n\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Set to true after the application finished with the socket\n   * by #MHD_UPGRADE_ACTION_CLOSE.\n   *\n   * When BOTH @e was_closed (changed by command from application)\n   * AND @e clean_ready (changed internally by MHD) are set to\n   * #MHD_YES, function #MHD_resume_connection() will move this\n   * connection to cleanup list.\n   * @remark This flag could be changed from any thread.\n   */\n  volatile bool was_closed;\n\n  /**\n   * Set to true if connection is ready for cleanup.\n   *\n   * In TLS mode functions #MHD_connection_finish_forward_() must\n   * be called before setting this flag to true.\n   *\n   * In thread-per-connection mode, true in this flag means\n   * that connection's thread exited or about to exit and will\n   * not use MHD_Connection::urh data anymore.\n   *\n   * In any mode true in this flag also means that\n   * MHD_Connection::urh data will not be used for socketpair\n   * forwarding and forwarding itself is finished.\n   *\n   * When BOTH @e was_closed (changed by command from application)\n   * AND @e clean_ready (changed internally by MHD) are set to\n   * true, function #MHD_resume_connection() will move this\n   * connection to cleanup list.\n   * @remark This flag could be changed from thread that process\n   * connection's recv(), send() and response.\n   */\n  volatile bool clean_ready;\n}\n...\nvoid\ninternal_suspend_connection_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  mhd_assert (NULL == daemon->worker_pool);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if (connection->resuming)\n  {\n    /* suspending again while we didn't even complete resuming yet */\n    connection->resuming = false;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    return;\n  }\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n    if (connection->connection_timeout_ms == daemon->connection_timeout_ms)\n      XDLL_remove (daemon->normal_timeout_head,\n                   daemon->normal_timeout_tail,\n                   connection);\n    else\n      XDLL_remove (daemon->manual_timeout_head,\n                   daemon->manual_timeout_tail,\n                   connection);\n  }\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              connection);\n  mhd_assert (! connection->suspended);\n  DLL_insert (daemon->suspended_connections_head,\n              daemon->suspended_connections_tail,\n              connection);\n  connection->suspended = true;\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon))\n  {\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n    {\n      EDLL_remove (daemon->eready_head,\n                   daemon->eready_tail,\n                   connection);\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n    }\n    if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET))\n    {\n      if (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          connection->socket_fd,\n                          NULL))\n        MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EPOLL_SET);\n    }\n    connection->epoll_state |= MHD_EPOLL_STATE_SUSPENDED;\n  }\n#endif\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nbool\nMHD_connection_set_nodelay_state_ (struct MHD_Connection *connection,\n                                   bool nodelay_state)\n{\n#ifdef TCP_NODELAY\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) (nodelay_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_nodelay = nodelay_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n                \"TCP_NODELAY\",\n                nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n              \"TCP_NODELAY\",\n              nodelay_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! TCP_NODELAY */\n  (void) connection; (void) nodelay_state; /* Mute compiler warnings */\n#endif /* ! TCP_NODELAY */\n  return false;\n}\n...\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n...\nstruct MHD_HTTP_Res_Header *\nMHD_get_response_element_n_ (struct MHD_Response *response,\n                             enum MHD_ValueKind kind,\n                             const char *key,\n                             size_t key_len)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  mhd_assert (NULL != key);\n  mhd_assert (0 != key[0]);\n  mhd_assert (0 != key_len);\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n  {\n    if ((pos->header_size == key_len) &&\n        (kind == pos->kind) &&\n        (MHD_str_equal_caseless_bin_n_ (pos->header, key, pos->header_size)))\n      return pos;\n  }\n  return NULL;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I found no assignments that reassign the pointer parameters themselves (response or connection) in MHD_response_execute_upgrade_ or in the related helper functions shown. All modifications are to members of the objects pointed to (e.g., connection->read_buffer_offset = 0; connection->urh = urh; response->upgrade_handler(...); connection->write_buffer = NULL; etc.), which is allowed by Rule 17.8 because the object referred to by a pointer parameter may be modified. There are also local pointer variables created (e.g., struct MHD_Daemon *const daemon = connection->daemon;) and new locals (urh) which are assigned, but these are not function parameters. No code fragment performs an assignment like response = ... or connection = ... within the function bodies shown, so there is no apparent violation of MISRA C 2023 Rule 17.8 to report."
}