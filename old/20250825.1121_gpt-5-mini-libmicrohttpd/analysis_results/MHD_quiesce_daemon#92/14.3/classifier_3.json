{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_quiesce_daemon:\n```c\n_MHD_EXTERN MHD_socket\nMHD_quiesce_daemon (struct MHD_Daemon *daemon)\n{\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  unsigned int i;\n#endif\n  MHD_socket ret;\n\n  ret = daemon->listen_fd;\n  if ((MHD_INVALID_SOCKET == ret)\n      || daemon->was_quiesced)\n    return MHD_INVALID_SOCKET;\n  if ( (0 == (daemon->options & (MHD_USE_ITC))) &&\n       MHD_D_IS_USING_THREADS_ (daemon) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Using MHD_quiesce_daemon in this mode \" \\\n                 \"requires MHD_USE_ITC.\\n\"));\n#endif\n    return MHD_INVALID_SOCKET;\n  }\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n    for (i = 0; i < daemon->worker_pool_size; i++)\n    {\n      daemon->worker_pool[i].was_quiesced = true;\n#ifdef EPOLL_SUPPORT\n      if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n          (-1 != daemon->worker_pool[i].epoll_fd) &&\n          (daemon->worker_pool[i].listen_socket_in_epoll) )\n      {\n        if (0 != epoll_ctl (daemon->worker_pool[i].epoll_fd,\n                            EPOLL_CTL_DEL,\n                            ret,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove listen FD from epoll set.\\n\"));\n        daemon->worker_pool[i].listen_socket_in_epoll = false;\n      }\n      else\n#endif\n      if (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n      {\n        if (! MHD_itc_activate_ (daemon->worker_pool[i].itc, \"q\"))\n          MHD_PANIC (_ (\"Failed to signal quiesce via inter-thread \" \\\n                        \"communication channel.\\n\"));\n      }\n    }\n#endif\n  daemon->was_quiesced = true;\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (-1 != daemon->epoll_fd) &&\n      (daemon->listen_socket_in_epoll) )\n  {\n    if ( (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          ret,\n                          NULL)) &&\n         (ENOENT != errno) )   /* ENOENT can happen due to race with\n                                  #MHD_epoll() */\n      MHD_PANIC (\"Failed to remove listen FD from epoll set.\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n#endif\n  if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"q\")) )\n    MHD_PANIC (_ (\"failed to signal quiesce via inter-thread \" \\\n                  \"communication channel.\\n\"));\n  return ret;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MHD_ITC_IS_VALID_ (daemon->worker_pool[i].itc))\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the controlling expression depends on the runtime value daemon->worker_pool[i].itc (and on i in the surrounding loop), so it is not invariant. A violation would occur if MHD_ITC_IS_VALID_ expanded to a compile-time constant (for example #define MHD_ITC_IS_VALID_(x) 1) or otherwise did not depend on mutable state, but that is not the case here."
}