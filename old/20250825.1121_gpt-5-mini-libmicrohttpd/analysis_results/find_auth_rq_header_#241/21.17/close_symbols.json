{
  "user_message": "Target function code is:\n```c\nstatic bool\nfind_auth_rq_header_ (const struct MHD_Connection *c, enum MHD_AuthType type,\n                      struct _MHD_str_w_len *auth_value)\n{\n  const struct MHD_HTTP_Req_Header *h;\n  const char *token;\n  size_t token_len;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= c->state);\n  if (MHD_CONNECTION_HEADERS_PROCESSED > c->state)\n    return false;\n\n#ifdef DAUTH_SUPPORT\n  if (MHD_AUTHTYPE_DIGEST == type)\n  {\n    token = _MHD_AUTH_DIGEST_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  }\n  else /* combined with the next line */\n#endif /* DAUTH_SUPPORT */\n#ifdef BAUTH_SUPPORT\n  if (MHD_AUTHTYPE_BASIC == type)\n  {\n    token = _MHD_AUTH_BASIC_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_BASIC_BASE);\n  }\n  else /* combined with the next line */\n#endif /* BAUTH_SUPPORT */\n  {\n    mhd_assert (0);\n    return false;\n  }\n\n  for (h = c->rq.headers_received; NULL != h; h = h->next)\n  {\n    if (MHD_HEADER_KIND != h->kind)\n      continue;\n    if (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_AUTHORIZATION) != h->header_size)\n      continue;\n    if (token_len > h->value_size)\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_AUTHORIZATION,\n                                         h->header,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_AUTHORIZATION)))\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (h->value, token, token_len))\n      continue;\n    /* Match only if token string is full header value or token is\n     * followed by space or tab\n     * Note: RFC 9110 (and RFC 7234) allows only space character, but\n     * tab is supported here as well for additional flexibility and uniformity\n     * as tabs are supported as separators between parameters.\n     */\n    if ((token_len == h->value_size) ||\n        (' ' == h->value[token_len]) || ('\\t'  == h->value[token_len]))\n    {\n      if (token_len != h->value_size)\n      { /* Skip whitespace */\n        auth_value->str = h->value + token_len + 1;\n        auth_value->len = h->value_size - (token_len + 1);\n      }\n      else\n      { /* No whitespace to skip */\n        auth_value->str = h->value + token_len;\n        auth_value->len = h->value_size - token_len;\n      }\n      return true; /* Found a match */\n    }\n  }\n  return false; /* No matching header has been found */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'find_auth_rq_header_': {'callees': [], 'callers': ['MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'MHD_get_rq_bauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_bauth_params'], 'callers': ['MHD_basic_auth_get_username_password3']}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (fields: state, rq.headers_received)",
    "struct MHD_HTTP_Req_Header (fields: kind, header_size, value_size, header, value, next)",
    "struct _MHD_str_w_len (fields: str, len)",
    "MHD_CONNECTION_HEADERS_PROCESSED",
    "MHD_HEADER_KIND",
    "MHD_HTTP_HEADER_AUTHORIZATION (string constant)",
    "MHD_STATICSTR_LEN_ (macro)",
    "_MHD_AUTH_BASIC_BASE (string constant)",
    "_MHD_AUTH_DIGEST_BASE (string constant)",
    "MHD_AUTHTYPE_BASIC",
    "MHD_AUTHTYPE_DIGEST",
    "MHD_str_equal_caseless_bin_n_ (function/prototype and implementation details)"
  ],
  "explanation": "For a correct MISRA <string.h> bounds analysis you must know the concrete types, sizes and behaviors that determine whether every pointer/index access (notably h->value[token_len], h->value + token_len(+1), and the comparisons) can read only within the referenced objects.\n\n- struct MHD_Connection (fields: state, rq.headers_received)\n  Required to know how headers_received is obtained (pointer validity, lifetime) and the meaning/type of state used in the early bounds/state check.\n\n- struct MHD_HTTP_Req_Header (fields: kind, header_size, value_size, header, value, next)\n  Essential: header_size and value_size are the length fields used to bound accesses; header/value are the pointer targets being indexed/used; next is needed to reason about list traversal and pointer validity.\n\n- struct _MHD_str_w_len (fields: str, len)\n  auth_value is written from h->value + token_len(+1) and its types/semantics (pointer and length) matter for reporting and ensuring no overflow when computing len.\n\n- MHD_CONNECTION_HEADERS_PROCESSED\n  Value/semantics used in the initial state check that gate access to headers; needed to ensure the function only executes when headers_received is valid.\n\n- MHD_HEADER_KIND\n  The header kind filter determines whether header_size/value_size semantics apply; include to confirm which entries are inspected.\n\n- MHD_HTTP_HEADER_AUTHORIZATION (string constant)\n  Used in the header name comparison; its content and length (when used with MHD_STATICSTR_LEN_) determine the n passed into the comparison function.\n\n- MHD_STATICSTR_LEN_ (macro)\n  Defines how compile-time string lengths are computed (e.g. sizeof(x)-1 or other). The numeric length values produced are directly used to bound comparisons and to compute token_len; correctness of those numeric values is required to judge index safety.\n\n- _MHD_AUTH_BASIC_BASE and _MHD_AUTH_DIGEST_BASE (string constants)\n  The token strings and their compile-time lengths (via MHD_STATICSTR_LEN_) are used to compute token_len and to compare with h->value; their contents and lengths determine whether subsequent indexing into h->value is within bounds.\n\n- MHD_AUTHTYPE_BASIC and MHD_AUTHTYPE_DIGEST\n  Enum values control which token and token_len are selected; needed to determine which string constant is used for the comparisons and bounds reasoning.\n\n- MHD_str_equal_caseless_bin_n_ (function/prototype and implementation details)\n  This helper performs the binary (length-limited) comparison used twice. To verify no out-of-bounds access you must see its prototype and implementation (does it read exactly n bytes, does it assume NUL-termination, does it call memcmp/memcpy, etc.). If it internally calls memcmp or similar, the implementation must be checked for correct use of the passed sizes so that it cannot read beyond header or token buffers.\n\nThese symbols together let the next analyst determine: (1) that the numeric checks (token_len > h->value_size, equality of lengths, and following indexing) prevent out-of-bounds indexing; (2) that the comparison routine(s) do not internally read past the provided length arguments; and (3) that the header/value pointers and their recorded sizes correctly represent accessible memory ranges. Without these definitions/implementations you cannot conclusively decide whether any string/memory operations in this function violate the MISRA rule."
}