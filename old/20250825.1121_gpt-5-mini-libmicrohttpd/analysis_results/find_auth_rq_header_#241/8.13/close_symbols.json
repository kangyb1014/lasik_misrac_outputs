{
  "user_message": "Target function code is:\n```c\nstatic bool\nfind_auth_rq_header_ (const struct MHD_Connection *c, enum MHD_AuthType type,\n                      struct _MHD_str_w_len *auth_value)\n{\n  const struct MHD_HTTP_Req_Header *h;\n  const char *token;\n  size_t token_len;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= c->state);\n  if (MHD_CONNECTION_HEADERS_PROCESSED > c->state)\n    return false;\n\n#ifdef DAUTH_SUPPORT\n  if (MHD_AUTHTYPE_DIGEST == type)\n  {\n    token = _MHD_AUTH_DIGEST_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  }\n  else /* combined with the next line */\n#endif /* DAUTH_SUPPORT */\n#ifdef BAUTH_SUPPORT\n  if (MHD_AUTHTYPE_BASIC == type)\n  {\n    token = _MHD_AUTH_BASIC_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_BASIC_BASE);\n  }\n  else /* combined with the next line */\n#endif /* BAUTH_SUPPORT */\n  {\n    mhd_assert (0);\n    return false;\n  }\n\n  for (h = c->rq.headers_received; NULL != h; h = h->next)\n  {\n    if (MHD_HEADER_KIND != h->kind)\n      continue;\n    if (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_AUTHORIZATION) != h->header_size)\n      continue;\n    if (token_len > h->value_size)\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_AUTHORIZATION,\n                                         h->header,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_AUTHORIZATION)))\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (h->value, token, token_len))\n      continue;\n    /* Match only if token string is full header value or token is\n     * followed by space or tab\n     * Note: RFC 9110 (and RFC 7234) allows only space character, but\n     * tab is supported here as well for additional flexibility and uniformity\n     * as tabs are supported as separators between parameters.\n     */\n    if ((token_len == h->value_size) ||\n        (' ' == h->value[token_len]) || ('\\t'  == h->value[token_len]))\n    {\n      if (token_len != h->value_size)\n      { /* Skip whitespace */\n        auth_value->str = h->value + token_len + 1;\n        auth_value->len = h->value_size - (token_len + 1);\n      }\n      else\n      { /* No whitespace to skip */\n        auth_value->str = h->value + token_len;\n        auth_value->len = h->value_size - token_len;\n      }\n      return true; /* Found a match */\n    }\n  }\n  return false; /* No matching header has been found */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'find_auth_rq_header_': {'callees': [], 'callers': ['MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'MHD_get_rq_bauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_bauth_params'], 'callers': ['MHD_basic_auth_get_username_password3']}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct _MHD_str_w_len",
    "struct MHD_HTTP_Req_Header",
    "_MHD_AUTH_DIGEST_BASE",
    "_MHD_AUTH_BASIC_BASE",
    "MHD_STATICSTR_LEN_",
    "MHD_str_equal_caseless_bin_n_",
    "MHD_HTTP_HEADER_AUTHORIZATION",
    "MHD_HEADER_KIND",
    "MHD_CONNECTION_HEADERS_PROCESSED",
    "mhd_assert"
  ],
  "explanation": "For checking MISRA rule about pointer const-qualification you must know the exact declarations/types and const-qualifiers of all pointers read from or written to by find_auth_rq_header_.\n- struct MHD_Connection: needed to see the type of c->rq and c->state and, crucially, the declared type (and const-qualification) of the headers_received member (pointer to header). Determines whether using const struct MHD_Connection *c is sufficient and whether headers_received yields const pointers.\n- struct _MHD_str_w_len: needed to see the type of auth_value->str (is it char * or const char *?) and auth_value->len. The function stores into auth_value->str \u2014 MISRA requires the pointed-to type to be const when possible; we must know its declaration to decide if this is a violation.\n- struct MHD_HTTP_Req_Header: required to examine the types and const-qualification of h->header, h->value, h->next and the numeric fields (header_size, value_size, kind). The const-qualification of h->header/h->value is central to deciding whether assigning/reading them respects the rule.\n- _MHD_AUTH_DIGEST_BASE and _MHD_AUTH_BASIC_BASE: their declarations (string literals or char arrays and their constness) determine the constness of token (const char *token). If these macros expand to const char[] or char[] affects whether token should be const.\n- MHD_STATICSTR_LEN_: macro or helper used with the auth base macros and header macro; needed to understand types/usage that produce token_len and comparisons (not strictly a pointer type, but included to fully inspect related macros that may expose non-const pointers).\n- MHD_str_equal_caseless_bin_n_: prototype is needed to know the parameter types (are they const char *?) to check whether passing h->header/h->value (and MHD_HTTP_HEADER_AUTHORIZATION) violates const-correctness.\n- MHD_HTTP_HEADER_AUTHORIZATION: its declaration (string literal or char array and constness) is needed because it is passed to MHD_str_equal_caseless_bin_n_ and compared against h->header; its constness affects whether pointer types are consistent.\n- MHD_HEADER_KIND: needed to interpret h->kind comparisons (not directly about const, but needed to inspect header symbol usages and ensure we inspect the right union/struct variant holding the header/value pointers).\n- MHD_CONNECTION_HEADERS_PROCESSED: value used with c->state \u2014 included so the reader can inspect any macros/types that might affect constness annotations on state or connection struct.\n- mhd_assert: macro may expand to expressions that reference pointer types (or cast away const). Including it allows checking whether any assert implementation violates const-correctness.\n\nIncluding these symbols lets the next analyst determine the declared const-qualification of every pointer used (c, headers_received, h, h->header, h->value, token, auth_value->str) and whether any assignment or parameter passing in find_auth_rq_header_ breaks the MISRA pointer-to-const rule."
}