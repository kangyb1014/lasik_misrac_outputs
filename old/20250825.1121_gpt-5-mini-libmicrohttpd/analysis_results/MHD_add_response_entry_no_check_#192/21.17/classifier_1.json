{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_add_response_entry_no_check_:\n```c\nbool\nMHD_add_response_entry_no_check_ (struct MHD_Response *response,\n                                  enum MHD_ValueKind kind,\n                                  const char *header,\n                                  size_t header_len,\n                                  const char *content,\n                                  size_t content_len)\n{\n  char *header_malloced;\n  char *value_malloced;\n\n  mhd_assert (0 != header_len);\n  mhd_assert (0 != content_len);\n  header_malloced = malloc (header_len + 1);\n  if (NULL == header_malloced)\n    return false;\n\n  memcpy (header_malloced, header, header_len);\n  header_malloced[header_len] = 0;\n\n  value_malloced = malloc (content_len + 1);\n  if (NULL != value_malloced)\n  {\n    memcpy (value_malloced, content, content_len);\n    value_malloced[content_len] = 0;\n\n    if (MHD_add_response_entry_no_alloc_ (response, kind,\n                                          header_malloced, header_len,\n                                          value_malloced, content_len))\n      return true; /* Success exit point */\n\n    free (value_malloced);\n  }\n  free (header_malloced);\n\n  return false; /* Failure exit point */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_add_response_entry_no_check_:\nenum MHD_ValueKind\n{\n\n  /**\n   * Response header\n   * @deprecated\n   */\n  MHD_RESPONSE_HEADER_KIND = 0,\n#define MHD_RESPONSE_HEADER_KIND \\\n  _MHD_DEPR_IN_MACRO ( \\\n    \"Value MHD_RESPONSE_HEADER_KIND is deprecated and not used\") \\\n  MHD_RESPONSE_HEADER_KIND\n\n  /**\n   * HTTP header (request/response).\n   */\n  MHD_HEADER_KIND = 1,\n\n  /**\n   * Cookies.  Note that the original HTTP header containing\n   * the cookie(s) will still be available and intact.\n   */\n  MHD_COOKIE_KIND = 2,\n\n  /**\n   * POST data.  This is available only if a content encoding\n   * supported by MHD is used (currently only URL encoding),\n   * and only if the posted content fits within the available\n   * memory pool.  Note that in that case, the upload data\n   * given to the #MHD_AccessHandlerCallback will be\n   * empty (since it has already been processed).\n   */\n  MHD_POSTDATA_KIND = 4,\n\n  /**\n   * GET (URI) arguments.\n   */\n  MHD_GET_ARGUMENT_KIND = 8,\n\n  /**\n   * HTTP footer (only for HTTP 1.1 chunked encodings).\n   */\n  MHD_FOOTER_KIND = 16\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemcpy (value_malloced, content, content_len);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "Yes \u2014 potential out-of-bounds read of the source. The code allocates the destination with malloc(content_len + 1) so the destination is large enough, but it does not validate that the source buffer pointed to by content actually contains at least content_len bytes. For example, if content points to the string \"abc\" (3 bytes) but content_len is 10, memcpy(value_malloced, content, content_len) will read beyond the bounds of the object pointed to by content, violating MISRA C 2023 Rule 21.17."
}