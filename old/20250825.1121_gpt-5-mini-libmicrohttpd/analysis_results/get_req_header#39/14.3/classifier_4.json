{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of get_req_header:\n```c\nstatic enum MHD_HdrLineReadRes_\nget_req_header (struct MHD_Connection *c,\n                bool process_footers,\n                struct _MHD_str_w_len *hdr_name,\n                struct _MHD_str_w_len *hdr_value)\n{\n  const int discp_lvl = c->daemon->client_discipline;\n  /* Treat bare LF as the end of the line.\n     RFC 9112, section 2.2-3\n     Note: MHD never replaces bare LF with space (RFC 9110, section 5.5-5).\n     Bare LF is processed as end of the line or rejected as broken request. */\n  const bool bare_lf_as_crlf = MHD_ALLOW_BARE_LF_AS_CRLF_ (discp_lvl);\n  /* Keep bare CR character as is.\n     Violates RFC 9112, section 2.2-4 */\n  const bool bare_cr_keep = (-3 >= discp_lvl);\n  /* Treat bare CR as space; replace it with space before processing.\n     RFC 9112, section 2.2-4 */\n  const bool bare_cr_as_sp = ((! bare_cr_keep) && (-1 >= discp_lvl));\n  /* Treat NUL as space; replace it with space before processing.\n     RFC 9110, section 5.5-5 */\n  const bool nul_as_sp = (-1 >= discp_lvl);\n  /* Allow folded header lines.\n     RFC 9112, section 5.2-4 */\n  const bool allow_folded = (0 >= discp_lvl);\n  /* Do not reject headers with the whitespace at the start of the first line.\n     When allowed, the first line with whitespace character at the first\n     position is ignored (as well as all possible line foldings of the first\n     line).\n     RFC 9112, section 2.2-8 */\n  const bool allow_wsp_at_start = allow_folded && (-1 >= discp_lvl);\n  /* Allow whitespace in header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_wsp_in_name = (-2 >= discp_lvl);\n  /* Allow zero-length header (field) name.\n     Violates RFC 9110, section 5.1-2 */\n  const bool allow_empty_name = (-2 >= discp_lvl);\n  /* Allow whitespace before colon.\n     Violates RFC 9112, section 5.1-2 */\n  const bool allow_wsp_before_colon = (-3 >= discp_lvl);\n  /* Do not abort the request when header line has no colon, just skip such\n     bad lines.\n     RFC 9112, section 5-1 */\n  const bool allow_line_without_colon = (-2 >= discp_lvl);\n\n  size_t p; /**< The position of the currently processed character */\n\n#if ! defined (HAVE_MESSAGES) && ! defined(_DEBUG)\n  (void) process_footers; /* Unused parameter */\n#endif /* !HAVE_MESSAGES && !_DEBUG */\n\n  mhd_assert ((process_footers ? MHD_CONNECTION_FOOTERS_RECEIVING : \\\n               MHD_CONNECTION_REQ_HEADERS_RECEIVING) == \\\n              c->state);\n\n  p = c->rq.hdrs.hdr.proc_pos;\n\n  mhd_assert (p <= c->read_buffer_offset);\n  while (p < c->read_buffer_offset)\n  {\n    const char chr = c->read_buffer[p];\n    bool end_of_line;\n\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_len < p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || (0 != p));\n    mhd_assert ((0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.name_end_found));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.name_len < c->rq.hdrs.hdr.value_start));\n    mhd_assert ((0 == c->rq.hdrs.hdr.value_start) || \\\n                (0 != c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.name_len) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.name_len));\n    mhd_assert ((0 == c->rq.hdrs.hdr.ws_start) || \\\n                (0 == c->rq.hdrs.hdr.value_start) || \\\n                (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start));\n\n    /* Check for the end of the line */\n    if ('\\r' == chr)\n    {\n      if (0 != p)\n      {\n        /* Line is not empty, need to check for possible line folding */\n        if (p + 2 >= c->read_buffer_offset)\n          break; /* Not enough data yet to check for folded line */\n      }\n      else\n      {\n        /* Line is empty, no need to check for possible line folding */\n        if (p + 2 > c->read_buffer_offset)\n          break; /* Not enough data yet to check for the end of the line */\n      }\n      if ('\\n' == c->read_buffer[p + 1])\n        end_of_line = true;\n      else\n      {\n        /* Bare CR alone */\n        /* Must be rejected or replaced with space char.\n           See RFC 9112, section 2.2-4 */\n        if (bare_cr_as_sp)\n        {\n          c->read_buffer[p] = ' ';\n          c->rq.num_cr_sp_replaced++;\n          continue; /* Re-start processing of the current character */\n        }\n        else if (! bare_cr_keep)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            BARE_CR_IN_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        end_of_line = false;\n      }\n    }\n    else if ('\\n' == chr)\n    {\n      /* Bare LF may be recognised as a line delimiter.\n         See RFC 9112, section 2.2-3 */\n      if (bare_lf_as_crlf)\n      {\n        if (0 != p)\n        {\n          /* Line is not empty, need to check for possible line folding */\n          if (p + 1 >= c->read_buffer_offset)\n            break; /* Not enough data yet to check for folded line */\n        }\n        end_of_line = true;\n      }\n      else\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          BARE_LF_IN_FOOTER);\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n    }\n    else\n      end_of_line = false;\n\n    if (end_of_line)\n    {\n      /* Handle the end of the line */\n      /**\n       *  The full length of the line, including CRLF (or bare LF).\n       */\n      const size_t line_len = p + (('\\r' == chr) ? 2 : 1);\n      char next_line_char;\n      mhd_assert (line_len <= c->read_buffer_offset);\n\n      if (0 == p)\n      {\n        /* Zero-length header line. This is the end of the request header\n           section.\n           RFC 9112, Section 2.1-1 */\n        mhd_assert (! c->rq.hdrs.hdr.starts_with_ws);\n        mhd_assert (! c->rq.hdrs.hdr.name_end_found);\n        mhd_assert (0 == c->rq.hdrs.hdr.name_len);\n        mhd_assert (0 == c->rq.hdrs.hdr.ws_start);\n        mhd_assert (0 == c->rq.hdrs.hdr.value_start);\n        /* Consume the line with CRLF (or bare LF) */\n        c->read_buffer += line_len;\n        c->read_buffer_offset -= line_len;\n        c->read_buffer_size -= line_len;\n        return MHD_HDR_LINE_READING_GOT_END_OF_HEADER;\n      }\n\n      mhd_assert (line_len < c->read_buffer_offset);\n      mhd_assert (0 != line_len);\n      mhd_assert ('\\n' == c->read_buffer[line_len - 1]);\n      next_line_char = c->read_buffer[line_len];\n      if ((' ' == next_line_char) ||\n          ('\\t' == next_line_char))\n      {\n        /* Folded line */\n        if (! allow_folded)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_OBS_FOLD_FOOTER);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        /* Replace CRLF (or bare LF) character(s) with space characters.\n           See RFC 9112, Section 5.2-4 */\n        c->read_buffer[p] = ' ';\n        if ('\\r' == chr)\n          c->read_buffer[p + 1] = ' ';\n        continue; /* Re-start processing of the current character */\n      }\n      else\n      {\n        /* It is not a folded line, it's the real end of the non-empty line */\n        bool skip_line = false;\n        mhd_assert (0 != p);\n        if (c->rq.hdrs.hdr.starts_with_ws)\n        {\n          /* This is the first line and it starts with whitespace. This line\n             must be discarded completely.\n             See RFC 9112, Section 2.2-8 */\n          mhd_assert (allow_wsp_at_start);\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (c->daemon,\n                    _ (\"Whitespace-prefixed first header line \" \\\n                       \"has been skipped.\\n\"));\n#endif /* HAVE_MESSAGES */\n          skip_line = true;\n        }\n        else if (! c->rq.hdrs.hdr.name_end_found)\n        {\n          if (! allow_line_without_colon)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_HEADER_WITHOUT_COLON);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_FOOTER_WITHOUT_COLON);\n\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          /* Skip broken line completely */\n          c->rq.skipped_broken_lines++;\n          skip_line = true;\n        }\n        if (skip_line)\n        {\n          /* Skip the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          p = 0;\n          /* Reset processing state */\n          memset (&c->rq.hdrs.hdr, 0, sizeof(c->rq.hdrs.hdr));\n          /* Start processing of the next line */\n          continue;\n        }\n        else\n        {\n          /* This line should be valid header line */\n          size_t value_len;\n          mhd_assert ((0 != c->rq.hdrs.hdr.name_len) || allow_empty_name);\n\n          hdr_name->str = c->read_buffer + 0; /* The name always starts at the first character */\n          hdr_name->len = c->rq.hdrs.hdr.name_len;\n          mhd_assert (0 == hdr_name->str[hdr_name->len]);\n\n          if (0 == c->rq.hdrs.hdr.value_start)\n          {\n            c->rq.hdrs.hdr.value_start = p;\n            c->read_buffer[p] = 0;\n            value_len = 0;\n          }\n          else if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            mhd_assert (c->rq.hdrs.hdr.ws_start > c->rq.hdrs.hdr.value_start);\n            c->read_buffer[c->rq.hdrs.hdr.ws_start] = 0;\n            value_len = c->rq.hdrs.hdr.ws_start - c->rq.hdrs.hdr.value_start;\n          }\n          else\n          {\n            mhd_assert (p > c->rq.hdrs.hdr.ws_start);\n            c->read_buffer[p] = 0;\n            value_len = p - c->rq.hdrs.hdr.value_start;\n          }\n          hdr_value->str = c->read_buffer + c->rq.hdrs.hdr.value_start;\n          hdr_value->len = value_len;\n          mhd_assert (0 == hdr_value->str[hdr_value->len]);\n          /* Consume the entire line */\n          c->read_buffer += line_len;\n          c->read_buffer_offset -= line_len;\n          c->read_buffer_size -= line_len;\n          return MHD_HDR_LINE_READING_GOT_HEADER;\n        }\n      }\n    }\n    else if ((' ' == chr) || ('\\t' == chr))\n    {\n      if (0 == p)\n      {\n        if (! allow_wsp_at_start)\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_HEADER);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_BEFORE_FOOTER);\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n        c->rq.hdrs.hdr.starts_with_ws = true;\n      }\n      else if ((! c->rq.hdrs.hdr.name_end_found) &&\n               (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Whitespace in header name / between header name and colon */\n        if (allow_wsp_in_name || allow_wsp_before_colon)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.ws_start = p;\n        }\n        else\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_HEADER_NAME);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_FOOTER_NAME);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n      }\n      else\n      {\n        /* Whitespace before/inside/after header (field) value */\n        if (0 == c->rq.hdrs.hdr.ws_start)\n          c->rq.hdrs.hdr.ws_start = p;\n      }\n    }\n    else if (0 == chr)\n    {\n      if (! nul_as_sp)\n      {\n        if (! process_footers)\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_HEADER);\n        else\n          transmit_error_response_static (c,\n                                          MHD_HTTP_BAD_REQUEST,\n                                          ERR_RSP_INVALID_CHR_IN_FOOTER);\n\n        return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n      }\n      c->read_buffer[p] = ' ';\n      continue; /* Re-start processing of the current character */\n    }\n    else\n    {\n      /* Not a whitespace, not the end of the header line */\n      mhd_assert ('\\r' != chr);\n      mhd_assert ('\\n' != chr);\n      mhd_assert ('\\0' != chr);\n      if ((! c->rq.hdrs.hdr.name_end_found) &&\n          (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Processing the header (field) name */\n        if (':' == chr)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.name_len = p;\n          else\n          {\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_before_colon)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n            c->rq.hdrs.hdr.name_len = c->rq.hdrs.hdr.ws_start;\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n          if ((0 == c->rq.hdrs.hdr.name_len) && ! allow_empty_name)\n          {\n            if (! process_footers)\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_HEADER_NAME);\n            else\n              transmit_error_response_static (c,\n                                              MHD_HTTP_BAD_REQUEST,\n                                              ERR_RSP_EMPTY_FOOTER_NAME);\n            return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n          }\n          c->rq.hdrs.hdr.name_end_found = true;\n          c->read_buffer[c->rq.hdrs.hdr.name_len] = 0; /* Zero-terminate the name */\n        }\n        else\n        {\n          if (0 != c->rq.hdrs.hdr.ws_start)\n          {\n            /* End of the whitespace in header (field) name */\n            mhd_assert (allow_wsp_in_name || allow_wsp_before_colon);\n            if (! allow_wsp_in_name)\n            {\n              if (! process_footers)\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_HEADER_NAME);\n              else\n                transmit_error_response_static (c,\n                                                MHD_HTTP_BAD_REQUEST,\n                                                ERR_RSP_WSP_IN_FOOTER_NAME);\n\n              return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n            }\n#ifndef MHD_FAVOR_SMALL_CODE\n            c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n          }\n        }\n      }\n      else\n      {\n        /* Processing the header (field) value */\n        if (0 == c->rq.hdrs.hdr.value_start)\n          c->rq.hdrs.hdr.value_start = p;\n#ifndef MHD_FAVOR_SMALL_CODE\n        c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n      }\n#ifdef MHD_FAVOR_SMALL_CODE\n      c->rq.hdrs.hdr.ws_start = 0; /* Not on whitespace anymore */\n#endif /* MHD_FAVOR_SMALL_CODE */\n    }\n    p++;\n  }\n  c->rq.hdrs.hdr.proc_pos = p;\n  return MHD_HDR_LINE_READING_NEED_MORE_DATA; /* Not enough data yet */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function get_req_header:\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nelse if ((! c->rq.hdrs.hdr.name_end_found) &&\n               (! c->rq.hdrs.hdr.starts_with_ws))\n      {\n        /* Whitespace in header name / between header name and colon */\n        if (allow_wsp_in_name || allow_wsp_before_colon)\n        {\n          if (0 == c->rq.hdrs.hdr.ws_start)\n            c->rq.hdrs.hdr.ws_start = p;\n        }\n        else\n        {\n          if (! process_footers)\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_HEADER_NAME);\n          else\n            transmit_error_response_static (c,\n                                            MHD_HTTP_BAD_REQUEST,\n                                            ERR_RSP_WSP_IN_FOOTER_NAME);\n\n          return MHD_HDR_LINE_READING_DATA_ERROR; /* Error in the request */\n        }\n      }\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The controlling expression is if (allow_wsp_in_name || allow_wsp_before_colon). Those booleans are computed from discp_lvl (c->daemon->client_discipline) at runtime, so the expression is not an invariant compile\u2011time constant. Therefore this fragment does not violate Rule 14.3. (It would violate the rule only if allow_wsp_in_name and allow_wsp_before_colon were compile\u2011time or otherwise always-constant\u2014e.g. if discp_lvl were a compile-time constant or macros yielding constant true/false.)"
}