{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN const union MHD_ConnectionInfo *\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)\n{\n  switch (info_type)\n  {\n#ifdef HTTPS_SUPPORT\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_cipher_algorithm_t res;\n      res = gnutls_cipher_get (connection->tls_session);\n      connection->connection_info_dummy.cipher_algorithm = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_PROTOCOL:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_protocol_t res;\n      res = gnutls_protocol_get_version (connection->tls_session);\n      connection->connection_info_dummy.protocol = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n    if (NULL == connection->tls_session)\n      return NULL;\n    connection->connection_info_dummy.tls_session = connection->tls_session;\n    return &connection->connection_info_dummy;\n#else  /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n  case MHD_CONNECTION_INFO_PROTOCOL:\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n#endif /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT:\n    return NULL; /* Not implemented */\n  case MHD_CONNECTION_INFO_CLIENT_ADDRESS:\n    if (0 < connection->addr_len)\n    {\n      mhd_assert (sizeof (connection->addr) == \\\n                  sizeof (connection->connection_info_dummy.client_addr));\n      memcpy (&connection->connection_info_dummy.client_addr,\n              &connection->addr,\n              sizeof(connection->addr));\n      return &connection->connection_info_dummy;\n    }\n    return NULL;\n  case MHD_CONNECTION_INFO_DAEMON:\n    connection->connection_info_dummy.daemon =\n      MHD_get_master (connection->daemon);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_FD:\n    connection->connection_info_dummy.connect_fd = connection->socket_fd;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_SOCKET_CONTEXT:\n    connection->connection_info_dummy.socket_context =\n      connection->socket_context;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_SUSPENDED:\n    connection->connection_info_dummy.suspended =\n      connection->suspended ? MHD_YES : MHD_NO;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_TIMEOUT:\n#if SIZEOF_UNSIGNED_INT <= (SIZEOF_UINT64_T - 2)\n    if (UINT_MAX < connection->connection_timeout_ms / 1000)\n      connection->connection_info_dummy.connection_timeout = UINT_MAX;\n    else\n#endif /* SIZEOF_UNSIGNED_INT <=(SIZEOF_UINT64_T - 2) */\n    connection->connection_info_dummy.connection_timeout =\n      (unsigned int) (connection->connection_timeout_ms / 1000);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE:\n    if ( (MHD_CONNECTION_HEADERS_RECEIVED > connection->state) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n      return NULL;   /* invalid, too early! */\n    connection->connection_info_dummy.header_size = connection->rq.header_size;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_HTTP_STATUS:\n    if (NULL == connection->rp.response)\n      return NULL;\n    connection->connection_info_dummy.http_status = connection->rp.responseCode;\n    return &connection->connection_info_dummy;\n  default:\n    return NULL;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_connection_info': {'callees': ['MHD_get_master'], 'callers': []}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (definition)",
    "union MHD_ConnectionInfo (definition)",
    "enum MHD_ConnectionInfoType and values (MHD_CONNECTION_INFO_*, MHD_CONNECTION_INFO_CIPHER_ALGO, MHD_CONNECTION_INFO_PROTOCOL, MHD_CONNECTION_INFO_GNUTLS_SESSION, MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT, MHD_CONNECTION_INFO_CLIENT_ADDRESS, MHD_CONNECTION_INFO_DAEMON, MHD_CONNECTION_INFO_CONNECTION_FD, MHD_CONNECTION_INFO_SOCKET_CONTEXT, MHD_CONNECTION_INFO_CONNECTION_SUSPENDED, MHD_CONNECTION_INFO_CONNECTION_TIMEOUT, MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE, MHD_CONNECTION_INFO_HTTP_STATUS)",
    "MHD_get_master",
    "mhd_assert (macro/implementation)",
    "memcpy (from <string.h>)",
    "HTTPS_SUPPORT (compile-time macro)",
    "gnutls_cipher_get (if HTTPS_SUPPORT)",
    "gnutls_protocol_get_version (if HTTPS_SUPPORT)",
    "gnutls_cipher_algorithm_t (type, if HTTPS_SUPPORT)",
    "gnutls_protocol_t (type, if HTTPS_SUPPORT)",
    "MHD_CONNECTION_HEADERS_RECEIVED",
    "MHD_CONNECTION_CLOSED",
    "MHD_YES",
    "MHD_NO",
    "SIZEOF_UNSIGNED_INT",
    "SIZEOF_UINT64_T",
    "UINT_MAX"
  ],
  "explanation": "To determine whether MHD_get_connection_info violates the MISRA rule 'A function parameter should not be modified' we must be able to tell whether the function assigns to the parameter variables (connection, info_type) or only mutates the object pointed to by connection (which is allowed). The listed symbols are required for that analysis for these reasons:\n\n- struct MHD_Connection (definition): needed to see which identifiers like connection->... are field accesses (permitted mutation of the pointee) versus any use that could be interpreted as assignment to the parameter itself. Also to inspect connection->connection_info_dummy fields and their types.\n- union MHD_ConnectionInfo (definition): needed to understand the return value and fields written into connection->connection_info_dummy (to confirm these are modifications of the pointed-to object, not the pointer parameter).\n- enum MHD_ConnectionInfoType and its values: needed to confirm which switch cases are selected and to ensure no case label or macro expands to code that assigns to the parameter variable.\n- MHD_get_master: the function is called with connection->daemon; its implementation should be checked only to ensure it cannot affect the parameter variable 'connection' itself via macro abuse; also to confirm no macro substitution introduces assignment to a parameter name.\n- mhd_assert (macro/implementation): the macro is invoked in the function; its expansion must be inspected to ensure it does not perform assignments to local parameters (for MISRA compliance) or redefine identifiers used as parameters.\n- memcpy: to confirm it operates on the memory pointed to by connection->connection_info_dummy.client_addr and &connection->addr (allowed mutation of pointee) and does not alter the pointer parameter.\n- HTTPS_SUPPORT (compile-time macro): controls presence of code paths that call gnutls functions and write into connection->connection_info_dummy; required to know whether those code paths exist and must be analyzed.\n- gnutls_cipher_get, gnutls_protocol_get_version: if HTTPS_SUPPORT is enabled, their prototypes/behavior should be known to ensure they are called with connection->tls_session and that they do not expand (via macros) into code that assigns to the parameter variable itself.\n- gnutls_cipher_algorithm_t, gnutls_protocol_t: types used to receive results before writing into the connection_info_dummy fields; needed to confirm only pointee fields are assigned, not the pointer parameter.\n- MHD_CONNECTION_HEADERS_RECEIVED, MHD_CONNECTION_CLOSED: these state macros/constants are used in a condition that governs a return; inspect to ensure no macro expansion assigns to parameters.\n- MHD_YES, MHD_NO: used in assigning a field from connection->suspended; needed to confirm those are ordinary constants/enums, not macros that could modify parameters.\n- SIZEOF_UNSIGNED_INT, SIZEOF_UINT64_T, UINT_MAX: used in conditional compilation/limits for computing connection_timeout; needed to check those macros/values and any conditional code paths for unintended assignments to parameters.\n\nIn short, the above definitions and macros must be checked to ensure that all uses inside MHD_get_connection_info are either reads of the enum parameter or writes to the object pointed to by 'connection' (permitted), and that no macro or called function expands or behaves in a way that assigns to the parameter variable itself (which would violate MISRA)."
}