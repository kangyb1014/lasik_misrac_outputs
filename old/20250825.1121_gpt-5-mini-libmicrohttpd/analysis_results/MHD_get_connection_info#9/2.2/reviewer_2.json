{
  "user_message": "An agent A claimed that the following MHD_get_connection_info code violates the MISRA C 2023 rule 2.2.\n<misra_rule>\nMISRA C 2023 Rule 2.2 is A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_connection_info.\n```c\n_MHD_EXTERN const union MHD_ConnectionInfo *\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)\n{\n  switch (info_type)\n  {\n#ifdef HTTPS_SUPPORT\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_cipher_algorithm_t res;\n      res = gnutls_cipher_get (connection->tls_session);\n      connection->connection_info_dummy.cipher_algorithm = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_PROTOCOL:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_protocol_t res;\n      res = gnutls_protocol_get_version (connection->tls_session);\n      connection->connection_info_dummy.protocol = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n    if (NULL == connection->tls_session)\n      return NULL;\n    connection->connection_info_dummy.tls_session = connection->tls_session;\n    return &connection->connection_info_dummy;\n#else  /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n  case MHD_CONNECTION_INFO_PROTOCOL:\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n#endif /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT:\n    return NULL; /* Not implemented */\n  case MHD_CONNECTION_INFO_CLIENT_ADDRESS:\n    if (0 < connection->addr_len)\n    {\n      mhd_assert (sizeof (connection->addr) == \\\n                  sizeof (connection->connection_info_dummy.client_addr));\n      memcpy (&connection->connection_info_dummy.client_addr,\n              &connection->addr,\n              sizeof(connection->addr));\n      return &connection->connection_info_dummy;\n    }\n    return NULL;\n  case MHD_CONNECTION_INFO_DAEMON:\n    connection->connection_info_dummy.daemon =\n      MHD_get_master (connection->daemon);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_FD:\n    connection->connection_info_dummy.connect_fd = connection->socket_fd;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_SOCKET_CONTEXT:\n    connection->connection_info_dummy.socket_context =\n      connection->socket_context;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_SUSPENDED:\n    connection->connection_info_dummy.suspended =\n      connection->suspended ? MHD_YES : MHD_NO;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_TIMEOUT:\n#if SIZEOF_UNSIGNED_INT <= (SIZEOF_UINT64_T - 2)\n    if (UINT_MAX < connection->connection_timeout_ms / 1000)\n      connection->connection_info_dummy.connection_timeout = UINT_MAX;\n    else\n#endif /* SIZEOF_UNSIGNED_INT <=(SIZEOF_UINT64_T - 2) */\n    connection->connection_info_dummy.connection_timeout =\n      (unsigned int) (connection->connection_timeout_ms / 1000);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE:\n    if ( (MHD_CONNECTION_HEADERS_RECEIVED > connection->state) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n      return NULL;   /* invalid, too early! */\n    connection->connection_info_dummy.header_size = connection->rq.header_size;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_HTTP_STATUS:\n    if (NULL == connection->rp.response)\n      return NULL;\n    connection->connection_info_dummy.http_status = connection->rp.responseCode;\n    return &connection->connection_info_dummy;\n  default:\n    return NULL;\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe mhd_assert line is potentially dead code. If mhd_assert is defined as a no-op (common in release builds, e.g. expanding to ((void)0) or omitted under NDEBUG), the entire statement disappears and the sizeof-only expression has no side effects; removing it does not change program behaviour. Even when assertions are enabled, the expression only computes sizeof (a compile-time property) and has no runtime side effects unless the assert fails (which is a diagnostic action). Therefore, as written this statement can be dead code in typical build configurations and thus can violate MISRA C 2023 Rule 2.2.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A's reasoning is correct in substance. The mhd_assert line contains only a sizeof comparison and is typically implemented by projects as a diagnostic macro that becomes a no-op (or an expression with no effect) in release builds. Per the MISRA 2.2 definition \u2014 \u201cAny operation that is executed but whose removal would not affect program behaviour constitutes dead code\u201d \u2014 an assertion that evaluates to an executed no-op (for example a macro expanding to ((void)0) or a benign expression statement) is dead code in that build configuration. Conversely, if mhd_assert in the actual project expands to a runtime check that can abort or otherwise affect behaviour, then the statement is not dead code. Thus the report is a valid finding as a potential MISRA 2.2 violation for projects/configurations where mhd_assert is disabled or is a no-op. To eliminate the problem unambiguously, replace this runtime assertion with a compile-time check (e.g. _Static_assert / static_assert where available) or ensure the project-wide definition of mhd_assert is such that it cannot become an executed no-op in the delivered build."
}