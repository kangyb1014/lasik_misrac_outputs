{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_connection_info:\n```c\n_MHD_EXTERN const union MHD_ConnectionInfo *\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)\n{\n  switch (info_type)\n  {\n#ifdef HTTPS_SUPPORT\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_cipher_algorithm_t res;\n      res = gnutls_cipher_get (connection->tls_session);\n      connection->connection_info_dummy.cipher_algorithm = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_PROTOCOL:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_protocol_t res;\n      res = gnutls_protocol_get_version (connection->tls_session);\n      connection->connection_info_dummy.protocol = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n    if (NULL == connection->tls_session)\n      return NULL;\n    connection->connection_info_dummy.tls_session = connection->tls_session;\n    return &connection->connection_info_dummy;\n#else  /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n  case MHD_CONNECTION_INFO_PROTOCOL:\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n#endif /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT:\n    return NULL; /* Not implemented */\n  case MHD_CONNECTION_INFO_CLIENT_ADDRESS:\n    if (0 < connection->addr_len)\n    {\n      mhd_assert (sizeof (connection->addr) == \\\n                  sizeof (connection->connection_info_dummy.client_addr));\n      memcpy (&connection->connection_info_dummy.client_addr,\n              &connection->addr,\n              sizeof(connection->addr));\n      return &connection->connection_info_dummy;\n    }\n    return NULL;\n  case MHD_CONNECTION_INFO_DAEMON:\n    connection->connection_info_dummy.daemon =\n      MHD_get_master (connection->daemon);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_FD:\n    connection->connection_info_dummy.connect_fd = connection->socket_fd;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_SOCKET_CONTEXT:\n    connection->connection_info_dummy.socket_context =\n      connection->socket_context;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_SUSPENDED:\n    connection->connection_info_dummy.suspended =\n      connection->suspended ? MHD_YES : MHD_NO;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_TIMEOUT:\n#if SIZEOF_UNSIGNED_INT <= (SIZEOF_UINT64_T - 2)\n    if (UINT_MAX < connection->connection_timeout_ms / 1000)\n      connection->connection_info_dummy.connection_timeout = UINT_MAX;\n    else\n#endif /* SIZEOF_UNSIGNED_INT <=(SIZEOF_UINT64_T - 2) */\n    connection->connection_info_dummy.connection_timeout =\n      (unsigned int) (connection->connection_timeout_ms / 1000);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE:\n    if ( (MHD_CONNECTION_HEADERS_RECEIVED > connection->state) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n      return NULL;   /* invalid, too early! */\n    connection->connection_info_dummy.header_size = connection->rq.header_size;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_HTTP_STATUS:\n    if (NULL == connection->rp.response)\n      return NULL;\n    connection->connection_info_dummy.http_status = connection->rp.responseCode;\n    return &connection->connection_info_dummy;\n  default:\n    return NULL;\n  }\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert (sizeof (connection->addr) == \\\n            sizeof (connection->connection_info_dummy.client_addr));\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The mhd_assert line is potentially dead code. If mhd_assert is defined as a no-op (common in release builds, e.g. expanding to ((void)0) or omitted under NDEBUG), the entire statement disappears and the sizeof-only expression has no side effects; removing it does not change program behaviour. Even when assertions are enabled, the expression only computes sizeof (a compile-time property) and has no runtime side effects unless the assert fails (which is a diagnostic action). Therefore, as written this statement can be dead code in typical build configurations and thus can violate MISRA C 2023 Rule 2.2."
}