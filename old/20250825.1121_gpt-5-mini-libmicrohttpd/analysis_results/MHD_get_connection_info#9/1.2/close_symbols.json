{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN const union MHD_ConnectionInfo *\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)\n{\n  switch (info_type)\n  {\n#ifdef HTTPS_SUPPORT\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_cipher_algorithm_t res;\n      res = gnutls_cipher_get (connection->tls_session);\n      connection->connection_info_dummy.cipher_algorithm = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_PROTOCOL:\n    if (NULL == connection->tls_session)\n      return NULL;\n    if (1)\n    { /* Workaround to mute compiler warning */\n      gnutls_protocol_t res;\n      res = gnutls_protocol_get_version (connection->tls_session);\n      connection->connection_info_dummy.protocol = (int) res;\n    }\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n    if (NULL == connection->tls_session)\n      return NULL;\n    connection->connection_info_dummy.tls_session = connection->tls_session;\n    return &connection->connection_info_dummy;\n#else  /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_CIPHER_ALGO:\n  case MHD_CONNECTION_INFO_PROTOCOL:\n  case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n#endif /* ! HTTPS_SUPPORT */\n  case MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT:\n    return NULL; /* Not implemented */\n  case MHD_CONNECTION_INFO_CLIENT_ADDRESS:\n    if (0 < connection->addr_len)\n    {\n      mhd_assert (sizeof (connection->addr) == \\\n                  sizeof (connection->connection_info_dummy.client_addr));\n      memcpy (&connection->connection_info_dummy.client_addr,\n              &connection->addr,\n              sizeof(connection->addr));\n      return &connection->connection_info_dummy;\n    }\n    return NULL;\n  case MHD_CONNECTION_INFO_DAEMON:\n    connection->connection_info_dummy.daemon =\n      MHD_get_master (connection->daemon);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_FD:\n    connection->connection_info_dummy.connect_fd = connection->socket_fd;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_SOCKET_CONTEXT:\n    connection->connection_info_dummy.socket_context =\n      connection->socket_context;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_SUSPENDED:\n    connection->connection_info_dummy.suspended =\n      connection->suspended ? MHD_YES : MHD_NO;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_CONNECTION_TIMEOUT:\n#if SIZEOF_UNSIGNED_INT <= (SIZEOF_UINT64_T - 2)\n    if (UINT_MAX < connection->connection_timeout_ms / 1000)\n      connection->connection_info_dummy.connection_timeout = UINT_MAX;\n    else\n#endif /* SIZEOF_UNSIGNED_INT <=(SIZEOF_UINT64_T - 2) */\n    connection->connection_info_dummy.connection_timeout =\n      (unsigned int) (connection->connection_timeout_ms / 1000);\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE:\n    if ( (MHD_CONNECTION_HEADERS_RECEIVED > connection->state) ||\n         (MHD_CONNECTION_CLOSED == connection->state) )\n      return NULL;   /* invalid, too early! */\n    connection->connection_info_dummy.header_size = connection->rq.header_size;\n    return &connection->connection_info_dummy;\n  case MHD_CONNECTION_INFO_HTTP_STATUS:\n    if (NULL == connection->rp.response)\n      return NULL;\n    connection->connection_info_dummy.http_status = connection->rp.responseCode;\n    return &connection->connection_info_dummy;\n  default:\n    return NULL;\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_get_connection_info': {'callees': ['MHD_get_master'], 'callers': []}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "struct MHD_Connection",
    "union MHD_ConnectionInfo",
    "enum MHD_ConnectionInfoType",
    "HTTPS_SUPPORT",
    "mhd_assert",
    "MHD_YES",
    "MHD_NO",
    "SIZEOF_UNSIGNED_INT",
    "SIZEOF_UINT64_T",
    "UINT_MAX",
    "MHD_get_master",
    "gnutls_cipher_get",
    "gnutls_protocol_get_version",
    "gnutls_cipher_algorithm_t",
    "gnutls_protocol_t"
  ],
  "explanation": "To determine whether MHD_get_connection_info uses any compiler/language extensions you must inspect the definitions and expansions that could hide extensions or attributes. Specifically:\n\n- _MHD_EXTERN: This storage-class/macro may expand to compiler-specific keywords or attributes (e.g. __attribute__, __declspec, extern \"C\") \u2014 must examine expansion to detect extensions.\n- struct MHD_Connection: The structure definition reveals member types, possible use of compiler-specific bitfields, anonymous/unnamed structs/unions or packed/aligned attributes \u2014 all potential language extensions.\n- union MHD_ConnectionInfo: The union layout and member types may include compiler-specific extensions (anonymous union, attributes); needed to verify standard-conforming usage.\n- enum MHD_ConnectionInfoType: Required to see the enum and case label values and whether any non-standard enum extensions/macros are used.\n- HTTPS_SUPPORT: Preprocessor conditional that changes which code is compiled; its definition determines whether gnutls-related code (and any extensions inside it) is present.\n- mhd_assert: This macro may expand to compiler built-ins or extensions (e.g. __builtin_expect, statement-expressions, attributes) \u2014 need its expansion.\n- MHD_YES / MHD_NO: Their definitions (macros or enum) may hide non-standard constructs or implicit casts; inspect to ensure no extensions.\n- SIZEOF_UNSIGNED_INT & SIZEOF_UINT64_T: These platform/configuration macros are used in conditional compilation; their definitions may come from generated headers that use compiler-specific constructs.\n- UINT_MAX: From limits.h; include to confirm standard use and that no non-standard override is in effect.\n- MHD_get_master: Called by the function \u2014 its declaration/definition should be checked for attributes (inline, visibility, non-standard linkage) that could be macro-expanded into extensions.\n- gnutls_cipher_get & gnutls_protocol_get_version: Functions used inside the HTTPS_SUPPORT block; their declarations/typedefs could use non-standard attributes or macros (or be macros themselves) \u2014 must inspect if that code path is active.\n- gnutls_cipher_algorithm_t & gnutls_protocol_t: typedefs used in the HTTPS_SUPPORT block; their definitions might involve compiler-specific types/attributes.\n\nInspecting these symbols (macro expansions, typedefs and struct/union/enum definitions, and called-function declarations) is sufficient to determine whether the function body or any code pulled in by conditionals uses language extensions that violate the MISRA rule."
}