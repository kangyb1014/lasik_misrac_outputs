{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of try_ready_normal_body:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function try_ready_normal_body:\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\nvoid *\nMHD_pool_try_alloc (struct MemoryPool *pool,\n                    size_t size,\n                    size_t *required_bytes)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n  { /* size is too close to SIZE_MAX, very unlikely */\n    *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  if (asize > pool->end - pool->pos)\n  {\n    mhd_assert ((pool->end - pool->pos) == \\\n                ROUND_TO_ALIGN (pool->end - pool->pos));\n    if (asize <= pool->end)\n      *required_bytes = asize - (pool->end - pool->pos);\n    else\n      *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  *required_bytes = 0;\n  ret = &pool->memory[pool->end - asize];\n  pool->end -= asize;\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n...\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n...\nvoid *\nMHD_pool_allocate (struct MemoryPool *pool,\n                   size_t size,\n                   bool from_end)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n    return NULL; /* size too close to SIZE_MAX */\n  if (asize > pool->end - pool->pos)\n    return NULL;\n  if (from_end)\n  {\n    ret = &pool->memory[pool->end - asize];\n    pool->end -= asize;\n  }\n  else\n  {\n    ret = &pool->memory[pool->pos];\n    pool->pos += asize;\n  }\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n...\nstatic void\nconnection_close_error (struct MHD_Connection *connection,\n                        const char *emsg)\n{\n  connection->stop_with_error = true;\n  connection->discard_request = true;\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              \"%s\\n\",\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void) emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nvoid\nMHD_connection_close_ (struct MHD_Connection *connection,\n                       enum MHD_RequestTerminationCode termination_code)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_Response *resp = connection->rp.response;\n\n  mhd_assert (! connection->suspended);\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  if ( (NULL != daemon->notify_completed) &&\n       (connection->rq.client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n                              connection,\n                              &connection->rq.client_context,\n                              termination_code);\n  connection->rq.client_aware = false;\n  if (NULL != resp)\n  {\n    connection->rp.response = NULL;\n    MHD_destroy_response (resp);\n  }\n  if (NULL != connection->pool)\n  {\n    MHD_pool_destroy (connection->pool);\n    connection->pool = NULL;\n  }\n\n  MHD_connection_mark_closed_ (connection);\n}\n...\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\nvoid\nMHD_pool_destroy (struct MemoryPool *pool)\n{\n  if (NULL == pool)\n    return;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  _MHD_UNPOISON_MEMORY (pool->memory, pool->size);\n  if (! pool->is_mmap)\n    free (pool->memory);\n  else\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    munmap (pool->memory,\n            pool->size);\n#elif defined(_WIN32)\n    VirtualFree (pool->memory,\n                 0,\n                 MEM_RELEASE);\n#else\n    abort ();\n#endif\n  free (pool);\n}\n...\nvoid\nMHD_connection_mark_closed_ (struct MHD_Connection *connection)\n{\n  const struct MHD_Daemon *daemon = connection->daemon;\n\n  if (0 == (daemon->options & MHD_USE_TURBO))\n  {\n#ifdef HTTPS_SUPPORT\n    /* For TLS connection use shutdown of TLS layer\n     * and do not shutdown TCP socket. This give more\n     * chances to send TLS closure data to remote side.\n     * Closure of TLS layer will be interpreted by\n     * remote side as end of transmission. */\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      if (! MHD_tls_connection_shutdown (connection))\n        shutdown (connection->socket_fd,\n                  SHUT_WR);\n    }\n    else   /* Combined with next 'shutdown()'. */\n#endif /* HTTPS_SUPPORT */\n    shutdown (connection->socket_fd,\n              SHUT_WR);\n  }\n  connection->state = MHD_CONNECTION_CLOSED;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n}\n...\nvoid\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n  {   /* HTTPS connection. */\n    if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n    {\n      if (! MHD_run_tls_handshake_ (connection))\n        return;\n    }\n  }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _ (\"In function %s handling connection at state: %s\\n\"),\n            MHD_FUNC_,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n  {\n  case MHD_CONNECTION_INIT:\n  case MHD_CONNECTION_REQ_LINE_RECEIVING:\n  case MHD_CONNECTION_REQ_LINE_RECEIVED:\n  case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n  case MHD_CONNECTION_HEADERS_RECEIVED:\n  case MHD_CONNECTION_HEADERS_PROCESSED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CONTINUE_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &HTTP_100_CONTINUE\n                          [connection->continue_message_write_offset],\n                          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)\n                          - connection->continue_message_write_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send data in request for %s.\\n\"),\n                connection->rq.url);\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n#if _MHD_DEBUG_SEND_DATA\n    fprintf (stderr,\n             _ (\"Sent 100 continue response: `%.*s'\\n\"),\n             (int) ret,\n             &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n    connection->continue_message_write_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    return;\n  case MHD_CONNECTION_BODY_RECEIVING:\n  case MHD_CONNECTION_BODY_RECEIVED:\n  case MHD_CONNECTION_FOOTERS_RECEIVING:\n  case MHD_CONNECTION_FOOTERS_RECEIVED:\n  case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_START_REPLY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_HEADERS_SENDING:\n    {\n      struct MHD_Response *const resp = connection->rp.response;\n      const size_t wb_ready = connection->write_buffer_append_offset\n                              - connection->write_buffer_send_offset;\n      mhd_assert (connection->write_buffer_append_offset >= \\\n                  connection->write_buffer_send_offset);\n      mhd_assert (NULL != resp);\n      mhd_assert ( (0 == resp->data_size) || \\\n                   (0 == resp->data_start) || \\\n                   (NULL != resp->crc) );\n      mhd_assert ( (0 == connection->rp.rsp_write_position) || \\\n                   (resp->total_size ==\n                    connection->rp.rsp_write_position) );\n      mhd_assert ((MHD_CONN_MUST_UPGRADE != connection->keepalive) || \\\n                  (! connection->rp.props.send_reply_body));\n\n      if ( (connection->rp.props.send_reply_body) &&\n           (NULL == resp->crc) &&\n           (NULL == resp->data_iov) &&\n           /* TODO: remove the next check as 'send_reply_body' is used */\n           (0 == connection->rp.rsp_write_position) &&\n           (! connection->rp.props.chunked) )\n      {\n        mhd_assert (resp->total_size >= resp->data_size);\n        mhd_assert (0 == resp->data_start);\n        /* Send response headers alongside the response body, if the body\n         * data is available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      resp->data,\n                                      resp->data_size,\n                                      (resp->total_size == resp->data_size));\n      }\n      else\n      {\n        /* This is response for HEAD request or reply body is not allowed\n         * for any other reason or reply body is dynamically generated. */\n        /* Do not send the body data even if it's available. */\n        ret = MHD_send_hdr_and_body_ (connection,\n                                      &connection->write_buffer\n                                      [connection->write_buffer_send_offset],\n                                      wb_ready,\n                                      false,\n                                      NULL,\n                                      0,\n                                      ((0 == resp->total_size) ||\n                                       (! connection->rp.props.send_reply_body)\n                                      ));\n      }\n\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response headers for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      /* 'ret' is not negative, it's safe to cast it to 'size_t'. */\n      if (((size_t) ret) > wb_ready)\n      {\n        /* The complete header and some response data have been sent,\n         * update both offsets. */\n        mhd_assert (0 == connection->rp.rsp_write_position);\n        mhd_assert (! connection->rp.props.chunked);\n        mhd_assert (connection->rp.props.send_reply_body);\n        connection->write_buffer_send_offset += wb_ready;\n        connection->rp.rsp_write_position = ((size_t) ret) - wb_ready;\n      }\n      else\n        connection->write_buffer_send_offset += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    }\n  case MHD_CONNECTION_HEADERS_SENT:\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_READY:\n    response = connection->rp.response;\n    if (connection->rp.rsp_write_position <\n        connection->rp.response->total_size)\n    {\n      uint64_t data_write_offset;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n      if (MHD_NO == try_ready_normal_body (connection))\n      {\n        /* mutex was already unlocked by try_ready_normal_body */\n        return;\n      }\n#if defined(_MHD_HAVE_SENDFILE)\n      if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n      {\n        mhd_assert (NULL == response->data_iov);\n        ret = MHD_send_sendfile_ (connection);\n      }\n      else /* combined with the next 'if' */\n#endif /* _MHD_HAVE_SENDFILE */\n      if (NULL != response->data_iov)\n      {\n        ret = MHD_send_iovec_ (connection,\n                               &connection->rp.resp_iov,\n                               true);\n      }\n      else\n      {\n        data_write_offset = connection->rp.rsp_write_position\n                            - response->data_start;\n        if (data_write_offset > (uint64_t) SIZE_MAX)\n          MHD_PANIC (_ (\"Data offset exceeds limit.\\n\"));\n        ret = MHD_send_data_ (connection,\n                              &response->data\n                              [(size_t) data_write_offset],\n                              response->data_size\n                              - (size_t) data_write_offset,\n                              true);\n#if _MHD_DEBUG_SEND_DATA\n        if (ret > 0)\n          fprintf (stderr,\n                   _ (\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                   (int) ret,\n                   (int) ret,\n                   &rp.response->data[connection->rp.rsp_write_position\n                                      - rp.response->data_start]);\n#endif\n      }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != response->crc)\n        MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n      if (ret < 0)\n      {\n        if (MHD_ERR_AGAIN_ == ret)\n          return;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"Failed to send the response body for the \" \\\n                     \"request for `%s'. Error: %s\\n\"),\n                  connection->rq.url,\n                  str_conn_error_ (ret));\n#endif\n        CONNECTION_CLOSE_ERROR (connection,\n                                NULL);\n        return;\n      }\n      connection->rp.rsp_write_position += (size_t) ret;\n      MHD_update_last_activity_ (connection);\n    }\n    if (connection->rp.rsp_write_position ==\n        connection->rp.response->total_size)\n      connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n    return;\n  case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_READY:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the chunked response body for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n      return;\n    check_write_done (connection,\n                      (connection->rp.response->total_size ==\n                       connection->rp.rsp_write_position) ?\n                      MHD_CONNECTION_CHUNKED_BODY_SENT :\n                      MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n    return;\n  case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n  case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_FOOTERS_SENDING:\n    ret = MHD_send_data_ (connection,\n                          &connection->write_buffer\n                          [connection->write_buffer_send_offset],\n                          connection->write_buffer_append_offset\n                          - connection->write_buffer_send_offset,\n                          true);\n    if (ret < 0)\n    {\n      if (MHD_ERR_AGAIN_ == ret)\n        return;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to send the footers for the \" \\\n                   \"request for `%s'. Error: %s\\n\"),\n                connection->rq.url,\n                str_conn_error_ (ret));\n#endif\n      CONNECTION_CLOSE_ERROR (connection,\n                              NULL);\n      return;\n    }\n    connection->write_buffer_send_offset += (size_t) ret;\n    MHD_update_last_activity_ (connection);\n    if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n      return;\n    check_write_done (connection,\n                      MHD_CONNECTION_FULL_REPLY_SENT);\n    return;\n  case MHD_CONNECTION_FULL_REPLY_SENT:\n    mhd_assert (0);\n    return;\n  case MHD_CONNECTION_CLOSED:\n    return;\n#ifdef UPGRADE_SUPPORT\n  case MHD_CONNECTION_UPGRADE:\n    mhd_assert (0);\n    return;\n#endif /* UPGRADE_SUPPORT */\n  default:\n    mhd_assert (0);\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Internal error.\\n\"));\n    break;\n  }\n  return;\n}\n...\nenum MHD_Result\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  enum MHD_Result ret;\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  /* 'daemon' is not used if epoll is not available and asserts are disabled */\n  (void) daemon; /* Mute compiler warning */\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n  {\n#ifdef HTTPS_SUPPORT\n    if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    {     /* HTTPS connection. */\n      if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n          (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n        break;\n    }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n    MHD_DLOG (daemon,\n              _ (\"In function %s handling connection at state: %s\\n\"),\n              MHD_FUNC_,\n              MHD_state_to_string (connection->state));\n#endif\n    switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (get_request_line (connection))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING < connection->state);\n        mhd_assert ((MHD_IS_HTTP_VER_SUPPORTED (connection->rq.http_ver)) \\\n                    || (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVING >= connection->state);\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n      switch_to_rq_headers_processing (connection);\n      mhd_assert (MHD_CONNECTION_REQ_LINE_RECEIVED != connection->state);\n      continue;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      if (get_req_headers (connection, false))\n      {\n        mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_HEADERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_REQ_HEADERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      parse_connection_headers (connection);\n      if (MHD_CONNECTION_HEADERS_RECEIVED != connection->state)\n        continue;\n      connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      call_connection_handler (connection);     /* first call */\n      if (MHD_CONNECTION_HEADERS_PROCESSED != connection->state)\n        continue;\n      if (connection->suspended)\n        continue;\n\n      if ( (NULL == connection->rp.response) &&\n           (need_100_continue (connection)) &&\n           /* If the client is already sending the payload (body)\n              there is no need to send \"100 Continue\" */\n           (0 == connection->read_buffer_offset) )\n      {\n        connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n        break;\n      }\n      if ( (NULL != connection->rp.response) &&\n           (0 != connection->rq.remaining_upload_size) )\n      {\n        /* we refused (no upload allowed!) */\n        connection->rq.remaining_upload_size = 0;\n        /* force close, in case client still tries to upload... */\n        connection->discard_request = true;\n      }\n      connection->state = (0 == connection->rq.remaining_upload_size)\n                          ? MHD_CONNECTION_FULL_REQ_RECEIVED\n                          : MHD_CONNECTION_BODY_RECEIVING;\n      if (connection->suspended)\n        break;\n      continue;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      if (connection->continue_message_write_offset ==\n          MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVING;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      mhd_assert (0 != connection->rq.remaining_upload_size);\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 != connection->read_buffer_offset)\n      {\n        process_request_body (connection);           /* loop call */\n        if (MHD_CONNECTION_BODY_RECEIVING != connection->state)\n          continue;\n      }\n      /* Modify here when queueing of the response during data processing\n         will be supported */\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        connection->state = MHD_CONNECTION_BODY_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_BODY_RECEIVED:\n      mhd_assert (! connection->discard_request);\n      mhd_assert (NULL == connection->rp.response);\n      if (0 == connection->rq.remaining_upload_size)\n      {\n        if (connection->rq.have_chunked_upload)\n        {\n          /* Reset counter variables reused for footers */\n          connection->rq.num_cr_sp_replaced = 0;\n          connection->rq.skipped_broken_lines = 0;\n          reset_rq_header_processing_state (connection);\n          connection->state = MHD_CONNECTION_FOOTERS_RECEIVING;\n        }\n        else\n          connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n        continue;\n      }\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      if (get_req_headers (connection, true))\n      {\n        mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING < connection->state);\n        mhd_assert ((MHD_CONNECTION_FOOTERS_RECEIVED == connection->state) || \\\n                    (connection->discard_request));\n        continue;\n      }\n      mhd_assert (MHD_CONNECTION_FOOTERS_RECEIVING == connection->state);\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      /* The header, the body, and the footers of the request has been received,\n       * switch to the final processing of the request. */\n      connection->state = MHD_CONNECTION_FULL_REQ_RECEIVED;\n      continue;\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n      call_connection_handler (connection);     /* \"final\" call */\n      if (connection->state != MHD_CONNECTION_FULL_REQ_RECEIVED)\n        continue;\n      if (NULL == connection->rp.response)\n        break;                  /* try again next time */\n      /* Response is ready, start reply */\n      connection->state = MHD_CONNECTION_START_REPLY;\n      continue;\n    case MHD_CONNECTION_START_REPLY:\n      mhd_assert (NULL != connection->rp.response);\n      connection_switch_from_recv_to_send (connection);\n      if (MHD_NO == build_header_response (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \"\n                                   \"response header).\\n\"));\n        continue;\n      }\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n      break;\n\n    case MHD_CONNECTION_HEADERS_SENDING:\n      /* no default action */\n      break;\n    case MHD_CONNECTION_HEADERS_SENT:\n#ifdef UPGRADE_SUPPORT\n      if (NULL != connection->rp.response->upgrade_handler)\n      {\n        connection->state = MHD_CONNECTION_UPGRADE;\n        /* This connection is \"upgraded\".  Pass socket to application. */\n        if (MHD_NO ==\n            MHD_response_execute_upgrade_ (connection->rp.response,\n                                           connection))\n        {\n          /* upgrade failed, fail hard */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          continue;\n        }\n        /* Response is not required anymore for this connection. */\n        if (1)\n        {\n          struct MHD_Response *const resp = connection->rp.response;\n\n          connection->rp.response = NULL;\n          MHD_destroy_response (resp);\n        }\n        continue;\n      }\n#endif /* UPGRADE_SUPPORT */\n\n      if (connection->rp.props.send_reply_body)\n      {\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n        else\n          connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      }\n      else\n        connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n      continue;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (! connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if (0 == connection->rp.response->total_size)\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        if (connection->rp.props.chunked)\n          connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        else\n          connection->state = MHD_CONNECTION_FULL_REPLY_SENT;\n        continue;\n      }\n      if (MHD_NO != try_ready_normal_body (connection))\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n        /* Buffering for flushable socket was already enabled*/\n\n        break;\n      }\n      /* mutex was already unlocked by \"try_ready_normal_body */\n      /* not ready, no socket action */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* nothing to do here */\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n      if (NULL != connection->rp.response->crc)\n        MHD_mutex_lock_chk_ (&connection->rp.response->mutex);\n#endif\n      if ( (0 == connection->rp.response->total_size) ||\n           (connection->rp.rsp_write_position ==\n            connection->rp.response->total_size) )\n      {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n        if (NULL != connection->rp.response->crc)\n          MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n        connection->state = MHD_CONNECTION_CHUNKED_BODY_SENT;\n        continue;\n      }\n      if (1)\n      { /* pseudo-branch for local variables scope */\n        bool finished;\n        if (MHD_NO != try_ready_chunked_body (connection, &finished))\n        {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n          if (NULL != connection->rp.response->crc)\n            MHD_mutex_unlock_chk_ (&connection->rp.response->mutex);\n#endif\n          connection->state = finished ? MHD_CONNECTION_CHUNKED_BODY_SENT :\n                              MHD_CONNECTION_CHUNKED_BODY_READY;\n          continue;\n        }\n        /* mutex was already unlocked by try_ready_chunked_body */\n      }\n      break;\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      mhd_assert (connection->write_buffer_send_offset <= \\\n                  connection->write_buffer_append_offset);\n\n      if (MHD_NO == build_connection_chunked_response_footer (connection))\n      {\n        /* oops - close! */\n        CONNECTION_CLOSE_ERROR (connection,\n                                _ (\"Closing connection (failed to create \" \\\n                                   \"response footer).\"));\n        continue;\n      }\n      mhd_assert (connection->write_buffer_send_offset < \\\n                  connection->write_buffer_append_offset);\n      connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n      continue;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      mhd_assert (connection->rp.props.send_reply_body);\n      mhd_assert (connection->rp.props.chunked);\n      /* no default action */\n      break;\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n      if (MHD_HTTP_PROCESSING == connection->rp.responseCode)\n      {\n        /* After this type of response, we allow sending another! */\n        connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n        MHD_destroy_response (connection->rp.response);\n        connection->rp.response = NULL;\n        /* FIXME: maybe partially reset memory pool? */\n        continue;\n      }\n      /* Reset connection after complete reply */\n      connection_reset (connection,\n                        MHD_CONN_USE_KEEPALIVE == connection->keepalive &&\n                        ! connection->read_closed &&\n                        ! connection->discard_request);\n      continue;\n    case MHD_CONNECTION_CLOSED:\n      cleanup_connection (connection);\n      connection->in_idle = false;\n      return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      connection->in_idle = false;\n      return MHD_YES;     /* keep open */\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      break;\n    }\n    break;\n  }\n  if (connection_check_timedout (connection))\n  {\n    MHD_connection_close_ (connection,\n                           MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n    connection->in_idle = false;\n    return MHD_YES;\n  }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_EPOLL_ (daemon) )\n  {\n    ret = MHD_connection_epoll_update_ (connection);\n  }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (MHD_NO != try_ready_normal_body (connection))\n      {\n        /* ... */\n      } (call site in MHD_connection_handle_idle)\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: try_ready_normal_body is called from MHD_connection_handle_idle but try_ready_normal_body does not call itself (no direct recursion) and there is no evidence in the provided code of an internal call chain that would lead back to try_ready_normal_body (no indirect recursion through other library functions)."
}