{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_ready_normal_body': {'callees': ['MHD_connection_alloc_memory_', '__builtin_unreachable', 'connection_close_error', 'MHD_connection_close_'], 'callers': ['MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'connection_close_error': {'callees': ['MHD_DLOG', 'MHD_connection_close_'], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'transmit_error_response_len', 'handle_recv_no_space', 'call_connection_handler', 'process_request_body', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_connection_handle_idle']}, 'MHD_connection_close_': {'callees': ['MHD_destroy_response', 'MHD_pool_destroy', 'MHD_connection_mark_closed_'], 'callers': ['connection_close_error', 'try_ready_normal_body', 'MHD_connection_handle_read', 'connection_reset', 'MHD_connection_handle_idle', 'call_handlers', 'thread_main_handle_connection', 'close_connection']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}, 'MHD_connection_handle_idle': {'callees': ['get_request_line', 'switch_to_rq_headers_processing', 'get_req_headers', 'parse_connection_headers', 'call_connection_handler', 'need_100_continue', 'process_request_body', 'reset_rq_header_processing_state', 'connection_switch_from_recv_to_send', 'build_header_response', 'connection_close_error', 'MHD_response_execute_upgrade_', 'MHD_destroy_response', '__builtin_unreachable', 'try_ready_normal_body', 'try_ready_chunked_body', 'build_connection_chunked_response_footer', 'connection_reset', 'cleanup_connection', 'connection_check_timedout', 'MHD_connection_close_', 'MHD_connection_update_event_loop_info', 'MHD_connection_epoll_update_'], 'callers': ['MHD_queue_response', 'call_handlers', 'thread_main_handle_connection', 'MHD_epoll']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "CONNECTION_CLOSE_ERROR",
    "connection_close_error",
    "__builtin_unreachable",
    "MHD_MIN",
    "MHD_connection_alloc_memory_",
    "MHD_mutex_unlock_chk_",
    "MHD_connection_close_",
    "MHD_DLOG",
    "struct MHD_Response",
    "struct MHD_Connection (including rp/resp_iov)",
    "MHD_iovec_",
    "enum MHD_Result (MHD_YES/MHD_NO)",
    "MHD_CONTENT_READER_END_OF_STREAM",
    "type/typedef of response->crc (crc callback)"
  ],
  "explanation": "For a correct determination whether try_ready_normal_body uses any compiler language extensions we must inspect not only the function body but also any macros, builtins, types and inlined constructs it relies on. Each listed symbol is required for the following reason:\n\n- CONNECTION_CLOSE_ERROR: This is invoked in the function (uppercase macro). Macros commonly expand to compiler-specific builtins or GCC extensions; its definition must be checked for any extension usage (e.g. __builtin_*, statement-expressions, typeof, attributes).\n\n- connection_close_error: the lowercase function name appears in the static call graph and may be the implementation used by the CONNECTION_CLOSE_ERROR macro; inspect its definition for extensions (attributes, builtin use, inline assembly, non-standard statements).\n\n- __builtin_unreachable: appears in the call graph as a callee reachable from this path. This is an explicit GCC/Clang builtin (language extension). We must confirm whether the function or any macros it expands to use this builtin.\n\n- MHD_MIN: used in the function. Some projects implement MIN macros using GCC typeof or statement-expression extensions to be type-safe. The macro definition must be inspected to ensure it does not use language extensions.\n\n- MHD_connection_alloc_memory_: called to allocate memory; its implementation or any macros used in its inline/definition may use compiler extensions (alloc-related attributes, statement-expressions, typeof, inline asm). Inspect to be sure calling it does not bring extensions into the target function via inlining or macro expansion.\n\n- MHD_mutex_unlock_chk_: invoked in the function. It may be a macro or inline function that expands to pthread or platform-specific primitives or builtins; its definition must be checked for extensions.\n\n- MHD_connection_close_: called in error paths. Its definition may carry attributes (noreturn), use builtins or inline asm; inspect for extensions that would affect the target function's compliance.\n\n- MHD_DLOG: logging macro invoked (via connection_close_error). Logging macros frequently use do { ... } while (0), compiler attributes, or builtins; inspect its definition for extensions.\n\n- struct MHD_Response: the function reads/writes many members (total_size, data_iov, data_iovcnt, mutex, crc, crc_cls, data, data_buffer_size, data_start, data_size). The struct or any embedded types (e.g. function-pointer types, flexible-array members, compiler-specific attributes) could use language extensions; inspect the full definition.\n\n- struct MHD_Connection (including rp/resp_iov): the function accesses connection->rp and resp_iov fields and modifies state. The structure definitions (and nested types) may contain non-standard attributes, bitfields with implementation-defined widths, anonymous structs/unions (some are language extensions in older compilers), or other extensions \u2014 inspect them.\n\n- MHD_iovec_: used in sizeof(MHD_iovec_). The typedef/struct may itself use extensions (e.g. unnamed bitfields, flexible array members, typeof-like constructs); check its definition.\n\n- enum MHD_Result (MHD_YES/MHD_NO): the function returns enum MHD_Result and uses MHD_YES/MHD_NO. Confirm the enum definition is standard C and that any related macros/constants are not implemented with extensions.\n\n- MHD_CONTENT_READER_END_OF_STREAM: used as a special return value from response->crc; its definition (macro or enum/constant) should be checked for extension use.\n\n- type/typedef of response->crc (crc callback): response->crc is invoked as a function pointer with parameters and a return type (ssize_t). The typedef or prototype could use non-standard calling conventions, attributes, or compiler-specific annotations \u2014 inspect the callback type/definition to ensure no extension is used.\n\nInspecting these symbols (macros, builtins, called functions, struct/enum/type definitions) is sufficient to decide whether try_ready_normal_body itself (including any expansions it triggers) relies on compiler language extensions that would violate the MISRA rule. Only these symbols are requested because they are the direct dependencies that can introduce language extensions into the compiled form of try_ready_normal_body."
}