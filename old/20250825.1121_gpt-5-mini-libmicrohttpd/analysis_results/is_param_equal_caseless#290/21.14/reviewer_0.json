{
  "user_message": "An agent A claimed that the following is_param_equal_caseless code violates the MISRA C 2023 rule 21.14.\n<misra_rule>\nMISRA C 2023 Rule 21.14 is The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal_caseless.\n```c\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis fragment uses memcmp to compare character sequences. If either 'str' or 'param->value.str' are null-terminated C strings (the common case when dealing with text), then memcmp is being used to compare null-terminated strings which violates MISRA C 2023 Rule 21.14. Even though a length is supplied and equality of lengths is checked, using memcmp for C strings is disallowed by the rule. Use a string comparison function (e.g. strcmp/strncmp or a locale/Case-insensitive variant) or explicitly documented byte-buffer semantics instead.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 Rule 21.14 forbids using memcmp to compare null\u2011terminated C strings. It does not ban memcmp for comparing byte buffers when an explicit length is used. In this function memcmp is only invoked after checking that the two lengths are equal and both source pointers are asserted non\u2011NULL; the call compares exactly str_len bytes. Nothing in the shown code indicates these objects are null\u2011terminated C strings rather than length\u2011specified byte sequences. Therefore, based on the provided code and without additional context that 'str' or 'param->value.str' are guaranteed null\u2011terminated C strings, the agent A's report is not correct. If in the wider program these values are in fact documented/guaranteed to be null\u2011terminated C strings, then using memcmp would violate 21.14 and should be replaced by the appropriate string routine (e.g. strcmp/strncmp or a documented, explicit byte semantics)."
}