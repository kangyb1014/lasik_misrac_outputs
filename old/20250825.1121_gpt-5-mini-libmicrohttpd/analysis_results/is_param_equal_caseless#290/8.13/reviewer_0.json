{
  "user_message": "An agent A claimed that the following is_param_equal_caseless code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal_caseless.\n```c\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the struct member param->value.str is declared as a non-const pointer (e.g. char *str), then this call reveals a Rule 8.13 violation: the code only reads from the buffer (the callee takes a const char *), so the pointer should have been declared as pointing to const (const char *). If, however, param->value.str is already declared as const char * (or equivalent), there is no violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function is_param_equal_caseless:\nbool\nMHD_str_equal_quoted_bin_n (const char *quoted,\n                            size_t quoted_len,\n                            const char *unquoted,\n                            size_t unquoted_len)\n{\n  size_t i;\n  size_t j;\n  if (unquoted_len < quoted_len / 2)\n    return false;\n\n  j = 0;\n  for (i = 0; quoted_len > i && unquoted_len > j; ++i, ++j)\n  {\n    if ('\\\\' == quoted[i])\n    {\n      i++; /* Advance to the next character */\n      if (quoted_len == i)\n        return false; /* No character after escaping backslash */\n    }\n    if (quoted[i] != unquoted[j])\n      return false; /* Different characters */\n  }\n  if ((quoted_len != i) || (unquoted_len != j))\n    return false; /* The strings have different length */\n\n  return true;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "MISRA C 2023 Rule 8.13 concerns how pointers are declared: a pointer type should point to a const-qualified object whenever the pointed-to object is not modified through that pointer. In is_param_equal_caseless the param->value.str object is only read: it is passed to MHD_str_equal_quoted_bin_n (which takes const char *) and to memcmp (which takes const void *). Therefore, if the struct member param->value.str is declared as a non-const pointer (e.g. char *str) that declaration would violate Rule 8.13 and the agent A's diagnosis is correct. If, however, param->value.str is already declared as const char * (or an equivalent const-qualified type), there is no Rule 8.13 violation. The snippet shown does not include the struct declaration, so a definite violation cannot be determined from the snippet alone, but the agent's conditional report is correct: a violation exists only when the member is declared non-const."
}