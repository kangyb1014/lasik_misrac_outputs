{
  "user_message": "An agent A claimed that the following is_param_equal_caseless code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of is_param_equal_caseless.\n```c\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThis fragment reads param->value.str but does not modify it; if the struct member is declared as a non-const pointer (e.g. char *value.str) then Rule 8.13 is violated because the pointer should be declared to point to a const-qualified type (const char *) when it is only used for read access. Note: if MHD_RqDAuthParam::value.str is already declared as const char * then there is no violation.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function is_param_equal_caseless:\nbool\nMHD_str_equal_quoted_bin_n (const char *quoted,\n                            size_t quoted_len,\n                            const char *unquoted,\n                            size_t unquoted_len)\n{\n  size_t i;\n  size_t j;\n  if (unquoted_len < quoted_len / 2)\n    return false;\n\n  j = 0;\n  for (i = 0; quoted_len > i && unquoted_len > j; ++i, ++j)\n  {\n    if ('\\\\' == quoted[i])\n    {\n      i++; /* Advance to the next character */\n      if (quoted_len == i)\n        return false; /* No character after escaping backslash */\n    }\n    if (quoted[i] != unquoted[j])\n      return false; /* Different characters */\n  }\n  if ((quoted_len != i) || (unquoted_len != j))\n    return false; /* The strings have different length */\n\n  return true;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The snippet shown does not itself prove a Rule 8.13 violation. Rule 8.13 concerns the declaration of pointers (they should point to const-qualified types where possible). The agent's argument is correct only if the struct member MHD_RqDAuthParam::value.str is declared as a non-const pointer (e.g. char *) and in fact the codebase never needs to modify the pointed-to characters. The target function only reads param->value.str (and param is a pointer to const struct, which makes the member itself non\u2011assignable but does not make the pointee const). Therefore you must inspect the declaration of MHD_RqDAuthParam::value.str (and the rest of the code: whether the pointee is ever modified). If value.str is declared as const char * (or the design requires writable pointees), there is no violation. Given only the provided code, there is insufficient evidence to declare a definite MISRA 8.13 violation, so the report as stated is not correct."
}