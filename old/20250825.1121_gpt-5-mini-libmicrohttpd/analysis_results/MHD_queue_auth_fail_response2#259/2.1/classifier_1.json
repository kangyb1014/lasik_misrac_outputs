{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_queue_auth_fail_response2:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_fail_response2 (struct MHD_Connection *connection,\n                               const char *realm,\n                               const char *opaque,\n                               struct MHD_Response *response,\n                               int signal_stale,\n                               enum MHD_DigestAuthAlgorithm algo)\n{\n  enum MHD_DigestAuthMultiAlgo3 algo3;\n\n  if (MHD_DIGEST_ALG_MD5 == algo)\n    algo3 = MHD_DIGEST_AUTH_MULT_ALGO3_MD5;\n  else if (MHD_DIGEST_ALG_SHA256 == algo)\n    algo3 = MHD_DIGEST_AUTH_MULT_ALGO3_SHA256;\n  else if (MHD_DIGEST_ALG_AUTO == algo)\n    algo3 = MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION;\n  else\n    MHD_PANIC (_ (\"Wrong algo value.\\n\")); /* API violation! */\n\n  return MHD_queue_auth_required_response3 (connection, realm, opaque,\n                                            NULL, response, signal_stale,\n                                            MHD_DIGEST_AUTH_MULT_QOP_AUTH,\n                                            algo3,\n                                            0, 0);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_queue_auth_fail_response2:\nenum MHD_DigestAuthAlgorithm\n{\n\n  /**\n   * MHD should pick (currently defaults to MD5).\n   */\n  MHD_DIGEST_ALG_AUTO = 0,\n\n  /**\n   * Force use of MD5.\n   */\n  MHD_DIGEST_ALG_MD5,\n\n  /**\n   * Force use of SHA-256.\n   */\n  MHD_DIGEST_ALG_SHA256\n\n}\n...\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_auth_required_response3 (struct MHD_Connection *connection,\n                                   const char *realm,\n                                   const char *opaque,\n                                   const char *domain,\n                                   struct MHD_Response *response,\n                                   int signal_stale,\n                                   enum MHD_DigestAuthMultiQOP mqop,\n                                   enum MHD_DigestAuthMultiAlgo3 malgo3,\n                                   int userhash_support,\n                                   int prefer_utf8)\n{\n  struct DigestAlgorithm da;\n  char *buf_ptr;\n  enum MHD_Result ret;\n\n  buf_ptr = NULL;\n  digest_setup_zero (&da);\n  ret = queue_auth_required_response3_inner (connection,\n                                             realm,\n                                             opaque,\n                                             domain,\n                                             response,\n                                             signal_stale,\n                                             mqop,\n                                             malgo3,\n                                             userhash_support,\n                                             prefer_utf8,\n                                             &buf_ptr,\n                                             &da);\n  digest_deinit (&da);\n  if (NULL != buf_ptr)\n    free (buf_ptr);\n  return ret;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the shown code. MHD_PANIC expands to a call to a non\u2011returning panic function plus a compiler intrinsic (BUILTIN_NOT_REACHED) that tells the compiler execution does not continue past that point. In MHD_queue_auth_fail_response2 it is used only in the else branch for an invalid enum value; the normal branches still reach the subsequent return, so there is no unreachable code in the project as shown. (A concrete violation would occur if MHD_PANIC were used unconditionally such that statements after it could never be reached on any control path, or if BUILTIN_NOT_REACHED were used in a way that made some code syntactically unreachable for all control flows.)"
}