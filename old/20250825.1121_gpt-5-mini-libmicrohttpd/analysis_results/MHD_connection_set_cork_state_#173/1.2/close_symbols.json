{
  "user_message": "Target function code is:\n```c\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_connection_set_cork_state_': {'callees': ['MHD_DLOG'], 'callers': []}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_TCP_CORK_NOPUSH",
    "MHD_SCKT_OPT_BOOL_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ENOPROTOOPT_",
    "MHD_SCKT_ENOTSOCK_",
    "_MHD_YES",
    "_MHD_UNKNOWN",
    "struct MHD_Connection (definition)",
    "setsockopt",
    "IPPROTO_TCP",
    "MHD_socket_get_error_",
    "MHD_socket_strerr_",
    "MHD_DLOG",
    "_ (gettext/localization macro)",
    "HAVE_MESSAGES",
    "TCP_CORK"
  ],
  "explanation": "For verifying whether the target function uses any language/compiler extensions you must inspect the definitions and expansions of all macros, typedefs and referenced types/funcs that affect compiled code. Each listed symbol is required for the following reasons:\n\n- MHD_TCP_CORK_NOPUSH: Controls conditional compilation of most of the function body. Its definition may be a complex macro or use compiler-specific constructs; you must know whether the body is actually compiled and whether the macro itself uses extensions.\n- MHD_SCKT_OPT_BOOL_: The type of on_val/off_val. Could be a typedef or macro that maps to a nonstandard or extension type (e.g., compiler-specific integer type or attribute usage). Inspecting it ensures no extension types or attributes are used.\n- MHD_SCKT_ERR_IS_: Macro/function used to test socket errors. Its definition may use macro tricks or extension constructs (statement expressions, typeof, GCC __extension__, etc.).\n- MHD_SCKT_EINVAL_, MHD_SCKT_ENOPROTOOPT_, MHD_SCKT_ENOTSOCK_: Error-code macros/constants; their definitions may hide enums, inline functions, or extension-dependent constructs.\n- _MHD_YES, _MHD_UNKNOWN: Values tested/assigned to connection->is_nonip. Their types/definitions are needed to determine whether nonstandard integer types or extensions are used for this status representation.\n- struct MHD_Connection (definition): The connection->is_nonip, socket_fd, sk_corked, daemon member types and any member attributes must be known. The struct definition could include compiler-specific attributes or bitfields/anonymous unions that are extensions.\n- setsockopt: Standard POSIX call used here; include to confirm prototype and ensure no unusual cast/usage relies on compiler extensions. The way it is called (casting pointer to const void *) should be validated against its prototype.\n- IPPROTO_TCP: The protocol constant used with setsockopt; included to confirm usage and that no extension is involved in its definition.\n- MHD_socket_get_error_: Called to obtain err_code; its implementation/definition might use extension constructs or nonstandard return types that affect the call here.\n- MHD_socket_strerr_: Used for error message formatting; its definition might use extension-heavy implementations (inline asm, statement expressions) or nonstandard attributes that must be inspected.\n- MHD_DLOG: Logging macro/function used in both branches. Logging macros are a common place to hide compiler extensions (variadic macro extensions, statement-expression macros, GCC attributes). Its expansion must be checked.\n- _ (gettext/localization macro): Commonly a macro that expands to gettext or similar; must be checked to ensure it does not use extensions (it could be defined as a function-like macro with GCC-specific constructs).\n- HAVE_MESSAGES: Controls compilation of logging branches. Need to know whether the log-containing branches are present and whether HAVE_MESSAGES or its dependent macros introduce extensions.\n- TCP_CORK: Controls the string passed to MHD_DLOG. Its presence/definition can change which branch is compiled; its own definition could be extension-bearing (less likely but must be checked).\n\nIn short: to determine whether any language extensions are used you must inspect the actual definitions/expansions of all macros, typedefs, struct members and helper functions referenced by this function. The symbols above are the minimal set that can affect compilation or hide possible compiler extensions in the target function."
}