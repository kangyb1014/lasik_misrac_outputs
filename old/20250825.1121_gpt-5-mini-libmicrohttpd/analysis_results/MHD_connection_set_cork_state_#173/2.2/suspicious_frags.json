{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_connection_set_cork_state_:\n```c\nbool\nMHD_connection_set_cork_state_ (struct MHD_Connection *connection,\n                                bool cork_state)\n{\n#if defined(MHD_TCP_CORK_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n  int err_code;\n\n  if (_MHD_YES == connection->is_nonip)\n    return false;\n  if (0 == setsockopt (connection->socket_fd,\n                       IPPROTO_TCP,\n                       MHD_TCP_CORK_NOPUSH,\n                       (const void *) (cork_state ? &on_val : &off_val),\n                       sizeof (off_val)))\n  {\n    connection->sk_corked = cork_state;\n    return true;\n  }\n\n  err_code = MHD_socket_get_error_ ();\n  if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */\n\n#else  /* ! MHD_TCP_CORK_NOPUSH */\n  (void) connection; (void) cork_state; /* Mute compiler warnings. */\n#endif /* ! MHD_TCP_CORK_NOPUSH */\n  return false;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_connection_set_cork_state_:\n#define MHD_TCP_CORK_NOPUSH TCP_CORK\n...\n#define HAVE_MESSAGES 1\n...\ntypedef int MHD_SCKT_OPT_BOOL_\n...\n#define MHD_socket_get_error_ (errno)\n...\n#define MHD_SCKT_ERR_IS_(err, code) ((MHD_SCKT_MISSING_ERR_CODE_!=(code))&&((code)==(err)))\n...\n#define MHD_SCKT_EINVAL_ EINVAL\n...\n#define MHD_SCKT_ENOPROTOOPT_ ENOPROTOOPT\n...\n#define MHD_SCKT_ENOTSOCK_ ENOTSOCK\n...\n#define MHD_socket_strerr_(err) strerror((err))\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_EINVAL_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOPROTOOPT_) ||\n      MHD_SCKT_ERR_IS_ (err_code, MHD_SCKT_ENOTSOCK_))\n  {\n    if (_MHD_UNKNOWN == connection->is_nonip)\n      connection->is_nonip = _MHD_YES;\n#ifdef HAVE_MESSAGES\n    else\n    {\n      MHD_DLOG (connection->daemon,\n                _ (\"Setting %s option to %s state failed \"\n                   \"for TCP/IP socket %d: %s\\n\"),\n#ifdef TCP_CORK\n                \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n                \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n                cork_state ? _ (\"ON\") : _ (\"OFF\"),\n                (int) connection->socket_fd,\n                MHD_socket_strerr_ (err_code));\n    }\n#endif /* HAVE_MESSAGES */\n  }",
    "err_code = MHD_socket_get_error_ ();",
    "#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Setting %s option to %s state failed: %s\\n\"),\n#ifdef TCP_CORK\n              \"TCP_CORK\",\n#else  /* ! TCP_CORK */\n              \"TCP_NOPUSH\",\n#endif /* ! TCP_CORK */\n              cork_state ? _ (\"ON\") : _ (\"OFF\"),\n              MHD_socket_strerr_ (err_code));\n  }\n#endif /* HAVE_MESSAGES */",
    "(void) connection; (void) cork_state; /* Mute compiler warnings. */",
    "if (_MHD_YES == connection->is_nonip)\n    return false;"
  ],
  "explanation": "I selected fragments that are likely to be no-op or could make other code effectively dead and therefore should be investigated for MISRA Rule 2.2: the early guard (if (_MHD_YES == connection->is_nonip) return false;) can render the remainder of the function dead for some configurations; the err_code retrieval line is suspicious (the provided macro definition of MHD_socket_get_error_ looks like a non-function macro, which may make this expression ill-formed or a no-op after preprocessing); the assignment to connection->is_nonip and its surrounding conditional can be redundant depending on the variable's possible values at runtime; both MHD_DLOG invocation blocks are runtime logging calls that may be compiled in but always be no-ops (e.g. if daemon->options never enables logging), which would constitute dead operations; and the (void) casts in the #else branch are explicit no-op statements present solely to silence warnings and thus are candidates for dead code. Other fragments were not listed because they perform observable operations that affect program behaviour (e.g. the setsockopt() call and the connection->sk_corked = cork_state assignment), or are initializations which per MISRA note 3 are not candidates for dead code, or are preprocessor selection constructs that do not by themselves constitute executed dead code. If further context shows that any of the reported fragments are in fact always effective (for example logging is actually enabled at runtime), they may be cleared on closer inspection."
}