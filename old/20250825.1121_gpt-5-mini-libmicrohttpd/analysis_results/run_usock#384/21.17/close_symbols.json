{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "snprintf",
    "struct WsData (definition)"
  ],
  "explanation": "Required symbols and why they are needed for MISRA <string.h> bounds analysis:\n\n1) ws_receive_frame\n   - run_usock passes the returned msg to \"%s\" in snprintf. To determine whether using %s can read past msg's allocated bounds (a violation equivalent to using string functions out-of-bounds), we must know how ws_receive_frame constructs and sizes msg: whether it NUL\u2011terminates the payload, what length it reports via the got/out parameters, and whether it uses memcpy/strlen/strncpy/etc. Internals of ws_receive_frame are essential.\n\n2) ws_send_frame\n   - run_usock calls ws_send_frame with text (formatted string). ws_send_frame may itself use string.h functions (memcpy, strlen, etc.) or call send_all with buffers derived from its arguments. To prove no string.h bound violations occur in the overall call chain, we must inspect ws_send_frame implementation.\n\n3) send_all\n   - send_all appears in the static call graph as a helper used by ws_send_frame. It may assemble buffers or copy data (e.g., with memcpy) and those copy operations must be checked for correct lengths. If send_all miscomputes sizes it could cause out-of-bounds string operations; therefore its implementation is needed.\n\n4) snprintf\n   - Although snprintf is in <stdio.h>, run_usock uses snprintf(NULL,0,...) to compute buf_size and then snprintf to write into the malloc'd buffer. To verify that this use cannot cause reads beyond msg (via \"%s\") and that the allocated size is correct, the precise semantics and return-value interpretation of snprintf must be considered (i.e., what snprintf(NULL,0,...) returns, whether the later snprintf writes exactly buf_size bytes plus NUL). Any assumptions about snprintf behavior must be validated.\n\n5) struct WsData (definition)\n   - The structure definition reveals the types of ws->sock and ws->urh and whether any other fields/constraints affect the lifetime/ownership/size of returned message buffers. It also helps trace whether ws_receive_frame/ ws_send_frame rely on other WsData fields that influence buffer sizes or termination.\n\nOptional but potentially useful symbols (include if available): WS_OPCODE_TEXT_FRAME and WS_OPCODE_CON_CLOSE_FRAME (to confirm control flow), and any helper functions called by ws_receive_frame/ws_send_frame/send_all that perform memory/string operations. Without the implementations listed above, you cannot reliably determine whether any string.h functions are being used out-of-bounds in the run_usock call chain."
}