{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MAX_CLIENTS",
    "CLIENT_SOCKS",
    "MHD_INVALID_SOCKET",
    "struct WsData",
    "ws_receive_frame (signature and behavior)",
    "WS_OPCODE_TEXT_FRAME",
    "WS_OPCODE_CON_CLOSE_FRAME",
    "MUTEX",
    "recv"
  ],
  "explanation": "Explain why each symbol is required to determine whether any controlling expression is invariant:\n\n- MAX_CLIENTS\n  Reason: Used in the for-loop controlling expression (i < MAX_CLIENTS). If MAX_CLIENTS is a constant value (for example 0) the loop condition could be invariant (always false). Knowing its definition/value is required to decide if the for-loop violates the rule.\n\n- CLIENT_SOCKS\n  Reason: The for-loop body inspects CLIENT_SOCKS[i] to find an entry to clear. The array contents or its initialisation do not directly change the loop condition, but knowledge of its declaration/size can clarify interactions with MAX_CLIENTS and whether the loop is intended or degenerate.\n\n- MHD_INVALID_SOCKET\n  Reason: Assigned to CLIENT_SOCKS[i] inside the loop. If this value has special semantics (e.g. equals a compile-time constant that affects array initialisation or loop invariance), it matters for reasoning about whether the loop condition or related logic is effectively invariant.\n\n- struct WsData\n  Reason: The function treats cls as struct WsData * and reads ws->sock and ws->urh. Knowing the struct layout and types (in particular the type and volatility of sock and urh) is necessary to determine whether expressions that use these fields (e.g. comparisons, snprintf arguments, or whether sock can change asynchronously) can be treated as invariant.\n\n- ws_receive_frame (signature and behavior)\n  Reason: This function is called as msg = ws_receive_frame(buf, &got, &type). The analysis of controlling expressions that compare got and type depends on whether ws_receive_frame actually modifies got and type at runtime. Its prototype and behavior (does it write to the supplied got and type, can it return NULL, does it block, etc.) are required to determine if subsequent tests (if (0 >= got), if (NULL == msg), and if (type == WS_OPCODE_TEXT_FRAME)) are invariant.\n\n- WS_OPCODE_TEXT_FRAME\n  Reason: Used as the RHS of if (type == WS_OPCODE_TEXT_FRAME). To know whether that comparison can be invariant you must know the symbolic value (macro/enum) and confirm that type is not a compile-time constant; combined with knowledge about ws_receive_frame, this ensures the test is not invariant.\n\n- WS_OPCODE_CON_CLOSE_FRAME\n  Reason: Used in the alternative branch comparison (if (type == WS_OPCODE_CON_CLOSE_FRAME)). Same rationale as above: the constant value itself and whether type can vary at runtime affect whether the controlling expression is invariant.\n\n- MUTEX\n  Reason: Passed to pthread_mutex_lock/unlock and compared against 0. While not a loop condition, the comparisons (if (0 != pthread_mutex_lock(&MUTEX))) use the return value of the lock call as a controlling expression; knowing MUTEX (and lock semantics) helps show these expressions are not compile-time invariant.\n\n- recv\n  Reason: The initial loop depends on got = recv(ws->sock, buf, sizeof(buf), 0); then if (0 >= got) breaks. To rule out invariance of that controlling expression you must assume standard runtime behavior of recv (i.e. its return value is not a compile-time constant). Explicit knowledge of recv (or any wrapper) ensures the test is not an invariant constant expression.\n\nNotes:\n- The literal while (1) is an invariant controlling expression but is covered by the MISRA exception permitting invariants that create infinite loops; the surrounding code contains breaks that exit the loop, which must be considered but does not remove the exception. The symbols above are the ones needed to confirm that the other controlling expressions (for-loop, if-tests) are not compile-time invariant."
}