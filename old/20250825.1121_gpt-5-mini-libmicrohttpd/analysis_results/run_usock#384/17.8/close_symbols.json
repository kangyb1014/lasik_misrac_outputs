{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "struct MHD_UpgradeResponseHandle",
    "make_blocking",
    "ws_receive_frame",
    "ws_send_frame",
    "send_all",
    "MHD_upgrade_action",
    "recv",
    "malloc",
    "snprintf",
    "free",
    "pthread_mutex_lock",
    "pthread_mutex_unlock",
    "MUTEX",
    "CLIENT_SOCKS",
    "MAX_CLIENTS",
    "MHD_INVALID_SOCKET",
    "abort"
  ],
  "explanation": "For checking the MISRA rule about modifying a function parameter (cls) you must ensure the parameter variable itself is never written to (e.g. assigned or altered via passed-by-reference). The listed symbols are required for that analysis for these reasons:\n\n- struct WsData: needed to confirm the type of cls (void * cast to struct WsData *) and to see if any member access or aliasing could implicitly change the pointer value or reveal unusual attributes (e.g. const qualifiers).\n- struct MHD_UpgradeResponseHandle: used via ws->urh and passed to MHD_upgrade_action; include to ensure no macro/prototype manipulates the caller's cls pointer.\n- make_blocking: callee; include prototype/definition to confirm it cannot modify run_usock's local parameter (e.g. via macros or unexpected signature taking &cls).\n- ws_receive_frame: callee that returns msg; include to ensure its declaration/signature cannot indirectly modify cls (e.g. by taking pointers to caller locals) and to check for macro expansions.\n- ws_send_frame: callee; include to verify it does not accept/modify the run_usock parameter by reference or via macro side-effects.\n- send_all: included because ws_send_frame calls it (in static call graph); its prototype/definition is needed to ensure no unexpected modification to caller state.\n- MHD_upgrade_action: callee; include prototype/definition to ensure it cannot modify the local parameter variable (through macros or unexpected calling conventions).\n- recv: standard library/socket call used on ws->sock; include to confirm it cannot affect the local parameter variable (defensive check for nonstandard macros).\n- malloc, snprintf, free: stdlib functions called here; include to rule out any macro redefinitions that might modify cls.\n- pthread_mutex_lock, pthread_mutex_unlock: used around CLIENT_SOCKS mutation; include to ensure no macro redefinition modifies the function parameter.\n- MUTEX: global used with pthread mutex calls; include to check for any macro or aliasing that could reference or modify 'cls'.\n- CLIENT_SOCKS, MAX_CLIENTS, MHD_INVALID_SOCKET: globals used/modified here; include to determine if any of those are implemented as macros or constructs that could reference/modify the local parameter.\n- abort: error path called on mutex failure; include to rule out any strange macro that could alter local parameters.\n\nIn short: include the struct/type definitions and the prototypes/definitions (or macro definitions) of every callee and every global/macro used in run_usock. This lets the next analyzer verify there are no hidden macro expansions or function signatures that could modify the function parameter 'cls' (either directly or by being passed its address)."
}