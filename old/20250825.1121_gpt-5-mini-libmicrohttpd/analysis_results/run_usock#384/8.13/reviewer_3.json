{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'urh' is declared as a non-const pointer (struct MHD_UpgradeResponseHandle *urh = ws->urh;) even though run_usock does not modify the pointed object \u2014 it only passes it to MHD_upgrade_action at the end. If the function(s) that use 'urh' do not modify the object, the pointer should be to a const-qualified type (e.g. const struct MHD_UpgradeResponseHandle *urh) and therefore the current code violates MISRA C 2023 Rule 8.13. (If, however, MHD_upgrade_action or other uses require a non-const pointer, then making it const would be impossible and no violation would occur.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function run_usock:\nstruct WsData\n{\n  struct MHD_UpgradeResponseHandle *urh;\n  MHD_socket sock;\n}\n...\nstruct MHD_UpgradeResponseHandle\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "MISRA C:2023 R8.13 says a pointer should point to a const-qualified type whenever possible (i.e. when the pointee will not be modified). In the snippet run_usock the local urh is not dereferenced or modified in this function, so purely from the body of run_usock one could make urh a pointer-to-const (const struct MHD_UpgradeResponseHandle *urh = ws->urh). However, whether that change is actually possible depends on the uses of urh outside run_usock \u2014 in particular the prototype of MHD_upgrade_action. If MHD_upgrade_action expects a non-const pointer (e.g. MHD_upgrade_action(struct MHD_UpgradeResponseHandle *, ...)) then urh cannot be made const without causing an incompatible-pointer-type/const-discard when calling that function, and keeping it non-const is necessary and compliant. The supplied code does not show the prototype of MHD_upgrade_action; therefore you cannot conclude a definite MISRA violation from the fragment alone. In short: the report is not conclusively correct. If the external API actually takes a const-qualified pointer, then the local declaration should be changed; if it takes a non-const pointer (as is likely for this API), no violation occurs."
}