{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct WsData *ws = cls;\n  struct MHD_UpgradeResponseHandle *urh = ws->urh;\n  unsigned char buf[2048];\n  unsigned char *msg;\n  char *text;\n  ssize_t got;\n  int type;\n  int i;\n\n  make_blocking (ws->sock);\n  while (1)\n  {\n    got = recv (ws->sock, (void *) buf, sizeof (buf), 0);\n    if (0 >= got)\n    {\n      break;\n    }\n    msg = ws_receive_frame (buf, &got, &type);\n    if (NULL == msg)\n    {\n      break;\n    }\n    if (type == WS_OPCODE_TEXT_FRAME)\n    {\n      ssize_t sent;\n      int buf_size;\n      buf_size = snprintf (NULL, 0, \"User#%d: %s\", (int) ws->sock, msg);\n      if (0 < buf_size)\n      {\n        text = malloc ((size_t) buf_size + 1);\n        if (NULL != text)\n        {\n          if (snprintf (text, (size_t) buf_size + 1,\n                        \"User#%d: %s\", (int) ws->sock, msg) == buf_size)\n            sent = ws_send_frame (ws->sock, text, (size_t) buf_size);\n          else\n            sent = -1;\n          free (text);\n        }\n        else\n          sent = -1;\n      }\n      else\n        sent = -1;\n      free (msg);\n      if (-1 == sent)\n      {\n        break;\n      }\n    }\n    else\n    {\n      if (type == WS_OPCODE_CON_CLOSE_FRAME)\n      {\n        free (msg);\n        break;\n      }\n    }\n  }\n  if (0 != pthread_mutex_lock (&MUTEX))\n    abort ();\n  for (i = 0; i < MAX_CLIENTS; i++)\n  {\n    if (CLIENT_SOCKS[i] == ws->sock)\n    {\n      CLIENT_SOCKS[i] = MHD_INVALID_SOCKET;\n      break;\n    }\n  }\n  if (0 != pthread_mutex_unlock (&MUTEX))\n    abort ();\n  free (ws);\n  MHD_upgrade_action (urh, MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct WsData",
    "ws_receive_frame (prototype)",
    "ws_send_frame (prototype)",
    "send_all (prototype)",
    "make_blocking (prototype)",
    "struct MHD_UpgradeResponseHandle",
    "MHD_upgrade_action (prototype)"
  ],
  "explanation": "To decide whether run_usock violates the MISRA C rule that pointers should point to const-qualified types whenever possible we must know the exact types and ownership/usage semantics of the pointers passed into and returned from called routines and the types of the struct fields accessed in this function:\n\n- struct WsData: needed to know the declared types (and any const qualifiers) of ws->urh and ws->sock and any other pointer fields. If ws->urh or other fields are already const-qualified, or if their declared types force non-const, that affects whether run_usock should use const pointers.\n\n- ws_receive_frame (prototype): this function is passed buf (unsigned char[]) and returns msg. We must know the const-qualification of its parameter and return type and whether the returned buffer is owned by the caller (caller must free). If ws_receive_frame could/should take a const unsigned char * or return const unsigned char *, that impacts whether buf/msg in run_usock could be const.\n\n- ws_send_frame (prototype): it is called with text (char *). We need to know whether its buffer parameter is declared const (e.g. const char *) or non-const; that determines whether text could/should be const in run_usock.\n\n- send_all (prototype): ws_send_frame calls send_all (and the static graph links send_all). The exact signature of send_all (whether it takes a const buffer pointer) influences whether higher-level APIs (ws_send_frame and run_usock) should accept const-qualified pointers for data to send.\n\n- make_blocking (prototype): while less likely to involve const pointers, its parameter types confirm whether socket parameters or any pointer parameters in the call chain require or prohibit const qualification.\n\n- struct MHD_UpgradeResponseHandle: needed to know whether urh (set from ws->urh) has any const qualification in its type and whether passing urh to MHD_upgrade_action requires dropping/adding const. This affects whether ws->urh/urh should be const in WsData/run_usock.\n\n- MHD_upgrade_action (prototype): to see whether it expects a const or non-const pointer for its first parameter. If it accepts a const pointer, run_usock could keep urh const; if it requires non-const, run_usock cannot make urh const.\n\nTogether these symbols provide the declarations and ownership semantics required to determine which pointer variables in run_usock could or should be declared to point to const-qualified types without violating API requirements or memory ownership (e.g. freeing)."
}