{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of check_apply_param__threads:\n```c\nstatic void\ncheck_apply_param__threads (void)\n{\n  if (0 == tool_params.threads)\n    return;\n\n  num_threads = tool_params.threads;\n\n  if (get_process_cpu_core_count () < num_threads)\n  {\n    fprintf (stderr, \"WARNING: The requested number of threads (%u) is \"\n             \"higher than the number of detected available CPU cores (%u).\\n\",\n             num_threads, get_process_cpu_core_count ());\n    fprintf (stderr, \"This decreases the performance. \"\n             \"Consider using fewer threads.\\n\");\n  }\n  if (get_cpu_core_count () == num_threads)\n  {\n    printf (\"The requested number of threads is equal to the number of \"\n            \"detected CPU cores.\\n\");\n    print_all_cores_used ();\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function check_apply_param__threads:\nstatic struct PerfRepl_parameters tool_params = {\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n}\n...\nstatic unsigned int num_threads = 0\n...\nstatic unsigned int\nget_process_cpu_core_count (void)\n{\n  static unsigned int proc_num_cpu_cores = 0;\n  if (0 == proc_num_cpu_cores)\n    proc_num_cpu_cores = detect_process_cpu_core_count ();\n  return proc_num_cpu_cores;\n}\n...\nstatic unsigned int\ndetect_process_cpu_core_count (void)\n{\n  unsigned int num_proc_cpu_cores;\n  unsigned int sys_cpu_cores;\n  int res;\n\n  sys_cpu_cores = get_cpu_core_count ();\n  res = mhd_tool_get_proc_cpu_count ();\n  if (0 > res)\n  {\n    fprintf (stderr, \"Cannot detect the number of logical CPU cores available \"\n             \"for this process.\\n\");\n    if (1 != sys_cpu_cores)\n      printf (\"Assuming all %u system logical CPU cores are available to run \"\n              \"threads of this process.\\n\", sys_cpu_cores);\n    else\n      printf (\"Assuming single logical CPU core available for this process.\\n\");\n    num_proc_cpu_cores = sys_cpu_cores;\n  }\n  else\n  {\n    printf (\"Detected %d logical CPU core%s available to run threads \"\n            \"of this process.\\n\", res, (1 == res) ? \"\" : \"s\");\n    num_proc_cpu_cores = (unsigned int) res;\n  }\n  if (num_proc_cpu_cores > sys_cpu_cores)\n  {\n    fprintf (stderr, \"WARNING: Detected number of CPU cores available \"\n             \"for this process (%u) is larger than detected number \"\n             \"of CPU cores on the system (%u).\\n\",\n             num_proc_cpu_cores, sys_cpu_cores);\n    num_proc_cpu_cores = sys_cpu_cores;\n    fprintf (stderr, \"Using %u as the number of logical CPU cores available \"\n             \"for this process.\\n\", num_proc_cpu_cores);\n  }\n  return num_proc_cpu_cores;\n}\n...\nstatic unsigned int\nget_cpu_core_count (void)\n{\n  static unsigned int num_cpu_cores = 0;\n  if (0 == num_cpu_cores)\n    num_cpu_cores = detect_cpu_core_count ();\n  return num_cpu_cores;\n}\n...\nstatic unsigned int\ndetect_cpu_core_count (void)\n{\n  int sys_cpu_count;\n  sys_cpu_count = mhd_tool_get_system_cpu_count ();\n  if (0 >= sys_cpu_count)\n  {\n    int proc_cpu_count;\n    fprintf (stderr, \"Failed to detect the number of logical CPU cores \"\n             \"available on the system.\\n\");\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (0 < proc_cpu_count)\n    {\n      fprintf (stderr, \"The number of CPU cores available for this process \"\n               \"is used as a fallback.\\n\");\n      sys_cpu_count = proc_cpu_count;\n    }\n#ifdef MHD_REAL_CPU_COUNT\n    if (0 >= sys_cpu_count)\n    {\n      fprintf (stderr, \"configure-detected hardcoded number is used \"\n               \"as a fallback.\\n\");\n      sys_cpu_count = MHD_REAL_CPU_COUNT;\n    }\n#endif\n    if (0 >= sys_cpu_count)\n      sys_cpu_count = 1;\n    printf (\"Assuming %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  else\n  {\n    printf (\"Detected %d logical CPU core%s on this system.\\n\", sys_cpu_count,\n            (1 == sys_cpu_count) ? \"\" : \"s\");\n  }\n  return (unsigned int) sys_cpu_count;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 == num_cpu_cores)\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation \u2014 the controlling expression \"0 == num_cpu_cores\" is not invariant. num_cpu_cores is a local static variable initialized to 0 and is assigned detect_cpu_core_count() on the first call, so the expression can evaluate true initially and false on subsequent calls (lazy initialization)."
}