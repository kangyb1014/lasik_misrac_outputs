{
  "user_message": "An agent A claimed that the following MHD_poll code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_poll.\n```c\nstatic enum MHD_Result\nMHD_poll (struct MHD_Daemon *daemon,\n          int may_block)\n{\n  if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n    return MHD_poll_all (daemon,\n                         may_block ? -1 : 0);\n  return MHD_poll_listen_socket (daemon,\n                                 may_block);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'struct MHD_Daemon *daemon' is not const-qualified but the fragment only shows it being used in a read-only test (MHD_D_IS_USING_THREAD_PER_CONN_(daemon)) and then passed to other routines. If MHD_poll and the called helpers (MHD_poll_all, MHD_poll_listen_socket) do not modify the pointed-to object, the parameter should be declared as 'const struct MHD_Daemon *daemon' (and the macro/signatures adjusted accordingly). In that case the current code violates Rule 8.13 because a pointer that can point to a const-qualified type is not declared const.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not proven by the fragment. MISRA C 2023 Rule 8.13 recommends that pointers should point to const-qualified types when possible, but whether a violation exists depends on whether the pointed-to object is actually modified (directly or via called routines or macros). In the shown snippet MHD_poll only reads the daemon via MHD_D_IS_USING_THREAD_PER_CONN_ and then passes the pointer to MHD_poll_all / MHD_poll_listen_socket. Those callees (and the macro) might legitimately modify the daemon, or their signatures may require a non-const pointer for API compatibility. Since the provided code fragment does not show the implementations or prototypes of MHD_poll_all, MHD_poll_listen_socket, or the macro, you cannot conclude that the parameter should be const. To confirm a violation you must inspect the declarations/definitions of the macro and the two functions (and any uses that might perform non-const operations or casts). If those routines do not modify the object and their prototypes accept a const pointer, then changing the parameter to const would be appropriate and the rule would be breached in the current code; otherwise the report is incorrect."
}