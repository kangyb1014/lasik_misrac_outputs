{
  "user_message": "Target function code is:\n```c\nstatic bool\ntry_grow_read_buffer (struct MHD_Connection *connection,\n                      bool required)\n{\n  size_t new_size;\n  size_t avail_size;\n  const size_t def_grow_size = connection->daemon->pool_increment;\n  void *rb;\n\n  avail_size = MHD_pool_get_free (connection->pool);\n  if (0 == avail_size)\n    return false;               /* No more space available */\n  if (0 == connection->read_buffer_size)\n    new_size = avail_size / 2;  /* Use half of available buffer for reading */\n  else\n  {\n    size_t grow_size;\n\n    grow_size = avail_size / 8;\n    if (def_grow_size > grow_size)\n    {                  /* Shortage of space */\n      const size_t left_free =\n        connection->read_buffer_size - connection->read_buffer_offset;\n      mhd_assert (connection->read_buffer_size >= \\\n                  connection->read_buffer_offset);\n      if ((def_grow_size <= grow_size + left_free)\n          && (left_free < def_grow_size))\n        grow_size = def_grow_size - left_free;  /* Use precise 'def_grow_size' for new free space */\n      else if (! required)\n        return false;                           /* Grow is not mandatory, leave some space in pool */\n      else\n      {\n        /* Shortage of space, but grow is mandatory */\n        const size_t small_inc =\n          ((MHD_BUF_INC_SIZE > def_grow_size) ?\n           def_grow_size : MHD_BUF_INC_SIZE) / 8;\n        if (small_inc < avail_size)\n          grow_size = small_inc;\n        else\n          grow_size = avail_size;\n      }\n    }\n    new_size = connection->read_buffer_size + grow_size;\n  }\n  /* Make sure that read buffer will not be moved */\n  if ((NULL != connection->read_buffer) &&\n      ! MHD_pool_is_resizable_inplace (connection->pool,\n                                       connection->read_buffer,\n                                       connection->read_buffer_size))\n  {\n    mhd_assert (0);\n    return false;\n  }\n  /* we can actually grow the buffer, do it! */\n  rb = MHD_pool_reallocate (connection->pool,\n                            connection->read_buffer,\n                            connection->read_buffer_size,\n                            new_size);\n  if (NULL == rb)\n  {\n    /* This should NOT be possible: we just computed 'new_size' so that\n       it should fit. If it happens, somehow our read buffer is not in\n       the right position in the pool, say because someone called\n       MHD_pool_allocate() without 'from_end' set to 'true'? Anyway,\n       should be investigated! (Ideally provide all data from\n       *pool and connection->read_buffer and new_size for debugging). */\n    mhd_assert (0);\n    return false;\n  }\n  mhd_assert (connection->read_buffer == rb);\n  connection->read_buffer = rb;\n  mhd_assert (NULL != connection->read_buffer);\n  connection->read_buffer_size = new_size;\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'MHD_pool_get_free': {'callees': [], 'callers': ['try_ready_chunked_body', 'try_grow_read_buffer', 'connection_maximize_write_buffer']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'check_and_grow_read_buffer_space': {'callees': ['try_grow_read_buffer', 'has_unprocessed_upload_body_data_in_buffer', 'handle_recv_no_space'], 'callers': ['MHD_connection_update_event_loop_info']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_pool_get_free",
    "MHD_pool_is_resizable_inplace",
    "MHD_pool_reallocate",
    "MHD_BUF_INC_SIZE",
    "struct MHD_Connection",
    "type of connection->daemon (e.g. struct MHD_Daemon) and its pool_increment",
    "type/definition of connection->pool (pool object)",
    "type/definition of connection->read_buffer",
    "definition/typedef of bool (stdbool.h or local typedef/_Bool)"
  ],
  "explanation": "Each listed symbol can hide compiler-specific language extensions or nonstandard constructs that would make the target function violate the MISRA rule banning language extensions. Explaination per symbol:\n\n- mhd_assert: This is a macro; its expansion may use compiler extensions (statement-expressions, __builtin_expect, __attribute__, inline asm, or other nonstandard features). You must inspect its definition to verify it uses only standard C.\n\n- MHD_pool_get_free: The prototype/definition may include nonstandard attributes, calling conventions, or be implemented as a macro using extensions. Its signature/definition is needed to check for extensions used in its declaration or implementation.\n\n- MHD_pool_is_resizable_inplace: Same rationale as above \u2014 its declaration/implementation may use compiler-specific attributes or macros (inline, __attribute__, typeof, statement expressions), so the symbol must be examined.\n\n- MHD_pool_reallocate: The reallocator's declaration/definition could employ extensions (special attributes, nonstandard memory allocation annotations, inline asm, or be a macro using GCC extensions). The code calls it and depends on its prototype/definition.\n\n- MHD_BUF_INC_SIZE: This macro constant may be defined via complex macros that use language extensions (e.g. typeof, statement-expression macros). Its definition must be checked to ensure it's pure standard C.\n\n- struct MHD_Connection: The struct definition (and any annotations on it) is required because the field types, bit-fields, anonymous unions/structs, packed/attribute annotations, or other nonstandard constructs could be present in the type declaration itself.\n\n- type of connection->daemon (e.g. struct MHD_Daemon) and its pool_increment: The daemon type and pool_increment member definition are required to verify that pool_increment is a standard integer type and that the daemon struct does not use nonstandard features/attributes.\n\n- type/definition of connection->pool (pool object): The pool object type might have nonstandard annotations or macros associated with allocation/reallocation helper functions; its definition and related macros must be inspected for extensions.\n\n- type/definition of connection->read_buffer: The buffer pointer type or its associated annotations (e.g. attributes for placement, alignment, or special storage) might be declared using extensions; check its definition.\n\n- definition/typedef of bool (stdbool.h or local typedef/_Bool): The use of 'bool' may be provided via stdbool.h (standard since C99) or via a nonstandard typedef or macro. To determine if 'bool' in this codebase is a compiler extension, inspect how it is defined/introduced.\n\nTogether these symbols cover macros, type definitions and called functions used by try_grow_read_buffer that are the most likely places where compiler-specific language extensions could be introduced. Inspecting their definitions will allow a conclusive determination whether the function (or the constructs it relies on) uses any compiler extensions."
}