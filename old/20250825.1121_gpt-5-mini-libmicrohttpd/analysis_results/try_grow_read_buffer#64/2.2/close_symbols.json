{
  "user_message": "Target function code is:\n```c\nstatic bool\ntry_grow_read_buffer (struct MHD_Connection *connection,\n                      bool required)\n{\n  size_t new_size;\n  size_t avail_size;\n  const size_t def_grow_size = connection->daemon->pool_increment;\n  void *rb;\n\n  avail_size = MHD_pool_get_free (connection->pool);\n  if (0 == avail_size)\n    return false;               /* No more space available */\n  if (0 == connection->read_buffer_size)\n    new_size = avail_size / 2;  /* Use half of available buffer for reading */\n  else\n  {\n    size_t grow_size;\n\n    grow_size = avail_size / 8;\n    if (def_grow_size > grow_size)\n    {                  /* Shortage of space */\n      const size_t left_free =\n        connection->read_buffer_size - connection->read_buffer_offset;\n      mhd_assert (connection->read_buffer_size >= \\\n                  connection->read_buffer_offset);\n      if ((def_grow_size <= grow_size + left_free)\n          && (left_free < def_grow_size))\n        grow_size = def_grow_size - left_free;  /* Use precise 'def_grow_size' for new free space */\n      else if (! required)\n        return false;                           /* Grow is not mandatory, leave some space in pool */\n      else\n      {\n        /* Shortage of space, but grow is mandatory */\n        const size_t small_inc =\n          ((MHD_BUF_INC_SIZE > def_grow_size) ?\n           def_grow_size : MHD_BUF_INC_SIZE) / 8;\n        if (small_inc < avail_size)\n          grow_size = small_inc;\n        else\n          grow_size = avail_size;\n      }\n    }\n    new_size = connection->read_buffer_size + grow_size;\n  }\n  /* Make sure that read buffer will not be moved */\n  if ((NULL != connection->read_buffer) &&\n      ! MHD_pool_is_resizable_inplace (connection->pool,\n                                       connection->read_buffer,\n                                       connection->read_buffer_size))\n  {\n    mhd_assert (0);\n    return false;\n  }\n  /* we can actually grow the buffer, do it! */\n  rb = MHD_pool_reallocate (connection->pool,\n                            connection->read_buffer,\n                            connection->read_buffer_size,\n                            new_size);\n  if (NULL == rb)\n  {\n    /* This should NOT be possible: we just computed 'new_size' so that\n       it should fit. If it happens, somehow our read buffer is not in\n       the right position in the pool, say because someone called\n       MHD_pool_allocate() without 'from_end' set to 'true'? Anyway,\n       should be investigated! (Ideally provide all data from\n       *pool and connection->read_buffer and new_size for debugging). */\n    mhd_assert (0);\n    return false;\n  }\n  mhd_assert (connection->read_buffer == rb);\n  connection->read_buffer = rb;\n  mhd_assert (NULL != connection->read_buffer);\n  connection->read_buffer_size = new_size;\n  return true;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'MHD_pool_get_free': {'callees': [], 'callers': ['try_ready_chunked_body', 'try_grow_read_buffer', 'connection_maximize_write_buffer']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'check_and_grow_read_buffer_space': {'callees': ['try_grow_read_buffer', 'has_unprocessed_upload_body_data_in_buffer', 'handle_recv_no_space'], 'callers': ['MHD_connection_update_event_loop_info']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct MHD_Daemon",
    "struct MHD_Pool (or pool implementation)",
    "MHD_pool_get_free",
    "MHD_pool_reallocate",
    "MHD_pool_is_resizable_inplace",
    "mhd_assert",
    "MHD_BUF_INC_SIZE",
    "check_and_grow_read_buffer_space"
  ],
  "explanation": "For determining whether any operations in try_grow_read_buffer are dead code (i.e. executed but could be removed without affecting program behaviour) the next agent needs precise information about all inputs, side-effects and compile-time configuration that govern the function's control flow. Each listed symbol is required for the reasons below:\n\n- struct MHD_Connection\n  - The function indexes several members (read_buffer, read_buffer_size, read_buffer_offset, pool, daemon). You must know their types, ranges, invariants (e.g. read_buffer_offset <= read_buffer_size), and whether any fields are fixed or can vary at runtime to decide if branches (left_free calculations, checks, and reallocation) can actually be taken.\n\n- struct MHD_Daemon\n  - The field pool_increment (used as def_grow_size) directly affects grow_size/new_size decisions. Knowing allowed values/constraints for pool_increment is necessary to decide if branches depending on def_grow_size are reachable or redundant.\n\n- struct MHD_Pool (or pool implementation)\n  - The pool object (connection->pool) is the subject of MHD_pool_get_free, MHD_pool_reallocate and MHD_pool_is_resizable_inplace. The pool implementation documents semantics and invariants (e.g. whether allocations are from_end, whether allocations can move existing allocations, maximum free size behavior) which influence whether certain conditions/branches (e.g. rb == NULL, is_resizable_inplace returning false) can occur in practice.\n\n- MHD_pool_get_free\n  - The function returns avail_size which gates most of the early control flow (immediate return when 0, magnitude influences new_size/grow_size choices). To prove a branch is dead you must know possible return values and whether particular return values (e.g. 0) can occur at call sites.\n\n- MHD_pool_reallocate\n  - Used to actually grow the buffer and can return NULL or a different pointer. You need its contract: when does it return NULL, when can it move memory, and whether it always succeeds given the computed new_size. Those semantics decide reachability of the rb == NULL branch and subsequent mhd_assert(0) and return.\n\n- MHD_pool_is_resizable_inplace\n  - Controls the branch that asserts and returns false if an existing buffer would have to be moved. Its possible return values (given pool and buffer state) determine whether that whole branch is reachable and thus whether the mhd_assert and return are dead/necessary.\n\n- mhd_assert\n  - Critical to dead-code reasoning: if mhd_assert expands to an aborting runtime-check (and is present in production builds) then code after mhd_assert(0) is unreachable; if it compiles to nothing (no-op) then the subsequent return remains meaningful. You must know its definition/configuration to decide if code guarded by or following mhd_assert is dead.\n\n- MHD_BUF_INC_SIZE\n  - This macro/constant affects computation of small_inc and hence branch outcomes in the \"shortage but mandatory\" path. Its value/range is needed to determine if the small_inc branch is ever taken or if resulting arithmetic makes some branches redundant.\n\n- check_and_grow_read_buffer_space\n  - It is the known caller. Its implementation and the arguments it passes (notably the 'required' boolean) matter: if it always calls try_grow_read_buffer with required==false (or always true) some branches inside try_grow_read_buffer could never be reached. To classify code as dead you need to know how the function is invoked in practice.\n\nProviding these symbols (definitions/prototypes/compile-time configuration) allows a precise reachability analysis of each conditional and the assertions in try_grow_read_buffer to determine if any executed operations are in fact removable without changing program behaviour (i.e. are dead code)."
}