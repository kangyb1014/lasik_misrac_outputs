{
  "user_message": "Target function code is:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_named_thread_': {'callees': ['MHD_create_thread_'], 'callers': ['new_connection_process_', 'MHD_start_daemon_va']}, 'MHD_create_thread_': {'callees': [], 'callers': ['MHD_create_named_thread_']}, 'new_connection_process_': {'callees': ['MHD_pool_create', 'MHD_DLOG', '__builtin_unreachable', 'MHD_connection_set_initial_state_', 'MHD_create_named_thread_', 'MHD_pool_destroy', 'MHD_ip_limit_del'], 'callers': ['internal_add_connection', 'new_connections_list_process_']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_THREAD_START_ROUTINE_",
    "MHD_thread_handle_ID_",
    "MHD_thread_handle_ID_get_native_handle_ptr_",
    "MHD_thread_handle_ID_set_native_handle_",
    "MHD_thread_handle_ID_set_invalid_",
    "struct MHD_named_helper_param_",
    "named_thread_starter",
    "MHD_create_thread_",
    "MHD_USE_THREAD_ATTR_SETNAME",
    "HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD",
    "HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI",
    "pthread_attr_setname_np",
    "pthread_attr_t",
    "pthread_t"
  ],
  "explanation": "For checking MISRA rule about language (compiler) extensions you must inspect any macro, typedef or function declaration used by MHD_create_named_thread_ that could hide compiler-specific extensions (e.g. __attribute__, __builtin_..., inline asm, statement-expressions, typeof, calling-convention attributes, __declspec, etc.) or that control which source branch is compiled. Each symbol is needed for the following reason:\n\n- MHD_THREAD_START_ROUTINE_: this macro/typedef declares the thread-start function type; it may expand to compiler-specific calling-convention or attribute annotations. Verify it does not use compiler extensions.\n- MHD_thread_handle_ID_: the thread-handle type may include implementation-specific attributes or non-standard storage-class/qualifiers. Inspect its definition for extensions.\n- MHD_thread_handle_ID_get_native_handle_ptr_: this name may be a macro or inline function; its definition could use statement-expressions, GCC statement macros, builtin or asm \u2014 must inspect expansion.\n- MHD_thread_handle_ID_set_native_handle_: same reason as above \u2014 could be a macro or inline with extensions.\n- MHD_thread_handle_ID_set_invalid_: same reason \u2014 macro/inline may hide compiler-specific constructs.\n- struct MHD_named_helper_param_: the struct definition might include bit-fields, anonymous unions/structs, or compiler-specific packing/attributes; inspect for extensions.\n- named_thread_starter: this function (used as starter in the non-attr branch) may be declared with extension attributes; need its prototype/definition.\n- MHD_create_thread_: this helper is called from here; its prototype or implementation may use non-standard attributes or macros \u2014 check its declaration/definition.\n- MHD_USE_THREAD_ATTR_SETNAME: this compile-time macro selects a different code path; you must know whether it is defined to know which code is actually compiled and therefore which symbols/constructs to inspect for extensions.\n- HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD and HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI: these macros further select platform-specific pthread_attr_setname_np variants; they determine which call form is used and whether a non-portable API (or an extension) is invoked.\n- pthread_attr_setname_np: the _np variant is nonstandard and may have platform-specific prototype or attributes. Inspect its declaration to see if any compiler-specific extension appears in its signature (attributes, calling-convention, macros).\n- pthread_attr_t and pthread_t: the underlying typedefs for these types may be defined using compiler-specific attributes or extension macros on some platforms; inspect their definitions to rule out language extensions.\n\nYou do not need ordinary library function bodies (malloc, free, errno macros, pthread_attr_init, pthread_create, pthread_attr_setstacksize, pthread_attr_destroy) unless their declarations contain compiler-specific attributes \u2014 but if any of those declarations in your environment use extension attributes, inspect them as well. The symbols above are the minimal set that can hide or control use of compiler-language extensions in the target function."
}