{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_create_named_thread_:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_named_thread_:\nstruct MHD_named_helper_param_\n{\n  /**\n   * Real thread start routine\n   */\n  MHD_THREAD_START_ROUTINE_ start_routine;\n\n  /**\n   * Argument for thread start routine\n   */\n  void *arg;\n\n  /**\n   * Name for thread\n   */\n  const char *name;\n}\n...\ntypedef MHD_THRD_RTRN_TYPE_\n(MHD_THRD_CALL_SPEC_ *MHD_THREAD_START_ROUTINE_)(void *cls)\n...\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n...\ntypedef struct _MHD_thread_handle_ID_ MHD_thread_handle_ID_\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nMHD_set_cur_thread_name_ (param->name);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: param->name is declared as const char * in struct MHD_named_helper_param_, and the call MHD_set_cur_thread_name_(param->name) therefore passes a pointer to a const-qualified type. This complies with Rule 8.13. (Only a violation would occur if MHD_set_cur_thread_name_ were declared to take a non-const char *; that prototype is not provided.)"
}