{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_create_named_thread_:\n```c\nint\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *handle_id,\n                          const char *thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n  {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n    /* NetBSD uses 3 arguments: second argument is string in printf-like format,\n     *                          third argument is single argument for printf;\n     * OSF1 uses 3 arguments too, but last one always must be zero (NULL).\n     * MHD doesn't use '%' in thread names, so both forms are used in same way.\n     */\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name,\n                                   0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n    res = pthread_attr_setname_np (&attr,\n                                   thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n    if ((res == 0) && (0 != stack_size) )\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n    if (0 == res)\n      res = pthread_create (new_tid_ptr,\n                            &attr,\n                            start_routine,\n                            arg);\n    pthread_attr_destroy (&attr);\n  }\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_ (handle_id,\n                            stack_size,\n                            &named_thread_starter,\n                            (void *) param))\n  {\n    int err_num;\n\n    err_num = errno;\n    free (param);\n    errno = err_num;\n    return 0;\n  }\n\n  return ! 0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_named_thread_:\n#define MHD_thread_handle_ID_set_native_handle_(hndl_id_ptr, native_val) MHD_thread_handle_set_native_(&((hndl_id_ptr)->handle),native_val)\n...\n#define MHD_thread_handle_ID_set_invalid_(hndl_id_ptr) (MHD_thread_handle_set_invalid_(&((hndl_id_ptr)->handle)),MHD_thread_ID_set_invalid_(&((hndl_id_ptr)->ID)))\n...\nstruct MHD_named_helper_param_\n{\n  /**\n   * Real thread start routine\n   */\n  MHD_THREAD_START_ROUTINE_ start_routine;\n\n  /**\n   * Argument for thread start routine\n   */\n  void *arg;\n\n  /**\n   * Name for thread\n   */\n  const char *name;\n}\n...\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n...\nint\nMHD_create_thread_ (MHD_thread_handle_ID_ *handle_id,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n#if defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  pthread_t *const new_tid_ptr =\n    MHD_thread_handle_ID_get_native_handle_ptr_ (handle_id);\n#else  /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n  pthread_t new_tid;\n  pthread_t *const new_tid_ptr = &new_tid;\n#endif /* ! MHD_thread_handle_ID_get_native_handle_ptr_ */\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (0 != stack_size)\n  {\n    pthread_attr_t attr;\n    res = pthread_attr_init (&attr);\n    if (0 == res)\n    {\n      res = pthread_attr_setstacksize (&attr,\n                                       stack_size);\n      if (0 == res)\n        res = pthread_create (new_tid_ptr,\n                              &attr,\n                              start_routine,\n                              arg);\n      pthread_attr_destroy (&attr);\n    }\n  }\n  else\n    res = pthread_create (new_tid_ptr,\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n  {\n    errno = res;\n    MHD_thread_handle_ID_set_invalid_ (handle_id);\n  }\n#if ! defined(MHD_thread_handle_ID_get_native_handle_ptr_)\n  else\n    MHD_thread_handle_ID_set_native_handle_ (handle_id, new_tid);\n#endif /* ! MHD_thread_handle_ID_set_current_thread_ID_ */\n\n  return ! res;\n#elif defined(MHD_USE_W32_THREADS)\n  uintptr_t thr_handle;\n#if SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT\n\n  mhd_assert (! MHD_thread_handle_ID_is_valid_handle_ (*handle_id));\n\n  if (stack_size > UINT_MAX)\n  {\n    errno = EINVAL;\n    return 0;\n  }\n#endif /* SIZEOF_SIZE_T != SIZEOF_UNSIGNED_INT */\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n#endif\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n  thr_handle = (uintptr_t) _beginthreadex (NULL,\n                                           (unsigned int) stack_size,\n                                           start_routine,\n                                           arg,\n                                           0,\n                                           NULL);\n  if ((MHD_thread_handle_native_) 0 == (MHD_thread_handle_native_) thr_handle)\n    return 0;\n\n  MHD_thread_handle_ID_set_native_handle_ (handle_id, \\\n                                           (MHD_thread_handle_native_) \\\n                                           thr_handle);\n\n  return ! 0;\n```\nFocus on the above code fragment and judge whether it violates the rule 2.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the operations are not dead. The assignment calls _beginthreadex (side effects), the if-check and early return are needed to handle failure, the call to MHD_thread_handle_ID_set_native_handle_ stores the created thread handle, and the final return indicates success. Removing any of these statements would change program behaviour (or error handling). (Minor redundant casts exist but they are not runtime dead code.)"
}