{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of handle_sec_areas_req:\n```c\nstatic enum MHD_Result\nhandle_sec_areas_req (struct MHD_Connection *c, const char *url, unsigned int\n                      sec_area_num)\n{\n  struct MHD_DigestAuthUsernameInfo *username_info;\n  struct UserEntry *user_entry;\n  void *userdigest;\n  size_t userdigest_size;\n  enum MHD_DigestAuthResult auth_res;\n\n  username_info = MHD_digest_auth_get_username3 (c);\n\n  if (NULL == username_info)\n    return reply_with_auth_required (c, 0, 0);\n\n  user_entry = find_entry_by_userinfo (username_info);\n\n  if (NULL == user_entry)\n    return reply_with_auth_required (c, 0, 1);\n\n  switch (username_info->algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n    userdigest = user_entry->userdigest_md5;\n    userdigest_size = sizeof(user_entry->userdigest_md5);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n    userdigest = user_entry->userdigest_sha256;\n    userdigest_size = sizeof(user_entry->userdigest_sha256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n    userdigest = user_entry->userdigest_sha512_256;\n    userdigest_size = sizeof(user_entry->userdigest_sha512_256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION:\n    /* Not supported currently and not used by MHD.\n       The client incorrectly used algorithm not advertised by the server. */\n    return reply_with_auth_required (c, 0, 1);\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning */\n  default:\n    return MHD_NO; /* Should be unreachable */\n  }\n\n  auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM, /* Make sure to use the proper realm, not the realm provided by the client and returned by \"user_entry\" */\n    user_entry->username,\n    userdigest,\n    userdigest_size,\n    0, /* Use daemon's default value for nonce_timeout*/\n    0, /* Use daemon's default value for max_nc */\n    get_m_QOP (),\n    (enum MHD_DigestAuthMultiAlgo3) username_info->algo3 /* Direct cast from \"single algorithm\" to \"multi-algorithm\" is allowed */\n    );\n\n  if (MHD_DAUTH_OK != auth_res)\n  {\n    int need_just_refresh_nonce;\n    /* Actually MHD_DAUTH_NONCE_OTHER_COND should not be returned as\n       MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE is not used for the daemon.\n       To keep the code universal the MHD_DAUTH_NONCE_OTHER_COND is\n       still checked here. */\n    need_just_refresh_nonce =\n      (MHD_DAUTH_NONCE_STALE == auth_res)\n      || (MHD_DAUTH_NONCE_OTHER_COND == auth_res);\n    return reply_with_auth_required (c,\n                                     need_just_refresh_nonce,\n                                     ! need_just_refresh_nonce);\n  }\n\n  /* The user successfully authenticated */\n\n  /* Check whether access to the request area is allowed for the user */\n  if (1 == sec_area_num)\n  {\n    if (user_entry->allow_area_1)\n      return reply_with_area1_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n  else if (2 == sec_area_num)\n  {\n    if (user_entry->allow_area_2)\n      return reply_with_area2_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n\n  return MHD_NO; /* Should be unreachable */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function handle_sec_areas_req:\nstruct MHD_DigestAuthUsernameInfo\n{\n  /**\n   * The algorithm as defined by client.\n   * Set automatically to MD5 if not specified by client.\n   * @warning Do not be confused with #MHD_DigestAuthAlgorithm,\n   *          which uses other values!\n   */\n  enum MHD_DigestAuthAlgo3 algo3;\n\n  /**\n   * The type of username used by client.\n   * The 'invalid' and 'missing' types are not used in this structure,\n   * instead NULL is returned by #MHD_digest_auth_get_username3().\n   */\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  /**\n   * The username string.\n   * Used only if username type is standard or extended, always NULL otherwise.\n   * If extended notation is used, this string is pct-decoded string\n   * with charset and language tag removed (i.e. it is original username\n   * extracted from the extended notation).\n   * When userhash is used by the client, this member is NULL and\n   * @a userhash_hex and @a userhash_bin are set.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username.\n   * When the @a username is NULL, this member is always zero.\n   */\n  size_t username_len;\n\n  /**\n   * The userhash string.\n   * Valid only if username type is userhash.\n   * This is unqoted string without decoding of the hexadecimal\n   * digits (as provided by the client).\n   * The buffer pointed by the @a userhash_hex becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @sa #MHD_digest_auth_calc_userhash_hex()\n   */\n  char *userhash_hex;\n\n  /**\n   * The length of the @a userhash_hex in characters.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) * 2 characters.\n   * When the @a userhash_hex is NULL, this member is always zero.\n   */\n  size_t userhash_hex_len;\n\n  /**\n   * The userhash decoded to binary form.\n   * Used only if username type is userhash, always NULL otherwise.\n   * When not NULL, this points to binary sequence @a userhash_hex_len /2 bytes\n   * long.\n   * The valid size should be #MHD_digest_get_hash_size(algo3) bytes.\n   * The buffer pointed by the @a userhash_bin becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   * @warning This is a binary data, no zero termination.\n   * @warning To avoid buffer overruns, always check the size of the data before\n   *          use, because @a userhash_bin can point even to zero-sized\n   *          data.\n   * @sa #MHD_digest_auth_calc_userhash()\n   */\n  uint8_t *userhash_bin;\n}\n...\n_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthUsernameInfo *uname_info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING == uname_type) ||\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_type) )\n    return NULL;\n\n  unif_buf_size = get_rq_unames_size (params, uname_type);\n\n  uname_info = (struct MHD_DigestAuthUsernameInfo *)\n               MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthUsernameInfo))\n                            + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (uname_info + 1);\n  unif_buf_used = get_rq_uname (params, uname_type, uname_info, unif_buf_ptr,\n                                unif_buf_size);\n  mhd_assert (unif_buf_size >= unif_buf_used);\n  (void) unif_buf_used; /* Mute compiler warning on non-debug builds */\n  mhd_assert (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_info->uname_type);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID == uname_info->uname_type)\n  {\n    free (uname_info);\n    return NULL;\n  }\n  mhd_assert (uname_type == uname_info->uname_type);\n  uname_info->algo3 = params->algo3;\n\n  return uname_info;\n}\n...\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n...\nstruct UserEntry\n{\n  /**\n   * The username.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *username;\n#if 0 /* Disabled code */\n  /* The cleartext password is not stored in the database.\n     The more secure \"userdigest\" is used instead. */\n  /**\n   * The password.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *password;\n#endif /* Disabled code */\n  /**\n   * The realm for this entry.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *realm;\n\n  /**\n   * The MD5 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_md5[MHD_MD5_DIGEST_SIZE];\n  /**\n   * The MD5 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_md5[MHD_MD5_DIGEST_SIZE];\n\n  /**\n   * The SHA-256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha256[MHD_SHA256_DIGEST_SIZE];\n  /**\n   * The SHA-256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha256[MHD_SHA256_DIGEST_SIZE];\n\n  /**\n   * The SHA-512/256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n  /**\n   * The SHA-512/256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n\n  /**\n   * User has access to \"area 1\" if non-zero\n   */\n  int allow_area_1;\n\n  /**\n   * User has access to \"area 2\" if non-zero\n   */\n  int allow_area_2;\n}\n...\n_MHD_EXTERN enum MHD_DigestAuthResult\nMHD_digest_auth_check_digest3 (struct MHD_Connection *connection,\n                               const char *realm,\n                               const char *username,\n                               const void *userdigest,\n                               size_t userdigest_size,\n                               unsigned int nonce_timeout,\n                               uint32_t max_nc,\n                               enum MHD_DigestAuthMultiQOP mqop,\n                               enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  if (1 != (((0 != (malgo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)\n            + ((0 != (malgo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)\n            + ((0 != (malgo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, only one base hashing algorithm \" \\\n                  \"(MD5, SHA-256 or SHA-512/256) must be specified, \" \\\n                  \"API violation\"));\n\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) malgo3) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n\n  if (digest_get_hash_size ((enum MHD_DigestAuthAlgo3) malgo3) !=\n      userdigest_size)\n    MHD_PANIC (_ (\"Wrong 'userdigest_size' value, does not match 'malgo3', \"\n                  \"API violation\"));\n\n  return digest_auth_check_all (connection,\n                                realm,\n                                username,\n                                NULL,\n                                (const uint8_t *) userdigest,\n                                nonce_timeout,\n                                max_nc,\n                                mqop,\n                                malgo3);\n}\n...\nenum MHD_DigestAuthMultiAlgo3\n{\n  /**\n   * Unknown or wrong algorithm type.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_INVALID = MHD_DIGEST_AUTH_ALGO3_INVALID,\n\n  /**\n   * The 'MD5' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_MD5 = MHD_DIGEST_AUTH_ALGO3_MD5,\n\n  /**\n   * The 'MD5-sess' algorithm.\n   * Not supported by MHD for authentication.\n   * Reserved value.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_MD5_SESSION = MHD_DIGEST_AUTH_ALGO3_MD5_SESSION,\n\n  /**\n   * The 'SHA-256' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA256 = MHD_DIGEST_AUTH_ALGO3_SHA256,\n\n  /**\n   * The 'SHA-256-sess' algorithm.\n   * Not supported by MHD for authentication.\n   * Reserved value.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA256_SESSION =\n    MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION,\n\n  /**\n   * The 'SHA-512-256' (SHA-512/256) algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256 = MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n\n  /**\n   * The 'SHA-512-256-sess' (SHA-512/256 session) algorithm.\n   * Not supported by MHD for authentication.\n   * Reserved value.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256_SESSION =\n    MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION,\n\n  /**\n   * SHA-256 or SHA-512/256 non-session algorithm, MHD will choose\n   * the preferred or the matching one.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA_ANY_NON_SESSION =\n    MHD_DIGEST_AUTH_ALGO3_SHA256 | MHD_DIGEST_AUTH_ALGO3_SHA512_256,\n\n  /**\n   * Any non-session algorithm, MHD will choose the preferred or\n   * the matching one.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION =\n    (0x3F) | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The SHA-256 or SHA-512/256 session algorithm.\n   * Not supported by MHD.\n   * Reserved value.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA_ANY_SESSION =\n    MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION\n    | MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION,\n\n  /**\n   * Any session algorithm.\n   * Not supported by MHD.\n   * Reserved value.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_ANY_SESSION =\n    (0x3F) | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The MD5 algorithm, session or non-session.\n   * Currently supported as non-session only.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_MD5_ANY =\n    MHD_DIGEST_AUTH_MULT_ALGO3_MD5 | MHD_DIGEST_AUTH_MULT_ALGO3_MD5_SESSION,\n\n  /**\n   * The SHA-256 algorithm, session or non-session.\n   * Currently supported as non-session only.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA256_ANY =\n    MHD_DIGEST_AUTH_MULT_ALGO3_SHA256\n    | MHD_DIGEST_AUTH_MULT_ALGO3_SHA256_SESSION,\n\n  /**\n   * The SHA-512/256 algorithm, session or non-session.\n   * Currently supported as non-session only.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256_ANY =\n    MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256\n    | MHD_DIGEST_AUTH_MULT_ALGO3_SHA512_256_SESSION,\n\n  /**\n   * The SHA-256 or SHA-512/256 algorithm, session or non-session.\n   * Currently supported as non-session only.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_SHA_ANY_ANY =\n    MHD_DIGEST_AUTH_MULT_ALGO3_SHA_ANY_NON_SESSION\n    | MHD_DIGEST_AUTH_MULT_ALGO3_SHA_ANY_SESSION,\n\n  /**\n   * Any algorithm, MHD will choose the preferred or the matching one.\n   */\n  MHD_DIGEST_AUTH_MULT_ALGO3_ANY =\n    (0x3F) | MHD_DIGEST_AUTH_ALGO3_NON_SESSION | MHD_DIGEST_AUTH_ALGO3_SESSION\n}\n...\nstatic enum MHD_Result\nreply_with_auth_required (struct MHD_Connection *c,\n                          int stale,\n                          int wrong_cred)\n{\n  static const char auth_required_content[] =\n    \"<html><head><title>Authentication required</title></head>\" \\\n    \"<body>The requested page needs authentication.</body></html>\";\n  static const size_t auth_required_content_len =\n    (sizeof(auth_required_content) / sizeof(char)) - 1;\n  static const char wrong_creds_content[] =\n    \"<html><head><title>Wrong credentials</title></head>\" \\\n    \"<body>The provided credentials are incorrect.</body></html>\";\n  static const size_t wrong_creds_content_len =\n    (sizeof(wrong_creds_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  if (wrong_cred)\n    stale = 0; /* Force client to ask user for username and password */\n\n  if (! wrong_cred)\n    resp = MHD_create_response_from_buffer_static (auth_required_content_len,\n                                                   auth_required_content);\n  else\n    resp = MHD_create_response_from_buffer_static (wrong_creds_content_len,\n                                                   wrong_creds_content);\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE, \"text/html\");\n\n\n  ret = MHD_queue_auth_required_response3 (\n    c,\n    REALM,\n    OPAQUE_DATA, /* The \"opaque data\", not really useful */\n    SEC_AREA1_URL \" \" SEC_AREA2_URL, /* Space-separated list of URLs' initial parts */\n    resp,\n    stale,\n    get_m_QOP (),\n    get_m_algo (),\n    ! 0, /* Userhash support enabled */\n    ! 0 /* UTF-8 is preferred */);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstatic enum MHD_Result\nreply_with_area1_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA1_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Restricted secret page</title></head>\" \\\n      \"<body>Welcome to the restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA1_URL \"some_path/some_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n...\nstatic enum MHD_Result\nreply_with_area2_pages (struct MHD_Connection *c,\n                        const char *url)\n{\n\n  if (0 == strcmp (url, SEC_AREA2_URL \"\"))\n  {\n    static const char page_content[] =\n      \"<html><head><title>Very restricted secret page</title></head>\" \\\n      \"<body>Welcome to the super restricted area</body></html>\";\n    static const size_t page_content_len =\n      (sizeof(page_content) / sizeof(char)) - 1;\n    struct MHD_Response *resp;\n    enum MHD_Result ret;\n\n    resp = MHD_create_response_from_buffer_static (page_content_len,\n                                                   page_content);\n    if (NULL == resp)\n      return MHD_NO;\n\n    /* Ignore possible error when adding the header as the reply will work even\n       without this header. */\n    (void) MHD_add_response_header (resp, MHD_HTTP_HEADER_CONTENT_TYPE,\n                                    \"text/html\");\n\n    ret = MHD_queue_response (c, MHD_HTTP_OK, resp);\n    MHD_destroy_response (resp);\n    return ret;\n  }\n  /* If needed: add handlers for other URLs in this area */\n#if 0 /* Disabled code */\n  if (0 == strcmp (url, SEC_AREA2_URL \"other_path/other_page\"))\n  {\n    /* Add page creation/processing code */\n  }\n#endif /* Disabled code */\n\n  /* The requested URL is unknown */\n  return reply_with_page_not_found (c);\n}\n...\nstatic enum MHD_Result\nreply_with_forbidden (struct MHD_Connection *c)\n{\n  static const char page_content[] =\n    \"<html><head><title>Forbidden</title></head>\" \\\n    \"<body>You do not have access to this page.</body></html>\";\n  static const size_t page_content_len =\n    (sizeof(page_content) / sizeof(char)) - 1;\n  struct MHD_Response *resp;\n  enum MHD_Result ret;\n\n  resp = MHD_create_response_from_buffer_static (page_content_len, page_content)\n  ;\n  if (NULL == resp)\n    return MHD_NO;\n\n  /* Ignore possible error when adding the header as the reply will work even\n     without this header. */\n  (void) MHD_add_response_header (resp,\n                                  MHD_HTTP_HEADER_CONTENT_TYPE,\n                                  \"text/html\");\n\n  ret = MHD_queue_response (c, MHD_HTTP_FORBIDDEN, resp);\n  MHD_destroy_response (resp);\n  return ret;\n}\n...\nstruct MHD_Connection\n...\nstatic enum MHD_DigestAuthMultiQOP\nget_m_QOP (void)\n{\n  if (allow_rfc2069)\n    return MHD_DIGEST_AUTH_MULT_QOP_ANY_NON_INT;\n\n  return MHD_DIGEST_AUTH_MULT_QOP_AUTH;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "struct UserEntry *user_entry;",
    "username_info = MHD_digest_auth_get_username3 (c);",
    "auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM,\n    user_entry->username,\n    userdigest,\n    userdigest_size,",
    "struct MHD_DigestAuthUsernameInfo *username_info;",
    "userdigest = user_entry->userdigest_sha512_256;",
    "void *userdigest;",
    "userdigest = user_entry->userdigest_md5;",
    "struct MHD_DigestAuthUsernameInfo *uname_info;",
    "userdigest = user_entry->userdigest_sha256;",
    "char *userhash_hex;",
    "_MHD_EXTERN struct MHD_DigestAuthUsernameInfo *\nMHD_digest_auth_get_username3 (struct MHD_Connection *connection)",
    "uint8_t *userhash_bin;",
    "static struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)",
    "char *username;",
    "return find_entry_by_username (username_info->username);"
  ],
  "explanation": "I only flagged pointer declarations/returns/fields and call sites where a non-const pointer is used but could reasonably be const-qualified and thus should be reviewed for compliance with MISRA C 2023 Rule 8.13. I did not flag fragments where const qualification is already present or where mutability is required by the code semantics: for example, buffers that are written into (allocation and filling helpers), fixed-size arrays (not pointer types), APIs that legitimately return or require a mutable pointer because the caller is expected to modify or free the memory, and function parameters that are already declared const. I also did not flag calls and headers that already use const-qualified pointer types. These remaining code areas therefore do not need investigation for this specific rule."
}