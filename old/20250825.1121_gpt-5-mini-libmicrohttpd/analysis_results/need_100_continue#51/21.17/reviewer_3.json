{
  "user_message": "An agent A claimed that the following need_100_continue code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of need_100_continue.\n```c\nstatic bool\nneed_100_continue (struct MHD_Connection *connection)\n{\n  const char *expect;\n\n  if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    return false;\n\n  if (0 == connection->rq.remaining_upload_size)\n    return false;\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_EXPECT,\n                                     MHD_STATICSTR_LEN_ ( \\\n                                       MHD_HTTP_HEADER_EXPECT),\n                                     &expect,\n                                     NULL))\n    return false;\n\n  if (MHD_str_equal_caseless_ (expect,\n                               \"100-continue\"))\n    return true;\n\n  return false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nMHD_lookup_connection_value_n can return a pointer to a header value (pos->value) without the caller receiving its length when value_size_ptr is NULL. In need_100_continue the call passes NULL for the size and then uses the returned expect pointer in a function (MHD_str_equal_caseless_) that scans until a NUL terminator. If pos->value is stored as a length-delimited buffer (pos->value_size) and is not NUL-terminated, scanning/using standard string functions (e.g. strlen, strcmp, strcat, etc.) on the returned pointer can read beyond the object bounds (out-of-bounds access). Therefore Rule 21.17 is violated in this usage scenario.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function need_100_continue:\n_MHD_EXTERN enum MHD_Result\nMHD_lookup_connection_value_n (struct MHD_Connection *connection,\n                               enum MHD_ValueKind kind,\n                               const char *key,\n                               size_t key_size,\n                               const char **value_ptr,\n                               size_t *value_size_ptr)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  if (NULL == connection)\n    return MHD_NO;\n\n  if (NULL == key)\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (NULL == pos->header) )\n        break;\n    }\n  }\n  else\n  {\n    for (pos = connection->rq.headers_received; NULL != pos; pos = pos->next)\n    {\n      if ( (0 != (kind & pos->kind)) &&\n           (key_size == pos->header_size) &&\n           ( (key == pos->header) ||\n             (MHD_str_equal_caseless_bin_n_ (key,\n                                             pos->header,\n                                             key_size) ) ) )\n        break;\n    }\n  }\n\n  if (NULL == pos)\n    return MHD_NO;\n\n  if (NULL != value_ptr)\n    *value_ptr = pos->value;\n\n  if (NULL != value_size_ptr)\n    *value_size_ptr = pos->value_size;\n\n  return MHD_YES;\n}\n...\nint\nMHD_str_equal_caseless_ (const char *str1,\n                         const char *str2)\n{\n  while (0 != (*str1))\n  {\n    const char c1 = *str1;\n    const char c2 = *str2;\n    if (charsequalcaseless (c1, c2))\n    {\n      str1++;\n      str2++;\n    }\n    else\n      return 0;\n  }\n  return 0 == (*str2);\n}\n...\n_MHD_static_inline bool\ncharsequalcaseless (const char c1, const char c2)\n{\n  return ( (c1 == c2) ||\n           (isasciiupper (c1) ?\n            ((c1 - 'A' + 'a') == c2) :\n            ((c1 == (c2 - 'A' + 'a')) && isasciiupper (c2))) );\n}\n...\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n...\n#define MHD_HTTP_HEADER_EXPECT \"Expect\"\n...\n#define MHD_IS_HTTP_VER_1_1_COMPAT(ver) (MHD_HTTP_VER_1_1==(ver)||MHD_HTTP_VER_1_2__1_9==(ver))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario describes a real runtime hazard (expect may point to a length-delimited buffer that is not NUL-terminated and MHD_str_equal_caseless_ scans until a NUL), but the claimed violation of MISRA C 2023 Rule 21.17 is not correct. Rule 21.17 (as given) \u201cstrictly applies to the Standard Library functions in <string.h>\u201d (strlen, strcmp, strcpy, memcpy, etc.). The code does not call any function from <string.h>; it calls a library-specific routine MHD_str_equal_caseless_, which is not a Standard Library <string.h> function. Therefore the specific invocation in need_100_continue does not violate Rule 21.17 as written.\n\nThat said, the code does present a genuine safety risk: MHD_lookup_connection_value_n can return pos->value without providing its length when value_size_ptr is NULL, and MHD_str_equal_caseless_ assumes NUL-termination of its first argument. If pos->value is stored as a non-NUL-terminated, length-delimited buffer, a run-time out-of-bounds read can occur. This would be a correctness/safety issue (and might violate other MISRA rules about bounds or assumptions), but it is not a violation of 21.17 specifically. Recommended fixes: pass a non-NULL value_size_ptr and use a length-bounded comparison, or ensure stored header values are NUL-terminated before calling NUL-terminated-string routines."
}