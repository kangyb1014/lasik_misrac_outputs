{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_ip_addr_to_key:\n```c\nstatic enum MHD_Result\nMHD_ip_addr_to_key (const struct sockaddr_storage *addr,\n                    socklen_t addrlen,\n                    struct MHD_IPCount *key)\n{\n  memset (key,\n          0,\n          sizeof(*key));\n\n  /* IPv4 addresses */\n  if (sizeof (struct sockaddr_in) <= (size_t) addrlen)\n  {\n    if (AF_INET == addr->ss_family)\n    {\n      key->family = AF_INET;\n      memcpy (&key->addr.ipv4,\n              &((const struct sockaddr_in *) addr)->sin_addr,\n              sizeof(((const struct sockaddr_in *) NULL)->sin_addr));\n      return MHD_YES;\n    }\n  }\n\n#ifdef HAVE_INET6\n  if (sizeof (struct sockaddr_in6) <= (size_t) addrlen)\n  {\n    /* IPv6 addresses */\n    if (AF_INET6 == addr->ss_family)\n    {\n      key->family = AF_INET6;\n      memcpy (&key->addr.ipv6,\n              &((const struct sockaddr_in6 *) addr)->sin6_addr,\n              sizeof(((const struct sockaddr_in6 *) NULL)->sin6_addr));\n      return MHD_YES;\n    }\n  }\n#endif\n\n  /* Some other address */\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_ip_addr_to_key:\nstruct MHD_IPCount\n{\n  /**\n   * Address family. AF_INET or AF_INET6 for now.\n   */\n  int family;\n\n  /**\n   * Actual address.\n   */\n  union\n  {\n    /**\n     * IPv4 address.\n     */\n    struct in_addr ipv4;\n#ifdef HAVE_INET6\n    /**\n     * IPv6 address.\n     */\n    struct in6_addr ipv6;\n#endif\n  } addr;\n\n  /**\n   * Counter.\n   */\n  unsigned int count;\n}\n...\n\n...\n\n...\n#define HAVE_INET6 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (sizeof (struct sockaddr_in) <= (size_t) addrlen)\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The check verifies that the provided addrlen is at least sizeof(struct sockaddr_in) before treating the sockaddr_storage pointer as a struct sockaddr_in. Because (size_t)addrlen is compared to sizeof(struct sockaddr_in) (using <=), the subsequent access to ((const struct sockaddr_in *)addr)->sin_addr (and the memcpy of that field) cannot read beyond the bounds indicated by addrlen. Therefore this fragment prevents out\u2011of\u2011bounds accesses related to the later memcpy and does not violate MISRA C 2023 Rule 21.17."
}