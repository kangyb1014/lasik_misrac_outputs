{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_ip_addr_to_key:\n```c\nstatic enum MHD_Result\nMHD_ip_addr_to_key (const struct sockaddr_storage *addr,\n                    socklen_t addrlen,\n                    struct MHD_IPCount *key)\n{\n  memset (key,\n          0,\n          sizeof(*key));\n\n  /* IPv4 addresses */\n  if (sizeof (struct sockaddr_in) <= (size_t) addrlen)\n  {\n    if (AF_INET == addr->ss_family)\n    {\n      key->family = AF_INET;\n      memcpy (&key->addr.ipv4,\n              &((const struct sockaddr_in *) addr)->sin_addr,\n              sizeof(((const struct sockaddr_in *) NULL)->sin_addr));\n      return MHD_YES;\n    }\n  }\n\n#ifdef HAVE_INET6\n  if (sizeof (struct sockaddr_in6) <= (size_t) addrlen)\n  {\n    /* IPv6 addresses */\n    if (AF_INET6 == addr->ss_family)\n    {\n      key->family = AF_INET6;\n      memcpy (&key->addr.ipv6,\n              &((const struct sockaddr_in6 *) addr)->sin6_addr,\n              sizeof(((const struct sockaddr_in6 *) NULL)->sin6_addr));\n      return MHD_YES;\n    }\n  }\n#endif\n\n  /* Some other address */\n  return MHD_NO;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_ip_addr_to_key:\nstruct MHD_IPCount\n{\n  /**\n   * Address family. AF_INET or AF_INET6 for now.\n   */\n  int family;\n\n  /**\n   * Actual address.\n   */\n  union\n  {\n    /**\n     * IPv4 address.\n     */\n    struct in_addr ipv4;\n#ifdef HAVE_INET6\n    /**\n     * IPv6 address.\n     */\n    struct in6_addr ipv6;\n#endif\n  } addr;\n\n  /**\n   * Counter.\n   */\n  unsigned int count;\n}\n...\n\n...\n\n...\n#define HAVE_INET6 1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset (key,\n          0,\n          sizeof(*key));\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The memset itself uses sizeof(*key) which writes sizeof(struct MHD_IPCount) bytes starting at key. This is correct when key actually points to a valid struct MHD_IPCount object. Therefore the code fragment as written does not intrinsically violate Rule 21.17. However a violation can occur if the caller passes an invalid pointer (for example NULL) or a pointer to a smaller object. Concrete violating scenarios include: (1) the caller does malloc(sizeof(struct in_addr)) and casts the result to struct MHD_IPCount* and passes that pointer \u2014 memset will write beyond the allocated buffer; (2) the caller passes NULL \u2014 the memset will dereference a null pointer; (3) the caller passes &some_struct.addr.ipv4 (a pointer to the ipv4 member) instead of a pointer to the full MHD_IPCount. In those cases the use of memset would access beyond the bounds of the referenced object, violating Rule 21.17."
}