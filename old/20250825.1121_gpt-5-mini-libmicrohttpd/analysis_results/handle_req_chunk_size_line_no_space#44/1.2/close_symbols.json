{
  "user_message": "Target function code is:\n```c\nstatic void\nhandle_req_chunk_size_line_no_space (struct MHD_Connection *c,\n                                     const char *chunk_size_line,\n                                     size_t chunk_size_line_size)\n{\n  unsigned int err_code;\n\n  if (NULL != chunk_size_line)\n  {\n    const char *semicol;\n    /* Check for chunk extension */\n    semicol = memchr (chunk_size_line, ';', chunk_size_line_size);\n    if (NULL != semicol)\n    { /* Chunk extension present. It could be removed without any loss of the\n         details of the request. */\n      transmit_error_response_static (c,\n                                      MHD_HTTP_CONTENT_TOO_LARGE,\n                                      ERR_MSG_REQUEST_CHUNK_LINE_EXT_TOO_BIG);\n    }\n  }\n  err_code = get_no_space_err_status_code (c,\n                                           MHD_PROC_RECV_BODY_CHUNKED,\n                                           chunk_size_line,\n                                           chunk_size_line_size);\n  transmit_error_response_static (c,\n                                  err_code,\n                                  ERR_MSG_REQUEST_CHUNK_LINE_TOO_BIG);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'handle_req_chunk_size_line_no_space': {'callees': ['transmit_error_response_len', 'get_no_space_err_status_code'], 'callers': ['handle_recv_no_space']}, 'transmit_error_response_len': {'callees': ['MHD_DLOG', 'connection_close_error', 'MHD_pool_deallocate', 'MHD_destroy_response', 'MHD_create_response_from_buffer_static', 'MHD_queue_response', 'build_header_response', 'MHD_pool_reset'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space', 'handle_recv_no_space', 'connection_add_header', 'parse_http_version', 'process_request_body', 'parse_connection_headers', 'get_request_line_inner', 'send_redirect_fixed_rq_target', 'get_request_line', 'get_req_header']}, 'get_no_space_err_status_code': {'callees': ['MHD_lookup_connection_value_n'], 'callers': ['handle_req_headers_no_space', 'handle_req_cookie_no_space', 'handle_req_chunk_size_line_no_space']}, 'handle_recv_no_space': {'callees': ['connection_close_error', 'transmit_error_response_len', 'handle_req_headers_no_space', 'has_unprocessed_upload_body_data_in_buffer', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space'], 'callers': ['check_and_grow_read_buffer_space']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "transmit_error_response_static",
    "transmit_error_response_len",
    "get_no_space_err_status_code",
    "ERR_MSG_REQUEST_CHUNK_LINE_EXT_TOO_BIG",
    "ERR_MSG_REQUEST_CHUNK_LINE_TOO_BIG",
    "MHD_HTTP_CONTENT_TOO_LARGE",
    "MHD_PROC_RECV_BODY_CHUNKED",
    "struct MHD_Connection",
    "memchr",
    "NULL",
    "size_t"
  ],
  "explanation": "For each symbol listed below we need its definition/declaration to determine whether the target function uses any compiler language extensions (e.g. macros expanding to statement-expressions, nonstandard attributes, inline asm, GCC typeof/extension syntax, nonstandard pointer conversions), or whether any referenced name is actually implemented as a compiler-specific extension.\n\n- transmit_error_response_static\n  Reason: Called directly from the target. If this name is a macro or alias that expands to nonstandard code (for example to a function-like macro using GNU statement-expressions, attributes, or asm), that would be a language extension. The actual definition is needed.\n\n- transmit_error_response_len\n  Reason: The static call graph references this symbol (possible alias/alternative implementation). Provide its definition to check for macro aliases or extension use that could affect the call made by the target.\n\n- get_no_space_err_status_code\n  Reason: Called directly; its implementation could be a macro or use compiler-specific constructs. We must inspect its definition to ensure no language extensions are used in the call or return (e.g. unusual attributes, inline assembly, or nonstandard types).\n\n- ERR_MSG_REQUEST_CHUNK_LINE_EXT_TOO_BIG\n  Reason: Passed to error-transmit call. If this symbol is a macro that expands to a complex expression or uses compiler-specific quoting/attributes, it could be a language extension; need its definition.\n\n- ERR_MSG_REQUEST_CHUNK_LINE_TOO_BIG\n  Reason: Same as above \u2014 check whether this macro/definition uses any compiler extensions.\n\n- MHD_HTTP_CONTENT_TOO_LARGE\n  Reason: An HTTP status macro/constant passed as an argument. If implemented via an unusual construct (enum with attributes, macro with extension), it must be inspected.\n\n- MHD_PROC_RECV_BODY_CHUNKED\n  Reason: Constant/enum used as an argument to get_no_space_err_status_code. Its definition could be a macro or use nonstandard constructs; verify.\n\n- struct MHD_Connection\n  Reason: The function takes a pointer to this type. Its definition could include compiler-specific extensions (bitfields with compiler attributes, packed/unaligned attributes, anonymous structs/unions which some compilers extend, or nonstandard storage-class specifiers). Inspecting the struct ensures no language extensions are used that affect this function's prototype or behavior.\n\n- memchr\n  Reason: Used to search the chunk_size_line buffer. memchr is ordinarily a standard C library function, but it could be redefined as a macro or inline builtin in the project headers to use compiler extensions. We need its declaration/definition to ensure no extension is involved and that the pointer conversion (void* -> const char*) is standard in the used dialect.\n\n- NULL\n  Reason: NULL is used in comparisons. Some projects redefine NULL in a nonstandard way (e.g. ((void*)0) is standard C but macro redefinitions or C++-style 0 could signal language-dialect assumptions). Confirming its definition ensures no extension is hidden behind the macro.\n\n- size_t\n  Reason: Used as a parameter type. Need its typedef to check for any project-specific redefinition or use of a nonstandard underlying type (or macro) that could indicate compiler-specific typedefs or extensions.\n\nNote: The above symbols are the external identifiers referenced directly by the target function. Their definitions (or the headers that provide them) must be examined to determine whether any of them are implemented using compiler-specific language extensions; only then can we conclude whether the target function (as actually compiled in the project) uses language extensions in violation of the MISRA rule."
}