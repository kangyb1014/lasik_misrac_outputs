{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of fast_simple_hash:\n```c\nstatic uint32_t\nfast_simple_hash (const uint8_t *data,\n                  size_t data_size)\n{\n  uint32_t hash;\n\n  if (0 != data_size)\n  {\n    size_t i;\n    hash = data[0];\n    for (i = 1; i < data_size; i++)\n      hash = _MHD_ROTL32 (hash, 7) ^ data[i];\n  }\n  else\n    hash = 0;\n\n  return hash;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function fast_simple_hash:\nstatic size_t\nget_nonce_nc_idx (size_t arr_size,\n                  const char *nonce,\n                  size_t noncelen)\n{\n  mhd_assert (0 != arr_size);\n  mhd_assert (0 != noncelen);\n  return fast_simple_hash ((const uint8_t *) nonce, noncelen) % arr_size;\n}\n...\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n    return MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n  mod = daemon->nonce_nc_size;\n  if (0 == mod)\n    return MHD_CHECK_NONCENC_STALE;  /* no array! */\n  if (nc >= UINT32_MAX - 64)\n    return MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n\n  nn = &daemon->nnc[get_nonce_nc_idx (mod, nonce, noncelen)];\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n  }\n  else if (nc < nn->nc)\n  {\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n...\nstatic bool\ncalculate_add_nonce (struct MHD_Connection *const connection,\n                     uint64_t timestamp,\n                     const char *realm,\n                     size_t realm_len,\n                     struct DigestAlgorithm *da,\n                     char *nonce)\n{\n  struct MHD_Daemon *const daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  const size_t nonce_size = NONCE_STD_LEN (digest_get_size (da));\n  bool ret;\n\n  mhd_assert (! da->hashing);\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH >= nonce_size);\n  mhd_assert (0 != nonce_size);\n\n  calculate_nonce (timestamp,\n                   connection->rq.http_mthd,\n                   connection->rq.method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->addr,\n                   (size_t) connection->addr_len,\n                   connection->rq.url,\n                   connection->rq.url_len,\n                   connection->rq.headers_received,\n                   realm,\n                   realm_len,\n                   daemon->dauth_bind_type,\n                   da,\n                   nonce);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return false;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 == daemon->nonce_nc_size)\n    return false;\n\n  /* Sanity check for values */\n  mhd_assert (MAX_DIGEST_NONCE_LENGTH == NONCE_STD_LEN (MAX_DIGEST));\n\n  nn = daemon->nnc + get_nonce_nc_idx (daemon->nonce_nc_size,\n                                       nonce,\n                                       nonce_size);\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (is_slot_available (nn, timestamp, nonce, nonce_size))\n  {\n    memcpy (nn->nonce,\n            nonce,\n            nonce_size);\n    nn->nonce[nonce_size] = 0;  /* With terminating zero */\n    nn->nc = 0;\n    nn->nmask = 0;\n    ret = true;\n  }\n  else\n    ret = false;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n...\nstatic bool\ncalculate_add_nonce_with_retry (struct MHD_Connection *const connection,\n                                const char *realm,\n                                struct DigestAlgorithm *da,\n                                char *nonce)\n{\n  const uint64_t timestamp1 = MHD_monotonic_msec_counter ();\n  const size_t realm_len = strlen (realm);\n  mhd_assert (! da->hashing);\n\n#ifdef HAVE_MESSAGES\n  if (0 == MHD_get_master (connection->daemon)->digest_auth_rand_size)\n    MHD_DLOG (connection->daemon,\n              _ (\"Random value was not initialised by \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM or \" \\\n                 \"MHD_OPTION_DIGEST_AUTH_RANDOM_COPY, generated nonces \" \\\n                 \"are predictable.\\n\"));\n#endif\n\n  if (! calculate_add_nonce (connection, timestamp1, realm, realm_len, da,\n                             nonce))\n  {\n    /* Either:\n     * 1. The same nonce was already generated. If it will be used then one\n     * of the clients will fail (as no initial 'nc' value could be given to\n     * the client, the second client which will use 'nc=00000001' will fail).\n     * 2. Another nonce uses the same slot, and this nonce never has been\n     * used by the client and this nonce is still fresh enough.\n     */\n    const size_t digest_size = digest_get_size (da);\n    char nonce2[NONCE_STD_LEN (MAX_DIGEST) + 1];\n    uint64_t timestamp2;\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return false; /* No need to re-try */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    if (0 == MHD_get_master (connection->daemon)->nonce_nc_size)\n      return false; /* No need to re-try */\n\n    timestamp2 = MHD_monotonic_msec_counter ();\n    if (timestamp1 == timestamp2)\n    {\n      /* The timestamps are equal, need to generate some arbitrary\n       * difference for nonce. */\n      /* As the number is needed only to differentiate clients, weak\n       * pseudo-random generators could be used. Seeding is not needed. */\n      uint64_t base1;\n      uint32_t base2;\n      uint16_t base3;\n      uint8_t base4;\n#ifdef HAVE_RANDOM\n      base1 = ((uint64_t) random ()) ^ UINT64_C (0x54a5acff5be47e63);\n      base4 = 0xb8;\n#elif defined(HAVE_RAND)\n      base1 = ((uint64_t) rand ()) ^ UINT64_C (0xc4bcf553b12f3965);\n      base4 = 0x92;\n#else\n      /* Monotonic msec counter alone does not really help here as it is already\n         known that this value is not unique. */\n      base1 = ((uint64_t) (uintptr_t) nonce2) ^ UINT64_C (0xf2e1b21bc6c92655);\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTR32 (base2, 4);\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      base1 = ((uint64_t) MHD_monotonic_msec_counter ())\n              ^ UINT64_C (0xccab93f72cf5b15);\n#endif\n      base2 = ((uint32_t) (base1 >> 32)) ^ ((uint32_t) base1);\n      base2 = _MHD_ROTL32 (base2, (((base4 >> 4) ^ base4) % 32));\n      base3 = ((uint16_t) (base2 >> 16)) ^ ((uint16_t) base2);\n      base4 = ((uint8_t) (base3 >> 8)) ^ ((uint8_t) base3);\n      /* Use up to 127 ms difference */\n      timestamp2 -= (base4 & DAUTH_JUMPBACK_MAX);\n      if (timestamp1 == timestamp2)\n        timestamp2 -= 2; /* Fallback value */\n    }\n    digest_reset (da);\n    if (! calculate_add_nonce (connection, timestamp2, realm, realm_len, da,\n                               nonce2))\n    {\n      /* No free slot has been found. Re-tries are expensive, just use\n       * the generated nonce. As it is not stored in nonce-nc map array,\n       * the next request of the client will be recognized as valid, but 'stale'\n       * so client should re-try automatically. */\n      return false;\n    }\n    memcpy (nonce, nonce2, NONCE_STD_LEN (digest_size));\n  }\n  return true;\n}\n...\nstatic void\nmd5_transform (uint32_t H[MD5_HASH_SIZE_WORDS],\n               const void *M)\n{\n  /* Working variables,\n     See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t A = H[0];\n  uint32_t B = H[1];\n  uint32_t C = H[2];\n  uint32_t D = H[3];\n\n  /* The data buffer. See RFC 1321, Clause 3.4 (step 4). */\n  uint32_t X[16];\n\n#ifndef _MHD_GET_32BIT_LE_UNALIGNED\n  if (0 != (((uintptr_t) M) % _MHD_UINT32_ALIGN))\n  { /* The input data is unaligned. */\n    /* Copy the unaligned input data to the aligned buffer. */\n    memcpy (X, M, sizeof(X));\n    /* The X[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps. */\n    M = (const void *) X;\n  }\n#endif /* _MHD_GET_32BIT_LE_UNALIGNED */\n\n  /* Four auxiliary functions, see RFC 1321, Clause 3.4 (step 4). */\n  /* Some optimisations used. */\n/* #define F_FUNC(x,y,z) (((x)&(y)) | ((~(x))&(z))) */ /* Original version */\n#define F_FUNC(x,y,z) ((((y) ^ (z)) & (x)) ^ (z))\n/* #define G_FUNC_1(x,y,z) (((x)&(z)) | ((y)&(~(z)))) */ /* Original version */\n/* #define G_FUNC_2(x,y,z) UINT32_C(0) */ /* Original version */\n#ifndef MHD_FAVOR_SMALL_CODE\n#  define G_FUNC_1(x,y,z) ((~(z)) & (y))\n#  define G_FUNC_2(x,y,z) ((z) & (x))\n#else  /* MHD_FAVOR_SMALL_CODE */\n#  define G_FUNC_1(x,y,z) ((((x) ^ (y)) & (z)) ^ (y))\n#  define G_FUNC_2(x,y,z) UINT32_C(0)\n#endif /* MHD_FAVOR_SMALL_CODE */\n#define H_FUNC(x,y,z) ((x) ^ (y) ^ (z)) /* Original version */\n/* #define I_FUNC(x,y,z) ((y) ^ ((x) | (~(z)))) */ /* Original version */\n#define I_FUNC(x,y,z) (((~(z)) | (x)) ^ (y))\n\n  /* One step of round 1 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R1(va,vb,vc,vd,vX,vs,vT) do {          \\\n    (va) += (vX) + (vT);                               \\\n    (va) += F_FUNC((vb),(vc),(vd));                    \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* Get value of X(k) from input data buffer.\n     See RFC 1321 Clause 3.4 (step 4). */\n#define GET_X_FROM_DATA(buf,t) \\\n  _MHD_GET_32BIT_LE (((const uint32_t*) (buf)) + (t))\n\n  /* One step of round 2 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R2(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += G_FUNC_1((vb),(vc),(vd));                 \\\n    (va) += G_FUNC_2((vb),(vc),(vd));                 \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 3 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R3(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += H_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n  /* One step of round 4 of MD5 computation, see RFC 1321, Clause 3.4 (step 4).\n     The original function was modified to use X[k] and T[i] as\n     direct inputs. */\n#define MD5STEP_R4(va,vb,vc,vd,vX,vs,vT) do {         \\\n    (va) += (vX) + (vT);                              \\\n    (va) += I_FUNC((vb),(vc),(vd));                   \\\n    (va) = _MHD_ROTL32((va),(vs)) + (vb); } while (0)\n\n#if ! defined(MHD_FAVOR_SMALL_CODE)\n\n  /* Round 1. */\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  if ((const void *) X == M)\n  {\n    /* The input data is already in the data buffer X[] in correct bytes\n       order. */\n    MD5STEP_R1 (A, B, C, D, X[0],  7,  UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1],  12, UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2],  17, UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3],  22, UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4],  7,  UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5],  12, UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6],  17, UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7],  22, UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8],  7,  UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9],  12, UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10], 17, UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11], 22, UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12], 7,  UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13], 12, UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14], 17, UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15], 22, UINT32_C (0x49b40821));\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN */\n  if (1)\n  {\n    /* The input data is loaded in correct (little-endian) format before\n       calculations on each step. */\n    MD5STEP_R1 (A, B, C, D, X[0]  = GET_X_FROM_DATA (M, 0),  7, \\\n                UINT32_C (0xd76aa478));\n    MD5STEP_R1 (D, A, B, C, X[1]  = GET_X_FROM_DATA (M, 1),  12, \\\n                UINT32_C (0xe8c7b756));\n    MD5STEP_R1 (C, D, A, B, X[2]  = GET_X_FROM_DATA (M, 2),  17, \\\n                UINT32_C (0x242070db));\n    MD5STEP_R1 (B, C, D, A, X[3]  = GET_X_FROM_DATA (M, 3),  22, \\\n                UINT32_C (0xc1bdceee));\n\n    MD5STEP_R1 (A, B, C, D, X[4]  = GET_X_FROM_DATA (M, 4),  7, \\\n                UINT32_C (0xf57c0faf));\n    MD5STEP_R1 (D, A, B, C, X[5]  = GET_X_FROM_DATA (M, 5),  12, \\\n                UINT32_C (0x4787c62a));\n    MD5STEP_R1 (C, D, A, B, X[6]  = GET_X_FROM_DATA (M, 6),  17, \\\n                UINT32_C (0xa8304613));\n    MD5STEP_R1 (B, C, D, A, X[7]  = GET_X_FROM_DATA (M, 7),  22, \\\n                UINT32_C (0xfd469501));\n\n    MD5STEP_R1 (A, B, C, D, X[8]  = GET_X_FROM_DATA (M, 8),  7, \\\n                UINT32_C (0x698098d8));\n    MD5STEP_R1 (D, A, B, C, X[9]  = GET_X_FROM_DATA (M, 9),  12, \\\n                UINT32_C (0x8b44f7af));\n    MD5STEP_R1 (C, D, A, B, X[10] = GET_X_FROM_DATA (M, 10), 17, \\\n                UINT32_C (0xffff5bb1));\n    MD5STEP_R1 (B, C, D, A, X[11] = GET_X_FROM_DATA (M, 11), 22, \\\n                UINT32_C (0x895cd7be));\n\n    MD5STEP_R1 (A, B, C, D, X[12] = GET_X_FROM_DATA (M, 12), 7, \\\n                UINT32_C (0x6b901122));\n    MD5STEP_R1 (D, A, B, C, X[13] = GET_X_FROM_DATA (M, 13), 12, \\\n                UINT32_C (0xfd987193));\n    MD5STEP_R1 (C, D, A, B, X[14] = GET_X_FROM_DATA (M, 14), 17, \\\n                UINT32_C (0xa679438e));\n    MD5STEP_R1 (B, C, D, A, X[15] = GET_X_FROM_DATA (M, 15), 22, \\\n                UINT32_C (0x49b40821));\n  }\n\n  /* Round 2. */\n\n  MD5STEP_R2 (A, B, C, D, X[1], 5, UINT32_C (0xf61e2562));\n  MD5STEP_R2 (D, A, B, C, X[6], 9, UINT32_C (0xc040b340));\n  MD5STEP_R2 (C, D, A, B, X[11], 14, UINT32_C (0x265e5a51));\n  MD5STEP_R2 (B, C, D, A, X[0], 20, UINT32_C (0xe9b6c7aa));\n\n  MD5STEP_R2 (A, B, C, D, X[5], 5, UINT32_C (0xd62f105d));\n  MD5STEP_R2 (D, A, B, C, X[10], 9, UINT32_C (0x02441453));\n  MD5STEP_R2 (C, D, A, B, X[15], 14, UINT32_C (0xd8a1e681));\n  MD5STEP_R2 (B, C, D, A, X[4], 20, UINT32_C (0xe7d3fbc8));\n\n  MD5STEP_R2 (A, B, C, D, X[9], 5, UINT32_C (0x21e1cde6));\n  MD5STEP_R2 (D, A, B, C, X[14], 9, UINT32_C (0xc33707d6));\n  MD5STEP_R2 (C, D, A, B, X[3], 14, UINT32_C (0xf4d50d87));\n  MD5STEP_R2 (B, C, D, A, X[8], 20, UINT32_C (0x455a14ed));\n\n  MD5STEP_R2 (A, B, C, D, X[13], 5, UINT32_C (0xa9e3e905));\n  MD5STEP_R2 (D, A, B, C, X[2], 9, UINT32_C (0xfcefa3f8));\n  MD5STEP_R2 (C, D, A, B, X[7], 14, UINT32_C (0x676f02d9));\n  MD5STEP_R2 (B, C, D, A, X[12], 20, UINT32_C (0x8d2a4c8a));\n\n  /* Round 3. */\n\n  MD5STEP_R3 (A, B, C, D, X[5], 4, UINT32_C (0xfffa3942));\n  MD5STEP_R3 (D, A, B, C, X[8], 11, UINT32_C (0x8771f681));\n  MD5STEP_R3 (C, D, A, B, X[11], 16, UINT32_C (0x6d9d6122));\n  MD5STEP_R3 (B, C, D, A, X[14], 23, UINT32_C (0xfde5380c));\n\n  MD5STEP_R3 (A, B, C, D, X[1], 4, UINT32_C (0xa4beea44));\n  MD5STEP_R3 (D, A, B, C, X[4], 11, UINT32_C (0x4bdecfa9));\n  MD5STEP_R3 (C, D, A, B, X[7], 16, UINT32_C (0xf6bb4b60));\n  MD5STEP_R3 (B, C, D, A, X[10], 23, UINT32_C (0xbebfbc70));\n\n  MD5STEP_R3 (A, B, C, D, X[13], 4, UINT32_C (0x289b7ec6));\n  MD5STEP_R3 (D, A, B, C, X[0], 11, UINT32_C (0xeaa127fa));\n  MD5STEP_R3 (C, D, A, B, X[3], 16, UINT32_C (0xd4ef3085));\n  MD5STEP_R3 (B, C, D, A, X[6], 23, UINT32_C (0x04881d05));\n\n  MD5STEP_R3 (A, B, C, D, X[9], 4, UINT32_C (0xd9d4d039));\n  MD5STEP_R3 (D, A, B, C, X[12], 11, UINT32_C (0xe6db99e5));\n  MD5STEP_R3 (C, D, A, B, X[15], 16, UINT32_C (0x1fa27cf8));\n  MD5STEP_R3 (B, C, D, A, X[2], 23, UINT32_C (0xc4ac5665));\n\n  /* Round 4. */\n\n  MD5STEP_R4 (A, B, C, D, X[0], 6, UINT32_C (0xf4292244));\n  MD5STEP_R4 (D, A, B, C, X[7], 10, UINT32_C (0x432aff97));\n  MD5STEP_R4 (C, D, A, B, X[14], 15, UINT32_C (0xab9423a7));\n  MD5STEP_R4 (B, C, D, A, X[5], 21, UINT32_C (0xfc93a039));\n\n  MD5STEP_R4 (A, B, C, D, X[12], 6, UINT32_C (0x655b59c3));\n  MD5STEP_R4 (D, A, B, C, X[3], 10, UINT32_C (0x8f0ccc92));\n  MD5STEP_R4 (C, D, A, B, X[10], 15, UINT32_C (0xffeff47d));\n  MD5STEP_R4 (B, C, D, A, X[1], 21, UINT32_C (0x85845dd1));\n\n  MD5STEP_R4 (A, B, C, D, X[8], 6, UINT32_C (0x6fa87e4f));\n  MD5STEP_R4 (D, A, B, C, X[15], 10, UINT32_C (0xfe2ce6e0));\n  MD5STEP_R4 (C, D, A, B, X[6], 15, UINT32_C (0xa3014314));\n  MD5STEP_R4 (B, C, D, A, X[13], 21, UINT32_C (0x4e0811a1));\n\n  MD5STEP_R4 (A, B, C, D, X[4], 6, UINT32_C (0xf7537e82));\n  MD5STEP_R4 (D, A, B, C, X[11], 10, UINT32_C (0xbd3af235));\n  MD5STEP_R4 (C, D, A, B, X[2], 15, UINT32_C (0x2ad7d2bb));\n  MD5STEP_R4 (B, C, D, A, X[9], 21, UINT32_C (0xeb86d391));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    static const uint32_t T[64] =\n    { UINT32_C (0xd76aa478), UINT32_C (0xe8c7b756), UINT32_C (0x242070db),\n      UINT32_C (0xc1bdceee), UINT32_C (0xf57c0faf), UINT32_C (0x4787c62a),\n      UINT32_C (0xa8304613), UINT32_C (0xfd469501), UINT32_C (0x698098d8),\n      UINT32_C (0x8b44f7af), UINT32_C (0xffff5bb1), UINT32_C (0x895cd7be),\n      UINT32_C (0x6b901122), UINT32_C (0xfd987193), UINT32_C (0xa679438e),\n      UINT32_C (0x49b40821), UINT32_C (0xf61e2562), UINT32_C (0xc040b340),\n      UINT32_C (0x265e5a51), UINT32_C (0xe9b6c7aa), UINT32_C (0xd62f105d),\n      UINT32_C (0x02441453), UINT32_C (0xd8a1e681), UINT32_C (0xe7d3fbc8),\n      UINT32_C (0x21e1cde6), UINT32_C (0xc33707d6), UINT32_C (0xf4d50d87),\n      UINT32_C (0x455a14ed), UINT32_C (0xa9e3e905), UINT32_C (0xfcefa3f8),\n      UINT32_C (0x676f02d9), UINT32_C (0x8d2a4c8a), UINT32_C (0xfffa3942),\n      UINT32_C (0x8771f681), UINT32_C (0x6d9d6122), UINT32_C (0xfde5380c),\n      UINT32_C (0xa4beea44), UINT32_C (0x4bdecfa9), UINT32_C (0xf6bb4b60),\n      UINT32_C (0xbebfbc70), UINT32_C (0x289b7ec6), UINT32_C (0xeaa127fa),\n      UINT32_C (0xd4ef3085), UINT32_C (0x04881d05), UINT32_C (0xd9d4d039),\n      UINT32_C (0xe6db99e5), UINT32_C (0x1fa27cf8), UINT32_C (0xc4ac5665),\n      UINT32_C (0xf4292244), UINT32_C (0x432aff97), UINT32_C (0xab9423a7),\n      UINT32_C (0xfc93a039), UINT32_C (0x655b59c3), UINT32_C (0x8f0ccc92),\n      UINT32_C (0xffeff47d), UINT32_C (0x85845dd1), UINT32_C (0x6fa87e4f),\n      UINT32_C (0xfe2ce6e0), UINT32_C (0xa3014314), UINT32_C (0x4e0811a1),\n      UINT32_C (0xf7537e82), UINT32_C (0xbd3af235), UINT32_C (0x2ad7d2bb),\n      UINT32_C (0xeb86d391) };\n    unsigned int i; /**< Zero-based index */\n\n    /* Round 1. */\n\n    i = 0;\n    do\n    {\n      /* The input data is loaded in correct (little-endian) format before\n         calculations on each step. */\n      MD5STEP_R1 (A, B, C, D, X[i]  = GET_X_FROM_DATA (M, i),  7,  T[i]);\n      ++i;\n      MD5STEP_R1 (D, A, B, C, X[i]  = GET_X_FROM_DATA (M, i),  12, T[i]);\n      ++i;\n      MD5STEP_R1 (C, D, A, B, X[i]  = GET_X_FROM_DATA (M, i),  17, T[i]);\n      ++i;\n      MD5STEP_R1 (B, C, D, A, X[i]  = GET_X_FROM_DATA (M, i),  22, T[i]);\n      ++i;\n    } while (i < 16);\n\n    /* Round 2. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R2 (A, B, C, D, X[(1U  + idx_add) & 15U], 5,  T[i]);\n      ++i;\n      MD5STEP_R2 (D, A, B, C, X[(6U  + idx_add) & 15U], 9,  T[i]);\n      ++i;\n      MD5STEP_R2 (C, D, A, B, X[(11U + idx_add) & 15U], 14, T[i]);\n      ++i;\n      MD5STEP_R2 (B, C, D, A, X[(0U  + idx_add) & 15U], 20, T[i]);\n      ++i;\n    } while (i < 32);\n\n    /* Round 3. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R3 (A, B, C, D, X[(5U  + 64U - idx_add) & 15U], 4,  T[i]);\n      ++i;\n      MD5STEP_R3 (D, A, B, C, X[(8U  + 64U - idx_add) & 15U], 11, T[i]);\n      ++i;\n      MD5STEP_R3 (C, D, A, B, X[(11U + 64U - idx_add) & 15U], 16, T[i]);\n      ++i;\n      MD5STEP_R3 (B, C, D, A, X[(14U + 64U - idx_add) & 15U], 23, T[i]);\n      ++i;\n    } while (i < 48);\n\n    /* Round 4. */\n\n    do\n    {\n      const unsigned int idx_add = i;\n      MD5STEP_R4 (A, B, C, D, X[(0U  + 64U - idx_add) & 15U], 6,  T[i]);\n      ++i;\n      MD5STEP_R4 (D, A, B, C, X[(7U  + 64U - idx_add) & 15U], 10, T[i]);\n      ++i;\n      MD5STEP_R4 (C, D, A, B, X[(14U + 64U - idx_add) & 15U], 15, T[i]);\n      ++i;\n      MD5STEP_R4 (B, C, D, A, X[(5U  + 64U - idx_add) & 15U], 21, T[i]);\n      ++i;\n    } while (i < 64);\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Finally increment and store working variables.\n     See RFC 1321, end of Clause 3.4 (step 4). */\n\n  H[0] += A;\n  H[1] += B;\n  H[2] += C;\n  H[3] += D;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstatic size_t\nget_nonce_nc_idx (size_t arr_size,\n                  const char *nonce,\n                  size_t noncelen)\n{\n  mhd_assert (0 != arr_size);\n  mhd_assert (0 != noncelen);\n  return fast_simple_hash ((const uint8_t *) nonce, noncelen) % arr_size;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: get_nonce_nc_idx calls fast_simple_hash, and fast_simple_hash is a simple non\u2011recursive function (it does not call get_nonce_nc_idx or any other function that eventually calls get_nonce_nc_idx). There is no direct or indirect recursion in the shown call graph, so MISRA C 2023 Rule 17.2 is not violated."
}