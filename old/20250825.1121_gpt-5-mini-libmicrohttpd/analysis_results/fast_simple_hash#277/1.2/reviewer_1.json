{
  "user_message": "An agent A claimed that the following fast_simple_hash code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of fast_simple_hash.\n```c\nstatic uint32_t\nfast_simple_hash (const uint8_t *data,\n                  size_t data_size)\n{\n  uint32_t hash;\n\n  if (0 != data_size)\n  {\n    size_t i;\n    hash = data[0];\n    for (i = 1; i < data_size; i++)\n      hash = _MHD_ROTL32 (hash, 7) ^ data[i];\n  }\n  else\n    hash = 0;\n\n  return hash;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro _MHD_ROTL32 invokes the compiler-specific builtin __builtin_rotateleft32, which is a GCC/Clang intrinsic (a documented compiler extension) and not part of standard C. Using this builtin in the definition constitutes a use of a language/compiler extension and therefore violates MISRA C 2023 Rule 1.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function fast_simple_hash:\n#define _MHD_ROTL32(value32, bits) ((uint32_t)__builtin_rotateleft32((value32),(bits)))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The supplied macro definition shows that _MHD_ROTL32 expands to (uint32_t)__builtin_rotateleft32(...). The name __builtin_rotateleft32 is a compiler intrinsic (GCC/Clang builtin) and is not part of standard ISO C; it is documented as a compiler extension. MISRA C 2023 Rule 1.2 forbids use of language/compiler extensions that are documented as such, so the code (via that macro) violates Rule 1.2. (If the macro were replaced by a strictly standard-C implementation of rotate or guarded so that no compiler builtin is used, there would be no Rule 1.2 violation.)"
}