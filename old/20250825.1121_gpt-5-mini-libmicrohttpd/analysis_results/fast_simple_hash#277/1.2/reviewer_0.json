{
  "user_message": "An agent A claimed that the following fast_simple_hash code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of fast_simple_hash.\n```c\nstatic uint32_t\nfast_simple_hash (const uint8_t *data,\n                  size_t data_size)\n{\n  uint32_t hash;\n\n  if (0 != data_size)\n  {\n    size_t i;\n    hash = data[0];\n    for (i = 1; i < data_size; i++)\n      hash = _MHD_ROTL32 (hash, 7) ^ data[i];\n  }\n  else\n    hash = 0;\n\n  return hash;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro _MHD_ROTL32 expands to the compiler builtin __builtin_rotateleft32, e.g. ((uint32_t)__builtin_rotateleft32((value32),(bits))). The fragment hash = _MHD_ROTL32(hash, 7) ^ data[i]; therefore relies on a compiler-specific builtin extension, which is an explicit language extension in compiler documentation (GCC/clang builtins).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function fast_simple_hash:\n#define _MHD_ROTL32(value32, bits) ((uint32_t)__builtin_rotateleft32((value32),(bits)))\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The provided macro definition shows that _MHD_ROTL32 expands to a compiler builtin ((__uint32_t)__builtin_rotateleft32(...)), which is a vendor-specific/implementation-defined compiler extension (GCC/Clang builtin). MISRA C:2023 Rule 1.2 prohibits use of language/compiler extensions; therefore the code as given violates Rule 1.2. (If the macro were instead defined in terms of standard C operations or to a documented portable fallback on compilers that do not provide the builtin, then it would not necessarily be a violation.)"
}