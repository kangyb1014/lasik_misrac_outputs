{
  "user_message": "An agent A claimed that the following add_response_entry code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of add_response_entry.\n```c\nstatic enum MHD_Result\nadd_response_entry (struct MHD_Response *response,\n                    enum MHD_ValueKind kind,\n                    const char *header,\n                    const char *content)\n{\n  size_t header_len;\n  size_t content_len;\n\n  if (NULL == content)\n    return MHD_NO;\n\n  header_len = strlen (header);\n  content_len = strlen (content);\n  return add_response_entry_n (response, kind, header,\n                               header_len, content,\n                               content_len) ? MHD_YES : MHD_NO;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointers 'header' and 'content' are declared as const char * in add_response_entry_n but are passed to MHD_add_response_entry_no_check_. If that callee is declared to take non-const char * for header and/or content, the const qualifier is discarded (an implicit conversion from const char * to char *), which violates MISRA C 2023 Rule 8.13. (If, however, MHD_add_response_entry_no_check_ is declared to take const char * for those parameters, no violation occurs.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function add_response_entry:\nstatic bool\nadd_response_entry_n (struct MHD_Response *response,\n                      enum MHD_ValueKind kind,\n                      const char *header,\n                      size_t header_len,\n                      const char *content,\n                      size_t content_len)\n{\n  if (NULL == response)\n    return false;\n  if (0 == header_len)\n    return false;\n  if (0 == content_len)\n    return false;\n  if (NULL != memchr (header, '\\t', header_len))\n    return false;\n  if (NULL != memchr (header, ' ', header_len))\n    return false;\n  if (NULL != memchr (header, '\\r', header_len))\n    return false;\n  if (NULL != memchr (header, '\\n', header_len))\n    return false;\n  if (NULL != memchr (content, '\\r', content_len))\n    return false;\n  if (NULL != memchr (content, '\\n', content_len))\n    return false;\n\n  return MHD_add_response_entry_no_check_ (response, kind, header, header_len,\n                                           content, content_len);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The claim is not proven by the code shown. add_response_entry and add_response_entry_n both use const char * for header and content (so these functions themselves are const-correct). A violation of MISRA C:2023 Rule 8.13 would only occur if MHD_add_response_entry_no_check_ is declared to take non-const char * parameters and those const-qualified pointers are implicitly passed to it (thereby discarding the const qualifier). The additional code calls MHD_add_response_entry_no_check_ without showing its prototype; if that callee\u2019s prototype uses const char * for those parameters, there is no violation. If its prototype instead uses char * (non-const), then the agent A\u2019s report would be correct and the code should be fixed (or the callee\u2019s prototype changed) to avoid discarding const. Therefore the report as stated is not definitively correct based on the provided code \u2014 it is only conditionally correct depending on the declaration of MHD_add_response_entry_no_check_."
}