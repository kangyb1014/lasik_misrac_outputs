{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n                  const struct sockaddr_storage *addr,\n                  socklen_t addrlen)\n{\n  struct MHD_IPCount *newkeyp;\n  struct MHD_IPCount *keyp;\n  struct MHD_IPCount **nodep;\n  enum MHD_Result result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  newkeyp = (struct MHD_IPCount *) malloc (sizeof(struct MHD_IPCount));\n  if (NULL == newkeyp)\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    newkeyp))\n  {\n    free (newkeyp);\n    return MHD_YES; /* Allow unhandled address types through */\n  }\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  nodep = (struct MHD_IPCount **) tsearch (newkeyp,\n                                           &daemon->per_ip_connection_count,\n                                           &MHD_ip_addr_compare);\n  if (NULL == nodep)\n  {\n    MHD_ip_count_unlock (daemon);\n    free (newkeyp);\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to add IP connection count node.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  keyp = *nodep;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (keyp->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_NO != result)\n    ++keyp->count;\n  MHD_ip_count_unlock (daemon);\n\n  /* If we got an existing node back, free the one we created */\n  if (keyp != newkeyp)\n    free (newkeyp);\n\n  return result;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_ip_limit_add': {'callees': ['MHD_get_master', 'MHD_ip_addr_to_key', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_DLOG'], 'callers': ['new_connection_prepare_']}, 'MHD_get_master': {'callees': [], 'callers': ['MHD_get_connection_info', 'MHD_ip_limit_add', 'MHD_ip_limit_del', 'check_nonce_nc', 'calculate_add_nonce', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'MHD_ip_addr_to_key': {'callees': [], 'callers': ['MHD_ip_limit_add', 'MHD_ip_limit_del']}, 'MHD_ip_count_lock': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_ip_limit_add', 'MHD_ip_limit_del']}, 'MHD_ip_count_unlock': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_ip_limit_add', 'MHD_ip_limit_del']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "struct MHD_IPCount",
    "enum MHD_Result",
    "MHD_get_master",
    "MHD_ip_addr_to_key",
    "MHD_ip_addr_compare",
    "MHD_ip_count_lock",
    "MHD_ip_count_unlock",
    "MHD_DLOG",
    "HAVE_MESSAGES",
    "_",
    "tsearch",
    "malloc",
    "free",
    "NULL",
    "socklen_t",
    "MHD_YES",
    "MHD_NO"
  ],
  "explanation": "For a correct MISRA check for use of compiler language extensions, the analyzer must inspect any symbol used or referenced by MHD_ip_limit_add whose definition or macro-expansion might hide an extension. Reason for each symbol: \n\n- struct MHD_Daemon: to examine the types and declarations of fields accessed (per_ip_connection_limit, per_ip_connection_count). Those fields could be declared with attributes/extension tokens (e.g. GCC __attribute__, typeof, bit-fields with implementation-defined behaviour). \n\n- struct MHD_IPCount: to inspect the layout and the member 'count' and to check whether the type uses any non-standard extensions (packed/attribute, typeof, anonymous members, etc.).\n\n- enum MHD_Result: to verify the enum definition and whether its values (MHD_YES, MHD_NO) use any extension (e.g. explicit underlying type attributes).\n\n- MHD_get_master: to inspect its declaration/definition for language-extension usage (inline, attributes, macros that expand to builtins, non-standard calling conventions).\n\n- MHD_ip_addr_to_key: to inspect its prototype/definition for non-standard parameter/return attributes or macros.\n\n- MHD_ip_addr_compare: tsearch uses a compare callback; its declaration/definition must be checked for non-standard function pointer attributes or extension constructs used in the comparator implementation.\n\n- MHD_ip_count_lock and MHD_ip_count_unlock: to inspect their implementations (they may expand to macros or use compiler builtins like __builtin_unreachable, inline assembly, or other extensions). The static call graph indicates __builtin_unreachable may appear in their callees, so these must be checked.\n\n- MHD_DLOG: to inspect macro/implementation: logging macros often expand to variadic macros, GCC extensions, or call gettext _(); it may hide extensions (statement expressions, asm, attributes).\n\n- HAVE_MESSAGES: the conditional compilation macro controls whether MHD_DLOG is used; the macro definitions and related headers may themselves use extensions \u2014 need to inspect.\n\n- _: the gettext-like macro/function used around the string \u2014 its definition may be a macro that uses extensions or non-standard language features.\n\n- tsearch: standard library function, but its prototype and use (void * key, void **rootp, compar) and possible platform-specific headers could include non-standard macros/attributes; check for use of non\u2011standard extensions in its header or interactions.\n\n- malloc and free: inspect their prototypes/macros (some projects wrap them with macros or attributes \u2014 e.g. __malloc__, __attribute__((malloc))) which are compiler extensions.\n\n- NULL: inspect how NULL is defined in the build (some platforms define NULL as ((void*)0) \u2014 acceptable in C, but other definitions or macros could be non-standard).\n\n- socklen_t: typedef for portability; check its definition for any extension or platform-specific typedefs.\n\n- MHD_YES and MHD_NO: the symbolic enum values used by the function \u2014 ensure they come from a standard enum and not from macros or extension constructs.\n\nSummary: these symbols cover all types, macros, functions and fields referenced by MHD_ip_limit_add whose definitions or macro expansions could introduce compiler-specific language extensions. The analyzer must examine these definitions to determine whether any extension (GCC/Clang builtins, attributes, statement expressions, asm, typeof, __extension__, etc.) is used and thus whether the MISRA rule is violated."
}