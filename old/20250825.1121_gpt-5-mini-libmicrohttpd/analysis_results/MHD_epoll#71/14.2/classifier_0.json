{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_epoll:\n```c\nstatic enum MHD_Result\nMHD_epoll (struct MHD_Daemon *daemon,\n           int32_t millisec)\n{\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  static const char *const upgrade_marker = \"upgrade_ptr\";\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n  struct epoll_event events[MAX_EVENTS];\n  struct epoll_event event;\n  int timeout_ms;\n  int num_events;\n  unsigned int i;\n  MHD_socket ls;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  bool run_upgraded = false;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  bool need_to_accept;\n\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 != (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (! MHD_thread_handle_ID_is_valid_ID_ (daemon->tid)));\n  mhd_assert ((0 == (daemon->options & MHD_USE_SELECT_INTERNALLY)) || \\\n              (MHD_thread_handle_ID_is_current_thread_ (daemon->tid)));\n\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO; /* we're down! */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (daemon->connections < daemon->connection_limit) &&\n       (! daemon->listen_socket_in_epoll) &&\n       (! daemon->at_limit) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n  if ( (daemon->was_quiesced) &&\n       (daemon->listen_socket_in_epoll) )\n  {\n    if ( (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_DEL,\n                          ls,\n                          NULL)) &&\n         (ENOENT != errno) )   /* ENOENT can happen due to race with\n                                  #MHD_quiesce_daemon() */\n      MHD_PANIC (\"Failed to remove listen FD from epoll set.\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if ( ( (! daemon->upgrade_fd_in_epoll) &&\n         (-1 != daemon->epoll_upgrade_fd) ) )\n  {\n    event.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (upgrade_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        daemon->epoll_upgrade_fd,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->upgrade_fd_in_epoll = true;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (daemon->listen_socket_in_epoll) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ||\n         (daemon->was_quiesced) ) )\n  {\n    /* we're at the connection limit, disable listen socket\n for event loop for now */\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        ls,\n                        NULL))\n      MHD_PANIC (_ (\"Failed to remove listen FD from epoll set.\\n\"));\n    daemon->listen_socket_in_epoll = false;\n  }\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_NO != resume_suspended_connections (daemon)) )\n    millisec = 0;\n\n  timeout_ms = get_timeout_millisec_int (daemon, millisec);\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: Used mostly for uniformity here as same situation is\n   * signaled in epoll mode by non-empty eready DLL. */\n  daemon->data_already_pending = false;\n\n  need_to_accept = false;\n  /* drain 'epoll' event queue; need to iterate as we get at most\n     MAX_EVENTS in one system call here; in practice this should\n     pretty much mean only one round, but better an extra loop here\n     than unfair behavior... */\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n  {\n    /* update event masks */\n    num_events = epoll_wait (daemon->epoll_fd,\n                             events,\n                             MAX_EVENTS,\n                             timeout_ms);\n    if (-1 == num_events)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_YES;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_wait failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n    for (i = 0; i < (unsigned int) num_events; i++)\n    {\n      /* First, check for the values of `ptr` that would indicate\n         that this event is not about a normal connection. */\n      if (NULL == events[i].data.ptr)\n        continue;     /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if (upgrade_marker == events[i].data.ptr)\n      {\n        /* activity on an upgraded connection, we process\n           those in a separate epoll() */\n        run_upgraded = true;\n        continue;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n      if (epoll_itc_marker == events[i].data.ptr)\n      {\n        /* It's OK to clear ITC here as all external\n           conditions will be processed later. */\n        MHD_itc_clear_ (daemon->itc);\n        continue;\n      }\n      if (daemon == events[i].data.ptr)\n      {\n        /* Check for error conditions on listen socket. */\n        /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n        if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n          need_to_accept = true;\n        continue;\n      }\n      /* this is an event relating to a 'normal' connection,\n         remember the event and if appropriate mark the\n         connection as 'eready'. */\n      pos = events[i].data.ptr;\n      /* normal processing: update read/write data */\n      if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n      {\n        pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n        if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_insert (daemon->eready_head,\n                       daemon->eready_tail,\n                       pos);\n          pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      }\n      else\n      {\n        if (0 != (events[i].events & EPOLLIN))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n          if ( ( (0 != (MHD_EVENT_LOOP_INFO_READ & pos->event_loop_info)) ||\n                 (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n        if (0 != (events[i].events & EPOLLOUT))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n          if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n      }\n    }\n  }\n\n  /* Process externally added connection if any */\n  if (daemon->have_new)\n    new_connections_list_process_ (daemon);\n\n  if (need_to_accept)\n  {\n    unsigned int series_length = 0;\n\n    /* Run 'accept' until it fails or daemon at limit of connections.\n     * Do not accept more then 10 connections at once. The rest will\n     * be accepted on next turn (level trigger is used for listen\n     * socket). */\n    while ( (MHD_NO != MHD_accept_connection (daemon)) &&\n            (series_length < 10) &&\n            (daemon->connections < daemon->connection_limit) &&\n            (! daemon->at_limit) )\n      series_length++;\n  }\n\n  /* Handle timed-out connections; we need to do this here\n     as the epoll mechanism won't call the 'MHD_connection_handle_idle()' on everything,\n     as the other event loops do.  As timeouts do not get an explicit\n     event, we need to find those connections that might have timed out\n     here.\n\n     Connections with custom timeouts must all be looked at, as we\n     do not bother to sort that (presumably very short) list. */\n  prev = daemon->manual_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n  }\n  /* Connections with the default timeout are sorted by prepending\n     them to the head of the list whenever we touch the connection;\n     thus it suffices to iterate from the tail until the first\n     connection is NOT timed out */\n  prev = daemon->normal_timeout_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevX;\n    MHD_connection_handle_idle (pos);\n    if (MHD_CONNECTION_CLOSED != pos->state)\n      break; /* sorted by timeout, no need to visit the rest! */\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (run_upgraded || (NULL != daemon->eready_urh_head))\n    run_epoll_for_upgrade (daemon);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* process events for connections */\n  prev = daemon->eready_tail;\n  while (NULL != (pos = prev))\n  {\n    prev = pos->prevE;\n    call_handlers (pos,\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_READ_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY),\n                   0 != (pos->epoll_state & MHD_EPOLL_STATE_ERROR));\n    if (MHD_EPOLL_STATE_IN_EREADY_EDLL ==\n        (pos->epoll_state & (MHD_EPOLL_STATE_SUSPENDED\n                             | MHD_EPOLL_STATE_IN_EREADY_EDLL)))\n    {\n      if ( ((MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_READ_READY)) ) ||\n           ((MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n            (0 == (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY)) ) ||\n           (MHD_EVENT_LOOP_INFO_CLEANUP == pos->event_loop_info) )\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n    }\n  }\n\n  return MHD_YES;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_epoll:\n#define EDLL_insert(head, tail, element) do{(element)->nextE=(head);(element)->prevE=NULL;if((tail)==NULL){(tail)=element;}else{(head)->prevE=element;}(head)=(element);}while(0)\n...\n#define MHD_itc_clear_(itc) do{uint64_t__b;(void)read((itc).fd,(void*)&__b,sizeof(__b));}while(0)\n...\nstatic const char *const epoll_itc_marker = \"itc_marker\"\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nfor (i = 0; i < (unsigned int) num_events; i++)\n    {\n      /* First, check for the values of `ptr` that would indicate\n         that this event is not about a normal connection. */\n      if (NULL == events[i].data.ptr)\n        continue;     /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if (upgrade_marker == events[i].data.ptr)\n      {\n        /* activity on an upgraded connection, we process\n           those in a separate epoll() */\n        run_upgraded = true;\n        continue;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n      if (epoll_itc_marker == events[i].data.ptr)\n      {\n        /* It's OK to clear ITC here as all external\n           conditions will be processed later. */\n        MHD_itc_clear_ (daemon->itc);\n        continue;\n      }\n      if (daemon == events[i].data.ptr)\n      {\n        /* Check for error conditions on listen socket. */\n        /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n        if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n          need_to_accept = true;\n        continue;\n      }\n      /* this is an event relating to a 'normal' connection,\n         remember the event and if appropriate mark the\n         connection as 'eready'. */\n      pos = events[i].data.ptr;\n      /* normal processing: update read/write data */\n      if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n      {\n        pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n        if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_insert (daemon->eready_head,\n                       daemon->eready_tail,\n                       pos);\n          pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      }\n      else\n      {\n        if (0 != (events[i].events & EPOLLIN))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n          if ( ( (0 != (MHD_EVENT_LOOP_INFO_READ & pos->event_loop_info)) ||\n                 (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n        if (0 != (events[i].events & EPOLLOUT))\n        {\n          pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n          if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n               (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n          {\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         pos);\n            pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n          }\n        }\n      }\n    }\n```\nFocus on the above code fragment and judge whether it violates the rule 14.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The for loop uses a single loop counter i initialized in the first clause (i = 0). The second clause is i < (unsigned int) num_events, which uses the loop counter and num_events; num_events is not modified by the loop body or by any functions/macros called within the body, so there are no persistent side effects. The third clause i++ modifies only the loop counter. The loop counter i is not modified inside the loop body. Therefore Rule 14.2 is satisfied."
}