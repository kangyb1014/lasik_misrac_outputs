{
  "user_message": "An agent A claimed that the following find_boundary code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of find_boundary.\n```c\nstatic int\nfind_boundary (struct MHD_PostProcessor *pp,\n               const char *boundary,\n               size_t blen,\n               size_t *ioffptr,\n               enum PP_State next_state,\n               enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  const char *dash;\n\n  if (pp->buffer_pos < 2 + blen)\n  {\n    if (pp->buffer_pos == pp->buffer_size)\n      pp->state = PP_Error;     /* out of memory */\n    /* ++(*ioffptr); */\n    return MHD_NO;              /* not enough data */\n  }\n  if ( (0 != memcmp (\"--\",\n                     buf,\n                     2)) ||\n       (0 != memcmp (&buf[2],\n                     boundary,\n                     blen)))\n  {\n    if (pp->state != PP_Init)\n    {\n      /* garbage not allowed */\n      pp->state = PP_Error;\n    }\n    else\n    {\n      /* skip over garbage (RFC 2046, 5.1.1) */\n      dash = memchr (buf,\n                     '-',\n                     pp->buffer_pos);\n      if (NULL == dash)\n        (*ioffptr) += pp->buffer_pos;         /* skip entire buffer */\n      else if (dash == buf)\n        (*ioffptr)++;                         /* at least skip one byte */\n      else\n        (*ioffptr) += (size_t) (dash - buf);  /* skip to first possible boundary */\n    }\n    return MHD_NO;                            /* expected boundary */\n  }\n  /* remove boundary from buffer */\n  (*ioffptr) += 2 + blen;\n  /* next: start with headers */\n  pp->skip_rn = RN_Dash;\n  pp->state = next_state;\n  pp->dash_state = next_dash_state;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local buffer pointer is declared as `char *buf = (char *)&pp[1];` but is only used for read-only operations (memcmp, memchr). In the fragment `dash = memchr (buf, '-', pp->buffer_pos);` a non-const pointer is passed where a const-qualified pointer would be appropriate. According to MISRA C 2023 Rule 8.13, the pointer should be const-qualified whenever possible \u2014 e.g. declare `const char *buf = (const char *)&pp[1];` \u2014 so the current code violates the rule.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_boundary:\nstruct MHD_PostProcessor *pp\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The local pointer buf is only used for read-only operations (memcmp, memchr) and is never used to modify the underlying bytes, so per MISRA C:2023 Rule 8.13 it should be declared to point to a const-qualified type (e.g. const char *buf = (const char *)&pp[1];). The called library functions accept const-qualified pointers (memcmp takes const void *; memchr accepts a const void * as its input), so there is no API impediment to making buf const. Changing the cast to (const char *)&pp[1] and declaring buf as const char *resolves the violation."
}