{
  "user_message": "An agent A claimed that the following find_boundary code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of find_boundary.\n```c\nstatic int\nfind_boundary (struct MHD_PostProcessor *pp,\n               const char *boundary,\n               size_t blen,\n               size_t *ioffptr,\n               enum PP_State next_state,\n               enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  const char *dash;\n\n  if (pp->buffer_pos < 2 + blen)\n  {\n    if (pp->buffer_pos == pp->buffer_size)\n      pp->state = PP_Error;     /* out of memory */\n    /* ++(*ioffptr); */\n    return MHD_NO;              /* not enough data */\n  }\n  if ( (0 != memcmp (\"--\",\n                     buf,\n                     2)) ||\n       (0 != memcmp (&buf[2],\n                     boundary,\n                     blen)))\n  {\n    if (pp->state != PP_Init)\n    {\n      /* garbage not allowed */\n      pp->state = PP_Error;\n    }\n    else\n    {\n      /* skip over garbage (RFC 2046, 5.1.1) */\n      dash = memchr (buf,\n                     '-',\n                     pp->buffer_pos);\n      if (NULL == dash)\n        (*ioffptr) += pp->buffer_pos;         /* skip entire buffer */\n      else if (dash == buf)\n        (*ioffptr)++;                         /* at least skip one byte */\n      else\n        (*ioffptr) += (size_t) (dash - buf);  /* skip to first possible boundary */\n    }\n    return MHD_NO;                            /* expected boundary */\n  }\n  /* remove boundary from buffer */\n  (*ioffptr) += 2 + blen;\n  /* next: start with headers */\n  pp->skip_rn = RN_Dash;\n  pp->state = next_state;\n  pp->dash_state = next_dash_state;\n  return MHD_YES;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call memchr(buf, '-', pp->buffer_pos) assumes that buf (defined as (char *)&pp[1]) points to at least pp->buffer_pos bytes of valid memory. If the object immediately following the pp structure is not an array of at least pp->buffer_pos bytes (for example if the trailing buffer was not allocated, if pp->buffer_pos > pp->buffer_size due to corruption, or the allocation layout differs), memchr may read past the end of the object and thus access out-of-bounds memory.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function find_boundary:\nconst void *buffer\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code computes buf as (char *)&pp[1], i.e. the address immediately after the pp object, and then calls memcmp/memchr with lengths derived from pp->buffer_pos. Nothing in the shown code proves that memory at buf actually comprises at least pp->buffer_pos bytes: if the object following pp is not an allocated trailing buffer (or pp->buffer_pos is corrupted or larger than the actual allocation), the calls to memcmp(&buf[2], ..., blen) and memchr(buf, '-', pp->buffer_pos) can read beyond the bounds of the object referenced by buf. Even though there is a guard that returns early when pp->buffer_pos < 2 + blen, that only ensures the memcmp sizes are <= pp->buffer_pos \u2014 it does not guarantee that buf points to an object of at least pp->buffer_pos bytes. Per MISRA C 2023 Rule 21.17, uses of string.h functions must not allow accesses beyond the bounds of the objects passed; the code as shown does not provide the necessary guarantee, so the reported violation is valid."
}