{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of mhd_tool_get_system_cpu_count:\n```c\nint\nmhd_tool_get_system_cpu_count (void)\n{\n  int res;\n\n  /* Try specialised APIs first */\n  res = mhd_tool_get_sys_cpu_count_special_api_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysctl*(). This is typically a direct interface to\n     kernel values. */\n  res = mhd_tool_get_sys_cpu_count_sysctl_ ();\n  if (0 < res)\n    return res;\n\n  /* Try sysconf() as the last resort as this is a generic interface\n     which can be implemented by parsing system files. */\n  res = mhd_tool_get_sys_cpu_count_sysconf_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n  if (0 < res)\n  {\n    /* '1' or '2' could a be fallback number.\n     * See get_nprocs_fallback() in glibc\n       sysdeps/unix/sysv/linux/getsysstats.c */\n\n    int proc_cpu_count;\n\n    proc_cpu_count = mhd_tool_get_proc_cpu_count ();\n    if (proc_cpu_count == res)\n    {\n      /* The detected number of CPUs available for the process\n         is equal to the detected number of system CPUs.\n         Assume detected number is correct. */\n      return res;\n    }\n  }\n#endif /* __linux__ || __GLIBC__  */\n\n  /* Try available fallbacks */\n\n  res = mhd_tool_get_sys_cpu_count_sysctl_fallback_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_sys_cpu_count_sysconf_fallback_ ();\n#if ! defined(__linux__) && ! defined(__GLIBC__)\n  if (0 < res)\n    return res;\n#else  /* __linux__ || __GLIBC__ */\n  if (2 < res)\n    return res;\n#endif /* __linux__ || __GLIBC__  */\n\n  return -1; /* Cannot detect */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function mhd_tool_get_system_cpu_count:\nstatic int\nmhd_tool_get_sys_cpu_count_special_api_ (void)\n{\n  int ret = -1;\n#ifdef HAVE_PSTAT_GETDYNAMIC\n  if (0 >= ret)\n  {\n    /* HP-UX things */\n    struct pst_dynamic psd_data;\n    memset ((void *) &psd_data, 0, sizeof (psd_data));\n    if (1 == pstat_getdynamic (&psd_data, sizeof (psd_data), (size_t) 1, 0))\n    {\n      if (0 < psd_data.psd_proc_cnt)\n        ret = (int) psd_data.psd_proc_cnt;\n    }\n  }\n#endif /* HAVE_PSTAT_GETDYNAMIC */\n#ifdef HAVE_VXCPUENABLEDGET\n  if (0 >= ret)\n  {\n    /* VxWorks */\n    cpuset_t enb_set;\n    enb_set = vxCpuEnabledGet ();\n    /* Count set bits */\n    for (ret = 0; 0 != enb_set; enb_set &= enb_set - 1)\n      ++ret;\n  }\n#endif /* HAVE_VXCPUENABLEDGET */\n#if defined(_WIN32) && ! defined (__CYGWIN__)\n  if (0 >= ret)\n  {\n    /* Native W32 */\n    HMODULE k32hndl;\n    k32hndl = LoadLibraryA (\"kernel32.dll\");\n    if (NULL != k32hndl)\n    {\n      typedef DWORD (WINAPI *GAPC_PTR)(WORD GroupNumber);\n      GAPC_PTR ptrGetActiveProcessorCount;\n      /* Available on W7 or later */\n      ptrGetActiveProcessorCount =\n        (GAPC_PTR) (void *) GetProcAddress (k32hndl, \"GetActiveProcessorCount\");\n      if (NULL != ptrGetActiveProcessorCount)\n      {\n        DWORD res;\n        res = ptrGetActiveProcessorCount (ALL_PROCESSOR_GROUPS);\n        ret = (int) res;\n        if (res != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if ((0 >= ret) && (NULL != k32hndl))\n    {\n      typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo);\n      GNSI_PTR ptrGetNativeSystemInfo;\n      /* May give incorrect (low) result on versions from W7 to W11\n         when more then 64 CPUs are available */\n      ptrGetNativeSystemInfo =\n        (GNSI_PTR) (void *) GetProcAddress (k32hndl, \"GetNativeSystemInfo\");\n      if (NULL != ptrGetNativeSystemInfo)\n      {\n        SYSTEM_INFO sysInfo;\n\n        memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n        ptrGetNativeSystemInfo (&sysInfo);\n        ret = (int) sysInfo.dwNumberOfProcessors;\n        if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n          ret = -1; /* Overflow */\n      }\n    }\n    if (NULL != k32hndl)\n      FreeLibrary (k32hndl);\n  }\n  if (0 >= ret)\n  {\n    /* May give incorrect (low) result on versions from W7 to W11\n       when more then 64 CPUs are available */\n    SYSTEM_INFO sysInfo;\n    memset ((void *) &sysInfo, 0, sizeof (sysInfo));\n    GetSystemInfo (&sysInfo);\n    ret = (int) sysInfo.dwNumberOfProcessors;\n    if (sysInfo.dwNumberOfProcessors != (DWORD) ret)\n      ret = -1; /* Overflow */\n  }\n#endif /* _WIN32 && ! __CYGWIN__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n...\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_ (void)\n{\n  int ret = -1;\n  /* Do not use sysctl() function on GNU/Linux even if\n     sysctl() is available */\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The number of available logical CPUs */\n    if ((0 != sysctlbyname (\"hw.logicalcpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* FreeBSD: The number of online CPUs */\n    if ((0 != sysctlbyname (\"kern.smp.cpus\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The current number of CPUs available to run threads */\n    if ((0 != sysctlbyname (\"hw.activecpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* OpenBSD, NetBSD: The number of online CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpuonline\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* Darwin: The old/alternative name for \"hw.activecpu\" */\n    if ((0 != sysctlbyname (\"hw.availcpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_NCPUONLINE)\n  if (0 >= ret)\n  {\n    /* OpenBSD, NetBSD: The number of online CPUs */\n    int mib[2] = {CTL_HW, HW_NCPUONLINE};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPUONLINE */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_AVAILCPU)\n  if (0 >= ret)\n  {\n    /* Darwin: The MIB name for \"hw.activecpu\" */\n    int mib[2] = {CTL_HW, HW_AVAILCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_AVAILCPU */\n#endif /* ! __linux__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n...\nstatic int\nmhd_tool_get_sys_cpu_count_sysconf_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SYSCONF) && \\\n  (defined(HAS_DECL__SC_NPROCESSORS_ONLN) || defined(HAS_DECL__SC_NPROC_ONLN))\n  long value = -1;\n#ifdef HAS_DECL__SC_NPROCESSORS_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROCESSORS_ONLN);\n#endif /* HAS_DECL__SC_NPROCESSORS_ONLN */\n#ifdef HAS_DECL__SC_NPROC_ONLN\n  if (0 >= value)\n    value = sysconf (_SC_NPROC_ONLN);\n#endif /* HAS_DECL__SC_NPROC_ONLN */\n  if (0 >= value)\n    return -1;\n  ret = (int) value;\n  if ((long) ret != value)\n    return -1; /* Overflow */\n#endif /* HAVE_SYSCONF &&\n          (HAS_DECL__SC_NPROCESSORS_ONLN || HAS_DECL__SC_NPROC_ONLN) */\n  return ret;\n}\n...\nint\nmhd_tool_get_proc_cpu_count (void)\n{\n  int res;\n\n#if defined(__linux__) || defined(__GLIBC__)\n  /* On Linux kernel try first 'sched_getaffinity()' as it should be\n     the native API.\n     Also try it first on other kernels if Glibc is used. */\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n#else  /* ! __linux__ && ! __GLIBC__ */\n  /* On non-Linux kernels 'cpuset_getaffinity()' could be the native API,\n     while 'sched_getaffinity()' could be implemented in compatibility layer. */\n  res = mhd_tool_get_proc_cpu_count_cpuset_getaffinity_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_ ();\n  if (0 < res)\n    return res;\n#endif /* ! __linux__ && ! __GLIBC__ */\n\n  res = mhd_tool_get_proc_cpu_count_sched_getaffinity_np_ ();\n  if (0 < res)\n    return res;\n\n  res = mhd_tool_get_proc_cpu_count_w32_ ();\n  if (0 < res)\n    return res;\n\n  return -1;\n}\n...\nstatic int\nmhd_tool_get_sys_cpu_count_sysctl_fallback_ (void)\n{\n  int ret = -1;\n  /* Do not use sysctl() function on GNU/Linux even if\n     sysctl() is available */\n#ifndef __linux__\n#ifdef HAVE_SYSCTLBYNAME\n  if (0 >= ret)\n  {\n    size_t value_size = sizeof (ret);\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    if ((0 != sysctlbyname (\"hw.ncpu\", &ret, &value_size,\n                            NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTLBYNAME */\n#if defined(HAVE_SYSCTL) && \\\n  defined(HAS_DECL_CTL_HW) && \\\n  defined(HAS_DECL_HW_NCPU)\n  if (0 >= ret)\n  {\n    /* FreeBSD, OpenBSD, NetBSD, Darwin (and others?): The number of CPUs */\n    int mib[2] = {CTL_HW, HW_NCPU};\n    size_t value_size = sizeof (ret);\n    if ((0 != sysctl (mib, 2, &ret, &value_size, NULL, 0))\n        || (sizeof (ret) != value_size))\n      ret = -1;\n  }\n#endif /* HAVE_SYSCTL && HAS_DECL_CTL_HW && HAS_DECL_HW_NCPU */\n#endif /* ! __linux__ */\n  if (0 >= ret)\n    return -1;\n  return ret;\n}\n...\nstatic int\nmhd_tool_get_sys_cpu_count_sysconf_fallback_ (void)\n{\n  int ret = -1;\n#if defined(HAVE_SYSCONF) && \\\n  (defined(HAS_DECL__SC_CRAY_NCPU) || defined(HAS_DECL__SC_NPROCESSORS_CONF))\n  long value = -1;\n#ifdef HAS_DECL__SC_CRAY_NCPU\n  if (0 >= value)\n    value = sysconf (_SC_CRAY_NCPU);\n#endif /* HAS_DECL__SC_CRAY_NCPU */\n#ifdef HAS_DECL__SC_NPROCESSORS_CONF\n  if (0 >= value)\n    value = sysconf (_SC_NPROCESSORS_CONF);\n#endif /* HAS_DECL__SC_NPROCESSORS_CONF */\n  if (0 >= value)\n    return -1;\n  ret = (int) value;\n  if ((long) ret != value)\n    return -1; /* Overflow */\n#endif /* HAVE_SYSCONF &&\n          (HAS_DECL__SC_CRAY_NCPU || HAS_DECL__SC_NPROCESSORS_CONF) */\n  return ret;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected all pointer usages and pointer-type declarations in the provided functions. No pointer variable or parameter stood out as a clear violation of MISRA C 2023 Rule 8.13 (i.e., a pointer declared without const that could reasonably be made a pointer-to-const). Rationale for not flagging the pointer occurrences in the code follows (grouped by site):\n\n- memset casts (e.g., memset ((void *) &psd_data, 0, ...); memset ((void *) &sysInfo, 0, ...)): memset takes a void* for an object to be modified, and the cast to void* is conventional for clarity/compatibility. The pointed-to objects are intentionally modified (initialized), so they must not be const.\n\n- sysctl/sysctlbyname calls (e.g., sysctlbyname(\"hw.logicalcpu\", &ret, &value_size, NULL, 0) and sysctl(mib, 2, &ret, &value_size, NULL, 0)): the &ret argument is an output buffer where the function writes the retrieved value; it must be a non-const pointer. The mib array is passed to sysctl with an API that expects an int*; even if the data is not modified by the callee on all implementations, the sysctl API historically requires non-const int*, so changing it to const would break the API contract.\n\n- GetProcAddress / LoadLibraryA string literals (e.g., LoadLibraryA(\"kernel32.dll\"), GetProcAddress(k32hndl, \"GetActiveProcessorCount\")): these are string literals passed to platform APIs that expect string pointers (Windows types like LPCSTR may be const-qualified in headers). There is no local non-const pointer variable here that can be changed to point-to-const; the APIs themselves control parameter constness.\n\n- Function-pointer typedefs and casts (e.g., typedef void (WINAPI *GNSI_PTR)(SYSTEM_INFO *pSysInfo); ptrGetNativeSystemInfo = (GNSI_PTR) (void *) GetProcAddress(...)): these typedefs model the real Windows API signatures. The ptrGetNativeSystemInfo callback is intended to fill in a SYSTEM_INFO structure, so its parameter must be a non-const pointer. The explicit cast from GetProcAddress\u2019s return to the function pointer type is a compatibility/portability necessity and not an indication that the pointed-to type should be const.\n\n- Calls that provide output buffers (e.g., ptrGetNativeSystemInfo(&sysInfo); pstat_getdynamic (&psd_data, ...); sysconf returns a long by value): these uses are clearly for output or mutation of the referenced objects, so pointers must be non-const.\n\n- cpuset_t / affinity-related usage (e.g., enb_set = vxCpuEnabledGet(); enb_set &= enb_set - 1;): these manipulate an integer/bitset value directly; no pointer usage to convert to const applies.\n\n- Any API that historically expects a non-const pointer (e.g., sysctl, sysctlbyname, platform-specific get functions): changing parameter types to const would be incompatible with the API and/or incorrect because the functions write into the provided buffers.\n\nGiven the above, there are no clear code fragments in the provided code that should be investigated for Rule 8.13: all pointer usages are either output buffers (must be non-const), are required by external API signatures, or are necessary casts for interoperability. If you want, I can re-check specific lines or external API prototypes (platform headers) to confirm const qualifications in the declarations you use; provide target platform headers or indicate which API(s) you want a deeper check for possible const qualification mismatches."
}