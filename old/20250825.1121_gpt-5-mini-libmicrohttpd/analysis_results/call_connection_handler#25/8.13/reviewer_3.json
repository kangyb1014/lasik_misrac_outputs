{
  "user_message": "An agent A claimed that the following call_connection_handler code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of call_connection_handler.\n```c\nstatic void\ncall_connection_handler (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t processed;\n\n  if (NULL != connection->rp.response)\n    return;                     /* already queued a response */\n  processed = 0;\n  connection->rq.client_aware = true;\n  connection->in_access_handler = true;\n  if (MHD_NO ==\n      daemon->default_handler (daemon->default_handler_cls,\n                               connection,\n                               connection->rq.url,\n                               connection->rq.method,\n                               connection->rq.version,\n                               NULL,\n                               &processed,\n                               &connection->rq.client_context))\n  {\n    connection->in_access_handler = false;\n    /* serious internal error, close connection */\n    CONNECTION_CLOSE_ERROR (connection,\n                            _ (\"Application reported internal error, \" \\\n                               \"closing connection.\"));\n    return;\n  }\n  connection->in_access_handler = false;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local pointer 'daemon' is only used for read-only accesses (daemon->default_handler and daemon->default_handler_cls) and is not used to modify the pointed-to object. Per MISRA C 2023 Rule 8.13 it should be declared as a pointer to a const-qualified type, e.g. 'const struct MHD_Daemon *daemon = connection->daemon;'. Assigning the non-const connection->daemon to a const pointer is allowed; only if the code later needs to modify the daemon would const be inappropriate.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In call_connection_handler the local variable daemon is only used for read-only accesses (reading the function pointer daemon->default_handler and the class pointer daemon->default_handler_cls) and the code never modifies *daemon. Per MISRA C:2023 Rule 8.13 a pointer should point to a const-qualified type when possible, so declaring the local as const struct MHD_Daemon *daemon = connection->daemon; would be appropriate. Assigning the non-const connection->daemon to a const-qualified pointer is allowed (no cast needed). The only caveat would be if the function needed to modify the daemon object through that local pointer (or if the accessed members must be passed to APIs that require mutable lvalues in a way that qualifiers would conflict), but none of that occurs in the shown code, so the original code violates Rule 8.13."
}