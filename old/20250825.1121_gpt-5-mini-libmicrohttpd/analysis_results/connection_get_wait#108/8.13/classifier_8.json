{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of connection_get_wait:\n```c\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  mhd_assert (0 != timeout);\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  return mseconds_left;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function connection_get_wait:\n_MHD_EXTERN enum MHD_Result\nMHD_get_timeout64 (struct MHD_Daemon *daemon,\n                   uint64_t *timeout64)\n{\n  uint64_t earliest_deadline;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *earliest_tmot_conn; /**< the connection with earliest timeout */\n\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif /* MHD_USE_THREADS */\n\n  if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Illegal call to MHD_get_timeout.\\n\"));\n#endif\n    return MHD_NO;\n  }\n  if (daemon->data_already_pending\n      || (NULL != daemon->cleanup_head)\n      || daemon->resuming\n      || daemon->have_new\n      || daemon->shutdown)\n  {\n    /* Some data or connection statuses already waiting to be processed. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#ifdef EPOLL_SUPPORT\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n       || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n      ) )\n  {\n    /* Some connection(s) already have some data pending. */\n    *timeout64 = 0;\n    return MHD_YES;\n  }\n#endif /* EPOLL_SUPPORT */\n\n  earliest_tmot_conn = NULL;\n  earliest_deadline = 0; /* mute compiler warning */\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout_ms) )\n  {\n    earliest_tmot_conn = pos;\n    earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n  }\n\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n  {\n    if (0 != pos->connection_timeout_ms)\n    {\n      if ( (NULL == earliest_tmot_conn) ||\n           (earliest_deadline - pos->last_activity >\n            pos->connection_timeout_ms) )\n      {\n        earliest_tmot_conn = pos;\n        earliest_deadline = pos->last_activity + pos->connection_timeout_ms;\n      }\n    }\n  }\n\n  if (NULL != earliest_tmot_conn)\n  {\n    *timeout64 = connection_get_wait (earliest_tmot_conn);\n    return MHD_YES;\n  }\n  return MHD_NO;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nconst uint64_t timeout = c->connection_timeout_ms;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": true,
  "scenario": "The code reads fields from the connection via the pointer parameter c but never modifies *c. The relevant line \u2018const uint64_t timeout = c->connection_timeout_ms;\u2019 itself does not declare a pointer, but it highlights that c is only used for read access. Therefore the pointer parameter should be const-qualified (e.g. change the function signature to \u2018static uint64_t connection_get_wait(const struct MHD_Connection *c)\u2019). As written, the non-const pointer parameter violates MISRA C 2023 Rule 8.13."
}