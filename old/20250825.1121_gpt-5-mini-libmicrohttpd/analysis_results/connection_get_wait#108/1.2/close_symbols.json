{
  "user_message": "Target function code is:\n```c\nstatic uint64_t\nconnection_get_wait (struct MHD_Connection *c)\n{\n  const uint64_t now = MHD_monotonic_msec_counter ();\n  const uint64_t since_actv = now - c->last_activity;\n  const uint64_t timeout = c->connection_timeout_ms;\n  uint64_t mseconds_left;\n\n  mhd_assert (0 != timeout);\n  /* Keep the next lines in sync with #connection_check_timedout() to avoid\n   * undesired side-effects like busy-waiting. */\n  if (timeout < since_actv)\n  {\n    if (UINT64_MAX / 2 < since_actv)\n    {\n      const uint64_t jump_back = c->last_activity - now;\n      /* Very unlikely that it is more than quarter-million years pause.\n       * More likely that system clock jumps back. */\n      if (5000 >= jump_back)\n      { /* Jump back is less than 5 seconds, try to recover. */\n        return 100; /* Set wait time to 0.1 seconds */\n      }\n      /* Too large jump back */\n    }\n    return 0; /* Connection has timed out */\n  }\n  else if (since_actv == timeout)\n  {\n    /* Exact match for timeout and time from last activity.\n     * Maybe this is just a precise match or this happens because the timer\n     * resolution is too low.\n     * Set wait time to 0.1 seconds to avoid busy-waiting with low\n     * timer resolution as connection is not timed-out yet. */\n    return 100;\n  }\n  mseconds_left = timeout - since_actv;\n\n  return mseconds_left;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'thread_main_handle_connection': {'callees': ['MHD_add_to_fd_set_', 'MHD_DLOG', 'MHD_update_last_activity_', 'MHD_connection_handle_idle', 'connection_get_wait', 'call_handlers', 'thread_main_connection_upgrade', 'MHD_resume_connection', 'MHD_connection_close_', 'MHD_destroy_response'], 'callers': []}, 'MHD_get_timeout64': {'callees': ['MHD_DLOG', 'connection_get_wait'], 'callers': ['MHD_get_timeout', 'MHD_get_timeout64s', 'get_timeout_millisec_', 'MHD_select', 'main']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "uint64_t",
    "UINT64_MAX",
    "struct MHD_Connection",
    "MHD_monotonic_msec_counter",
    "mhd_assert"
  ],
  "explanation": "uint64_t \u2014 to check how the fixed-width integer type is provided/defined (via stdint.h or any project-specific typedef) and whether its definition uses compiler-specific extensions.\n\nUINT64_MAX \u2014 to inspect the macro expansion (literal suffixes, use of compiler extensions like __extension__, or non-standard constants) used in the comparison and arithmetic in the function.\n\nstruct MHD_Connection \u2014 to see the exact declarations and types of members last_activity and connection_timeout_ms (their types, bitfields, attributes or other extension usage) and any struct-level attributes or non-standard extensions.\n\nMHD_monotonic_msec_counter \u2014 to examine its declaration/definition for any compiler extensions (inline definitions, attributes, builtin wrappers, macros expanding to compiler-specific constructs) and to confirm its return type and semantics.\n\nmhd_assert \u2014 to inspect the macro or function implementation for use of compiler extensions (statement-expressions, __builtin_*, __attribute__ annotations, or other non-standard constructs) since it is used in the target function and could introduce language extensions.\n\nThese symbols are enough to determine whether the target function or the types/macros it directly uses rely on compiler language extensions; other callers/callees are not required for this specific MISRA language-extension check."
}