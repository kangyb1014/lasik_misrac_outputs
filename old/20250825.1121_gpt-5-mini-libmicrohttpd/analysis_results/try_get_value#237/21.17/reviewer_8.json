{
  "user_message": "An agent A claimed that the following try_get_value code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of try_get_value.\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strstr(bpos, key) can read past the bounds of the object identified by buf (or bpos) if buf does not point to a null\u2011terminated string (or if bpos is not within a properly terminated string). The function does not validate that buf is non\u2011NULL and NUL\u2011terminated, so invoking try_get_value with a buffer that lacks an in\u2011object '\\0' (or with buf==NULL) will cause strstr to access memory beyond the object bounds.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The calls to the <string.h> functions in try_get_value (strlen, strstr, strchr, memcpy) assume that the pointer arguments refer to valid NUL-terminated strings and a valid destination pointer. The function does not check buf or key for NULL nor does it verify that buf (or bpos) is a NUL-terminated string before calling strstr/strchr. If buf (or bpos) does not point to a NUL-terminated object (or if buf==NULL), strstr/strchr may read past the bounds of the referenced object, and strlen(key) will also UB if key is not a valid NUL-terminated string. That is exactly a potential breach of MISRA C 2023 Rule 21.17 unless the function has a documented and enforced precondition that buf and key are valid NUL-terminated strings and destination is a valid pointer to pointer. In the absence of such guaranteed preconditions or explicit validation in the code, the report of a Rule 21.17 violation is correct."
}