{
  "user_message": "Target function code is:\n```c\nstatic void\ntry_get_value (const char *buf,\n               const char *key,\n               char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n  {\n    if ( (spos[klen] != '=') ||\n         ( (spos != buf) &&\n           (spos[-1] != ' ') ) )\n    {\n      /* no match */\n      bpos = spos + 1;\n      continue;\n    }\n    if (spos[klen + 1] != '\"')\n      return;                   /* not quoted */\n    if (NULL == (endv = strchr (&spos[klen + 2],\n                                '\\\"')))\n      return;                   /* no end-quote */\n    vlen = (size_t) (endv - spos) - klen - 1;\n    *destination = malloc (vlen);\n    if (NULL == *destination)\n      return;                   /* out of memory */\n    (*destination)[vlen - 1] = '\\0';\n    memcpy (*destination,\n            &spos[klen + 2],\n            vlen - 1);\n    return;                     /* success */\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'try_get_value': {'callees': [], 'callers': ['process_multipart_headers']}, 'process_multipart_headers': {'callees': ['MHD_str_equal_caseless_n_', 'try_get_value', 'try_match_header'], 'callers': ['post_process_multipart']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "strlen",
    "strstr",
    "strchr",
    "malloc",
    "memcpy",
    "NULL",
    "size_t",
    "process_multipart_headers"
  ],
  "explanation": "Explain why each symbol is required to check for language extensions:\n- strlen: the target calls strlen; the analysis must ensure the identifier is the standard library function (prototype) and not a macro/alias that expands to a compiler-specific builtin or extension.\n- strstr: used in the loop to find the key; verify it is the standard library function and not implemented via a compiler extension or macro.\n- strchr: used to find the closing quote; must confirm it is the standard C library function and not a language-extension replacement.\n- malloc: used to allocate memory; must confirm the declaration/definition is the standard one and not a compiler-provided extension or macro (some projects replace malloc with wrappers or builtins).\n- memcpy: used to copy bytes; ensure it is the standard library function and not a compiler intrinsic or extension macro that could constitute a language extension.\n- NULL: the code uses NULL; check its definition (macro) to ensure it is the standard sentinel and not defined via a compiler-specific extension.\n- size_t: used for klen/vlen types; confirm it is the standard typedef (from <stddef.h>/<stdlib.h>) and not a compiler-specific extended type.\n- process_multipart_headers: this is the caller shown in the call graph; include it to allow checking for any file-scope or declaration attributes (macros or compiler-specific annotations) on the caller or surrounding translation unit that might affect try_get_value (e.g., attribute macros that change calling conventions or inject compiler extensions).\n\nThese symbols (their declarations/definitions) are needed so the next analyzer can determine whether any of them are implemented or aliased using compiler-specific language extensions or macros, which would cause the target function to rely on language extensions in violation of the rule."
}