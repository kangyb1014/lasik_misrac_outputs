{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "MemoryPool.memory",
    "MemoryPool.pos",
    "MemoryPool.end",
    "MemoryPool.size",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "mhd_assert",
    "__asan_region_is_poisoned"
  ],
  "explanation": "For a sound MISRA C analysis of the string.h calls (memcpy, memset) in MHD_pool_reallocate you must be able to determine exact object bounds and offsets, the sizes of allocations, and the effect of any helper macros that change or validate those sizes. Each listed symbol is needed for the reasons below:\n\n- struct MemoryPool: The overall layout (types and semantics) of the MemoryPool object is needed to understand where allocations live and how pos/end/size relate to memory capacity.\n- MemoryPool.memory: The base pointer for all pool allocations; needed to determine the valid address range for source (old) and destination (new_blc) of memcpy/memset.\n- MemoryPool.pos: pos is used to compute the allocation start (pool->memory + pool->pos) and is adjusted when allocating; needed to check that copying/writing does not exceed pool bounds.\n- MemoryPool.end: end denotes the pool limit used in bounds checks; necessary to confirm destination and source ranges lie within the pool.\n- MemoryPool.size: Used in assertions and invariants; needed to reason about space available and to validate pointer arithmetic and wrap-around checks.\n- ROUND_TO_ALIGN: The rounding of sizes to alignment affects allocated size and therefore the usable bytes for memcpy/memset. You must know the rounding rule to compute actual allocation footprints.\n- ROUND_TO_ALIGN_PLUS_RED_ZONE: This macro/function both rounds and adds the red-zone overhead used throughout safety checks and pos/end comparisons. It directly determines asize and offsets used to decide in-place resize vs new allocation.\n- _MHD_RED_ZONE_SIZE: The red zone is explicitly subtracted in multiple asserts; its value affects whether copies/writes land inside or outside valid memory.\n- mp_ptr_diff_: Computes old_offset = mp_ptr_diff_(old, pool->memory). You must know its semantics (units, wrap handling, range guarantees) to reason about computed offsets used in bounds checks for memcpy/memset.\n- mp_ptr_le_: Used to assert ordering of pointers. Its exact comparison semantics are required to trust the code's assumptions that 'old' lies within the pool.\n- _MHD_POISON_MEMORY: This macro/function may perform memory writes or tooling operations (ASAN calls, memset wrappers). Its behavior affects whether additional memory accesses occur and whether poisoning operations themselves are in-bounds.\n- _MHD_UNPOISON_MEMORY: Same rationale as _MHD_POISON_MEMORY; unpoisoning may touch memory and must be checked for in-bound accesses.\n- mhd_assert: The asserts encode important invariants (e.g., checks that old is in the pool, that pool->pos equals certain rounded values). To rely on those invariants in the safety argument you must know what mhd_assert expands to (e.g., is it a no-op in release builds or aborting check) and whether the asserted relations are guaranteed by surrounding code.\n- __asan_region_is_poisoned: Present under conditional compilation; if ASAN-related code is active, this function affects when asserts test poisoned regions. Its semantics matter to reason about any implicit accesses or assumptions under ASAN builds.\n\nIn short: to decide if memcpy/memset calls can access beyond object bounds you must know (1) where 'old' and 'new_blc' point (MemoryPool.memory and pos), (2) how big the destination block is (ROUND_TO_ALIGN_PLUS_RED_ZONE, _MHD_RED_ZONE_SIZE, pool->end/pos/size), (3) that 'old' lies within the pool (mp_ptr_diff_, mp_ptr_le_, mhd_assert), and (4) whether the poison/unpoison macros themselves touch memory. Providing these symbols (and their definitions/semantics) in the next-agent prompt will allow a precise MISRA rule compliance check."
}