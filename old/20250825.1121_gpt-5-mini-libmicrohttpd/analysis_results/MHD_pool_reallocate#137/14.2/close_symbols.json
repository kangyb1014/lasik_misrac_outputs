{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "mhd_assert",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_RED_ZONE_SIZE",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "__asan_region_is_poisoned",
    "memset",
    "memcpy"
  ],
  "explanation": "You must inspect the definitions/bodies of every symbol (macros, inline funcs or functions) that the target uses because the MISRA rule about well-formed for loops requires examining the behaviour of any functions called within a for statement and any macro expansions that could introduce for loops. Concretely:\n\n- struct MemoryPool\n  - Needed to see the types of pool->pos, pool->end, pool->size and pool->memory. ROUND_TO_ALIGN(\u2026) and pointer arithmetic operate on these fields; if any of these are implemented via macros or accessors that expand to for loops or modify objects used as loop counters, that would affect MISRA analysis.\n\n- mp_ptr_diff_\n  - Used to compute old_offset. It may be a macro or inline function; its definition could contain loops or side-effects that influence for-loop analysis.\n\n- mp_ptr_le_\n  - Used in assertions to check pointer ordering. Could be a macro or inline function; must inspect its body for any loop constructs or side-effects.\n\n- mhd_assert\n  - Assertion macro may expand to function calls or control-flow constructs. Must confirm it does not introduce for loops or side-effects that would interact with loop counters.\n\n- ROUND_TO_ALIGN\n  - Rounding macro/function used on pool->pos. Macro definitions sometimes expand to loops or call helpers; check it for any for-loop usage or side-effects on objects that could be loop counters.\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE\n  - Used repeatedly to compute allocation boundaries. Must inspect its expansion/definition for loops or modifications of objects used in for-loop clauses.\n\n- _MHD_RED_ZONE_SIZE\n  - Constant/macro used in arithmetic with offsets; include to see if it's defined via any computed expression or macro that may include loops or function calls.\n\n- _MHD_POISON_MEMORY\n  - Likely a macro or function that writes/marks memory; must check whether it contains for loops (e.g., byte-wise loops) or modifies global/state objects that could be used as loop counters.\n\n- _MHD_UNPOISON_MEMORY\n  - Same rationale as _MHD_POISON_MEMORY: its body may contain loops or side-effects relevant to MISRA for-loop analysis.\n\n- __asan_region_is_poisoned\n  - Called inside a compile-time conditional. If present, its implementation might contain loops or side-effects; include to be thorough.\n\n- memset\n  - Standard library function used here; although typically implemented in optimized C/assembly, its body may contain loops. If any for-loops in this function had called memset inside their body, the behaviour of that called function is part of the for-loop body semantics per the MISRA phrasing. We include it so the analyzer can decide whether to treat it as external (allowed) or to inspect its implementation in this context.\n\n- memcpy\n  - Same rationale as memset: called from the function and part of the body semantics; include to determine whether any for-loop interaction arises from its implementation.\n\nNote: The target function itself contains no for statements. The purpose of listing these symbols is to allow the next analyst to inspect any macro expansions or called-function bodies that could introduce for-loops (or modify loop counters/other objects) when the target function is expanded/linked into the full program. Inspecting these definitions will determine conclusively whether any for-loop-related MISRA violations are introduced by the macros/callees used here."
}