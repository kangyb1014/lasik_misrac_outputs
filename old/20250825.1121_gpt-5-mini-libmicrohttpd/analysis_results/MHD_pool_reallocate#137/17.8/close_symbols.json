{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MemoryPool",
    "ROUND_TO_ALIGN",
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "_MHD_RED_ZONE_SIZE",
    "mhd_assert",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY",
    "__asan_region_is_poisoned",
    "memset",
    "memcpy"
  ],
  "explanation": "For deciding whether the function modifies its parameter variables (pool, old, old_size, new_size) you must examine any macros/functions that are invoked with those parameter names or that might contain side-effects/assignments when expanded or called. The listed symbols are the ones referenced from MHD_pool_reallocate whose definitions could change that determination:\n\n- struct MemoryPool: needed to see the members (memory, pos, end, size) and to confirm that pool is a pointer and that modifying pool->pos (or other members) modifies the pointed-to object (allowed) rather than the parameter variable pool itself (disallowed).\n\n- ROUND_TO_ALIGN and ROUND_TO_ALIGN_PLUS_RED_ZONE: these are function-like macros (or inline funcs) used with pool->pos and offsets. Their definitions must be inspected to ensure they do not perform assignments to their argument identifiers (which could modify the parameter variable when the macro argument is an expression involving a parameter) or otherwise have side-effects on parameter variables.\n\n- _MHD_RED_ZONE_SIZE: constant used inside the ROUND/compare expressions; included because ROUND_TO_ALIGN_PLUS_RED_ZONE may use it, and its definition may influence macro expansion semantics (if it is itself a macro with side-effects, unlikely but must be checked).\n\n- mhd_assert: assertions appear many times and receive expressions built from parameters. The macro expansion could evaluate its argument multiple times or include side-effects; its definition must be checked to ensure it does not assign to parameter variables or otherwise modify them.\n\n- mp_ptr_diff_ and mp_ptr_le_: these are used with old and pool->memory; if they are macros they could contain assignments to their arguments when expanded \u2014 must inspect to ensure they do not modify the parameter variables.\n\n- _MHD_POISON_MEMORY and _MHD_UNPOISON_MEMORY: these surround memory regions given by pointer parameters (old, new_blc). Their definitions (macros/wrappers around ASAN primitives) must be checked to ensure they do not assign to the pointer parameter variables themselves.\n\n- __asan_region_is_poisoned: conditionally called with (old, old_size); include it to verify it has no side-effects on the pointer parameter when present.\n\n- memset and memcpy: standard library functions that operate on the memory pointed to by pointer parameters. Include them to confirm they do not (and cannot) modify the pointer parameter variables themselves (they operate on pointees only).\n\nIn short, to prove compliance with the MISRA rule you must inspect the definitions/expansions of these symbols to ensure none of them perform assignments to the parameter identifiers (pool, old, old_size, new_size) or otherwise bind/modify those parameter variables. The struct definition is needed to distinguish allowed modifications to the object pointed-to (pool->...) from forbidden modification of the pointer parameter itself."
}