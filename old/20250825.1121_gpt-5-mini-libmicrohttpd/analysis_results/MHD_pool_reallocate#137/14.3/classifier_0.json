{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_pool_reallocate:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_reallocate:\n#define ROUND_TO_ALIGN_PLUS_RED_ZONE(n) ROUND_TO_ALIGN(n)\n...\n#define ROUND_TO_ALIGN(n) (((n)+(ALIGN_SIZE-1))/(ALIGN_SIZE)*(ALIGN_SIZE))\n...\n#define _MHD_RED_ZONE_SIZE (0)\n...\n#define mp_ptr_diff_(p1, p2) ((size_t)(((constuint8_t*)(p1))-((constuint8_t*)(p2))))\n...\n#define mp_ptr_le_(p1, p2) (((constuint8_t*)(p1))<=((constuint8_t*)(p2)))\n...\nstruct MemoryPool\n{\n\n  /**\n   * Pointer to the pool's memory\n   */\n  uint8_t *memory;\n\n  /**\n   * Size of the pool.\n   */\n  size_t size;\n\n  /**\n   * Offset of the first unallocated byte.\n   */\n  size_t pos;\n\n  /**\n   * Offset of the byte after the last unallocated byte.\n   */\n  size_t end;\n\n  /**\n   * 'false' if pool was malloc'ed, 'true' if mmapped (VirtualAlloc'ed for W32).\n   */\n  bool is_mmap;\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define _MHD_POISON_MEMORY(pointer, size) (void)0\n...\n#define _MHD_UNPOISON_MEMORY(pointer, size) (void)0\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 != old_size)\n```\nFocus on the above code fragment and judge whether it violates the rule 14.3 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The controlling expression depends on the function parameter 'old_size' (if (0 != old_size)), so it is not an invariant compile-time constant. The mhd_asserts are no-ops, so they do not make 'old_size' constant. Therefore this if-statement does not violate MISRA C 2023 Rule 14.3."
}