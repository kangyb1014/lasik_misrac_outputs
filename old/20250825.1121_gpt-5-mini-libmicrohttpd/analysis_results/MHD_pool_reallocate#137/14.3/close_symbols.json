{
  "user_message": "Target function code is:\n```c\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'MHD_connection_alloc_memory_': {'callees': ['MHD_pool_try_alloc', 'MHD_pool_reallocate', 'MHD_pool_allocate'], 'callers': ['MHD_set_connection_value_n_nocheck_', 'try_ready_normal_body', 'parse_cookie_header', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_']}, 'try_ready_chunked_body': {'callees': ['MHD_pool_get_free', '__builtin_unreachable', 'connection_close_error', 'MHD_pool_reallocate', 'MHD_uint32_to_strx'], 'callers': ['MHD_connection_handle_idle']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'connection_shrink_read_buffer': {'callees': ['MHD_pool_deallocate', 'MHD_pool_reallocate'], 'callers': ['connection_switch_from_recv_to_send']}, 'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_connection_handle_read': {'callees': ['MHD_DLOG', 'MHD_connection_close_', 'str_conn_error_', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_pool_reallocate'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "ROUND_TO_ALIGN_PLUS_RED_ZONE",
    "ROUND_TO_ALIGN",
    "_MHD_RED_ZONE_SIZE",
    "mp_ptr_diff_",
    "mp_ptr_le_",
    "struct MemoryPool",
    "mhd_assert",
    "MHD_ASAN_POISON_ACTIVE",
    "HAVE___ASAN_REGION_IS_POISONED",
    "__asan_region_is_poisoned",
    "_MHD_POISON_MEMORY",
    "_MHD_UNPOISON_MEMORY"
  ],
  "explanation": "For determining whether any controlling expression in MHD_pool_reallocate is an invariant (constant) you must know how the macros, helpers and data it uses are defined and whether assertions/poison helpers introduce control flow. Each listed symbol is needed for that reasoning:\n\n- ROUND_TO_ALIGN_PLUS_RED_ZONE: Used in several if/tests and to compute asize/new_apos. Its definition (macro or function) determines whether the expression can ever be a compile-time constant or depends on runtime parameters (old_offset, old_size, new_size).\n\n- ROUND_TO_ALIGN: Used in an assert; knowing its expansion is required to decide whether the assert contains any controlling expression that is constant or compiles to no code.\n\n- _MHD_RED_ZONE_SIZE: A macro/constant used in arithmetic inside conditional expressions. If this were the only operand the expression might be constant; combined with runtime operands it is not, but you must inspect its value to be certain.\n\n- mp_ptr_diff_: Computes old_offset from pointers. Its prototype/implementation shows whether old_offset is computed at runtime (normal) or in some exotic way that could make comparisons invariant.\n\n- mp_ptr_le_: Predicate used in an assert; need to know if it is a runtime comparison or a compile-time check (macro) that could produce invariant controlling expressions.\n\n- struct MemoryPool: Definition (types and qualifiers of memory, pos, end, size fields) is required to know which operands (pool->pos, pool->end, pool->size, pool->memory) are runtime state and whether any could be constant/const-qualified, or optimized into invariants.\n\n- mhd_assert: Macro/implementation determines whether assertions generate control-flow (e.g., if/abort) or compile to nothing. If assertions expand to control statements with constant conditions they could trigger the MISRA rule; if they compile away they do not.\n\n- MHD_ASAN_POISON_ACTIVE and HAVE___ASAN_REGION_IS_POISONED: These preprocessor symbols control inclusion of the asan-related mhd_assert line. You must know whether that conditional is active in the build to see if the extra assert (with __asan_region_is_poisoned) contributes any controlling expression.\n\n- __asan_region_is_poisoned: If the above conditional is active, the asan call appears inside an assert; its signature/semantics determine whether the assert's controlling expression is runtime-dependent or invariant.\n\n- _MHD_POISON_MEMORY and _MHD_UNPOISON_MEMORY: These are macros called in the function. Their expansions could contain control statements or influence control-flow diagnostics; you need their definitions to ensure they do not introduce invariant controlling expressions.\n\nKnowing these symbols (definitions/prototypes) lets the analyzer determine whether each if/conditional/assert in MHD_pool_reallocate is genuinely runtime-dependent or could be an invariant under the build/configuration being analyzed."
}