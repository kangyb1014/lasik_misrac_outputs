{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_pool_allocate:\n```c\nvoid *\nMHD_pool_allocate (struct MemoryPool *pool,\n                   size_t size,\n                   bool from_end)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n    return NULL; /* size too close to SIZE_MAX */\n  if (asize > pool->end - pool->pos)\n    return NULL;\n  if (from_end)\n  {\n    ret = &pool->memory[pool->end - asize];\n    pool->end -= asize;\n  }\n  else\n  {\n    ret = &pool->memory[pool->pos];\n    pool->pos += asize;\n  }\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_allocate:\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n...\nvoid\nMHD_connection_set_initial_state_ (struct MHD_Connection *c)\n{\n  size_t read_buf_size;\n\n#ifdef HTTPS_SUPPORT\n  mhd_assert ( (0 == (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_INIT == c->tls_state) );\n  mhd_assert ( (0 != (c->daemon->options & MHD_USE_TLS)) || \\\n               (MHD_TLS_CONN_NO_TLS == c->tls_state) );\n#endif /* HTTPS_SUPPORT */\n  mhd_assert (MHD_CONNECTION_INIT == c->state);\n\n  c->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n  c->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n\n  memset (&c->rq, 0, sizeof(c->rq));\n  memset (&c->rp, 0, sizeof(c->rp));\n\n  c->write_buffer = NULL;\n  c->write_buffer_size = 0;\n  c->write_buffer_send_offset = 0;\n  c->write_buffer_append_offset = 0;\n\n  c->continue_message_write_offset = 0;\n\n  c->read_buffer_offset = 0;\n  read_buf_size = c->daemon->pool_size / 2;\n  c->read_buffer\n    = MHD_pool_allocate (c->pool,\n                         read_buf_size,\n                         false);\n  c->read_buffer_size = read_buf_size;\n}\n...\nvoid *\nMHD_pool_try_alloc (struct MemoryPool *pool,\n                    size_t size,\n                    size_t *required_bytes)\n{\n  void *ret;\n  size_t asize;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (size);\n  if ( (0 == asize) && (0 != size) )\n  { /* size is too close to SIZE_MAX, very unlikely */\n    *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  if (asize > pool->end - pool->pos)\n  {\n    mhd_assert ((pool->end - pool->pos) == \\\n                ROUND_TO_ALIGN (pool->end - pool->pos));\n    if (asize <= pool->end)\n      *required_bytes = asize - (pool->end - pool->pos);\n    else\n      *required_bytes = SIZE_MAX;\n    return NULL;\n  }\n  *required_bytes = 0;\n  ret = &pool->memory[pool->end - asize];\n  pool->end -= asize;\n  _MHD_UNPOISON_MEMORY (ret, size);\n  return ret;\n}\n...\nvoid *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n                     size_t old_size,\n                     size_t new_size)\n{\n  size_t asize;\n  uint8_t *new_blc;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (old != NULL || old_size == 0);\n  mhd_assert (pool->size >= old_size);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n#if defined(MHD_ASAN_POISON_ACTIVE) && defined(HAVE___ASAN_REGION_IS_POISONED)\n  mhd_assert (NULL == __asan_region_is_poisoned (old, old_size));\n#endif /* MHD_ASAN_POISON_ACTIVE && HAVE___ASAN_REGION_IS_POISONED */\n\n  if (NULL != old)\n  {   /* Have previously allocated data */\n    const size_t old_offset = mp_ptr_diff_ (old, pool->memory);\n    const bool shrinking = (old_size > new_size);\n\n    mhd_assert (mp_ptr_le_ (pool->memory, old));\n    /* (pool->memory + pool->size >= (uint8_t*) old + old_size) */\n    mhd_assert ((pool->size - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size));\n    /* Blocks \"from the end\" must not be reallocated */\n    /* (old_size == 0 || pool->memory + pool->pos > (uint8_t*) old) */\n    mhd_assert ((old_size == 0) || \\\n                (pool->pos > old_offset));\n    mhd_assert ((old_size == 0) || \\\n                ((pool->end - _MHD_RED_ZONE_SIZE) >= (old_offset + old_size)));\n    /* Try resizing in-place */\n    if (shrinking)\n    {     /* Shrinking in-place, zero-out freed part */\n      memset ((uint8_t *) old + new_size, 0, old_size - new_size);\n      _MHD_POISON_MEMORY ((uint8_t *) old + new_size, old_size - new_size);\n    }\n    if (pool->pos ==\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + old_size))\n    {     /* \"old\" block is the last allocated block */\n      const size_t new_apos =\n        ROUND_TO_ALIGN_PLUS_RED_ZONE (old_offset + new_size);\n      if (! shrinking)\n      {                               /* Grow in-place, check for enough space. */\n        if ( (new_apos > pool->end) ||\n             (new_apos < pool->pos) ) /* Value wrap */\n          return NULL;                /* No space */\n      }\n      /* Resized in-place */\n      pool->pos = new_apos;\n      _MHD_UNPOISON_MEMORY (old, new_size);\n      return old;\n    }\n    if (shrinking)\n      return old;   /* Resized in-place, freed part remains allocated */\n  }\n  /* Need to allocate new block */\n  asize = ROUND_TO_ALIGN_PLUS_RED_ZONE (new_size);\n  if ( ( (0 == asize) &&\n         (0 != new_size) ) || /* Value wrap, too large new_size. */\n       (asize > pool->end - pool->pos) ) /* Not enough space */\n    return NULL;\n\n  new_blc = pool->memory + pool->pos;\n  pool->pos += asize;\n\n  _MHD_UNPOISON_MEMORY (new_blc, new_size);\n  if (0 != old_size)\n  {\n    /* Move data to new block, old block remains allocated */\n    memcpy (new_blc, old, old_size);\n    /* Zero-out old block */\n    memset (old, 0, old_size);\n    _MHD_POISON_MEMORY (old, old_size);\n  }\n  return new_blc;\n}\n...\nstatic enum MHD_Result\nMHD_set_connection_value_n_nocheck_ (struct MHD_Connection *connection,\n                                     enum MHD_ValueKind kind,\n                                     const char *key,\n                                     size_t key_size,\n                                     const char *value,\n                                     size_t value_size)\n{\n  struct MHD_HTTP_Req_Header *pos;\n\n  pos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = key;\n  pos->header_size = key_size;\n  pos->value = value;\n  pos->value_size = value_size;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->rq.headers_received_tail)\n  {\n    connection->rq.headers_received = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  else\n  {\n    connection->rq.headers_received_tail->next = pos;\n    connection->rq.headers_received_tail = pos;\n  }\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->rp.response;\n  mhd_assert (connection->rp.props.send_reply_body);\n\n  if ( (0 == response->total_size) ||\n                     /* TODO: replace the next check with assert */\n       (connection->rp.rsp_write_position == response->total_size) )\n    return MHD_YES;  /* 0-byte response is always ready */\n  if (NULL != response->data_iov)\n  {\n    size_t copy_size;\n\n    if (NULL != connection->rp.resp_iov.iov)\n      return MHD_YES;\n    copy_size = response->data_iovcnt * sizeof(MHD_iovec_);\n    connection->rp.resp_iov.iov = MHD_connection_alloc_memory_ (connection,\n                                                                copy_size);\n    if (NULL == connection->rp.resp_iov.iov)\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      /* not enough memory */\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (out of memory).\"));\n      return MHD_NO;\n    }\n    memcpy (connection->rp.resp_iov.iov,\n            response->data_iov,\n            copy_size);\n    connection->rp.resp_iov.cnt = response->data_iovcnt;\n    connection->rp.resp_iov.sent = 0;\n    return MHD_YES;\n  }\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (response->data_start <=\n        connection->rp.rsp_write_position) &&\n       (response->data_size + response->data_start >\n        connection->rp.rsp_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->rp.resp_sender)\n  {\n    /* will use sendfile, no need to bother response crc */\n    return MHD_YES;\n  }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->rp.rsp_write_position,\n                       (char *) response->data,\n                       (size_t) MHD_MIN ((uint64_t) response->data_buffer_size,\n                                         response->total_size\n                                         - connection->rp.rsp_write_position));\n  if (0 > ret)\n  {\n    /* either error or http 1.0 transfer, close socket! */\n    /* TODO: do not update total size, check whether response\n     * was really with unknown size */\n    response->total_size = connection->rp.rsp_write_position;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    if (MHD_CONTENT_READER_END_OF_STREAM == ret)\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_COMPLETED_OK);\n    else\n      CONNECTION_CLOSE_ERROR (connection,\n                              _ (\"Closing connection (application reported \" \\\n                                 \"error generating data).\"));\n    return MHD_NO;\n  }\n  response->data_start = connection->rp.rsp_write_position;\n  response->data_size = (size_t) ret;\n  if (0 == ret)\n  {\n    connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n...\nstatic enum _MHD_ParseCookie\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  size_t hdr_len;\n  char *cpy;\n  size_t i;\n  enum _MHD_ParseCookie parse_res;\n  struct MHD_HTTP_Req_Header *const saved_tail =\n    connection->rq.headers_received_tail;\n  const bool allow_partially_correct_cookie =\n    (1 >= connection->daemon->client_discipline);\n\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_COOKIE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_COOKIE),\n                                     &hdr,\n                                     &hdr_len))\n    return MHD_PARSE_COOKIE_OK;\n  if (0 == hdr_len)\n    return MHD_PARSE_COOKIE_OK;\n\n  cpy = MHD_connection_alloc_memory_ (connection,\n                                      hdr_len + 1);\n  if (NULL == cpy)\n    parse_res = MHD_PARSE_COOKIE_NO_MEMORY;\n  else\n  {\n    memcpy (cpy,\n            hdr,\n            hdr_len);\n    cpy[hdr_len] = '\\0';\n\n    i = 0;\n    /* Skip all initial whitespaces */\n    while (i < hdr_len && (' ' == cpy[i] || '\\t' == cpy[i]))\n      i++;\n\n    parse_res = parse_cookies_string (cpy + i, hdr_len - i, connection);\n  }\n\n  switch (parse_res)\n  {\n  case MHD_PARSE_COOKIE_OK:\n    break;\n  case MHD_PARSE_COOKIE_OK_LAX:\n#ifdef HAVE_MESSAGES\n    if (saved_tail != connection->rq.headers_received_tail)\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has been parsed, but it is not fully \"\n                   \"compliant with the standard.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_MALFORMED:\n    if (saved_tail != connection->rq.headers_received_tail)\n    {\n      if (! allow_partially_correct_cookie)\n      {\n        /* Remove extracted values from partially broken cookie */\n        /* Memory remains allocated until the end of the request processing */\n        connection->rq.headers_received_tail = saved_tail;\n        saved_tail->next = NULL;\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been ignored as it contains \"\n                     \"malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (connection->daemon,\n                  _ (\"The Cookie header has been only partially parsed as it \"\n                     \"contains malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"The Cookie header has malformed data.\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  case MHD_PARSE_COOKIE_NO_MEMORY:\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection pool to \"\n                 \"parse client cookies!\\n\"));\n#endif /* HAVE_MESSAGES */\n    break;\n  default:\n    mhd_assert (0);\n    break;\n  }\n#ifndef HAVE_MESSAGES\n  (void) saved_tail; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n\n  return parse_res;\n}\n...\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n...\nconst struct MHD_RqDAuth *\nMHD_get_rq_dauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqDAuth *dauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.dauth_tried)\n    return connection->rq.dauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_DIGEST, &h_auth_value))\n  {\n    connection->rq.dauth_tried = true;\n    connection->rq.dauth = NULL;\n    return NULL;\n  }\n\n  dauth =\n    (struct MHD_RqDAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqDAuth));\n\n  if (NULL == dauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Digest Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (dauth, 0, sizeof(struct MHD_RqDAuth));\n  if (parse_dauth_params (h_auth_value.str, h_auth_value.len, dauth))\n    connection->rq.dauth = dauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Digest Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.dauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.dauth_tried = true;\n  return connection->rq.dauth;\n}\n...\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\npos = MHD_connection_alloc_memory_ (connection,\n                                      sizeof (struct MHD_HTTP_Res_Header));\n```\nFocus on the above code fragment and judge whether it violates the rule 17.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The call pos = MHD_connection_alloc_memory_(connection, sizeof(struct MHD_HTTP_Res_Header)); invokes MHD_connection_alloc_memory_, which calls pool allocation helpers (MHD_pool_try_alloc, MHD_pool_reallocate, MHD_pool_allocate) but none of these call MHD_connection_alloc_memory_ (directly or indirectly). There is no recursion in the call graph shown, so Rule 17.2 is not violated."
}