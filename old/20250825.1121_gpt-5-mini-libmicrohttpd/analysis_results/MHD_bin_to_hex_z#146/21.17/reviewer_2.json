{
  "user_message": "An agent A claimed that the following MHD_bin_to_hex_z code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_bin_to_hex_z.\n```c\nsize_t\nMHD_bin_to_hex_z (const void *bin,\n                  size_t size,\n                  char *hex)\n{\n  size_t res;\n\n  res = MHD_bin_to_hex (bin, size, hex);\n  hex[res] = 0;\n\n  return res;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call to strlen(username) and strlen(realm) can read past the provided objects if username or realm are not NUL-terminated (or are NULL). MHD_digest_auth_calc_userhash performs no checks that the pointers are non-NULL and that the strings are properly terminated before calling strlen, so if a caller passes a non-terminated buffer or NULL, strlen will access beyond the object bounds (violation of Rule 21.17).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_bin_to_hex_z:\nsize_t\nMHD_bin_to_hex (const void *bin,\n                size_t size,\n                char *hex)\n{\n  size_t i;\n\n  for (i = 0; i < size; ++i)\n  {\n    uint8_t j;\n    const uint8_t b = ((const uint8_t *) bin)[i];\n    j = b >> 4;\n    hex[i * 2] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n    j = b & 0x0f;\n    hex[i * 2 + 1] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n  }\n  return i * 2;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash_hex (enum MHD_DigestAuthAlgo3 algo3,\n                                   const char *username,\n                                   const char *realm,\n                                   char *userhash_hex,\n                                   size_t hex_buf_size)\n{\n  uint8_t userhash_bin[MAX_DIGEST];\n  size_t digest_size;\n\n  digest_size = digest_get_hash_size (algo3);\n  if (digest_size * 2 + 1 > hex_buf_size)\n    return MHD_NO;\n  if (MHD_NO == MHD_digest_auth_calc_userhash (algo3, username, realm,\n                                               userhash_bin, MAX_DIGEST))\n    return MHD_NO;\n\n  MHD_bin_to_hex_z (userhash_bin, digest_size, userhash_hex);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n...\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n#ifdef MHD_MD5_SUPPORT\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    return MHD_SHA256_DIGEST_SIZE;\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    return MHD_SHA512_256_DIGEST_SIZE;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  return 0; /* Wrong input or unsupported algorithm */\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct for the target function MHD_bin_to_hex_z. That function does not call any <string.h> routines; it simply calls MHD_bin_to_hex (which writes exactly 2*size bytes) and then writes a terminating NUL at hex[res]. In the shown call path (MHD_digest_auth_calc_userhash_hex) the caller checks that digest_size * 2 + 1 <= hex_buf_size before calling MHD_bin_to_hex_z, so the terminating NUL write is within bounds. The agent's described scenario concerns calls to strlen in MHD_digest_auth_calc_userhash (potentially problematic if username or realm are NULL or not NUL-terminated), but that is a different function than the reported target. Therefore the claim that MHD_bin_to_hex_z violates MISRA C:2023 Rule 21.17 is false. (Note: the strlen usage in MHD_digest_auth_calc_userhash could be a separate concern if the API does not guarantee non-NULL, NUL-terminated strings.)"
}