{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_bin_to_hex_z:\n```c\nsize_t\nMHD_bin_to_hex_z (const void *bin,\n                  size_t size,\n                  char *hex)\n{\n  size_t res;\n\n  res = MHD_bin_to_hex (bin, size, hex);\n  hex[res] = 0;\n\n  return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_bin_to_hex_z:\nsize_t\nMHD_bin_to_hex (const void *bin,\n                size_t size,\n                char *hex)\n{\n  size_t i;\n\n  for (i = 0; i < size; ++i)\n  {\n    uint8_t j;\n    const uint8_t b = ((const uint8_t *) bin)[i];\n    j = b >> 4;\n    hex[i * 2] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n    j = b & 0x0f;\n    hex[i * 2 + 1] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n  }\n  return i * 2;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash_hex (enum MHD_DigestAuthAlgo3 algo3,\n                                   const char *username,\n                                   const char *realm,\n                                   char *userhash_hex,\n                                   size_t hex_buf_size)\n{\n  uint8_t userhash_bin[MAX_DIGEST];\n  size_t digest_size;\n\n  digest_size = digest_get_hash_size (algo3);\n  if (digest_size * 2 + 1 > hex_buf_size)\n    return MHD_NO;\n  if (MHD_NO == MHD_digest_auth_calc_userhash (algo3, username, realm,\n                                               userhash_bin, MAX_DIGEST))\n    return MHD_NO;\n\n  MHD_bin_to_hex_z (userhash_bin, digest_size, userhash_hex);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_digest_auth_calc_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                               const char *username,\n                               const char *realm,\n                               void *userhash_bin,\n                               size_t bin_buf_size)\n{\n  struct DigestAlgorithm da;\n  enum MHD_Result ret;\n\n  if (! digest_init_one_time (&da, get_base_digest_algo (algo3)))\n    return MHD_NO;\n  if (digest_get_size (&da) > bin_buf_size)\n    ret = MHD_NO;\n  else\n  {\n    calc_userhash (&da,\n                   username,\n                   strlen (username),\n                   realm,\n                   strlen (realm),\n                   userhash_bin);\n    ret = MHD_YES;\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (&da))\n      ret = MHD_NO;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  }\n  digest_deinit (&da);\n\n  return ret;\n}\n...\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n#ifdef MHD_MD5_SUPPORT\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    return MHD_SHA256_DIGEST_SIZE;\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    return MHD_SHA512_256_DIGEST_SIZE;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  return 0; /* Wrong input or unsupported algorithm */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nsize_t\nMHD_bin_to_hex (const void *bin,\n                size_t size,\n                char *hex)\n{\n  size_t i;\n\n  for (i = 0; i < size; ++i)\n  {\n    uint8_t j;\n    const uint8_t b = ((const uint8_t *) bin)[i];\n    j = b >> 4;\n    hex[i * 2] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n    j = b & 0x0f;\n    hex[i * 2 + 1] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n  }\n  return i * 2;\n}\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation in the provided code: MHD_bin_to_hex does not use any <string.h> functions and writes exactly 2*size bytes to hex indices 0..(2*size-1), returning 2*size. MHD_bin_to_hex_z writes a terminating NUL at hex[res]. The caller MHD_digest_auth_calc_userhash_hex checks that hex_buf_size >= digest_size*2 + 1 before calling, so no out-of-bounds access occurs. (A potential violation would occur only if a caller passed a hex buffer smaller than 2*size or omitted the +1 for the terminating NUL.)"
}