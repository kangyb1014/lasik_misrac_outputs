{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 17.8 is: A function parameter should not be modified.\nNote that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of parse_options:\n```c\nstatic enum MHD_Result\nparse_options (struct MHD_Daemon *daemon,\n               struct MHD_InterimParams_ *params,\n               ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n\n  va_start (ap, params);\n  ret = parse_options_va (daemon,\n                          params,\n                          ap);\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function parse_options:\nstatic enum MHD_Result\nparse_options_va (struct MHD_Daemon *daemon,\n                  struct MHD_InterimParams_ *params,\n                  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  const char *pstr;\n#if GNUTLS_VERSION_MAJOR >= 3\n  gnutls_certificate_retrieve_function2 * pgcrf;\n#endif\n#if GNUTLS_VERSION_NUMBER >= 0x030603\n  gnutls_certificate_retrieve_function3 * pgcrf2;\n#endif\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n  {\n    /* Increase counter at start, so resulting value is number of\n     * processed options, including any failed ones. */\n    params->num_opts++;\n    switch (opt)\n    {\n    case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n        if (0 != val)\n        {\n          daemon->pool_size = val;\n          if (64 > daemon->pool_size)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT \" \\\n                         \"value is too small and rounded up to 64.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_size = 64;\n          }\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n            daemon->pool_increment = daemon->pool_size / 4;\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n      if (1)\n      {\n        size_t val;\n\n        val = va_arg (ap,\n                      size_t);\n\n        if (0 != val)\n        {\n          daemon->pool_increment = val;\n          if (daemon->pool_size / 4 < daemon->pool_increment)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Warning: specified \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_INCREMENT value is \" \\\n                         \"too large and rounded down to 1/4 of \" \\\n                         \"MHD_OPTION_CONNECTION_MEMORY_LIMIT.\\n\"));\n#endif /* HAVE_MESSAGES */\n            daemon->pool_increment = daemon->pool_size / 4;\n          }\n        }\n      }\n      break;\n    case MHD_OPTION_CONNECTION_LIMIT:\n      daemon->connection_limit = va_arg (ap,\n                                         unsigned int);\n      break;\n    case MHD_OPTION_CONNECTION_TIMEOUT:\n      uv = va_arg (ap,\n                   unsigned int);\n#if (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT\n      if ((UINT64_MAX / 4000 - 1) < uv)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"The specified connection timeout (%u) is too large. \" \\\n                     \"Maximum allowed value (%\" PRIu64 \") will be used \" \\\n                     \"instead.\\n\"),\n                  uv,\n                  (UINT64_MAX / 4000 - 1));\n#endif\n        uv = UINT64_MAX / 4000 - 1;\n      }\n#endif /* (SIZEOF_UINT64_T - 2) <= SIZEOF_UNSIGNED_INT */\n      daemon->connection_timeout_ms = ((uint64_t) uv) * 1000;\n      break;\n    case MHD_OPTION_NOTIFY_COMPLETED:\n      daemon->notify_completed = va_arg (ap,\n                                         MHD_RequestCompletedCallback);\n      daemon->notify_completed_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_NOTIFY_CONNECTION:\n      daemon->notify_connection = va_arg (ap,\n                                          MHD_NotifyConnectionCallback);\n      daemon->notify_connection_cls = va_arg (ap,\n                                              void *);\n      break;\n    case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n      daemon->per_ip_connection_limit = va_arg (ap,\n                                                unsigned int);\n      break;\n    case MHD_OPTION_SOCK_ADDR_LEN:\n      params->server_addr_len = va_arg (ap,\n                                        socklen_t);\n      params->server_addr_len_set = true;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_SOCK_ADDR:\n      params->server_addr_len_set = false;\n      params->pserver_addr = va_arg (ap,\n                                     const struct sockaddr *);\n      params->pserver_addr_set = true;\n      break;\n    case MHD_OPTION_URI_LOG_CALLBACK:\n      daemon->uri_log_callback = va_arg (ap,\n                                         LogCallback);\n      daemon->uri_log_callback_cls = va_arg (ap,\n                                             void *);\n      break;\n    case MHD_OPTION_SERVER_INSANITY:\n      daemon->insanity_level = (enum MHD_DisableSanityCheck)\n                               va_arg (ap,\n                                       unsigned int);\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_POOL_SIZE:\n      daemon->worker_pool_size = va_arg (ap,\n                                         unsigned int);\n      if (0 == daemon->worker_pool_size)\n      {\n        (void) 0; /* MHD_OPTION_THREAD_POOL_SIZE ignored, do nothing */\n      }\n      else if (1 == daemon->worker_pool_size)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Warning: value \\\"1\\\", specified as the thread pool \" \\\n                     \"size, is ignored. Thread pool is not used.\\n\"));\n#endif\n        daemon->worker_pool_size = 0;\n      }\n#if SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2)\n      /* Next comparison could be always false on some platforms and whole branch will\n       * be optimized out on these platforms. On others it will be compiled into real\n       * check. */\n      else if (daemon->worker_pool_size >=\n               (SIZE_MAX / sizeof (struct MHD_Daemon)))            /* Compiler may warn on some platforms, ignore warning. */\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Specified thread pool size (%u) too big.\\n\"),\n                  daemon->worker_pool_size);\n#endif\n        return MHD_NO;\n      }\n#endif /* SIZEOF_UNSIGNED_INT >= (SIZEOF_SIZE_T - 2) */\n      else\n      {\n        if (! MHD_D_IS_USING_THREADS_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n                       \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n                       \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n          return MHD_NO;\n        }\n      }\n      break;\n#endif\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_key = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_key_password = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_CERT:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_cert = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->https_mem_trust = pstr;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n      daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                              int);\n      break;\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        gnutls_datum_t dhpar;\n        size_t pstr_len;\n\n        if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Error initializing DH parameters.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.data = (unsigned char *) _MHD_DROP_CONST (pstr);\n        pstr_len = strlen (pstr);\n        if (UINT_MAX < pstr_len)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Diffie-Hellman parameters string too long.\\n\"));\n#endif\n          return MHD_NO;\n        }\n        dhpar.size = (unsigned int) pstr_len;\n        if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                           &dhpar,\n                                           GNUTLS_X509_FMT_PEM) < 0)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _ (\"Bad Diffie-Hellman parameters format.\\n\"));\n#endif\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          return MHD_NO;\n        }\n        daemon->have_dhparams = true;\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n      pstr = va_arg (ap,\n                     const char *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n      {\n        if (NULL != daemon->priority_cache)\n          gnutls_priority_deinit (daemon->priority_cache);\n\n        if (MHD_OPTION_HTTPS_PRIORITIES == opt)\n        {\n          int init_res;\n          const char *err_pos;\n          init_res = gnutls_priority_init (&daemon->priority_cache,\n                                           pstr,\n                                           &err_pos);\n          if (GNUTLS_E_SUCCESS != init_res)\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _ (\"Setting priorities to '%s' failed: %s \" \\\n                         \"The problematic part starts at: %s\\n\"),\n                      pstr,\n                      gnutls_strerror (init_res),\n                      err_pos);\n#endif\n            daemon->priority_cache = NULL;\n            return MHD_NO;\n          }\n        }\n        else\n        {\n          /* The cache has been deinited */\n          daemon->priority_cache = NULL;\n          if (! daemon_tls_priorities_init_append (daemon, pstr))\n            return MHD_NO;\n        }\n      }\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif\n      break;\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building \" \\\n                   \"MHD with GnuTLS >= 3.0.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf = va_arg (ap,\n                      gnutls_certificate_retrieve_function2 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback = pgcrf;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /*  HAVE_MESSAGES */\n      break;\n#endif\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#if GNUTLS_VERSION_NUMBER < 0x030603\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD_OPTION_HTTPS_CERT_CALLBACK2 requires building \" \\\n                   \"MHD with GnuTLS >= 3.6.3.\\n\"));\n#endif\n      return MHD_NO;\n#else\n      pgcrf2 = va_arg (ap,\n                       gnutls_certificate_retrieve_function3 *);\n      if (0 != (daemon->options & MHD_USE_TLS))\n        daemon->cert_callback2 = pgcrf2;\n#ifdef HAVE_MESSAGES\n      else\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD but \" \\\n                     \"MHD_USE_TLS not set.\\n\"),\n                  opt);\n#endif /* HAVE_MESSAGES */\n      break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n      daemon->digest_auth_rand_size = va_arg (ap,\n                                              size_t);\n      daemon->digest_auth_random = va_arg (ap,\n                                           const char *);\n      if (MHD_OPTION_DIGEST_AUTH_RANDOM_COPY == opt)\n        /* Set to some non-NULL value just to indicate that copy is required. */\n        daemon->digest_auth_random_copy = daemon;\n      else\n        daemon->digest_auth_random_copy = NULL;\n      break;\n    case MHD_OPTION_NONCE_NC_SIZE:\n      daemon->nonce_nc_size = va_arg (ap,\n                                      unsigned int);\n      break;\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n      daemon->dauth_bind_type = va_arg (ap,\n                                        unsigned int);\n      if (0 != (daemon->dauth_bind_type & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n        daemon->dauth_bind_type |= MHD_DAUTH_BIND_NONCE_URI;\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n      if (1)\n      {\n        unsigned int val;\n        val = va_arg (ap,\n                      unsigned int);\n        if (0 != val)\n          daemon->dauth_def_nonce_timeout = val;\n      }\n      break;\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n      if (1)\n      {\n        uint32_t val;\n        val = va_arg (ap,\n                      uint32_t);\n        if (0 != val)\n          daemon->dauth_def_max_nc = val;\n      }\n      break;\n#else  /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_DIGEST_AUTH_RANDOM:\n    case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n    case MHD_OPTION_NONCE_NC_SIZE:\n    case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n    case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Digest Auth is disabled for this build \" \\\n                   \"of GNU libmicrohttpd.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! DAUTH_SUPPORT */\n    case MHD_OPTION_LISTEN_SOCKET:\n      params->listen_fd = va_arg (ap,\n                                  MHD_socket);\n      params->listen_fd_set = true;\n      break;\n    case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n      daemon->custom_error_log = va_arg (ap,\n                                         VfprintfFunctionPointerType);\n      daemon->custom_error_log_cls = va_arg (ap,\n                                             void *);\n      if (1 != params->num_opts)\n        MHD_DLOG (daemon,\n                  _ (\"MHD_OPTION_EXTERNAL_LOGGER is not the first option \"\n                     \"specified for the daemon. Some messages may be \"\n                     \"printed by the standard MHD logger.\\n\"));\n\n#else\n      (void) va_arg (ap,\n                     VfprintfFunctionPointerType);\n      (void) va_arg (ap,\n                     void *);\n#endif\n      break;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    case MHD_OPTION_THREAD_STACK_SIZE:\n      daemon->thread_stack_size = va_arg (ap,\n                                          size_t);\n      break;\n#endif\n    case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n#ifdef TCP_FASTOPEN\n      daemon->fastopen_queue_size = va_arg (ap,\n                                            unsigned int);\n      break;\n#else  /* ! TCP_FASTOPEN */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"TCP fastopen is not supported on this platform.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n#endif /* ! TCP_FASTOPEN */\n    case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n      daemon->listening_address_reuse = va_arg (ap,\n                                                unsigned int) ? 1 : -1;\n      break;\n    case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n      daemon->listen_backlog_size = va_arg (ap,\n                                            unsigned int);\n      break;\n    case MHD_OPTION_STRICT_FOR_CLIENT:\n      daemon->client_discipline = va_arg (ap, int); /* Temporal assignment */\n      /* Map to correct value */\n      if (-1 >= daemon->client_discipline)\n        daemon->client_discipline = -3;\n      else if (1 <= daemon->client_discipline)\n        daemon->client_discipline = 1;\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_STRICT_CLIENT.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n      daemon->client_discipline = va_arg (ap, int);\n#ifdef HAVE_MESSAGES\n      if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n           (1 != daemon->client_discipline) )\n      {\n        MHD_DLOG (daemon,\n                  _ (\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                     \"another behaviour is specified by \"\n                     \"MHD_OPTION_CLIENT_DISCIPLINE_LVL.\\n\"));\n      }\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_ARRAY:\n      params->num_opts--; /* Do not count MHD_OPTION_ARRAY */\n      oa = va_arg (ap, struct MHD_OptionItem *);\n      i = 0;\n      while (MHD_OPTION_END != (opt = oa[i].option))\n      {\n        switch (opt)\n        {\n        /* all options taking 'size_t' */\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'unsigned int' */\n        case MHD_OPTION_NONCE_NC_SIZE:\n        case MHD_OPTION_CONNECTION_LIMIT:\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n        case MHD_OPTION_THREAD_POOL_SIZE:\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n        case MHD_OPTION_LISTENING_ADDRESS_REUSE:\n        case MHD_OPTION_LISTEN_BACKLOG_SIZE:\n        case MHD_OPTION_SERVER_INSANITY:\n        case MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE:\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_NONCE_TIMEOUT:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (unsigned int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'enum' */\n        case MHD_OPTION_HTTPS_CRED_TYPE:\n#ifdef HTTPS_SUPPORT\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (gnutls_credentials_type_t) oa[i].value,\n                                       MHD_OPTION_END))\n#endif /* HTTPS_SUPPORT */\n          return MHD_NO;\n          break;\n        /* all options taking 'MHD_socket' */\n        case MHD_OPTION_LISTEN_SOCKET:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (MHD_socket) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'int' */\n        case MHD_OPTION_STRICT_FOR_CLIENT:\n        case MHD_OPTION_CLIENT_DISCIPLINE_LVL:\n        case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n        case MHD_OPTION_TLS_NO_ALPN:\n        case MHD_OPTION_APP_FD_SETSIZE:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (int) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking 'uint32_t' */\n        case MHD_OPTION_DIGEST_AUTH_DEFAULT_MAX_NC:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (uint32_t) oa[i].value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking one pointer */\n        case MHD_OPTION_SOCK_ADDR:\n        case MHD_OPTION_HTTPS_MEM_KEY:\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n        case MHD_OPTION_HTTPS_MEM_CERT:\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n        case MHD_OPTION_HTTPS_PRIORITIES:\n        case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n        case MHD_OPTION_ARRAY:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n        case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* all options taking two pointers */\n        case MHD_OPTION_NOTIFY_COMPLETED:\n        case MHD_OPTION_NOTIFY_CONNECTION:\n        case MHD_OPTION_URI_LOG_CALLBACK:\n        case MHD_OPTION_EXTERNAL_LOGGER:\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n        case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (void *) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking size_t-number followed by pointer */\n        case MHD_OPTION_DIGEST_AUTH_RANDOM:\n        case MHD_OPTION_DIGEST_AUTH_RANDOM_COPY:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (size_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        /* options taking socklen_t-number followed by pointer */\n        case MHD_OPTION_SOCK_ADDR_LEN:\n          if (MHD_NO == parse_options (daemon,\n                                       params,\n                                       opt,\n                                       (socklen_t) oa[i].value,\n                                       oa[i].ptr_value,\n                                       MHD_OPTION_END))\n            return MHD_NO;\n          break;\n        case MHD_OPTION_END: /* Not possible */\n        default:\n          return MHD_NO;\n        }\n        i++;\n      }\n      break;\n    case MHD_OPTION_UNESCAPE_CALLBACK:\n      daemon->unescape_callback = va_arg (ap,\n                                          UnescapeCallback);\n      daemon->unescape_callback_cls = va_arg (ap,\n                                              void *);\n      break;\n#ifdef HTTPS_SUPPORT\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n#if GNUTLS_VERSION_MAJOR >= 3\n      daemon->cred_callback = va_arg (ap,\n                                      MHD_PskServerCredentialsCallback);\n      daemon->cred_callback_cls = va_arg (ap,\n                                          void *);\n      break;\n#else\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD compiled \" \\\n                   \"without GNUtls >= 3.\\n\"),\n                opt);\n      return MHD_NO;\n#endif\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_SIGPIPE_HANDLED_BY_APP:\n      if (! MHD_D_IS_USING_THREADS_ (daemon))\n        daemon->sigpipe_blocked = ( (va_arg (ap,\n                                             int)) != 0);\n      else\n      {\n        (void) va_arg (ap,\n                       int);\n      }\n      break;\n    case MHD_OPTION_TLS_NO_ALPN:\n#ifdef HTTPS_SUPPORT\n      daemon->disable_alpn = (va_arg (ap,\n                                      int) != 0);\n#else  /* ! HTTPS_SUPPORT */\n      (void) va_arg (ap, int);\n#endif /* ! HTTPS_SUPPORT */\n#ifdef HAVE_MESSAGES\n      if (0 == (daemon->options & MHD_USE_TLS))\n        MHD_DLOG (daemon,\n                  _ (\"MHD HTTPS option %d passed to MHD \" \\\n                     \"but MHD_USE_TLS not set.\\n\"),\n                  (int) opt);\n#endif /* HAVE_MESSAGES */\n      break;\n    case MHD_OPTION_APP_FD_SETSIZE:\n      params->fdset_size_set = true;\n      params->fdset_size = va_arg (ap,\n                                   int);\n      break;\n#ifndef HTTPS_SUPPORT\n    case MHD_OPTION_HTTPS_MEM_KEY:\n    case MHD_OPTION_HTTPS_MEM_CERT:\n    case MHD_OPTION_HTTPS_CRED_TYPE:\n    case MHD_OPTION_HTTPS_PRIORITIES:\n    case MHD_OPTION_HTTPS_PRIORITIES_APPEND:\n    case MHD_OPTION_HTTPS_MEM_TRUST:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK:\n    case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n    case MHD_OPTION_HTTPS_KEY_PASSWORD:\n    case MHD_OPTION_GNUTLS_PSK_CRED_HANDLER:\n    case MHD_OPTION_HTTPS_CERT_CALLBACK2:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"MHD HTTPS option %d passed to MHD \"\n                   \"compiled without HTTPS support.\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n#endif /* HTTPS_SUPPORT */\n    case MHD_OPTION_END: /* Not possible */\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Invalid option %d! (Did you terminate \"\n                   \"the list with MHD_OPTION_END?).\\n\"),\n                opt);\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nparams->listen_fd = va_arg (ap,\n                                  MHD_socket);\n\n```\nFocus on the above code fragment and judge whether it violates the rule 17.8 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "Not violated. The statement assigns to a member of *params (params->listen_fd), i.e. it modifies the object pointed to by the pointer parameter, not the pointer parameter itself. MISRA Rule 17.8 allows modifying the object referred to by a pointer parameter; it forbids changing the pointer parameter (e.g. doing \u2018params = some_other_ptr;\u2019 or incrementing \u2018params\u2019), which this code does not do."
}