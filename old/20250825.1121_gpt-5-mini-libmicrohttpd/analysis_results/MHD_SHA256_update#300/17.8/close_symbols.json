{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (definition)",
    "SHA256_BLOCK_SIZE (macro)",
    "MHD_FAVOR_SMALL_CODE (macro)",
    "mhd_assert (macro/function)",
    "memcpy (prototype/definition or macro)",
    "sha256_transform (prototype/definition)",
    "uint8_t typedef (include <stdint.h> or equivalent)",
    "size_t typedef (include <stddef.h> or equivalent)"
  ],
  "explanation": "Needed symbols and reasons:\n\n- struct Sha256Ctx (definition): required to know the types of ctx members (count, buffer, H). This confirms that ctx is a pointer parameter (so modifying *ctx is allowed under the rule) and shows whether any use could alias or affect parameter semantics.\n\n- SHA256_BLOCK_SIZE (macro): needed to understand the loop and arithmetic that drive the updates to data and length (how many times data and length get adjusted). Knowing the constant value helps determine whether the code necessarily modifies parameter variables in normal execution.\n\n- MHD_FAVOR_SMALL_CODE (macro): presence/absence of this macro changes control flow (early return when length == 0). To decide if parameter modifications can occur in some build configurations we must know whether this macro is defined.\n\n- mhd_assert (macro/function): the assert uses the parameters (data, length). Its definition could expand to code that reads or modifies parameters (or to nothing), affecting whether parameter variables are touched prior to other modifications.\n\n- memcpy (prototype/definition or macro): memcpy might be a macro or function; its definition ensures it does not implicitly modify the parameter variables (data or length) passed to MHD_SHA256_update, and clarifies whether any side-effects on the pointer variables can occur through macro expansion.\n\n- sha256_transform (prototype/definition): to confirm its signature and whether it could be a macro that affects the parameter variables (e.g., by reusing the identifier data via macro expansion) and to ensure it does not alter the parameter variables of MHD_SHA256_update through unexpected side-effects.\n\n- uint8_t typedef (header providing it): to confirm the exact type used for data and whether any unusual typedefs or macros change interpretation of the parameter declaration.\n\n- size_t typedef (header providing it): to confirm type of length (signed/unsigned width) because arithmetic on length could be affected by its actual definition; also to ensure there are no typedefs that turn size_t into something with different semantics.\n\nRationale summary: The MISRA rule under scrutiny forbids modifying function parameter variables themselves. To determine if MHD_SHA256_update violates it we must confirm which identifiers in the function are parameters vs. local variables, whether any macros or called-inlined code could implicitly modify those parameters, and whether build-time macros change control flow so that parameter modification may or may not occur. The listed symbols are the minimal additional definitions needed to perform that determination reliably."
}