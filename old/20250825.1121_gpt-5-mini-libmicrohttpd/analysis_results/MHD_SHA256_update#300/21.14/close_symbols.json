{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nThe Standard Library function memcmp shall not be used to compare null terminated strings. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition: fields count, buffer, H)",
    "SHA256_BLOCK_SIZE macro",
    "memcpy (declaration/implementation)",
    "sha256_transform (declaration and implementation)",
    "memcmp (declaration/any uses in linked code)",
    "MHD_FAVOR_SMALL_CODE macro",
    "mhd_assert (macro/definition)",
    "uint8_t (typedef)",
    "size_t (typedef)"
  ],
  "explanation": "1) struct Sha256Ctx (full definition: fields count, buffer, H)\n   - Required to know the exact type and intent of ctx->buffer and ctx->count. If buffer is a character/string buffer or contains/produces null-terminated data this matters for deciding whether any byte operations (copies or comparisons) are being applied to C-strings. Also needed to verify whether buffer holds binary blocks (so memcmp would not be comparing null-terminated strings).\n\n2) SHA256_BLOCK_SIZE macro\n   - Needed to understand block boundaries and buffer sizing. If block size or buffer layout implies binary block processing (not string operations), that supports that no memcmp-on-NT-strings violation occurs.\n\n3) memcpy (declaration/implementation / include location)\n   - The function uses memcpy to copy data. To distinguish copying raw bytes from string operations, the declaration and standard semantics confirm it is a memory-copy, not a comparison function; also to ensure there is no accidental alias to a string-comparing wrapper.\n\n4) sha256_transform (declaration and implementation)\n   - The target calls sha256_transform. If that callee uses memcmp on its inputs (for example comparing data as null-terminated strings), the call from MHD_SHA256_update could indirectly cause a MISRA rule violation. Inspecting the callee is necessary to ensure no memcmp-on-NT-strings happens in the flow invoked by this function.\n\n5) memcmp (declaration/any uses in linked code)\n   - To check for violation we must know whether memcmp is used anywhere reachable from this function (in inline code, in callees, or via macros). Having the symbol and any occurrences allows detection of comparisons that could be applied to null-terminated strings.\n\n6) MHD_FAVOR_SMALL_CODE macro\n   - The function contains conditional compilation based on this macro. Knowing its value affects whether the early-return on length==0 exists; control-flow differences can affect whether certain code paths that might compare strings (if present elsewhere) are reachable.\n\n7) mhd_assert (macro/definition)\n   - The assert enforces (data != NULL) || (length == 0). To reason about possible uses of memcmp on null-terminated strings you need to know whether data can be NULL and whether that constraint or other assertion macros mask string semantics.\n\n8) uint8_t (typedef)\n   - To confirm data and buffer are treated as unsigned bytes (binary data) rather than char-based strings. This helps determine intent (binary hashing vs string processing).\n\n9) size_t (typedef)\n   - For precise reasoning about length arithmetic and whether any length values could be used as string lengths (e.g., implicit assumptions about NUL-termination).\n\nTogether these symbols let the next analyst determine whether any memcmp use reachable from MHD_SHA256_update is ever applied to null-terminated C-strings (thus violating the MISRA rule), or whether all operations are byte/buffer-oriented and therefore not subject to that specific rule."
}