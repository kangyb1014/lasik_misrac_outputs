{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition)",
    "Sha256Ctx::buffer (declaration and size)",
    "Sha256Ctx::count (declaration and type)",
    "SHA256_BLOCK_SIZE (macro/value)",
    "sha256_transform (prototype and behavior)",
    "digest_update (caller) \u2014 and its call sites that pass data/length (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner)"
  ],
  "explanation": "To decide whether the two memcpy calls in MHD_SHA256_update can access beyond the bounds of their pointer parameters you must know the actual object sizes and value ranges involved and whether callers supply sufficiently large source objects. Specifically:\n\n- struct Sha256Ctx (full definition): contains the declarations of all fields accessed in the function. You need the full struct to find the declared type and size of ctx->buffer and the type of ctx->count; both directly affect pointer arithmetic and bounds.\n\n- Sha256Ctx::buffer (declaration and size): memcpy writes into ((uint8_t *)ctx->buffer) + bytes_have with length bytes_left or length. To prove these writes are in-bounds you must know the compile-time size (and element type) of the buffer object inside the context (for example whether it is an array of SHA256_BLOCK_SIZE bytes or some other size).\n\n- Sha256Ctx::count (declaration and type): bytes_have is computed from (ctx->count & (SHA256_BLOCK_SIZE - 1)) cast to unsigned. The width/sign of count and its valid range determine whether this masking produces a correct offset and whether any assumptions about modulo behavior hold.\n\n- SHA256_BLOCK_SIZE (macro/value): the code relies on this constant to compute bytes_left, to test loop bounds (while (SHA256_BLOCK_SIZE <= length)), and to relate buffer capacity to copies. You must know its value to compare against buffer size and lengths passed to memcpy.\n\n- sha256_transform (prototype and behavior): the function is called with ctx->buffer as an argument. Although sha256_transform is expected to consume the block, you must confirm it does not reallocate/resize/overwrite ctx->buffer (or otherwise change assumptions about buffer capacity) and to confirm that after the call the buffer object still has at least the same declared size.\n\n- digest_update and its callers (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner): to prove the source operand of memcpy (the pointer data and the value length) reference objects of at least 'length' bytes, you must inspect call sites that pass data and length into MHD_SHA256_update. Those callers establish whether length can exceed the size of the object pointed to by data or can cause data to point inside ctx->buffer (overlap) which would be relevant for correctness/undefined behavior.\n\nTogether, these symbols provide the necessary information about destination object sizes, computed offsets, block-size constants, and the provenance and sizes of source objects to determine whether the memcpy uses in MHD_SHA256_update can access beyond the bounds of the referenced objects (per the MISRA string.h bound rule)."
}