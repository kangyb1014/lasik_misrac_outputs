{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "sha256_transform",
    "__builtin_rotateright32",
    "__builtin_bswap32",
    "memcpy",
    "mhd_assert",
    "struct Sha256Ctx",
    "SHA256_BLOCK_SIZE",
    "MHD_FAVOR_SMALL_CODE"
  ],
  "explanation": "sha256_transform: The target function calls sha256_transform directly. Any for\u2011loops inside sha256_transform (or the behaviour of functions it calls) count toward the MISRA well\u2011formed for\u2011loop rule because the rule states the behaviour of a for loop body includes called functions. You must inspect sha256_transform's body to detect any for loops and see whether they obey the three clauses and single counter rule.\n\n__builtin_rotateright32 and __builtin_bswap32: These intrinsics are callees of sha256_transform (from the static call graph). Although typically compiler intrinsics do not contain for loops, they are part of sha256_transform\u2019s behaviour and must be considered when determining if any for loops reachable from the target violate the rule.\n\nmemcpy: The target function calls memcpy. If an implementation of memcpy used in this build contains for loops and those loops are relevant to the MISRA rule (for example, if memcpy is inlined into a for loop body or contains non\u2011conforming for constructs), it must be inspected. Also some builds inline or replace memcpy with helper code \u2014 include it to be sure.\n\nmhd_assert: The function/macro is invoked at the top of the target. If it expands to code containing for loops (or modifies loop counters/objects used in loops), that affects conformance. Include it to be certain no for loops or side\u2011effects are introduced.\n\nstruct Sha256Ctx: You need the definition to know what ctx->count, ctx->buffer and ctx->H are (types, alignment, whether they alias other objects). This is necessary to reason about which objects might be used or modified in loop clauses and bodies when inspecting for loops in called code.\n\nSHA256_BLOCK_SIZE: The macro is used in loop/condition calculations. Its value (and type) matters when reasoning about expressions used in loop second/third clauses or when determining whether an expression uses objects modified in loop bodies.\n\nMHD_FAVOR_SMALL_CODE: This compile\u2011time macro controls whether the early return on length == 0 is present. The compiled shape of the function (which blocks are present) can affect whether a for loop (if present via inlining or conditional compilation of callees) exists in the final translation unit; include it to know which code paths are compiled.\n\nNotes: The goal is to inspect any for loops present in the target and in any functions it calls (transitively). The symbols above are the minimal additional translation\u2011unit symbols you must open/inspect to determine whether any for loops reachable from MHD_SHA256_update violate the MISRA C well\u2011formed for\u2011loop rule."
}