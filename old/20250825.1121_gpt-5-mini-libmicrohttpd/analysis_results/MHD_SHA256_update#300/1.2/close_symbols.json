{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "sha256_transform",
    "__builtin_rotateright32",
    "__builtin_bswap32",
    "struct Sha256Ctx (definition: fields count, buffer, H)",
    "SHA256_BLOCK_SIZE",
    "mhd_assert",
    "memcpy",
    "MHD_FAVOR_SMALL_CODE"
  ],
  "explanation": "sha256_transform: The target calls this function; its implementation may use compiler builtins or other language extensions \u2014 needed to decide if the update() function indirectly relies on extensions. __builtin_rotateright32 and __builtin_bswap32: These are compiler builtin intrinsics (language extensions) referenced in the static call graph under sha256_transform; their presence directly determines a violation if indirect use is considered. struct Sha256Ctx (definition: fields count, buffer, H): The layout/types of count, buffer and H determine whether casts/operations in MHD_SHA256_update (e.g. (uint8_t *)ctx->buffer, ctx->count & ...) are implementing any non-standard behaviour or relying on compiler-specific types or bit-width assumptions. SHA256_BLOCK_SIZE: The macro value affects expressions like (SHA256_BLOCK_SIZE - 1) and loop bounds; if defined via non-standard extension or unusual value it could indicate extension usage. mhd_assert: Macro or function implementation may use compiler-specific extensions (e.g. statement expressions, typeof, __builtin_*); need its definition to ensure no language extensions are used. memcpy: While a standard library function, its declaration/implementation or any wrapper in this project could be an extension; include its prototype/wrapper to rule that out. MHD_FAVOR_SMALL_CODE: The conditional compilation flag controls compilation paths; its definition may enable extension-heavy code paths \u2014 needed to ensure the compiled code path for MHD_SHA256_update does not depend on extensions."
}