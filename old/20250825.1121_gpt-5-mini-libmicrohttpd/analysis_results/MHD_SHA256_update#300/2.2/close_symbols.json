{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition: types and sizes of fields count, buffer, H)",
    "SHA256_BLOCK_SIZE (macro/value)",
    "mhd_assert (macro or function definition)",
    "MHD_FAVOR_SMALL_CODE (macro: defined/undefined)",
    "sha256_transform (implementation)",
    "memcpy (library/builtin implementation/semantics)",
    "digest_update and its callers (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner)",
    "typedefs / widths of uint8_t and size_t (platform type sizes)",
    "any build macros that alter assertion/inline behavior (e.g. NDEBUG or project-specific debug macros)"
  ],
  "explanation": "For each symbol: \n\n- struct Sha256Ctx (full definition: types and sizes of fields count, buffer, H)\n  Reason: The update routine manipulates ctx->count, ctx->buffer and passes ctx->H to sha256_transform. To tell if those writes/reads are meaningful or removable (dead), we must know the exact types, buffer size/layout and whether writes change observable state.\n\n- SHA256_BLOCK_SIZE (macro/value)\n  Reason: The control flow (bytes_have calculation, bytes_left, the while loop) depends on this value. If the constant makes some branches impossible (e.g. 1, or <=0) or makes the mask/loop no-op, code may be dead. Also the mask trick (count & (SHA256_BLOCK_SIZE-1)) relies on block size properties (power-of-two).\n\n- mhd_assert (macro or function definition)\n  Reason: The assert may be compiled out or may abort/produce side effects. Whether the assertion code is present affects whether that statement is dead or not and affects control-flow/observable behavior.\n\n- MHD_FAVOR_SMALL_CODE (macro: defined/undefined)\n  Reason: Presence/absence controls the early-return shortcut for length==0. To decide if that return (and the surrounding test) is dead code one must know whether the macro is set in the build.\n\n- sha256_transform (implementation)\n  Reason: Calls to sha256_transform are the potentially observable side effects of this function (they mutate ctx->H/state). To determine whether the transform calls (and the associated memcpy that prepares inputs) are removable, the implementation (and whether it is a no-op under some build/config) must be inspected.\n\n- memcpy (library/builtin implementation/semantics)\n  Reason: The function copies bytes into ctx->buffer. Removing memcpy would change memory state unless it can be proven redundant; knowledge of memcpy semantics (and whether compiler replaces or optimizes it away) is needed to decide if those stores are dead.\n\n- digest_update and its callers (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner)\n  Reason: To decide if MHD_SHA256_update (or parts of it) are dead at project level you must know whether this function is ever reachable from program entry points. The static callers (and whether those callers are reachable) determine whether the whole function is dead code.\n\n- typedefs / widths of uint8_t and size_t (platform type sizes)\n  Reason: The cast and arithmetic (ctx->count += length; mask & operations) depend on type widths and unsigned wrap behaviour. That affects whether operations can be optimized away or are observable (e.g. overflow behavior).\n\n- any build macros that alter assertion/inline behavior (e.g. NDEBUG or project-specific debug macros)\n  Reason: These macros can remove assertions or change inlining/optimization of functions (memcpy, sha256_transform), altering whether code is present or can be removed safely.\n\nProviding these symbol definitions and build/config settings lets the next analyst determine whether each executed operation in MHD_SHA256_update has an observable effect (so not dead) or can be removed without changing program behaviour (dead)."
}