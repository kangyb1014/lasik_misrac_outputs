{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "SHA256_BLOCK_SIZE",
    "struct Sha256Ctx (definition)",
    "ctx->count (member type and qualifiers)",
    "ctx->buffer (member type)",
    "MHD_FAVOR_SMALL_CODE (preprocessor symbol)",
    "mhd_assert (macro definition)"
  ],
  "explanation": "Brief rationale for each symbol (why it is needed to decide if any controlling expression in MHD_SHA256_update is invariant):\n\n- SHA256_BLOCK_SIZE\n  - The code uses (SHA256_BLOCK_SIZE - 1) in a bitwise mask and tests while (SHA256_BLOCK_SIZE <= length). The numeric value (and whether it can be 0 or 1 or another small constant) directly affects whether expressions such as (ctx->count & (SHA256_BLOCK_SIZE - 1)) and the while condition can be invariant (always zero/always true/always false).\n\n- struct Sha256Ctx (definition)\n  - To determine if bytes_have can vary at run time we need the exact declaration of the context structure. The struct tells us which members exist and their types/qualifiers; in particular we need to inspect the 'count' and 'buffer' members.\n\n- ctx->count (member type and qualifiers)\n  - The computation bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1)) depends on the type, width, signedness and any qualifiers (e.g. volatile) of count. If count has a type or qualifier that makes the & result constant (for example if the type is narrower than the mask or count is a compile-time constant or a volatile/constant semantic), the if (0 != bytes_have) controlling expression could be invariant. Knowing the exact type/qualifiers is required.\n\n- ctx->buffer (member type)\n  - While buffer\u2019s type does not usually affect invariance of conditions, its type determines pointer arithmetic and whether memcpy arguments are well-formed; include it because the bytes_have offset calculation and the memcpy call interplay with the branch that is guarded by a controlling expression (if (0 != bytes_have)). Understanding buffer typing helps confirm whether the branch is meaningful or effectively inert.\n\n- MHD_FAVOR_SMALL_CODE (preprocessor symbol)\n  - The early if (0 == length) return; is conditionally compiled depending on this macro. To decide whether that controlling expression must be analyzed for invariance you must know whether the macro is defined in the build being checked.\n\n- mhd_assert (macro definition)\n  - The file calls mhd_assert((data != NULL) || (length == 0)). If mhd_assert expands to a runtime check, that controlling expression exists in the compiled code and must be checked for invariance; if it expands to nothing or a compile-time-only construct, the expression may be absent. Knowing the exact macro expansion (and whether it introduces other control flow) is necessary to determine which controlling expressions are present and whether they are invariant."
}