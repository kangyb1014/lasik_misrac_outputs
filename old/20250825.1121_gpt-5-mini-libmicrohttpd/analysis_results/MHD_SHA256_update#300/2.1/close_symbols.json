{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_FAVOR_SMALL_CODE",
    "mhd_assert",
    "NDEBUG",
    "SHA256_BLOCK_SIZE",
    "struct Sha256Ctx",
    "digest_update",
    "digest_update_str",
    "digest_update_with_colon",
    "calculate_nonce",
    "calc_userdigest",
    "calc_userhash",
    "digest_auth_check_all_inner",
    "sha256_transform"
  ],
  "explanation": "To determine whether any code in MHD_SHA256_update is unreachable you must know: \n\n- MHD_FAVOR_SMALL_CODE: this preprocessor macro controls whether the early \"if (0 == length) return;\" is compiled. If defined/undefined changes presence/absence of that branch (compiled-out code could be reported as unreachable). \n\n- mhd_assert: the behavior of this assertion (macro or function) matters. If it aborts on failure the subsequent code paths may be unreachable for some inputs; if it is a no-op the function proceeds. \n\n- NDEBUG: mhd_assert is often conditional on NDEBUG; the assert semantics (compiled-in vs removed) affect reachability. Include to resolve mhd_assert behavior. \n\n- SHA256_BLOCK_SIZE: the numeric block size is required to reason about the arithmetic and conditions ((ctx->count & (SHA256_BLOCK_SIZE-1)), comparisons against SHA256_BLOCK_SIZE, bytes_left, and the while loop). Particular values (e.g. 0 or 1) could make branches or loops unreachable or infinite. \n\n- struct Sha256Ctx: full definition (types and semantics of ctx->count, ctx->buffer, ctx->H) is needed to determine possible values of bytes_have and whether expressions like ctx->count & (SHA256_BLOCK_SIZE-1) can produce only a single value (which could make some branches dead) and to verify pointer buffering behavior. \n\n- digest_update and its callers (digest_update_str, digest_update_with_colon, calculate_nonce, calc_userdigest, calc_userhash, digest_auth_check_all_inner): to establish the actual call sites and argument patterns for MHD_SHA256_update in the project. If every call always passes length==0 or never passes data==NULL, some branches could be provably unreachable at project-level. You must inspect the callers to see which argument combinations occur. \n\n- sha256_transform: while not required to inspect low-level transform logic, its signature/behavior matters if it can, for example, not return (longjmp/abort) or have side-effects that affect later code reachability; include to rule out such effects. \n\nThese symbols together let an analyzer determine (1) which portions of the code are actually compiled, (2) what value ranges are possible for the key branching expressions, and (3) what argument combinations occur in practice \u2014 all necessary to decide whether any part of MHD_SHA256_update is unreachable per MISRA."
}