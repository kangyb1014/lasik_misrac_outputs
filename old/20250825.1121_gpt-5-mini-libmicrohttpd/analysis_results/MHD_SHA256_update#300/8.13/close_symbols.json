{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_update': {'callees': ['sha256_transform'], 'callers': ['digest_update']}, 'sha256_transform': {'callees': ['__builtin_rotateright32', '__builtin_bswap32'], 'callers': ['MHD_SHA256_update', 'MHD_SHA256_finish']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx (full definition, including types of members count, buffer and H)",
    "sha256_transform (function prototype/signature)",
    "SHA256_BLOCK_SIZE (macro)",
    "memcpy (standard prototype from <string.h>)",
    "uint8_t (typedef from <stdint.h>)",
    "size_t (typedef from <stddef.h> or <stdint.h>)",
    "mhd_assert (macro or function declaration)"
  ],
  "explanation": "- struct Sha256Ctx: Needed to know the exact types and const\u2011qualification of its members (ctx->count, ctx->buffer, ctx->H). The code writes into ctx->buffer (via memcpy) and updates ctx->count; if buffer or H were declared const, this function would be casting away const or otherwise violating the rule. Only the struct definition can answer that.\n- sha256_transform (function prototype/signature): Required to know the constness of its parameters (does it take const uint8_t * for the data argument, or non\u2011const?), and the type of H parameter. That affects whether passing ctx->buffer or ctx->H is compatible with const qualifications or forces non\u2011const pointers.\n- SHA256_BLOCK_SIZE (macro): Needed to determine buffer sizing and to confirm how buffer is used (block boundary math) and whether buffer should be const (fixed scratch buffer vs pointer to externally owned const data).\n- memcpy (standard prototype): The prototype shows that the destination is void * and the source is const void *. This matters for checking that the source (data) is correctly const and whether the destination (ctx->buffer) must be non\u2011const.\n- uint8_t (typedef): To confirm the exact pointer type used in the function signature and in casts ((uint8_t *) ctx->buffer). Verifies whether casting is removing constness or matching typedefs.\n- size_t (typedef): To fully understand the count type used for ctx->count and the length parameter; while not about const directly, exact types help determine whether any implicit casts or promotions interact with const qualification analysis.\n- mhd_assert (macro or function): Included because the function calls it with data; its definition could contain casts or checks that affect whether data is treated as const or whether the code temporarily removes const. Not strictly required in many cases, but useful to ensure no stealth const casts occur there.\n\nThese symbols let an analyst determine whether any pointer passed or stored here is declared without const where it could/should be const, whether the code casts away const, or whether writes (memcpy) target objects that are non\u2011const as required by the rule."
}