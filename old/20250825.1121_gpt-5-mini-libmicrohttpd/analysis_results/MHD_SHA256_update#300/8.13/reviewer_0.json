{
  "user_message": "An agent A claimed that the following MHD_SHA256_update code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_SHA256_update.\n```c\nvoid\nMHD_SHA256_update (struct Sha256Ctx *ctx,\n                   const uint8_t *data,\n                   size_t length)\n{\n  unsigned bytes_have; /**< Number of bytes in buffer */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA256_BLOCK_SIZE-1))\n           equals (count % SHA256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned) (ctx->count & (SHA256_BLOCK_SIZE - 1));\n  ctx->count += length;\n\n  if (0 != bytes_have)\n  {\n    unsigned bytes_left = SHA256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha256_transform (ctx->H, data);\n    data += SHA256_BLOCK_SIZE;\n    length -= SHA256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the sha256_transform function is declared to take a non-const pointer for the data parameter (e.g. void sha256_transform(uint32_t *H, uint8_t *data)), then passing 'data' (which is declared const uint8_t * in MHD_SHA256_update) discards the const qualifier. That would violate MISRA C 2023 Rule 8.13 because the pointer should point to a const-qualified type whenever possible. The fix is to declare sha256_transform to take a const-qualified data parameter (e.g. const uint8_t *data) if it does not modify the input.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct in substance. If sha256_transform is declared to take a non-const pointer (e.g. uint8_t *data) but MHD_SHA256_update has data declared as const uint8_t *, then passing data to sha256_transform would discard the const qualifier (and the compiler will normally diagnose this as passing a const-qualified pointer to a non-const parameter). MISRA C 2023 Rule 8.13 advises that pointers should point to const-qualified types whenever possible, so the sha256_transform declaration should be changed to take const uint8_t *data if the function does not modify the input. Note that the actual violation is in the sha256_transform prototype (or in an implicit/incorrect use that removes const), not in the MHD_SHA256_update definition itself; nevertheless the reported issue and the recommended fix are correct."
}