{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nsend_upgrade_required (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res =\n    MHD_create_response_from_buffer_static (strlen (UPGRADE_REQUIRED_PAGE),\n                                            (const void *)\n                                            UPGRADE_REQUIRED_PAGE);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION,\n                               WS_SEC_WEBSOCKET_VERSION))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_UPGRADE_REQUIRED, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_upgrade_required': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': ['ahc_cb']}, 'MHD_create_response_from_buffer_static': {'callees': ['MHD_create_response_from_buffer_with_free_callback_cls'], 'callers': ['transmit_error_response_len', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'not_found_page', 'create_response', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'create_response_object', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_create_response_from_buffer_static",
    "MHD_create_response_from_buffer_with_free_callback_cls",
    "MHD_add_response_header",
    "MHD_str_equal_caseless_",
    "add_response_entry",
    "add_response_header_connection",
    "MHD_get_response_element_n_",
    "MHD_destroy_response",
    "MHD_queue_response",
    "enum MHD_Result",
    "MHD_YES",
    "MHD_NO",
    "struct MHD_Connection",
    "struct MHD_Response",
    "UPGRADE_REQUIRED_PAGE",
    "WS_SEC_WEBSOCKET_VERSION",
    "MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION",
    "MHD_HTTP_UPGRADE_REQUIRED",
    "strlen"
  ],
  "explanation": "For MISRA rule checking of language extensions, you must inspect any called symbol that might be a macro, inline function, or otherwise implemented using compiler-specific extensions. The listed symbols are required because:\n\n- MHD_create_response_from_buffer_static: may be a macro wrapper or use GCC extensions (statement-expression, typeof, attributes). Need its full definition to detect extensions.\n- MHD_create_response_from_buffer_with_free_callback_cls: the static variant may expand to or call this; inspect its definition for extensions.\n- MHD_add_response_header: could be a macro or inline function that uses extensions; examine its definition.\n- MHD_str_equal_caseless_, add_response_entry, add_response_header_connection, MHD_get_response_element_n_: these are internal callees/expansion targets of MHD_add_response_header per the call graph. If MHD_add_response_header is a macro or thin wrapper, these subordinate symbols must be checked for extensions as well.\n- MHD_destroy_response: may be implemented as a macro/inline/attribute-bearing function; its definition must be checked.\n- MHD_queue_response: same rationale \u2014 could hide compiler extensions in its implementation.\n- enum MHD_Result, MHD_YES, MHD_NO: the return type and these constants/macros determine comparisons and returns. They may be implemented via macros or nonstandard enum tricks; inspect their declarations for extensions.\n- struct MHD_Connection, struct MHD_Response: type definitions could use compiler extensions (packed/attribute pragmas, flexible-array members, anonymous/unnamed fields, GCC extensions). Their full definitions are needed to be sure the target function does not rely on extensions.\n- UPGRADE_REQUIRED_PAGE: typically a macro or constant string; it might be built with GCC extensions (statement-expression, compound literals, asm labels). Inspect its definition.\n- WS_SEC_WEBSOCKET_VERSION, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION, MHD_HTTP_UPGRADE_REQUIRED: header/value macros used in MHD_add_response_header and MHD_queue_response \u2014 need their definitions to ensure no extension usage.\n- strlen: standard function prototype from <string.h> is needed only to confirm standard usage; include it to verify no local macro redefinition or extension-wrapped variant is in scope.\n\nIn short: any callee, type, macro or constant used directly (and the likely internal symbols those macros expand to) must be examined because language extensions are typically hidden in macro/inline/function definitions rather than at the call site. The above minimal set lets the next analyst inspect the actual implementations/declarations for use of compiler-specific extensions."
}