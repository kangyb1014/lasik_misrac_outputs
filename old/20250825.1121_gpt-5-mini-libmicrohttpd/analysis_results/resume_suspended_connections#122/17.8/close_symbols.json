{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nresume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev = NULL;\n  enum MHD_Result ret;\n  const bool used_thr_p_c = (0 != (daemon->options\n                                   & MHD_USE_THREAD_PER_CONNECTION));\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert (NULL == daemon->worker_pool);\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n#endif\n\n  ret = MHD_NO;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n\n  if (daemon->resuming)\n  {\n    prev = daemon->suspended_connections_tail;\n    /* During shutdown check for resuming is forced. */\n    mhd_assert ((NULL != prev) || (daemon->shutdown) || \\\n                (0 != (daemon->options & MHD_ALLOW_UPGRADE)));\n  }\n\n  daemon->resuming = false;\n\n  while (NULL != (pos = prev))\n  {\n#ifdef UPGRADE_SUPPORT\n    struct MHD_UpgradeResponseHandle *const urh = pos->urh;\n#else  /* ! UPGRADE_SUPPORT */\n    static const void *const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n    prev = pos->prev;\n    if ( (! pos->resuming)\n#ifdef UPGRADE_SUPPORT\n         || ( (NULL != urh) &&\n              ( (! urh->was_closed) ||\n                (! urh->clean_ready) ) )\n#endif /* UPGRADE_SUPPORT */\n         )\n      continue;\n    ret = MHD_YES;\n    mhd_assert (pos->suspended);\n    DLL_remove (daemon->suspended_connections_head,\n                daemon->suspended_connections_tail,\n                pos);\n    pos->suspended = false;\n    if (NULL == urh)\n    {\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  pos);\n      if (! used_thr_p_c)\n      {\n        /* Reset timeout timer on resume. */\n        if (0 != pos->connection_timeout_ms)\n          pos->last_activity = MHD_monotonic_msec_counter ();\n\n        if (pos->connection_timeout_ms == daemon->connection_timeout_ms)\n          XDLL_insert (daemon->normal_timeout_head,\n                       daemon->normal_timeout_tail,\n                       pos);\n        else\n          XDLL_insert (daemon->manual_timeout_head,\n                       daemon->manual_timeout_tail,\n                       pos);\n      }\n#ifdef EPOLL_SUPPORT\n      if (MHD_D_IS_USING_EPOLL_ (daemon))\n      {\n        if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n          MHD_PANIC (\"Resumed connection was already in EREADY set.\\n\");\n        /* we always mark resumed connections as ready, as we\n           might have missed the edge poll event during suspension */\n        EDLL_insert (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL   \\\n                            | MHD_EPOLL_STATE_READ_READY\n                            | MHD_EPOLL_STATE_WRITE_READY;\n        pos->epoll_state &= ~((enum MHD_EpollState) MHD_EPOLL_STATE_SUSPENDED);\n      }\n#endif\n    }\n#ifdef UPGRADE_SUPPORT\n    else\n    {\n      /* Data forwarding was finished (for TLS connections) AND\n       * application was closed upgraded connection.\n       * Insert connection into cleanup list. */\n\n      if ( (NULL != daemon->notify_completed) &&\n           (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon)) &&\n           (pos->rq.client_aware) )\n      {\n        daemon->notify_completed (daemon->notify_completed_cls,\n                                  pos,\n                                  &pos->rq.client_context,\n                                  MHD_REQUEST_TERMINATED_COMPLETED_OK);\n        pos->rq.client_aware = false;\n      }\n      DLL_insert (daemon->cleanup_head,\n                  daemon->cleanup_tail,\n                  pos);\n      daemon->data_already_pending = true;\n    }\n#endif /* UPGRADE_SUPPORT */\n    pos->resuming = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  if ( (used_thr_p_c) &&\n       (MHD_NO != ret) )\n  {   /* Wake up suspended connections. */\n    if (! MHD_itc_activate_ (daemon->itc,\n                             \"w\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal resume of connection via \" \\\n                   \"inter-thread communication channel.\\n\"));\n#endif\n    }\n  }\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, '__builtin_unreachable': {'callees': [], 'callers': ['try_ready_normal_body', 'try_ready_chunked_body', 'process_request_body', 'MHD_update_last_activity_', 'MHD_connection_handle_write', 'cleanup_connection', 'MHD_connection_handle_idle', 'MHD_set_connection_option', 'MHD_ip_count_lock', 'MHD_ip_count_unlock', 'MHD_ip_limit_del', 'new_connection_prepare_', 'new_connection_close_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'internal_suspend_connection_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_cleanup_connections', 'MHD_epoll', 'close_connection', 'MHD_quiesce_daemon', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_stop_daemon', 'MHD_create_response_from_iovec', 'MHD_destroy_response', 'MHD_increment_response_rc', 'MHD_create_post_processor', 'post_process_urlencoded', 'post_process_multipart', 'check_nonce_nc', 'calculate_add_nonce', 'digest_auth_check_all_inner', 'MHD_digest_auth_check_digest3', 'MHD_digest_auth_check2', 'MHD_digest_auth_check_digest2', 'queue_auth_required_response3_inner', 'MHD_queue_auth_fail_response2']}, 'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_run_from_select2': {'callees': ['MHD_DLOG', 'MHD_epoll', 'MHD_cleanup_connections', 'resume_suspended_connections', 'internal_run_from_select'], 'callers': ['MHD_run_from_select']}, 'MHD_select': {'callees': ['resume_suspended_connections', 'internal_get_fdset2', 'MHD_DLOG', 'MHD_add_to_fd_set_', 'MHD_get_timeout64', 'internal_run_from_select'], 'callers': ['MHD_run_wait', 'MHD_polling_thread']}, 'MHD_poll_all': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'call_handlers'], 'callers': ['MHD_poll', 'MHD_run_wait']}, 'MHD_poll_listen_socket': {'callees': ['resume_suspended_connections', 'MHD_DLOG', 'new_connections_list_process_', 'MHD_accept_connection'], 'callers': ['MHD_poll']}, 'MHD_epoll': {'callees': ['MHD_DLOG', '__builtin_unreachable', 'resume_suspended_connections', 'get_timeout_millisec_int', 'new_connections_list_process_', 'MHD_accept_connection', 'MHD_connection_handle_idle', 'call_handlers'], 'callers': ['MHD_run_from_select2', 'MHD_run_wait', 'MHD_polling_thread']}, 'MHD_polling_thread': {'callees': ['MHD_DLOG', 'MHD_poll', 'MHD_epoll', 'MHD_select', 'MHD_cleanup_connections', 'resume_suspended_connections', 'close_all_connections'], 'callers': []}, 'close_all_connections': {'callees': ['__builtin_unreachable', 'new_connection_close_', 'resume_suspended_connections', 'MHD_DLOG', 'close_connection', 'MHD_cleanup_connections'], 'callers': ['MHD_polling_thread', 'MHD_stop_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Daemon",
    "struct MHD_Connection",
    "struct MHD_UpgradeResponseHandle",
    "enum MHD_Result",
    "enum MHD_EpollState",
    "mhd_assert",
    "MHD_mutex_lock_chk_",
    "MHD_mutex_unlock_chk_",
    "DLL_remove",
    "DLL_insert",
    "XDLL_insert",
    "EDLL_insert",
    "MHD_monotonic_msec_counter",
    "MHD_itc_activate_",
    "MHD_DLOG",
    "MHD_PANIC",
    "MHD_D_IS_USING_EPOLL_",
    "MHD_D_IS_USING_THREAD_PER_CONN_",
    "MHD_thread_handle_ID_is_current_thread_",
    "MHD_USE_THREAD_PER_CONNECTION",
    "UPGRADE_SUPPORT",
    "EPOLL_SUPPORT",
    "MHD_USE_POSIX_THREADS",
    "MHD_USE_W32_THREADS"
  ],
  "explanation": "You must be able to see macro/function expansions and the daemon/connection type layouts to prove the function parameter (the pointer variable 'daemon') is not being modified. Concretely:\n- struct MHD_Daemon: needed to know which accesses are writes to the pointed-to object (allowed) versus any possible assignment to the parameter itself.\n- struct MHD_Connection: required to understand member writes (pos->...) performed inside the function.\n- struct MHD_UpgradeResponseHandle: to interpret urh uses/fields and decide whether operations touch the parameter.\n- enum MHD_Result: return values (MHD_NO/MHD_YES) used by the function.\n- enum MHD_EpollState: epoll-state bit manipulations show member updates (not pointer reassignments).\n- mhd_assert: macro may expand to code that could reference/modify its argument; need its expansion to be sure it does not assign to the parameter.\n- MHD_mutex_lock_chk_, MHD_mutex_unlock_chk_: macros/functions called with &daemon->cleanup_connection_mutex \u2014 need their definitions to ensure they do not perform assignments to the local parameter variable.\n- DLL_remove, DLL_insert, XDLL_insert, EDLL_insert: list-manipulation macros/functions that take daemon->... heads/tails and pos; inspect their expansions to confirm they modify daemon->members (permitted) and do not reassign the local pointer parameter.\n- MHD_monotonic_msec_counter: called to set pos->last_activity; include for completeness to inspect side effects (should not modify parameter pointer).\n- MHD_itc_activate_: called with daemon->itc; include to ensure it cannot reassign the function parameter via some macro/trick.\n- MHD_DLOG, MHD_PANIC: logging/panic macros may expand to complex code; need to verify they do not assign to the parameter variable.\n- MHD_D_IS_USING_EPOLL_, MHD_D_IS_USING_THREAD_PER_CONN_, MHD_thread_handle_ID_is_current_thread_: macros/functions that test daemon state \u2014 their expansions could use or (unlikely) assign the parameter; must check.\n- MHD_USE_THREAD_PER_CONNECTION, UPGRADE_SUPPORT, EPOLL_SUPPORT, MHD_USE_POSIX_THREADS, MHD_USE_W32_THREADS: compile-time flags that change which code is present; the exact compiled code must be known to conclude whether the parameter is modified.\n\nWith these symbols (type definitions and macro/function bodies/flags) the next analyser can (1) expand all macro calls to ensure no macro assigns to the local parameter variable, and (2) confirm all modifications are to members of *daemon or to other local variables (allowed by MISRA) rather than reassignments to the parameter pointer itself."
}