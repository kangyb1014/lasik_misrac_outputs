{
  "user_message": "Target function code is:\n```c\nbool\nMHD_str_remove_tokens_caseless_ (char *str,\n                                 size_t *str_len,\n                                 const char *const tokens,\n                                 const size_t tokens_len)\n{\n  const char *const t = tokens;   /**< a short alias for @a tokens */\n  size_t pt;                      /**< position in @a tokens */\n  bool token_removed;\n\n  mhd_assert (NULL == memchr (tokens, 0, tokens_len));\n\n  token_removed = false;\n  pt = 0;\n\n  while (pt < tokens_len && *str_len != 0)\n  {\n    const char *tkn; /**< the current token */\n    size_t tkn_len;\n\n    /* Skip any initial whitespaces and empty tokens in 'tokens' */\n    while ( (pt < tokens_len) &&\n            ((' ' == t[pt]) || ('\\t' == t[pt]) || (',' == t[pt])) )\n      pt++;\n\n    if (pt >= tokens_len)\n      break; /* No more tokens, nothing to remove */\n\n    /* Found non-whitespace char which is not a comma */\n    tkn = t + pt;\n    do\n    {\n      do\n      {\n        pt++;\n      } while (pt < tokens_len &&\n               (' ' != t[pt] && '\\t' != t[pt] && ',' != t[pt]));\n      /* Found end of the token string, space, tab, or comma */\n      tkn_len = pt - (size_t) (tkn - t);\n\n      /* Skip all spaces and tabs */\n      while (pt < tokens_len && (' ' == t[pt] || '\\t' == t[pt]))\n        pt++;\n      /* Found end of the token string or non-whitespace char */\n    } while (pt < tokens_len && ',' != t[pt]);\n\n    /* 'tkn' is the input token with 'tkn_len' chars */\n    mhd_assert (0 != tkn_len);\n\n    if (*str_len == tkn_len)\n    {\n      if (MHD_str_equal_caseless_bin_n_ (str, tkn, tkn_len))\n      {\n        *str_len = 0;\n        token_removed = true;\n      }\n      continue;\n    }\n    /* 'tkn' cannot match part of 'str' if length of 'tkn' is larger\n     * than length of 'str'.\n     * It's know that 'tkn' is not equal to the 'str' (was checked previously).\n     * As 'str' is normalized when 'tkn' is not equal to the 'str'\n     * it is required that 'str' to be at least 3 chars larger then 'tkn'\n     * (the comma, the space and at least one additional character for the next\n     * token) to remove 'tkn' from the 'str'. */\n    if (*str_len > tkn_len + 2)\n    { /* Remove 'tkn' from the input string */\n      size_t pr;    /**< the 'read' position in the @a str */\n      size_t pw;    /**< the 'write' position in the @a str */\n\n      pr = 0;\n      pw = 0;\n\n      do\n      {\n        mhd_assert (pr >= pw);\n        mhd_assert ((*str_len) >= (pr + tkn_len));\n        if ( ( ((*str_len) == (pr + tkn_len)) || (',' == str[pr + tkn_len]) ) &&\n             MHD_str_equal_caseless_bin_n_ (str + pr, tkn, tkn_len) )\n        {\n          /* current token in the input string matches the 'tkn', skip it */\n          mhd_assert ((*str_len == pr + tkn_len) || \\\n                      (' ' == str[pr + tkn_len + 1])); /* 'str' must be normalized */\n          token_removed = true;\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += tkn_len + 2;\n        }\n        else\n        {\n          /* current token in the input string does not match the 'tkn',\n           * copy to the output */\n          if (0 != pw)\n          { /* not the first output token, add \", \" to separate */\n            if (pr != pw + 2)\n            {\n              str[pw++] = ',';\n              str[pw++] = ' ';\n            }\n            else\n              pw += 2; /* 'str' is not yet modified in this round */\n          }\n          do\n          {\n            if (pr != pw)\n              str[pw] = str[pr];\n            pr++;\n            pw++;\n          } while (pr < *str_len && ',' != str[pr]);\n          /* Advance to the next token in the input string or beyond\n           * the end of the input string. */\n          pr += 2;\n        }\n        /* 'pr' should point to the next token in the input string or beyond\n         * the end of the input string */\n        if ((*str_len) < (pr + tkn_len))\n        { /* The rest of the 'str + pr' is too small to match 'tkn' */\n          if ((*str_len) > pr)\n          { /* Copy the rest of the string */\n            size_t copy_size;\n            copy_size = *str_len - pr;\n            if (0 != pw)\n            { /* not the first output token, add \", \" to separate */\n              if (pr != pw + 2)\n              {\n                str[pw++] = ',';\n                str[pw++] = ' ';\n              }\n              else\n                pw += 2; /* 'str' is not yet modified in this round */\n            }\n            if (pr != pw)\n              memmove (str + pw, str + pr, copy_size);\n            pw += copy_size;\n          }\n          *str_len = pw;\n          break;\n        }\n        mhd_assert ((' ' != str[0]) && ('\\t' != str[0]));\n        mhd_assert ((0 == pr) || (3 <= pr));\n        mhd_assert ((0 == pr) || (' ' == str[pr - 1]));\n        mhd_assert ((0 == pr) || (',' == str[pr - 2]));\n      } while (1);\n    }\n  }\n\n  return token_removed;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert (macro/implementation) [+ any build config that affects it, e.g. NDEBUG]",
    "memchr (implementation/wrapper used in this project)",
    "MHD_str_equal_caseless_bin_n_ (declaration + implementation)",
    "memmove (implementation/wrapper used in this project)",
    "Call sites of MHD_str_remove_tokens_caseless_ (all functions that invoke it)",
    "Caller-visible contract / preconditions for MHD_str_remove_tokens_caseless_ (\"normalization\" invariant for 'str' and 'str_len')"
  ],
  "explanation": "Explain why each symbol is required for dead\u2011code analysis\n\n1) mhd_assert (macro/implementation) and its build configuration (e.g. NDEBUG):\n   - The function invokes memchr inside mhd_assert: mhd_assert (NULL == memchr (tokens, 0, tokens_len)); whether that memchr call is actually executed depends on how mhd_assert is implemented (asserting macro that may evaluate its argument only in debug builds, or a function that always evaluates). To decide if the memchr call (and thus the entire assert line) is dead code you must know the exact mhd_assert definition and build-time switches that enable/disable it.\n\n2) memchr (implementation/wrapper used in this project):\n   - Even if mhd_assert evaluates its argument, the exact semantics (side effects, special wrappers) could matter. Knowing memchr behaviour confirms that the assert does not do anything else that could affect program behaviour; if memchr is a wrapper with side effects, the call may not be removable.\n\n3) MHD_str_equal_caseless_bin_n_ (declaration + implementation):\n   - This helper is used in multiple conditional branches to decide whether tokens match parts of str. Its truth table (pure boolean, side effects, possible early exits) directly affects which branches of the function are executed. To determine whether assignments/branches in the target function are dead (never taken, or never influence external state), you must know the exact behaviour and possible return values of this function for relevant inputs.\n\n4) memmove (implementation/wrapper used in this project):\n   - The function conditionally calls memmove to copy tail data. If memmove is a no-op in some builds or has nonstandard semantics/wrappers, the code that computes copy_size and calls memmove may or may not have an effect. To judge whether that block is removable without changing program behaviour you need its actual implementation/semantics.\n\n5) Call sites of MHD_str_remove_tokens_caseless_ (all functions that invoke it):\n   - MISRA dead\u2011code is defined by effect on program behaviour. Whether some operations in this function (for example assignments to token_removed, updates to *str_len, or setting str[.] characters) are removable without changing the program depends on how callers use the return value and/or modified str/str_len. If all callers ignore the boolean return value, assignments solely affecting token_removed (but not str or *str_len) might be dead; conversely, if callers rely on the return value the assignments are live. You must inspect each caller to see which outputs are observed.\n\n6) Caller-visible contract / preconditions for MHD_str_remove_tokens_caseless_ (the \"normalization\" invariant for 'str' and 'str_len'):\n   - The function contains many assertions and comments that assume 'str' is \"normalized\" (no leading spaces, tokens formatted as \", \", etc.) and that certain length relationships hold. These preconditions can render some branches unreachable in practice (and thus dead if their bodies have no external effect), or conversely make certain checks redundant. To decide if code is dead you need the documented/guaranteed preconditions (or the function(s) that ensure normalization) so you can determine which internal branches are actually possible when the function is used in the system.\n\nSummary: to judge dead code you need the exact definitions/semantics of the assertion macro and the three called functions (memchr, MHD_str_equal_caseless_bin_n_, memmove), the callers (to see which outputs matter), and the formal caller contract (normalization invariants). These symbols determine which expressions are actually evaluated, which branches can occur, and whether side effects are observed by the rest of the program."
}