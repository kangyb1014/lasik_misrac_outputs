{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of calculate_nonce:\n```c\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function calculate_nonce:\n#define TIMESTAMP_BIN_SIZE (48/8)\n...\n#define HAVE_INET6 1\n...\nstruct MHD_HTTP_Req_Header\n{\n  /**\n   * Headers are kept in a double-linked list.\n   */\n  struct MHD_HTTP_Req_Header *next;\n\n  /**\n   * Headers are kept in a double-linked list.\n   */\n  struct MHD_HTTP_Req_Header *prev;\n\n  /**\n   * The name of the header (key), without the colon.\n   */\n  const char *header;\n\n  /**\n   * The length of the @a header, not including the final zero termination.\n   */\n  size_t header_size;\n\n  /**\n   * The value of the header.\n   */\n  const char *value;\n\n  /**\n   * The length of the @a value, not including the final zero termination.\n   */\n  size_t value_size;\n\n  /**\n   * Type of the value.\n   */\n  enum MHD_ValueKind kind;\n\n}\n...\n\n...\n\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define MAX_DIGEST SHA512_256_DIGEST_SIZE\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }",
    "#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */",
    "if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }"
  ],
  "explanation": "I flagged constructs that introduce constant compile-time conditions or compile-time inclusion/exclusion that commonly cause unreachable code and therefore deserve inspection for MISRA Rule 2.1. Specifically:\n\n- The two \"if (1) { ... }\" blocks are constant-true conditionals; constant conditions can mask unreachable branches or indicate dead code patterns and should be reviewed. Even though the code inside is executed, the use of literal true conditions is worth investigation to ensure no unconditional/guarded code elsewhere is unreachable.\n\n- The #ifdef HAVE_INET6 / else-if(AF_INET6...) block is a compile-time conditional that changes which code is present in a given build configuration; such preprocessor guards can make branches unreachable in particular configurations and should be checked across configurations.\n\nOther conditional fragments in the function were not selected because they are dependent on runtime values or on macros/constants given in the additional code (and thus are not statically unreachable in the provided configuration). Examples include:\n\n- The TIMESTAMP_BIN_SIZE preprocessor check resolves to 6 given TIMESTAMP_BIN_SIZE (48/8) in the provided definitions; it does not produce unreachable code here (it produces a compile-time error if mismatched).\n\n- All checks involving bind_options, saddr_size, mthd_e, first_header, and similar values depend on parameters passed at run-time; their branches can be taken depending on inputs, so they are not statically unreachable.\n\n- The mhd_assert macro expands to ((void)0) per the provided definition; while it becomes a no-op, it does not create unreachable code in this function.\n\nIf you want, I can run a more exhaustive symbolic/constant evaluation (given any additional macro/constant values) to identify other statically unreachable branches across different build configurations."
}