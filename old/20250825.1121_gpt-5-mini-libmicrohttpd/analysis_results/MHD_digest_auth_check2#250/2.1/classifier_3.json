{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_digest_auth_check2:\n```c\n_MHD_EXTERN int\nMHD_digest_auth_check2 (struct MHD_Connection *connection,\n                        const char *realm,\n                        const char *username,\n                        const char *password,\n                        unsigned int nonce_timeout,\n                        enum MHD_DigestAuthAlgorithm algo)\n{\n  enum MHD_DigestAuthResult res;\n  enum MHD_DigestAuthMultiAlgo3 malgo3;\n\n  if (MHD_DIGEST_ALG_AUTO == algo)\n    malgo3 = MHD_DIGEST_AUTH_MULT_ALGO3_ANY_NON_SESSION;\n  else if (MHD_DIGEST_ALG_MD5 == algo)\n    malgo3 = MHD_DIGEST_AUTH_MULT_ALGO3_MD5;\n  else if (MHD_DIGEST_ALG_SHA256 == algo)\n    malgo3 = MHD_DIGEST_AUTH_MULT_ALGO3_SHA256;\n  else\n    MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n\n  res = MHD_digest_auth_check3 (connection,\n                                realm,\n                                username,\n                                password,\n                                nonce_timeout,\n                                0, MHD_DIGEST_AUTH_MULT_QOP_AUTH,\n                                malgo3);\n  if (MHD_DAUTH_OK == res)\n    return MHD_YES;\n  else if ((MHD_DAUTH_NONCE_STALE == res) || (MHD_DAUTH_NONCE_WRONG == res) ||\n           (MHD_DAUTH_NONCE_OTHER_COND == res) )\n    return MHD_INVALID_NONCE;\n  return MHD_NO;\n\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_digest_auth_check2:\nenum MHD_DigestAuthAlgorithm\n{\n\n  /**\n   * MHD should pick (currently defaults to MD5).\n   */\n  MHD_DIGEST_ALG_AUTO = 0,\n\n  /**\n   * Force use of MD5.\n   */\n  MHD_DIGEST_ALG_MD5,\n\n  /**\n   * Force use of SHA-256.\n   */\n  MHD_DIGEST_ALG_SHA256\n\n}\n...\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n...\n_MHD_EXTERN enum MHD_DigestAuthResult\nMHD_digest_auth_check3 (struct MHD_Connection *connection,\n                        const char *realm,\n                        const char *username,\n                        const char *password,\n                        unsigned int nonce_timeout,\n                        uint32_t max_nc,\n                        enum MHD_DigestAuthMultiQOP mqop,\n                        enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  mhd_assert (NULL != password);\n\n  return digest_auth_check_all (connection,\n                                realm,\n                                username,\n                                password,\n                                NULL,\n                                nonce_timeout,\n                                max_nc,\n                                mqop,\n                                malgo3);\n}\n...\nenum MHD_DigestAuthResult\n{\n  /**\n   * Authentication OK.\n   */\n  MHD_DAUTH_OK = 1,\n\n  /**\n   * General error, like \"out of memory\".\n   */\n  MHD_DAUTH_ERROR = 0,\n\n  /**\n   * No \"Authorization\" header or wrong format of the header.\n   * Also may be returned if required parameters in client Authorisation header\n   * are missing or broken (in invalid format).\n   */\n  MHD_DAUTH_WRONG_HEADER = -1,\n\n  /**\n   * Wrong 'username'.\n   */\n  MHD_DAUTH_WRONG_USERNAME = -2,\n\n  /**\n   * Wrong 'realm'.\n   */\n  MHD_DAUTH_WRONG_REALM = -3,\n\n  /**\n   * Wrong 'URI' (or URI parameters).\n   */\n  MHD_DAUTH_WRONG_URI = -4,\n\n  /**\n   * Wrong 'qop'.\n   */\n  MHD_DAUTH_WRONG_QOP = -5,\n\n  /**\n   * Wrong 'algorithm'.\n   */\n  MHD_DAUTH_WRONG_ALGO = -6,\n\n  /**\n   * Too large (>64 KiB) Authorization parameter value.\n   */\n  MHD_DAUTH_TOO_LARGE = -15,\n\n  /* The different form of naming is intentionally used for the results below,\n   * as they are more important */\n\n  /**\n   * The 'nonce' is too old. Suggest the client to retry with the same\n   * username and password to get the fresh 'nonce'.\n   * The validity of the 'nonce' may be not checked.\n   */\n  MHD_DAUTH_NONCE_STALE = -17,\n\n  /**\n   * The 'nonce' was generated by MHD for other conditions.\n   * This value is only returned if #MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE\n   * is set to anything other than #MHD_DAUTH_BIND_NONCE_NONE.\n   * The interpretation of this code could be different. For example, if\n   * #MHD_DAUTH_BIND_NONCE_URI is set and client just used the same 'nonce' for\n   * another URI, the code could be handled as #MHD_DAUTH_NONCE_STALE as\n   * RFCs allow nonces re-using for other URIs in the same \"protection\n   * space\". However, if only #MHD_DAUTH_BIND_NONCE_CLIENT_IP bit is set and\n   * it is know that clients have fixed IP addresses, this return code could\n   * be handled like #MHD_DAUTH_NONCE_WRONG.\n   */\n  MHD_DAUTH_NONCE_OTHER_COND = -18,\n\n  /**\n   * The 'nonce' is wrong. May indicate an attack attempt.\n   */\n  MHD_DAUTH_NONCE_WRONG = -33,\n\n  /**\n   * The 'response' is wrong. Typically it means that wrong password used.\n   * May indicate an attack attempt.\n   */\n  MHD_DAUTH_RESPONSE_WRONG = -34\n}\n...\n#define MHD_INVALID_NONCE -1\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nelse MHD_PANIC (_ (\"Wrong 'algo' value, API violation\"));\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the else branch handles unexpected 'algo' values by calling MHD_PANIC which invokes a panic routine and uses BUILTIN_NOT_REACHED to indicate the call does not return. This is an intentional abort path, not unreachable code elsewhere in the project. All normal control paths (AUTO/MD5/SHA256) continue to the subsequent code, so there is no unreachable code introduced by this fragment."
}