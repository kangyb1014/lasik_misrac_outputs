{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. If *dest_size + have overflows size_t the code can allocate a smaller buffer than expected and then memcpy will write past the allocated object. Example: suppose *dest_size == SIZE_MAX - 100 and have == 200. After '*dest_size += have' the value wraps (e.g. becomes 99). realloc(*dest, *dest_size) may succeed and return a buffer of length 99, but memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) will attempt to copy 200 bytes starting at an offset that underflows (99 - 200), causing writes beyond the bounds of *dest. This violates MISRA C 2023 Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function compress_buf:\n#define CHUNK 16384\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code does unchecked addition of have into *dest_size and then reallocates using the (potentially wrapped) value, then memcpy's have bytes at an offset computed as (*dest_size - have). If size_t overflow occurs in '*dest_size += have' (i.e. *dest_size > SIZE_MAX - have), the addition will wrap to a small value, realloc may succeed returning a buffer of that smaller size, and the subsequent memcpy will copy have bytes starting at an offset that no longer equals the previous allocation size \u2014 causing writes beyond the bounds of the allocated object. That is exactly the kind of out-of-bounds access of memcpy forbidden by MISRA C 2023 Rule 21.17.\n\nNote: setting '*dest_size = 0' at the start does not prevent a later overflow after many iterations; the incremental adds by have (<= CHUNK) can eventually overflow. The safe fix is to test for overflow before the addition (e.g. if (*dest_size > SIZE_MAX - have) handle error) or otherwise ensure the requested realloc size is computed and validated before calling realloc and memcpy."
}