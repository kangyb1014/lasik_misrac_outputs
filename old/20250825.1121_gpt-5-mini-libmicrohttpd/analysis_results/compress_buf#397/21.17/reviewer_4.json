{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIf the caller supplies a tmp buffer smaller than the CHUNK (16384) bytes used as the zlib output buffer, memcpy may read beyond the tmp buffer. Example: caller passes tmp pointing to a 1024\u2011byte buffer; the code sets strm->avail_out = CHUNK and deflate may write have up to CHUNK (16384) bytes into tmp, so memcpy(..., tmp, have) will read up to 16384 bytes from tmp and thus access memory beyond the tmp object.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function compress_buf:\n#define CHUNK 16384\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. compress_buf sets strm->avail_out = CHUNK and strm->next_out = tmp, then calls deflate which may write up to CHUNK bytes into the buffer pointed to by tmp. The code then does memcpy(dest + offset, tmp, have) where have can be as large as CHUNK. There is no size parameter or check on tmp in the function, so if the caller supplies a tmp buffer smaller than CHUNK the memcpy will read beyond the bounds of tmp (and deflate itself may have written beyond tmp). That behaviour violates MISRA C 2023 Rule 21.17 unless an external invariant (tmp is guaranteed to be at least CHUNK bytes) is documented and enforced; no such guarantee exists in the function signature or body, so the reported violation stands."
}