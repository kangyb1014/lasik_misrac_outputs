{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe assignment sets zlib's output pointer to tmp and the code then sets avail_out = CHUNK and later does memcpy(tmp_source, ...) copying 'have' bytes (where have \u2264 CHUNK). If the caller supplies tmp that is smaller than CHUNK (or smaller than the actual 'have' value produced by deflate), memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) will read beyond tmp's bounds. Thus, assigning strm->next_out = tmp without guaranteeing tmp is at least CHUNK bytes can lead to out-of-bounds accesses by memcpy (a <string.h> function).\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function compress_buf:\n#define CHUNK 16384\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. compress_buf sets strm->avail_out = CHUNK and strm->next_out = tmp and then calls deflate() which may produce up to CHUNK bytes into tmp. After deflate the code does memcpy(..., tmp, have) where have = CHUNK - strm->avail_out (so 0 <= have <= CHUNK). There is no check that the caller-supplied tmp points to at least have (or CHUNK) bytes, therefore memcpy can read beyond tmp's object bounds. That use of memcpy is exactly the kind of string.h access prohibited by MISRA C 2023 Rule 21.17. To remediate, ensure tmp is documented/validated to be at least CHUNK bytes, pass the actual tmp size and set avail_out accordingly, or avoid memcpy by using a guaranteed-size buffer."
}