{
  "user_message": "An agent A claimed that the following compress_buf code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of compress_buf.\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nSetting strm->avail_out = CHUNK (16384) before calling deflate and then memcpy\u2019ing 'have' bytes from tmp assumes that tmp points to a buffer of at least CHUNK bytes. If the caller passes a smaller tmp (e.g. malloc(1024) or a smaller stack array), deflate may write up to CHUNK bytes into tmp and memcpy will copy up to CHUNK bytes from tmp, causing out\u2011of\u2011bounds accesses of tmp and violating Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function compress_buf:\n#define CHUNK 16384\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. The code calls memcpy(((uint8_t *)(*dest)) + ((*dest_size) - have), tmp, have) where have is computed as CHUNK - strm->avail_out and can be as large as CHUNK. Earlier the code sets strm->avail_out = CHUNK and strm->next_out = tmp and then calls deflate(), so the function assumes the buffer pointed to by tmp is at least CHUNK bytes. The function neither checks nor receives the size of tmp, so if a caller supplies a smaller buffer (for example malloc(1024) or a smaller stack array), deflate may write up to CHUNK bytes into tmp and memcpy will read up to CHUNK bytes from tmp, causing out\u2011of\u2011bounds accesses. That behavior violates MISRA C 2023 Rule 21.17 for use of memcpy. To fix this, the routine must ensure tmp is large enough (e.g. allocate a CHUNK-sized local buffer, or take and check a tmp_size parameter, or otherwise document and enforce the precondition)."
}