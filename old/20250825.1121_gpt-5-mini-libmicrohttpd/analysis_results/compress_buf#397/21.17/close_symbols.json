{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\ncompress_buf (z_stream *strm, const void *src, size_t src_size, size_t *offset,\n              void **dest, size_t *dest_size,\n              void *tmp)\n{\n  unsigned int have;\n  enum MHD_Result ret;\n  int flush;\n  void *tmp_dest;\n  *dest = NULL;\n  *dest_size = 0;\n  do\n  {\n    if (src_size > CHUNK)\n    {\n      strm->avail_in = CHUNK;\n      src_size -= CHUNK;\n      flush = Z_NO_FLUSH;\n    }\n    else\n    {\n      strm->avail_in = (uInt) src_size;\n      flush = Z_SYNC_FLUSH;\n    }\n    *offset += strm->avail_in;\n    strm->next_in = (const Bytef *) src;\n    do\n    {\n      strm->avail_out = CHUNK;\n      strm->next_out = tmp;\n      ret = (Z_OK == deflate (strm, flush)) ? MHD_YES : MHD_NO;\n      have = CHUNK - strm->avail_out;\n      *dest_size += have;\n      tmp_dest = realloc (*dest, *dest_size);\n      if (NULL == tmp_dest)\n      {\n        free (*dest);\n        *dest = NULL;\n        return MHD_NO;\n      }\n      *dest = tmp_dest;\n      memcpy (((uint8_t *) (*dest)) + ((*dest_size) - have), tmp, have);\n    }\n    while (0 == strm->avail_out);\n  }\n  while (flush != Z_SYNC_FLUSH);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'compress_buf': {'callees': [], 'callers': ['read_cb']}, 'read_cb': {'callees': ['compress_buf'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "CHUNK",
    "z_stream (definition: members avail_in, avail_out, next_in, next_out)",
    "Bytef",
    "uInt",
    "deflate (zlib) and its contract",
    "Z_OK",
    "Z_NO_FLUSH",
    "Z_SYNC_FLUSH",
    "read_cb (caller)",
    "tmp buffer allocation/size (in caller)",
    "realloc (semantics)",
    "memcpy (semantics)",
    "uint8_t / size_t (standard integer types)"
  ],
  "explanation": "Explanation of why each symbol is required to check memcpy bounds safety:\n\n- CHUNK\n  - The code repeatedly sets strm->avail_out = CHUNK and copies up to CHUNK bytes from tmp. To verify that the memcpy length (have) is within the allocated source (tmp) and that the destination arithmetic (*dest_size - have) is valid, the numeric value of CHUNK (or its definition) is needed.\n\n- z_stream (definition: members avail_in, avail_out, next_in, next_out)\n  - The function relies on z_stream members to determine how many bytes are produced/consumed. You must know the exact struct members and their types to reason about the values of avail_out/avail_in and the pointer next_out/next_in used with deflate and copying.\n\n- Bytef\n  - Bytef is the byte type used by zlib for next_in/next_out. Knowing its typedef ensures correct pointer casts and byte-sized copy reasoning.\n\n- uInt\n  - uInt is used for casting src_size to set avail_in. Its width and semantics affect whether avail_in can represent the requested count and therefore whether deflate will read beyond src.\n\n- deflate (zlib) and its contract\n  - You must know what deflate writes to next_out and how it updates avail_out/avail_in (i.e., it writes at most the provided output buffer size and decreases avail_out by number of bytes written). This determines the correctness of calculating have = CHUNK - strm->avail_out and whether tmp actually contains have bytes.\n\n- Z_OK\n  - Return code from deflate used in ret; required only to fully understand control-flow/return but also to ensure deflate executed normally when bytes were written.\n\n- Z_NO_FLUSH and Z_SYNC_FLUSH\n  - These control flush modes can alter deflate behaviour (how many output bytes are produced). Their meanings are needed to reason about how many bytes deflate may write for a given input chunk.\n\n- read_cb (caller)\n  - The caller supplies the tmp pointer and may set or allocate other buffers. To guarantee that tmp points to a buffer of at least CHUNK bytes (or otherwise large enough for copies of size have) you must inspect the caller (read_cb) to see how tmp is allocated and its size.\n\n- tmp buffer allocation/size (in caller)\n  - Closely related to read_cb: the actual size and lifetime of the tmp buffer passed into compress_buf is required to ensure memcpy(tmp, have) does not read beyond tmp.\n\n- realloc (semantics)\n  - The code grows *dest via realloc and uses the returned size *dest_size. To ensure the destination pointer arithmetic and length passed to memcpy are within the allocated destination buffer, you must rely on standard realloc semantics (and its behavior when *dest is NULL).\n\n- memcpy (semantics)\n  - Understanding that memcpy copies exactly the requested number of bytes and has no bounds checking means you must ensure source and destination buffers are at least that long. Its prototype helps state units are bytes.\n\n- uint8_t / size_t (standard integer types)\n  - Needed to reason about pointer arithmetic and sizes in bytes (the expression ((uint8_t *)(*dest)) + ((*dest_size) - have) and arithmetic between size_t and unsigned counts).\n\nTogether these symbols let an analyst determine (1) whether 'have' can be larger than the allocated tmp buffer, and (2) whether the computed destination offset and the destination allocation from realloc provide at least 'have' bytes at that offset before memcpy is called \u2014 the two conditions required to check the MISRA C rule about accesses beyond object bounds for memcpy."
}