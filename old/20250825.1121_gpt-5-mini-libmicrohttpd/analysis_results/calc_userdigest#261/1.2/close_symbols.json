{
  "user_message": "Target function code is:\n```c\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'calc_userdigest': {'callees': ['digest_update', 'digest_update_with_colon', 'digest_update_str', 'digest_calc_hash'], 'callers': ['MHD_digest_auth_calc_userdigest', 'digest_auth_check_all_inner']}, 'digest_update': {'callees': ['MHD_MD5_update', 'MHD_SHA256_update', 'MHD_SHA512_256_update'], 'callers': ['digest_update_str', 'digest_update_with_colon', 'calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}, 'digest_update_with_colon': {'callees': ['digest_update'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}, 'digest_update_str': {'callees': ['digest_update'], 'callers': ['calculate_nonce', 'calc_userdigest', 'digest_auth_check_all_inner']}, 'digest_calc_hash': {'callees': ['MHD_MD5_finish', 'MHD_SHA256_finish', 'MHD_SHA512_256_finish'], 'callers': ['calculate_nonce', 'calc_userdigest', 'calc_userhash', 'digest_auth_check_all_inner']}, 'MHD_digest_auth_calc_userdigest': {'callees': ['digest_init_one_time', 'get_base_digest_algo', 'digest_get_size', 'calc_userdigest'], 'callers': ['add_new_user_entry']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_static_inline",
    "mhd_assert",
    "struct DigestAlgorithm (definition)",
    "digest_update (declaration + implementation)",
    "digest_update_with_colon (declaration + implementation)",
    "digest_update_str (declaration + implementation)",
    "digest_calc_hash (declaration + implementation)"
  ],
  "explanation": "To determine whether calc_userdigest uses any compiler language extensions you must inspect the macros, types and called routines that appear directly in its definition: \n\n- _MHD_static_inline: This macro is on the function signature. It commonly expands to compiler-specific inline keywords or attributes (e.g. __inline__, __attribute__((always_inline)), __inline__ __attribute__, __extension__, etc.). You must see its definition to decide if a non\u2011standard extension is being used. \n\n- mhd_assert: The assertion macro/function could be implemented with compiler extensions (statement expressions, __builtin_expect, __attribute__ annotations, asm, or other non\u2011standard constructs). Inspecting its definition is needed to decide if an extension is introduced at the call site. \n\n- struct DigestAlgorithm (definition): calc_userdigest dereferences da->hashing. The struct definition could use implementation\u2011specific features (bit\u2011fields with non\u2011standard widths, anonymous/unnamed structs/unions, flexible array members used in a non\u2011standard way, or attributes attached to members), any of which may be language extensions. You need the full type to check for such constructs. \n\n- digest_update (declaration + implementation): Called directly from calc_userdigest. Its prototype/definition could use compiler extensions (attribute annotations, inline/extern linkage extensions, GCC/Clang builtins, or macros that expand to extensions), or it may expand to macros that invoke extension constructs (e.g. statement expressions). You must analyze the code it expands/calls to detect extensions (including the MHD_* update functions it invokes). \n\n- digest_update_with_colon (declaration + implementation): This symbol is a wrapper that calls digest_update; its implementation may contain macro tricks or extensions (macros or inline variants) that need inspection. \n\n- digest_update_str (declaration + implementation): Similar to digest_update_with_colon \u2014 its implementation/prototype may introduce extensions. \n\n- digest_calc_hash (declaration + implementation): Final hash routine called by calc_userdigest; its prototype/definition may use inline/attribute extensions or call functions/macros that do. Also inspect its use of MHD_MD5_finish / SHA finish functions for extension usage.\n\nNote: standard types used in the function (size_t, uint8_t, const, pointers) are not themselves compiler extensions. The above list targets all macros, type definitions and called functions whose declarations/definitions could introduce language extensions that would violate the MISRA prohibition on compiler extensions."
}