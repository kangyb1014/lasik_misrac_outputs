{
  "user_message": "An agent A claimed that the following MHD_set_thread_name_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_set_thread_name_.\n```c\nstatic int\nMHD_set_thread_name_ (const MHD_thread_ID_native_ thread_id,\n                      const char *thread_name)\n{\n  if (NULL == thread_name)\n    return 0;\n\n#if defined(HAVE_PTHREAD_SETNAME_NP_GNU)\n  return ! pthread_setname_np (thread_id, thread_name);\n#elif defined(HAVE_PTHREAD_SET_NAME_NP_FREEBSD)\n  /* FreeBSD and OpenBSD use different function name and void return type */\n  pthread_set_name_np (thread_id, thread_name);\n  return ! 0;\n#elif defined(HAVE_PTHREAD_SETNAME_NP_NETBSD)\n  /* NetBSD use 3 arguments: second argument is string in printf-like format,\n   *                         third argument is a single argument for printf();\n   * OSF1 use 3 arguments too, but last one always must be zero (NULL).\n   * MHD doesn't use '%' in thread names, so both form are used in same way.\n   */\n  return ! pthread_setname_np (thread_id, thread_name, 0);\n#endif /* HAVE_PTHREAD_SETNAME_NP_NETBSD */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code casts the void* 'data' to a pointer to a non-const struct: (struct MHD_named_helper_param_ *)data and binds it to 'struct MHD_named_helper_param_ *const param'. The function only reads fields from *param (param->name, param->arg, param->start_routine) and does not modify the pointed-to object, so the pointer should point to a const-qualified type. Casting to a non-const pointee type when mutation is not needed violates MISRA C 2023 Rule 8.13. Recommendation: use a const-qualified pointee, e.g. const struct MHD_named_helper_param_ * const param = (const struct MHD_named_helper_param_ *) data;\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_thread_name_:\ntypedef pthread_t MHD_thread_ID_native_\n...\n#define HAVE_PTHREAD_SETNAME_NP_GNU 1\n...\nstatic MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ *const param =\n    (struct MHD_named_helper_param_ *) data;\n  void *arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_) 0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free (data);\n\n  return thr_func (arg);\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In named_thread_starter the local variable 'param' is declared as a pointer to a non-const struct: struct MHD_named_helper_param_ *const param = (struct MHD_named_helper_param_ *) data; only read access is performed (param->name, param->arg, param->start_routine) and the object is not modified through 'param' (the allocated block is freed via the original 'data' pointer). Per MISRA C 2023 Rule 8.13 a pointer should point to a const-qualified type whenever mutation is not required. Thus 'param' should be declared to point to a const-qualified type, for example: const struct MHD_named_helper_param_ * const param = (const struct MHD_named_helper_param_ *) data; This change is compatible with the later free(data) call (free takes void * and the original 'data' remains available), so the current code violates Rule 8.13 and the report is correct."
}