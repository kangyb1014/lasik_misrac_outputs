{
  "user_message": "Target function code is:\n```c\nstatic size_t\nconnection_maximize_write_buffer (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MemoryPool *const pool = connection->pool;\n  void *new_buf;\n  size_t new_size;\n  size_t free_size;\n\n  mhd_assert ((NULL != c->write_buffer) || (0 == c->write_buffer_size));\n  mhd_assert (c->write_buffer_append_offset >= c->write_buffer_send_offset);\n  mhd_assert (c->write_buffer_size >= c->write_buffer_append_offset);\n\n  free_size = MHD_pool_get_free (pool);\n  if (0 != free_size)\n  {\n    new_size = c->write_buffer_size + free_size;\n    /* This function must not move the buffer position.\n     * MHD_pool_reallocate () may return the new position only if buffer was\n     * allocated 'from_end' or is not the last allocation,\n     * which should not happen. */\n    mhd_assert ((NULL == c->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (pool, c->write_buffer, \\\n                                               c->write_buffer_size));\n    new_buf = MHD_pool_reallocate (pool,\n                                   c->write_buffer,\n                                   c->write_buffer_size,\n                                   new_size);\n    mhd_assert ((c->write_buffer == new_buf) || (NULL == c->write_buffer));\n    c->write_buffer = new_buf;\n    c->write_buffer_size = new_size;\n    if (c->write_buffer_send_offset == c->write_buffer_append_offset)\n    {\n      /* All data have been sent, reset offsets to zero. */\n      c->write_buffer_send_offset = 0;\n      c->write_buffer_append_offset = 0;\n    }\n  }\n\n  return c->write_buffer_size - c->write_buffer_append_offset;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'connection_maximize_write_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['build_header_response', 'build_connection_chunked_response_footer']}, 'MHD_pool_get_free': {'callees': [], 'callers': ['try_ready_chunked_body', 'try_grow_read_buffer', 'connection_maximize_write_buffer']}, 'MHD_pool_reallocate': {'callees': [], 'callers': ['MHD_connection_alloc_memory_', 'try_ready_chunked_body', 'try_grow_read_buffer', 'connection_shrink_read_buffer', 'connection_maximize_write_buffer', 'MHD_connection_handle_read']}, 'build_header_response': {'callees': ['setup_reply_properties', 'check_connection_reply', 'connection_maximize_write_buffer', 'buffer_append', 'MHD_uint16_to_str', 'MHD_get_reason_phrase_len_for', 'MHD_get_reason_phrase_for', 'get_date_header', 'add_user_headers', 'MHD_uint64_to_str'], 'callers': ['transmit_error_response_len', 'MHD_connection_handle_idle']}, 'build_connection_chunked_response_footer': {'callees': ['connection_maximize_write_buffer'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection",
    "struct MemoryPool",
    "mhd_assert",
    "MHD_pool_get_free",
    "MHD_pool_reallocate",
    "MHD_pool_is_resizable_inplace"
  ],
  "explanation": "To determine whether connection_maximize_write_buffer uses any compiler language extensions you must inspect the declarations/definitions that this function relies on. For each symbol above explain/check the following:\n\n- struct MHD_Connection\n  - Required because the function accesses members (write_buffer, write_buffer_size, write_buffer_append_offset, write_buffer_send_offset, pool). The struct definition can contain compiler extensions (non\u2011standard bitfields, zero\u2011length arrays (GCC extension), unnamed bitfields with nonstandard widths, packed/aligned attributes, Microsoft __declspec, GCC __attribute__((...)), or other extension syntax). Inspecting the struct is needed to detect any such uses affecting this function.\n\n- struct MemoryPool\n  - Required because pool-related functions/macros may be declared in or near the MemoryPool definition or headers. The struct or its header could contain extension attributes, inline assembly, or nonstandard layout directives that are language extensions.\n\n- mhd_assert\n  - Required because it is a macro/inline function used in several places in this function (including a multi\u2011line invocation using backslash continuation). The macro may use compiler extensions (statement expressions '({ ... })', typeof, __extension__, __builtin_expect, __attribute__, nested functions, labels as values, or other non\u2011standard constructs). You must inspect the macro expansion to see if any explicitly documented compiler extension is used.\n\n- MHD_pool_get_free\n  - Required because it is called and its declaration/definition may be a macro or an inline/extern function that uses extensions (e.g. GCC attributes, inline assembly, statement expressions, typeof, or platform-specific __declspec). Check its prototype/definition for any compiler-specific syntax.\n\n- MHD_pool_reallocate\n  - Required because its return value is assigned to a void* and it is critical to the function behavior. Its declaration/definition may use compiler extensions (attributes like alloc_size, nonstandard return attributes, inline assembly, statement expressions, or be a macro that uses GCC/Clang extensions). Inspecting it is necessary to determine if any extension is present.\n\n- MHD_pool_is_resizable_inplace\n  - Required because it appears inside an mhd_assert condition and may be a macro that expands with extensions, or an inline/function declaration that uses attributes or extension syntax. The assertion condition uses it; to verify whether that use relies on extensions you must inspect its definition.\n\nNote: Standard library typedefs/macros such as size_t and NULL are standard C and do not need to be listed unless their project headers have nonstandard redefinitions. The listed symbols are the minimal set whose declarations/definitions must be examined to decide whether the target function (or the macros it invokes) employ any compiler language extensions documented as extensions in compiler manuals."
}