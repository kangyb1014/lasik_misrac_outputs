{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of connection_maximize_write_buffer:\n```c\nstatic size_t\nconnection_maximize_write_buffer (struct MHD_Connection *connection)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n  struct MemoryPool *const pool = connection->pool;\n  void *new_buf;\n  size_t new_size;\n  size_t free_size;\n\n  mhd_assert ((NULL != c->write_buffer) || (0 == c->write_buffer_size));\n  mhd_assert (c->write_buffer_append_offset >= c->write_buffer_send_offset);\n  mhd_assert (c->write_buffer_size >= c->write_buffer_append_offset);\n\n  free_size = MHD_pool_get_free (pool);\n  if (0 != free_size)\n  {\n    new_size = c->write_buffer_size + free_size;\n    /* This function must not move the buffer position.\n     * MHD_pool_reallocate () may return the new position only if buffer was\n     * allocated 'from_end' or is not the last allocation,\n     * which should not happen. */\n    mhd_assert ((NULL == c->write_buffer) || \\\n                MHD_pool_is_resizable_inplace (pool, c->write_buffer, \\\n                                               c->write_buffer_size));\n    new_buf = MHD_pool_reallocate (pool,\n                                   c->write_buffer,\n                                   c->write_buffer_size,\n                                   new_size);\n    mhd_assert ((c->write_buffer == new_buf) || (NULL == c->write_buffer));\n    c->write_buffer = new_buf;\n    c->write_buffer_size = new_size;\n    if (c->write_buffer_send_offset == c->write_buffer_append_offset)\n    {\n      /* All data have been sent, reset offsets to zero. */\n      c->write_buffer_send_offset = 0;\n      c->write_buffer_append_offset = 0;\n    }\n  }\n\n  return c->write_buffer_size - c->write_buffer_append_offset;\n}\n```\n</target_code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmhd_assert ((NULL != c->write_buffer) || (0 == c->write_buffer_size));\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The expression mhd_assert ((NULL != c->write_buffer) || (0 == c->write_buffer_size)); contains no unreachable code: both operands of the logical-OR are ordinary runtime expressions and whether the second operand is evaluated depends on the runtime value of the first (C's short-circuit semantics). There is no construct here that makes any statement or branch permanently unreachable. Even if mhd_assert is a macro that expands to nothing in non-debug builds, removing the assertion does not introduce unreachable code in this fragment. Therefore MISRA C 2023 Rule 2.1 is not violated."
}