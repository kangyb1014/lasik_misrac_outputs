{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of init_response_body_data:\n```c\nstatic int\ninit_response_body_data (void)\n{\n  if (0 != body_dyn_size)\n  {\n    body_dyn = (char *) malloc (body_dyn_size);\n    if (NULL == body_dyn)\n    {\n      fprintf (stderr, \"Failed to allocate memory.\\n\");\n      return 0;\n    }\n    if (tool_params.medium)\n    {\n      /* Fill the body with HTML-like content */\n      size_t pos;\n      size_t filler_pos;\n      static const char body_header[] =\n        \"<html>\\n\"\n        \"<head>\\n<title>Sample page title</title>\\n<head>\\n\"\n        \"<body>\\n\";\n      static const char body_filler[] =\n        \"The quick brown fox jumps over the lazy dog.<br>\\n\";\n      static const char body_footer[] =\n        \"</body>\\n\"\n        \"</html>\\n\";\n      pos = 0;\n      memcpy (body_dyn + pos, body_header, MHD_STATICSTR_LEN_ (body_header));\n      pos += MHD_STATICSTR_LEN_ (body_header);\n      for (filler_pos = 0;\n           filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                          + MHD_STATICSTR_LEN_ (body_footer)));\n           ++filler_pos)\n      {\n        body_dyn[pos + filler_pos] =\n          body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n      }\n      pos += filler_pos;\n      memcpy (body_dyn + pos, body_footer, MHD_STATICSTR_LEN_ (body_footer));\n    }\n    else\n    {\n      /* Fill the body with binary-like content */\n      size_t pos;\n      for (pos = 0; pos < body_dyn_size; ++pos)\n      {\n        body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n      }\n    }\n  }\n  return ! 0;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function init_response_body_data:\nstatic size_t body_dyn_size\n...\nstatic char *body_dyn = NULL\n...\nstatic struct PerfRepl_parameters tool_params = {\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n}\n...\nstatic int\ninit_data (void)\n{\n  unsigned int i;\n\n  if (tool_params.medium)\n    body_dyn_size = 8U * 1024U;\n  else if (tool_params.large)\n    body_dyn_size = 1024U * 1024U;\n  else\n    body_dyn_size = 0;\n\n  if (! init_response_body_data ())\n    return 25;\n\n  if (tool_params.unique)\n    return 0; /* Responses are generated on-fly */\n\n  if (tool_params.single)\n  {\n    resp_single = create_response_object ();\n    if (NULL == resp_single)\n    {\n      fprintf (stderr, \"Failed to create response.\\n\");\n      return 25;\n    }\n    return 0;\n  }\n\n  /* Use more responses to minimise waiting in threads while the response\n     used by other thread. */\n  if (! tool_params.thread_per_conn)\n    num_resps = 16 * get_num_threads ();\n  else\n    num_resps = 16 * get_cpu_core_count ();\n\n  resps = (struct MHD_Response **)\n          malloc ((sizeof(struct MHD_Response *)) * num_resps);\n  if (NULL == resps)\n  {\n    if (NULL != body_dyn)\n    {\n      free (body_dyn);\n      body_dyn = NULL;\n    }\n    fprintf (stderr, \"Failed to allocate memory.\\n\");\n    return 25;\n  }\n  for (i = 0; i < num_resps; ++i)\n  {\n    resps[i] = create_response_object ();\n    if (NULL == resps[i])\n    {\n      fprintf (stderr, \"Failed to create responses.\\n\");\n      break;\n    }\n  }\n  if (i == num_resps)\n    return 0; /* Success */\n\n  /* Cleanup */\n  while (--i < num_resps)\n    MHD_destroy_response (resps[i]);\n  free (resps);\n  resps = NULL;\n  num_resps = 0;\n  if (NULL != body_dyn)\n    free (body_dyn);\n  body_dyn = NULL;\n  return 32;\n}\n...\n#define MHD_STATICSTR_LEN_(macro) (sizeof(macro)/sizeof(char)-1)\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "for (pos = 0; pos < body_dyn_size; ++pos)\n{\n  body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n}",
    "if (0 != body_dyn_size)\n{\n  body_dyn = (char *) malloc (body_dyn_size);\n  if (NULL == body_dyn)\n  {\n    fprintf (stderr, \"Failed to allocate memory.\\n\");\n    return 0;\n  }\n  if (tool_params.medium)\n  {\n    /* Fill the body with HTML-like content */\n    size_t pos;\n    size_t filler_pos;\n    static const char body_header[] =\n      \"<html>\\n\"\n      \"<head>\\n<title>Sample page title</title>\\n<head>\\n\"\n      \"<body>\\n\";\n    static const char body_filler[] =\n      \"The quick brown fox jumps over the lazy dog.<br>\\n\";\n    static const char body_footer[] =\n      \"</body>\\n\"\n      \"</html>\\n\";\n    pos = 0;\n    memcpy (body_dyn + pos, body_header, MHD_STATICSTR_LEN_ (body_header));\n    pos += MHD_STATICSTR_LEN_ (body_header);\n    for (filler_pos = 0;\n         filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                        + MHD_STATICSTR_LEN_ (body_footer)));\n         ++filler_pos)\n    {\n      body_dyn[pos + filler_pos] =\n        body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n    }\n    pos += filler_pos;\n    memcpy (body_dyn + pos, body_footer, MHD_STATICSTR_LEN_ (body_footer));\n  }\n  else\n  {\n    /* Fill the body with binary-like content */\n    size_t pos;\n    for (pos = 0; pos < body_dyn_size; ++pos)\n    {\n      body_dyn[pos] = (char) (unsigned char) (255U - pos % 256U);\n    }\n  }\n}",
    "while (--i < num_resps)\n  MHD_destroy_response (resps[i]);",
    "for (i = 0; i < num_resps; ++i)\n{\n  resps[i] = create_response_object ();\n  if (NULL == resps[i])\n  {\n    fprintf (stderr, \"Failed to create responses.\\n\");\n    break;\n  }\n}",
    "for (filler_pos = 0;\n     filler_pos < (body_dyn_size - (MHD_STATICSTR_LEN_ (body_header)\n                                    + MHD_STATICSTR_LEN_ (body_footer)));\n     ++filler_pos)\n{\n  body_dyn[pos + filler_pos] =\n    body_filler[filler_pos % MHD_STATICSTR_LEN_ (body_filler)];\n}"
  ],
  "explanation": "I selected fragments that should be investigated for possible unreachable-code problems or logic that can make code paths impossible or skipped in all realistic executions (e.g. loop bounds, underflow, unsigned wrap, conditional initialization that may never enable a branch, and cleanup loops whose control expression is suspect). Other code parts were not selected because they are standard, obviously reachable constructs or straightforward error-return paths that are executed conditionally (e.g. the malloc call and its immediate NULL-check/return, memcpy calls, the binary-fill loop structure itself apart from the shown loop bounds, and the normal allocation/return sequences). In particular, code that is intentionally conditional and can execute depending on run-time parameters (such as choosing medium vs binary fill, the normal allocation-success path, the immediate error returns on allocation failures) were not listed because they are not inherently unreachable by program structure and are required for normal operation; they should be reviewed for correctness but do not constitute obviously unreachable code under the project semantics."
}