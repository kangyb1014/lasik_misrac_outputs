{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of find_entry_by_userhash:\n```c\nstatic struct UserEntry *\nfind_entry_by_userhash (enum MHD_DigestAuthAlgo3 algo3,\n                        const void *userhash,\n                        size_t userhash_size)\n{\n  size_t i;\n\n  if (MHD_digest_get_hash_size (algo3) != userhash_size)\n    return NULL; /* Wrong length of the userhash */\n\n  switch (algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_md5) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha256,\n                       sizeof(entry->userhash_sha256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION: /* An extra case not used currently */\n    if (sizeof(user_ids[0].userhash_sha512_256) != userhash_size) /* Extra check. The size was checked before */\n      return NULL;\n    for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n    {\n      struct UserEntry *entry;\n\n      entry = user_ids + i;\n      if (0 == memcmp (userhash, entry->userhash_sha512_256,\n                       sizeof(entry->userhash_sha512_256)))\n        return entry;\n    }\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning. Impossible value in this context. */\n  default:\n    break;\n  }\n  return NULL;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function find_entry_by_userhash:\nstatic struct UserEntry user_ids[2]\n...\nstruct UserEntry\n{\n  /**\n   * The username.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *username;\n#if 0 /* Disabled code */\n  /* The cleartext password is not stored in the database.\n     The more secure \"userdigest\" is used instead. */\n  /**\n   * The password.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *password;\n#endif /* Disabled code */\n  /**\n   * The realm for this entry.\n   * Static data is used in this example.\n   * In real application dynamic buffer or fixed size array could be used.\n   */\n  const char *realm;\n\n  /**\n   * The MD5 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_md5[MHD_MD5_DIGEST_SIZE];\n  /**\n   * The MD5 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_md5[MHD_MD5_DIGEST_SIZE];\n\n  /**\n   * The SHA-256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha256[MHD_SHA256_DIGEST_SIZE];\n  /**\n   * The SHA-256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha256[MHD_SHA256_DIGEST_SIZE];\n\n  /**\n   * The SHA-512/256 hash of the username together with the realm.\n   * This hash can be used by the client to send the username in encrypted\n   * form.\n   * The purpose of userhash is to hide user identity when transmitting\n   * requests over insecure link.\n   */\n  uint8_t userhash_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n  /**\n   * The SHA-512/256 hash of the username with the password and the realm.\n   * It is used to verify that password used by the client matches password\n   * required by the server.\n   * The purpose of userhash is to avoid keeping the password in cleartext\n   * on the server side.\n   */\n  uint8_t userdigest_sha512_256[MHD_SHA512_256_DIGEST_SIZE];\n\n  /**\n   * User has access to \"area 1\" if non-zero\n   */\n  int allow_area_1;\n\n  /**\n   * User has access to \"area 2\" if non-zero\n   */\n  int allow_area_2;\n}\n...\nenum MHD_DigestAuthAlgo3\n{\n  /**\n   * Unknown or wrong algorithm type.\n   * Used in struct MHD_DigestAuthInfo to indicate client value that\n   * cannot by identified.\n   */\n  MHD_DIGEST_AUTH_ALGO3_INVALID = 0,\n\n  /**\n   * The 'MD5' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5 =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'MD5-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_MD5_SESSION =\n    MHD_DIGEST_BASE_ALGO_MD5 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-256' algorithm, non-session version.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256 =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-256-sess' algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA256 | MHD_DIGEST_AUTH_ALGO3_SESSION,\n\n  /**\n   * The 'SHA-512-256' (SHA-512/256) algorithm.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256 =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_NON_SESSION,\n\n  /**\n   * The 'SHA-512-256-sess' (SHA-512/256 session) algorithm.\n   * Not supported by MHD for authentication.\n   */\n  MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION =\n    MHD_DIGEST_BASE_ALGO_SHA512_256 | MHD_DIGEST_AUTH_ALGO3_SESSION\n}\n...\n_MHD_EXTERN size_t\nMHD_digest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n  return digest_get_hash_size (algo3);\n}\n...\n_MHD_static_inline size_t\ndigest_get_hash_size (enum MHD_DigestAuthAlgo3 algo3)\n{\n#ifdef MHD_MD5_SUPPORT\n  mhd_assert (MHD_MD5_DIGEST_SIZE == MD5_DIGEST_SIZE);\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (MHD_SHA256_DIGEST_SIZE == SHA256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  mhd_assert (MHD_SHA512_256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#ifdef MHD_SHA256_SUPPORT\n  mhd_assert (SHA256_DIGEST_SIZE == SHA512_256_DIGEST_SIZE);\n#endif /* MHD_SHA256_SUPPORT */\n#endif /* MHD_SHA512_256_SUPPORT */\n  /* Only one algorithm must be specified */\n  mhd_assert (1 == \\\n              (((0 != (algo3 & MHD_DIGEST_BASE_ALGO_MD5)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA256)) ? 1 : 0)   \\\n               + ((0 != (algo3 & MHD_DIGEST_BASE_ALGO_SHA512_256)) ? 1 : 0)));\n#ifdef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_MD5)))\n    return MHD_MD5_DIGEST_SIZE;\n  else\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) && defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ( ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)\n                | ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256))))\n    return MHD_SHA256_DIGEST_SIZE; /* The same as SHA512_256_DIGEST_SIZE */\n  else\n#elif defined(MHD_SHA256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA256)))\n    return MHD_SHA256_DIGEST_SIZE;\n  else\n#elif defined(MHD_SHA512_256_SUPPORT)\n  if (0 != (((unsigned int) algo3)\n            & ((unsigned int) MHD_DIGEST_BASE_ALGO_SHA512_256)))\n    return MHD_SHA512_256_DIGEST_SIZE;\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n    (void) 0; /* Unsupported algorithm */\n\n  return 0; /* Wrong input or unsupported algorithm */\n}\n...\nstatic struct UserEntry *\nfind_entry_by_userinfo (const struct MHD_DigestAuthUsernameInfo *username_info)\n{\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD <= username_info->uname_type)\n    return find_entry_by_username (username_info->username);\n\n  if (MHD_DIGEST_AUTH_UNAME_TYPE_USERHASH == username_info->uname_type)\n    return find_entry_by_userhash (username_info->algo3,\n                                   username_info->userhash_bin,\n                                   username_info->userhash_hex_len / 2);\n\n  return NULL; /* Should be unreachable as all cases are covered before */\n}\n...\nstatic struct UserEntry *\nfind_entry_by_username (const char *const username)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof(user_ids) / sizeof(user_ids[0])); ++i)\n  {\n    struct UserEntry *entry;\n\n    entry = user_ids + i;\n    if (0 == strcmp (username, entry->username))\n      return entry;\n  }\n  return NULL;\n}\n...\nstatic enum MHD_Result\nhandle_sec_areas_req (struct MHD_Connection *c, const char *url, unsigned int\n                      sec_area_num)\n{\n  struct MHD_DigestAuthUsernameInfo *username_info;\n  struct UserEntry *user_entry;\n  void *userdigest;\n  size_t userdigest_size;\n  enum MHD_DigestAuthResult auth_res;\n\n  username_info = MHD_digest_auth_get_username3 (c);\n\n  if (NULL == username_info)\n    return reply_with_auth_required (c, 0, 0);\n\n  user_entry = find_entry_by_userinfo (username_info);\n\n  if (NULL == user_entry)\n    return reply_with_auth_required (c, 0, 1);\n\n  switch (username_info->algo3)\n  {\n  case MHD_DIGEST_AUTH_ALGO3_MD5:\n    userdigest = user_entry->userdigest_md5;\n    userdigest_size = sizeof(user_entry->userdigest_md5);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA256:\n    userdigest = user_entry->userdigest_sha256;\n    userdigest_size = sizeof(user_entry->userdigest_sha256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256:\n    userdigest = user_entry->userdigest_sha512_256;\n    userdigest_size = sizeof(user_entry->userdigest_sha512_256);\n    break;\n  case MHD_DIGEST_AUTH_ALGO3_MD5_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION:\n  case MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION:\n    /* Not supported currently and not used by MHD.\n       The client incorrectly used algorithm not advertised by the server. */\n    return reply_with_auth_required (c, 0, 1);\n  case MHD_DIGEST_AUTH_ALGO3_INVALID: /* Mute compiler warning */\n  default:\n    return MHD_NO; /* Should be unreachable */\n  }\n\n  auth_res = MHD_digest_auth_check_digest3 (\n    c,\n    REALM, /* Make sure to use the proper realm, not the realm provided by the client and returned by \"user_entry\" */\n    user_entry->username,\n    userdigest,\n    userdigest_size,\n    0, /* Use daemon's default value for nonce_timeout*/\n    0, /* Use daemon's default value for max_nc */\n    get_m_QOP (),\n    (enum MHD_DigestAuthMultiAlgo3) username_info->algo3 /* Direct cast from \"single algorithm\" to \"multi-algorithm\" is allowed */\n    );\n\n  if (MHD_DAUTH_OK != auth_res)\n  {\n    int need_just_refresh_nonce;\n    /* Actually MHD_DAUTH_NONCE_OTHER_COND should not be returned as\n       MHD_OPTION_DIGEST_AUTH_NONCE_BIND_TYPE is not used for the daemon.\n       To keep the code universal the MHD_DAUTH_NONCE_OTHER_COND is\n       still checked here. */\n    need_just_refresh_nonce =\n      (MHD_DAUTH_NONCE_STALE == auth_res)\n      || (MHD_DAUTH_NONCE_OTHER_COND == auth_res);\n    return reply_with_auth_required (c,\n                                     need_just_refresh_nonce,\n                                     ! need_just_refresh_nonce);\n  }\n\n  /* The user successfully authenticated */\n\n  /* Check whether access to the request area is allowed for the user */\n  if (1 == sec_area_num)\n  {\n    if (user_entry->allow_area_1)\n      return reply_with_area1_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n  else if (2 == sec_area_num)\n  {\n    if (user_entry->allow_area_2)\n      return reply_with_area2_pages (c, url);\n    else\n      return reply_with_forbidden (c);\n  }\n\n  return MHD_NO; /* Should be unreachable */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nif (0 == memcmp (userhash, entry->userhash_md5,\n                       sizeof(entry->userhash_md5)))\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The call to memcmp uses sizeof(entry->userhash_md5) as the length; earlier the function checks that MHD_digest_get_hash_size(algo3) == userhash_size and, for the MD5 case, additionally that sizeof(user_ids[0].userhash_md5) == userhash_size. Therefore the length passed to memcmp equals the actual size of entry->userhash_md5 and equals the validated userhash_size, so memcmp will not read beyond either object when userhash points to a buffer of at least userhash_size bytes."
}