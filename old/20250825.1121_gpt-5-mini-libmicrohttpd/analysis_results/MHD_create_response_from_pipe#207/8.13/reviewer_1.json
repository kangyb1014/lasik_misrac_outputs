{
  "user_message": "An agent A claimed that the following MHD_create_response_from_pipe code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_create_response_from_pipe.\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_pipe (int fd)\n{\n  struct MHD_Response *response;\n\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                MHD_FILE_READ_BLOCK_SIZE,\n                                                &pipe_reader,\n                                                NULL,\n                                                &free_callback);\n  if (NULL == response)\n    return NULL;\n  response->fd = fd;\n  response->is_pipe = true;\n  response->crc_cls = response;\n  return response;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nIn pipe_reader the callback parameter cls is treated as a pointer to struct MHD_Response but only read (response->fd is read). The code uses a non-const pointer: struct MHD_Response *response = cls; since the object is not modified in pipe_reader the pointer should be to a const-qualified type (e.g. const struct MHD_Response *response = cls or declare the callback parameter as const void *cls). This violates MISRA C 2023 Rule 8.13. (Note: in free_callback the response object is modified, so a non-const pointer is necessary there.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_create_response_from_pipe:\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_callback (uint64_t size,\n                                   size_t block_size,\n                                   MHD_ContentReaderCallback crc,\n                                   void *crc_cls,\n                                   MHD_ContentReaderFreeCallback crfc)\n{\n  struct MHD_Response *response;\n\n  if ((NULL == crc) || (0 == block_size))\n    return NULL;\n  if (NULL == (response = MHD_calloc_ (1, sizeof (struct MHD_Response)\n                                       + block_size)))\n    return NULL;\n  response->fd = -1;\n  response->data = (void *) &response[1];\n  response->data_buffer_size = block_size;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n#endif\n  response->crc = crc;\n  response->crfc = crfc;\n  response->crc_cls = crc_cls;\n  response->reference_count = 1;\n  response->total_size = size;\n  return response;\n}\n...\nstatic ssize_t\npipe_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n  ssize_t n;\n\n  (void) pos;\n\n#ifndef _WIN32\n  if (SSIZE_MAX < max)\n    max = SSIZE_MAX;\n  n = read (response->fd,\n            buf,\n            (MHD_SCKT_SEND_SIZE_) max);\n#else  /* _WIN32 */\n  if (UINT_MAX < max)\n    max = INT_MAX;\n  n = read (response->fd,\n            buf,\n            (unsigned int) max);\n#endif /* _WIN32 */\n\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n}\n...\nstatic void\nfree_callback (void *cls)\n{\n  struct MHD_Response *response = cls;\n\n  (void) close (response->fd);\n  response->fd = -1;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Rule 8.13 asks that a pointer should point to a const-qualified type whenever possible. In pipe_reader the function only reads the response object (it reads response->fd) but the local pointer is declared non-const: struct MHD_Response *response = cls; therefore the pointer could and should be to a const-qualified type (e.g. const struct MHD_Response *response = cls). That is a straightforward application of 8.13 and is a valid violation. Note: changing the callback typedef parameter to const void *cls would be an API change and is not required; the local pointer in pipe_reader can (and should) be const while free_callback remains non-const because free_callback does modify the object. In short, the agent A report is correct \u2014 pipe_reader violates MISRA C 2023 Rule 8.13 and can be fixed by making the local response pointer point to a const-qualified type."
}