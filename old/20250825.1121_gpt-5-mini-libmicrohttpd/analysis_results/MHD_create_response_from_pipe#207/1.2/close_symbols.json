{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_pipe (int fd)\n{\n  struct MHD_Response *response;\n\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                MHD_FILE_READ_BLOCK_SIZE,\n                                                &pipe_reader,\n                                                NULL,\n                                                &free_callback);\n  if (NULL == response)\n    return NULL;\n  response->fd = fd;\n  response->is_pipe = true;\n  response->crc_cls = response;\n  return response;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_create_response_from_pipe': {'callees': ['MHD_create_response_from_callback'], 'callers': []}, 'MHD_create_response_from_callback': {'callees': [], 'callers': ['MHD_create_response_from_fd_at_offset64', 'MHD_create_response_from_pipe', 'ahc_echo']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_EXTERN",
    "struct MHD_Response",
    "MHD_create_response_from_callback (declaration/prototype)",
    "MHD_SIZE_UNKNOWN",
    "MHD_FILE_READ_BLOCK_SIZE",
    "pipe_reader",
    "free_callback",
    "true"
  ],
  "explanation": "Explain why each symbol is required to check for language-extension use:\n\n- MHD_EXTERN\n  - This is a macro used on the function definition line. It may expand to compiler-specific storage-class or attribute extensions (for example, __attribute__((visibility(...))), __declspec(dllexport), or other compiler-specific annotations). You must inspect its definition to determine whether a language/compiler extension is being used.\n\n- struct MHD_Response\n  - The function writes into fields (fd, is_pipe, crc_cls). The structure definition can contain non\u2011standard constructs (anonymous unions/structs, compiler bit\u2011field extensions, packed/pragma attributes, or other vendor extensions). Inspecting the struct is required to see whether use of those fields relies on language extensions.\n\n- MHD_create_response_from_callback (declaration/prototype)\n  - The called function\u2019s prototype may itself be declared with compiler extensions (calling\u2011convention attributes, GCC __attribute__ annotations, nonstandard parameter types, or macros that expand to extensions). Also the parameter types determine the required types for pipe_reader/free_callback and any special attributes used for callbacks.\n\n- MHD_SIZE_UNKNOWN\n  - This macro/constant is passed as an argument. Its definition could use nonstandard token concatenation, GNU integer suffixes, or other extensions; confirm it\u2019s a standard constant or macro.\n\n- MHD_FILE_READ_BLOCK_SIZE\n  - Same rationale as MHD_SIZE_UNKNOWN: it may be a macro that expands using compiler extensions or nonstandard constructs; check its definition.\n\n- pipe_reader\n  - This callback identifier is passed by address. You need its function prototype/declaration to check for nonstandard function attributes (e.g., nested functions, GCC __attribute__((regparm))/calling convention specs, or other extensions). A nested function (a GCC extension) would be a direct violation of the \u201cno language extensions\u201d rule.\n\n- free_callback\n  - As with pipe_reader, inspect its declaration/prototype. The callback type or macro wrapper could use compiler-specific attributes or other extensions.\n\n- true\n  - The code uses the identifier true. Confirm whether it is the standard C99/C11 boolean macro from <stdbool.h> (or a standard typedef/enum), or whether it is a custom macro/identifier that hides an extension. This ensures no nonstandard boolean extension is being used.\n\nIn short, to decide whether the target function violates the MISRA prohibition on language extensions you must examine the macros and declarations that can hide compiler-specific extensions: storage-class/attribute macros (MHD_EXTERN), the called-function prototype and callback prototypes, any macros used as arguments, and the struct definition that makes field accesses. Inspecting those symbols will reveal any use of compiler-specific language extensions."
}