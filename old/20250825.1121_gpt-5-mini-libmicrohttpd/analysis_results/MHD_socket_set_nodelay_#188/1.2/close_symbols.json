{
  "user_message": "Target function code is:\n```c\nint\nMHD_socket_set_nodelay_ (MHD_socket sock,\n                         bool on)\n{\n#ifdef TCP_NODELAY\n  {\n    const MHD_SCKT_OPT_BOOL_ off_val = 0;\n    const MHD_SCKT_OPT_BOOL_ on_val = 1;\n    /* Disable Nagle's algorithm for normal buffering */\n    return setsockopt (sock,\n                       IPPROTO_TCP,\n                       TCP_NODELAY,\n                       (const void *) ((on) ? &on_val : &off_val),\n                       sizeof (on_val));\n  }\n#else\n  (void) sock;\n  return 0;\n#endif /* TCP_NODELAY */\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "TCP_NODELAY",
    "IPPROTO_TCP",
    "setsockopt",
    "MHD_socket",
    "MHD_SCKT_OPT_BOOL_",
    "bool"
  ],
  "explanation": "TCP_NODELAY: The function body is conditionally compiled under #ifdef TCP_NODELAY. Whether the setsockopt call exists in the compiled translation unit depends on this macro. You must know if TCP_NODELAY is defined (and how it is defined) to determine whether any potential language-extension usage in the setsockopt branch actually applies.\n\nIPPROTO_TCP: Used as the 'level' argument in the setsockopt call. You need its definition to confirm it is a normal macro/constant (not some compiler-specific extension or unusual type) and to understand whether any nonstandard use of integer/enum values or extensions is involved in the call.\n\nsetsockopt: The prototype/ declaration of setsockopt is required to check for implicit function declaration (which older compilers allowed and which can be a language-extension issue), argument types (e.g., the expected type of the optval and optlen parameters), and whether any casts in the call are masking a type mismatch that relies on a compiler extension.\n\nMHD_socket: The typedef/definition of MHD_socket is required to verify it is a standard integer/socket handle type compatible with the setsockopt prototype. If MHD_socket is defined using a compiler-specific extension (e.g., special attributes, nonstandard underlying type), that could be a MISRA violation under the \"no language extensions\" rule.\n\nMHD_SCKT_OPT_BOOL_: The definition of this type (and any related typedefs) is necessary to check whether it is a plain integer type or is implemented using compiler-specific extensions (bit-field types, mode attributes, packed types, unusual qualifiers, etc.). The correctness of taking the address of on_val/off_val and passing it (after cast) to setsockopt must be validated against the declared type.\n\nbool: The origin of 'bool' must be known (C99 stdbool.h/_Bool, or a project typedef/alias) to determine whether a nonstandard/ compiler-specific boolean type is being used. Using a compiler-specific boolean type instead of the standard _Bool/stdbool.h would be a language-extension concern.\n\nNote: The above symbols are those referenced directly by the target function whose definitions could change which code is compiled or reveal use of nonstandard typedefs/attributes. Other standard operators used in the code (sizeof, ternary operator, casts) are part of standard C and do not by themselves indicate language extensions; however, their interaction with the listed symbols must be checked once the listed symbols' definitions are known."
}