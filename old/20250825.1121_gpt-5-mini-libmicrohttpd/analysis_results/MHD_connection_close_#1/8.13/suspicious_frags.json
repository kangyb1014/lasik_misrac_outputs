{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_connection_close_:\n```c\nvoid\nMHD_connection_close_ (struct MHD_Connection *connection,\n                       enum MHD_RequestTerminationCode termination_code)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_Response *resp = connection->rp.response;\n\n  mhd_assert (! connection->suspended);\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  if ( (NULL != daemon->notify_completed) &&\n       (connection->rq.client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n                              connection,\n                              &connection->rq.client_context,\n                              termination_code);\n  connection->rq.client_aware = false;\n  if (NULL != resp)\n  {\n    connection->rp.response = NULL;\n    MHD_destroy_response (resp);\n  }\n  if (NULL != connection->pool)\n  {\n    MHD_pool_destroy (connection->pool);\n    connection->pool = NULL;\n  }\n\n  MHD_connection_mark_closed_ (connection);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_connection_close_:\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\nvoid\nMHD_pool_destroy (struct MemoryPool *pool)\n{\n  if (NULL == pool)\n    return;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  _MHD_UNPOISON_MEMORY (pool->memory, pool->size);\n  if (! pool->is_mmap)\n    free (pool->memory);\n  else\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    munmap (pool->memory,\n            pool->size);\n#elif defined(_WIN32)\n    VirtualFree (pool->memory,\n                 0,\n                 MEM_RELEASE);\n#else\n    abort ();\n#endif\n  free (pool);\n}\n...\nvoid\nMHD_connection_mark_closed_ (struct MHD_Connection *connection)\n{\n  const struct MHD_Daemon *daemon = connection->daemon;\n\n  if (0 == (daemon->options & MHD_USE_TURBO))\n  {\n#ifdef HTTPS_SUPPORT\n    /* For TLS connection use shutdown of TLS layer\n     * and do not shutdown TCP socket. This give more\n     * chances to send TLS closure data to remote side.\n     * Closure of TLS layer will be interpreted by\n     * remote side as end of transmission. */\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      if (! MHD_tls_connection_shutdown (connection))\n        shutdown (connection->socket_fd,\n                  SHUT_WR);\n    }\n    else   /* Combined with next 'shutdown()'. */\n#endif /* HTTPS_SUPPORT */\n    shutdown (connection->socket_fd,\n              SHUT_WR);\n  }\n  connection->state = MHD_CONNECTION_CLOSED;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "if ( (NULL != daemon->notify_completed) &&\n       (connection->rq.client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n                              connection,\n                              &connection->rq.client_context,\n                              termination_code);",
    "struct MHD_Daemon *daemon = connection->daemon;"
  ],
  "explanation": "I selected the two fragments above for investigation because they involve pointers/references to daemon-owned data (the local 'daemon' pointer and the client_context passed to a daemon callback) that appear to be used only for read/callback purposes and therefore may be candidates for const-qualification under MISRA C 2023 Rule 8.13. Other pointer uses in the provided code are not reported because they clearly require non-const semantics: - 'struct MHD_Response *resp = connection->rp.response;' and the subsequent call MHD_destroy_response(resp) modify/free the response object, so the pointer cannot be const. - The code that sets connection->rp.response = NULL and later frees resp demonstrates mutation/ownership transfer, again requiring non-const. - 'if (NULL != connection->pool) { MHD_pool_destroy (connection->pool); connection->pool = NULL; }' destroys and frees the pool, so that pointer must be non-const. - In MHD_destroy_response, the routine decrements reference_count, destroys mutexes, frees contained buffers and the response object itself; those actions require non-const pointers. - In MHD_pool_destroy, memory is unmapped/freed and the pool object freed; that requires a non-const pointer. - MHD_connection_mark_closed_ already binds daemon as 'const struct MHD_Daemon *daemon = connection->daemon;' and therefore follows the const recommendation for that context. The fragments I did not flag either perform modifications/frees (so const would be inappropriate) or already use const where appropriate. The two reported fragments should be inspected to determine whether the local 'daemon' variable and the address passed as &connection->rq.client_context (and the stored notify_completed function pointer's parameter types) could/should be changed to point to const-qualified types to comply with Rule 8.13."
}