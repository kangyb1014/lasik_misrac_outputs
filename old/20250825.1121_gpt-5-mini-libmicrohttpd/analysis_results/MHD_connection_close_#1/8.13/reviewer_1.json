{
  "user_message": "An agent A claimed that the following MHD_connection_close_ code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_connection_close_.\n```c\nvoid\nMHD_connection_close_ (struct MHD_Connection *connection,\n                       enum MHD_RequestTerminationCode termination_code)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_Response *resp = connection->rp.response;\n\n  mhd_assert (! connection->suspended);\n#ifdef MHD_USE_THREADS\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (connection->tid) );\n#endif /* MHD_USE_THREADS */\n  if ( (NULL != daemon->notify_completed) &&\n       (connection->rq.client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n                              connection,\n                              &connection->rq.client_context,\n                              termination_code);\n  connection->rq.client_aware = false;\n  if (NULL != resp)\n  {\n    connection->rp.response = NULL;\n    MHD_destroy_response (resp);\n  }\n  if (NULL != connection->pool)\n  {\n    MHD_pool_destroy (connection->pool);\n    connection->pool = NULL;\n  }\n\n  MHD_connection_mark_closed_ (connection);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe local variable 'daemon' only reads fields from connection->daemon (calls notify_completed, checks options via macros), and the function does not modify the daemon object through this pointer. Therefore 'daemon' could (and should) be declared as 'const struct MHD_Daemon *daemon = connection->daemon;'. Using a non-const pointer when a const-qualified pointer is possible violates MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_connection_close_:\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\nvoid\nMHD_pool_destroy (struct MemoryPool *pool)\n{\n  if (NULL == pool)\n    return;\n\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (pool->pos == ROUND_TO_ALIGN (pool->pos));\n  _MHD_UNPOISON_MEMORY (pool->memory, pool->size);\n  if (! pool->is_mmap)\n    free (pool->memory);\n  else\n#if defined(MAP_ANONYMOUS) && ! defined(_WIN32)\n    munmap (pool->memory,\n            pool->size);\n#elif defined(_WIN32)\n    VirtualFree (pool->memory,\n                 0,\n                 MEM_RELEASE);\n#else\n    abort ();\n#endif\n  free (pool);\n}\n...\nvoid\nMHD_connection_mark_closed_ (struct MHD_Connection *connection)\n{\n  const struct MHD_Daemon *daemon = connection->daemon;\n\n  if (0 == (daemon->options & MHD_USE_TURBO))\n  {\n#ifdef HTTPS_SUPPORT\n    /* For TLS connection use shutdown of TLS layer\n     * and do not shutdown TCP socket. This give more\n     * chances to send TLS closure data to remote side.\n     * Closure of TLS layer will be interpreted by\n     * remote side as end of transmission. */\n    if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      if (! MHD_tls_connection_shutdown (connection))\n        shutdown (connection->socket_fd,\n                  SHUT_WR);\n    }\n    else   /* Combined with next 'shutdown()'. */\n#endif /* HTTPS_SUPPORT */\n    shutdown (connection->socket_fd,\n              SHUT_WR);\n  }\n  connection->state = MHD_CONNECTION_CLOSED;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In MHD_connection_close_ the local variable 'daemon' is only used for read-only access (checking options via macros and calling the notify_completed function pointer stored in the daemon). The function does not modify the daemon object through this pointer and does not pass it to any callees that require a mutable daemon. Converting the declaration to 'const struct MHD_Daemon *daemon = connection->daemon;' is safe (and consistent with MHD_connection_mark_closed_ which already uses a const daemon pointer). Therefore the code violates MISRA C:2023 Rule 8.13, which advises using a pointer to a const-qualified type whenever modification through that pointer is not needed."
}