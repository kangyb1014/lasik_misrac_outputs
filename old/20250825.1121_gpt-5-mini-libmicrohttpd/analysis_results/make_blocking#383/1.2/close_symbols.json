{
  "user_message": "Target function code is:\n```c\nstatic void\nmake_blocking (MHD_socket fd)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (fd, F_GETFL);\n  if (-1 == flags)\n    abort ();\n  if ((flags & ~O_NONBLOCK) != flags)\n    if (-1 == fcntl (fd, F_SETFL, flags & ~O_NONBLOCK))\n      abort ();\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 0;\n\n  if (0 != ioctlsocket (fd, (int) FIONBIO, &flags))\n    abort ();\n#endif /* MHD_WINSOCK_SOCKETS */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_POSIX_SOCKETS",
    "MHD_WINSOCK_SOCKETS",
    "MHD_socket",
    "SOCKET",
    "fcntl",
    "F_GETFL",
    "F_SETFL",
    "O_NONBLOCK",
    "ioctlsocket",
    "FIONBIO",
    "abort"
  ],
  "explanation": "You must check these symbols to decide whether the function uses any compiler language extensions (MISRA rule). For each:\n\n- MHD_POSIX_SOCKETS, MHD_WINSOCK_SOCKETS: These conditional macros select platform-specific code paths. Determine how they are defined (build system or headers) to see if platform-only or compiler-specific macros are used as extensions.\n\n- MHD_socket: The typedef behind MHD_socket may map to a platform- or compiler-specific type (e.g. SOCKET or a compiler-specific integer type). Inspect its definition to ensure no non-standard/extension types (like compiler-specific integer widths or attributes) are used.\n\n- SOCKET: If MHD_socket aliases SOCKET on Windows, inspect SOCKET's typedef (it may be ULONG_PTR or typedefs that vary by compiler) to detect any compiler-specific extensions.\n\n- fcntl: A POSIX API; verify it is a standard library/system call, not a compiler-provided extension on the target toolchain.\n\n- F_GETFL, F_SETFL, O_NONBLOCK: Constants/macros used with fcntl. Check their definitions in the system headers to confirm they are standard macros (not extension-builtins) and that their usage does not rely on compiler-specific behavior.\n\n- ioctlsocket: A Win32/WinSock API; verify it is the expected platform API and not a compiler extension or macro alias that expands to nonstandard constructs.\n\n- FIONBIO: WinSock/ioctl constant. Inspect its definition to ensure it is a normal platform macro and not a compiler-specific extension.\n\n- abort: Standard C library function; include to confirm usage is standard and not replaced by a compiler-specific builtin or attribute.\n\nIn short: inspect the typedefs and the system header definitions for these macros/functions to confirm they are standard library or OS APIs and not compiler-specific language extensions (e.g., __attribute__, __asm__, typeof, statement-expressions, nonstandard integer types, or other documented compiler extensions)."
}