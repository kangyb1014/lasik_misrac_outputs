{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 2.2 is: A project shall not contain dead code.\nAny operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of free_unmarked:\n```c\nstatic void\nfree_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n  {\n    free (pp->content_name);\n    pp->content_name = NULL;\n  }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n  {\n    free (pp->content_type);\n    pp->content_type = NULL;\n  }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n  {\n    free (pp->content_filename);\n    pp->content_filename = NULL;\n  }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n  {\n    free (pp->content_transfer_encoding);\n    pp->content_transfer_encoding = NULL;\n  }\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function free_unmarked:\nstruct MHD_PostProcessor\n{\n\n  /**\n   * The connection for which we are doing\n   * POST processing.\n   */\n  struct MHD_Connection *connection;\n\n  /**\n   * Function to call with POST data.\n   */\n  MHD_PostDataIterator ikvi;\n\n  /**\n   * Extra argument to ikvi.\n   */\n  void *cls;\n\n  /**\n   * Encoding as given by the headers of the connection.\n   */\n  const char *encoding;\n\n  /**\n   * Primary boundary (points into encoding string)\n   */\n  const char *boundary;\n\n  /**\n   * Nested boundary (if we have multipart/mixed encoding).\n   */\n  char *nested_boundary;\n\n  /**\n   * Pointer to the name given in disposition.\n   */\n  char *content_name;\n\n  /**\n   * Pointer to the (current) content type.\n   */\n  char *content_type;\n\n  /**\n   * Pointer to the (current) filename.\n   */\n  char *content_filename;\n\n  /**\n   * Pointer to the (current) encoding.\n   */\n  char *content_transfer_encoding;\n\n  /**\n   * Value data left over from previous iteration.\n   */\n  char xbuf[2];\n\n  /**\n   * Size of our buffer for the key.\n   */\n  size_t buffer_size;\n\n  /**\n   * Current position in the key buffer.\n   */\n  size_t buffer_pos;\n\n  /**\n   * Current position in @e xbuf.\n   */\n  size_t xbuf_pos;\n\n  /**\n   * Current offset in the value being processed.\n   */\n  uint64_t value_offset;\n\n  /**\n   * strlen(boundary) -- if boundary != NULL.\n   */\n  size_t blen;\n\n  /**\n   * strlen(nested_boundary) -- if nested_boundary != NULL.\n   */\n  size_t nlen;\n\n  /**\n   * Do we have to call the 'ikvi' callback when processing the\n   * multipart post body even if the size of the payload is zero?\n   * Set to #MHD_YES whenever we parse a new multiparty entry header,\n   * and to #MHD_NO the first time we call the 'ikvi' callback.\n   * Used to ensure that we do always call 'ikvi' even if the\n   * payload is empty (but not more than once).\n   */\n  bool must_ikvi;\n\n  /**\n   * Set if we still need to run the unescape logic\n   * on the key allocated at the end of this struct.\n   */\n  bool must_unescape_key;\n\n  /**\n   * State of the parser.\n   */\n  enum PP_State state;\n\n  /**\n   * Side-state-machine: skip CRLF (or just LF).\n   * Set to 0 if we are not in skip mode.  Set to 2\n   * if a CRLF is expected, set to 1 if a CR should\n   * be skipped if it is the next character.\n   */\n  enum RN_State skip_rn;\n\n  /**\n   * If we are in skip_rn with \"dash\" mode and\n   * do find 2 dashes, what state do we go into?\n   */\n  enum PP_State dash_state;\n\n  /**\n   * Which headers are global? (used to tell which\n   * headers were only valid for the nested multipart).\n   */\n  enum NE_State have;\n\n}\n...\nstatic enum MHD_Result\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n                        size_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n  {\n    /* first, move as much input data\n       as possible to our internal buffer */\n    max = pp->buffer_size - pp->buffer_pos;\n    if (max > post_data_len - poff)\n      max = post_data_len - poff;\n    memcpy (&buf[pp->buffer_pos],\n            &post_data[poff],\n            max);\n    poff += max;\n    pp->buffer_pos += max;\n    if ( (0 == max) &&\n         (0 == state_changed) &&\n         (poff < post_data_len) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n    state_changed = 0;\n\n    /* first state machine for '\\r'-'\\n' and '--' handling */\n    switch (pp->skip_rn)\n    {\n    case RN_Inactive:\n      break;\n    case RN_OptN:\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n    /* fall-through! */\n    case RN_Dash:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Dash2;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Full;\n    /* fall-through! */\n    case RN_Full:\n      if (buf[0] == '\\r')\n      {\n        if ( (pp->buffer_pos > 1) &&\n             ('\\n' == buf[1]) )\n        {\n          pp->skip_rn = RN_Inactive;\n          ioff += 2;\n        }\n        else\n        {\n          pp->skip_rn = RN_OptN;\n          ioff++;\n        }\n        goto AGAIN;\n      }\n      if (buf[0] == '\\n')\n      {\n        ioff++;\n        pp->skip_rn = RN_Inactive;\n        goto AGAIN;\n      }\n      pp->skip_rn = RN_Inactive;\n      pp->state = PP_Error;\n      return MHD_NO;            /* no '\\r\\n' */\n    case RN_Dash2:\n      if (buf[0] == '-')\n      {\n        ioff++;\n        pp->skip_rn = RN_Full;\n        pp->state = pp->dash_state;\n        goto AGAIN;\n      }\n      pp->state = PP_Error;\n      break;\n    }\n\n    /* main state engine */\n    switch (pp->state)\n    {\n    case PP_Error:\n      return MHD_NO;\n    case PP_Done:\n      /* did not expect to receive more data */\n      pp->state = PP_Error;\n      return MHD_NO;\n    case PP_Init:\n      /**\n       * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n       * prior to the first multipart boundary:\n       *\n       * > There appears to be room for additional information prior\n       * > to the first boundary delimiter line and following the\n       * > final boundary delimiter line.  These areas should\n       * > generally be left blank, and implementations must ignore\n       * > anything that appears before the first boundary delimiter\n       * > line or after the last one.\n       */\n      (void) find_boundary (pp,\n                            pp->boundary,\n                            pp->blen,\n                            &ioff,\n                            PP_ProcessEntryHeaders,\n                            PP_Done);\n      break;\n    case PP_NextBoundary:\n      if (MHD_NO == find_boundary (pp,\n                                   pp->boundary,\n                                   pp->blen,\n                                   &ioff,\n                                   PP_ProcessEntryHeaders,\n                                   PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_ProcessEntryHeaders:\n      pp->must_ikvi = true;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_PerformCheckMultipart))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_PerformCheckMultipart:\n      if ( (NULL != pp->content_type) &&\n           (MHD_str_equal_caseless_n_ (pp->content_type,\n                                       \"multipart/mixed\",\n                                       MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n      {\n        pp->nested_boundary = strstr (pp->content_type,\n                                      \"boundary=\");\n        if (NULL == pp->nested_boundary)\n        {\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        pp->nested_boundary =\n          strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n        if (NULL == pp->nested_boundary)\n        {\n          /* out of memory */\n          pp->state = PP_Error;\n          return MHD_NO;\n        }\n        /* free old content type, we will need that field\n           for the content type of the nested elements */\n        free (pp->content_type);\n        pp->content_type = NULL;\n        pp->nlen = strlen (pp->nested_boundary);\n        pp->state = PP_Nested_Init;\n        state_changed = 1;\n        break;\n      }\n      pp->state = PP_ProcessValueToBoundary;\n      pp->value_offset = 0;\n      state_changed = 1;\n      break;\n    case PP_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->boundary,\n                                               pp->blen,\n                                               PP_PerformCleanup,\n                                               PP_Done))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_PerformCleanup:\n      /* clean up state of one multipart form-data element! */\n      pp->have = NE_none;\n      free_unmarked (pp);\n      if (NULL != pp->nested_boundary)\n      {\n        free (pp->nested_boundary);\n        pp->nested_boundary = NULL;\n      }\n      pp->state = PP_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_Init:\n      if (NULL == pp->nested_boundary)\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      if (MHD_NO == find_boundary (pp,\n                                   pp->nested_boundary,\n                                   pp->nlen,\n                                   &ioff,\n                                   PP_Nested_PerformMarking,\n                                   PP_NextBoundary /* or PP_Error? */))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        goto END;\n      }\n      break;\n    case PP_Nested_PerformMarking:\n      /* remember what headers were given\n         globally */\n      pp->have = NE_none;\n      if (NULL != pp->content_name)\n        pp->have |= NE_content_name;\n      if (NULL != pp->content_type)\n        pp->have |= NE_content_type;\n      if (NULL != pp->content_filename)\n        pp->have |= NE_content_filename;\n      if (NULL != pp->content_transfer_encoding)\n        pp->have |= NE_content_transfer_encoding;\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessEntryHeaders:\n      pp->value_offset = 0;\n      if (MHD_NO ==\n          process_multipart_headers (pp,\n                                     &ioff,\n                                     PP_Nested_ProcessValueToBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        else\n          goto END;\n      }\n      state_changed = 1;\n      break;\n    case PP_Nested_ProcessValueToBoundary:\n      if (MHD_NO == process_value_to_boundary (pp,\n                                               &ioff,\n                                               pp->nested_boundary,\n                                               pp->nlen,\n                                               PP_Nested_PerformCleanup,\n                                               PP_NextBoundary))\n      {\n        if (pp->state == PP_Error)\n          return MHD_NO;\n        break;\n      }\n      break;\n    case PP_Nested_PerformCleanup:\n      free_unmarked (pp);\n      pp->state = PP_Nested_ProcessEntryHeaders;\n      state_changed = 1;\n      break;\n    case PP_ProcessKey:\n    case PP_ProcessValue:\n    case PP_Callback:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\nAGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }\n  }\nEND:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }\n  if (poff < post_data_len)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* serious error */\n  }\n  return MHD_YES;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_destroy_post_processor (struct MHD_PostProcessor *pp)\n{\n  enum MHD_Result ret;\n\n  if (NULL == pp)\n    return MHD_YES;\n  if (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n  /* These internal strings need cleaning up since\n     the post-processing may have been interrupted\n     at any stage */\n  if ( (pp->xbuf_pos > 0) ||\n       ( (pp->state != PP_Done) &&\n         (pp->state != PP_Init) ) )\n    ret = MHD_NO;\n  else\n    ret = MHD_YES;\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n    free (pp->nested_boundary);\n  free (pp);\n  return ret;\n}\n...\nstatic int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  if (newline == pp->buffer_size)\n  {\n    pp->state = PP_Error;\n    return MHD_NO;              /* out of memory */\n  }\n  if (newline == pp->buffer_pos)\n    return MHD_NO;              /* will need more data */\n  if (0 == newline)\n  {\n    /* empty line - end of headers */\n    pp->skip_rn = RN_Full;\n    pp->state = next_state;\n    return MHD_YES;\n  }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n  {\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"name\",\n                   &pp->content_name);\n    try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                   \"filename\",\n                   &pp->content_filename);\n  }\n  else\n  {\n    try_match_header (\"Content-type: \",\n                      MHD_STATICSTR_LEN_ (\"Content-type: \"),\n                      buf,\n                      &pp->content_type);\n    try_match_header (\"Content-Transfer-Encoding: \",\n                      MHD_STATICSTR_LEN_ (\"Content-Transfer-Encoding: \"),\n                      buf,\n                      &pp->content_transfer_encoding);\n  }\n  (*ioffptr) += newline + 1;\n  return MHD_YES;\n}\n...\nstatic int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n  {\n    while (newline + 4 < pp->buffer_pos)\n    {\n      r = memchr (&buf[newline],\n                  '\\r',\n                  pp->buffer_pos - newline - 4);\n      if (NULL == r)\n      {\n        newline = pp->buffer_pos - 4;\n        break;\n      }\n      newline = (size_t) (r - buf);\n      if (0 == memcmp (\"\\r\\n--\",\n                       &buf[newline],\n                       4))\n        break;\n      newline++;\n    }\n    if (newline + blen + 4 <= pp->buffer_pos)\n    {\n      /* can check boundary */\n      if (0 != memcmp (&buf[newline + 4],\n                       boundary,\n                       blen))\n      {\n        /* no boundary, \"\\r\\n--\" is part of content, skip */\n        newline += 4;\n        continue;\n      }\n      else\n      {\n        /* boundary found, process until newline then\n           skip boundary and go back to init */\n        pp->skip_rn = RN_Dash;\n        pp->state = next_state;\n        pp->dash_state = next_dash_state;\n        (*ioffptr) += blen + 4;             /* skip boundary as well */\n        buf[newline] = '\\0';\n        break;\n      }\n    }\n    else\n    {\n      /* cannot check for boundary, process content that\n         we have and check again later; except, if we have\n         no content, abort (out of memory) */\n      if ( (0 == newline) &&\n           (pp->buffer_pos == pp->buffer_size) )\n      {\n        pp->state = PP_Error;\n        return MHD_NO;\n      }\n      break;\n    }\n  }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (pp->must_ikvi) ||\n         (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n                            MHD_POSTDATA_KIND,\n                            pp->content_name,\n                            pp->content_filename,\n                            pp->content_type,\n                            pp->content_transfer_encoding,\n                            buf,\n                            pp->value_offset,\n                            newline)) )\n  {\n    pp->state = PP_Error;\n    return MHD_NO;\n  }\n  pp->must_ikvi = false;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n  return MHD_YES;\n}\n...\nstatic enum MHD_Result\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n                         size_t post_data_len)\n{\n  char *kbuf = (char *) &pp[1];\n  size_t poff;\n  const char *start_key = NULL;\n  const char *end_key = NULL;\n  const char *start_value = NULL;\n  const char *end_value = NULL;\n  const char *last_escape = NULL;\n\n  mhd_assert (PP_Callback != pp->state);\n\n  poff = 0;\n  while ( ( (poff < post_data_len) ||\n            (pp->state == PP_Callback) ) &&\n          (pp->state != PP_Error) )\n  {\n    switch (pp->state)\n    {\n    case PP_Error:\n      /* clearly impossible as per while loop invariant */\n      abort ();\n      break; /* Unreachable */\n    case PP_Init:\n      /* initial phase */\n      mhd_assert (NULL == start_key);\n      mhd_assert (NULL == end_key);\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: (no key)'=' */\n        /* Empty key with value */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* Case: (no key)'&' */\n        /* Empty key without value */\n        poff++;\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: (no key)'\\n' or (no key)'\\r' */\n        pp->state = PP_Done;\n        poff++;\n        break;\n      default:\n        /* normal character, key start, advance! */\n        pp->state = PP_ProcessKey;\n        start_key = &post_data[poff];\n        pp->must_ikvi = true;\n        poff++;\n        continue;\n      }\n      break; /* end PP_Init */\n    case PP_ProcessKey:\n      /* key phase */\n      mhd_assert (NULL == start_value);\n      mhd_assert (NULL == end_value);\n      mhd_assert (NULL != start_key || 0 == poff);\n      mhd_assert (0 != poff || NULL == start_key);\n      mhd_assert (NULL == end_key);\n      switch (post_data[poff])\n      {\n      case '=':\n        /* Case: 'key=' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_ProcessValue;\n        break;\n      case '&':\n        /* Case: 'key&' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        poff++;\n        pp->state = PP_Callback;\n        break;\n      case '\\n':\n      case '\\r':\n        /* Case: 'key\\n' or 'key\\r' */\n        if (0 != poff)\n          end_key = &post_data[poff];\n        /* No advance here, 'PP_Done' will be selected by next 'PP_Init' phase */\n        pp->state = PP_Callback;\n        break;\n      default:\n        /* normal character, advance! */\n        if (0 == poff)\n          start_key = post_data;\n        poff++;\n        break;\n      }\n      mhd_assert (NULL == end_key || NULL != start_key);\n      break; /* end PP_ProcessKey */\n    case PP_ProcessValue:\n      if (NULL == start_value)\n        start_value = &post_data[poff];\n      switch (post_data[poff])\n      {\n      case '=':\n        /* case 'key==' */\n        pp->state = PP_Error;\n        continue;\n      case '&':\n        /* case 'value&' */\n        end_value = &post_data[poff];\n        poff++;\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n        {\n          pp->state = PP_Callback;\n        }\n        else\n        {\n          pp->buffer_pos = 0;\n          pp->value_offset = 0;\n          pp->state = PP_Init;\n          start_value = NULL;\n          end_value = NULL;\n        }\n        continue;\n      case '\\n':\n      case '\\r':\n        /* Case: 'value\\n' or 'value\\r' */\n        end_value = &post_data[poff];\n        if (pp->must_ikvi ||\n            (start_value != end_value) )\n          pp->state = PP_Callback; /* No poff advance here to set PP_Done in the next iteration */\n        else\n        {\n          poff++;\n          pp->state = PP_Done;\n        }\n        break;\n      case '%':\n        last_escape = &post_data[poff];\n        poff++;\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        /* character, may be part of escaping */\n        poff++;\n        continue;\n      default:\n        /* normal character, no more escaping! */\n        last_escape = NULL;\n        poff++;\n        continue;\n      }\n      break; /* end PP_ProcessValue */\n    case PP_Done:\n      switch (post_data[poff])\n      {\n      case '\\n':\n      case '\\r':\n        poff++;\n        continue;\n      }\n      /* unexpected data at the end, fail! */\n      pp->state = PP_Error;\n      break;\n    case PP_Callback:\n      mhd_assert ((NULL != end_key) || (NULL == start_key));\n      if (1)\n      {\n        const size_t key_len = (size_t) (end_key - start_key);\n        mhd_assert (end_key >= start_key);\n        if (0 != key_len)\n        {\n          if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n               (pp->buffer_pos + key_len < pp->buffer_pos) )\n          {\n            /* key too long, cannot parse! */\n            pp->state = PP_Error;\n            continue;\n          }\n          /* compute key, if we have not already */\n          memcpy (&kbuf[pp->buffer_pos],\n                  start_key,\n                  key_len);\n          pp->buffer_pos += key_len;\n          start_key = NULL;\n          end_key = NULL;\n          pp->must_unescape_key = true;\n        }\n      }\n#ifdef _DEBUG\n      else\n        mhd_assert (0 != pp->buffer_pos);\n#endif /* _DEBUG */\n      if (pp->must_unescape_key)\n      {\n        kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n        MHD_unescape_plus (kbuf);\n        MHD_http_unescape (kbuf);\n        pp->must_unescape_key = false;\n      }\n      process_value (pp,\n                     start_value,\n                     end_value,\n                     NULL);\n      if (PP_Error == pp->state)\n        continue;\n      pp->value_offset = 0;\n      start_value = NULL;\n      end_value = NULL;\n      pp->buffer_pos = 0;\n      pp->state = PP_Init;\n      break;\n    case PP_NextBoundary:\n    case PP_ProcessEntryHeaders:\n    case PP_PerformCheckMultipart:\n    case PP_ProcessValueToBoundary:\n    case PP_PerformCleanup:\n    case PP_Nested_Init:\n    case PP_Nested_PerformMarking:\n    case PP_Nested_ProcessEntryHeaders:\n    case PP_Nested_ProcessValueToBoundary:\n    case PP_Nested_PerformCleanup:\n    default:\n      MHD_PANIC (_ (\"internal error.\\n\")); /* should never happen! */\n    }\n    mhd_assert ((end_key == NULL) || (start_key != NULL));\n    mhd_assert ((end_value == NULL) || (start_value != NULL));\n  }\n\n  mhd_assert (PP_Callback != pp->state);\n\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n\n  /* save remaining data for next iteration */\n  if (NULL != start_key)\n  {\n    size_t key_len;\n    mhd_assert ((PP_ProcessKey == pp->state) || (NULL != end_key));\n    if (NULL == end_key)\n      end_key = &post_data[poff];\n    mhd_assert (end_key >= start_key);\n    key_len = (size_t) (end_key - start_key);\n    mhd_assert (0 != key_len); /* it must be always non-zero here */\n    if (pp->buffer_pos + key_len >= pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;\n    }\n    memcpy (&kbuf[pp->buffer_pos],\n            start_key,\n            key_len);\n    pp->buffer_pos += key_len;\n    pp->must_unescape_key = true;\n    start_key = NULL;\n    end_key = NULL;\n  }\n  if ( (NULL != start_value) &&\n       (PP_ProcessValue == pp->state) )\n  {\n    /* compute key, if we have not already */\n    if (pp->must_unescape_key)\n    {\n      kbuf[pp->buffer_pos] = '\\0'; /* 0-terminate key */\n      MHD_unescape_plus (kbuf);\n      MHD_http_unescape (kbuf);\n      pp->must_unescape_key = false;\n    }\n    if (NULL == end_value)\n      end_value = &post_data[poff];\n    if ( (NULL != last_escape) &&\n         (2 < (end_value - last_escape)) )\n      last_escape = NULL;\n    process_value (pp,\n                   start_value,\n                   end_value,\n                   last_escape);\n    pp->must_ikvi = false;\n  }\n  if (PP_Error == pp->state)\n  {\n    /* State in error, returning failure */\n    return MHD_NO;\n  }\n  return MHD_YES;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_post_process (struct MHD_PostProcessor *pp,\n                  const char *post_data,\n                  size_t post_data_len)\n{\n  if (0 == post_data_len)\n    return MHD_YES;\n  if (NULL == pp)\n    return MHD_NO;\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n    return post_process_urlencoded (pp,\n                                    post_data,\n                                    post_data_len);\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n    return post_process_multipart (pp,\n                                   post_data,\n                                   post_data_len);\n  /* this should never be reached */\n  return MHD_NO;\n}\n...\n_MHD_EXTERN struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    MHD_PANIC (_ (\"libmicrohttpd API violation.\\n\"));\n  encoding = NULL;\n  if (MHD_NO ==\n      MHD_lookup_connection_value_n (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_CONTENT_TYPE,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_HEADER_CONTENT_TYPE),\n                                     &encoding,\n                                     NULL))\n    return NULL;\n  mhd_assert (NULL != encoding);\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (\n                                     MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n  {\n    if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                     encoding,\n                                     MHD_STATICSTR_LEN_ (\n                                       MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n      return NULL;\n    boundary =\n      &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n    /* Q: should this be \"strcasestr\"? */\n    boundary = strstr (boundary, \"boundary=\");\n    if (NULL == boundary)\n      return NULL; /* failed to determine boundary */\n    boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n    blen = strlen (boundary);\n    if ( (blen < 2) ||\n         (blen * 2 + 2 > buffer_size) )\n      return NULL;              /* (will be) out of memory or invalid boundary */\n    if ( (boundary[0] == '\"') &&\n         (boundary[blen - 1] == '\"') )\n    {\n      /* remove enclosing quotes */\n      ++boundary;\n      blen -= 2;\n    }\n  }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor)\n                                  + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "static void\nfree_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n  {\n    free (pp->content_name);\n    pp->content_name = NULL;\n  }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n  {\n    free (pp->content_type);\n    pp->content_type = NULL;\n  }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n  {\n    free (pp->content_filename);\n    pp->content_filename = NULL;\n  }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n  {\n    free (pp->content_transfer_encoding);\n    pp->content_transfer_encoding = NULL;\n  }\n}",
    "AGAIN:\n    if (ioff > 0)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n      ioff = 0;\n      state_changed = 1;\n    }",
    "case PP_PerformCleanup:\n  /* clean up state of one multipart form-data element! */\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n  {\n    free (pp->nested_boundary);\n    pp->nested_boundary = NULL;\n  }\n  pp->state = PP_ProcessEntryHeaders;\n  state_changed = 1;\n  break;",
    "_MHD_EXTERN enum MHD_Result\nMHD_destroy_post_processor (struct MHD_PostProcessor *pp)\n{\n  enum MHD_Result ret;\n\n  if (NULL == pp)\n    return MHD_YES;\n  if (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n  /* These internal strings need cleaning up since\n     the post-processing may have been interrupted\n     at any stage */\n  if ( (pp->xbuf_pos > 0) ||\n       ( (pp->state != PP_Done) &&\n         (pp->state != PP_Init) ) )\n    ret = MHD_NO;\n  else\n    ret = MHD_YES;\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n    free (pp->nested_boundary);\n  free (pp);\n  return ret;\n}",
    "_MHD_EXTERN enum MHD_Result\nMHD_post_process (struct MHD_PostProcessor *pp,\n                  const char *post_data,\n                  size_t post_data_len)\n{\n  if (0 == post_data_len)\n    return MHD_YES;\n  if (NULL == pp)\n    return MHD_NO;\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n    return post_process_urlencoded (pp,\n                                    post_data,\n                                    post_data_len);\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n    return post_process_multipart (pp,\n                                   post_data,\n                                   post_data_len);\n  /* this should never be reached */\n  return MHD_NO;\n}",
    "case PP_Error:\n  /* clearly impossible as per while loop invariant */\n  abort ();\n  break; /* Unreachable */",
    "END:\n  if (0 != ioff)\n  {\n    memmove (buf,\n             &buf[ioff],\n             pp->buffer_pos - ioff);\n    pp->buffer_pos -= ioff;\n  }",
    "case PP_Callback:\n  mhd_assert ((NULL != end_key) || (NULL == start_key));\n  if (1)\n  {\n    const size_t key_len = (size_t) (end_key - start_key);\n    mhd_assert (end_key >= start_key);\n    if (0 != key_len)\n    {\n      if ( (pp->buffer_pos + key_len >= pp->buffer_size) ||\n           (pp->buffer_pos + key_len < pp->buffer_pos) )\n      {\n        /* key too long, cannot parse! */\n        pp->state = PP_Error;\n        continue;\n      }\n      /* compute key, if we have not already */\n      memcpy (&kbuf[pp->buffer_pos],\n              start_key,\n              key_len);\n      pp->buffer_pos += key_len;\n      start_key = NULL;\n      end_key = NULL;\n      pp->must_unescape_key = true;\n    }\n  }\n#ifdef _DEBUG\n  else\n    mhd_assert (0 != pp->buffer_pos);\n#endif /* _DEBUG */"
  ],
  "explanation": "I report fragments that appear suspicious with respect to possible dead or redundant operations and therefore should be investigated for compliance with MISRA C 2023 Rule 2.2. Specifically:\n\n- free_unmarked and its call sites (PP_PerformCleanup and MHD_destroy_post_processor) are flagged because the code sets pp->have = NE_none immediately before calling free_unmarked in some places. That makes the '(0 == (pp->have & ...))' checks predictably true at those call sites; the interaction of the have flags across all call sites should be reviewed to ensure no freeing/conditional logic is redundant or inconsistent.\n\n- The two memmove blocks (at the AGAIN label and at END) are similar; while they may be correct for different control-flow paths, the duplication should be checked to ensure one is not redundant or always executed in a way that makes the other unnecessary.\n\n- The PP_Error case in post_process_urlencoded contains abort(); followed by a break with a comment /* Unreachable */. The presence of the break (or the comment) suggests unreachable code; while unreachable code is excluded from MISRA's dead-code definition, such constructs may indicate inconsistent control flow or vestigial statements that should be reviewed.\n\n- The PP_Callback 'if (1) { ... } #ifdef _DEBUG else ...' construct contains an unconditional if (1) and an #ifdef guarded else branch that is never selected in normal builds; this pattern is suspicious (the else is effectively dead in non-_DEBUG builds) and should be examined.\n\n- The final fallback in MHD_post_process is marked \"this should never be reached\" and returns MHD_NO. Any code paths that make that return reachable or that render it redundant should be validated.\n\nWhy other fragments were NOT reported:\n- State-machine fall-throughs (explicit /* fall-through! */ comments) and the switch/case constructs are intentional control-flow patterns for parsing multipart and urlencoded data; they are standard for parsers and are not by themselves dead code.\n- Many NULL checks, buffer-size checks, and error-path assignments (e.g. setting pp->state = PP_Error) are defensive programming to handle input and memory conditions; they are meaningful and used to affect subsequent behaviour, so they are not dead.\n- Calls that free memory only when pointers are non-NULL (and immediately NULL them) are standard safe-free patterns and are not dead unless shown to be provably redundant across all call sites; for free_unmarked I reported the function itself and its immediate call sites so the overall logic can be inspected together.\n- Repeated-looking constructs (e.g. initialization of local variables, temporary assignments) are kept out of the suspicious list where their usage is clearly necessary for control-flow across multiple loop iterations.\n\nIf you want, I can perform a more focused analysis to try to prove whether any of the flagged operations are provably redundant in all call contexts (i.e. actual dead code), or provide a control-flow/path analysis for each flagged fragment."
}