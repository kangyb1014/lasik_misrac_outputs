{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_add_connection:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_add_connection:\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n...\nstatic struct MHD_Connection *\nnew_connection_prepare_ (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n  int eno = 0;\n\n#ifdef HAVE_MESSAGES\n#if _MHD_DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _ (\"Accepted connection on socket %d.\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n  {\n    /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Server reached connection limit. \" \\\n                 \"Closing inbound connection.\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return NULL;\n  }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n                               (const struct sockaddr *) addr,\n                               addrlen)) )\n  {\n#if _MHD_DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n#if defined(EACCESS) && (EACCESS + 0 != 0)\n    errno = EACCESS;\n#endif\n    return NULL;\n  }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n  {\n    eno = errno;\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    errno = eno;\n    return NULL;\n  }\n\n  if (! external_add)\n  {\n    connection->sk_corked = _MHD_OFF;\n    connection->sk_nodelay = _MHD_OFF;\n  }\n  else\n  {\n    connection->sk_corked = _MHD_UNKNOWN;\n    connection->sk_nodelay = _MHD_UNKNOWN;\n  }\n\n  if (0 < addrlen)\n  {\n    if (NULL == (connection->addr = malloc ((size_t) addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Error allocating memory: %s\\n\"),\n                MHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n      errno = eno;\n      return NULL;\n    }\n    memcpy (connection->addr,\n            addr,\n            (size_t) addrlen);\n  }\n  else\n    connection->addr = NULL;\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->is_nonip = sk_is_nonip;\n  connection->sk_spipe_suppress = sk_spipe_supprs;\n#ifdef MHD_USE_THREADS\n  MHD_thread_handle_ID_set_invalid_ (&connection->tid);\n#endif /* MHD_USE_THREADS */\n  connection->daemon = daemon;\n  connection->connection_timeout_ms = daemon->connection_timeout_ms;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n  if (0 != connection->connection_timeout_ms)\n    connection->last_activity = MHD_monotonic_msec_counter ();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n  {\n    /* set default connection handlers  */\n    MHD_set_http_callbacks_ (connection);\n  }\n  else\n  {\n#ifdef HTTPS_SUPPORT\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030500)\n    gnutls_init_flags_t\n#else\n    unsigned int\n#endif\n    flags;\n\n    flags = GNUTLS_SERVER;\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030402)\n    flags |= GNUTLS_NO_SIGNAL;\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n    flags |= GNUTLS_NONBLOCK;\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030603)\n    if (0 != (daemon->options & MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT))\n      flags |= GNUTLS_POST_HANDSHAKE_AUTH;\n#endif\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030605)\n    if (0 != (daemon->options & MHD_USE_INSECURE_TLS_EARLY_DATA))\n      flags |= GNUTLS_ENABLE_EARLY_DATA;\n#endif\n    connection->tls_state = MHD_TLS_CONN_INIT;\n    MHD_set_https_callbacks (connection);\n    if ((GNUTLS_E_SUCCESS != gnutls_init (&connection->tls_session, flags)) ||\n        (GNUTLS_E_SUCCESS != gnutls_priority_set (connection->tls_session,\n                                                  daemon->priority_cache)))\n    {\n      if (NULL != connection->tls_session)\n        gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to initialise TLS session.\\n\"));\n#endif\n#if defined(EPROTO) && (EPROTO + 0 != 0)\n      errno = EPROTO;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030200)\n    if (! daemon->disable_alpn)\n    {\n      static const char prt1[] = \"http/1.1\"; /* Registered code for HTTP/1.1 */\n      static const char prt2[] = \"http/1.0\"; /* Registered code for HTTP/1.0 */\n      static const gnutls_datum_t prts[2] =\n      { {_MHD_DROP_CONST (prt1), MHD_STATICSTR_LEN_ (prt1)},\n        {_MHD_DROP_CONST (prt2), MHD_STATICSTR_LEN_ (prt2)} };\n\n      if (GNUTLS_E_SUCCESS !=\n          gnutls_alpn_set_protocols (connection->tls_session,\n                                     prts,\n                                     sizeof(prts) / sizeof(prts[0]),\n                                     0 /* | GNUTLS_ALPN_SERVER_PRECEDENCE */))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"Failed to set ALPN protocols.\\n\"));\n#else  /* ! HAVE_MESSAGES */\n        (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n      }\n    }\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030200 */\n    gnutls_session_set_ptr (connection->tls_session,\n                            connection);\n    switch (daemon->cred_type)\n    {\n    /* set needed credentials for certificate authentication. */\n    case GNUTLS_CRD_CERTIFICATE:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_CERTIFICATE,\n                              daemon->x509_cred);\n      break;\n    case GNUTLS_CRD_PSK:\n      gnutls_credentials_set (connection->tls_session,\n                              GNUTLS_CRD_PSK,\n                              daemon->psk_cred);\n      gnutls_psk_set_server_credentials_function (daemon->psk_cred,\n                                                  &psk_gnutls_adapter);\n      break;\n    case GNUTLS_CRD_ANON:\n    case GNUTLS_CRD_SRP:\n    case GNUTLS_CRD_IA:\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to setup TLS credentials: \" \\\n                   \"unknown credential type %d.\\n\"),\n                daemon->cred_type);\n#endif\n      gnutls_deinit (connection->tls_session);\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      if (NULL != connection->addr)\n        free (connection->addr);\n      free (connection);\n      MHD_PANIC (_ (\"Unknown credential type.\\n\"));\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n      errno = EINVAL;\n#endif\n      return NULL;\n    }\n#if (GNUTLS_VERSION_NUMBER + 0 >= 0x030109) && ! defined(_WIN64)\n    gnutls_transport_set_int (connection->tls_session,\n                              (int) (client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n    gnutls_transport_set_ptr (connection->tls_session,\n                              (gnutls_transport_ptr_t) \\\n                              (intptr_t) client_socket);\n#endif /* GnuTLS before 3.1.9 or Win x64 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n    gnutls_transport_set_push_function (connection->tls_session,\n                                        MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n    if (daemon->https_mem_trust)\n      gnutls_certificate_server_set_request (connection->tls_session,\n                                             GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n    MHD_socket_close_chk_ (client_socket);\n    MHD_ip_limit_del (daemon,\n                      addr,\n                      addrlen);\n    free (connection->addr);\n    free (connection);\n    MHD_PANIC (_ (\"TLS connection on non-TLS daemon.\\n\"));\n#if 0\n    /* Unreachable code */\n    eno = EINVAL;\n    return NULL;\n#endif\n#endif /* ! HTTPS_SUPPORT */\n  }\n\n  return connection;\n}\n...\nstatic enum MHD_Result\nnew_connection_process_ (struct MHD_Daemon *daemon,\n                         struct MHD_Connection *connection)\n{\n  int eno = 0;\n\n  mhd_assert (connection->daemon == daemon);\n\n#ifdef MHD_USE_THREADS\n  /* Function manipulate connection and timeout DL-lists,\n   * must be called only within daemon thread. */\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n#endif /* MHD_USE_THREADS */\n\n  /* Allocate memory pool in the processing thread so\n   * intensively used memory area is allocated in \"good\"\n   * (for the thread) memory region. It is important with\n   * NUMA and/or complex cache hierarchy. */\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n  { /* 'pool' creation failed */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Error allocating memory: %s\\n\"),\n              MHD_strerror_ (errno));\n#endif\n#if defined(ENOMEM) && (ENOMEM + 0 != 0)\n    eno = ENOMEM;\n#endif\n    (void) 0; /* Mute possible compiler warning */\n  }\n  else\n  { /* 'pool' creation succeed */\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n    /* Firm check under lock. */\n    if (daemon->connections >= daemon->connection_limit)\n    { /* Connections limit */\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Server reached connection limit. \"\n                   \"Closing inbound connection.\\n\"));\n#endif\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n      eno = ENFILE;\n#endif\n      (void) 0; /* Mute possible compiler warning */\n    }\n    else\n    { /* Have space for new connection */\n      daemon->connections++;\n      DLL_insert (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_insert (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      MHD_connection_set_initial_state_ (connection);\n\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_STARTED);\n#ifdef MHD_USE_THREADS\n      if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        mhd_assert (! MHD_D_IS_USING_EPOLL_ (daemon));\n        if (! MHD_create_named_thread_ (&connection->tid,\n                                        \"MHD-connection\",\n                                        daemon->thread_stack_size,\n                                        &thread_main_handle_connection,\n                                        connection))\n        {\n          eno = errno;\n#ifdef HAVE_MESSAGES\n#ifdef EAGAIN\n          if (EAGAIN == eno)\n            MHD_DLOG (daemon,\n                      _ (\"Failed to create a new thread because it would \"\n                         \"have exceeded the system limit on the number of \"\n                         \"threads or no system resources available.\\n\"));\n          else\n#endif /* EAGAIN */\n          MHD_DLOG (daemon,\n                    _ (\"Failed to create a thread: %s\\n\"),\n                    MHD_strerror_ (eno));\n#endif /* HAVE_MESSAGES */\n        }\n        else               /* New thread has been created successfully */\n          return MHD_YES;  /* *** Function success exit point *** */\n      }\n      else\n#else  /* ! MHD_USE_THREADS */\n      if (1)\n#endif /* ! MHD_USE_THREADS */\n      { /* No 'thread-per-connection' */\n#ifdef MHD_USE_THREADS\n        connection->tid = daemon->tid;\n#endif /* MHD_USE_THREADS */\n#ifdef EPOLL_SUPPORT\n        if (MHD_D_IS_USING_EPOLL_ (daemon))\n        {\n          if (0 == (daemon->options & MHD_USE_TURBO))\n          {\n            struct epoll_event event;\n\n            event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET | EPOLLRDHUP;\n            event.data.ptr = connection;\n            if (0 != epoll_ctl (daemon->epoll_fd,\n                                EPOLL_CTL_ADD,\n                                connection->socket_fd,\n                                &event))\n            {\n              eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _ (\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n            else\n            { /* 'socket_fd' has been added to 'epool' */\n              connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\n              return MHD_YES;  /* *** Function success exit point *** */\n            }\n          }\n          else\n          {\n            connection->epoll_state |= MHD_EPOLL_STATE_READ_READY\n                                       | MHD_EPOLL_STATE_WRITE_READY\n                                       | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            EDLL_insert (daemon->eready_head,\n                         daemon->eready_tail,\n                         connection);\n\n            return MHD_YES;  /* *** Function success exit point *** */\n          }\n        }\n        else /* No 'epoll' */\n#endif /* EPOLL_SUPPORT */\n        return MHD_YES;    /* *** Function success exit point *** */\n      }\n\n      /* ** Below is a cleanup path ** */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   connection,\n                                   &connection->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if (! MHD_D_IS_USING_THREAD_PER_CONN_ (daemon))\n      {\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n      daemon->connections--;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    }\n    MHD_pool_destroy (connection->pool);\n  }\n  /* Free resources allocated before the call of this functions */\n#ifdef HTTPS_SUPPORT\n  if (NULL != connection->tls_session)\n    gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_ip_limit_del (daemon,\n                    connection->addr,\n                    connection->addr_len);\n  if (NULL != connection->addr)\n    free (connection->addr);\n  MHD_socket_close_chk_ (connection->socket_fd);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n#ifdef EINVAL\n  else\n    errno = EINVAL;\n#endif /* EINVAL */\n  return MHD_NO;  /* *** Function failure exit point *** */\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nunsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n```\nFocus on the above code fragment and judge whether it violates the rule 14.2 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The for loop \"for (i = 0; i < daemon->worker_pool_size; ++i)\" is well-formed: the first clause initializes the single loop counter i; the second clause is a side-effect-free comparison using only i and daemon->worker_pool_size (which is not modified in the loop body); the third clause ++i modifies only the loop counter. No other object used in the second or third clause is modified by the loop body or by called functions (internal_add_connection does not alter worker_pool_size)."
}