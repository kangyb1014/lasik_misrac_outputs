{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_add_connection:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_add_connection:\nstatic void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               MHD_thread_handle_ID_is_current_thread_ (daemon->tid) );\n  mhd_assert (NULL == daemon->worker_pool);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n  while (NULL != (pos = daemon->cleanup_tail))\n  {\n    DLL_remove (daemon->cleanup_head,\n                daemon->cleanup_tail,\n                pos);\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n    if (MHD_D_IS_USING_THREAD_PER_CONN_ (daemon) &&\n        (! pos->thread_joined) &&\n        (! MHD_thread_handle_ID_join_thread_ (pos->tid)) )\n      MHD_PANIC (_ (\"Failed to join a thread.\\n\"));\n#endif\n#ifdef UPGRADE_SUPPORT\n    cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n    MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n    if (NULL != pos->tls_session)\n      gnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n    /* clean up the connection */\n    if (NULL != daemon->notify_connection)\n      daemon->notify_connection (daemon->notify_connection_cls,\n                                 pos,\n                                 &pos->socket_context,\n                                 MHD_CONNECTION_NOTIFY_CLOSED);\n    MHD_ip_limit_del (daemon,\n                      pos->addr,\n                      pos->addr_len);\n#ifdef EPOLL_SUPPORT\n    if (MHD_D_IS_USING_EPOLL_ (daemon))\n    {\n      if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n      {\n        EDLL_remove (daemon->eready_head,\n                     daemon->eready_tail,\n                     pos);\n        pos->epoll_state &=\n          ~((enum MHD_EpollState) MHD_EPOLL_STATE_IN_EREADY_EDLL);\n      }\n      if ( (-1 != daemon->epoll_fd) &&\n           (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n      {\n        /* epoll documentation suggests that closing a FD\n           automatically removes it from the epoll set; however,\n           this is not true as if we fail to do manually remove it,\n           we are still seeing an event for this fd in epoll,\n           causing grief (use-after-free...) --- at least on my\n           system. */\n        if (0 != epoll_ctl (daemon->epoll_fd,\n                            EPOLL_CTL_DEL,\n                            pos->socket_fd,\n                            NULL))\n          MHD_PANIC (_ (\"Failed to remove FD from epoll set.\\n\"));\n        pos->epoll_state &=\n          ~((enum MHD_EpollState)\n            MHD_EPOLL_STATE_IN_EPOLL_SET);\n      }\n    }\n#endif\n    if (NULL != pos->rp.response)\n    {\n      MHD_destroy_response (pos->rp.response);\n      pos->rp.response = NULL;\n    }\n    if (MHD_INVALID_SOCKET != pos->socket_fd)\n      MHD_socket_close_chk_ (pos->socket_fd);\n    if (NULL != pos->addr)\n      free (pos->addr);\n    free (pos);\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n    daemon->connections--;\n    daemon->at_limit = false;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#endif\n}\n...\nstatic enum MHD_Result\ninternal_add_connection (struct MHD_Daemon *daemon,\n                         MHD_socket client_socket,\n                         const struct sockaddr_storage *addr,\n                         socklen_t addrlen,\n                         bool external_add,\n                         bool non_blck,\n                         bool sk_spipe_supprs,\n                         enum MHD_tristate sk_is_nonip)\n{\n  struct MHD_Connection *connection;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n\n  if (MHD_D_IS_USING_SELECT_ (daemon) &&\n      (! MHD_D_DOES_SCKT_FIT_FDSET_ (client_socket, daemon)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"New connection socket descriptor (%d) is not less \" \\\n                 \"than FD_SETSIZE (%d).\\n\"),\n              (int) client_socket,\n              (int) MHD_D_GET_FD_SETSIZE_ (daemon));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n\n  if (MHD_D_IS_USING_EPOLL_ (daemon) &&\n      (! non_blck) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Epoll mode supports only non-blocking sockets\\n\"));\n#endif\n    MHD_socket_close_chk_ (client_socket);\n#if defined(EINVAL) && (EINVAL + 0 != 0)\n    errno = EINVAL;\n#endif\n    return MHD_NO;\n  }\n\n  connection = new_connection_prepare_ (daemon,\n                                        client_socket,\n                                        addr, addrlen,\n                                        external_add,\n                                        non_blck,\n                                        sk_spipe_supprs,\n                                        sk_is_nonip);\n  if (NULL == connection)\n    return MHD_NO;\n\n  if ((external_add) &&\n      MHD_D_IS_THREAD_SAFE_ (daemon))\n  {\n    /* Connection is added externally and MHD is thread safe mode. */\n    MHD_mutex_lock_chk_ (&daemon->new_connections_mutex);\n    DLL_insert (daemon->new_connections_head,\n                daemon->new_connections_tail,\n                connection);\n    daemon->have_new = true;\n    MHD_mutex_unlock_chk_ (&daemon->new_connections_mutex);\n\n    /* The rest of connection processing must be handled in\n     * the daemon thread. */\n    if ((MHD_ITC_IS_VALID_ (daemon->itc)) &&\n        (! MHD_itc_activate_ (daemon->itc, \"n\")))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Failed to signal new connection via inter-thread \" \\\n                   \"communication channel.\\n\"));\n#endif\n    }\n    return MHD_YES;\n  }\n\n  return new_connection_process_ (daemon, connection);\n}\n...\n#define MHD_D_IS_THREAD_SAFE_(d) (0==((d)->options&MHD_USE_NO_THREAD_SAFETY))\n...\n#define MHD_D_IS_USING_THREADS_(d) (0!=(d->options&(MHD_USE_INTERNAL_POLLING_THREAD)))\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nint\nMHD_socket_nonblocking_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFL);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | O_NONBLOCK) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFL,\n                    flags | O_NONBLOCK)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        (int) FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n...\n#define MHD_socket_get_error_ (errno)\n...\n#define MHD_socket_close_(fd) ((0==close((fd)))||(EBADF!=errno))\n...\n#define MHD_socket_fset_error_(err) (errno=(err))\n...\nint\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE) sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return ! 0;\n}\n...\n#define MHD_socket_close_chk_(fd) do{if(!MHD_socket_close_(fd))MHD_PANIC(_(\"Close socket failed.\\n\"));\\\n}while(0)\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /* Direct add to master daemon could never happen. */\n  mhd_assert (NULL == daemon->worker_pool);\n#endif\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the fragment is under conditional compilation and is compiled only when MHD_USE_POSIX_THREADS or MHD_USE_W32_THREADS is defined. The mhd_assert(...) is a runtime (or macro) check and not statically unreachable code. If the macros are not defined the preprocessor removes the code (not an unreachable-code violation). Therefore Rule 2.1 is not violated."
}