{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_add_connection:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  bool sk_spipe_supprs;\n  struct sockaddr_storage addrstorage;\n\n  /* TODO: fix atomic value reading */\n  if ((! MHD_D_IS_THREAD_SAFE_ (daemon)) &&\n      (daemon->connection_limit <= daemon->connections))\n    MHD_cleanup_connections (daemon);\n\n#ifdef HAVE_MESSAGES\n  if (MHD_D_IS_USING_THREADS_ (daemon) &&\n      (0 == (daemon->options & MHD_USE_ITC)))\n  {\n    MHD_DLOG (daemon,\n              _ (\"MHD_add_connection() has been called for daemon started\"\n                 \" without MHD_USE_ITC flag.\\nDaemon will not process newly\"\n                 \" added connection until any activity occurs in already\"\n                 \" added sockets.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n  if (0 != addrlen)\n  {\n    if (AF_INET == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_INET6\n    if (AF_INET6 == addr->sa_family)\n    {\n      if (sizeof(struct sockaddr_in6) > (size_t) addrlen)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \"\n                     \"incorrect 'addrlen' value.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      if ((0 != addr->sa_len) &&\n          (sizeof(struct sockaddr_in6) > (size_t) addr->sa_len) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _ (\"MHD_add_connection() has been called with \" \\\n                     \"non-zero value of 'sa_len' member of \" \\\n                     \"'struct sockaddr' which does not match 'sa_family'.\\n\"));\n#endif /* HAVE_MESSAGES */\n        return MHD_NO;\n      }\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n    }\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n    if ((0 != addr->sa_len) &&\n        (addrlen > addr->sa_len))\n      addrlen = (socklen_t) addr->sa_len;   /* Use safest value */\n#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */\n#endif /* HAVE_INET6 */\n  }\n\n  if (! MHD_socket_nonblocking_ (client_socket))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#endif\n    sk_nonbl = false;\n  }\n  else\n    sk_nonbl = true;\n\n#ifndef MHD_WINSOCK_SOCKETS\n  sk_spipe_supprs = false;\n#else  /* MHD_WINSOCK_SOCKETS */\n  sk_spipe_supprs = true; /* Nothing to suppress on W32 */\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(MHD_socket_nosignal_)\n  if (! sk_spipe_supprs)\n    sk_spipe_supprs = MHD_socket_nosignal_ (client_socket);\n  if (! sk_spipe_supprs)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to suppress SIGPIPE on new client socket: %s\\n\"),\n              MHD_socket_last_strerr_ ());\n#else  /* ! HAVE_MESSAGES */\n    (void) 0; /* Mute compiler warning */\n#endif /* ! HAVE_MESSAGES */\n#ifndef MSG_NOSIGNAL\n    /* Application expects that SIGPIPE will be suppressed,\n     * but suppression failed and SIGPIPE cannot be suppressed with send(). */\n    if (! daemon->sigpipe_blocked)\n    {\n      int err = MHD_socket_get_error_ ();\n      MHD_socket_close_ (client_socket);\n      MHD_socket_fset_error_ (err);\n      return MHD_NO;\n    }\n#endif /* MSG_NOSIGNAL */\n  }\n#endif /* MHD_socket_nosignal_ */\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n  }\n\n  /* Copy to sockaddr_storage structure to avoid alignment problems */\n  if (0 < addrlen)\n    memcpy (&addrstorage, addr, (size_t) addrlen);\n#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  addrstorage.ss_len = addrlen; /* Force set the right length */\n#endif /* HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if (NULL != daemon->worker_pool)\n  {\n    unsigned int i;\n    /* have a pool, try to find a pool with capacity; we use the\n       socket as the initial offset into the pool for load\n       balancing */\n    for (i = 0; i < daemon->worker_pool_size; ++i)\n    {\n      struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];\n      if (worker->connections < worker->connection_limit)\n        return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);\n    }\n    /* all pools are at their connection limit, must refuse */\n    MHD_socket_close_chk_ (client_socket);\n#if defined(ENFILE) && (ENFILE + 0 != 0)\n    errno = ENFILE;\n#endif\n    return MHD_NO;\n  }\n#endif /* MHD_USE_POSIX_THREADS || MHD_USE_W32_THREADS */\n\n  return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);\n}\n```\n</target_code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "MHD_add_connection (struct MHD_Daemon *daemon,\n                    MHD_socket client_socket,\n                    const struct sockaddr *addr,\n                    socklen_t addrlen)",
    "struct MHD_Daemon *const worker =\n        &daemon->worker_pool[(i + (unsigned int) client_socket)\n                             % daemon->worker_pool_size];",
    "return internal_add_connection (worker,\n                                        client_socket,\n                                        &addrstorage,\n                                        addrlen,\n                                        true,\n                                        sk_nonbl,\n                                        sk_spipe_supprs,\n                                        _MHD_UNKNOWN);",
    "return internal_add_connection (daemon,\n                                  client_socket,\n                                  &addrstorage,\n                                  addrlen,\n                                  true,\n                                  sk_nonbl,\n                                  sk_spipe_supprs,\n                                  _MHD_UNKNOWN);",
    "memcpy (&addrstorage, addr, (size_t) addrlen);"
  ],
  "explanation": "I focused on places where pointers to non-const data are created or passed and where it is plausible the pointed-to data need not be modified (i.e. candidates for const qualification under MISRA C:2023 Rule 8.13). The items not listed as suspicious were reviewed and excluded for the following reasons:\n\n- The parameter addr is already a pointer-to-const (const struct sockaddr *addr), so it complies with the rule and does not need investigation.\n- Calls and checks that only read members via the const addr (e.g. addr->sa_family, addr->sa_len) are already using a const-qualified pointer and therefore are not suspicious.\n- Socket-handling and logging calls that take or use daemon as a non-const pointer (for example MHD_cleanup_connections(daemon), MHD_DLOG(daemon,...), MHD_socket_close_(client_socket)) likely need to modify or pass daemon to routines that modify state; thus making those pointers-to-const would be inappropriate and are not flagged.\n- The local variable addrstorage is a mutable storage area intended to be written (memcpy into it), so uses of its address as a non-const destination for memcpy are expected; the only question is whether callees that receive &addrstorage could have used a const pointer instead \u2014 those call sites are included in the suspicious list.\n- The worker pointer is declared as a const pointer (pointer value unmodifiable) to a non-const MHD_Daemon; it is used to test and then passed to internal_add_connection, which very likely mutates the worker or requires non-const access. It is included because it is a candidate for review to confirm whether internal_add_connection actually needs a non-const pointer or could accept a pointer-to-const.\n\nIn short, I included all places where non-const pointers are created/passed and where it is plausible that const qualification could be applied (function signature, memcpy destination/read, and calls passing &addrstorage and worker). Other pointer uses either are already const or are clearly intended to be mutable and thus were not included."
}