{
  "user_message": "An agent A claimed that the following MHD_init code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_init.\n```c\nvoid\nMHD_init (void)\n{\n#if defined(MHD_WINSOCK_SOCKETS)\n  WSADATA wsd;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  MHD_set_panic_func (NULL, NULL);\n\n#if defined(MHD_WINSOCK_SOCKETS)\n  if (0 != WSAStartup (MAKEWORD (2, 2), &wsd))\n    MHD_PANIC (_ (\"Failed to initialize winsock.\\n\"));\n  if ((2 != LOBYTE (wsd.wVersion)) && (2 != HIBYTE (wsd.wVersion)))\n    MHD_PANIC (_ (\"Winsock version 2.2 is not available.\\n\"));\n#endif /* MHD_WINSOCK_SOCKETS */\n#ifdef HTTPS_SUPPORT\n#ifdef MHD_HTTPS_REQUIRE_GCRYPT\n#if GCRYPT_VERSION_NUMBER < 0x010600\n#if GNUTLS_VERSION_NUMBER <= 0x020b00\n#if defined(MHD_USE_POSIX_THREADS)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_pthread))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#elif defined(MHD_W32_MUTEX_)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_w32))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#endif /* defined(MHD_W32_MUTEX_) */\n#endif /* GNUTLS_VERSION_NUMBER <= 0x020b00 */\n  gcry_check_version (NULL);\n#else\n  if (NULL == gcry_check_version (\"1.6.0\"))\n    MHD_PANIC (_ (\"libgcrypt is too old. MHD was compiled for \" \\\n                  \"libgcrypt 1.6.0 or newer.\\n\"));\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GCRYPT */\n  gnutls_global_init ();\n#endif /* HTTPS_SUPPORT */\n  MHD_monotonic_sec_counter_init ();\n  MHD_send_init_static_vars_ ();\n  MHD_init_mem_pools_ ();\n  /* Check whether sizes were correctly detected by configure */\n#ifdef _DEBUG\n  if (1)\n  {\n    struct timeval tv;\n    mhd_assert (sizeof(tv.tv_sec) == SIZEOF_STRUCT_TIMEVAL_TV_SEC);\n  }\n#endif /* _DEBUG */\n  mhd_assert (sizeof(uint64_t) == SIZEOF_UINT64_T);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses BUILTIN_NOT_REACHED inside the expansion. If BUILTIN_NOT_REACHED is (as is common) defined to a compiler intrinsic such as GCC's __builtin_unreachable() or MSVC's __assume(0) (both documented compiler extensions), then this macro employs a language extension and thus violates MISRA C 2023 Rule 1.2. If, however, BUILTIN_NOT_REACHED is defined to a standard-C construct (for example ((void)0)), there is no violation. The given fragment itself does not define BUILTIN_NOT_REACHED, so the violation occurs when it expands to a documented compiler-specific builtin.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_init:\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n...\n#define _(String) (String)\n...\n#define MHD_USE_POSIX_THREADS 1\n...\n#define mhd_assert(ignore) ((void)0)\n...\n#define SIZEOF_STRUCT_TIMEVAL_TV_SEC 8\n...\n#define SIZEOF_UINT64_T 8\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not correct for the code as given. The MHD_init fragment itself (and the additional macros you showed) reference BUILTIN_NOT_REACHED but do not define it; MISRA C 2023 Rule 1.2 is only breached if the translation unit actually uses a documented compiler language extension (e.g. a compiler intrinsic such as __builtin_unreachable() or __assume(0)). Since no definition of BUILTIN_NOT_REACHED is provided in the supplied code, there is no evidence the code uses a compiler-specific extension and therefore no provable violation. That said, if in the real build environment BUILTIN_NOT_REACHED is defined to a documented compiler intrinsic, then the claim would be correct for that build \u2014 you should inspect the macro\u2019s definition and the compiler documentation to decide definitively."
}