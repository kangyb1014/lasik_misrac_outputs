{
  "user_message": "An agent A claimed that the following MHD_init code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_init.\n```c\nvoid\nMHD_init (void)\n{\n#if defined(MHD_WINSOCK_SOCKETS)\n  WSADATA wsd;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  MHD_set_panic_func (NULL, NULL);\n\n#if defined(MHD_WINSOCK_SOCKETS)\n  if (0 != WSAStartup (MAKEWORD (2, 2), &wsd))\n    MHD_PANIC (_ (\"Failed to initialize winsock.\\n\"));\n  if ((2 != LOBYTE (wsd.wVersion)) && (2 != HIBYTE (wsd.wVersion)))\n    MHD_PANIC (_ (\"Winsock version 2.2 is not available.\\n\"));\n#endif /* MHD_WINSOCK_SOCKETS */\n#ifdef HTTPS_SUPPORT\n#ifdef MHD_HTTPS_REQUIRE_GCRYPT\n#if GCRYPT_VERSION_NUMBER < 0x010600\n#if GNUTLS_VERSION_NUMBER <= 0x020b00\n#if defined(MHD_USE_POSIX_THREADS)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_pthread))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#elif defined(MHD_W32_MUTEX_)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_w32))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#endif /* defined(MHD_W32_MUTEX_) */\n#endif /* GNUTLS_VERSION_NUMBER <= 0x020b00 */\n  gcry_check_version (NULL);\n#else\n  if (NULL == gcry_check_version (\"1.6.0\"))\n    MHD_PANIC (_ (\"libgcrypt is too old. MHD was compiled for \" \\\n                  \"libgcrypt 1.6.0 or newer.\\n\"));\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GCRYPT */\n  gnutls_global_init ();\n#endif /* HTTPS_SUPPORT */\n  MHD_monotonic_sec_counter_init ();\n  MHD_send_init_static_vars_ ();\n  MHD_init_mem_pools_ ();\n  /* Check whether sizes were correctly detected by configure */\n#ifdef _DEBUG\n  if (1)\n  {\n    struct timeval tv;\n    mhd_assert (sizeof(tv.tv_sec) == SIZEOF_STRUCT_TIMEVAL_TV_SEC);\n  }\n#endif /* _DEBUG */\n  mhd_assert (sizeof(uint64_t) == SIZEOF_UINT64_T);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe panic callback and its context pointer are used with non-const pointer types: mhd_panic is called as mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg). __FILE__ (and likely msg) are string literals (const char[]) and the context (mhd_panic_cls) is stored as void * via MHD_set_panic_func(void *cls). If the MHD_PanicCallback prototype (and the mhd_panic_cls declaration) use non-const pointer parameters (e.g. char *file, char *msg or void *cls) instead of const-qualified types (const char *file, const char *msg, const void *cls), Rule 8.13 is violated because pointers that could/should be const-qualified are not.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_init:\n_MHD_EXTERN void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  if ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n\n  mhd_panic_cls = cls;\n}\n...\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The evidence provided does not demonstrate a definite violation of MISRA C 2023 Rule 8.13. Rule 8.13 concerns how pointers are declared (they should point to const-qualified types when possible). The code shown in MHD_init and the snippets (MHD_set_panic_func, MHD_PANIC macro) do not include the definition/typedef of MHD_PanicCallback nor the declaration of the mhd_panic function-pointer type. Without the actual prototype/typedef for MHD_PanicCallback (i.e. whether its parameters are declared as const char * / const void * or as non-const char * / void *), you cannot conclude that the codebase violates Rule 8.13.\n\nTwo important points:\n- If MHD_PanicCallback is declared with const-qualified pointer parameters (const char *file, const char *msg, const void *cls), then there is no Rule 8.13 violation in the shown code. The macro passing __FILE__ or a literal to a const parameter is fine.\n- If MHD_PanicCallback is declared with non-const pointer parameters (char *file, char *msg, void *cls) even though the callback never modifies those objects and they are frequently string literals, then the declaration of MHD_PanicCallback would itself be a candidate violation of Rule 8.13. That problem would be in the callback typedef/declaration, not specifically in MHD_init.\n\nConclusion: Agent A\u2019s claim that MHD_init violates Rule 8.13 is not supported by the provided code. To verify the claim you must inspect the MHD_PanicCallback typedef and the mhd_panic / mhd_panic_std declarations; only if those omit const qualifiers where they could be used is there an actual Rule 8.13 violation."
}