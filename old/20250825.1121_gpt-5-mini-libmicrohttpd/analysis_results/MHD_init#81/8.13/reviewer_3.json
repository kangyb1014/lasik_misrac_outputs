{
  "user_message": "An agent A claimed that the following MHD_init code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_init.\n```c\nvoid\nMHD_init (void)\n{\n#if defined(MHD_WINSOCK_SOCKETS)\n  WSADATA wsd;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  MHD_set_panic_func (NULL, NULL);\n\n#if defined(MHD_WINSOCK_SOCKETS)\n  if (0 != WSAStartup (MAKEWORD (2, 2), &wsd))\n    MHD_PANIC (_ (\"Failed to initialize winsock.\\n\"));\n  if ((2 != LOBYTE (wsd.wVersion)) && (2 != HIBYTE (wsd.wVersion)))\n    MHD_PANIC (_ (\"Winsock version 2.2 is not available.\\n\"));\n#endif /* MHD_WINSOCK_SOCKETS */\n#ifdef HTTPS_SUPPORT\n#ifdef MHD_HTTPS_REQUIRE_GCRYPT\n#if GCRYPT_VERSION_NUMBER < 0x010600\n#if GNUTLS_VERSION_NUMBER <= 0x020b00\n#if defined(MHD_USE_POSIX_THREADS)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_pthread))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#elif defined(MHD_W32_MUTEX_)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_w32))\n    MHD_PANIC (_ (\"Failed to initialise multithreading in libgcrypt.\\n\"));\n#endif /* defined(MHD_W32_MUTEX_) */\n#endif /* GNUTLS_VERSION_NUMBER <= 0x020b00 */\n  gcry_check_version (NULL);\n#else\n  if (NULL == gcry_check_version (\"1.6.0\"))\n    MHD_PANIC (_ (\"libgcrypt is too old. MHD was compiled for \" \\\n                  \"libgcrypt 1.6.0 or newer.\\n\"));\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GCRYPT */\n  gnutls_global_init ();\n#endif /* HTTPS_SUPPORT */\n  MHD_monotonic_sec_counter_init ();\n  MHD_send_init_static_vars_ ();\n  MHD_init_mem_pools_ ();\n  /* Check whether sizes were correctly detected by configure */\n#ifdef _DEBUG\n  if (1)\n  {\n    struct timeval tv;\n    mhd_assert (sizeof(tv.tv_sec) == SIZEOF_STRUCT_TIMEVAL_TV_SEC);\n  }\n#endif /* _DEBUG */\n  mhd_assert (sizeof(uint64_t) == SIZEOF_UINT64_T);\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe code takes the address of the callback table object gcry_threads_w32 and passes it as a non-const pointer to gcry_control: &gcry_threads_w32. If the callback table is not modified by gcry_control (i.e. it should be treated read-only), then the pointer should be to a const-qualified type (const <type> *), but here a non-const pointer is used. This is a violation of MISRA C 2023 Rule 8.13. Note: if the external API gcry_control legitimately requires a modifiable pointer (non-const) then the API mismatch is the cause; otherwise the object should be declared const to comply with the rule.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_init:\n_MHD_EXTERN void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  if ((MHD_PanicCallback) NULL != cb)\n    mhd_panic = cb;\n  else\n    mhd_panic = &mhd_panic_std;\n\n  mhd_panic_cls = cls;\n}\n...\n#define MHD_PANIC(msg) do{mhd_panic(mhd_panic_cls,__FILE__,__LINE__,msg);BUILTIN_NOT_REACHED;}while(0)\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not supported by the evidence shown. MISRA C:2023 R8.13 says a pointer should point to a const-qualified type whenever possible, but whether that applies here depends on the prototype of the external API and the mutability of gcry_threads_w32. In MHD_init the code simply passes &gcry_threads_pthread or &gcry_threads_w32 to gcry_control. If gcry_control's parameter type requires a non-const pointer (e.g. void * or a non-const callback struct pointer) or if gcry_control legitimately modifies the pointed object, then passing a non-const pointer is required and there is no MISRA violation in this caller. The snippet does not show the declarations of gcry_control or gcry_threads_w32, so you cannot conclude that the caller violated R8.13. If, after inspecting the libgcrypt headers, gcry_control does not modify the object and its parameter could be const-qualified, the mismatch is actually in the external API or in the declaration of gcry_threads_w32, not in this call site. Suggested action: inspect the gcry_control prototype and the declaration of gcry_threads_w32; if safe, declare the callback table const (or request a const-correct API) or add a documented MISRA justification where an unavoidable non-const API is used."
}