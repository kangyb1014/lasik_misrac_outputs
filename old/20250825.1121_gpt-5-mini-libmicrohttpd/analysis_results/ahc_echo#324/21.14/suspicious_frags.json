{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 21.14 is: The Standard Library function memcmp shall not be used to compare null terminated strings.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of ahc_echo:\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function ahc_echo:\n_MHD_EXTERN enum MHD_Result\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  if (MHD_str_equal_caseless_ (header, MHD_HTTP_HEADER_CONNECTION))\n    return add_response_header_connection (response, content);\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_TRANSFER_ENCODING))\n  {\n    if (! MHD_str_equal_caseless_ (content, \"chunked\"))\n      return MHD_NO;   /* Only \"chunked\" encoding is allowed */\n    if (0 != (response->flags_auto & MHD_RAF_HAS_TRANS_ENC_CHUNKED))\n      return MHD_YES;  /* Already has \"chunked\" encoding header */\n    if ( (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH)) &&\n         (0 == (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) )\n      return MHD_NO; /* Has \"Content-Length\" header and no \"Insanity\" flag */\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_TRANS_ENC_CHUNKED;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_DATE))\n  {\n    if (0 != (response->flags_auto & MHD_RAF_HAS_DATE_HDR))\n    {\n      struct MHD_HTTP_Res_Header *hdr;\n      hdr = MHD_get_response_element_n_ (response, MHD_HEADER_KIND,\n                                         MHD_HTTP_HEADER_DATE,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_DATE));\n      mhd_assert (NULL != hdr);\n      _MHD_remove_header (response, hdr);\n      if (NULL != hdr->value)\n        free (hdr->value);\n      free (hdr->header);\n      free (hdr);\n    }\n    if (MHD_NO != add_response_entry (response,\n                                      MHD_HEADER_KIND,\n                                      header,\n                                      content))\n    {\n      response->flags_auto |= MHD_RAF_HAS_DATE_HDR;\n      return MHD_YES;\n    }\n    return MHD_NO;\n  }\n\n  if (MHD_str_equal_caseless_ (header,\n                               MHD_HTTP_HEADER_CONTENT_LENGTH))\n  {\n    /* Generally MHD sets automatically correct \"Content-Length\" always when\n     * needed.\n     * Custom \"Content-Length\" header is allowed only in special cases. */\n    if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) ||\n         ((0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n          (0 == (response->flags_auto & (MHD_RAF_HAS_TRANS_ENC_CHUNKED\n                                         | MHD_RAF_HAS_CONTENT_LENGTH)))) )\n    {\n      if (MHD_NO != add_response_entry (response,\n                                        MHD_HEADER_KIND,\n                                        header,\n                                        content))\n      {\n        response->flags_auto |= MHD_RAF_HAS_CONTENT_LENGTH;\n        return MHD_YES;\n      }\n    }\n    return MHD_NO;\n  }\n\n  return add_response_entry (response,\n                             MHD_HEADER_KIND,\n                             header,\n                             content);\n}\n...\nint\nMHD_str_equal_caseless_ (const char *str1,\n                         const char *str2)\n{\n  while (0 != (*str1))\n  {\n    const char c1 = *str1;\n    const char c2 = *str2;\n    if (charsequalcaseless (c1, c2))\n    {\n      str1++;\n      str2++;\n    }\n    else\n      return 0;\n  }\n  return 0 == (*str2);\n}\n...\n_MHD_EXTERN const char *\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)\n{\n  const char *value;\n\n  value = NULL;\n  (void) MHD_lookup_connection_value_n (connection,\n                                        kind,\n                                        key,\n                                        (NULL == key) ? 0 : strlen (key),\n                                        &value,\n                                        NULL);\n  return value;\n}\n...\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n...\nsize_t\nMHD_base64_to_bin_n (const char *base64,\n                     size_t base64_len,\n                     void *bin,\n                     size_t bin_size)\n{\n#if MHD_BASE64_FUNC_VERSION >= 2\n  static const MHD_base64_map_type_ map[] = {\n    /* -1 = invalid char, -2 = padding\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    NUL,  SOH,  STX,  ETX,  EOT,  ENQ,  ACK,  BEL,  */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    BS,   HT,   LF,   VT,   FF,   CR,   SO,   SI,   */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    DLE,  DC1,  DC2,  DC3,  DC4,  NAK,  SYN,  ETB,  */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    CAN,  EM,   SUB,  ESC,  FS,   GS,   RS,   US,   */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    ' ',  '!',  '\"',  '#',  '$',  '%',  '&',  '\\'', */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    '(',  ')',  '*',  '+',  ',',  '-',  '.',  '/',  */\n    -1,   -1,   -1,   62,   -1,   -1,   -1,   63,\n    /*\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  */\n    52,   53,   54,   55,   56,   57,   58,   59,\n    /*\n    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    '8',  '9',  ':',  ';',  '<',  '=',  '>',  '?',  */\n    60,   61,   -1,   -1,   -1,   -2,   -1,   -1,\n    /*\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',  */\n    -1,    0,    1,    2,    3,    4,    5,    6,\n    /*\n    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',  */\n    7,     8,    9,   10,   11,   12,   13,   14,\n    /*\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',  */\n    15,   16,   17,   18,   19,   20,   21,   22,\n    /*\n     0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    'X',  'Y',  'Z',  '[',  '\\',  ']',  '^',  '_',  */\n    23,   24,   25,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',  */\n    -1,   26,   27,   28,   29,   30,   31,   32,\n    /*\n    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',  */\n    33,   34,   35,   36,   37,   38,   39,   40,\n    /*\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    'p',  'q',  'r',  's',  't',  'u',  'v',  'w',  */\n    41,   42,   43,   44,   45,   46,   47,   48,\n    /*\n    0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    'x',  'y',  'z',  '{',  '|',  '}',  '~',  DEL,  */\n    49,   50,   51,   -1,   -1,   -1,   -1,   -1\n\n#if MHD_BASE64_FUNC_VERSION == 3\n    ,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 80..8F */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 90..9F */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* A0..AF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* B0..BF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* C0..CF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* D0..DF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* E0..EF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* F0..FF */\n#endif /* ! MHD_BASE64_FUNC_VERSION == 3 */\n  };\n#define base64_char_to_value_(c) map[(c)]\n#endif /* MHD_BASE64_FUNC_VERSION >= 2 */\n  const uint8_t *const in = (const uint8_t *) base64;\n  uint8_t *const out = (uint8_t *) bin;\n  size_t i;\n  size_t j;\n  if (0 == base64_len)\n    return 0;  /* Nothing to decode */\n  if (0 != base64_len % 4)\n    return 0;  /* Wrong input length */\n  if (base64_len / 4 * 3 - 2 > bin_size)\n    return 0;\n\n  j = 0;\n  for (i = 0; i < (base64_len - 4); i += 4)\n  {\n#if MHD_BASE64_FUNC_VERSION == 2\n    if (0 != (0x80 & (in[i] | in[i + 1] | in[i + 2] | in[i + 3])))\n      return 0;\n#endif /* MHD_BASE64_FUNC_VERSION == 2 */\n    if (1)\n    {\n      const MHD_base64_map_type_ v1 = base64_char_to_value_ (in[i + 0]);\n      const MHD_base64_map_type_ v2 = base64_char_to_value_ (in[i + 1]);\n      const MHD_base64_map_type_ v3 = base64_char_to_value_ (in[i + 2]);\n      const MHD_base64_map_type_ v4 = base64_char_to_value_ (in[i + 3]);\n      if ((0 > v1) || (0 > v2) || (0 > v3) || (0 > v4))\n        return 0;\n      out[j + 0] = (uint8_t) (((uint8_t) (((uint8_t) v1) << 2))\n                              | ((uint8_t) (((uint8_t) v2) >> 4)));\n      out[j + 1] = (uint8_t) (((uint8_t) (((uint8_t) v2) << 4))\n                              | ((uint8_t) (((uint8_t) v3) >> 2)));\n      out[j + 2] = (uint8_t) (((uint8_t) (((uint8_t) v3) << 6))\n                              | ((uint8_t) v4));\n    }\n    j += 3;\n  }\n#if MHD_BASE64_FUNC_VERSION == 2\n  if (0 != (0x80 & (in[i] | in[i + 1] | in[i + 2] | in[i + 3])))\n    return 0;\n#endif /* MHD_BASE64_FUNC_VERSION == 2 */\n  if (1)\n  { /* The last four chars block */\n    const MHD_base64_map_type_ v1 = base64_char_to_value_ (in[i + 0]);\n    const MHD_base64_map_type_ v2 = base64_char_to_value_ (in[i + 1]);\n    const MHD_base64_map_type_ v3 = base64_char_to_value_ (in[i + 2]);\n    const MHD_base64_map_type_ v4 = base64_char_to_value_ (in[i + 3]);\n    if ((0 > v1) || (0 > v2))\n      return 0; /* Invalid char or padding at first two positions */\n    mhd_assert (j < bin_size);\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v1) << 2))\n                          | ((uint8_t) (((uint8_t) v2) >> 4)));\n    if (0 > v3)\n    { /* Third char is either padding or invalid */\n      if ((-2 != v3) || (-2 != v4))\n        return 0;  /* Both two last chars must be padding */\n      if (0 != (uint8_t) (((uint8_t) v2) << 4))\n        return 0;  /* Wrong last char */\n      return j;\n    }\n    if (j >= bin_size)\n      return 0; /* Not enough space */\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v2) << 4))\n                          | ((uint8_t) (((uint8_t) v3) >> 2)));\n    if (0 > v4)\n    { /* Fourth char is either padding or invalid */\n      if (-2 != v4)\n        return 0;  /* The char must be padding */\n      if (0 != (uint8_t) (((uint8_t) v3) << 6))\n        return 0;  /* Wrong last char */\n      return j;\n    }\n    if (j >= bin_size)\n      return 0; /* Not enough space */\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v3) << 6))\n                          | ((uint8_t) v4));\n  }\n  return j;\n#if MHD_BASE64_FUNC_VERSION >= 2\n#undef base64_char_to_value_\n#endif /* MHD_BASE64_FUNC_VERSION >= 2 */\n}\n...\nsize_t\nMHD_str_quote (const char *unquoted,\n               size_t unquoted_len,\n               char *result,\n               size_t buf_size)\n{\n  size_t r;\n  size_t w;\n\n  r = 0;\n  w = 0;\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (unquoted_len * 2 <= buf_size)\n  {\n    /* Fast loop: the output will fit the buffer with any input string content */\n    while (unquoted_len > r)\n    {\n      const char chr = unquoted[r++];\n      if (('\\\\' == chr) || ('\\\"' == chr))\n        result[w++] = '\\\\'; /* Escape current char */\n      result[w++] = chr;\n    }\n  }\n  else\n  {\n    if (unquoted_len > buf_size)\n      return 0; /* Quick fail: the output buffer is too small */\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n    while (unquoted_len > r)\n    {\n      if (buf_size <= w)\n        return 0; /* The output buffer is too small */\n      else\n      {\n        const char chr = unquoted[r++];\n        if (('\\\\' == chr) || ('\\\"' == chr))\n        {\n          result[w++] = '\\\\'; /* Escape current char */\n          if (buf_size <= w)\n            return 0; /* The output buffer is too small */\n        }\n        result[w++] = chr;\n      }\n    }\n  }\n\n  mhd_assert (w >= r);\n  mhd_assert (w <= r * 2);\n  return w;\n}\n...\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_basic_auth_required_response3 (struct MHD_Connection *connection,\n                                         const char *realm,\n                                         int prefer_utf8,\n                                         struct MHD_Response *response)\n{\n  static const char prefix[] = \"Basic realm=\\\"\";\n  static const char suff_charset[] = \"\\\", charset=\\\"UTF-8\\\"\";\n  static const size_t prefix_len = MHD_STATICSTR_LEN_ (prefix);\n  static const size_t suff_simple_len = MHD_STATICSTR_LEN_ (\"\\\"\");\n  static const size_t suff_charset_len =\n    MHD_STATICSTR_LEN_ (suff_charset);\n  enum MHD_Result ret;\n  char *h_str;\n  size_t h_maxlen;\n  size_t suffix_len;\n  size_t realm_len;\n  size_t realm_quoted_len;\n  size_t pos;\n\n  if (NULL == response)\n    return MHD_NO;\n\n  suffix_len = (0 == prefer_utf8) ? suff_simple_len : suff_charset_len;\n  realm_len = strlen (realm);\n  h_maxlen = prefix_len + realm_len * 2 + suffix_len;\n\n  h_str = (char *) malloc (h_maxlen + 1);\n  if (NULL == h_str)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              \"Failed to allocate memory for Basic Authentication header.\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  memcpy (h_str, prefix, prefix_len);\n  pos = prefix_len;\n  realm_quoted_len = MHD_str_quote (realm, realm_len, h_str + pos,\n                                    h_maxlen - prefix_len - suffix_len);\n  pos += realm_quoted_len;\n  mhd_assert (pos + suffix_len <= h_maxlen);\n  if (0 == prefer_utf8)\n  {\n    h_str[pos++] = '\\\"';\n    h_str[pos++] = 0; /* Zero terminate the result */\n    mhd_assert (pos <= h_maxlen + 1);\n  }\n  else\n  {\n    /* Copy with the final zero-termination */\n    mhd_assert (pos + suff_charset_len <= h_maxlen);\n    memcpy (h_str + pos, suff_charset, suff_charset_len + 1);\n    mhd_assert (0 == h_str[pos + suff_charset_len]);\n  }\n\n  ret = MHD_add_response_header (response,\n                                 MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                 h_str);\n  free (h_str);\n  if (MHD_NO != ret)\n  {\n    ret = MHD_queue_response (connection,\n                              MHD_HTTP_UNAUTHORIZED,\n                              response);\n  }\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to add Basic Authentication header.\\n\"));\n#endif /* HAVE_MESSAGES */\n  }\n  return ret;\n}\n...\n_MHD_EXTERN enum MHD_DigestAuthResult\nMHD_digest_auth_check3 (struct MHD_Connection *connection,\n                        const char *realm,\n                        const char *username,\n                        const char *password,\n                        unsigned int nonce_timeout,\n                        uint32_t max_nc,\n                        enum MHD_DigestAuthMultiQOP mqop,\n                        enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  mhd_assert (NULL != password);\n\n  return digest_auth_check_all (connection,\n                                realm,\n                                username,\n                                password,\n                                NULL,\n                                nonce_timeout,\n                                max_nc,\n                                mqop,\n                                malgo3);\n}\n...\nstatic enum MHD_Result\ncan_compress (struct MHD_Connection *con)\n{\n  const char *ae;\n  const char *de;\n\n  ae = MHD_lookup_connection_value (con,\n                                    MHD_HEADER_KIND,\n                                    MHD_HTTP_HEADER_ACCEPT_ENCODING);\n  if (NULL == ae)\n    return MHD_NO;\n  if (0 == strcmp (ae,\n                   \"*\"))\n    return MHD_YES;\n  de = strstr (ae,\n               \"deflate\");\n  if (NULL == de)\n    return MHD_NO;\n  if (((de == ae) ||\n       (de[-1] == ',') ||\n       (de[-1] == ' ')) &&\n      ((de[strlen (\"deflate\")] == '\\0') ||\n       (de[strlen (\"deflate\")] == ',') ||\n       (de[strlen (\"deflate\")] == ';')))\n    return MHD_YES;\n  return MHD_NO;\n}\n...\nstatic enum replyBodyUse\nis_reply_body_needed (struct MHD_Connection *connection,\n                      unsigned int rcode)\n{\n  struct MHD_Connection *const c = connection; /**< a short alias */\n\n  mhd_assert (100 <= rcode);\n  mhd_assert (999 >= rcode);\n\n  if (199 >= rcode)\n    return RP_BODY_NONE;\n\n  if (MHD_HTTP_NO_CONTENT == rcode)\n    return RP_BODY_NONE;\n\n#if 0\n  /* This check is not needed as upgrade handler is used only with code 101 */\n#ifdef UPGRADE_SUPPORT\n  if (NULL != rp.response->upgrade_handler)\n    return RP_BODY_NONE;\n#endif /* UPGRADE_SUPPORT */\n#endif\n\n#if 0\n  /* CONNECT is not supported by MHD */\n  /* Successful responses for connect requests are filtered by\n   * MHD_queue_response() */\n  if ( (MHD_HTTP_MTHD_CONNECT == c->rq.http_mthd) &&\n       (2 == rcode / 100) )\n    return false; /* Actually pass-through CONNECT is not supported by MHD */\n#endif\n\n  /* Reply body headers could be used.\n   * Check whether reply body itself must be used. */\n\n  if (MHD_HTTP_MTHD_HEAD == c->rq.http_mthd)\n    return RP_BODY_HEADERS_ONLY;\n\n  if (MHD_HTTP_NOT_MODIFIED == rcode)\n    return RP_BODY_HEADERS_ONLY;\n\n  /* Reply body must be sent. The body may have zero length, but body size\n   * must be indicated by headers ('Content-Length:' or\n   * 'Transfer-Encoding: chunked'). */\n  return RP_BODY_SEND;\n}\n...\n_MHD_EXTERN enum MHD_Result\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n  bool reply_icy;\n\n  if ((NULL == connection) || (NULL == response))\n    return MHD_NO;\n\n  daemon = connection->daemon;\n  if ((! connection->in_access_handler) && (! connection->suspended) &&\n      MHD_D_IS_USING_THREADS_ (daemon))\n    return MHD_NO;\n\n  reply_icy = (0 != (status_code & MHD_ICY_FLAG));\n  status_code &= ~MHD_ICY_FLAG;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  if ( (! connection->suspended) &&\n       MHD_D_IS_USING_THREADS_ (daemon) &&\n       (! MHD_thread_handle_ID_is_current_thread_ (connection->tid)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n    return MHD_NO;\n  }\n#endif\n\n  if (NULL != connection->rp.response)\n    return MHD_NO; /* The response was already set */\n\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n       (MHD_CONNECTION_FULL_REQ_RECEIVED != connection->state) )\n    return MHD_NO; /* Wrong connection state */\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n#ifdef UPGRADE_SUPPORT\n  if (NULL != response->upgrade_handler)\n  {\n    struct MHD_HTTP_Res_Header *conn_header;\n    if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Attempted 'upgrade' connection on daemon without\" \\\n                   \" MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (MHD_HTTP_SWITCHING_PROTOCOLS != status_code)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid status code for\" \\\n                   \" 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (0 == (response->flags_auto & MHD_RAF_HAS_CONNECTION_HDR))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    conn_header = response->first_header;\n    mhd_assert (NULL != conn_header);\n    mhd_assert (MHD_str_equal_caseless_ (conn_header->header,\n                                         MHD_HTTP_HEADER_CONNECTION));\n    if (! MHD_str_has_s_token_caseless_ (conn_header->value,\n                                         \"upgrade\"))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used invalid response\" \\\n                   \" without \\\"upgrade\\\" token in\" \\\n                   \" \\\"Connection\\\" header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n    if (! MHD_IS_HTTP_VER_1_1_COMPAT (connection->rq.http_ver))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Connection \\\"Upgrade\\\" can be used only \" \\\n                   \"with HTTP/1.1 connections!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  }\n#endif /* UPGRADE_SUPPORT */\n  if (MHD_HTTP_SWITCHING_PROTOCOLS == status_code)\n  {\n#ifdef UPGRADE_SUPPORT\n    if (NULL == response->upgrade_handler)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Application used status code 101 \\\"Switching Protocols\\\" \" \\\n                   \"with non-'upgrade' response!\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n#else  /* ! UPGRADE_SUPPORT */\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Application used status code 101 \\\"Switching Protocols\\\", \" \\\n                 \"but this MHD was built without \\\"Upgrade\\\" support!\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n#endif /* ! UPGRADE_SUPPORT */\n  }\n  if ( (100 > status_code) ||\n       (999 < status_code) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Refused wrong status code (%u). \" \\\n                 \"HTTP requires three digits status code!\\n\"),\n              status_code);\n#endif\n    return MHD_NO;\n  }\n  if (200 > status_code)\n  {\n    if (MHD_HTTP_VER_1_0 == connection->rq.http_ver)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 clients do not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n    if (0 != (response->flags & (MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n                                 | MHD_RF_HTTP_1_0_SERVER)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Wrong status code (%u) refused. \" \\\n                   \"HTTP/1.0 reply mode does not support 1xx status codes!\\n\"),\n                (status_code));\n#endif\n      return MHD_NO;\n    }\n  }\n  if ( (MHD_HTTP_MTHD_CONNECT == connection->rq.http_mthd) &&\n       (2 == status_code / 100) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Successful (%u) response code cannot be used to answer \" \\\n                 \"\\\"CONNECT\\\" request!\\n\"),\n              (status_code));\n#endif\n    return MHD_NO;\n  }\n\n  if ( (0 != (MHD_RF_HEAD_ONLY_RESPONSE & response->flags)) &&\n       (RP_BODY_HEADERS_ONLY < is_reply_body_needed (connection, status_code)) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"HEAD-only response cannot be used when the request requires \"\n                 \"reply body to be sent!\\n\"));\n#endif\n    return MHD_NO;\n  }\n\n#ifdef HAVE_MESSAGES\n  if ( (0 != (MHD_RF_INSANITY_HEADER_CONTENT_LENGTH & response->flags)) &&\n       (0 != (MHD_RAF_HAS_CONTENT_LENGTH & response->flags_auto)) )\n  {\n    MHD_DLOG (daemon,\n              _ (\"The response has application-defined \\\"Content-Length\\\" \" \\\n                 \"header. The reply to the request will be not \" \\\n                 \"HTTP-compliant and may result in hung connection or \" \\\n                 \"other problems!\\n\"));\n  }\n#endif\n\n  MHD_increment_response_rc (response);\n  connection->rp.response = response;\n  connection->rp.responseCode = status_code;\n  connection->rp.responseIcy = reply_icy;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (response->is_pipe) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS))\n#if defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED) && \\\n       defined(MHD_SEND_SPIPE_SUPPRESS_POSSIBLE)\n       || (! daemon->sigpipe_blocked && ! connection->sk_spipe_suppress)\n#endif /* MHD_SEND_SPIPE_SUPPRESS_NEEDED &&\n          MHD_SEND_SPIPE_SUPPRESS_POSSIBLE */\n       )\n    connection->rp.resp_sender = MHD_resp_sender_std;\n  else\n    connection->rp.resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n  /* FIXME: if 'is_pipe' is set, TLS is off, and we have *splice*, we could use splice()\n     to avoid two user-space copies... */\n\n  if ( (MHD_HTTP_MTHD_HEAD == connection->rq.http_mthd) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n  {\n    /* if this is a \"HEAD\" request, or a status code for\n       which a body is not allowed, pretend that we\n       have already sent the full message body. */\n    /* TODO: remove the next assignment, use 'rp_props.send_reply_body' in\n     * checks */\n    connection->rp.rsp_write_position = response->total_size;\n  }\n  if (MHD_CONNECTION_HEADERS_PROCESSED == connection->state)\n  {\n    /* response was queued \"early\", refuse to read body / footers or\n       further requests! */\n    connection->discard_request = true;\n    connection->state = MHD_CONNECTION_START_REPLY;\n    connection->rq.remaining_upload_size = 0;\n  }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  MHD_update_last_activity_ (connection);\n  return MHD_YES;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback (size_t size,\n                                                    void *buffer,\n                                                    MHD_ContentReaderFreeCallback\n                                                    crfc)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 crfc,\n                                                                 buffer);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_copy (size_t size,\n                                      const void *buffer)\n{\n  struct MHD_Response *r;\n  void *mhd_copy;\n\n  if (0 == size)\n    return MHD_create_response_from_buffer_with_free_callback_cls (0,\n                                                                   NULL,\n                                                                   NULL,\n                                                                   NULL);\n  if (NULL == buffer)\n    return NULL;\n\n  mhd_copy = malloc (size);\n  if (NULL == mhd_copy)\n    return NULL;\n  memcpy (mhd_copy, buffer, size);\n\n  r = MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                              mhd_copy,\n                                                              &free,\n                                                              mhd_copy);\n  if (NULL == r)\n    free (mhd_copy);\n  else\n  {\n    /* TODO: remove the next assignment, the buffer should not be modifiable */\n    r->data_buffer_size = size;\n  }\n\n  return r;\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_fd64 (uint64_t size,\n                               int fd)\n{\n  return MHD_create_response_from_fd_at_offset64 (size,\n                                                  fd,\n                                                  0);\n}\n...\nstatic enum MHD_Result\nbody_compress (void **buf,\n               size_t *buf_size)\n{\n  Bytef *cbuf;\n  uLongf cbuf_size;\n  int ret;\n\n  cbuf_size = compressBound ((uLong) * buf_size);\n  cbuf = malloc (cbuf_size);\n  if (NULL == cbuf)\n    return MHD_NO;\n  ret = compress (cbuf,\n                  &cbuf_size,\n                  (const Bytef *) *buf,\n                  (uLong) * buf_size);\n  if ((Z_OK != ret) ||\n      (cbuf_size >= *buf_size))\n  {\n    /* compression failed */\n    free (cbuf);\n    return MHD_NO;\n  }\n  free (*buf);\n  *buf = (void *) cbuf;\n  *buf_size = (size_t) cbuf_size;\n  return MHD_YES;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "I inspected the provided target function (ahc_echo) and all additional code snippets for any use of the Standard Library function memcmp. No occurrences of memcmp are present in the supplied code. Rule 21.14 specifically prohibits using memcmp to compare null-terminated strings; therefore only direct calls to memcmp (or wrappers that obviously call memcmp to compare C strings) would be suspicious. The code does use functions that operate on strings or memory (strcmp, strstr, memchr, memcpy, memcpy-like helper functions, and manual character comparisons in MHD_str_equal_caseless_), but none of these are memcmp and none indicate memcmp is being used to compare null-terminated strings. I also checked functions called from the shown code (e.g. MHD_str_equal_caseless_, MHD_base64_to_bin_n, MHD_lookup_connection_value, MHD_basic_auth_get_username_password3, etc.) and found no memcmp usage. Therefore there are no code fragments to flag for investigation under MISRA C 2023 Rule 21.14 in the provided code."
}