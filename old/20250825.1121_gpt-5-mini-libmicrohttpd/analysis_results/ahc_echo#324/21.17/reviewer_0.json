{
  "user_message": "An agent A claimed that the following ahc_echo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of ahc_echo.\n```c\nstatic enum MHD_Result\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size, void **req_cls)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  enum MHD_Result ret;\n  int fd;\n  struct stat buf;\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) version;           /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *req_cls)\n  {\n    /* do never respond on first call */\n    *req_cls = &aptr;\n    return MHD_YES;\n  }\n  *req_cls = NULL;                 /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr (url, \"../\")) /* Very simplified check! */\n    fd = -1;                       /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n  {\n    if ( (0 != fstat (fd, &buf)) ||\n         (! S_ISREG (buf.st_mode)) )\n    {\n      /* not a regular file, refuse to serve */\n      if (0 != close (fd))\n        abort ();\n      fd = -1;\n    }\n  }\n  if (-1 == fd)\n  {\n    response = MHD_create_response_from_buffer_static (strlen (PAGE),\n                                                       PAGE);\n    ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n    MHD_destroy_response (response);\n  }\n  else\n  {\n    response = MHD_create_response_from_fd64 ((uint64_t) buf.st_size, fd);\n    if (NULL == response)\n    {\n      if (0 != close (fd))\n        abort ();\n      return MHD_NO;\n    }\n    ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    MHD_destroy_response (response);\n  }\n  return ret;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nYes. Calling strstr(url, \"../\") can read until it finds a NUL terminator in the haystack (url). If url is NULL or not guaranteed to be NUL-terminated (e.g. derived from truncated or unvalidated input), strstr may read past the bounds of the url buffer causing an out-of-bounds access. Example: url points to a fixed-length network buffer that lacks a terminating '\\0' \u2014 strstr will continue scanning beyond the buffer, violating Rule 21.17.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function ahc_echo:\n#define MHD_HTTP_METHOD_GET \"GET\"\n...\n#define MHD_HTTP_METHOD_HEAD \"HEAD\"\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A\u2019s report is correct as a potential MISRA 21.17 violation. The code calls strstr(url, \"../\") (and also uses url later as a filename) without checking that url is non-NULL and that it is a properly NUL-terminated string. strstr (and other string.h functions) scan until they find a NUL terminator; if url were NULL or came from a fixed-length/non-terminated buffer, the call could read past the object bounds and thus violate Rule 21.17. \n\nThat said, if the surrounding API (libmicrohttpd) formally guarantees that the url parameter is always non-NULL and NUL-terminated, then in practice this particular use would be safe and would not violate the rule. MISRA requires that such uses must not result in out-of-bounds accesses unless a documented, verifiable guarantee exists. The code contains no local check or comment asserting that guarantee, so the reported violation is valid unless the API contract is relied upon and documented."
}