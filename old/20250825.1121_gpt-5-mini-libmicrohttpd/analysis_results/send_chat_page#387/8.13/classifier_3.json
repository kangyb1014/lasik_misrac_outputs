{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of send_chat_page:\n```c\nstatic enum MHD_Result\nsend_chat_page (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE),\n                                                (const void *) CHAT_PAGE);\n  ret = MHD_queue_response (con, MHD_HTTP_OK, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function send_chat_page:\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_with_free_callback_cls (size_t size,\n                                                        const void *buffer,\n                                                        MHD_ContentReaderFreeCallback\n                                                        crfc,\n                                                        void *crfc_cls)\n{\n  struct MHD_Response *r;\n\n  if ((NULL == buffer) && (size > 0))\n    return NULL;\n#if SIZEOF_SIZE_T >= SIZEOF_UINT64_T\n  if (MHD_SIZE_UNKNOWN == size)\n    return NULL;\n#endif /* SIZEOF_SIZE_T >= SIZEOF_UINT64_T */\n  r = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == r)\n    return NULL;\n#if defined(MHD_USE_THREADS)\n  if (! MHD_mutex_init_ (&r->mutex))\n  {\n    free (r);\n    return NULL;\n  }\n#endif\n  r->fd = -1;\n  r->reference_count = 1;\n  r->total_size = size;\n  r->data = buffer;\n  r->data_size = size;\n  r->crfc = crfc;\n  r->crc_cls = crfc_cls;\n  return r;\n}\n...\nstruct MHD_Response\n...\n_MHD_EXTERN void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Res_Header *pos;\n\n  if (NULL == response)\n    return;\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_lock_chk_ (&response->mutex);\n#endif\n  if (0 != --(response->reference_count))\n  {\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n    MHD_mutex_unlock_chk_ (&response->mutex);\n#endif\n    return;\n  }\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n#endif\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n\n  if (NULL != response->data_iov)\n  {\n    free (response->data_iov);\n  }\n\n  while (NULL != response->first_header)\n  {\n    pos = response->first_header;\n    response->first_header = pos->next;\n    free (pos->header);\n    free (pos->value);\n    free (pos);\n  }\n  free (response);\n}\n...\n#define CHAT_PAGE \"<html>\\n\"\"<head>\\n\"\"<title>WebSocket chat</title>\\n\"\"<script>\\n\"\"document.addEventListener('DOMContentLoaded', function() {\\n\"\"  const ws = new WebSocket('ws:/\"\"/' + window.location.host);\\n\"\"  const btn = document.getElementById('send');\\n\"\"  const msg = document.getElementById('msg');\\n\"\"  const log = document.getElementById('log');\\n\"\"  ws.onopen = function() {\\n\"\"    log.value += 'Connected\\\\n';\\n\"\"  };\\n\"\"  ws.onclose = function() {\\n\"\"    log.value += 'Disconnected\\\\n';\\n\"\"  };\\n\"\"  ws.onmessage = function(ev) {\\n\"\"    log.value += ev.data + '\\\\n';\\n\"\"  };\\n\"\"  btn.onclick = function() {\\n\"\"    log.value += '<You>: ' + msg.value + '\\\\n';\\n\"\"    ws.send(msg.value);\\n\"\"  };\\n\"\"  msg.onkeyup = function(ev) {\\n\"\"    if (ev.keyCode === 13) {\\n\"\"      ev.preventDefault();\\n\"\"      ev.stopPropagation();\\n\"\"      btn.click();\\n\"\"      msg.value = '';\\n\"\"    }\\n\"\"  };\\n\"\"});\\n\"\"</script>\\n\"\"</head>\\n\"\"<body>\\n\"\"<input type='text' id='msg' autofocus/>\\n\"\"<input type='button' id='send' value='Send' /><br /><br />\\n\"\"<textarea id='log' rows='20' cols='28'></textarea>\\n\"\"</body>\\n\"\"</html>\"\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nres = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE), (const void *) CHAT_PAGE);\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. The code casts CHAT_PAGE to (const void *) and the API MHD_create_response_from_buffer_static takes a const void *buffer, so the pointer points to a const-qualified type. (A violation would occur if a non-const pointer to the string literal were used or if the function stored it into a non-const pointer, dropping the const qualifier.)"
}