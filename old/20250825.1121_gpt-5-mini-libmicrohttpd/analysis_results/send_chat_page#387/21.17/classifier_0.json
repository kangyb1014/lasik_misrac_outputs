{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 21.17 is: Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of send_chat_page:\n```c\nstatic enum MHD_Result\nsend_chat_page (struct MHD_Connection *con)\n{\n  struct MHD_Response *res;\n  enum MHD_Result ret;\n\n  res = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE),\n                                                (const void *) CHAT_PAGE);\n  ret = MHD_queue_response (con, MHD_HTTP_OK, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function send_chat_page:\n#define CHAT_PAGE \"<html>\\n\"\"<head>\\n\"\"<title>WebSocket chat</title>\\n\"\"<script>\\n\"\"document.addEventListener('DOMContentLoaded', function() {\\n\"\"  const ws = new WebSocket('ws:/\"\"/' + window.location.host);\\n\"\"  const btn = document.getElementById('send');\\n\"\"  const msg = document.getElementById('msg');\\n\"\"  const log = document.getElementById('log');\\n\"\"  ws.onopen = function() {\\n\"\"    log.value += 'Connected\\\\n';\\n\"\"  };\\n\"\"  ws.onclose = function() {\\n\"\"    log.value += 'Disconnected\\\\n';\\n\"\"  };\\n\"\"  ws.onmessage = function(ev) {\\n\"\"    log.value += ev.data + '\\\\n';\\n\"\"  };\\n\"\"  btn.onclick = function() {\\n\"\"    log.value += '<You>: ' + msg.value + '\\\\n';\\n\"\"    ws.send(msg.value);\\n\"\"  };\\n\"\"  msg.onkeyup = function(ev) {\\n\"\"    if (ev.keyCode === 13) {\\n\"\"      ev.preventDefault();\\n\"\"      ev.stopPropagation();\\n\"\"      btn.click();\\n\"\"      msg.value = '';\\n\"\"    }\\n\"\"  };\\n\"\"});\\n\"\"</script>\\n\"\"</head>\\n\"\"<body>\\n\"\"<input type='text' id='msg' autofocus/>\\n\"\"<input type='button' id='send' value='Send' /><br /><br />\\n\"\"<textarea id='log' rows='20' cols='28'></textarea>\\n\"\"</body>\\n\"\"</html>\"\n...\n_MHD_EXTERN struct MHD_Response *\nMHD_create_response_from_buffer_static (size_t size,\n                                        const void *buffer)\n{\n  return MHD_create_response_from_buffer_with_free_callback_cls (size,\n                                                                 buffer,\n                                                                 NULL,\n                                                                 NULL);\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nres = MHD_create_response_from_buffer_static (strlen (CHAT_PAGE),\n                                                (const void *) CHAT_PAGE);\n```\nFocus on the above code fragment and judge whether it violates the rule 21.17 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation. CHAT_PAGE is formed from adjacent string literals which are concatenated into a single null-terminated string literal, so strlen(CHAT_PAGE) will only read up to the terminating NUL and cannot access beyond the object. A hypothetical violation would occur if CHAT_PAGE were not null-terminated (for example a non-terminated char array or a pointer into a buffer without a terminating NUL), or if strlen were called with a pointer that does not point to the start of a null-terminated object."
}