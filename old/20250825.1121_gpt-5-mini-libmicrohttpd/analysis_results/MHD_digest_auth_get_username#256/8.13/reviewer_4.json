{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_username code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_username.\n```c\n_MHD_EXTERN char *\nMHD_digest_auth_get_username (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  char *username;\n  size_t buf_size;\n  enum MHD_DigestAuthUsernameType uname_type;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  uname_type = get_rq_uname_type (params);\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_STANDARD != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_EXTENDED != uname_type) )\n    return NULL;\n\n  buf_size = get_rq_unames_size (params, uname_type);\n\n  mhd_assert (0 != buf_size);\n\n  username = (char *) MHD_calloc_ (1, buf_size);\n  if (NULL == username)\n    return NULL;\n\n  if (1)\n  {\n    struct MHD_DigestAuthUsernameInfo uname_strct;\n    size_t used;\n\n    memset (&uname_strct, 0, sizeof(uname_strct));\n\n    used = get_rq_uname (params, uname_type, &uname_strct,\n                         (uint8_t *) username, buf_size);\n    if (uname_type != uname_strct.uname_type)\n    { /* Broken encoding for extended notation */\n      free (username);\n      return NULL;\n    }\n    (void) used; /* Mute compiler warning for non-debug builds */\n    mhd_assert (buf_size >= used);\n  }\n\n  return username;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function takes a pointer parameter 'struct MHD_Connection *connection' but (in the shown body) does not modify the pointed-to object; it only reads from it (calls MHD_get_rq_dauth_params_ and other accessors). Therefore the parameter could/should be declared as 'const struct MHD_Connection *connection'. Declaring it non-const violates MISRA C 2023 Rule 8.13, which requires pointers to point to const-qualified types whenever possible.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The reporter's observation that MHD_digest_auth_get_username does not itself modify the object pointed to by 'connection' is correct, but that alone is not sufficient to conclude a MISRA 8.13 violation. Rule 8.13 requires that pointers point to const-qualified types whenever it is possible to do so \u2014 i.e. without breaking interfaces or requiring casts. In the shown body the only use of 'connection' is to call MHD_get_rq_dauth_params_(connection) (and potentially other accessors not shown). If those callee functions require a non-const struct MHD_Connection * (their prototypes are not provided here), then the parameter cannot be changed to const without changing those prototypes or inserting casts, so it may not be possible to declare it const in the current program context. Conversely, if all called functions accept a pointer-to-const (or otherwise do not require a non-const pointer), then making the parameter 'const struct MHD_Connection *connection' would be appropriate and the current declaration would be a violation. Because the report did not check the prototypes of the functions to which 'connection' is passed, there is insufficient evidence to assert a definite MISRA 8.13 violation in this translation unit. Recommendation: inspect the declarations of MHD_get_rq_dauth_params_ and any other callees that take 'connection'; if they accept/should accept const, change the parameter to 'const struct MHD_Connection *connection' (or adjust the callees) or otherwise document/justify why const cannot be used."
}