{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nsetup_epoll_to_listen (struct MHD_Daemon *daemon)\n{\n  struct epoll_event event;\n  MHD_socket ls;\n\n  mhd_assert (MHD_D_IS_USING_EPOLL_ (daemon));\n  mhd_assert (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n  mhd_assert ( (! MHD_D_IS_USING_THREADS_ (daemon)) || \\\n               (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) || \\\n               MHD_ITC_IS_VALID_ (daemon->itc) );\n  daemon->epoll_fd = setup_epoll_fd (daemon);\n  if (! MHD_D_IS_USING_THREADS_ (daemon)\n      && (0 != (daemon->options & MHD_USE_AUTO)))\n  {\n    /* Application requested \"MHD_USE_AUTO\", probably MHD_get_fdset() will be\n       used.\n       Make sure that epoll FD is suitable for fd_set.\n       Actually, MHD_get_fdset() is allowed for MHD_USE_EPOLL direct,\n       but most probably direct requirement for MHD_USE_EPOLL means that\n       epoll FD will be used directly. This logic is fuzzy, but better\n       than nothing with current MHD API. */\n    if (! MHD_D_DOES_SCKT_FIT_FDSET_ (daemon->epoll_fd, daemon))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"The epoll FD is too large to be used with fd_set.\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n  }\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (0 != (MHD_ALLOW_UPGRADE & daemon->options))\n  {\n    daemon->epoll_upgrade_fd = setup_epoll_fd (daemon);\n    if (MHD_INVALID_SOCKET == daemon->epoll_upgrade_fd)\n      return MHD_NO;\n  }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = daemon;\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        ls,\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n    daemon->listen_socket_in_epoll = true;\n  }\n\n  if (MHD_ITC_IS_VALID_ (daemon->itc))\n  {\n    event.events = EPOLLIN | EPOLLRDHUP;\n    event.data.ptr = _MHD_DROP_CONST (epoll_itc_marker);\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_ADD,\n                        MHD_itc_r_fd_ (daemon->itc),\n                        &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n  }\n  return MHD_YES;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'setup_epoll_to_listen': {'callees': ['setup_epoll_fd', 'MHD_DLOG'], 'callers': ['MHD_start_daemon_va']}, 'setup_epoll_fd': {'callees': ['MHD_DLOG'], 'callers': ['setup_epoll_to_listen']}, 'MHD_DLOG': {'callees': [], 'callers': ['connection_close_error', 'check_connection_reply', 'transmit_error_response_len', 'connection_add_header', 'parse_cookie_header', 'process_request_body', 'parse_connection_headers', 'get_req_header', 'get_req_headers', 'MHD_connection_handle_read', 'MHD_connection_handle_write', 'connection_check_timedout', 'cleanup_connection', 'MHD_connection_epoll_update_', 'MHD_queue_response', 'MHD_ip_limit_add', 'MHD_get_fdset2', 'thread_main_handle_connection', 'new_connection_prepare_', 'new_connection_process_', 'internal_add_connection', 'new_connections_list_process_', 'MHD_suspend_connection', 'MHD_resume_connection', 'MHD_upgraded_connection_mark_app_closed_', 'resume_suspended_connections', 'MHD_add_connection', 'MHD_accept_connection', 'MHD_get_timeout64', 'MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'unescape_wrapper', 'MHD_quiesce_daemon', 'parse_options_va', 'setup_epoll_fd', 'setup_epoll_to_listen', 'process_interim_params', 'MHD_start_daemon_va', 'close_all_connections', 'MHD_connection_set_nodelay_state_', 'MHD_connection_set_cork_state_', 'post_send_setopt', 'MHD_response_execute_upgrade_', 'MHD_get_rq_bauth_params_', 'MHD_get_rq_dauth_params_', 'calculate_add_nonce_with_retry', 'check_uri_match', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner', 'MHD_basic_auth_get_username_password3', 'MHD_basic_auth_get_username_password', 'MHD_queue_basic_auth_required_response3']}, 'MHD_start_daemon_va': {'callees': ['parse_options_va', 'process_interim_params', 'MHD_DLOG', '__builtin_unreachable', 'MHD_socket_create_listen_', 'MHD_socket_nonblocking_', 'setup_epoll_to_listen', 'MHD_create_named_thread_', 'MHD_stop_daemon'], 'callers': ['MHD_start_daemon']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "mhd_assert",
    "MHD_D_IS_USING_EPOLL_",
    "MHD_D_IS_USING_THREADS_",
    "MHD_ITC_IS_VALID_",
    "MHD_D_DOES_SCKT_FIT_FDSET_",
    "_MHD_DROP_CONST",
    "epoll_itc_marker",
    "setup_epoll_fd",
    "MHD_DLOG",
    "MHD_socket_last_strerr_",
    "MHD_itc_r_fd_",
    "MHD_INVALID_SOCKET",
    "MHD_YES",
    "MHD_NO",
    "MHD_USE_AUTO",
    "MHD_ALLOW_UPGRADE",
    "struct epoll_event",
    "EPOLLIN",
    "EPOLLRDHUP",
    "EPOLL_CTL_ADD",
    "epoll_ctl",
    "struct MHD_Daemon",
    "MHD_socket",
    "true",
    "false"
  ],
  "explanation": "mhd_assert \u2014 macro expansion must be inspected: assertion macros sometimes use compiler extensions (statement expressions, __builtin_*, inline asm) that would violate MISRA rule.  \nMHD_D_IS_USING_EPOLL_ \u2014 macro controlling code paths; its expansion may use extensions (typeof, GCC attributes, etc.).  \nMHD_D_IS_USING_THREADS_ \u2014 same reason as above (macro expansion may contain extensions).  \nMHD_ITC_IS_VALID_ \u2014 macro; its definition could use nonstandard constructs.  \nMHD_D_DOES_SCKT_FIT_FDSET_ \u2014 macro or function-like macro whose expansion could use extensions.  \n_MHD_DROP_CONST \u2014 macro used to drop constness; such casts are often implemented with compiler-specific tricks (casts through uintptr_t, __extension__, or GCC builtins) \u2014 must inspect.  \nepoll_itc_marker \u2014 object whose type/definition might rely on extensions (anonymous objects, attributes).  \nsetup_epoll_fd \u2014 called function; its implementation may contain language extensions that affect correctness or violate the rule.  \nMHD_DLOG \u2014 logging macro/function: variadic macros or special attributes may use extensions; must check its definition.  \nMHD_socket_last_strerr_ \u2014 function/macro used in diagnostics; its definition could use extensions.  \nMHD_itc_r_fd_ \u2014 accessor (macro/function) for ITC read FD; its implementation may hide extensions.  \nMHD_INVALID_SOCKET \u2014 constant/macro: could be defined using casts or expressions that rely on extensions.  \nMHD_YES / MHD_NO \u2014 return-value macros/enum constants: need their definitions to check use of nonstandard enums, implicit conversions, or extension-dependent values.  \nMHD_USE_AUTO / MHD_ALLOW_UPGRADE \u2014 option macros (bitflags); their definitions could use unusual integer literals or extensions.  \nstruct epoll_event \u2014 system struct: inspect for use of anonymous unions/structs or other nonstandard members in the platform headers.  \nEPOLLIN / EPOLLRDHUP / EPOLL_CTL_ADD \u2014 constants used with epoll_ctl: check headers for any nonstandard definitions or uses of extension features.  \nepoll_ctl \u2014 system call wrapper/prototype: check signature and macros around it for extensions.  \nstruct MHD_Daemon \u2014 the daemon structure definition is required to know member types (e.g. listen_fd, epoll_fd, epoll_upgrade_fd, itc, listen_socket_in_epoll) \u2014 these member types or initializers may use extensions (bitfields, anonymous structs, C99 bool, attributes).  \nMHD_socket \u2014 typedef for socket type: could be a platform-specific typedef or macro that uses extensions.  \ntrue / false \u2014 the literal identifiers assigned to listen_socket_in_epoll; need to know whether <stdbool.h> or custom macros are used (custom definitions might be extensions or macros that hide nonstandard behavior).  \n\nRationale summary: The target function heavily uses macros, typedefs and small accessor functions. Any of those definitions may themselves employ compiler or language extensions (statement expressions, typeof, attributes, builtin intrinsics, nonstandard casts, anonymous structs/unions, GCC __extension__, inline asm, etc.). To determine compliance with the MISRA prohibition on language extensions, the next analyzer must be given the exact definitions of these macros, types, and called functions so it can inspect them for extension usage."
}