{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of digest_auth_check_all:\n```c\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all (struct MHD_Connection *connection,\n                       const char *realm,\n                       const char *username,\n                       const char *password,\n                       const uint8_t *userdigest,\n                       unsigned int nonce_timeout,\n                       uint32_t max_nc,\n                       enum MHD_DigestAuthMultiQOP mqop,\n                       enum MHD_DigestAuthMultiAlgo3 malgo3)\n{\n  enum MHD_DigestAuthResult res;\n  char *buf;\n  struct DigestAlgorithm da;\n\n  buf = NULL;\n  digest_setup_zero (&da);\n  if (0 == nonce_timeout)\n    nonce_timeout = connection->daemon->dauth_def_nonce_timeout;\n  if (0 == max_nc)\n    max_nc = connection->daemon->dauth_def_max_nc;\n  res = digest_auth_check_all_inner (connection, realm, username, password,\n                                     userdigest,\n                                     nonce_timeout,\n                                     max_nc, mqop, malgo3,\n                                     &buf, &da);\n  digest_deinit (&da);\n  if (NULL != buf)\n    free (buf);\n\n  return res;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function digest_auth_check_all:\nstatic enum MHD_DigestAuthResult\ndigest_auth_check_all_inner (struct MHD_Connection *connection,\n                             const char *realm,\n                             const char *username,\n                             const char *password,\n                             const uint8_t *userdigest,\n                             unsigned int nonce_timeout,\n                             uint32_t max_nc,\n                             enum MHD_DigestAuthMultiQOP mqop,\n                             enum MHD_DigestAuthMultiAlgo3 malgo3,\n                             char **pbuf,\n                             struct DigestAlgorithm *da)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  enum MHD_DigestAuthAlgo3 c_algo; /**< Client's algorithm */\n  enum MHD_DigestAuthQOP c_qop; /**< Client's QOP */\n  unsigned int digest_size;\n  uint8_t hash1_bin[MAX_DIGEST];\n  uint8_t hash2_bin[MAX_DIGEST];\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n  uint64_t nonce_time;\n  uint64_t nci;\n  const struct MHD_RqDAuth *params;\n  /**\n   * Temporal buffer in stack for unquoting and other needs\n   */\n  char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE];\n  char **const ptmp2 = pbuf;     /**< Temporal malloc'ed buffer for unquoting */\n  size_t tmp2_size; /**< The size of @a tmp2 buffer */\n  struct _MHD_str_w_len unquoted;\n  struct _MHD_mstr_w_len unq_copy;\n  enum _MHD_GetUnqResult unq_res;\n  size_t username_len;\n  size_t realm_len;\n\n  mhd_assert ((NULL != password) || (NULL != userdigest));\n  mhd_assert (! ((NULL != userdigest) && (NULL != password)));\n\n  tmp2_size = 0;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return MHD_DAUTH_WRONG_HEADER;\n\n  /* ** Initial parameters checks and setup ** */\n  /* Get client's algorithm */\n  c_algo = params->algo3;\n  /* Check whether client's algorithm is allowed by function parameter */\n  if (((unsigned int) c_algo) !=\n      (((unsigned int) c_algo) & ((unsigned int) malgo3)))\n    return MHD_DAUTH_WRONG_ALGO;\n  /* Check whether client's algorithm is supported */\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_AUTH_ALGO3_SESSION))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'session' algorithms are not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#ifndef MHD_MD5_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The MD5 algorithm is not supported by this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_MD5_SUPPORT */\n#ifndef MHD_SHA256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA256_SUPPORT */\n#ifndef MHD_SHA512_256_SUPPORT\n  if (0 != (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_SHA512_256))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The SHA-512/256 algorithm is not supported by \"\n                 \"this MHD build.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_ALGO;\n  }\n#endif /* ! MHD_SHA512_256_SUPPORT */\n  if (! digest_init_one_time (da, get_base_digest_algo (c_algo)))\n    MHD_PANIC (_ (\"Wrong 'malgo3' value, API violation\"));\n  /* Check 'mqop' value */\n  c_qop = params->qop;\n  /* Check whether client's QOP is allowed by function parameter */\n  if (((unsigned int) c_qop) !=\n      (((unsigned int) c_qop) & ((unsigned int) mqop)))\n    return MHD_DAUTH_WRONG_QOP;\n  if (0 != (((unsigned int) c_qop) & MHD_DIGEST_AUTH_QOP_AUTH_INT))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The 'auth-int' QOP is not supported.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return MHD_DAUTH_WRONG_QOP;\n  }\n#ifdef HAVE_MESSAGES\n  if ((MHD_DIGEST_AUTH_QOP_NONE == c_qop) &&\n      (0 == (((unsigned int) c_algo) & MHD_DIGEST_BASE_ALGO_MD5)))\n    MHD_DLOG (connection->daemon,\n              _ (\"RFC2069 with SHA-256 or SHA-512/256 algorithm is \" \\\n                 \"non-standard extension.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  digest_size = digest_get_size (da);\n\n  /* ** A quick check for presence of all required parameters ** */\n\n  if ((NULL == params->username.value.str) &&\n      (NULL == params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;\n  else if ((NULL != params->username.value.str) &&\n           (NULL != params->username_ext.value.str))\n    return MHD_DAUTH_WRONG_USERNAME; /* Parameters cannot be used together */\n  else if ((NULL != params->username_ext.value.str) &&\n           (MHD_DAUTH_EXT_PARAM_MIN_LEN > params->username_ext.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Broken extended notation */\n  else if (params->userhash && (NULL == params->username.value.str))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Userhash cannot be used with extended notation */\n  else if (params->userhash && (digest_size * 2 > params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too few chars for correct userhash */\n  else if (params->userhash && (digest_size * 4 < params->username.value.len))\n    return MHD_DAUTH_WRONG_USERNAME;  /* Too many chars for correct userhash */\n\n  if (NULL == params->realm.value.str)\n    return MHD_DAUTH_WRONG_REALM;\n  else if (((NULL == userdigest) || params->userhash) &&\n           (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->realm.value.len))\n    return MHD_DAUTH_TOO_LARGE; /* Realm is too large and should be used in hash calculations */\n\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    if (NULL == params->nc.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->nc.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (4 * 8 < params->nc.value.len) /* Four times more than needed */\n      return MHD_DAUTH_WRONG_HEADER;\n\n    if (NULL == params->cnonce.value.str)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (0 == params->cnonce.value.len)\n      return MHD_DAUTH_WRONG_HEADER;\n    else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->cnonce.value.len)\n      return MHD_DAUTH_TOO_LARGE;\n  }\n\n  /* The QOP parameter was checked already */\n\n  if (NULL == params->uri.value.str)\n    return MHD_DAUTH_WRONG_URI;\n  else if (0 == params->uri.value.len)\n    return MHD_DAUTH_WRONG_URI;\n  else if (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < params->uri.value.len)\n    return MHD_DAUTH_TOO_LARGE;\n\n  if (NULL == params->nonce.value.str)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (0 == params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n  else if (NONCE_STD_LEN (digest_size) * 2 < params->nonce.value.len)\n    return MHD_DAUTH_NONCE_WRONG;\n\n  if (NULL == params->response.value.str)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (0 == params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n  else if (digest_size * 4 < params->response.value.len)\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* ** Check simple parameters match ** */\n\n  /* Check 'algorithm' */\n  /* The 'algorithm' was checked at the start of the function */\n  /* 'algorithm' valid */\n\n  /* Check 'qop' */\n  /* The 'qop' was checked at the start of the function */\n  /* 'qop' valid */\n\n  /* Check 'realm' */\n  realm_len = strlen (realm);\n  if (! is_param_equal (&params->realm, realm, realm_len))\n    return MHD_DAUTH_WRONG_REALM;\n  /* 'realm' valid */\n\n  /* Check 'username' */\n  username_len = strlen (username);\n  if (! params->userhash)\n  {\n    if (NULL != params->username.value.str)\n    { /* Username in standard notation */\n      if (! is_param_equal (&params->username, username, username_len))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n    else\n    { /* Username in extended notation */\n      char *r_uname;\n      size_t buf_size = params->username_ext.value.len;\n      ssize_t res;\n\n      mhd_assert (NULL != params->username_ext.value.str);\n      mhd_assert (MHD_DAUTH_EXT_PARAM_MIN_LEN <= buf_size); /* It was checked already */\n      buf_size += 1; /* For zero-termination */\n      buf_size -= MHD_DAUTH_EXT_PARAM_MIN_LEN;\n      r_uname = get_buffer_for_size (tmp1, ptmp2, &tmp2_size, buf_size);\n      if (NULL == r_uname)\n        return (_MHD_AUTH_DIGEST_MAX_PARAM_SIZE < buf_size) ?\n               MHD_DAUTH_TOO_LARGE : MHD_DAUTH_ERROR;\n      res = get_rq_extended_uname_copy_z (params->username_ext.value.str,\n                                          params->username_ext.value.len,\n                                          r_uname, buf_size);\n      if (0 > res)\n        return MHD_DAUTH_WRONG_HEADER; /* Broken extended notation */\n      if ((username_len != (size_t) res) ||\n          (0 != memcmp (username, r_uname, username_len)))\n        return MHD_DAUTH_WRONG_USERNAME;\n    }\n  }\n  else\n  { /* Userhash */\n    mhd_assert (NULL != params->username.value.str);\n    calc_userhash (da, username, username_len, realm, realm_len, hash1_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n    mhd_assert (sizeof (tmp1) >= (2 * digest_size));\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n    if (! is_param_equal_caseless (&params->username, tmp1, 2 * digest_size))\n      return MHD_DAUTH_WRONG_USERNAME;\n    /* To simplify the logic, the digest is reset here instead of resetting\n       before the next hash calculation. */\n    digest_reset (da);\n  }\n  /* 'username' valid */\n\n  /* ** Do basic nonce and nonce-counter checks (size, timestamp) ** */\n\n  /* Get 'nc' digital value */\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n\n    if (unquoted.len != MHD_strx_to_uint64_n_ (unquoted.str,\n                                               unquoted.len,\n                                               &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nonce format */\n    }\n    if (0 == nci)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Authentication failed, invalid 'nc' value.\\n\"));\n#endif\n      return MHD_DAUTH_WRONG_HEADER;   /* invalid nc value */\n    }\n    if ((0 != max_nc) && (max_nc < nci))\n      return MHD_DAUTH_NONCE_STALE;    /* Too large 'nc' value */\n  }\n  else\n    nci = 1; /* Force 'nc' value */\n  /* Got 'nc' digital value */\n\n  /* Get 'nonce' with basic checks */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  if ((NONCE_STD_LEN (digest_size) != unquoted.len) ||\n      (! get_nonce_timestamp (unquoted.str, unquoted.len, &nonce_time)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, invalid nonce format.\\n\"));\n#endif\n    return MHD_DAUTH_NONCE_WRONG;\n  }\n\n  if (1)\n  {\n    uint64_t t;\n\n    t = MHD_monotonic_msec_counter ();\n    /*\n     * First level vetting for the nonce validity: if the timestamp\n     * attached to the nonce exceeds `nonce_timeout', then the nonce is\n     * stale.\n     */\n    if (TRIM_TO_TIMESTAMP (t - nonce_time) > (nonce_timeout * 1000))\n      return MHD_DAUTH_NONCE_STALE; /* too old */\n  }\n  if (1)\n  {\n    enum MHD_CheckNonceNC_ nonce_nc_check;\n    /*\n     * Checking if that combination of nonce and nc is sound\n     * and not a replay attack attempt. Refuse if nonce was not\n     * generated previously.\n     */\n    nonce_nc_check = check_nonce_nc (connection,\n                                     unquoted.str,\n                                     NONCE_STD_LEN (digest_size),\n                                     nonce_time,\n                                     nci);\n    if (MHD_CHECK_NONCENC_STALE == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. If this happens a lot, you should \"\n                     \"probably increase the size of the nonce array.\\n\"));\n      else\n        MHD_DLOG (daemon,\n                  _ (\"Stale nonce received. This is expected when client \" \\\n                     \"uses RFC2069-compatible mode and makes more than one \" \\\n                     \"request.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_STALE;\n    }\n    else if (MHD_CHECK_NONCENC_WRONG == nonce_nc_check)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _ (\"Received nonce that was not \"\n                   \"generated by MHD. This may indicate an attack attempt.\\n\"));\n#endif\n      return MHD_DAUTH_NONCE_WRONG;\n    }\n    mhd_assert (MHD_CHECK_NONCENC_OK == nonce_nc_check);\n  }\n  /* The nonce was generated by MHD, is not stale and nonce-nc combination was\n     not used before */\n\n  /* ** Build H(A2) and check URI match in the header and in the request ** */\n\n  /* Get 'uri' */\n  mhd_assert (! da->hashing);\n  digest_update_str (da, connection->rq.method);\n  digest_update_with_colon (da);\n#if 0\n  /* TODO: add support for \"auth-int\" */\n  digest_update_str (da, hentity);\n  digest_update_with_colon (da);\n#endif\n  unq_res = get_unquoted_param_copy (&params->uri, tmp1, ptmp2, &tmp2_size,\n                                     &unq_copy);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n\n  digest_update (da, unq_copy.str, unq_copy.len);\n  /* The next check will modify copied URI string */\n  if (! check_uri_match (connection, unq_copy.str, unq_copy.len))\n    return MHD_DAUTH_WRONG_URI;\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  /* Skip digest calculation external error check, the next one checks both */\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A2) */\n\n  /* ** Build H(A1) ** */\n  if (NULL == userdigest)\n  {\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calc_userdigest (da,\n                     username, username_len,\n                     realm, realm_len,\n                     password,\n                     hash1_bin);\n  }\n  /* TODO: support '-sess' versions */\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n  /* Got H(A1) */\n\n  /* **  Check 'response' ** */\n\n  mhd_assert (! da->hashing);\n  digest_reset (da);\n  /* Update digest with H(A1) */\n  mhd_assert (sizeof (tmp1) >= (digest_size * 2));\n  if (NULL == userdigest)\n    MHD_bin_to_hex (hash1_bin, digest_size, tmp1);\n  else\n    MHD_bin_to_hex (userdigest, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A1) is not needed anymore, reuse the buffer.\n   * Use hash1_bin for the client's 'response' decoded to binary form. */\n  unq_res = get_unquoted_param (&params->response, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  if (digest_size != MHD_hex_to_bin (unquoted.str, unquoted.len, hash1_bin))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  /* Update digest with 'nonce' text value */\n  unq_res = get_unquoted_param (&params->nonce, tmp1, ptmp2, &tmp2_size,\n                                &unquoted);\n  if (_MHD_UNQ_OK != unq_res)\n    return MHD_DAUTH_ERROR;\n  digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n  /* Update digest with ':' */\n  digest_update_with_colon (da);\n  if (MHD_DIGEST_AUTH_QOP_NONE != c_qop)\n  {\n    /* Update digest with 'nc' text value */\n    unq_res = get_unquoted_param (&params->nc, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'cnonce' value */\n    unq_res = get_unquoted_param (&params->cnonce, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n    /* Update digest with 'qop' value */\n    unq_res = get_unquoted_param (&params->qop_raw, tmp1, ptmp2, &tmp2_size,\n                                  &unquoted);\n    if (_MHD_UNQ_OK != unq_res)\n      return MHD_DAUTH_ERROR;\n    digest_update (da, (const uint8_t *) unquoted.str, unquoted.len);\n    /* Update digest with ':' */\n    digest_update_with_colon (da);\n  }\n  /* Update digest with H(A2) */\n  MHD_bin_to_hex (hash2_bin, digest_size, tmp1);\n  digest_update (da, (const uint8_t *) tmp1, digest_size * 2);\n\n  /* H(A2) is not needed anymore, reuse the buffer.\n   * Use hash2_bin for the calculated response in binary form */\n  digest_calc_hash (da, hash2_bin);\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n  if (digest_ext_error (da))\n    return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n  if (0 != memcmp (hash1_bin, hash2_bin, digest_size))\n    return MHD_DAUTH_RESPONSE_WRONG;\n\n  if (MHD_DAUTH_BIND_NONCE_NONE != daemon->dauth_bind_type)\n  {\n    mhd_assert (sizeof(tmp1) >= (NONCE_STD_LEN (digest_size) + 1));\n    /* It was already checked that 'nonce' (including timestamp) was generated\n       by MHD. */\n    mhd_assert (! da->hashing);\n    digest_reset (da);\n    calculate_nonce (nonce_time,\n                     connection->rq.http_mthd,\n                     connection->rq.method,\n                     daemon->digest_auth_random,\n                     daemon->digest_auth_rand_size,\n                     connection->addr,\n                     (size_t) connection->addr_len,\n                     connection->rq.url,\n                     connection->rq.url_len,\n                     connection->rq.headers_received,\n                     realm,\n                     realm_len,\n                     daemon->dauth_bind_type,\n                     da,\n                     tmp1);\n\n#ifdef MHD_DIGEST_HAS_EXT_ERROR\n    if (digest_ext_error (da))\n      return MHD_DAUTH_ERROR;\n#endif /* MHD_DIGEST_HAS_EXT_ERROR */\n\n    if (! is_param_equal (&params->nonce, tmp1,\n                          NONCE_STD_LEN (digest_size)))\n      return MHD_DAUTH_NONCE_OTHER_COND;\n    /* The 'nonce' was generated in the same conditions */\n  }\n\n  return MHD_DAUTH_OK;\n}\n...\nconst struct MHD_RqDAuth *\nMHD_get_rq_dauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqDAuth *dauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.dauth_tried)\n    return connection->rq.dauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_DIGEST, &h_auth_value))\n  {\n    connection->rq.dauth_tried = true;\n    connection->rq.dauth = NULL;\n    return NULL;\n  }\n\n  dauth =\n    (struct MHD_RqDAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqDAuth));\n\n  if (NULL == dauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Digest Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (dauth, 0, sizeof(struct MHD_RqDAuth));\n  if (parse_dauth_params (h_auth_value.str, h_auth_value.len, dauth))\n    connection->rq.dauth = dauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Digest Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.dauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.dauth_tried = true;\n  return connection->rq.dauth;\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\n_MHD_static_inline bool\ndigest_init_one_time (struct DigestAlgorithm *da,\n                      enum MHD_DigestBaseAlgo algo)\n{\n#ifdef _DEBUG\n  da->uninitialised = false;\n  da->algo_selected = false;\n  da->ready_for_hashing = false;\n  da->hashing = false;\n#endif /* _DEBUG */\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_MD5;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_MD5_init_one_time (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA256_init_one_time (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == algo)\n  {\n    da->algo = MHD_DIGEST_BASE_ALGO_SHA512_256;\n#ifdef _DEBUG\n    da->algo_selected = true;\n#endif\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n    return true;\n  }\n#endif /* MHD_SHA512_256_SUPPORT */\n\n  da->algo = MHD_DIGEST_BASE_ALGO_INVALID;\n  return false; /* Unsupported or bad algorithm */\n}\n...\n_MHD_static_inline enum MHD_DigestBaseAlgo\nget_base_digest_algo (enum MHD_DigestAuthAlgo3 algo3)\n{\n  unsigned int base_algo;\n\n  base_algo =\n    ((unsigned int) algo3)\n    & ~((unsigned int)\n        (MHD_DIGEST_AUTH_ALGO3_NON_SESSION\n         | MHD_DIGEST_AUTH_ALGO3_NON_SESSION));\n  return (enum MHD_DigestBaseAlgo) base_algo;\n}\n...\n_MHD_static_inline unsigned int\ndigest_get_size (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    return MD5_DIGEST_SIZE;\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    return SHA256_DIGEST_SIZE;\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    return SHA512_256_DIGEST_SIZE;\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0); /* May not happen */\n  return 0;\n}\n...\n_MHD_static_inline bool\nis_param_equal (const struct MHD_RqDAuthParam *param,\n                const char *const str,\n                const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n...\nstatic char *\nget_buffer_for_size (char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                     char **ptmp2,\n                     size_t *ptmp2_size,\n                     size_t required_size)\n{\n  mhd_assert ((0 == *ptmp2_size) || (NULL != *ptmp2));\n  mhd_assert ((NULL != *ptmp2) || (0 == *ptmp2_size));\n  mhd_assert ((0 == *ptmp2_size) || \\\n              (_MHD_STATIC_UNQ_BUFFER_SIZE < *ptmp2_size));\n\n  if (required_size <= _MHD_STATIC_UNQ_BUFFER_SIZE)\n    return tmp1;\n\n  if (required_size <= *ptmp2_size)\n    return *ptmp2;\n\n  if (required_size > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE)\n    return NULL;\n  if (NULL != *ptmp2)\n    free (*ptmp2);\n  *ptmp2 = (char *) malloc (required_size);\n  if (NULL == *ptmp2)\n    *ptmp2_size = 0;\n  else\n    *ptmp2_size = required_size;\n  return *ptmp2;\n}\n...\nstatic ssize_t\nget_rq_extended_uname_copy_z (const char *uname_ext, size_t uname_ext_len,\n                              char *buf, size_t buf_size)\n{\n  size_t r;\n  size_t w;\n  if ((size_t) SSIZE_MAX < uname_ext_len)\n    return -1; /* Too long input string */\n\n  if (MHD_DAUTH_EXT_PARAM_MIN_LEN > uname_ext_len)\n    return -1; /* Required prefix is missing */\n\n  if (! MHD_str_equal_caseless_bin_n_ (uname_ext, MHD_DAUTH_EXT_PARAM_PREFIX,\n                                       MHD_STATICSTR_LEN_ ( \\\n                                         MHD_DAUTH_EXT_PARAM_PREFIX)))\n    return -1; /* Only UTF-8 is supported, as it is implied by RFC 7616 */\n\n  r = MHD_STATICSTR_LEN_ (MHD_DAUTH_EXT_PARAM_PREFIX);\n  /* Skip language tag */\n  while (r < uname_ext_len && '\\'' != uname_ext[r])\n  {\n    const char chr = uname_ext[r];\n    if ((' ' == chr) || ('\\t' == chr) || ('\\\"' == chr) || (',' == chr) ||\n        (';' == chr) )\n      return -1; /* Wrong char in language tag */\n    r++;\n  }\n  if (r >= uname_ext_len)\n    return -1; /* The end of the language tag was not found */\n  r++; /* Advance to the next char */\n\n  w = MHD_str_pct_decode_strict_n_ (uname_ext + r, uname_ext_len - r,\n                                    buf, buf_size);\n  if ((0 == w) && (0 != uname_ext_len - r))\n    return -1; /* Broken percent encoding */\n  buf[w] = 0; /* Zero terminate the result */\n  mhd_assert (SSIZE_MAX > w);\n  return (ssize_t) w;\n}\n...\n_MHD_static_inline void\ncalc_userhash (struct DigestAlgorithm *da,\n               const char *username, const size_t username_len,\n               const char *realm, const size_t realm_len,\n               uint8_t *digest_bin)\n{\n  mhd_assert (NULL != username);\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_calc_hash (da, digest_bin);\n}\n...\nsize_t\nMHD_bin_to_hex (const void *bin,\n                size_t size,\n                char *hex)\n{\n  size_t i;\n\n  for (i = 0; i < size; ++i)\n  {\n    uint8_t j;\n    const uint8_t b = ((const uint8_t *) bin)[i];\n    j = b >> 4;\n    hex[i * 2] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n    j = b & 0x0f;\n    hex[i * 2 + 1] = (char) ((j < 10) ? (j + '0') : (j - 10 + 'a'));\n  }\n  return i * 2;\n}\n...\n_MHD_static_inline bool\nis_param_equal_caseless (const struct MHD_RqDAuthParam *param,\n                         const char *const str,\n                         const size_t str_len)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n  if (param->quoted)\n    return MHD_str_equal_quoted_bin_n (param->value.str, param->value.len,\n                                       str, str_len);\n  return (str_len == param->value.len) &&\n         (0 == memcmp (str, param->value.str, str_len));\n\n}\n...\n_MHD_static_inline void\ndigest_reset (struct DigestAlgorithm *da)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (! da->hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    mhd_assert (! da->ready_for_hashing);\n#else  /* ! MHD_MD5_HAS_FINISH */\n    mhd_assert (da->ready_for_hashing);\n#endif /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_reset (&da->ctx.md5_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    mhd_assert (! da->ready_for_hashing);\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    mhd_assert (da->ready_for_hashing);\n#endif /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_reset (&da->ctx.sha256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    mhd_assert (! da->ready_for_hashing);\n    MHD_SHA512_256_init (&da->ctx.sha512_256_ctx);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  {\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif\n    mhd_assert (0); /* May not happen, bad algorithm */\n  }\n}\n...\nstatic enum _MHD_GetUnqResult\nget_unquoted_param (const struct MHD_RqDAuthParam *param,\n                    char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                    char **ptmp2,\n                    size_t *ptmp2_size,\n                    struct _MHD_str_w_len *unquoted)\n{\n  char *str;\n  size_t len;\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  if (! param->quoted)\n  {\n    unquoted->str = param->value.str;\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  str = get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len);\n  if (NULL == str)\n    return (param->value.len > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  len = MHD_str_unquote (param->value.str, param->value.len, str);\n  unquoted->str = str;\n  unquoted->len = len;\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n...\nsize_t\nMHD_strx_to_uint64_n_ (const char *str,\n                       size_t maxlen,\n                       uint64_t *out_val)\n{\n  size_t i;\n  uint64_t res;\n  int digit;\n  if (! str || ! out_val)\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (i < maxlen && (digit = toxdigitvalue (str[i])) >= 0)\n  {\n    if ( (res > (UINT64_MAX / 16)) ||\n         ((res == (UINT64_MAX / 16)) &&\n          ( (uint64_t) digit > (UINT64_MAX % 16)) ) )\n      return 0;\n\n    res *= 16;\n    res += (unsigned int) digit;\n    i++;\n  }\n\n  if (i)\n    *out_val = res;\n  return i;\n}\n...\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n...\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n...\nstatic enum MHD_CheckNonceNC_\ncheck_nonce_nc (struct MHD_Connection *connection,\n                const char *nonce,\n                size_t noncelen,\n                uint64_t nonce_time,\n                uint64_t nc)\n{\n  struct MHD_Daemon *daemon = MHD_get_master (connection->daemon);\n  struct MHD_NonceNc *nn;\n  uint32_t mod;\n  enum MHD_CheckNonceNC_ ret;\n\n  mhd_assert (0 != noncelen);\n  mhd_assert (0 != nc);\n  if (MAX_DIGEST_NONCE_LENGTH < noncelen)\n    return MHD_CHECK_NONCENC_WRONG; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n  mod = daemon->nonce_nc_size;\n  if (0 == mod)\n    return MHD_CHECK_NONCENC_STALE;  /* no array! */\n  if (nc >= UINT32_MAX - 64)\n    return MHD_CHECK_NONCENC_STALE;  /* Overflow, unrealistically high value */\n\n  nn = &daemon->nnc[get_nonce_nc_idx (mod, nonce, noncelen)];\n\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n\n  mhd_assert (0 == nn->nonce[noncelen]); /* The old value must be valid */\n\n  if ( (0 != memcmp (nn->nonce, nonce, noncelen)) ||\n       (0 != nn->nonce[noncelen]) )\n  { /* The nonce in the slot does not match nonce from the client */\n    if (0 == nn->nonce[0])\n    { /* The slot was never used, while the client's nonce value should be\n       * recorded when it was generated by MHD */\n      ret = MHD_CHECK_NONCENC_WRONG;\n    }\n    else if (0 != nn->nonce[noncelen])\n    { /* The value is the slot is wrong */\n      ret =  MHD_CHECK_NONCENC_STALE;\n    }\n    else\n    {\n      uint64_t slot_ts; /**< The timestamp in the slot */\n      if (! get_nonce_timestamp (nn->nonce, noncelen, &slot_ts))\n      {\n        mhd_assert (0); /* The value is the slot is wrong */\n        ret = MHD_CHECK_NONCENC_STALE;\n      }\n      else\n      {\n        /* Unsigned value, will be large if nonce_time is less than slot_ts */\n        const uint64_t ts_diff = TRIM_TO_TIMESTAMP (nonce_time - slot_ts);\n        if ((REUSE_TIMEOUT * 1000) >= ts_diff)\n        {\n          /* The nonce from the client may not have been placed in the slot\n           * because another nonce in that slot has not yet expired. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else if (TRIM_TO_TIMESTAMP (UINT64_MAX) / 2 >= ts_diff)\n        {\n          /* Too large value means that nonce_time is less than slot_ts.\n           * The nonce from the client may have been overwritten by the newer\n           * nonce. */\n          ret = MHD_CHECK_NONCENC_STALE;\n        }\n        else\n        {\n          /* The nonce from the client should be generated after the nonce\n           * in the slot has been expired, the nonce must be recorded, but\n           * it's not. */\n          ret = MHD_CHECK_NONCENC_WRONG;\n        }\n      }\n    }\n  }\n  else if (nc > nn->nc)\n  {\n    /* 'nc' is larger, shift bitmask and bump limit */\n    const uint32_t jump_size = (uint32_t) nc - nn->nc;\n    if (64 > jump_size)\n    {\n      /* small jump, less than mask width */\n      nn->nmask <<= jump_size;\n      /* Set bit for the old 'nc' value */\n      nn->nmask |= (UINT64_C (1) << (jump_size - 1));\n    }\n    else if (64 == jump_size)\n      nn->nmask = (UINT64_C (1) << 63);\n    else\n      nn->nmask = 0;                /* big jump, unset all bits in the mask */\n    nn->nc = (uint32_t) nc;\n    ret = MHD_CHECK_NONCENC_OK;\n  }\n  else if (nc < nn->nc)\n  {\n    /* Note that we use 64 here, as we do not store the\n       bit for 'nn->nc' itself in 'nn->nmask' */\n    if ( (nc + 64 >= nn->nc) &&\n         (0 == ((UINT64_C (1) << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (UINT64_C (1) << (nn->nc - nc - 1));\n      ret = MHD_CHECK_NONCENC_OK;\n    }\n    else\n      /* 'nc' was already used or too old (more then 64 values ago) */\n      ret = MHD_CHECK_NONCENC_STALE;\n  }\n  else /* if (nc == nn->nc) */\n    /* 'nc' was already used */\n    ret = MHD_CHECK_NONCENC_STALE;\n\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n\n  return ret;\n}\n...\n_MHD_static_inline void\ndigest_update_str (struct DigestAlgorithm *da,\n                   const char *str)\n{\n  const size_t str_len = strlen (str);\n  digest_update (da, (const uint8_t *) str, str_len);\n}\n...\n_MHD_static_inline void\ndigest_update_with_colon (struct DigestAlgorithm *da)\n{\n  static const uint8_t colon = (uint8_t) ':';\n  digest_update (da, &colon, 1);\n}\n...\nstatic enum _MHD_GetUnqResult\nget_unquoted_param_copy (const struct MHD_RqDAuthParam *param,\n                         char tmp1[_MHD_STATIC_UNQ_BUFFER_SIZE],\n                         char **ptmp2,\n                         size_t *ptmp2_size,\n                         struct _MHD_mstr_w_len *unquoted)\n{\n  mhd_assert (NULL != param->value.str);\n  mhd_assert (0 != param->value.len);\n\n  /* The value is present and is quoted, needs to be copied and unquoted */\n  /* Allocate buffer with one more additional byte for zero-termination */\n  unquoted->str =\n    get_buffer_for_size (tmp1, ptmp2, ptmp2_size, param->value.len + 1);\n\n  if (NULL == unquoted->str)\n    return (param->value.len + 1 > _MHD_AUTH_DIGEST_MAX_PARAM_SIZE) ?\n           _MHD_UNQ_TOO_LARGE : _MHD_UNQ_OUT_OF_MEM;\n\n  if (! param->quoted)\n  {\n    memcpy (unquoted->str, param->value.str, param->value.len);\n    unquoted->len = param->value.len;\n    return _MHD_UNQ_OK;\n  }\n\n  unquoted->len =\n    MHD_str_unquote (param->value.str, param->value.len, unquoted->str);\n  mhd_assert (0 != unquoted->len);\n  mhd_assert (unquoted->len < param->value.len);\n  return _MHD_UNQ_OK;\n}\n...\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n...\nstatic bool\ncheck_uri_match (struct MHD_Connection *connection, char *uri, size_t uri_len)\n{\n  char *qmark;\n  char *args;\n  struct MHD_Daemon *const daemon = connection->daemon;\n\n  uri[uri_len] = 0;\n  qmark = memchr (uri,\n                  '?',\n                  uri_len);\n  if (NULL != qmark)\n    *qmark = '\\0';\n\n  /* Need to unescape URI before comparing with connection->url */\n  uri_len = daemon->unescape_callback (daemon->unescape_callback_cls,\n                                       connection,\n                                       uri);\n  if ((uri_len != connection->rq.url_len) ||\n      (0 != memcmp (uri, connection->rq.url, uri_len)))\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, URI does not match.\\n\"));\n#endif\n    return false;\n  }\n\n  args = (NULL != qmark) ? (qmark + 1) : uri + uri_len;\n\n  if (! check_argument_match (connection,\n                              args) )\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (daemon,\n              _ (\"Authentication failed, arguments do not match.\\n\"));\n#endif\n    return false;\n  }\n  return true;\n}\n...\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n...\n_MHD_static_inline void\ncalc_userdigest (struct DigestAlgorithm *da,\n                 const char *username, const size_t username_len,\n                 const char *realm, const size_t realm_len,\n                 const char *password,\n                 uint8_t *ha1_bin)\n{\n  mhd_assert (! da->hashing);\n  digest_update (da, username, username_len);\n  digest_update_with_colon (da);\n  digest_update (da, realm, realm_len);\n  digest_update_with_colon (da);\n  digest_update_str (da, password);\n  digest_calc_hash (da, ha1_bin);\n}\n...\nsize_t\nMHD_hex_to_bin (const char *hex,\n                size_t len,\n                void *bin)\n{\n  uint8_t *const out = (uint8_t *) bin;\n  size_t r;\n  size_t w;\n\n  if (0 == len)\n    return 0;\n  r = 0;\n  w = 0;\n  if (0 != len % 2)\n  {\n    /* Assume the first byte is encoded with single digit */\n    const int l = toxdigitvalue (hex[r++]);\n    if (0 > l)\n      return 0;\n    out[w++] = (uint8_t) ((unsigned int) l);\n  }\n  while (r < len)\n  {\n    const int h = toxdigitvalue (hex[r++]);\n    const int l = toxdigitvalue (hex[r++]);\n    if ((0 > h) || (0 > l))\n      return 0;\n    out[w++] = (uint8_t) ( ((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                           | ((uint8_t) ((unsigned int) l)) );\n  }\n  mhd_assert (len == r);\n  mhd_assert ((len + 1) / 2 == w);\n  return w;\n}\n...\nstatic void\ncalculate_nonce (uint64_t nonce_time,\n                 enum MHD_HTTP_Method mthd_e,\n                 const char *method,\n                 const char *rnd,\n                 size_t rnd_size,\n                 const struct sockaddr_storage *saddr,\n                 size_t saddr_size,\n                 const char *uri,\n                 size_t uri_len,\n                 const struct MHD_HTTP_Req_Header *first_header,\n                 const char *realm,\n                 size_t realm_len,\n                 unsigned int bind_options,\n                 struct DigestAlgorithm *da,\n                 char *nonce)\n{\n  mhd_assert (! da->hashing);\n  if (1)\n  {\n    /* Add the timestamp to the hash calculation */\n    uint8_t timestamp[TIMESTAMP_BIN_SIZE];\n    /* If the nonce_time is milliseconds, then the same 48 bit value will repeat\n     * every 8 919 years, which is more than enough to mitigate a replay attack */\n#if TIMESTAMP_BIN_SIZE != 6\n#error The code needs to be updated here\n#endif\n    timestamp[0] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 0)));\n    timestamp[1] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 1)));\n    timestamp[2] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 2)));\n    timestamp[3] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 3)));\n    timestamp[4] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 4)));\n    timestamp[5] = (uint8_t) (nonce_time >> (8 * (TIMESTAMP_BIN_SIZE - 1 - 5)));\n    MHD_bin_to_hex (timestamp,\n                    sizeof (timestamp),\n                    nonce + digest_get_size (da) * 2);\n    digest_update (da,\n                   timestamp,\n                   sizeof (timestamp));\n  }\n  if (rnd_size > 0)\n  {\n    /* Add the unique random value to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   rnd,\n                   rnd_size);\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) &&\n       (0 != saddr_size) )\n  {\n    /* Add full client address including source port to make unique nonces\n     * for requests received exactly at the same time */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   saddr,\n                   saddr_size);\n  }\n  if ( (0 != (bind_options & MHD_DAUTH_BIND_NONCE_CLIENT_IP)) &&\n       (0 != saddr_size) )\n  {\n    /* Add the client's IP address to the hash calculation */\n    digest_update_with_colon (da);\n    if (AF_INET == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in *) saddr)->sin_addr,\n                     sizeof(((const struct sockaddr_in *) saddr)->sin_addr));\n#ifdef HAVE_INET6\n    else if (AF_INET6 == saddr->ss_family)\n      digest_update (da,\n                     &((const struct sockaddr_in6 *) saddr)->sin6_addr,\n                     sizeof(((const struct sockaddr_in6 *) saddr)->sin6_addr));\n#endif /* HAVE_INET6 */\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI)))\n  {\n    /* Add the request method to the hash calculation */\n    digest_update_with_colon (da);\n    if (MHD_HTTP_MTHD_OTHER != mthd_e)\n    {\n      uint8_t mthd_for_hash;\n      if (MHD_HTTP_MTHD_HEAD != mthd_e)\n        mthd_for_hash = (uint8_t) mthd_e;\n      else /* Treat HEAD method in the same way as GET method */\n        mthd_for_hash = (uint8_t) MHD_HTTP_MTHD_GET;\n      digest_update (da,\n                     &mthd_for_hash,\n                     sizeof(mthd_for_hash));\n    }\n    else\n      digest_update_str (da, method);\n  }\n\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI))\n  {\n    /* Add the request URI to the hash calculation */\n    digest_update_with_colon (da);\n\n    digest_update (da,\n                   uri,\n                   uri_len);\n  }\n  if (0 != (bind_options & MHD_DAUTH_BIND_NONCE_URI_PARAMS))\n  {\n    /* Add the request URI parameters to the hash calculation */\n    const struct MHD_HTTP_Req_Header *h;\n\n    digest_update_with_colon (da);\n    for (h = first_header; NULL != h; h = h->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != h->kind)\n        continue;\n      digest_update (da, \"\\0\", 2);\n      if (0 != h->header_size)\n        digest_update (da, h->header, h->header_size);\n      digest_update (da, \"\", 1);\n      if (0 != h->value_size)\n        digest_update (da, h->value, h->value_size);\n    }\n  }\n  if ( (MHD_DAUTH_BIND_NONCE_NONE == bind_options) ||\n       (0 != (bind_options & MHD_DAUTH_BIND_NONCE_REALM)))\n  {\n    /* Add the realm to the hash calculation */\n    digest_update_with_colon (da);\n    digest_update (da,\n                   realm,\n                   realm_len);\n  }\n  if (1)\n  {\n    uint8_t hash[MAX_DIGEST];\n    digest_calc_hash (da, hash);\n    MHD_bin_to_hex (hash,\n                    digest_get_size (da),\n                    nonce);\n  }\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\n#if 0\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n#endif\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: the code inside `#if 0 ... #endif` is removed by the preprocessor and therefore is not part of the translation unit; MISRA Rule 2.1 applies to code present in the compiled translation unit that can never be executed. (A violating scenario would be, for example, statements after an unconditional `return` in the same function body that remain in the compiled code and can never be reached.)"
}