{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}, 'MHD_lookup_connection_value': {'callees': ['MHD_lookup_connection_value_n'], 'callers': ['ahc_echo', 'get_session', 'ahc_cb', 'can_compress']}, 'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'send_chat_page': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': ['ahc_cb']}, 'send_bad_request': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': ['ahc_cb']}, 'send_upgrade_required': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': ['ahc_cb']}, 'MHD_lookup_connection_value_n': {'callees': [], 'callers': ['MHD_lookup_connection_value', 'need_100_continue', 'get_no_space_err_status_code', 'parse_cookie_header', 'parse_connection_headers', 'MHD_create_post_processor', 'ahc_cb']}, 'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}, 'MHD_create_response_for_upgrade': {'callees': ['MHD_add_response_header', 'MHD_destroy_response'], 'callers': ['ahc_echo', 'ahc_cb']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_lookup_connection_value",
    "MHD_lookup_connection_value_n",
    "is_websocket_request",
    "send_chat_page",
    "send_bad_request",
    "send_upgrade_required",
    "ws_get_accept_value",
    "MHD_create_response_for_upgrade",
    "MHD_add_response_header",
    "MHD_destroy_response",
    "MHD_queue_response",
    "uh_cb",
    "MHD_YES",
    "MHD_NO",
    "MHD_HTTP_SWITCHING_PROTOCOLS",
    "MHD_HEADER_KIND",
    "MHD_HTTP_HEADER_UPGRADE",
    "MHD_HTTP_HEADER_CONNECTION",
    "MHD_HTTP_METHOD_GET",
    "MHD_HTTP_VERSION_1_1",
    "MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION",
    "WS_SEC_WEBSOCKET_VERSION",
    "MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY",
    "WS_KEY_LEN",
    "MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT",
    "WS_UPGRADE_VALUE",
    "strlen",
    "strcmp",
    "free",
    "enum MHD_Result"
  ],
  "explanation": "For verifying whether any statements in ahc_cb are dead (i.e. executed but removable without changing program behaviour) we must know which branches and side-effects are actually possible at runtime. Each listed symbol is needed for that reasoning:\n\n- MHD_lookup_connection_value: determines how upgrade/connection/version headers are looked up; its possible return behaviors affect branch reachability (e.g. selects websocket vs non-websocket path).\n- MHD_lookup_connection_value_n: used to obtain Sec-WebSocket-Key and key_size; semantics (return codes, whether it sets pointer/size) decide whether the key-check branch can be taken.\n- is_websocket_request: its return values (MHD_YES/MHD_NO) determine whether the websocket upgrade code path is ever reached vs send_chat_page \u2014 essential to decide if subsequent code is dead.\n- send_chat_page: has side effects (response creation/queue) that matter for behaviour; needed to know if omitting the non-websocket branch would change behaviour.\n- send_bad_request: called on several validation failures; must know its side effects to decide if those calls are meaningful.\n- send_upgrade_required: similar to send_bad_request \u2014 verifies behaviour when Sec-WebSocket-Version mismatches.\n- ws_get_accept_value: computes Sec-WebSocket-Accept and allocates ws_ac_value; its success/failure and allocation side effects affect whether following code (header add/free) is required.\n- MHD_create_response_for_upgrade: creates a response object used later; whether it can fail or has side effects affects dead-code analysis for response-manipulation code.\n- MHD_add_response_header: return value and side effects determine whether header-add branches (and the corresponding cleanup) can be skipped without changing behaviour.\n- MHD_destroy_response: deallocates response \u2014 required to reason about resource-release side effects in each branch (removal might change behaviour if resources or callbacks are important).\n- MHD_queue_response: enqueues the response and returns a result; side effects and return values determine whether queuing is necessary for observable behaviour.\n- uh_cb: callback passed to MHD_create_response_for_upgrade \u2014 its presence/behaviour could have observable effects (timing/side-effects) making the upgrade response path non-dead.\n- MHD_YES / MHD_NO / enum MHD_Result: the exact enumerators and semantics are needed to interpret return-value checks and branch conditions throughout ahc_cb.\n- MHD_HTTP_SWITCHING_PROTOCOLS: response code used when queuing the upgrade response; needed to reason about observable protocol behaviour.\n- MHD_HEADER_KIND: header-kind constant used in lookups \u2014 required to understand MHD_lookup_* semantics in context.\n- MHD_HTTP_HEADER_UPGRADE, MHD_HTTP_HEADER_CONNECTION, MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION, MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT: header-name constants used in lookups/additions; their exact strings/semantics determine whether header matches are possible (affects reachability of branches).\n- WS_SEC_WEBSOCKET_VERSION: expected Sec-WebSocket-Version value used in strcmp check \u2014 required to decide if that branch can be true or always false.\n- WS_KEY_LEN: expected key length used to validate lookup result; needed to know whether the key-size condition can pass.\n- WS_UPGRADE_VALUE: value used when adding Upgrade response header; its presence/meaning can affect observable protocol behaviour for the upgrade path.\n- strlen / strcmp: standard string routines used in conditions \u2014 their semantics are needed to reason about comparisons and possible branch outcomes (e.g. method/version checks, header value comparisons).\n- free: used to release ws_ac_value; required to reason about memory side-effects and whether removal would change behaviour (leaks vs observable behaviour).\n\nTogether these symbols provide the functional semantics, return values, side-effects, allocation/deallocation and header/value constants necessary to determine whether any executed operation in ahc_cb could be removed without changing program behaviour (i.e. whether it constitutes dead code)."
}