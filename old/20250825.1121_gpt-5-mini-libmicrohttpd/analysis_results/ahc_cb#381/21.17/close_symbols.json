{
  "user_message": "Target function code is:\n```c\nstatic enum MHD_Result\nahc_cb (void *cls, struct MHD_Connection *con, const char *url,\n        const char *method, const char *version, const char *upload_data,\n        size_t *upload_data_size, void **req_cls)\n{\n  struct MHD_Response *res;\n  const char *upg_header;\n  const char *con_header;\n  const char *ws_version_header;\n  const char *ws_key_header;\n  char *ws_ac_value;\n  enum MHD_Result ret;\n  size_t key_size;\n\n  (void) cls;               /* Unused. Silent compiler warning. */\n  (void) url;               /* Unused. Silent compiler warning. */\n  (void) upload_data;       /* Unused. Silent compiler warning. */\n  (void) upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *req_cls)\n  {\n    *req_cls = (void *) 1;\n    return MHD_YES;\n  }\n  *req_cls = NULL;\n  upg_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_UPGRADE);\n  con_header = MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_CONNECTION);\n  if (MHD_NO == is_websocket_request (con, upg_header, con_header))\n  {\n    return send_chat_page (con);\n  }\n  if ((0 != strcmp (method, MHD_HTTP_METHOD_GET))\n      || (0 != strcmp (version, MHD_HTTP_VERSION_1_1)))\n  {\n    return send_bad_request (con);\n  }\n  ws_version_header =\n    MHD_lookup_connection_value (con, MHD_HEADER_KIND,\n                                 MHD_HTTP_HEADER_SEC_WEBSOCKET_VERSION);\n  if ((NULL == ws_version_header)\n      || (0 != strcmp (ws_version_header, WS_SEC_WEBSOCKET_VERSION)))\n  {\n    return send_upgrade_required (con);\n  }\n  ret = MHD_lookup_connection_value_n (con, MHD_HEADER_KIND,\n                                       MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY,\n                                       strlen (\n                                         MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY),\n                                       &ws_key_header, &key_size);\n  if ((MHD_NO == ret) || (key_size != WS_KEY_LEN))\n  {\n    return send_bad_request (con);\n  }\n  ret = ws_get_accept_value (ws_key_header, &ws_ac_value);\n  if (MHD_NO == ret)\n  {\n    return ret;\n  }\n  res = MHD_create_response_for_upgrade (&uh_cb, NULL);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_SEC_WEBSOCKET_ACCEPT,\n                               ws_ac_value))\n  {\n    free (ws_ac_value);\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  free (ws_ac_value);\n  if (MHD_YES !=\n      MHD_add_response_header (res, MHD_HTTP_HEADER_UPGRADE, WS_UPGRADE_VALUE))\n  {\n    MHD_destroy_response (res);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (con, MHD_HTTP_SWITCHING_PROTOCOLS, res);\n  MHD_destroy_response (res);\n  return ret;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'ahc_cb': {'callees': ['MHD_lookup_connection_value', 'is_websocket_request', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'MHD_lookup_connection_value_n', 'ws_get_accept_value', 'MHD_create_response_for_upgrade', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': []}, 'MHD_lookup_connection_value': {'callees': ['MHD_lookup_connection_value_n'], 'callers': ['ahc_echo', 'get_session', 'ahc_cb', 'can_compress']}, 'is_websocket_request': {'callees': [], 'callers': ['ahc_cb']}, 'send_chat_page': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': ['ahc_cb']}, 'send_bad_request': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_queue_response', 'MHD_destroy_response'], 'callers': ['ahc_cb']}, 'send_upgrade_required': {'callees': ['MHD_create_response_from_buffer_static', 'MHD_add_response_header', 'MHD_destroy_response', 'MHD_queue_response'], 'callers': ['ahc_cb']}, 'MHD_lookup_connection_value_n': {'callees': [], 'callers': ['MHD_lookup_connection_value', 'need_100_continue', 'get_no_space_err_status_code', 'parse_cookie_header', 'parse_connection_headers', 'MHD_create_post_processor', 'ahc_cb']}, 'ws_get_accept_value': {'callees': ['SHA1Reset', 'SHA1Input', 'SHA1Result', 'BASE64Encode'], 'callers': ['ahc_cb']}, 'MHD_create_response_for_upgrade': {'callees': ['MHD_add_response_header', 'MHD_destroy_response'], 'callers': ['ahc_echo', 'ahc_cb']}, 'MHD_add_response_header': {'callees': ['MHD_str_equal_caseless_', 'add_response_header_connection', 'add_response_entry', 'MHD_get_response_element_n_'], 'callers': ['MHD_create_response_for_upgrade', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'add_session_cookie', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'mark_as_html', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_upgrade_required', 'ahc_cb', 'send_page']}, 'MHD_destroy_response': {'callees': ['__builtin_unreachable'], 'callers': ['MHD_connection_close_', 'transmit_error_response_len', 'cleanup_connection', 'connection_reset', 'MHD_connection_handle_idle', 'thread_main_handle_connection', 'MHD_cleanup_connections', 'MHD_create_response_for_upgrade', 'main', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'update_cached_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_auth_required', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'init_data', 'deinit_data', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}, 'MHD_queue_response': {'callees': ['MHD_DLOG', 'is_reply_body_needed', 'MHD_increment_response_rc', 'MHD_connection_handle_idle', 'MHD_update_last_activity_'], 'callers': ['transmit_error_response_len', 'queue_auth_required_response3_inner', 'MHD_queue_basic_auth_required_response3', 'ahc_echo', 'answer_to_connection', 'serve_simple_form', 'fill_v1_form', 'fill_v1_v2_form', 'not_found_page', 'create_response', 'return_directory_response', 'generate_page', 'reply_with_page_not_found', 'reply_with_forbidden', 'reply_with_area1_pages', 'reply_with_area2_pages', 'reply_with_main_page', 'reply_with_method_not_supported', 'send_chat_page', 'send_bad_request', 'send_upgrade_required', 'ahc_cb', 'answer_shared_response', 'answer_single_response', 'answer_unique_empty_response', 'answer_unique_tiny_response', 'answer_unique_dyn_response', 'send_page']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nUse of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters. This rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "strcmp",
    "strlen",
    "MHD_lookup_connection_value_n",
    "MHD_lookup_connection_value",
    "ws_get_accept_value",
    "MHD_add_response_header",
    "MHD_HTTP_METHOD_GET",
    "MHD_HTTP_VERSION_1_1",
    "WS_SEC_WEBSOCKET_VERSION",
    "WS_KEY_LEN",
    "MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY",
    "WS_UPGRADE_VALUE",
    "semantics of callback parameters 'method' and 'version' (MHD guarantees)"
  ],
  "explanation": "Why each symbol is required for the MISRA <string.h> bounds analysis:\n\n- strcmp\n  - ahc_cb calls strcmp(method, MHD_HTTP_METHOD_GET) and strcmp(version, MHD_HTTP_VERSION_1_1). To determine whether these strcmp calls can read past the end of the referenced objects we need the exact behavior and preconditions of strcmp (it reads until a NUL).\n\n- strlen\n  - ahc_cb calls strlen(MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY) when invoking MHD_lookup_connection_value_n. Knowing strlen behavior (reads until NUL) is necessary to ensure the argument is a proper NUL-terminated string literal and this call is safe.\n\n- MHD_lookup_connection_value_n\n  - This function returns the header value pointer and key_size. We must know whether it returns a pointer to a NUL-terminated string or a non-terminated buffer and whether it writes/terminates storage; this affects subsequent uses (ws_get_accept_value expects a valid C string, and later code compares key_size to WS_KEY_LEN).\n\n- MHD_lookup_connection_value\n  - ws_version_header and other header values are obtained via this function. We must know whether it returns NUL-terminated strings for header values (so strcmp(ws_version_header, ... ) is safe).\n\n- ws_get_accept_value\n  - It consumes ws_key_header and produces ws_ac_value that is later passed to MHD_add_response_header (which will likely use string functions). We need to know whether ws_get_accept_value expects a NUL-terminated input and whether it returns a NUL-terminated ws_ac_value buffer (and its allocation/length guarantees).\n\n- MHD_add_response_header\n  - This function is given ws_ac_value and other header values; its implementation likely uses string functions (e.g., strlen/strcpy). To ensure no out-of-bounds accesses, we need its contract: does it expect NUL-terminated strings and how does it use them.\n\n- MHD_HTTP_METHOD_GET, MHD_HTTP_VERSION_1_1\n  - These are the RHS arguments to strcmp. We must confirm they are valid, NUL-terminated string constants suitable for strcmp.\n\n- WS_SEC_WEBSOCKET_VERSION\n  - Used in strcmp(ws_version_header, WS_SEC_WEBSOCKET_VERSION); need to know it is a proper NUL-terminated string literal and the expected format to judge safety of strcmp.\n\n- WS_KEY_LEN\n  - Compared against key_size returned by MHD_lookup_connection_value_n. Understanding the expected key length is required to determine whether subsequent callers (ws_get_accept_value) rely on a NUL terminator or fixed-length binary data.\n\n- MHD_HTTP_HEADER_SEC_WEBSOCKET_KEY\n  - Passed to strlen() when calling MHD_lookup_connection_value_n. Confirming this macro is a NUL-terminated string literal makes that strlen call safe and documents the header name length.\n\n- WS_UPGRADE_VALUE\n  - Passed to MHD_add_response_header. While not directly implicated in string.h use inside ahc_cb, knowing it is a proper NUL-terminated string is needed because MHD_add_response_header may call string functions on it.\n\n- semantics of callback parameters 'method' and 'version' (MHD guarantees)\n  - The pointers method and version are supplied by the MHD library to the callback; we must know the library guarantee that these pointers reference NUL-terminated strings (or otherwise bounded buffers) to conclude whether strcmp/version usage is safe.\n\nIn short, to decide compliance with the MISRA rule we need the exact contracts (null-termination and length guarantees) of all header/value-producing functions (MHD_lookup_connection_value/_n), the ws_get_accept_value producer, and the string literals/constants used with strcmp/strlen and MHD_add_response_header, plus the guarantees for the callback parameters 'method' and 'version'."
}