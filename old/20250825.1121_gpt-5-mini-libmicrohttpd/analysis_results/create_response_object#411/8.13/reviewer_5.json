{
  "user_message": "An agent A claimed that the following create_response_object code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of create_response_object.\n```c\nstatic struct MHD_Response *\ncreate_response_object (void)\n{\n#if MHD_VERSION >= 0x00097701\n  if (NULL != body_dyn)\n    return MHD_create_response_from_buffer_static (body_dyn_size,\n                                                   body_dyn);\n  else if (tool_params.empty)\n    return MHD_create_response_empty (MHD_RF_NONE);\n\n  return MHD_create_response_from_buffer_static (MHD_STATICSTR_LEN_ (tiny_body),\n                                                 tiny_body);\n\n#else  /* MHD_VERSION < 0x00097701 */\n  if (NULL != body_dyn)\n    return MHD_create_response_from_buffer (body_dyn_size,\n                                            (void *) body_dyn,\n                                            MHD_RESPMEM_PERSISTENT);\n  else if (tool_params.empty)\n    return MHD_create_response_from_buffer (0,\n                                            (void *) tiny_body,\n                                            MHD_RESPMEM_PERSISTENT);\n\n  return MHD_create_response_from_buffer (MHD_STATICSTR_LEN_ (tiny_body),\n                                          (void *) tiny_body,\n                                          MHD_RESPMEM_PERSISTENT);\n#endif /* MHD_VERSION < 0x00097701 */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer body_dyn is declared as 'static char *body_dyn = NULL' but in create_response_object it is only used as a read\u2011only buffer (passed to MHD_create_response_from_buffer_static which takes a const void * in newer API). Also tiny_body is declared 'static const char[]' and in the older API branch the code casts away const when passing it. If body_dyn is never modified after allocation (i.e. used only for read access when creating responses), it should be declared 'const char *' to meet MISRA C 2023 Rule 8.13. As written, the non-const declaration violates the rule in that scenario (if the buffer is read-only); note that if body_dyn is intentionally modified elsewhere, keeping it non-const is justified.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function create_response_object:\nstatic char *body_dyn = NULL\n...\nstatic size_t body_dyn_size\n...\nstatic const char tiny_body[] = \"Hi!\"\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Not enough evidence to conclude a definite MISRA 8.13 violation from the snippet alone. Rule 8.13 requires that a pointer should point to a const-qualified type whenever possible. If body_dyn truly is only used for read access everywhere in the program, then it ought to be declared const char * and the agent\u2019s point would be correct. However, the provided code only shows the declaration static char *body_dyn = NULL and a single read-only use site; it does not show whether body_dyn is written to elsewhere (e.g. populated, reallocated, or modified). If body_dyn is modified elsewhere, keeping it as char * is justified and there is no 8.13 violation.\n\nOne definite const-correctness issue in the snippet is the older-API branch where tiny_body (declared static const char[]) is passed via an explicit cast (void *) tiny_body to an API that expects a non-const pointer. That cast discards const and is a const\u2011qualification violation (and would typically be flagged by MISRA as undesirable). Whether that alone is reported under Rule 8.13 depends on interpretation, but it is certainly a const-correctness problem and should be fixed by using an API that accepts const or by making the object non-const if mutation/persistence semantics require it.\n\nRecommendation: audit all uses of body_dyn. If it is never written to after initialization, change its declaration to static const char *body_dyn; otherwise leave it as char *. Also remove the const-discarding cast for tiny_body by using the newer API that accepts const, or by making tiny_body non-const if it must be passed to an API requiring non-const data."
}