{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_get_rq_bauth_params_:\n```c\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_get_rq_bauth_params_:\nstruct MHD_RqBAuth\n{\n  struct _MHD_str_w_len token68;\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n...\nstruct _MHD_str_w_len\n{\n  const char *str;\n  size_t len;\n}\n...\nstatic bool\nparse_bauth_params (const char *str,\n                    size_t str_len,\n                    struct MHD_RqBAuth *pbauth)\n{\n  size_t i;\n\n  i = 0;\n\n  /* Skip all whitespaces at start */\n  while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n    i++;\n\n  if (str_len > i)\n  {\n    size_t token68_start;\n    size_t token68_len;\n\n    /* 'i' points to the first non-whitespace char after scheme token */\n    token68_start = i;\n    /* Find end of the token. Token cannot contain whitespace. */\n    while (i < str_len && ' ' != str[i] && '\\t' != str[i])\n    {\n      if (0 == str[i])\n        return false;  /* Binary zero is not allowed */\n      if ((',' == str[i]) || (';' == str[i]))\n        return false;  /* Only single token68 is allowed */\n      i++;\n    }\n    token68_len = i - token68_start;\n    mhd_assert (0 != token68_len);\n\n    /* Skip all whitespaces */\n    while (i < str_len && (' ' == str[i] || '\\t' == str[i]))\n      i++;\n    /* Check whether any garbage is present at the end of the string */\n    if (str_len != i)\n      return false;\n    else\n    {\n      /* No more data in the string, only single token68. */\n      pbauth->token68.str = str + token68_start;\n      pbauth->token68.len = token68_len;\n    }\n  }\n  return true;\n}\n...\nstatic bool\nfind_auth_rq_header_ (const struct MHD_Connection *c, enum MHD_AuthType type,\n                      struct _MHD_str_w_len *auth_value)\n{\n  const struct MHD_HTTP_Req_Header *h;\n  const char *token;\n  size_t token_len;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= c->state);\n  if (MHD_CONNECTION_HEADERS_PROCESSED > c->state)\n    return false;\n\n#ifdef DAUTH_SUPPORT\n  if (MHD_AUTHTYPE_DIGEST == type)\n  {\n    token = _MHD_AUTH_DIGEST_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_DIGEST_BASE);\n  }\n  else /* combined with the next line */\n#endif /* DAUTH_SUPPORT */\n#ifdef BAUTH_SUPPORT\n  if (MHD_AUTHTYPE_BASIC == type)\n  {\n    token = _MHD_AUTH_BASIC_BASE;\n    token_len = MHD_STATICSTR_LEN_ (_MHD_AUTH_BASIC_BASE);\n  }\n  else /* combined with the next line */\n#endif /* BAUTH_SUPPORT */\n  {\n    mhd_assert (0);\n    return false;\n  }\n\n  for (h = c->rq.headers_received; NULL != h; h = h->next)\n  {\n    if (MHD_HEADER_KIND != h->kind)\n      continue;\n    if (MHD_STATICSTR_LEN_ (MHD_HTTP_HEADER_AUTHORIZATION) != h->header_size)\n      continue;\n    if (token_len > h->value_size)\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (MHD_HTTP_HEADER_AUTHORIZATION,\n                                         h->header,\n                                         MHD_STATICSTR_LEN_ ( \\\n                                           MHD_HTTP_HEADER_AUTHORIZATION)))\n      continue;\n    if (! MHD_str_equal_caseless_bin_n_ (h->value, token, token_len))\n      continue;\n    /* Match only if token string is full header value or token is\n     * followed by space or tab\n     * Note: RFC 9110 (and RFC 7234) allows only space character, but\n     * tab is supported here as well for additional flexibility and uniformity\n     * as tabs are supported as separators between parameters.\n     */\n    if ((token_len == h->value_size) ||\n        (' ' == h->value[token_len]) || ('\\t'  == h->value[token_len]))\n    {\n      if (token_len != h->value_size)\n      { /* Skip whitespace */\n        auth_value->str = h->value + token_len + 1;\n        auth_value->len = h->value_size - (token_len + 1);\n      }\n      else\n      { /* No whitespace to skip */\n        auth_value->str = h->value + token_len;\n        auth_value->len = h->value_size - token_len;\n      }\n      return true; /* Found a match */\n    }\n  }\n  return false; /* No matching header has been found */\n}\n...\nvoid *\nMHD_connection_alloc_memory_ (struct MHD_Connection *connection,\n                              size_t size)\n{\n  struct MHD_Connection *const c = connection; /* a short alias */\n  struct MemoryPool *const pool = c->pool;     /* a short alias */\n  size_t need_to_be_freed = 0; /**< The required amount of additional free memory */\n  void *res;\n\n  res = MHD_pool_try_alloc (pool,\n                            size,\n                            &need_to_be_freed);\n  if (NULL != res)\n    return res;\n\n  if (MHD_pool_is_resizable_inplace (pool,\n                                     c->write_buffer,\n                                     c->write_buffer_size))\n  {\n    if (c->write_buffer_size - c->write_buffer_append_offset >=\n        need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->write_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->write_buffer,\n                                 c->write_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->write_buffer == buf);\n      mhd_assert (c->write_buffer_append_offset <= new_buf_size);\n      mhd_assert (c->write_buffer_send_offset <= new_buf_size);\n      c->write_buffer_size = new_buf_size;\n      c->write_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else if (MHD_pool_is_resizable_inplace (pool,\n                                          c->read_buffer,\n                                          c->read_buffer_size))\n  {\n    if (c->read_buffer_size - c->read_buffer_offset >= need_to_be_freed)\n    {\n      char *buf;\n      const size_t new_buf_size = c->read_buffer_size - need_to_be_freed;\n      buf = MHD_pool_reallocate (pool,\n                                 c->read_buffer,\n                                 c->read_buffer_size,\n                                 new_buf_size);\n      mhd_assert (c->read_buffer == buf);\n      mhd_assert (c->read_buffer_offset <= new_buf_size);\n      c->read_buffer_size = new_buf_size;\n      c->read_buffer = buf;\n    }\n    else\n      return NULL;\n  }\n  else\n    return NULL;\n  res = MHD_pool_allocate (pool, size, true);\n  mhd_assert (NULL != res); /* It has been checked that pool has enough space */\n  return res;\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nmemset (bauth, 0, sizeof(struct MHD_RqBAuth));\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: bauth is a non-const pointer to a freshly allocated, writable object and memset writes to it. Rule 8.13 would be violated if code attempted to write through a pointer declared to point to const (for example if bauth were declared as \"const struct MHD_RqBAuth *bauth\" and then passed to memset or modified), but that is not the case here."
}