{
  "user_message": "An agent A claimed that the following MHD_pool_is_resizable_inplace code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_is_resizable_inplace.\n```c\nbool\nMHD_pool_is_resizable_inplace (struct MemoryPool *pool,\n                               void *block,\n                               size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  if (NULL != block)\n  {\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (pool->size >= block_offset);\n    mhd_assert (pool->size >= block_offset + block_size);\n    return (pool->pos ==\n            ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size));\n  }\n  return false; /* Unallocated blocks cannot be resized in-place */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe expression passes pool->memory (declared as uint8_t *) and block (declared as void *) to a comparison function but neither pointer is modified \u2014 they are used only for read-only operations. According to MISRA C 2023 Rule 8.13, such pointers should be const-qualified when possible (e.g. const uint8_t *memory in the struct and const void *block in the function). Because these pointers are not const-qualified despite being usable as read-only, this is a violation of Rule 8.13. (If, however, pool->memory must be writable elsewhere, memory may legitimately be non-const; in that case only block should be changed to const and the violation would be limited to block.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_is_resizable_inplace:\nstruct MemoryPool\n{\n\n  /**\n   * Pointer to the pool's memory\n   */\n  uint8_t *memory;\n\n  /**\n   * Size of the pool.\n   */\n  size_t size;\n\n  /**\n   * Offset of the first unallocated byte.\n   */\n  size_t pos;\n\n  /**\n   * Offset of the byte after the last unallocated byte.\n   */\n  size_t end;\n\n  /**\n   * 'false' if pool was malloc'ed, 'true' if mmapped (VirtualAlloc'ed for W32).\n   */\n  bool is_mmap;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is essentially correct that Rule 8.13 is being violated in this code, but with an important nuance. In the shown function the parameter block is only used in read\u2011only operations (pointer comparisons/offset computation) and is never used to modify the pointed\u2011to object. Therefore it can and should be declared as const void *block to satisfy MISRA C 2023 Rule 8.13. That is a clear, fixable violation.\n\nBy contrast, pool->memory is a member of struct MemoryPool declared as uint8_t *memory. Whether that member must be non\u2011const depends on other uses of the pool: if the pool implementation writes into memory (very likely for a memory pool), then memory legitimately must remain a non\u2011const pointer and is not a Rule 8.13 violation. Agent A acknowledged that possibility, so their overall claim that \u201cthe code violates Rule 8.13\u201d is correct in that there is at least one violation (block), but not necessarily for pool->memory.\n\nRecommendation: change the function to take const void *block (and update called helpers to accept const pointers or provide const overloads) unless the public API semantics require a non\u2011const parameter. If the API must remain non\u2011const for compatibility, document/justify the deviation from Rule 8.13 rather than silently casting away const elsewhere."
}