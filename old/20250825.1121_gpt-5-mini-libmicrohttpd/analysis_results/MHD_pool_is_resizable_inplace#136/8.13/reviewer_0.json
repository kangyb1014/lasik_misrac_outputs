{
  "user_message": "An agent A claimed that the following MHD_pool_is_resizable_inplace code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_is_resizable_inplace.\n```c\nbool\nMHD_pool_is_resizable_inplace (struct MemoryPool *pool,\n                               void *block,\n                               size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  if (NULL != block)\n  {\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (pool->size >= block_offset);\n    mhd_assert (pool->size >= block_offset + block_size);\n    return (pool->pos ==\n            ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size));\n  }\n  return false; /* Unallocated blocks cannot be resized in-place */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameter 'block' is declared as void * but is only read (not modified) and is passed to mp_ptr_diff_. It could and should be declared as const void * (and mp_ptr_diff_ accept const pointers) so the pointer points to a const-qualified type. This is a violation of MISRA C 2023 Rule 8.13. (Note: pool->memory is uint8_t * in the struct; making that const is only appropriate if the pool ever does not write to that memory.)\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_is_resizable_inplace:\nstruct MemoryPool\n{\n\n  /**\n   * Pointer to the pool's memory\n   */\n  uint8_t *memory;\n\n  /**\n   * Size of the pool.\n   */\n  size_t size;\n\n  /**\n   * Offset of the first unallocated byte.\n   */\n  size_t pos;\n\n  /**\n   * Offset of the byte after the last unallocated byte.\n   */\n  size_t end;\n\n  /**\n   * 'false' if pool was malloc'ed, 'true' if mmapped (VirtualAlloc'ed for W32).\n   */\n  bool is_mmap;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Agent A is correct. In MHD_pool_is_resizable_inplace the parameter block is only inspected (passed to mp_ptr_diff_ and compared) and never used to modify pointee data; therefore it can (and according to MISRA C 2023 Rule 8.13 should) be declared to point to a const-qualified type (e.g. const void * or const uint8_t *). As written the function accepts void * which lacks the const qualification even though that qualification is possible. Note: changing the parameter to const void * may require updating the prototype of mp_ptr_diff_ (or adding appropriate const-qualified overloads) or adjusting casts where mp_ptr_diff_ is declared; also an explicit justification would be required if the API intentionally uses non-const void * for compatibility reasons. But absent such a justification, the current code violates Rule 8.13."
}