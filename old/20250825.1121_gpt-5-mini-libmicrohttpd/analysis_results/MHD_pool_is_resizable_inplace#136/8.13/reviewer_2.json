{
  "user_message": "An agent A claimed that the following MHD_pool_is_resizable_inplace code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_pool_is_resizable_inplace.\n```c\nbool\nMHD_pool_is_resizable_inplace (struct MemoryPool *pool,\n                               void *block,\n                               size_t block_size)\n{\n  mhd_assert (pool->end >= pool->pos);\n  mhd_assert (pool->size >= pool->end - pool->pos);\n  mhd_assert (block != NULL || block_size == 0);\n  mhd_assert (pool->size >= block_size);\n  if (NULL != block)\n  {\n    const size_t block_offset = mp_ptr_diff_ (block, pool->memory);\n    mhd_assert (mp_ptr_le_ (pool->memory, block));\n    mhd_assert (pool->size >= block_offset);\n    mhd_assert (pool->size >= block_offset + block_size);\n    return (pool->pos ==\n            ROUND_TO_ALIGN_PLUS_RED_ZONE (block_offset + block_size));\n  }\n  return false; /* Unallocated blocks cannot be resized in-place */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function parameters are not const-qualified even though they are only read. In MHD_pool_is_resizable_inplace the parameter 'void *block' is used only for address/offset calculations and not modified \u2014 it should be 'const void *block'. Likewise 'struct MemoryPool *pool' is only inspected (pool->end, pool->pos, pool->size) and not modified, so it could be 'const struct MemoryPool *pool'. As written, non-const pointer types violate MISRA C 2023 Rule 8.13.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_pool_is_resizable_inplace:\nstruct MemoryPool\n{\n\n  /**\n   * Pointer to the pool's memory\n   */\n  uint8_t *memory;\n\n  /**\n   * Size of the pool.\n   */\n  size_t size;\n\n  /**\n   * Offset of the first unallocated byte.\n   */\n  size_t pos;\n\n  /**\n   * Offset of the byte after the last unallocated byte.\n   */\n  size_t end;\n\n  /**\n   * 'false' if pool was malloc'ed, 'true' if mmapped (VirtualAlloc'ed for W32).\n   */\n  bool is_mmap;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. MISRA C 2023 R8.13 requires pointer parameters that are not used to modify the pointed-to object to be const-qualified. In MHD_pool_is_resizable_inplace neither parameter is used to modify the objects they point to: the function only inspects pool fields and uses block for address/offset calculations. Therefore both could be declared const (e.g. const struct MemoryPool *pool and const void *block). Note: making pool a pointer-to-const struct does not make the memory buffer itself const (pool->memory has type uint8_t * and remains a pointer to mutable bytes), so this change is safe with respect to the semantics of this function. Any required adjustments to helper macros/functions that take non-const pointer types do not negate the fact that the current code violates R8.13."
}