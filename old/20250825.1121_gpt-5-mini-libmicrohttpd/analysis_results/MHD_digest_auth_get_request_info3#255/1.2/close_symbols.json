{
  "user_message": "Target function code is:\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_digest_auth_get_request_info3': {'callees': ['MHD_get_rq_dauth_params_', 'get_rq_uname_type', 'get_rq_unames_size', 'get_rq_uname', 'get_rq_param_unquoted_copy_z', 'get_rq_nc'], 'callers': []}, 'MHD_get_rq_dauth_params_': {'callees': ['find_auth_rq_header_', 'MHD_connection_alloc_memory_', 'MHD_DLOG', 'parse_dauth_params'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username', 'digest_auth_check_all_inner']}, 'get_rq_uname_type': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_unames_size': {'callees': [], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_uname': {'callees': ['get_rq_param_unquoted_copy_z', 'MHD_hex_to_bin', 'get_rq_extended_uname_copy_z'], 'callers': ['MHD_digest_auth_get_request_info3', 'MHD_digest_auth_get_username3', 'MHD_digest_auth_get_username']}, 'get_rq_param_unquoted_copy_z': {'callees': ['MHD_str_unquote'], 'callers': ['get_rq_uname', 'MHD_digest_auth_get_request_info3']}, 'get_rq_nc': {'callees': ['MHD_str_unquote', 'MHD_strx_to_uint64_n_'], 'callers': ['MHD_digest_auth_get_request_info3']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "_MHD_EXTERN",
    "struct MHD_DigestAuthInfo",
    "struct MHD_RqDAuth",
    "struct MHD_DigestAuthUsernameInfo",
    "MHD_calloc_",
    "mhd_assert",
    "MHD_DIGEST_AUTH_UNAME_TYPE_MISSING",
    "MHD_DIGEST_AUTH_UNAME_TYPE_INVALID",
    "MHD_DIGEST_AUTH_INVALID_NC_VALUE"
  ],
  "explanation": "Explain why each symbol is needed to check for compiler language extensions (MISRA rule):\n\n- _MHD_EXTERN: This macro appears in the function declaration. It often expands to storage-class/visibility attributes (e.g. __attribute__((visibility(...))), __declspec(dllexport), extern \"C\", __extension__ etc.). You must inspect its definition to determine whether it injects any non\u2011standard compiler extension.\n\n- struct MHD_DigestAuthInfo: The function allocates and indexes past this struct (info + 1) and casts it to reach trailing buffer bytes. The struct definition may use non\u2011standard constructs (zero\u2011length arrays, anonymous/unions, GCC attributes, alignment directives, or other extensions) that would make the function rely on a language extension.\n\n- struct MHD_RqDAuth: The code accesses nested fields like params->opaque.value.str and params->realm.value.len; the struct/union definition may contain anonymous structs/unions, bitfields with non\u2011standard types, or other compiler extensions that affect member access semantics. Inspecting this definition is necessary to spot any extensions used by the function.\n\n- struct MHD_DigestAuthUsernameInfo: The code casts info to this type when calling get_rq_uname. The layout of this type (including any flexible/zero\u2011length arrays, anonymous members, or attributes) influences whether the cast and subsequent memory usage rely on extensions.\n\n- MHD_calloc_: This allocation helper may be a macro that expands to builtin functions or uses compiler extensions (e.g. __builtin_calloc, __attribute__((malloc)), custom allocation with inline assembly). Its definition must be checked for extensions that affect this function.\n\n- mhd_assert: This macro is used in the function. Assertion macros often expand to compiler builtins, __attribute__ uses, or do/while(0) constructs that might use extensions. Check its definition for any non\u2011standard constructs.\n\n- MHD_DIGEST_AUTH_UNAME_TYPE_MISSING and MHD_DIGEST_AUTH_UNAME_TYPE_INVALID: These constants may be macros or enum values. Inspecting their definitions is needed because macros can expand to expressions using extensions (e.g. __extension__, __typeof__, GCC statement expressions). If they are enums, the enum declaration may carry attributes.\n\n- MHD_DIGEST_AUTH_INVALID_NC_VALUE: Same rationale as above \u2014 verify this constant's definition/decl to ensure it does not rely on compiler extensions.\n\nNote: Other called functions (get_rq_uname, get_rq_param_unquoted_copy_z, get_rq_uname_type, get_rq_unames_size, get_rq_nc) should be inspected only if their declarations/macros are used directly in this translation unit (e.g. as macros or inline functions) because language extensions embedded inside called functions' bodies do not by themselves make this function use an extension unless the extension is present in a macro/inline used here. The list above contains the minimal symbols that can introduce compile\u2011time language extensions into the target function's translation unit."
}