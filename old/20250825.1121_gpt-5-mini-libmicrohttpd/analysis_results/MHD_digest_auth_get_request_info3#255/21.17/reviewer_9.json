{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe call passes info->opaque (a pointer into the single allocated unif_buf) to get_rq_param_unquoted_copy_z without providing the remaining buffer size. Earlier the total buffer size was computed from params->opaque.value.len + 1, but unif_buf_used may already be non\u2011zero (e.g. get_rq_uname wrote into the buffer). If get_rq_param_unquoted_copy_z internally uses string.h functions (memcpy/strcpy/etc.) and copies params->opaque.value.len+1 bytes (or more) without being informed of the remaining space (unif_buf_size - unif_buf_used), it can write past the end of the allocated region. Therefore this fragment can lead to out\u2011of\u2011bounds accesses of objects referenced by pointer parameters and violates MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not correct as a definite violation of MISRA C:2023 Rule 21.17 in this function. The function allocates a single contiguous buffer whose size (unif_buf_size) includes the space required for the username area (get_rq_unames_size) and the opaque and realm fields (params->*.value.len + 1 each). When the username is written, get_rq_uname is explicitly passed the remaining buffer space (unif_buf_size - unif_buf_used), so it cannot legally write past the space that was reserved for the remaining fields. Before writing opaque/realm the code sets info->opaque/info->realm to unif_buf_ptr + unif_buf_used, and the computed allocation guaranteed space for params->opaque.value.len + 1 and params->realm.value.len + 1 respectively. The mhd_assert at the end also checks the invariant that the total reserved size is not smaller than what was used. Therefore, assuming the helper functions honour their documented contracts (get_rq_uname writes no more than the size it was given, get_rq_param_unquoted_copy_z writes no more than the parsed params->*.value.len + 1 that was accounted for), there is no out\u2011of\u2011bounds string operation introduced by this function itself.\n\nIf get_rq_param_unquoted_copy_z or get_rq_uname were implemented incorrectly and themselves use string.h functions without respecting destination bounds, that would be a violation located in those helper functions, not in MHD_digest_auth_get_request_info3. To make the caller more robust the code could pass an explicit remaining-size parameter to get_rq_param_unquoted_copy_z (or otherwise document and enforce its contract), but the absence of that size parameter alone does not prove a MISRA 21.17 violation in this function."
}