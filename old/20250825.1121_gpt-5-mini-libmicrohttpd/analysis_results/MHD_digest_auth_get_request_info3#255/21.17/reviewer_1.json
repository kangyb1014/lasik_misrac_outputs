{
  "user_message": "An agent A claimed that the following MHD_digest_auth_get_request_info3 code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of MHD_digest_auth_get_request_info3.\n```c\n_MHD_EXTERN struct MHD_DigestAuthInfo *\nMHD_digest_auth_get_request_info3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqDAuth *params;\n  struct MHD_DigestAuthInfo *info;\n  enum MHD_DigestAuthUsernameType uname_type;\n  size_t unif_buf_size;\n  uint8_t *unif_buf_ptr;\n  size_t unif_buf_used;\n  enum MHD_GetRqNCResult nc_res;\n\n  params = MHD_get_rq_dauth_params_ (connection);\n  if (NULL == params)\n    return NULL;\n\n  unif_buf_size = 0;\n\n  uname_type = get_rq_uname_type (params);\n\n  unif_buf_size += get_rq_unames_size (params, uname_type);\n\n  if (NULL != params->opaque.value.str)\n    unif_buf_size += params->opaque.value.len + 1;  /* Add one for zero-termination */\n  if (NULL != params->realm.value.str)\n    unif_buf_size += params->realm.value.len + 1;   /* Add one for zero-termination */\n  info = (struct MHD_DigestAuthInfo *)\n         MHD_calloc_ (1, (sizeof(struct MHD_DigestAuthInfo)) + unif_buf_size);\n  unif_buf_ptr = (uint8_t *) (info + 1);\n  unif_buf_used = 0;\n\n  info->algo3 = params->algo3;\n\n  if ( (MHD_DIGEST_AUTH_UNAME_TYPE_MISSING != uname_type) &&\n       (MHD_DIGEST_AUTH_UNAME_TYPE_INVALID != uname_type) )\n    unif_buf_used +=\n      get_rq_uname (params, uname_type,\n                    (struct MHD_DigestAuthUsernameInfo *) info,\n                    unif_buf_ptr + unif_buf_used,\n                    unif_buf_size - unif_buf_used);\n  else\n    info->uname_type = uname_type;\n\n  if (NULL != params->opaque.value.str)\n  {\n    info->opaque = (char *) (unif_buf_ptr + unif_buf_used);\n    info->opaque_len = get_rq_param_unquoted_copy_z (&params->opaque,\n                                                     info->opaque);\n    unif_buf_used += info->opaque_len + 1;\n  }\n  if (NULL != params->realm.value.str)\n  {\n    info->realm = (char *) (unif_buf_ptr + unif_buf_used);\n    info->realm_len = get_rq_param_unquoted_copy_z (&params->realm,\n                                                    info->realm);\n    unif_buf_used += info->realm_len + 1;\n  }\n\n  mhd_assert (unif_buf_size >= unif_buf_used);\n\n  info->qop = params->qop;\n\n  if (NULL != params->cnonce.value.str)\n    info->cnonce_len = params->cnonce.value.len;\n  else\n    info->cnonce_len = 0;\n\n  nc_res = get_rq_nc (params, &info->nc);\n  if (MHD_GET_RQ_NC_VALID != nc_res)\n    info->nc = MHD_DIGEST_AUTH_INVALID_NC_VALUE;\n\n  return info;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nA violation can occur if the supplied buffer length is insufficient or not respected. unif_buf_size is computed from get_rq_unames_size(...) plus optional opaque/realm lengths and then passed as the available size (unif_buf_size - unif_buf_used) to get_rq_uname. If get_rq_unames_size under\u2011estimates the actual bytes written, if an integer overflow occurs while computing unif_buf_size, or if get_rq_uname ignores the provided length and uses an unbounded string routine (e.g. strcpy/memcpy) to copy the username, the call may write past the allocated buffer and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not definitively correct. The reviewed function itself does not call any of the <string.h> routines: it computes a buffer size, allocates memory and passes pointers and an explicit remaining length to helper routines (get_rq_uname, get_rq_param_unquoted_copy_z). MISRA C 2023 Rule 21.17 targets use of the standard string functions that can access beyond object bounds. Whether a Rule 21.17 violation actually occurs depends on the implementations of the called helpers and on overflow checks: if get_rq_uname or get_rq_param_unquoted_copy_z ignore the supplied length or internally call unsafe string.h functions that read/write out of bounds, those helpers would be the locus of the Rule 21.17 violation, not this wrapper per se. That said, this function does have risk factors that can enable out\u2011of\u2011bounds accesses: the incremental accumulation of unif_buf_size is not checked for integer overflow and there is only an assert (mhd_assert) that unif_buf_size >= unif_buf_used at the end. If an integer overflow occurred when computing unif_buf_size (or if get_rq_unames_size under\u2011estimates required bytes), the allocation could be too small and subsequent helper writes could overflow the buffer. In summary: Agent A\u2019s scenario is plausible, but from this function alone you cannot conclude a definite Rule 21.17 violation \u2014 the real violation would be in the helpers or due to lack of overflow checks here. Recommend adding explicit overflow checks when computing unif_buf_size and validating helper return values/consuming lengths to ensure bounds cannot be exceeded."
}