{
  "user_message": "Target function code is:\n```c\nstatic bool\ncheck_and_grow_read_buffer_space (struct MHD_Connection *c)\n{\n  /**\n   * The increase of read buffer size is desirable.\n   */\n  bool rbuff_grow_desired;\n  /**\n   * The increase of read buffer size is a hard requirement.\n   */\n  bool rbuff_grow_required;\n\n  mhd_assert (0 != (MHD_EVENT_LOOP_INFO_READ & c->event_loop_info));\n  mhd_assert (! c->discard_request);\n\n  rbuff_grow_required = (c->read_buffer_offset == c->read_buffer_size);\n  if (rbuff_grow_required)\n    rbuff_grow_desired = true;\n  else\n  {\n    rbuff_grow_desired = (c->read_buffer_offset + c->daemon->pool_increment >\n                          c->read_buffer_size);\n\n    if ((rbuff_grow_desired) &&\n        (MHD_CONNECTION_BODY_RECEIVING == c->state))\n    {\n      if (! c->rq.have_chunked_upload)\n      {\n        mhd_assert (MHD_SIZE_UNKNOWN != c->rq.remaining_upload_size);\n        /* Do not grow read buffer more than necessary to process the current\n           request. */\n        rbuff_grow_desired =\n          (c->rq.remaining_upload_size > c->read_buffer_size);\n      }\n      else\n      {\n        mhd_assert (MHD_SIZE_UNKNOWN == c->rq.remaining_upload_size);\n        if (0 == c->rq.current_chunk_size)\n          rbuff_grow_desired =  /* Reading value of the next chunk size */\n                               (MHD_CHUNK_HEADER_REASONABLE_LEN >\n                                c->read_buffer_size);\n        else\n        {\n          const uint64_t cur_chunk_left =\n            c->rq.current_chunk_size - c->rq.current_chunk_offset;\n          /* Do not grow read buffer more than necessary to process the current\n             chunk with terminating CRLF. */\n          mhd_assert (c->rq.current_chunk_offset <= c->rq.current_chunk_size);\n          rbuff_grow_desired =\n            ((cur_chunk_left + 2) > (uint64_t) (c->read_buffer_size));\n        }\n      }\n    }\n  }\n\n  if (! rbuff_grow_desired)\n    return true; /* No need to increase the buffer */\n\n  if (try_grow_read_buffer (c, rbuff_grow_required))\n    return true; /* Buffer increase succeed */\n\n  if (! rbuff_grow_required)\n    return true; /* Can continue without buffer increase */\n\n  /* Failed to increase the read buffer size, but need to read the data\n     from the network.\n     No more space left in the buffer, no more space to increase the buffer. */\n\n  /* 'PROCESS_READ' event state flag must be set only if the last application\n     callback has processed some data. If any data is processed then some\n     space in the read buffer must be available. */\n  mhd_assert (0 == (MHD_EVENT_LOOP_INFO_PROCESS & c->event_loop_info));\n\n  if ((! MHD_D_IS_USING_THREADS_ (c->daemon))\n      && (MHD_CONNECTION_BODY_RECEIVING == c->state)\n      && has_unprocessed_upload_body_data_in_buffer (c))\n  {\n    /* The application is handling processing cycles.\n       The data could be processed later. */\n    c->event_loop_info = MHD_EVENT_LOOP_INFO_PROCESS;\n    return true;\n  }\n  else\n  {\n    enum MHD_ProcRecvDataStage stage;\n\n    switch (c->state)\n    {\n    case MHD_CONNECTION_INIT:\n      stage = MHD_PROC_RECV_INIT;\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVING:\n      if (MHD_HTTP_MTHD_NO_METHOD == c->rq.http_mthd)\n        stage = MHD_PROC_RECV_METHOD;\n      else if (0 == c->rq.req_target_len)\n        stage = MHD_PROC_RECV_URI;\n      else\n        stage = MHD_PROC_RECV_HTTPVER;\n      break;\n    case MHD_CONNECTION_REQ_HEADERS_RECEIVING:\n      stage = MHD_PROC_RECV_HEADERS;\n      break;\n    case MHD_CONNECTION_BODY_RECEIVING:\n      stage = c->rq.have_chunked_upload ?\n              MHD_PROC_RECV_BODY_CHUNKED : MHD_PROC_RECV_BODY_NORMAL;\n      break;\n    case MHD_CONNECTION_FOOTERS_RECEIVING:\n      stage = MHD_PROC_RECV_FOOTERS;\n      break;\n    case MHD_CONNECTION_REQ_LINE_RECEIVED:\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n    case MHD_CONNECTION_CONTINUE_SENDING:\n    case MHD_CONNECTION_BODY_RECEIVED:\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n    case MHD_CONNECTION_FULL_REQ_RECEIVED:\n    case MHD_CONNECTION_START_REPLY:\n    case MHD_CONNECTION_HEADERS_SENDING:\n    case MHD_CONNECTION_HEADERS_SENT:\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n    case MHD_CONNECTION_CHUNKED_BODY_SENT:\n    case MHD_CONNECTION_FOOTERS_SENDING:\n    case MHD_CONNECTION_FULL_REPLY_SENT:\n    case MHD_CONNECTION_CLOSED:\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n#endif\n    default:\n      stage = MHD_PROC_RECV_BODY_NORMAL;\n      mhd_assert (0);\n    }\n\n    handle_recv_no_space (c, stage);\n  }\n  return false;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'check_and_grow_read_buffer_space': {'callees': ['try_grow_read_buffer', 'has_unprocessed_upload_body_data_in_buffer', 'handle_recv_no_space'], 'callers': ['MHD_connection_update_event_loop_info']}, 'try_grow_read_buffer': {'callees': ['MHD_pool_get_free', 'MHD_pool_reallocate'], 'callers': ['check_and_grow_read_buffer_space']}, 'has_unprocessed_upload_body_data_in_buffer': {'callees': [], 'callers': ['handle_recv_no_space', 'check_and_grow_read_buffer_space', 'MHD_connection_update_event_loop_info']}, 'handle_recv_no_space': {'callees': ['connection_close_error', 'transmit_error_response_len', 'handle_req_headers_no_space', 'has_unprocessed_upload_body_data_in_buffer', 'handle_req_chunk_size_line_no_space', 'handle_req_footers_no_space'], 'callers': ['check_and_grow_read_buffer_space']}, 'MHD_connection_update_event_loop_info': {'callees': ['has_unprocessed_upload_body_data_in_buffer', 'check_and_grow_read_buffer_space'], 'callers': ['MHD_connection_handle_idle']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_Connection (full definition)",
    "c->rq sub-structure definition and field types (have_chunked_upload, remaining_upload_size, current_chunk_size, current_chunk_offset, http_mthd, req_target_len)",
    "c->daemon (daemon structure) definition and field types (pool_increment, any other fields used by macros)",
    "enum / macros for MHD_CONNECTION_* (all connection state constants) and enum MHD_ProcRecvDataStage (definition)",
    "Macro: mhd_assert (definition/expansion)",
    "Macro: MHD_D_IS_USING_THREADS_ (definition/expansion)",
    "Macro/constants: MHD_EVENT_LOOP_INFO_READ, MHD_EVENT_LOOP_INFO_PROCESS (definitions)",
    "Macro/constants: MHD_SIZE_UNKNOWN, MHD_CHUNK_HEADER_REASONABLE_LEN, MHD_HTTP_MTHD_NO_METHOD (definitions)",
    "Preprocessor symbol: UPGRADE_SUPPORT (whether defined)",
    "Prototype/definition of try_grow_read_buffer (declaration and body if available)",
    "Prototype/definition of has_unprocessed_upload_body_data_in_buffer",
    "Prototype/definition of handle_recv_no_space"
  ],
  "explanation": "To determine whether the target function uses any compiler language extensions you must be able to inspect any macros, types, constants and called-function declarations that affect the code the compiler actually sees. For each listed symbol: \n\n- struct MHD_Connection (full definition): the function accesses many fields (read_buffer_offset, read_buffer_size, state, event_loop_info, discard_request, etc.). The struct definition may contain compiler extensions (e.g. attributes, bit\u2011fields, anonymous/unnamed fields, packed/aligned attributes) that would make the function use an extension. \n\n- c->rq sub-structure definition and field types: code branches and arithmetic depend on these fields; their declarations may use extensions (e.g. 64\u2011bit types, bitfields, attributes, nonstandard storage class). You must inspect their declarations to detect such extensions. \n\n- c->daemon (daemon structure) definition and pool_increment type: the MHD_D_IS_USING_THREADS_ macro likely inspects daemon or its type; pool_increment's type affects integer arithmetic and casts. The daemon struct or its fields could carry compiler-specific attributes. \n\n- enum / macros for MHD_CONNECTION_* and enum MHD_ProcRecvDataStage: switch/case relies on these enumerators; enum definitions could use compiler extensions or nonstandard underlying types. Inspecting the enum ensures no use of extension syntax. \n\n- mhd_assert (definition/expansion): used twice; assertions are macros and may expand to compiler builtin intrinsics, asm, typeof, or attributes. The macro expansion must be checked for extension usage. \n\n- MHD_D_IS_USING_THREADS_ (definition/expansion): used as a function\u2011like macro; its expansion might use thread\u2011checking builtins, typeof, or other extensions. \n\n- MHD_EVENT_LOOP_INFO_READ and MHD_EVENT_LOOP_INFO_PROCESS (definitions): these bitmask macros might be defined using compiler extensions (e.g. bit\u2011field constants, expressions using sizeof on VLA, or GCC extension constants). \n\n- MHD_SIZE_UNKNOWN, MHD_CHUNK_HEADER_REASONABLE_LEN, MHD_HTTP_MTHD_NO_METHOD (definitions): these constants/macros influence branches; their definitions could use extension constructs (e.g. ULL suffixes, unusual macros, or attributes). \n\n- UPGRADE_SUPPORT (preprocessor symbol): the code contains an #ifdef UPGRADE_SUPPORT case label; whether this symbol is defined changes compilation and could enable code with extensions. You must know if it is defined in the build. \n\n- Prototypes/definitions of try_grow_read_buffer, has_unprocessed_upload_body_data_in_buffer, handle_recv_no_space: function declarations/bodies could use compiler-specific function attributes (e.g. GNU attributes, asm labels, calling\u2011convention attributes) that affect whether the call site is using language extensions. Also the called bodies may inline or expand macros that are extensions which could affect the relocation/semantics seen by the compiler. \n\nIn short, macros and type/enum definitions used by the target function are the primary places where compiler extensions typically appear. Inspecting these symbols lets you decide whether the target function, as written and as expanded, relies on any language extensions."
}