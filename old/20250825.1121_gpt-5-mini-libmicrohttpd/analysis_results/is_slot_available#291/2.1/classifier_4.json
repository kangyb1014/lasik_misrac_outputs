{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 2.1 is: A project shall not contain unreachable code.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of is_slot_available:\n```c\nstatic bool\nis_slot_available (const struct MHD_NonceNc *const nn,\n                   const uint64_t now,\n                   const char *const new_nonce,\n                   size_t new_nonce_len)\n{\n  uint64_t timestamp;\n  bool timestamp_valid;\n  mhd_assert (new_nonce_len <= NONCE_STD_LEN (MAX_DIGEST));\n  mhd_assert (NONCE_STD_LEN (MAX_DIGEST) <= MAX_DIGEST_NONCE_LENGTH);\n  if (0 == nn->nonce[0])\n    return true; /* The slot is empty */\n\n  if (0 == memcmp (nn->nonce, new_nonce, new_nonce_len))\n  {\n    /* The slot has the same nonce already. This nonce cannot be registered\n     * again as it would just clear 'nc' usage history. */\n    return false;\n  }\n\n  if (0 != nn->nc)\n    return true; /* Client already used the nonce in this slot at least\n                    one time, re-use the slot */\n\n  /* The nonce must be zero-terminated */\n  mhd_assert (0 == nn->nonce[sizeof(nn->nonce) - 1]);\n  if (0 != nn->nonce[sizeof(nn->nonce) - 1])\n    return true; /* Wrong nonce format in the slot */\n\n  timestamp_valid = get_nonce_timestamp (nn->nonce, 0, &timestamp);\n  mhd_assert (timestamp_valid);\n  if (! timestamp_valid)\n    return true; /* Invalid timestamp in nonce-nc, should not be possible */\n\n  if ((REUSE_TIMEOUT * 1000) < TRIM_TO_TIMESTAMP (now - timestamp))\n    return true;\n\n  return false;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function is_slot_available:\nstruct MHD_NonceNc\n{\n\n  /**\n   * Nonce counter, a value that increases for each subsequent\n   * request for the same nonce. Matches the largest last received\n   * 'nc' value.\n   * This 'nc' value was already used by the client.\n   */\n  uint32_t nc;\n\n  /**\n   * Bitmask over the previous 64 nonce counter values (down to to nc-64).\n   * Used to allow out-of-order 'nc'.\n   * If bit in the bitmask is set to one, then this 'nc' value was already used\n   * by the client.\n   */\n  uint64_t nmask;\n\n  /**\n   * Nonce value\n   */\n  char nonce[MAX_DIGEST_NONCE_LENGTH + 1];\n\n}\n...\n#define NONCE_STD_LEN(digest_size) ((digest_size)*2+TIMESTAMP_CHARS_LEN)\n...\n#define MAX_DIGEST SHA512_256_DIGEST_SIZE\n...\n#define MAX_DIGEST_NONCE_LENGTH ((32+6)*2)\n...\n#define mhd_assert(ignore) ((void)0)\n...\nstatic bool\nget_nonce_timestamp (const char *const nonce,\n                     size_t noncelen,\n                     uint64_t *const ptimestamp)\n{\n  if (0 == noncelen)\n    noncelen = strlen (nonce);\n\n  if (true\n#ifdef MHD_MD5_SUPPORT\n      && (NONCE_STD_LEN (MD5_DIGEST_SIZE) != noncelen)\n#endif /* MHD_MD5_SUPPORT */\n#if defined(MHD_SHA256_SUPPORT) || defined(MHD_SHA512_256_SUPPORT)\n      && (NONCE_STD_LEN (SHA256_SHA512_256_DIGEST_SIZE) != noncelen)\n#endif /* MHD_SHA256_SUPPORT */\n      )\n    return false;\n\n  if (TIMESTAMP_CHARS_LEN !=\n      MHD_strx_to_uint64_n_ (nonce + noncelen - TIMESTAMP_CHARS_LEN,\n                             TIMESTAMP_CHARS_LEN,\n                             ptimestamp))\n    return false;\n  return true;\n}\n...\n#define TRIM_TO_TIMESTAMP(value) ((value)&((UINT64_C(1)<<(TIMESTAMP_BIN_SIZE*8))-1))\n...\n#define REUSE_TIMEOUT 30\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\ntimestamp_valid = get_nonce_timestamp (nn->nonce, 0, &timestamp);\n  mhd_assert (timestamp_valid);\n  if (! timestamp_valid)\n    return true; /* Invalid timestamp in nonce-nc, should not be possible */\n```\nFocus on the above code fragment and judge whether it violates the rule 2.1 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "The branch is reachable: get_nonce_timestamp can return false (e.g. if the build has no MD5/SHA256/SHA512_256 support then the function unconditionally returns false, or if the nonce has an invalid timestamp so MHD_strx_to_uint64_n_ fails). mhd_assert is a no-op, so there is no compile-time removal of the check. In these cases timestamp_valid is false and the if (! timestamp_valid) return true; is executed."
}