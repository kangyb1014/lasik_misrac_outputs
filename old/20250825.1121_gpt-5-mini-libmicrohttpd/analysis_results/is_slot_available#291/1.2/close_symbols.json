{
  "user_message": "Target function code is:\n```c\nstatic bool\nis_slot_available (const struct MHD_NonceNc *const nn,\n                   const uint64_t now,\n                   const char *const new_nonce,\n                   size_t new_nonce_len)\n{\n  uint64_t timestamp;\n  bool timestamp_valid;\n  mhd_assert (new_nonce_len <= NONCE_STD_LEN (MAX_DIGEST));\n  mhd_assert (NONCE_STD_LEN (MAX_DIGEST) <= MAX_DIGEST_NONCE_LENGTH);\n  if (0 == nn->nonce[0])\n    return true; /* The slot is empty */\n\n  if (0 == memcmp (nn->nonce, new_nonce, new_nonce_len))\n  {\n    /* The slot has the same nonce already. This nonce cannot be registered\n     * again as it would just clear 'nc' usage history. */\n    return false;\n  }\n\n  if (0 != nn->nc)\n    return true; /* Client already used the nonce in this slot at least\n                    one time, re-use the slot */\n\n  /* The nonce must be zero-terminated */\n  mhd_assert (0 == nn->nonce[sizeof(nn->nonce) - 1]);\n  if (0 != nn->nonce[sizeof(nn->nonce) - 1])\n    return true; /* Wrong nonce format in the slot */\n\n  timestamp_valid = get_nonce_timestamp (nn->nonce, 0, &timestamp);\n  mhd_assert (timestamp_valid);\n  if (! timestamp_valid)\n    return true; /* Invalid timestamp in nonce-nc, should not be possible */\n\n  if ((REUSE_TIMEOUT * 1000) < TRIM_TO_TIMESTAMP (now - timestamp))\n    return true;\n\n  return false;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'is_slot_available': {'callees': ['get_nonce_timestamp'], 'callers': ['calculate_add_nonce']}, 'get_nonce_timestamp': {'callees': ['MHD_strx_to_uint64_n_'], 'callers': ['check_nonce_nc', 'is_slot_available', 'digest_auth_check_all_inner']}, 'calculate_add_nonce': {'callees': ['MHD_get_master', 'digest_get_size', 'calculate_nonce', 'get_nonce_nc_idx', '__builtin_unreachable', 'is_slot_available'], 'callers': ['calculate_add_nonce_with_retry']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_NonceNc",
    "mhd_assert",
    "NONCE_STD_LEN",
    "MAX_DIGEST",
    "MAX_DIGEST_NONCE_LENGTH",
    "get_nonce_timestamp",
    "MHD_strx_to_uint64_n_",
    "TRIM_TO_TIMESTAMP",
    "REUSE_TIMEOUT",
    "memcmp"
  ],
  "explanation": "For determining whether is_slot_available uses any compiler language extensions, the following symbols must be inspected because they can introduce extensions into the apparent source of the target function:\n\n- struct MHD_NonceNc: The function accesses nn->nonce and nn->nc and uses sizeof(nn->nonce). You must see the struct definition (types, array sizes, any packed/attribute annotations or non-standard extensions) to ensure these members are ordinary standard-C declarations and not compiler-specific extensions.\n\n- mhd_assert: This macro/function is invoked multiple times. Its definition may expand to compiler-specific constructs (e.g. GCC attributes, __builtin_* functions, statement expressions, asm, or other extensions). Inspecting its definition is required to verify no language extensions are introduced via the assert macro.\n\n- NONCE_STD_LEN: This macro is used in compile-time assertions and comparisons. Macros can hide extension usage (complex expressions, typeof, statement expressions). Check its definition to ensure it is a standard-compliant macro.\n\n- MAX_DIGEST: Used as an argument to NONCE_STD_LEN; its definition may be a macro or enum or typedef that could include extensions. Inspect to ensure no extension is used.\n\n- MAX_DIGEST_NONCE_LENGTH: Used in an assertion comparing against NONCE_STD_LEN. Its definition must be checked for non-standard constructs.\n\n- get_nonce_timestamp: The target calls this function; it may be a macro or inline function that uses compiler extensions (attributes, builtins). You must inspect its declaration/definition to ensure the call and its internals do not introduce language extensions into the target's behavior.\n\n- MHD_strx_to_uint64_n_: Because get_nonce_timestamp (per the call graph) calls this symbol, inspect it as well: it could be a macro or inline that uses compiler-specific builtins or extensions which would mean the target function effectively uses those extensions.\n\n- TRIM_TO_TIMESTAMP: This macro is used in an arithmetic comparison. Macros can hide extension usage (statement expressions, typeof, __builtin_*). Inspect its definition to ensure it is standard-C only.\n\n- REUSE_TIMEOUT: A macro/constant used in the time comparison; its definition should be checked for any extension usage (e.g. computed via non-standard constructs).\n\n- memcmp: Although a standard library function, projects sometimes #define or inline-wrap standard names with macros or non-standard implementations. Confirm memcmp is the standard declaration (or a plain function) and not a project macro that uses language extensions.\n\nInspecting these symbols (their headers/definitions) lets you determine whether any compiler-specific language extensions are introduced into the body of is_slot_available via macros, inline functions, attributes, builtins, statement expressions, or other non-standard constructs."
}