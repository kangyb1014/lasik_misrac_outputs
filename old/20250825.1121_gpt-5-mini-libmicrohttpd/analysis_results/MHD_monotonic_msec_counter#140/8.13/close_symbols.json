{
  "user_message": "Target function code is:\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'connection_check_timedout': {'callees': ['MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_set_connection_option': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': []}, 'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA pointer should point to a const-qualified type whenever possible. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "clock_gettime",
    "clock_get_time",
    "timespec_get",
    "gettimeofday",
    "QueryPerformanceCounter",
    "GetTickCount64",
    "gethrtime",
    "time",
    "struct timespec",
    "mach_timespec_t",
    "struct timeval",
    "LARGE_INTEGER",
    "clockid_t",
    "mono_clock_id",
    "_MHD_UNWANTED_CLOCK",
    "mono_clock_start",
    "mono_clock_service",
    "_MHD_INVALID_CLOCK_SERV",
    "tick_start",
    "perf_freq",
    "perf_start",
    "hrtime_start",
    "gettime_start",
    "sys_clock_start"
  ],
  "explanation": "To decide whether this function violates the MISRA rule that pointers should point to const-qualified types whenever possible, the analyzer needs the declarations/prototypes and relevant globals/types listed: \n\n- clock_gettime: check its prototype (parameter types/qualifiers) because &ts (struct timespec *) is passed \u2014 need to confirm whether the function requires a non-const pointer (i.e. it writes into it) so non-const is justified.\n- clock_get_time: same reason \u2014 the function is called with &cur_time; prototype/parameter qualifiers must be inspected.\n- timespec_get: called with &ts; need prototype to see if parameter could/should be const.\n- gettimeofday: called with &tv; prototype shows it writes to the timeval \u2014 confirm that non-const pointer is required.\n- QueryPerformanceCounter: called with &perf_counter; need prototype to verify parameter qualifier.\n- GetTickCount64: included to confirm it has no pointer parameters (helps rule not applicable here).\n- gethrtime: prototype (no pointer) to confirm no pointer-related issues.\n- time: prototype (time_t * or NULL) to confirm pointer usage on last-resort call.\n\n- struct timespec, mach_timespec_t, struct timeval, LARGE_INTEGER: type definitions are required to check whether any fields are pointer types (which might introduce pointer-to-non-const usage) and to understand what addresses are passed.\n\n- clockid_t: type of mono_clock_id needed to inspect whether mono_clock_id is a pointer type or scalar (if pointer, MISRA const qualification may apply).\n\n- mono_clock_id, _MHD_UNWANTED_CLOCK: to know mono_clock_id's type and how it is compared; if mono_clock_id were a pointer, const qualification would matter.\n- mono_clock_start, mono_clock_service, _MHD_INVALID_CLOCK_SERV: to know whether mono_clock_service is a pointer (and thus whether const qualification of that pointer/value is relevant) and whether mono_clock_start is a pointer or scalar.\n- tick_start, perf_freq, perf_start, hrtime_start, gettime_start, sys_clock_start: these globals are subtracted from returned timer values; their types (and whether any are pointers) must be known to determine any pointer-to-non-const usage.\n\nIn short, the primary focus is the prototypes of the time-related functions and the definitions of the time-structure types and the global variables used. Those symbols let an analyzer confirm whether any pointer passed in this function could/should be const-qualified (or whether non-const pointers are required because the functions write into the provided storage)."
}