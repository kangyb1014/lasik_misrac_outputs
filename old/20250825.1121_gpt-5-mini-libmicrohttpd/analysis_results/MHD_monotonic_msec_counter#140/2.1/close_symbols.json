{
  "user_message": "Target function code is:\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'connection_check_timedout': {'callees': ['MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_set_connection_option': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': []}, 'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain unreachable code. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GETTIME",
    "HAVE_TIMESPEC_GET",
    "HAVE_CLOCK_GET_TIME",
    "_MHD_UNWANTED_CLOCK",
    "mono_clock_id",
    "clock_gettime",
    "mono_clock_start",
    "_MHD_INVALID_CLOCK_SERV",
    "mono_clock_service",
    "clock_get_time",
    "KERN_SUCCESS",
    "_WIN32",
    "_WIN32_WINNT",
    "GetTickCount64",
    "tick_start",
    "perf_freq",
    "QueryPerformanceCounter",
    "perf_start",
    "HAVE_GETHRTIME",
    "gethrtime",
    "hrtime_start",
    "timespec_get",
    "TIME_UTC",
    "gettime_start",
    "HAVE_GETTIMEOFDAY",
    "gettimeofday",
    "time",
    "sys_clock_start"
  ],
  "explanation": "For determining whether any code in MHD_monotonic_msec_counter is unreachable you must know which blocks are compiled in and which runtime branches can ever be true. The listed symbols are required for that analysis: \n\n- HAVE_CLOCK_GETTIME, HAVE_TIMESPEC_GET, HAVE_CLOCK_GET_TIME, _WIN32, _WIN32_WINNT, HAVE_GETHRTIME, HAVE_GETTIMEOFDAY: these preprocessor feature macros control which code blocks are present in the compiled function. If a block is excluded by these macros it is not part of the final translation unit (affects compile-time reachability). \n\n- _MHD_UNWANTED_CLOCK, mono_clock_id, clock_gettime, mono_clock_start: the CLOCK_GETTIME branch contains a runtime if that compares mono_clock_id to _MHD_UNWANTED_CLOCK and calls clock_gettime; their values/behaviour determine whether that return path can execute. mono_clock_start is needed to see whether the arithmetic is meaningful but mainly to decide if the branch is executable. \n\n- _MHD_INVALID_CLOCK_SERV, mono_clock_service, clock_get_time, KERN_SUCCESS: the MACH (clock_get_time) branch has an if that compares mono_clock_service to _MHD_INVALID_CLOCK_SERV and checks clock_get_time result vs KERN_SUCCESS. These symbols determine whether that branch can be reached/return. \n\n- GetTickCount64, tick_start, perf_freq, QueryPerformanceCounter, perf_start: the Windows branches depend on _WIN32/_WIN32_WINNT and at runtime either call GetTickCount64 (constant-if branch present) or QueryPerformanceCounter and use perf_freq/perf_start; these globals/functions decide whether those return paths can occur. \n\n- gethrtime, hrtime_start: the gethrtime() branch (HAVE_GETHRTIME) returns based on gethrtime - hrtime_start; needed to know if that path can execute. \n\n- timespec_get, TIME_UTC, gettime_start: the timespec_get fallback branch requires timespec_get returning TIME_UTC and uses gettime_start; both affect reachability of that return. \n\n- gettimeofday, HAVE_GETTIMEOFDAY, gettime_start: the gettimeofday fallback branch (when present) returns after a successful gettimeofday; gettimeofday and gettime_start determine if that path can execute. \n\n- time, sys_clock_start: the final fallback always present uses time(NULL) - sys_clock_start; sys_clock_start determines whether the final return is a viable executed path (and whether earlier branches can preempt it). \n\nIn short: the feature macros decide which code is compiled, and the listed globals/constants/functions determine at runtime whether each conditional return can be taken. Both sets are necessary to decide if any compiled code in this function is provably unreachable (MISRA: unreachable code)."
}