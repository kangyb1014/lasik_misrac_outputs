{
  "user_message": "Target function code is:\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'connection_check_timedout': {'callees': ['MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_set_connection_option': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': []}, 'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA project shall not contain dead code. Any operation that is executed but whose removal would not affect program behaviour constitutes dead code. Notes:\n1. The behaviour of an embedded sytem is often determined not just by the nature of its actions, but also by the time at which they occur.\n2. unreachable code is not dead code, as it cannot be executed.\n3.Initialization is not the same as an assignment operation and is therfore not a candidate for dead code.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GETTIME",
    "HAVE_TIMESPEC_GET",
    "HAVE_CLOCK_GET_TIME",
    "_WIN32",
    "_WIN32_WINNT",
    "HAVE_GETHRTIME",
    "HAVE_GETTIMEOFDAY",
    "_MHD_UNWANTED_CLOCK",
    "mono_clock_id",
    "clock_gettime",
    "mono_clock_start",
    "_MHD_INVALID_CLOCK_SERV",
    "mono_clock_service",
    "clock_get_time",
    "KERN_SUCCESS",
    "mach_timespec_t",
    "GetTickCount64",
    "tick_start",
    "perf_freq",
    "LARGE_INTEGER",
    "QueryPerformanceCounter",
    "perf_start",
    "gethrtime",
    "hrtime_start",
    "timespec_get",
    "TIME_UTC",
    "gettime_start",
    "gettimeofday",
    "sys_clock_start",
    "time"
  ],
  "explanation": "For MISRA dead-code analysis we must know which branches are compiled in and which runtime conditions make branches reachable. Each symbol below is required to decide whether a code region is actually used (and thus not dead) or can be removed without changing behaviour:\n\nCompile-time feature macros (determine which code blocks exist at build time):\n- HAVE_CLOCK_GETTIME: enables the clock_gettime branch\u2014if undefined that block is dead at compile time.\n- HAVE_TIMESPEC_GET: enables the timespec_get fallback\u2014affects presence of that block.\n- HAVE_CLOCK_GET_TIME: enables the Mach clock_get_time branch on some systems.\n- _WIN32: enables Windows-specific branches (GetTickCount64 / perf counter) vs POSIX.\n- _WIN32_WINNT: distinguishes between GetTickCount64 usage and older perf counter code.\n- HAVE_GETHRTIME: enables gethrtime branch.\n- HAVE_GETTIMEOFDAY: enables gettimeofday fallback.\n\nRuntime selectors and constants (determine reachability at runtime and whether removing code would change behaviour):\n- _MHD_UNWANTED_CLOCK: used to compare against mono_clock_id; determines if clock_gettime branch is valid.\n- mono_clock_id: runtime clock identifier used with clock_gettime; necessary to know whether that branch may execute.\n- mono_clock_start: base time used in clock_gettime and Mach branch computations; affects returned values\u2014removing code using it changes behaviour.\n- _MHD_INVALID_CLOCK_SERV: sentinel for mono_clock_service; determines whether Mach branch runs.\n- mono_clock_service: runtime Mach clock service handle used by clock_get_time; controls reachability.\n- KERN_SUCCESS: return code used to decide success of clock_get_time; required to know if branch can return.\n- tick_start: Windows tick baseline for GetTickCount64 path; removing that code would change result if used.\n- perf_freq: performance-counter frequency used to compute ms for legacy Windows path; zero/non-zero decides whether that branch executes.\n- perf_start: baseline QueryPerformanceCounter value used in perf counter computations.\n- hrtime_start: baseline used by gethrtime path; affects returned value.\n- gettime_start: baseline used by timespec_get/gettimeofday fallback computations.\n- sys_clock_start: baseline used by time() fallback; last-resort return depends on it.\n\nFunctions and types that can succeed/fail and affect branch outcomes or timing behaviour:\n- clock_gettime: may succeed/fail; success leads to immediate return\u2014its semantics decide reachability.\n- clock_get_time: Mach kernel call that may succeed/fail; its return affects whether the branch returns.\n- mach_timespec_t: type of value returned by clock_get_time; needed to interpret the call result (tv_sec/tv_nsec).\n- GetTickCount64: Windows API used when available; presence and semantics matter for behaviour.\n- QueryPerformanceCounter: used for high-resolution time on older Windows; its availability/behavior affects branch.\n- LARGE_INTEGER: type used with QueryPerformanceCounter/ perf_counter arithmetic.\n- gethrtime: alternative high-resolution timer; its semantics determine behaviour of that branch.\n- timespec_get: C11 timespec_get function used in timespec_get fallback; return value compared to TIME_UTC to decide success.\n- TIME_UTC: expected return value for timespec_get success\u2014controls reachability of that fallback return.\n- gettimeofday: fallback function whose success affects whether that block returns.\n- time: standard last-resort function used in final return; its semantics (and sys_clock_start) determine final behaviour.\n\nWithout knowledge of these compile-time macros, runtime variables, return codes and timing baselines, you cannot decide which code paths are actually compiled or can execute, nor whether removing a branch would change observable behaviour (time values returned). Therefore they must be provided to the next analyst."
}