{
  "user_message": "Target function code is:\n```c\nuint64_t\nMHD_monotonic_msec_counter (void)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_TIMESPEC_GET)\n  struct timespec ts;\n#endif /* HAVE_CLOCK_GETTIME || HAVE_TIMESPEC_GET */\n\n#ifdef HAVE_CLOCK_GETTIME\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return (uint64_t) (((uint64_t) (ts.tv_sec - mono_clock_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return (uint64_t) (((uint64_t) (cur_time.tv_sec - mono_clock_start))\n                         * 1000 + (uint64_t) (cur_time.tv_nsec / 1000000));\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (uint64_t) (GetTickCount64 () - tick_start);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n    uint64_t num_ticks;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    num_ticks = (uint64_t) (perf_counter.QuadPart - perf_start);\n    return ((num_ticks / perf_freq) * 1000)\n           + ((num_ticks % perf_freq) / (perf_freq / 1000));\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return ((uint64_t) (gethrtime () - hrtime_start)) / 1000000;\n#endif /* HAVE_GETHRTIME */\n\n  /* Fallbacks, affected by system time change */\n#ifdef HAVE_TIMESPEC_GET\n  if (TIME_UTC == timespec_get (&ts, TIME_UTC))\n    return (uint64_t) (((uint64_t) (ts.tv_sec - gettime_start)) * 1000\n                       + (uint64_t) (ts.tv_nsec / 1000000));\n#elif defined(HAVE_GETTIMEOFDAY)\n  if (1)\n  {\n    struct timeval tv;\n    if (0 == gettimeofday (&tv, NULL))\n      return (uint64_t) (((uint64_t) (tv.tv_sec - gettime_start)) * 1000\n                         + (uint64_t) (tv.tv_usec / 1000));\n  }\n#endif /* HAVE_GETTIMEOFDAY */\n\n  /* The last resort fallback with very low resolution */\n  return (uint64_t) (time (NULL) - sys_clock_start) * 1000;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_monotonic_msec_counter': {'callees': [], 'callers': ['MHD_update_last_activity_', 'connection_check_timedout', 'MHD_set_connection_option', 'connection_get_wait', 'new_connection_prepare_', 'resume_suspended_connections', 'calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}, 'MHD_update_last_activity_': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': ['MHD_connection_handle_read', 'MHD_connection_handle_write', 'MHD_queue_response', 'thread_main_handle_connection']}, 'connection_check_timedout': {'callees': ['MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_connection_handle_idle']}, 'MHD_set_connection_option': {'callees': ['MHD_monotonic_msec_counter', '__builtin_unreachable'], 'callers': []}, 'connection_get_wait': {'callees': ['MHD_monotonic_msec_counter'], 'callers': ['thread_main_handle_connection', 'MHD_get_timeout64']}, 'new_connection_prepare_': {'callees': ['MHD_ip_limit_add', 'MHD_DLOG', '__builtin_unreachable', 'MHD_ip_limit_del', 'MHD_monotonic_msec_counter', 'MHD_set_http_callbacks_'], 'callers': ['internal_add_connection']}, 'resume_suspended_connections': {'callees': ['__builtin_unreachable', 'MHD_monotonic_msec_counter', 'MHD_DLOG'], 'callers': ['MHD_run_from_select2', 'MHD_select', 'MHD_poll_all', 'MHD_poll_listen_socket', 'MHD_epoll', 'MHD_polling_thread', 'close_all_connections']}, 'calculate_add_nonce_with_retry': {'callees': ['MHD_monotonic_msec_counter', 'MHD_get_master', 'MHD_DLOG', 'calculate_add_nonce', 'digest_get_size', '__builtin_rotateleft32', 'digest_reset'], 'callers': ['queue_auth_required_response3_inner']}, 'digest_auth_check_all_inner': {'callees': ['MHD_get_master', 'MHD_get_rq_dauth_params_', 'MHD_DLOG', 'digest_init_one_time', 'get_base_digest_algo', '__builtin_unreachable', 'digest_get_size', 'is_param_equal', 'get_buffer_for_size', 'get_rq_extended_uname_copy_z', 'calc_userhash', 'MHD_bin_to_hex', 'is_param_equal_caseless', 'digest_reset', 'get_unquoted_param', 'MHD_strx_to_uint64_n_', 'get_nonce_timestamp', 'MHD_monotonic_msec_counter', 'check_nonce_nc', 'digest_update_str', 'digest_update_with_colon', 'get_unquoted_param_copy', 'digest_update', 'check_uri_match', 'digest_calc_hash', 'calc_userdigest', 'MHD_hex_to_bin', 'calculate_nonce'], 'callers': ['digest_auth_check_all']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nControlling expressions shall not be invariant. Here are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GETTIME",
    "HAVE_TIMESPEC_GET",
    "HAVE_CLOCK_GET_TIME",
    "_WIN32",
    "_WIN32_WINNT",
    "HAVE_GETHRTIME",
    "HAVE_GETTIMEOFDAY",
    "TIME_UTC",
    "_MHD_UNWANTED_CLOCK",
    "mono_clock_id",
    "clock_gettime",
    "_MHD_INVALID_CLOCK_SERV",
    "mono_clock_service",
    "clock_get_time",
    "KERN_SUCCESS",
    "perf_freq",
    "QueryPerformanceCounter",
    "perf_start",
    "GetTickCount64",
    "tick_start",
    "gethrtime",
    "hrtime_start",
    "timespec_get",
    "gettime_start",
    "gettimeofday",
    "time",
    "sys_clock_start"
  ],
  "explanation": "For checking whether any controlling expression in MHD_monotonic_msec_counter is an invariant (constant) under the MISRA rule, the analyzer needs the following kinds of symbols:\n\n- Feature-test macros that control which conditional blocks are compiled (#ifdef/#elif). Whether an apparent invariant controlling expression (for example if (1)) is present in the translation unit depends on these macros. Symbols: HAVE_CLOCK_GETTIME, HAVE_TIMESPEC_GET, HAVE_CLOCK_GET_TIME, _WIN32, _WIN32_WINNT, HAVE_GETHRTIME, HAVE_GETTIMEOFDAY, TIME_UTC.\n\n- Symbols used directly in the controlling expressions so the analyzer can determine if they are compile-time constants or runtime-varying:\n  - _MHD_UNWANTED_CLOCK, mono_clock_id: used in the first conditional ( _MHD_UNWANTED_CLOCK != mono_clock_id ). If either is a compile-time constant or macro the condition could be invariant.\n  - clock_gettime: called in the controlling expression (0 == clock_gettime(...)). The analyzer needs to know whether this call can be evaluated at compile time (usually not) or is a macro/constant.\n  - _MHD_INVALID_CLOCK_SERV, mono_clock_service, clock_get_time, KERN_SUCCESS: used in the MACH clock block; required to judge whether the if condition can be invariant.\n  - perf_freq, QueryPerformanceCounter, perf_start: used in the Windows high-resolution timer branch; needed to determine if (0 != perf_freq) is invariant and whether QueryPerformanceCounter is a runtime call.\n  - GetTickCount64, tick_start: used under newer Windows; the block contains if (1) \u2014 the presence of that invariant depends on _WIN32/_WIN32_WINNT and whether GetTickCount64/tick_start are relevant to judge intent.\n  - gethrtime, hrtime_start: used with an if (1) under HAVE_GETHRTIME; need to know whether that if (1) is compiled in and whether gethrtime is a runtime call.\n  - timespec_get, gettime_start: used in the timespec_get fallback (TIME_UTC == timespec_get(...)); needed to determine if the timespec_get expression is invariant.\n  - gettimeofday: present in the HAVE_GETTIMEOFDAY fallback; the outer block uses if (1) \u2014 need to know if that is present and whether inner gettimeofday return value is runtime-varying.\n  - time, sys_clock_start: used in the final fallback return; while not a controlling expression here, time/sys_clock_start inform whether any last-resort behavior might have accompanied invariant conditionals elsewhere.\n\nIn short: include all feature macros that change which conditionals exist and every identifier appearing in the controlling expressions (macros, global variables, and functions) so the next agent can decide if any controlling expression is a compile-time invariant or is dependent on runtime state (and thus whether a MISRA violation actually occurs)."
}