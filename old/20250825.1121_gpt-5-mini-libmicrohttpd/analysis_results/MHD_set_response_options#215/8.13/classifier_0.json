{
  "user_message": "<misra_rule>\nMISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<response format>\nProvide your answer with these fields.\n- is_rule_violated: whether the rule is violated or not (true/false),\n- scenario: a specific violation scenario.\n</response format>\n<target_code>\nHere is the code of MHD_set_response_options:\n```c\n_MHD_EXTERN enum MHD_Result\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  enum MHD_Result ret;\n  enum MHD_ResponseOptions ro;\n\n  if (0 != (response->flags_auto & MHD_RAF_HAS_CONTENT_LENGTH))\n  { /* Response has custom \"Content-Lengh\" header */\n    if ( (0 != (response->flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)) &&\n         (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH)))\n    { /* Request to remove MHD_RF_INSANITY_HEADER_CONTENT_LENGTH flag */\n      return MHD_NO;\n    }\n    if ( (0 != (response->flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n         (0 == (flags & MHD_RF_HEAD_ONLY_RESPONSE)))\n    { /* Request to remove MHD_RF_HEAD_ONLY_RESPONSE flag */\n      if (0 == (flags & MHD_RF_INSANITY_HEADER_CONTENT_LENGTH))\n        return MHD_NO;\n    }\n  }\n\n  if ( (0 != (flags & MHD_RF_HEAD_ONLY_RESPONSE)) &&\n       (0 != response->total_size) )\n    return MHD_NO;\n\n  ret = MHD_YES;\n  response->flags = flags;\n\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    case MHD_RO_END: /* Not possible */\n      break;\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n  return ret;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_set_response_options:\nstruct MHD_Response\n{\n\n  /**\n   * Head of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *first_header;\n\n  /**\n   * Tail of double-linked list of headers to send for the response.\n   */\n  struct MHD_HTTP_Res_Header *last_header;\n\n  /**\n   * Buffer pointing to data that we are supposed\n   * to send as a response.\n   */\n  const char *data;\n\n  /**\n   * Closure to give to the content reader @e crc\n   * and content reader free callback @e crfc.\n   */\n  void *crc_cls;\n\n  /**\n   * How do we get more data?  NULL if we are\n   * given all of the data up front.\n   */\n  MHD_ContentReaderCallback crc;\n\n  /**\n   * NULL if data must not be freed, otherwise\n   * either user-specified callback or \"&free\".\n   */\n  MHD_ContentReaderFreeCallback crfc;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * Application function to call once we are done sending the headers\n   * of the response; NULL unless this is a response created with\n   * #MHD_create_response_for_upgrade().\n   */\n  MHD_UpgradeHandler upgrade_handler;\n\n  /**\n   * Closure for @e uh.\n   */\n  void *upgrade_handler_cls;\n#endif /* UPGRADE_SUPPORT */\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Mutex to synchronize access to @e data, @e size and\n   * @e reference_count.\n   */\n  MHD_mutex_ mutex;\n#endif\n\n  /**\n   * The size of the response body.\n   * Set to #MHD_SIZE_UNKNOWN if size is not known.\n   */\n  uint64_t total_size;\n\n  /**\n   * At what offset in the stream is the\n   * beginning of @e data located?\n   */\n  uint64_t data_start;\n\n  /**\n   * Offset to start reading from when using @e fd.\n   */\n  uint64_t fd_off;\n\n  /**\n   * Number of bytes ready in @e data (buffer may be larger\n   * than what is filled with payload).\n   */\n  size_t data_size;\n\n  /**\n   * Size of the writable data buffer @e data.\n   */\n  size_t data_buffer_size;\n\n  /**\n   * Reference count for this response.  Free once the counter hits\n   * zero.\n   */\n  unsigned int reference_count;\n\n  /**\n   * File-descriptor if this response is FD-backed.\n   */\n  int fd;\n\n  /**\n   * Flags set for the MHD response.\n   */\n  enum MHD_ResponseFlags flags;\n\n  /**\n   * Automatic flags set for the MHD response.\n   */\n  enum MHD_ResponseAutoFlags flags_auto;\n\n  /**\n   * If the @e fd is a pipe (no sendfile()).\n   */\n  bool is_pipe;\n\n  /**\n   * I/O vector used with MHD_create_response_from_iovec.\n   */\n  MHD_iovec_ *data_iov;\n\n  /**\n   * Number of elements in data_iov.\n   */\n  unsigned int data_iovcnt;\n}\n...\nenum MHD_Result\n{\n  /**\n   * MHD result code for \"NO\".\n   */\n  MHD_NO = 0,\n\n  /**\n   * MHD result code for \"YES\".\n   */\n  MHD_YES = 1\n\n}\n...\nenum MHD_ResponseFlags\n{\n  /**\n   * Default: no special flags.\n   * @note Available since #MHD_VERSION 0x00093701\n   */\n  MHD_RF_NONE = 0,\n\n  /**\n   * Only respond in conservative (dumb) HTTP/1.0-compatible mode.\n   * Response still use HTTP/1.1 version in header, but always close\n   * the connection after sending the response and do not use chunked\n   * encoding for the response.\n   * You can also set the #MHD_RF_HTTP_1_0_SERVER flag to force\n   * HTTP/1.0 version in the response.\n   * Responses are still compatible with HTTP/1.1.\n   * This option can be used to communicate with some broken client, which\n   * does not implement HTTP/1.1 features, but advertises HTTP/1.1 support.\n   * @note Available since #MHD_VERSION 0x00097308\n   */\n  MHD_RF_HTTP_1_0_COMPATIBLE_STRICT = 1 << 0,\n  /**\n   * The same as #MHD_RF_HTTP_1_0_COMPATIBLE_STRICT\n   * @note Available since #MHD_VERSION 0x00093701\n   */\n  MHD_RF_HTTP_VERSION_1_0_ONLY = 1 << 0,\n\n  /**\n   * Only respond in HTTP 1.0-mode.\n   * Contrary to the #MHD_RF_HTTP_1_0_COMPATIBLE_STRICT flag, the response's\n   * HTTP version will always be set to 1.0 and keep-alive connections\n   * will be used if explicitly requested by the client.\n   * The \"Connection:\" header will be added for both \"close\" and \"keep-alive\"\n   * connections.\n   * Chunked encoding will not be used for the response.\n   * Due to backward compatibility, responses still can be used with\n   * HTTP/1.1 clients.\n   * This option can be used to emulate HTTP/1.0 server (for response part\n   * only as chunked encoding in requests (if any) is processed by MHD).\n   * @note Available since #MHD_VERSION 0x00097308\n   */\n  MHD_RF_HTTP_1_0_SERVER = 1 << 1,\n  /**\n   * The same as #MHD_RF_HTTP_1_0_SERVER\n   * @note Available since #MHD_VERSION 0x00096000\n   */\n  MHD_RF_HTTP_VERSION_1_0_RESPONSE = 1 << 1,\n\n  /**\n   * Disable sanity check preventing clients from manually\n   * setting the HTTP content length option.\n   * Allow to set several \"Content-Length\" headers. These headers will\n   * be used even with replies without body.\n   * @note Available since #MHD_VERSION 0x00096702\n   */\n  MHD_RF_INSANITY_HEADER_CONTENT_LENGTH = 1 << 2,\n\n  /**\n   * Enable sending of \"Connection: keep-alive\" header even for\n   * HTTP/1.1 clients when \"Keep-Alive\" connection is used.\n   * Disabled by default for HTTP/1.1 clients as per RFC.\n   * @note Available since #MHD_VERSION 0x00097310\n   */\n  MHD_RF_SEND_KEEP_ALIVE_HEADER = 1 << 3,\n\n  /**\n   * Enable special processing of the response as body-less (with undefined\n   * body size). No automatic \"Content-Length\" or \"Transfer-Encoding: chunked\"\n   * headers are added when the response is used with #MHD_HTTP_NOT_MODIFIED\n   * code or to respond to HEAD request.\n   * The flag also allow to set arbitrary \"Content-Length\" by\n   * MHD_add_response_header() function.\n   * This flag value can be used only with responses created without body\n   * (zero-size body).\n   * Responses with this flag enabled cannot be used in situations where\n   * reply body must be sent to the client.\n   * This flag is primarily intended to be used when automatic \"Content-Length\"\n   * header is undesirable in response to HEAD requests.\n   * @note Available since #MHD_VERSION 0x00097701\n   */\n  MHD_RF_HEAD_ONLY_RESPONSE = 1 << 4\n}\n...\nenum MHD_ResponseOptions\n{\n  /**\n   * End of the list of options.\n   */\n  MHD_RO_END = 0\n}\n</additional code>\n<target_code>\nHere is the code fragment that you need to analyze:\n```c\nstruct MHD_HTTP_Res_Header *last_header;\n```\nFocus on the above code fragment and judge whether it violates the rule 8.13 or not.\n</target_code>\n",
  "is_rule_violated": false,
  "scenario": "No violation: last_header is the tail pointer of a mutable double-linked list of response headers and will be used to add/remove/update headers, so it must point to a non-const MHD_HTTP_Res_Header. Therefore it cannot be const-qualified; the declaration is appropriate. (If the pointer were only used for read-only access, it should be const-qualified.)"
}