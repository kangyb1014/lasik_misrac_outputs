{
  "user_message": "An agent A claimed that the following sha512_256_transform code violates the MISRA C 2023 rule 1.2.\n<misra_rule>\nMISRA C 2023 Rule 1.2 is Language extensions should not be used.\nYou should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\n</misra_rule>\n<target_code>\nHere is the original code of sha512_256_transform.\n```c\nstatic void\nsha512_256_transform (uint64_t H[SHA512_256_HASH_SIZE_WORDS],\n                      const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 clause 6.7, 6.4. */\n  uint64_t a = H[0];\n  uint64_t b = H[1];\n  uint64_t c = H[2];\n  uint64_t d = H[3];\n  uint64_t e = H[4];\n  uint64_t f = H[5];\n  uint64_t g = H[6];\n  uint64_t h = H[7];\n\n  /* Data buffer, used as a cyclic buffer.\n     See FIPS PUB 180-4 clause 5.2.2, 6.7, 6.4. */\n  uint64_t W[16];\n\n#ifndef _MHD_GET_64BIT_BE_ALLOW_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT64_ALIGN))\n  { /* The input data is unaligned */\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, sizeof(W));\n    /* The W[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_64BIT_BE_ALLOW_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimisation.\n     See FIPS PUB 180-4 formulae 4.8, 4.9. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.10, 4.11, 4.12, 4.13. */\n#define SIG0(x)  \\\n  ( _MHD_ROTR64 ((x), 28) ^ _MHD_ROTR64 ((x), 34) ^ _MHD_ROTR64 ((x), 39) )\n#define SIG1(x)  \\\n  ( _MHD_ROTR64 ((x), 14) ^ _MHD_ROTR64 ((x), 18) ^ _MHD_ROTR64 ((x), 41) )\n#define sig0(x)  \\\n  ( _MHD_ROTR64 ((x), 1) ^ _MHD_ROTR64 ((x), 8) ^ ((x) >> 7) )\n#define sig1(x)  \\\n  ( _MHD_ROTR64 ((x), 19) ^ _MHD_ROTR64 ((x), 61) ^ ((x) >> 6) )\n\n  /* One step of SHA-512/256 computation,\n     see FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: the first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n           the second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other\n           data as well every time when used. */\n#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer for 0 <= t <= 15,\n     See FIPS PUB 180-4 clause 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 clause 3.1.2. */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_64BIT_BE (((const uint64_t*) (buf)) + (t))\n\n  /* 'W' generation and assignment for 16 <= t <= 79.\n     See FIPS PUB 180-4 clause 6.4.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as a cyclic buffer.\n   * Note: ((t-16) & 15) have same value as (t & 15) */\n#define Wgen(w,t) ( (w)[(t - 16) & 15] + sig1 ((w)[((t) - 2) & 15])   \\\n                    + (w)[((t) - 7) & 15] + sig0 ((w)[((t) - 15) & 15]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP64(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP64(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), W[0]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), W[1]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), W[2]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), W[3]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), W[4]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), W[5]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), W[6]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), W[7]);\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), W[8]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), W[9]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), W[10]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), W[11]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), W[12]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), W[13]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), W[14]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), \\\n                W[0] = GET_W_FROM_DATA (data, 0));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), \\\n                W[1] = GET_W_FROM_DATA (data, 1));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), \\\n                W[2] = GET_W_FROM_DATA (data, 2));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), \\\n                W[3] = GET_W_FROM_DATA (data, 3));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), \\\n                W[4] = GET_W_FROM_DATA (data, 4));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), \\\n                W[5] = GET_W_FROM_DATA (data, 5));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), \\\n                W[6] = GET_W_FROM_DATA (data, 6));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), \\\n                W[7] = GET_W_FROM_DATA (data, 7));\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), \\\n                W[8] = GET_W_FROM_DATA (data, 8));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), \\\n                W[9] = GET_W_FROM_DATA (data, 9));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), \\\n                W[10] = GET_W_FROM_DATA (data, 10));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), \\\n                W[11] = GET_W_FROM_DATA (data, 11));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), \\\n                W[12] = GET_W_FROM_DATA (data, 12));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), \\\n                W[13] = GET_W_FROM_DATA (data, 13));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), \\\n                W[14] = GET_W_FROM_DATA (data, 14));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), \\\n                W[15] = GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 64 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n     K values. */\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xe49b69c19ef14ad2), \\\n              W[16 & 15] = Wgen (W,16));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xefbe4786384f25e3), \\\n              W[17 & 15] = Wgen (W,17));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x0fc19dc68b8cd5b5), \\\n              W[18 & 15] = Wgen (W,18));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x240ca1cc77ac9c65), \\\n              W[19 & 15] = Wgen (W,19));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x2de92c6f592b0275), \\\n              W[20 & 15] = Wgen (W,20));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4a7484aa6ea6e483), \\\n              W[21 & 15] = Wgen (W,21));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5cb0a9dcbd41fbd4), \\\n              W[22 & 15] = Wgen (W,22));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x76f988da831153b5), \\\n              W[23 & 15] = Wgen (W,23));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x983e5152ee66dfab), \\\n              W[24 & 15] = Wgen (W,24));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa831c66d2db43210), \\\n              W[25 & 15] = Wgen (W,25));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb00327c898fb213f), \\\n              W[26 & 15] = Wgen (W,26));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xbf597fc7beef0ee4), \\\n              W[27 & 15] = Wgen (W,27));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xc6e00bf33da88fc2), \\\n              W[28 & 15] = Wgen (W,28));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd5a79147930aa725), \\\n              W[29 & 15] = Wgen (W,29));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x06ca6351e003826f), \\\n              W[30 & 15] = Wgen (W,30));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x142929670a0e6e70), \\\n              W[31 & 15] = Wgen (W,31));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x27b70a8546d22ffc), \\\n              W[32 & 15] = Wgen (W,32));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x2e1b21385c26c926), \\\n              W[33 & 15] = Wgen (W,33));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x4d2c6dfc5ac42aed), \\\n              W[34 & 15] = Wgen (W,34));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x53380d139d95b3df), \\\n              W[35 & 15] = Wgen (W,35));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x650a73548baf63de), \\\n              W[36 & 15] = Wgen (W,36));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x766a0abb3c77b2a8), \\\n              W[37 & 15] = Wgen (W,37));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x81c2c92e47edaee6), \\\n              W[38 & 15] = Wgen (W,38));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x92722c851482353b), \\\n              W[39 & 15] = Wgen (W,39));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xa2bfe8a14cf10364), \\\n              W[40 & 15] = Wgen (W,40));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa81a664bbc423001), \\\n              W[41 & 15] = Wgen (W,41));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xc24b8b70d0f89791), \\\n              W[42 & 15] = Wgen (W,42));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xc76c51a30654be30), \\\n              W[43 & 15] = Wgen (W,43));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xd192e819d6ef5218), \\\n              W[44 & 15] = Wgen (W,44));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd69906245565a910), \\\n              W[45 & 15] = Wgen (W,45));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xf40e35855771202a), \\\n              W[46 & 15] = Wgen (W,46));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x106aa07032bbd1b8), \\\n              W[47 & 15] = Wgen (W,47));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x19a4c116b8d2d0c8), \\\n              W[48 & 15] = Wgen (W,48));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x1e376c085141ab53), \\\n              W[49 & 15] = Wgen (W,49));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x2748774cdf8eeb99), \\\n              W[50 & 15] = Wgen (W,50));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x34b0bcb5e19b48a8), \\\n              W[51 & 15] = Wgen (W,51));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x391c0cb3c5c95a63), \\\n              W[52 & 15] = Wgen (W,52));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4ed8aa4ae3418acb), \\\n              W[53 & 15] = Wgen (W,53));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5b9cca4f7763e373), \\\n              W[54 & 15] = Wgen (W,54));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x682e6ff3d6b2b8a3), \\\n              W[55 & 15] = Wgen (W,55));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x748f82ee5defb2fc), \\\n              W[56 & 15] = Wgen (W,56));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x78a5636f43172f60), \\\n              W[57 & 15] = Wgen (W,57));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x84c87814a1f0ab72), \\\n              W[58 & 15] = Wgen (W,58));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x8cc702081a6439ec), \\\n              W[59 & 15] = Wgen (W,59));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x90befffa23631e28), \\\n              W[60 & 15] = Wgen (W,60));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xa4506cebde82bde9), \\\n              W[61 & 15] = Wgen (W,61));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xbef9a3f7b2c67915), \\\n              W[62 & 15] = Wgen (W,62));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc67178f2e372532b), \\\n              W[63 & 15] = Wgen (W,63));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xca273eceea26619c), \\\n              W[64 & 15] = Wgen (W,64));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xd186b8c721c0c207), \\\n              W[65 & 15] = Wgen (W,65));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xeada7dd6cde0eb1e), \\\n              W[66 & 15] = Wgen (W,66));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xf57d4f7fee6ed178), \\\n              W[67 & 15] = Wgen (W,67));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x06f067aa72176fba), \\\n              W[68 & 15] = Wgen (W,68));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x0a637dc5a2c898a6), \\\n              W[69 & 15] = Wgen (W,69));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x113f9804bef90dae), \\\n              W[70 & 15] = Wgen (W,70));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x1b710b35131c471b), \\\n              W[71 & 15] = Wgen (W,71));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x28db77f523047d84), \\\n              W[72 & 15] = Wgen (W,72));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x32caab7b40c72493), \\\n              W[73 & 15] = Wgen (W,73));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x3c9ebe0a15c9bebc), \\\n              W[74 & 15] = Wgen (W,74));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x431d67c49c100d4c), \\\n              W[75 & 15] = Wgen (W,75));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x4cc5d4becb3e42b6), \\\n              W[76 & 15] = Wgen (W,76));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x597f299cfc657e2a), \\\n              W[77 & 15] = Wgen (W,77));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5fcb6fab3ad6faec), \\\n              W[78 & 15] = Wgen (W,78));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x6c44198c4a475817), \\\n              W[79 & 15] = Wgen (W,79));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 clause 4.2.3 for K values. */\n    static const uint64_t K[80] =\n    { UINT64_C (0x428a2f98d728ae22), UINT64_C (0x7137449123ef65cd),\n      UINT64_C (0xb5c0fbcfec4d3b2f), UINT64_C (0xe9b5dba58189dbbc),\n      UINT64_C (0x3956c25bf348b538), UINT64_C (0x59f111f1b605d019),\n      UINT64_C (0x923f82a4af194f9b), UINT64_C (0xab1c5ed5da6d8118),\n      UINT64_C (0xd807aa98a3030242), UINT64_C (0x12835b0145706fbe),\n      UINT64_C (0x243185be4ee4b28c), UINT64_C (0x550c7dc3d5ffb4e2),\n      UINT64_C (0x72be5d74f27b896f), UINT64_C (0x80deb1fe3b1696b1),\n      UINT64_C (0x9bdc06a725c71235), UINT64_C (0xc19bf174cf692694),\n      UINT64_C (0xe49b69c19ef14ad2), UINT64_C (0xefbe4786384f25e3),\n      UINT64_C (0x0fc19dc68b8cd5b5), UINT64_C (0x240ca1cc77ac9c65),\n      UINT64_C (0x2de92c6f592b0275), UINT64_C (0x4a7484aa6ea6e483),\n      UINT64_C (0x5cb0a9dcbd41fbd4), UINT64_C (0x76f988da831153b5),\n      UINT64_C (0x983e5152ee66dfab), UINT64_C (0xa831c66d2db43210),\n      UINT64_C (0xb00327c898fb213f), UINT64_C (0xbf597fc7beef0ee4),\n      UINT64_C (0xc6e00bf33da88fc2), UINT64_C (0xd5a79147930aa725),\n      UINT64_C (0x06ca6351e003826f), UINT64_C (0x142929670a0e6e70),\n      UINT64_C (0x27b70a8546d22ffc), UINT64_C (0x2e1b21385c26c926),\n      UINT64_C (0x4d2c6dfc5ac42aed), UINT64_C (0x53380d139d95b3df),\n      UINT64_C (0x650a73548baf63de), UINT64_C (0x766a0abb3c77b2a8),\n      UINT64_C (0x81c2c92e47edaee6), UINT64_C (0x92722c851482353b),\n      UINT64_C (0xa2bfe8a14cf10364), UINT64_C (0xa81a664bbc423001),\n      UINT64_C (0xc24b8b70d0f89791), UINT64_C (0xc76c51a30654be30),\n      UINT64_C (0xd192e819d6ef5218), UINT64_C (0xd69906245565a910),\n      UINT64_C (0xf40e35855771202a), UINT64_C (0x106aa07032bbd1b8),\n      UINT64_C (0x19a4c116b8d2d0c8), UINT64_C (0x1e376c085141ab53),\n      UINT64_C (0x2748774cdf8eeb99), UINT64_C (0x34b0bcb5e19b48a8),\n      UINT64_C (0x391c0cb3c5c95a63), UINT64_C (0x4ed8aa4ae3418acb),\n      UINT64_C (0x5b9cca4f7763e373), UINT64_C (0x682e6ff3d6b2b8a3),\n      UINT64_C (0x748f82ee5defb2fc), UINT64_C (0x78a5636f43172f60),\n      UINT64_C (0x84c87814a1f0ab72), UINT64_C (0x8cc702081a6439ec),\n      UINT64_C (0x90befffa23631e28), UINT64_C (0xa4506cebde82bde9),\n      UINT64_C (0xbef9a3f7b2c67915), UINT64_C (0xc67178f2e372532b),\n      UINT64_C (0xca273eceea26619c), UINT64_C (0xd186b8c721c0c207),\n      UINT64_C (0xeada7dd6cde0eb1e), UINT64_C (0xf57d4f7fee6ed178),\n      UINT64_C (0x06f067aa72176fba), UINT64_C (0x0a637dc5a2c898a6),\n      UINT64_C (0x113f9804bef90dae), UINT64_C (0x1b710b35131c471b),\n      UINT64_C (0x28db77f523047d84), UINT64_C (0x32caab7b40c72493),\n      UINT64_C (0x3c9ebe0a15c9bebc), UINT64_C (0x431d67c49c100d4c),\n      UINT64_C (0x4cc5d4becb3e42b6), UINT64_C (0x597f299cfc657e2a),\n      UINT64_C (0x5fcb6fab3ad6faec), UINT64_C (0x6c44198c4a475817)};\n\n    /* One step of SHA-512/256 computation with working variables rotation,\n       see FIPS PUB 180-4 clause 6.4.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP64RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n  uint64_t tmp_h_ = (vH);                                             \\\n  SHA2STEP64((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));    \\\n  (vH) = (vG);                                                        \\\n  (vG) = (vF);                                                        \\\n  (vF) = (vE);                                                        \\\n  (vE) = (vD);                                                        \\\n  (vD) = (vC);                                                        \\\n  (vC) = (vB);                                                        \\\n  (vB) = (vA);                                                        \\\n  (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n    /* During last 64 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 80; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Compute and store the intermediate hash.\n     See FIPS PUB 180-4 clause 6.4.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe macro uses the compiler-specific builtin __builtin_rotateright64 (a GCC/Clang extension) in _MHD_ROTR64: #define _MHD_ROTR64(value64, bits) ((uint64_t)__builtin_rotateright64((value64),(bits))). This is an explicit compiler language extension and thus violates MISRA C 2023 Rule 1.2.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function sha512_256_transform:\n#define _MHD_ROTR64(value64, bits) ((uint64_t)__builtin_rotateright64((value64),(bits)))\n...\n#define _MHD_GET_64BIT_BE(addr) _MHD_BYTES_SWAP64(*(constuint64_t*)(addr))\n...\n#define _MHD_UINT64_ALIGN _MHD_ALIGNOF(uint64_t)\n...\n#define _MHD_BYTE_ORDER _MHD_LITTLE_ENDIAN\n...\n#define _MHD_BIG_ENDIAN 1234\n...\n#define SHA512_256_HASH_SIZE_WORDS 8\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "Correct. The supplied additional definitions show that _MHD_ROTR64 expands to the non\u2011standard compiler intrinsic __builtin_rotateright64. __builtin_* intrinsics are compiler extensions (GCC/Clang documented builtins) and are not part of standard C. MISRA C:2023 Rule 1.2 forbids use of language/compiler extensions unless they are explicitly allowed; therefore the code as written (using _MHD_ROTR64 -> __builtin_rotateright64, and then used in SIG0/SIG1/sig macros inside sha512_256_transform) violates Rule 1.2. To comply, the rotation should be implemented portably (for example with (x >> n) | (x << (64U - (n))) or guarded by conditional compilation that provides a strictly conforming fallback)."
}