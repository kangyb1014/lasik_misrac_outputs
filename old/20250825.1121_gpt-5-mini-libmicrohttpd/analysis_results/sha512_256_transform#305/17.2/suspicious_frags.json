{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 17.2 is: Functions shall not call themselves, either directly or indirectly.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of sha512_256_transform:\n```c\nstatic void\nsha512_256_transform (uint64_t H[SHA512_256_HASH_SIZE_WORDS],\n                      const void *data)\n{\n  /* Working variables,\n     see FIPS PUB 180-4 clause 6.7, 6.4. */\n  uint64_t a = H[0];\n  uint64_t b = H[1];\n  uint64_t c = H[2];\n  uint64_t d = H[3];\n  uint64_t e = H[4];\n  uint64_t f = H[5];\n  uint64_t g = H[6];\n  uint64_t h = H[7];\n\n  /* Data buffer, used as a cyclic buffer.\n     See FIPS PUB 180-4 clause 5.2.2, 6.7, 6.4. */\n  uint64_t W[16];\n\n#ifndef _MHD_GET_64BIT_BE_ALLOW_UNALIGNED\n  if (0 != (((uintptr_t) data) % _MHD_UINT64_ALIGN))\n  { /* The input data is unaligned */\n    /* Copy the unaligned input data to the aligned buffer */\n    memcpy (W, data, sizeof(W));\n    /* The W[] buffer itself will be used as the source of the data,\n     * but the data will be reloaded in correct bytes order on\n     * the next steps */\n    data = (const void *) W;\n  }\n#endif /* _MHD_GET_64BIT_BE_ALLOW_UNALIGNED */\n\n  /* 'Ch' and 'Maj' macro functions are defined with\n     widely-used optimisation.\n     See FIPS PUB 180-4 formulae 4.8, 4.9. */\n#define Ch(x,y,z)     ( (z) ^ ((x) & ((y) ^ (z))) )\n#define Maj(x,y,z)    ( ((x) & (y)) ^ ((z) & ((x) ^ (y))) )\n  /* Unoptimized (original) versions: */\n/* #define Ch(x,y,z)  ( ( (x) & (y) ) ^ ( ~(x) & (z) ) )          */\n/* #define Maj(x,y,z) ( ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)) ) */\n\n  /* Four 'Sigma' macro functions.\n     See FIPS PUB 180-4 formulae 4.10, 4.11, 4.12, 4.13. */\n#define SIG0(x)  \\\n  ( _MHD_ROTR64 ((x), 28) ^ _MHD_ROTR64 ((x), 34) ^ _MHD_ROTR64 ((x), 39) )\n#define SIG1(x)  \\\n  ( _MHD_ROTR64 ((x), 14) ^ _MHD_ROTR64 ((x), 18) ^ _MHD_ROTR64 ((x), 41) )\n#define sig0(x)  \\\n  ( _MHD_ROTR64 ((x), 1) ^ _MHD_ROTR64 ((x), 8) ^ ((x) >> 7) )\n#define sig1(x)  \\\n  ( _MHD_ROTR64 ((x), 19) ^ _MHD_ROTR64 ((x), 61) ^ ((x) >> 6) )\n\n  /* One step of SHA-512/256 computation,\n     see FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: this macro updates working variables in-place, without rotation.\n   * Note: the first (vH += SIG1(vE) + Ch(vE,vF,vG) + kt + wt) equals T1 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n           the second (vH += SIG0(vA) + Maj(vE,vF,vC) equals T1 + T2 in\n           FIPS PUB 180-4 clause 6.4.2 step 3.\n   * Note: 'wt' must be used exactly one time in this macro as it change other\n           data as well every time when used. */\n#define SHA2STEP64(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {                  \\\n    (vD) += ((vH) += SIG1 ((vE)) + Ch ((vE),(vF),(vG)) + (kt) + (wt));  \\\n    (vH) += SIG0 ((vA)) + Maj ((vA),(vB),(vC)); } while (0)\n\n  /* Get value of W(t) from input data buffer for 0 <= t <= 15,\n     See FIPS PUB 180-4 clause 6.2.\n     Input data must be read in big-endian bytes order,\n     see FIPS PUB 180-4 clause 3.1.2. */\n#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_64BIT_BE (((const uint64_t*) (buf)) + (t))\n\n  /* 'W' generation and assignment for 16 <= t <= 79.\n     See FIPS PUB 180-4 clause 6.4.2.\n     As only last 16 'W' are used in calculations, it is possible to\n     use 16 elements array of W as a cyclic buffer.\n   * Note: ((t-16) & 15) have same value as (t & 15) */\n#define Wgen(w,t) ( (w)[(t - 16) & 15] + sig1 ((w)[((t) - 2) & 15])   \\\n                    + (w)[((t) - 7) & 15] + sig0 ((w)[((t) - 15) & 15]) )\n\n#ifndef MHD_FAVOR_SMALL_CODE\n\n  /* Note: instead of using K constants as array, all K values are specified\n           individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n           K values. */\n  /* Note: instead of reassigning all working variables on each step,\n           variables are rotated for each step:\n             SHA2STEP64(a, b, c, d, e, f, g, h, K[0], data[0]);\n             SHA2STEP64(h, a, b, c, d, e, f, g, K[1], data[1]);\n           so current 'vD' will be used as 'vE' on next step,\n           current 'vH' will be used as 'vA' on next step. */\n#if _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN\n  if ((const void *) W == data)\n  {\n    /* The input data is already in the cyclic data buffer W[] in correct bytes\n       order. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), W[0]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), W[1]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), W[2]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), W[3]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), W[4]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), W[5]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), W[6]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), W[7]);\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), W[8]);\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), W[9]);\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), W[10]);\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), W[11]);\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), W[12]);\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), W[13]);\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), W[14]);\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), W[15]);\n  }\n  else /* Combined with the next 'if' */\n#endif /* _MHD_BYTE_ORDER == _MHD_BIG_ENDIAN */\n  if (1)\n  {\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), \\\n                W[0] = GET_W_FROM_DATA (data, 0));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), \\\n                W[1] = GET_W_FROM_DATA (data, 1));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), \\\n                W[2] = GET_W_FROM_DATA (data, 2));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), \\\n                W[3] = GET_W_FROM_DATA (data, 3));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), \\\n                W[4] = GET_W_FROM_DATA (data, 4));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), \\\n                W[5] = GET_W_FROM_DATA (data, 5));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), \\\n                W[6] = GET_W_FROM_DATA (data, 6));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), \\\n                W[7] = GET_W_FROM_DATA (data, 7));\n    SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), \\\n                W[8] = GET_W_FROM_DATA (data, 8));\n    SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), \\\n                W[9] = GET_W_FROM_DATA (data, 9));\n    SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), \\\n                W[10] = GET_W_FROM_DATA (data, 10));\n    SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), \\\n                W[11] = GET_W_FROM_DATA (data, 11));\n    SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), \\\n                W[12] = GET_W_FROM_DATA (data, 12));\n    SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), \\\n                W[13] = GET_W_FROM_DATA (data, 13));\n    SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), \\\n                W[14] = GET_W_FROM_DATA (data, 14));\n    SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), \\\n                W[15] = GET_W_FROM_DATA (data, 15));\n  }\n\n  /* During last 64 steps, before making any calculations on each step,\n     current W element is generated from other W elements of the cyclic buffer\n     and the generated value is stored back in the cyclic buffer. */\n  /* Note: instead of using K constants as array, all K values are specified\n     individually for each step, see FIPS PUB 180-4 clause 4.2.3 for\n     K values. */\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xe49b69c19ef14ad2), \\\n              W[16 & 15] = Wgen (W,16));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xefbe4786384f25e3), \\\n              W[17 & 15] = Wgen (W,17));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x0fc19dc68b8cd5b5), \\\n              W[18 & 15] = Wgen (W,18));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x240ca1cc77ac9c65), \\\n              W[19 & 15] = Wgen (W,19));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x2de92c6f592b0275), \\\n              W[20 & 15] = Wgen (W,20));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4a7484aa6ea6e483), \\\n              W[21 & 15] = Wgen (W,21));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5cb0a9dcbd41fbd4), \\\n              W[22 & 15] = Wgen (W,22));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x76f988da831153b5), \\\n              W[23 & 15] = Wgen (W,23));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x983e5152ee66dfab), \\\n              W[24 & 15] = Wgen (W,24));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa831c66d2db43210), \\\n              W[25 & 15] = Wgen (W,25));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb00327c898fb213f), \\\n              W[26 & 15] = Wgen (W,26));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xbf597fc7beef0ee4), \\\n              W[27 & 15] = Wgen (W,27));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xc6e00bf33da88fc2), \\\n              W[28 & 15] = Wgen (W,28));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd5a79147930aa725), \\\n              W[29 & 15] = Wgen (W,29));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x06ca6351e003826f), \\\n              W[30 & 15] = Wgen (W,30));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x142929670a0e6e70), \\\n              W[31 & 15] = Wgen (W,31));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x27b70a8546d22ffc), \\\n              W[32 & 15] = Wgen (W,32));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x2e1b21385c26c926), \\\n              W[33 & 15] = Wgen (W,33));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x4d2c6dfc5ac42aed), \\\n              W[34 & 15] = Wgen (W,34));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x53380d139d95b3df), \\\n              W[35 & 15] = Wgen (W,35));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x650a73548baf63de), \\\n              W[36 & 15] = Wgen (W,36));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x766a0abb3c77b2a8), \\\n              W[37 & 15] = Wgen (W,37));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x81c2c92e47edaee6), \\\n              W[38 & 15] = Wgen (W,38));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x92722c851482353b), \\\n              W[39 & 15] = Wgen (W,39));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xa2bfe8a14cf10364), \\\n              W[40 & 15] = Wgen (W,40));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xa81a664bbc423001), \\\n              W[41 & 15] = Wgen (W,41));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xc24b8b70d0f89791), \\\n              W[42 & 15] = Wgen (W,42));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xc76c51a30654be30), \\\n              W[43 & 15] = Wgen (W,43));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0xd192e819d6ef5218), \\\n              W[44 & 15] = Wgen (W,44));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xd69906245565a910), \\\n              W[45 & 15] = Wgen (W,45));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xf40e35855771202a), \\\n              W[46 & 15] = Wgen (W,46));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x106aa07032bbd1b8), \\\n              W[47 & 15] = Wgen (W,47));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x19a4c116b8d2d0c8), \\\n              W[48 & 15] = Wgen (W,48));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x1e376c085141ab53), \\\n              W[49 & 15] = Wgen (W,49));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x2748774cdf8eeb99), \\\n              W[50 & 15] = Wgen (W,50));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x34b0bcb5e19b48a8), \\\n              W[51 & 15] = Wgen (W,51));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x391c0cb3c5c95a63), \\\n              W[52 & 15] = Wgen (W,52));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x4ed8aa4ae3418acb), \\\n              W[53 & 15] = Wgen (W,53));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5b9cca4f7763e373), \\\n              W[54 & 15] = Wgen (W,54));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x682e6ff3d6b2b8a3), \\\n              W[55 & 15] = Wgen (W,55));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x748f82ee5defb2fc), \\\n              W[56 & 15] = Wgen (W,56));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x78a5636f43172f60), \\\n              W[57 & 15] = Wgen (W,57));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x84c87814a1f0ab72), \\\n              W[58 & 15] = Wgen (W,58));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x8cc702081a6439ec), \\\n              W[59 & 15] = Wgen (W,59));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x90befffa23631e28), \\\n              W[60 & 15] = Wgen (W,60));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0xa4506cebde82bde9), \\\n              W[61 & 15] = Wgen (W,61));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0xbef9a3f7b2c67915), \\\n              W[62 & 15] = Wgen (W,62));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc67178f2e372532b), \\\n              W[63 & 15] = Wgen (W,63));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xca273eceea26619c), \\\n              W[64 & 15] = Wgen (W,64));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0xd186b8c721c0c207), \\\n              W[65 & 15] = Wgen (W,65));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xeada7dd6cde0eb1e), \\\n              W[66 & 15] = Wgen (W,66));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xf57d4f7fee6ed178), \\\n              W[67 & 15] = Wgen (W,67));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x06f067aa72176fba), \\\n              W[68 & 15] = Wgen (W,68));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x0a637dc5a2c898a6), \\\n              W[69 & 15] = Wgen (W,69));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x113f9804bef90dae), \\\n              W[70 & 15] = Wgen (W,70));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x1b710b35131c471b), \\\n              W[71 & 15] = Wgen (W,71));\n  SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x28db77f523047d84), \\\n              W[72 & 15] = Wgen (W,72));\n  SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x32caab7b40c72493), \\\n              W[73 & 15] = Wgen (W,73));\n  SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x3c9ebe0a15c9bebc), \\\n              W[74 & 15] = Wgen (W,74));\n  SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x431d67c49c100d4c), \\\n              W[75 & 15] = Wgen (W,75));\n  SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x4cc5d4becb3e42b6), \\\n              W[76 & 15] = Wgen (W,76));\n  SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x597f299cfc657e2a), \\\n              W[77 & 15] = Wgen (W,77));\n  SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x5fcb6fab3ad6faec), \\\n              W[78 & 15] = Wgen (W,78));\n  SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0x6c44198c4a475817), \\\n              W[79 & 15] = Wgen (W,79));\n#else  /* MHD_FAVOR_SMALL_CODE */\n  if (1)\n  {\n    unsigned int t;\n    /* K constants array.\n       See FIPS PUB 180-4 clause 4.2.3 for K values. */\n    static const uint64_t K[80] =\n    { UINT64_C (0x428a2f98d728ae22), UINT64_C (0x7137449123ef65cd),\n      UINT64_C (0xb5c0fbcfec4d3b2f), UINT64_C (0xe9b5dba58189dbbc),\n      UINT64_C (0x3956c25bf348b538), UINT64_C (0x59f111f1b605d019),\n      UINT64_C (0x923f82a4af194f9b), UINT64_C (0xab1c5ed5da6d8118),\n      UINT64_C (0xd807aa98a3030242), UINT64_C (0x12835b0145706fbe),\n      UINT64_C (0x243185be4ee4b28c), UINT64_C (0x550c7dc3d5ffb4e2),\n      UINT64_C (0x72be5d74f27b896f), UINT64_C (0x80deb1fe3b1696b1),\n      UINT64_C (0x9bdc06a725c71235), UINT64_C (0xc19bf174cf692694),\n      UINT64_C (0xe49b69c19ef14ad2), UINT64_C (0xefbe4786384f25e3),\n      UINT64_C (0x0fc19dc68b8cd5b5), UINT64_C (0x240ca1cc77ac9c65),\n      UINT64_C (0x2de92c6f592b0275), UINT64_C (0x4a7484aa6ea6e483),\n      UINT64_C (0x5cb0a9dcbd41fbd4), UINT64_C (0x76f988da831153b5),\n      UINT64_C (0x983e5152ee66dfab), UINT64_C (0xa831c66d2db43210),\n      UINT64_C (0xb00327c898fb213f), UINT64_C (0xbf597fc7beef0ee4),\n      UINT64_C (0xc6e00bf33da88fc2), UINT64_C (0xd5a79147930aa725),\n      UINT64_C (0x06ca6351e003826f), UINT64_C (0x142929670a0e6e70),\n      UINT64_C (0x27b70a8546d22ffc), UINT64_C (0x2e1b21385c26c926),\n      UINT64_C (0x4d2c6dfc5ac42aed), UINT64_C (0x53380d139d95b3df),\n      UINT64_C (0x650a73548baf63de), UINT64_C (0x766a0abb3c77b2a8),\n      UINT64_C (0x81c2c92e47edaee6), UINT64_C (0x92722c851482353b),\n      UINT64_C (0xa2bfe8a14cf10364), UINT64_C (0xa81a664bbc423001),\n      UINT64_C (0xc24b8b70d0f89791), UINT64_C (0xc76c51a30654be30),\n      UINT64_C (0xd192e819d6ef5218), UINT64_C (0xd69906245565a910),\n      UINT64_C (0xf40e35855771202a), UINT64_C (0x106aa07032bbd1b8),\n      UINT64_C (0x19a4c116b8d2d0c8), UINT64_C (0x1e376c085141ab53),\n      UINT64_C (0x2748774cdf8eeb99), UINT64_C (0x34b0bcb5e19b48a8),\n      UINT64_C (0x391c0cb3c5c95a63), UINT64_C (0x4ed8aa4ae3418acb),\n      UINT64_C (0x5b9cca4f7763e373), UINT64_C (0x682e6ff3d6b2b8a3),\n      UINT64_C (0x748f82ee5defb2fc), UINT64_C (0x78a5636f43172f60),\n      UINT64_C (0x84c87814a1f0ab72), UINT64_C (0x8cc702081a6439ec),\n      UINT64_C (0x90befffa23631e28), UINT64_C (0xa4506cebde82bde9),\n      UINT64_C (0xbef9a3f7b2c67915), UINT64_C (0xc67178f2e372532b),\n      UINT64_C (0xca273eceea26619c), UINT64_C (0xd186b8c721c0c207),\n      UINT64_C (0xeada7dd6cde0eb1e), UINT64_C (0xf57d4f7fee6ed178),\n      UINT64_C (0x06f067aa72176fba), UINT64_C (0x0a637dc5a2c898a6),\n      UINT64_C (0x113f9804bef90dae), UINT64_C (0x1b710b35131c471b),\n      UINT64_C (0x28db77f523047d84), UINT64_C (0x32caab7b40c72493),\n      UINT64_C (0x3c9ebe0a15c9bebc), UINT64_C (0x431d67c49c100d4c),\n      UINT64_C (0x4cc5d4becb3e42b6), UINT64_C (0x597f299cfc657e2a),\n      UINT64_C (0x5fcb6fab3ad6faec), UINT64_C (0x6c44198c4a475817)};\n\n    /* One step of SHA-512/256 computation with working variables rotation,\n       see FIPS PUB 180-4 clause 6.4.2 step 3.\n     * Note: this version of macro reassign all working variable on\n             each step. */\n#define SHA2STEP64RV(vA,vB,vC,vD,vE,vF,vG,vH,kt,wt) do {              \\\n  uint64_t tmp_h_ = (vH);                                             \\\n  SHA2STEP64((vA),(vB),(vC),(vD),(vE),(vF),(vG),tmp_h_,(kt),(wt));    \\\n  (vH) = (vG);                                                        \\\n  (vG) = (vF);                                                        \\\n  (vF) = (vE);                                                        \\\n  (vE) = (vD);                                                        \\\n  (vD) = (vC);                                                        \\\n  (vC) = (vB);                                                        \\\n  (vB) = (vA);                                                        \\\n  (vA) = tmp_h_;  } while (0)\n\n    /* During first 16 steps, before making any calculations on each step,\n       the W element is read from the input data buffer as big-endian value and\n       stored in the array of W elements. */\n    for (t = 0; t < 16; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t] = GET_W_FROM_DATA (data, t));\n    }\n    /* During last 64 steps, before making any calculations on each step,\n       current W element is generated from other W elements of the cyclic buffer\n       and the generated value is stored back in the cyclic buffer. */\n    for (t = 16; t < 80; ++t)\n    {\n      SHA2STEP64RV (a, b, c, d, e, f, g, h, K[t], \\\n                    W[t & 15] = Wgen (W,t));\n    }\n  }\n#endif /* MHD_FAVOR_SMALL_CODE */\n\n  /* Compute and store the intermediate hash.\n     See FIPS PUB 180-4 clause 6.4.2 step 4. */\n  H[0] += a;\n  H[1] += b;\n  H[2] += c;\n  H[3] += d;\n  H[4] += e;\n  H[5] += f;\n  H[6] += g;\n  H[7] += h;\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function sha512_256_transform:\nvoid\nMHD_SHA512_256_update (struct Sha512_256Ctx *ctx,\n                       const uint8_t *data,\n                       size_t length)\n{\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n  uint64_t count_hi; /**< The high part to be moved to another variable */\n\n  mhd_assert ((data != NULL) || (length == 0));\n\n#ifndef MHD_FAVOR_SMALL_CODE\n  if (0 == length)\n    return; /* Shortcut, do nothing */\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n  ctx->count += length;\n#if SIZEOF_SIZE_T > 7\n  if (length > ctx->count)\n    ctx->count_bits_hi += 1U << 3; /* Value wrap */\n#endif /* SIZEOF_SIZE_T > 7 */\n  count_hi = ctx->count >> 61;\n  if (0 != count_hi)\n  {\n    ctx->count_bits_hi += count_hi;\n    ctx->count &= UINT64_C (0x1FFFFFFFFFFFFFFF);\n  }\n\n  if (0 != bytes_have)\n  {\n    unsigned int bytes_left = SHA512_256_BLOCK_SIZE - bytes_have;\n    if (length >= bytes_left)\n    {     /* Combine new data with data in the buffer and\n             process the full block. */\n      memcpy (((uint8_t *) ctx->buffer) + bytes_have,\n              data,\n              bytes_left);\n      data += bytes_left;\n      length -= bytes_left;\n      sha512_256_transform (ctx->H, ctx->buffer);\n      bytes_have = 0;\n    }\n  }\n\n  while (SHA512_256_BLOCK_SIZE <= length)\n  {   /* Process any full blocks of new data directly,\n         without copying to the buffer. */\n    sha512_256_transform (ctx->H, data);\n    data += SHA512_256_BLOCK_SIZE;\n    length -= SHA512_256_BLOCK_SIZE;\n  }\n\n  if (0 != length)\n  {   /* Copy incomplete block of new data (if any)\n         to the buffer. */\n    memcpy (((uint8_t *) ctx->buffer) + bytes_have, data, length);\n  }\n}\n...\nvoid\nMHD_SHA512_256_finish (struct Sha512_256Ctx *ctx,\n                       uint8_t digest[SHA512_256_DIGEST_SIZE])\n{\n  uint64_t num_bits;   /**< Number of processed bits */\n  unsigned int bytes_have; /**< Number of bytes in the context buffer */\n\n  /* Memorise the number of processed bits.\n     The padding and other data added here during the postprocessing must\n     not change the amount of hashed data. */\n  num_bits = ctx->count << 3;\n\n  /* Note: (count & (SHA512_256_BLOCK_SIZE-1))\n           equals (count % SHA512_256_BLOCK_SIZE) for this block size. */\n  bytes_have = (unsigned int) (ctx->count & (SHA512_256_BLOCK_SIZE - 1));\n\n  /* Input data must be padded with a single bit \"1\", then with zeros and\n     the finally the length of data in bits must be added as the final bytes\n     of the last block.\n     See FIPS PUB 180-4 clause 5.1.2. */\n\n  /* Data is always processed in form of bytes (not by individual bits),\n     therefore position of the first padding bit in byte is always\n     predefined (0x80). */\n  /* Buffer always have space for one byte at least (as full buffers are\n     processed immediately). */\n  ((uint8_t *) ctx->buffer)[bytes_have++] = 0x80;\n\n  if (SHA512_256_BLOCK_SIZE - bytes_have < SHA512_256_SIZE_OF_LEN_ADD)\n  {   /* No space in the current block to put the total length of message.\n         Pad the current block with zeros and process it. */\n    if (bytes_have < SHA512_256_BLOCK_SIZE)\n      memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n              SHA512_256_BLOCK_SIZE - bytes_have);\n    /* Process the full block. */\n    sha512_256_transform (ctx->H, ctx->buffer);\n    /* Start the new block. */\n    bytes_have = 0;\n  }\n\n  /* Pad the rest of the buffer with zeros. */\n  memset (((uint8_t *) ctx->buffer) + bytes_have, 0,\n          SHA512_256_BLOCK_SIZE - SHA512_256_SIZE_OF_LEN_ADD - bytes_have);\n  /* Put high part of number of bits in processed message and then lower\n     part of number of bits as big-endian values.\n     See FIPS PUB 180-4 clause 5.1.2. */\n  /* Note: the target location is predefined and buffer is always aligned */\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 2,\n                     ctx->count_bits_hi);\n  _MHD_PUT_64BIT_BE (ctx->buffer + SHA512_256_BLOCK_SIZE_WORDS - 1,\n                     num_bits);\n  /* Process the full final block. */\n  sha512_256_transform (ctx->H, ctx->buffer);\n\n  /* Put in BE mode the leftmost part of the hash as the final digest.\n     See FIPS PUB 180-4 clause 6.7. */\n#ifndef _MHD_PUT_64BIT_BE_UNALIGNED\n  if (1\n#ifndef MHD_FAVOR_SMALL_CODE\n      && (0 != ((uintptr_t) digest) % _MHD_UINT64_ALIGN)\n#endif /* MHD_FAVOR_SMALL_CODE */\n      )\n  {\n    /* If storing of the final result requires aligned address and\n       the destination address is not aligned or compact code is used,\n       store the final digest in aligned temporary buffer first, then\n       copy it to the destination. */\n    uint64_t alig_dgst[SHA512_256_DIGEST_SIZE_WORDS];\n    _MHD_PUT_64BIT_BE (alig_dgst + 0, ctx->H[0]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 1, ctx->H[1]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 2, ctx->H[2]);\n    _MHD_PUT_64BIT_BE (alig_dgst + 3, ctx->H[3]);\n    /* Copy result to the unaligned destination address */\n    memcpy (digest, alig_dgst, SHA512_256_DIGEST_SIZE);\n  }\n#ifndef MHD_FAVOR_SMALL_CODE\n  else /* Combined with the next 'if' */\n#endif /* MHD_FAVOR_SMALL_CODE */\n#endif /* ! _MHD_PUT_64BIT_BE_UNALIGNED */\n#if ! defined(MHD_FAVOR_SMALL_CODE) || defined(_MHD_PUT_64BIT_BE_UNALIGNED)\n  if (1)\n  {\n    /* Use cast to (void*) here to mute compiler alignment warnings.\n     * Compilers are not smart enough to see that alignment has been checked. */\n    _MHD_PUT_64BIT_BE ((void *) (digest + 0 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[0]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 1 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[1]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 2 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[2]);\n    _MHD_PUT_64BIT_BE ((void *) (digest + 3 * SHA512_256_BYTES_IN_WORD), \\\n                       ctx->H[3]);\n  }\n#endif /* ! MHD_FAVOR_SMALL_CODE || _MHD_PUT_64BIT_BE_UNALIGNED */\n\n  /* Erase potentially sensitive data. */\n  memset (ctx, 0, sizeof(struct Sha512_256Ctx));\n}\n...\n_MHD_static_inline void\ndigest_update (struct DigestAlgorithm *da,\n               const void *data,\n               size_t length)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n    MHD_MD5_update (&da->ctx.md5_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n    MHD_SHA256_update (&da->ctx.sha256_ctx, (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n    MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* May not happen */\n#ifdef _DEBUG\n  da->hashing = true;\n#endif\n}\n...\n_MHD_static_inline void\ndigest_calc_hash (struct DigestAlgorithm *da, uint8_t *digest)\n{\n  mhd_assert (! da->uninitialised);\n  mhd_assert (da->algo_selected);\n  mhd_assert (da->ready_for_hashing);\n#ifdef MHD_MD5_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_MD5 == da->algo)\n  {\n#ifdef MHD_MD5_HAS_FINISH\n    MHD_MD5_finish (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_MD5_HAS_FINISH */\n    MHD_MD5_finish_reset (&da->ctx.md5_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_MD5_HAS_FINISH */\n  }\n  else\n#endif /* MHD_MD5_SUPPORT */\n#ifdef MHD_SHA256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA256 == da->algo)\n  {\n#ifdef MHD_SHA256_HAS_FINISH\n    MHD_SHA256_finish (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n#else  /* ! MHD_SHA256_HAS_FINISH */\n    MHD_SHA256_finish_reset (&da->ctx.sha256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = true;\n#endif /* _DEBUG */\n#endif /* ! MHD_SHA256_HAS_FINISH */\n  }\n  else\n#endif /* MHD_SHA256_SUPPORT */\n#ifdef MHD_SHA512_256_SUPPORT\n  if (MHD_DIGEST_BASE_ALGO_SHA512_256 == da->algo)\n  {\n    MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);\n#ifdef _DEBUG\n    da->ready_for_hashing = false;\n#endif /* _DEBUG */\n  }\n  else\n#endif /* MHD_SHA512_256_SUPPORT */\n  mhd_assert (0);   /* Should not happen */\n#ifdef _DEBUG\n  da->hashing = false;\n#endif /* _DEBUG */\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0x428a2f98d728ae22), \\\n                W[0] = GET_W_FROM_DATA (data, 0));",
    "memcpy (W, data, sizeof(W));",
    "SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x7137449123ef65cd), \\\n                W[1] = GET_W_FROM_DATA (data, 1));",
    "MHD_SHA512_256_update (&da->ctx.sha512_256_ctx,\n                           (const uint8_t *) data, length);",
    "SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0x243185be4ee4b28c), \\\n                W[10] = GET_W_FROM_DATA (data, 10));",
    "SHA2STEP64 (h, a, b, c, d, e, f, g, UINT64_C (0x12835b0145706fbe), \\\n                W[9] = GET_W_FROM_DATA (data, 9));",
    "sha512_256_transform (ctx->H, data);",
    "SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x59f111f1b605d019), \\\n                W[5] = GET_W_FROM_DATA (data, 5));",
    "SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0x550c7dc3d5ffb4e2), \\\n                W[11] = GET_W_FROM_DATA (data, 11));",
    "SHA2STEP64 (a, b, c, d, e, f, g, h, UINT64_C (0xd807aa98a3030242), \\\n                W[8] = GET_W_FROM_DATA (data, 8));",
    "SHA2STEP64 (f, g, h, a, b, c, d, e, UINT64_C (0xe9b5dba58189dbbc), \\\n                W[3] = GET_W_FROM_DATA (data, 3));",
    "SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xc19bf174cf692694), \\\n                W[15] = GET_W_FROM_DATA (data, 15));",
    "SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x9bdc06a725c71235), \\\n                W[14] = GET_W_FROM_DATA (data, 14));",
    "SHA2STEP64 (g, h, a, b, c, d, e, f, UINT64_C (0xb5c0fbcfec4d3b2f), \\\n                W[2] = GET_W_FROM_DATA (data, 2));",
    "SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x3956c25bf348b538), \\\n                W[4] = GET_W_FROM_DATA (data, 4));",
    "MHD_SHA512_256_finish (&da->ctx.sha512_256_ctx, digest);",
    "#define GET_W_FROM_DATA(buf,t) \\\n  _MHD_GET_64BIT_BE (((const uint64_t*) (buf)) + (t))",
    "SHA2STEP64 (c, d, e, f, g, h, a, b, UINT64_C (0x923f82a4af194f9b), \\\n                W[6] = GET_W_FROM_DATA (data, 6));",
    "SHA2STEP64 (d, e, f, g, h, a, b, c, UINT64_C (0x80deb1fe3b1696b1), \\\n                W[13] = GET_W_FROM_DATA (data, 13));",
    "sha512_256_transform (ctx->H, ctx->buffer);",
    "SHA2STEP64 (b, c, d, e, f, g, h, a, UINT64_C (0xab1c5ed5da6d8118), \\\n                W[7] = GET_W_FROM_DATA (data, 7));",
    "SHA2STEP64 (e, f, g, h, a, b, c, d, UINT64_C (0x72be5d74f27b896f), \\\n                W[12] = GET_W_FROM_DATA (data, 12));"
  ],
  "explanation": "I have reported all sites that either directly call sha512_256_transform (the calls in MHD_SHA512_256_update and MHD_SHA512_256_finish) and the higher-level wrapper calls that invoke those (digest_update and digest_calc_hash), so the call graph leading to sha512_256_transform can be inspected for possible indirect recursion. Inside sha512_256_transform I reported the memcpy of unaligned input and every use of GET_W_FROM_DATA (which expands to _MHD_GET_64BIT_BE) because those macro invocations could expand to or call functions outside the visible code and so merit inspection for potential back-calls. Other code fragments were not reported because: (1) The bulk of the SHA step macros (Ch, Maj, SIG0, SIG1, sig0, sig1, Wgen, SHA2STEP64, SHA2STEP64RV) are macro expansions performing local computations and rotations only; they do not contain function calls that could introduce recursion. (2) Standard library or obvious utility calls shown (e.g. memcpy used elsewhere for copying the final digest, _MHD_PUT_64BIT_BE in finish) are typical data movement helpers and, based on the provided code, do not call back into the SHA update/transform functions. (3) There are no function pointers or callbacks visible in the provided code that would create an indirect call path to sha512_256_transform beyond the listed call sites. Therefore the listed fragments are the meaningful places to investigate for compliance with Rule 17.2; other snippets in the provided code do not show function-call behavior that could create direct or indirect self-calls to sha512_256_transform."
}