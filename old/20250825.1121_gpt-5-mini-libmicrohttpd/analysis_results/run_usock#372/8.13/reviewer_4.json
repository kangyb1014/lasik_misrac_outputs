{
  "user_message": "An agent A claimed that the following run_usock code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of run_usock.\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct MyData *md = cls;\n  struct MHD_UpgradeResponseHandle *urh = md->urh;\n  char buf[128];\n  ssize_t got;\n\n  make_blocking (md->sock);\n  /* start by sending extra data MHD may have already read, if any */\n  if (0 != md->extra_in_size)\n  {\n    send_all (md->sock,\n              md->extra_in,\n              md->extra_in_size);\n    free (md->extra_in);\n  }\n  /* now echo in a loop */\n  while (1)\n  {\n    got = recv (md->sock,\n                buf,\n                sizeof (buf),\n                0);\n    if (0 >= got)\n      break;\n    send_all (md->sock,\n              buf,\n              (size_t) got);\n  }\n  free (md);\n  MHD_upgrade_action (urh,\n                      MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe pointer extra_in is declared as 'char *extra_in' but in run_usock it is only used as a read-only buffer (passed to send_all and then freed); its pointee is not modified through this pointer. According to MISRA C 2023 Rule 8.13, this should be a pointer to a const-qualified type (e.g. 'const char *extra_in') where possible. Therefore the current declaration violates the rule. Note: changing to 'const char *' would require handling the subsequent free() (which expects void *) appropriately (e.g. maintain a non-const owning pointer or cast explicitly at the free site), to preserve correct ownership semantics without discarding qualifiers elsewhere.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function run_usock:\nstruct MyData\n{\n  struct MHD_UpgradeResponseHandle *urh;\n  char *extra_in;\n  size_t extra_in_size;\n  MHD_socket sock;\n}\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct given the code shown. The struct member extra_in is declared as char * but in run_usock it is only read (passed to send_all) and then freed; it is not used to modify the pointee. MISRA C 2023 Rule 8.13 recommends that pointers should point to a const-qualified type whenever possible, so extra_in could (and should) be declared const char * if no other code modifies the pointee. Note the usual practical implications: changing the declaration to const char * means free() cannot be called with that pointer without discarding qualifiers (so you would preserve ownership with a non-const owning pointer or use an explicit cast at the free site). If, elsewhere in the translation unit or program, the pointee is modified via that member, then it cannot be made const; you must examine all uses to be certain. Based on the provided code, the agent A\u2019s assertion of a Rule 8.13 violation is correct."
}