{
  "user_message": "Target function code is:\n```c\nstatic void *\nrun_usock (void *cls)\n{\n  struct MyData *md = cls;\n  struct MHD_UpgradeResponseHandle *urh = md->urh;\n  char buf[128];\n  ssize_t got;\n\n  make_blocking (md->sock);\n  /* start by sending extra data MHD may have already read, if any */\n  if (0 != md->extra_in_size)\n  {\n    send_all (md->sock,\n              md->extra_in,\n              md->extra_in_size);\n    free (md->extra_in);\n  }\n  /* now echo in a loop */\n  while (1)\n  {\n    got = recv (md->sock,\n                buf,\n                sizeof (buf),\n                0);\n    if (0 >= got)\n      break;\n    send_all (md->sock,\n              buf,\n              (size_t) got);\n  }\n  free (md);\n  MHD_upgrade_action (urh,\n                      MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'run_usock': {'callees': ['make_blocking', 'send_all', 'MHD_upgrade_action', 'ws_receive_frame', 'ws_send_frame'], 'callers': []}, 'make_blocking': {'callees': [], 'callers': ['send_all', 'run_usock']}, 'send_all': {'callees': ['make_blocking'], 'callers': ['run_usock', 'ws_send_frame']}, 'MHD_upgrade_action': {'callees': ['MHD_upgraded_connection_mark_app_closed_'], 'callers': ['run_usock', 'uh_cb']}, 'ws_receive_frame': {'callees': [], 'callers': ['run_usock']}, 'ws_send_frame': {'callees': ['send_all'], 'callers': ['run_usock']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA function parameter should not be modified. Note that the object referred to by a pointer parameter may be modified, but the pointer itself shall not be modified.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MyData",
    "make_blocking (declaration/definition)",
    "send_all (declaration/definition)",
    "MHD_upgrade_action (declaration/definition)",
    "struct MHD_UpgradeResponseHandle",
    "MHD_UPGRADE_ACTION_CLOSE (macro/enum)",
    "ws_receive_frame (declaration/definition)",
    "ws_send_frame (declaration/definition)",
    "free (stdlib prototype)",
    "recv (socket prototype)"
  ],
  "explanation": "Explain why each symbol is required for checking the MISRA rule (a function parameter shall not be modified):\n\n- struct MyData\n  - Needed to know the exact type of 'md' (the object derived from the parameter 'cls'), the types of its fields (sock, extra_in, extra_in_size, urh) and whether any of those field accesses could be implemented via macros or non-standard constructs that might write back to the original parameter object or its address. Also to confirm that assigning 'md = cls' is just a local pointer copy, and to reason about the effect of free(md) on the object referred to by the parameter.\n\n- make_blocking (declaration/definition)\n  - The body or macro form is required to ensure it does not expand to or call code that writes to the run_usock formal parameter 'cls' (for example, via some hidden/inline reference). Even though run_usock passes md->sock (not cls), a macro or inline could capture outer names; the prototype/definition rules out such surprises.\n\n- send_all (declaration/definition)\n  - send_all is called repeatedly with buffers derived from md; its implementation or macro form must be inspected to ensure it does not (directly or indirectly) modify the run_usock formal parameter variable 'cls' (for example, by accessing a global or via unexpected macro expansion). Also to check it does not take pointer-to-pointer parameters that could have been passed the address of the parameter (not the case here, but verify).\n\n- MHD_upgrade_action (declaration/definition)\n  - Needed to ensure this symbol (or any macro/inline implementing it) does not modify the run_usock parameter variable 'cls' (for example, via closure over local names if implemented as a macro), and to check whether calling it after free(md) has any interaction with the freed object that could be construed as modifying the original parameter.\n\n- struct MHD_UpgradeResponseHandle\n  - Type of 'urh' (taken from md->urh). Knowing its type ensures MHD_upgrade_action is being passed an appropriate handle and helps confirm there is no aliasing back to 'cls' that could allow modification of the formal parameter.\n\n- MHD_UPGRADE_ACTION_CLOSE (macro/enum)\n  - The constant passed to MHD_upgrade_action could be a macro with side-effects; its definition should be checked to ensure it does not expand to code that touches the run_usock parameter variable.\n\n- ws_receive_frame (declaration/definition)\n  - Present in the static call graph: include its definition to confirm whether run_usock in the real project actually invokes it (or if macros/inline code bring it in) and to ensure it cannot modify run_usock's formal parameter (by indirect/macro means).\n\n- ws_send_frame (declaration/definition)\n  - Same rationale as ws_receive_frame; also it calls send_all (per graph) so its implementation could contain macros or inlines that reference outer names \u2014 verify it cannot alter the formal parameter.\n\n- free (stdlib prototype)\n  - To confirm the semantics of free(void*) and that calling free(md) frees the object referred to by the parameter but does not modify the formal parameter variable 'cls' itself. Also to reason whether freeing the memory could be considered a forbidden modification of the object (the MISRA rule allows modification of the object pointed to, but this must be confirmed in context).\n\n- recv (socket prototype)\n  - To confirm the prototype and make sure recv is not a macro with side-effects that could reference or modify the run_usock parameter variable. Also to verify correct use of types and that passing buf/md->sock cannot indirectly mutate the formal parameter.\n\n(Concise rationale: MISRA\u2019s rule targets modification of the formal parameter variable itself. To be certain run_usock does not violate it you must inspect all types and callees/macros/inlines used inside run_usock to rule out any code expansion or indirect access that would write to the formal parameter 'cls'. The above symbols cover the local type and all callees/macros that could plausibly affect 'cls'.)"
}