{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_hdr_and_body_ (struct MHD_Connection *connection,\n                        const char *header,\n                        size_t header_size,\n                        bool never_push_hdr,\n                        const char *body,\n                        size_t body_size,\n                        bool complete_response)\n{\n  ssize_t ret;\n  bool push_hdr;\n  bool push_body;\n  MHD_socket s = connection->socket_fd;\n#ifndef _WIN32\n#define _MHD_SEND_VEC_MAX   MHD_SCKT_SEND_MAX_SIZE_\n#else  /* ! _WIN32 */\n#define _MHD_SEND_VEC_MAX   UINT32_MAX\n#endif /* ! _WIN32 */\n#ifdef MHD_VECT_SEND\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  struct iovec vector[2];\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#endif /* HAVE_SENDMSG */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  WSABUF vector[2];\n  DWORD vec_sent;\n#endif /* _WIN32 */\n  bool no_vec; /* Is vector-send() disallowed? */\n\n  no_vec = false;\n#ifdef HTTPS_SUPPORT\n  no_vec = no_vec || (connection->daemon->options & MHD_USE_TLS);\n#endif /* HTTPS_SUPPORT */\n#if (! defined(HAVE_SENDMSG) || ! defined(MSG_NOSIGNAL) ) && \\\n  defined(MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE) && \\\n  defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n  no_vec = no_vec || (! connection->daemon->sigpipe_blocked &&\n                      ! connection->sk_spipe_suppress);\n#endif /* (!HAVE_SENDMSG || ! MSG_NOSIGNAL) &&\n          MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE &&\n          MHD_SEND_SPIPE_SUPPRESS_NEEDED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert ( (NULL != body) || (0 == body_size) );\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  push_body = complete_response;\n\n  if (! never_push_hdr)\n  {\n    if (! complete_response)\n      push_hdr = true; /* Push the header as the client may react\n                        * on header alone while the body data is\n                        * being prepared. */\n    else\n    {\n      if (1400 > (header_size + body_size))\n        push_hdr = false;  /* Do not push the header as complete\n                           * reply is already ready and the whole\n                           * reply most probably will fit into\n                           * the single IP packet. */\n      else\n        push_hdr = true;   /* Push header alone so client may react\n                           * on it while reply body is being delivered. */\n    }\n  }\n  else\n    push_hdr = false;\n\n  if (complete_response && (0 == body_size))\n    push_hdr = true; /* The header alone is equal to the whole response. */\n\n  if (\n#ifdef MHD_VECT_SEND\n    (no_vec) ||\n    (0 == body_size) ||\n    ((size_t) SSIZE_MAX <= header_size) ||\n    ((size_t) _MHD_SEND_VEC_MAX < header_size)\n#ifdef _WIN32\n    || ((size_t) UINT_MAX < header_size)\n#endif /* _WIN32 */\n#else  /* ! MHD_VECT_SEND */\n    true\n#endif /* ! MHD_VECT_SEND */\n    )\n  {\n    ret = MHD_send_data_ (connection,\n                          header,\n                          header_size,\n                          push_hdr);\n\n    if ( (header_size == (size_t) ret) &&\n         ((size_t) SSIZE_MAX > header_size) &&\n         (0 != body_size) &&\n         (connection->sk_nonblck) )\n    {\n      ssize_t ret2;\n      /* The header has been sent completely.\n       * Try to send the reply body without waiting for\n       * the next round. */\n      /* Make sure that sum of ret + ret2 will not exceed SSIZE_MAX as\n       * function needs to return positive value if succeed. */\n      if ( (((size_t) SSIZE_MAX) - ((size_t) ret)) <  body_size)\n      {\n        body_size = (((size_t) SSIZE_MAX) - ((size_t) ret));\n        complete_response = false;\n        push_body = complete_response;\n      }\n\n      ret2 = MHD_send_data_ (connection,\n                             body,\n                             body_size,\n                             push_body);\n      if (0 < ret2)\n        return ret + ret2; /* Total data sent */\n      if (MHD_ERR_AGAIN_ == ret2)\n        return ret;\n\n      return ret2; /* Error code */\n    }\n    return ret;\n  }\n#ifdef MHD_VECT_SEND\n\n  if ( ((size_t) SSIZE_MAX <= body_size) ||\n       ((size_t) SSIZE_MAX < (header_size + body_size)) )\n  {\n    /* Return value limit */\n    body_size = SSIZE_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#if (SSIZE_MAX != _MHD_SEND_VEC_MAX) || (_MHD_SEND_VEC_MAX + 0 == 0)\n  if (((size_t) _MHD_SEND_VEC_MAX <= body_size) ||\n      ((size_t) _MHD_SEND_VEC_MAX < (header_size + body_size)))\n  {\n    /* Send total amount limit */\n    body_size = _MHD_SEND_VEC_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#endif /* SSIZE_MAX != _MHD_SEND_VEC_MAX */\n\n  pre_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                   true,\n#else  /* ! HAVE_SENDMSG */\n                   false,\n#endif /* ! HAVE_SENDMSG */\n                   push_hdr || push_body);\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  vector[0].iov_base = _MHD_DROP_CONST (header);\n  vector[0].iov_len = header_size;\n  vector[1].iov_base = _MHD_DROP_CONST (body);\n  vector[1].iov_len = body_size;\n\n#if defined(HAVE_SENDMSG)\n  memset (&msg, 0, sizeof(msg));\n  msg.msg_iov = vector;\n  msg.msg_iovlen = 2;\n\n  ret = sendmsg (s, &msg, MSG_NOSIGNAL_OR_ZERO);\n#elif defined(HAVE_WRITEV)\n  ret = writev (s, vector, 2);\n#endif /* HAVE_WRITEV */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  if ((size_t) UINT_MAX < body_size)\n  {\n    /* Send item size limit */\n    body_size = UINT_MAX;\n    complete_response = false;\n    push_body = complete_response;\n  }\n  vector[0].buf = (char *) _MHD_DROP_CONST (header);\n  vector[0].len = (unsigned long) header_size;\n  vector[1].buf = (char *) _MHD_DROP_CONST (body);\n  vector[1].len = (unsigned long) body_size;\n\n  ret = WSASend (s, vector, 2, &vec_sent, 0, NULL, NULL);\n  if (0 == ret)\n    ret = (ssize_t) vec_sent;\n  else\n    ret = -1;\n#endif /* _WIN32 */\n\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN, no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n#ifdef EPOLL_SUPPORT\n  else if ((header_size + body_size) > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  if ( (push_body) &&\n       ((header_size + body_size) == (size_t) ret) )\n  {\n    /* Complete reply has been sent. */\n    /* If TLS connection is used then next final send() will be\n     * without MSG_MORE support. If non-TLS connection is used\n     * it's unknown whether next 'send' will be plain send() / sendmsg() or\n     * sendfile() will be used so assume that next final send() will be\n     * the same, like for this response. */\n    post_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                      true,\n#else  /* ! HAVE_SENDMSG */\n                      false,\n#endif /* ! HAVE_SENDMSG */\n                      true);\n  }\n  else if ( (push_hdr) &&\n            (header_size <= (size_t) ret))\n  {\n    /* The header has been sent completely and there is a\n     * need to push the header data. */\n    /* Luckily the type of send function will be used next is known. */\n    post_send_setopt (connection,\n#if defined(_MHD_HAVE_SENDFILE)\n                      MHD_resp_sender_std == connection->rp.resp_sender,\n#else  /* ! _MHD_HAVE_SENDFILE */\n                      true,\n#endif /* ! _MHD_HAVE_SENDFILE */\n                      true);\n  }\n\n  return ret;\n#else  /* ! MHD_VECT_SEND */\n  mhd_assert (false);\n  return MHD_ERR_CONNRESET_; /* Unreachable. Mute warnings. */\n#endif /* ! MHD_VECT_SEND */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_socket",
    "MHD_INVALID_SOCKET",
    "connection->state",
    "MHD_CONNECTION_CLOSED",
    "mhd_assert",
    "_MHD_SEND_VEC_MAX",
    "MHD_SCKT_SEND_MAX_SIZE_",
    "MHD_VECT_SEND",
    "HAVE_SENDMSG",
    "HAVE_WRITEV",
    "MSG_NOSIGNAL_OR_ZERO",
    "_MHD_DROP_CONST",
    "SSIZE_MAX",
    "UINT_MAX",
    "UINT32_MAX",
    "_WIN32",
    "WSABUF",
    "WSASend",
    "sendmsg",
    "writev",
    "pre_send_setopt",
    "post_send_setopt",
    "HTTPS_SUPPORT",
    "MHD_USE_TLS",
    "MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE",
    "MHD_SEND_SPIPE_SUPPRESS_NEEDED",
    "connection->daemon (options, sigpipe_blocked)",
    "connection->sk_spipe_suppress",
    "connection->sk_nonblck",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_EBADF_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_BADF_",
    "EPOLL_SUPPORT",
    "connection->epoll_state",
    "MHD_EPOLL_STATE_WRITE_READY",
    "_MHD_HAVE_SENDFILE",
    "MHD_resp_sender_std",
    "connection->rp.resp_sender",
    "MSG_NOSIGNAL"
  ],
  "explanation": "To determine whether MHD_send_hdr_and_body_ uses any compiler language extensions you must inspect the definitions of all macros, typedefs, platform flags and helper functions referenced by the function. Each listed symbol can hide compiler-specific extensions (GNU/Clang/MSVC keywords, builtins like __builtin_*, attributes, inline asm, statement-expressions, typeof, nonstandard casts, or other compiler-specific constructs) or cause non-standard behavior via conditional compilation. Brief reasons: \n\n- MHD_socket, MHD_INVALID_SOCKET, connection->state, MHD_CONNECTION_CLOSED: type and state macros/enum definitions may use compiler-specific attributes or non-standard integer types.\n- mhd_assert: often a macro that can expand to compiler builtins or attributes; must check for extensions like __builtin_expect, __attribute__, or statement expressions.\n- _MHD_SEND_VEC_MAX, MHD_SCKT_SEND_MAX_SIZE_, MHD_VECT_SEND, HAVE_SENDMSG, HAVE_WRITEV, MSG_NOSIGNAL_OR_ZERO, _MHD_DROP_CONST: preprocessor macros may be defined using compiler-specific constructs (e.g. cast macros, statement-expressions, use of typeof, or nonstandard pragmas). _MHD_DROP_CONST is specifically a cast helper \u2014 its expansion must be checked.\n- SSIZE_MAX, UINT_MAX, UINT32_MAX: constants from headers may be fine, but their presence affects conditional compilation and truncation logic; ensure no non-standard definitions used.\n- _WIN32, WSABUF, WSASend, sendmsg, writev, MSG_NOSIGNAL: platform API bindings and wrapper macros may use compiler-specific annotations or typedefs. WinAPI usage (WSASend/WSABUF) can introduce MSVC-only constructs.\n- pre_send_setopt, post_send_setopt: although in the call graph, their implementations can include compiler extensions (attributes, inline asm) that alter semantics; need to inspect to ensure target function's calls do not rely on extensions.\n- HTTPS_SUPPORT, MHD_USE_TLS, MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE, MHD_SEND_SPIPE_SUPPRESS_NEEDED, connection->daemon (options, sigpipe_blocked), connection->sk_spipe_suppress, connection->sk_nonblck: daemon/options flags and related macros may be defined via extension-bearing macros or use non-standard bitfield/attribute syntax.\n- MHD_socket_get_error_, MHD_SCKT_ERR_IS_*, MHD_SCKT_E* constants: error-checking macros can hide compiler-specific constructs (e.g. macros that use typeof or complex statement-expressions).\n- MHD_ERR_* return-code macros: definitions should be checked to ensure they are simple constants and not constructed via extensions.\n- EPOLL_SUPPORT, connection->epoll_state, MHD_EPOLL_STATE_WRITE_READY: epoll-related macros and enum definitions can use attributes or nonstandard enum extensions.\n- _MHD_HAVE_SENDFILE, MHD_resp_sender_std, connection->rp.resp_sender: sendfile-related conditional code may introduce compiler-specific constructs.\n\nIn short: any macro, typedef, constant, struct member or helper function used in the function can hide language extensions; the above symbols are the concise set you must inspect to decide MISRA compliance for 'no language extensions'."
}