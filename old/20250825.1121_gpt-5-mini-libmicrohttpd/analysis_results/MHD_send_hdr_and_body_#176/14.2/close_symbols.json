{
  "user_message": "Target function code is:\n```c\nssize_t\nMHD_send_hdr_and_body_ (struct MHD_Connection *connection,\n                        const char *header,\n                        size_t header_size,\n                        bool never_push_hdr,\n                        const char *body,\n                        size_t body_size,\n                        bool complete_response)\n{\n  ssize_t ret;\n  bool push_hdr;\n  bool push_body;\n  MHD_socket s = connection->socket_fd;\n#ifndef _WIN32\n#define _MHD_SEND_VEC_MAX   MHD_SCKT_SEND_MAX_SIZE_\n#else  /* ! _WIN32 */\n#define _MHD_SEND_VEC_MAX   UINT32_MAX\n#endif /* ! _WIN32 */\n#ifdef MHD_VECT_SEND\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  struct iovec vector[2];\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#endif /* HAVE_SENDMSG */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  WSABUF vector[2];\n  DWORD vec_sent;\n#endif /* _WIN32 */\n  bool no_vec; /* Is vector-send() disallowed? */\n\n  no_vec = false;\n#ifdef HTTPS_SUPPORT\n  no_vec = no_vec || (connection->daemon->options & MHD_USE_TLS);\n#endif /* HTTPS_SUPPORT */\n#if (! defined(HAVE_SENDMSG) || ! defined(MSG_NOSIGNAL) ) && \\\n  defined(MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE) && \\\n  defined(MHD_SEND_SPIPE_SUPPRESS_NEEDED)\n  no_vec = no_vec || (! connection->daemon->sigpipe_blocked &&\n                      ! connection->sk_spipe_suppress);\n#endif /* (!HAVE_SENDMSG || ! MSG_NOSIGNAL) &&\n          MHD_SEND_SPIPE_SEND_SUPPRESS_POSSIBLE &&\n          MHD_SEND_SPIPE_SUPPRESS_NEEDED */\n#endif /* MHD_VECT_SEND */\n\n  mhd_assert ( (NULL != body) || (0 == body_size) );\n\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  push_body = complete_response;\n\n  if (! never_push_hdr)\n  {\n    if (! complete_response)\n      push_hdr = true; /* Push the header as the client may react\n                        * on header alone while the body data is\n                        * being prepared. */\n    else\n    {\n      if (1400 > (header_size + body_size))\n        push_hdr = false;  /* Do not push the header as complete\n                           * reply is already ready and the whole\n                           * reply most probably will fit into\n                           * the single IP packet. */\n      else\n        push_hdr = true;   /* Push header alone so client may react\n                           * on it while reply body is being delivered. */\n    }\n  }\n  else\n    push_hdr = false;\n\n  if (complete_response && (0 == body_size))\n    push_hdr = true; /* The header alone is equal to the whole response. */\n\n  if (\n#ifdef MHD_VECT_SEND\n    (no_vec) ||\n    (0 == body_size) ||\n    ((size_t) SSIZE_MAX <= header_size) ||\n    ((size_t) _MHD_SEND_VEC_MAX < header_size)\n#ifdef _WIN32\n    || ((size_t) UINT_MAX < header_size)\n#endif /* _WIN32 */\n#else  /* ! MHD_VECT_SEND */\n    true\n#endif /* ! MHD_VECT_SEND */\n    )\n  {\n    ret = MHD_send_data_ (connection,\n                          header,\n                          header_size,\n                          push_hdr);\n\n    if ( (header_size == (size_t) ret) &&\n         ((size_t) SSIZE_MAX > header_size) &&\n         (0 != body_size) &&\n         (connection->sk_nonblck) )\n    {\n      ssize_t ret2;\n      /* The header has been sent completely.\n       * Try to send the reply body without waiting for\n       * the next round. */\n      /* Make sure that sum of ret + ret2 will not exceed SSIZE_MAX as\n       * function needs to return positive value if succeed. */\n      if ( (((size_t) SSIZE_MAX) - ((size_t) ret)) <  body_size)\n      {\n        body_size = (((size_t) SSIZE_MAX) - ((size_t) ret));\n        complete_response = false;\n        push_body = complete_response;\n      }\n\n      ret2 = MHD_send_data_ (connection,\n                             body,\n                             body_size,\n                             push_body);\n      if (0 < ret2)\n        return ret + ret2; /* Total data sent */\n      if (MHD_ERR_AGAIN_ == ret2)\n        return ret;\n\n      return ret2; /* Error code */\n    }\n    return ret;\n  }\n#ifdef MHD_VECT_SEND\n\n  if ( ((size_t) SSIZE_MAX <= body_size) ||\n       ((size_t) SSIZE_MAX < (header_size + body_size)) )\n  {\n    /* Return value limit */\n    body_size = SSIZE_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#if (SSIZE_MAX != _MHD_SEND_VEC_MAX) || (_MHD_SEND_VEC_MAX + 0 == 0)\n  if (((size_t) _MHD_SEND_VEC_MAX <= body_size) ||\n      ((size_t) _MHD_SEND_VEC_MAX < (header_size + body_size)))\n  {\n    /* Send total amount limit */\n    body_size = _MHD_SEND_VEC_MAX - header_size;\n    complete_response = false;\n    push_body = complete_response;\n  }\n#endif /* SSIZE_MAX != _MHD_SEND_VEC_MAX */\n\n  pre_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                   true,\n#else  /* ! HAVE_SENDMSG */\n                   false,\n#endif /* ! HAVE_SENDMSG */\n                   push_hdr || push_body);\n#if defined(HAVE_SENDMSG) || defined(HAVE_WRITEV)\n  vector[0].iov_base = _MHD_DROP_CONST (header);\n  vector[0].iov_len = header_size;\n  vector[1].iov_base = _MHD_DROP_CONST (body);\n  vector[1].iov_len = body_size;\n\n#if defined(HAVE_SENDMSG)\n  memset (&msg, 0, sizeof(msg));\n  msg.msg_iov = vector;\n  msg.msg_iovlen = 2;\n\n  ret = sendmsg (s, &msg, MSG_NOSIGNAL_OR_ZERO);\n#elif defined(HAVE_WRITEV)\n  ret = writev (s, vector, 2);\n#endif /* HAVE_WRITEV */\n#endif /* HAVE_SENDMSG || HAVE_WRITEV */\n#ifdef _WIN32\n  if ((size_t) UINT_MAX < body_size)\n  {\n    /* Send item size limit */\n    body_size = UINT_MAX;\n    complete_response = false;\n    push_body = complete_response;\n  }\n  vector[0].buf = (char *) _MHD_DROP_CONST (header);\n  vector[0].len = (unsigned long) header_size;\n  vector[1].buf = (char *) _MHD_DROP_CONST (body);\n  vector[1].len = (unsigned long) body_size;\n\n  ret = WSASend (s, vector, 2, &vec_sent, 0, NULL, NULL);\n  if (0 == ret)\n    ret = (ssize_t) vec_sent;\n  else\n    ret = -1;\n#endif /* _WIN32 */\n\n  if (0 > ret)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN, no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n#ifdef EPOLL_SUPPORT\n  else if ((header_size + body_size) > (size_t) ret)\n    connection->epoll_state &=\n      ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n\n  /* If there is a need to push the data from network buffers\n   * call post_send_setopt(). */\n  if ( (push_body) &&\n       ((header_size + body_size) == (size_t) ret) )\n  {\n    /* Complete reply has been sent. */\n    /* If TLS connection is used then next final send() will be\n     * without MSG_MORE support. If non-TLS connection is used\n     * it's unknown whether next 'send' will be plain send() / sendmsg() or\n     * sendfile() will be used so assume that next final send() will be\n     * the same, like for this response. */\n    post_send_setopt (connection,\n#ifdef HAVE_SENDMSG\n                      true,\n#else  /* ! HAVE_SENDMSG */\n                      false,\n#endif /* ! HAVE_SENDMSG */\n                      true);\n  }\n  else if ( (push_hdr) &&\n            (header_size <= (size_t) ret))\n  {\n    /* The header has been sent completely and there is a\n     * need to push the header data. */\n    /* Luckily the type of send function will be used next is known. */\n    post_send_setopt (connection,\n#if defined(_MHD_HAVE_SENDFILE)\n                      MHD_resp_sender_std == connection->rp.resp_sender,\n#else  /* ! _MHD_HAVE_SENDFILE */\n                      true,\n#endif /* ! _MHD_HAVE_SENDFILE */\n                      true);\n  }\n\n  return ret;\n#else  /* ! MHD_VECT_SEND */\n  mhd_assert (false);\n  return MHD_ERR_CONNRESET_; /* Unreachable. Mute warnings. */\n#endif /* ! MHD_VECT_SEND */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_send_hdr_and_body_': {'callees': ['MHD_send_data_', 'pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write']}, 'MHD_send_data_': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_connection_handle_write', 'MHD_send_hdr_and_body_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_connection_handle_write': {'callees': ['MHD_send_data_', 'MHD_DLOG', 'connection_close_error', 'MHD_update_last_activity_', 'MHD_send_hdr_and_body_', 'str_conn_error_', 'check_write_done', '__builtin_unreachable', 'try_ready_normal_body', 'MHD_send_sendfile_', 'MHD_send_iovec_'], 'callers': ['call_handlers']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nA for loop shall be well-formed. The three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "MHD_send_data_",
    "pre_send_setopt",
    "post_send_setopt",
    "MHD_DLOG",
    "struct MHD_Connection and the following members: socket_fd, state, sk_nonblck, epoll_state, sk_spipe_suppress, rp.resp_sender, daemon (and daemon->options, daemon->sigpipe_blocked)",
    "MHD_VECT_SEND (compile-time feature macro)",
    "HAVE_SENDMSG, HAVE_WRITEV, _MHD_HAVE_SENDFILE (compile-time feature macros)",
    "SSIZE_MAX, _MHD_SEND_VEC_MAX, UINT_MAX (size/limit macros)",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_* macros (e.g. MHD_SCKT_ERR_IS_EAGAIN_, MHD_SCKT_ERR_IS_EINTR_, MHD_SCKT_ERR_IS_REMOTE_DISCNN_, MHD_SCKT_EPIPE_, etc.)"
  ],
  "explanation": "For each symbol: \n\n- MHD_send_data_: This function is called directly from MHD_send_hdr_and_body_. To determine MISRA for-loop compliance we must inspect any for-loops inside its body (the rule counts behaviour of functions called within loop bodies) and whether it modifies potential loop counters or loop-control flags shared with the caller. \n\n- pre_send_setopt: Called by the target (in the MHD_VECT_SEND path) and by MHD_send_data_. Its implementation may contain for-loops or modify connection state/flags that could act as loop counters/flags; therefore its code and side-effects must be known. \n\n- post_send_setopt: Likewise called by the target and MHD_send_data_. It may contain loops or change flags/objects that a for-loop in the target (or in callees) would rely on; inspect it for loops and side-effects. \n\n- MHD_DLOG: post_send_setopt calls this logging helper. If post_send_setopt delegates loop work to logging or utility routines, those routines must be checked for for-loops or for modifications of objects used as loop counters/flags. \n\n- struct MHD_Connection and members (socket_fd, state, sk_nonblck, epoll_state, sk_spipe_suppress, rp.resp_sender, daemon and daemon->options, daemon->sigpipe_blocked): Many conditional decisions and boolean-like flags in the target use these fields. If a for-loop uses any of these objects as a loop-control flag or loop counter, MISRA requires they have the proper types and are not modified in the loop body (or in called functions). To verify compliance you must know their types and which functions may modify them. \n\n- MHD_VECT_SEND (feature macro): The presence/absence of this compile-time macro changes which code paths (including the vector-send block that calls pre_send_setopt/post_send_setopt) are compiled. To know which code to inspect for for-loops, you must know whether this macro is defined. \n\n- HAVE_SENDMSG, HAVE_WRITEV, _MHD_HAVE_SENDFILE (feature macros): These macros enable alternative code paths (sendmsg/writev, sendfile-related paths). Different compiled paths may contain for-loops or use different objects as loop-control flags; their definitions determine which routines must be inspected. \n\n- SSIZE_MAX, _MHD_SEND_VEC_MAX, UINT_MAX (size/limit macros): These macros affect arithmetic and conditional logic that could be used as loop counters/limits or influence whether loops would be present in alternative implementations. Knowing their values is needed to reason about any loops using these limits. \n\n- MHD_socket_get_error_: Used when a negative send result is obtained; if any error-reporting path contains loops or modifies shared flags/counters, it must be checked. Also required to understand error-handling control flow that might interact with loops. \n\n- MHD_SCKT_ERR_IS_* macros (EAGAIN/EINTR/REMOTE_DISCONN/EPIPE/\u2026): These conditionals determine which error branch executes; if branches call functions that contain for-loops or modify loop-control objects, their behaviour must be analyzed.\n\nRationale summary: MISRA's for-loop rule ties loop-body behaviour to any functions called from that for statement and forbids modification of loop counters/flags in the loop body or in called functions. Although MHD_send_hdr_and_body_ itself has no for statements, to conclusively determine compliance in all compiled variants you must examine the functions it calls (MHD_send_data_, pre_send_setopt, post_send_setopt and any utilities they invoke) and the connection/global objects and compile-time macros that affect which code paths (and potential for-loops) are present."
}