{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.2 is: A for loop shall be well-formed.\nThe three clauses of a for statement are the:\n1. First clause shall be empty or an expression whose set the value of the loop counter or define and intialize the loop counter.\n2. Second clause shall be an expression that has no persistent side effects, and shall use the loop counter and optionally loop control flags, and shall not use any other object that is modified in the for loop body.\n3.Third clause shall be an expression whose modify only the value of the loop counter, and shall not use objects that are modified in the for loop body.\n4. There shall only be one loop counter in a for loop, which shall not be modified in for loop body. A loop control flag is defined as single identifier denoting an object with Boolean type that is used in the second clause. The behaviour of a for loop body includes the behaviour of any functions called within that statement. \n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_basic_auth_get_username_password:\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_basic_auth_get_username_password:\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n...\nconst struct MHD_RqBAuth *\nMHD_get_rq_bauth_params_ (struct MHD_Connection *connection)\n{\n  struct _MHD_str_w_len h_auth_value;\n  struct MHD_RqBAuth *bauth;\n\n  mhd_assert (MHD_CONNECTION_HEADERS_PROCESSED <= connection->state);\n\n  if (connection->rq.bauth_tried)\n    return connection->rq.bauth;\n\n  if (MHD_CONNECTION_HEADERS_PROCESSED > connection->state)\n    return NULL;\n\n  if (! find_auth_rq_header_ (connection, MHD_AUTHTYPE_BASIC, &h_auth_value))\n  {\n    connection->rq.bauth_tried = true;\n    connection->rq.bauth = NULL;\n    return NULL;\n  }\n\n  bauth =\n    (struct MHD_RqBAuth *)\n    MHD_connection_alloc_memory_ (connection, sizeof (struct MHD_RqBAuth));\n\n  if (NULL == bauth)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"Not enough memory in the connection's pool to allocate \" \\\n                 \"for Basic Authorization header parsing.\\n\"));\n#endif /* HAVE_MESSAGES */\n    return NULL;\n  }\n\n  memset (bauth, 0, sizeof(struct MHD_RqBAuth));\n  if (parse_bauth_params (h_auth_value.str, h_auth_value.len, bauth))\n    connection->rq.bauth = bauth;\n  else\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG (connection->daemon,\n              _ (\"The Basic Authorization client's header has \"\n                 \"incorrect format.\\n\"));\n#endif /* HAVE_MESSAGES */\n    connection->rq.bauth = NULL;\n    /* Memory in the pool remains allocated until next request */\n  }\n  connection->rq.bauth_tried = true;\n  return connection->rq.bauth;\n}\n...\nsize_t\nMHD_base64_to_bin_n (const char *base64,\n                     size_t base64_len,\n                     void *bin,\n                     size_t bin_size)\n{\n#if MHD_BASE64_FUNC_VERSION >= 2\n  static const MHD_base64_map_type_ map[] = {\n    /* -1 = invalid char, -2 = padding\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    NUL,  SOH,  STX,  ETX,  EOT,  ENQ,  ACK,  BEL,  */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n    BS,   HT,   LF,   VT,   FF,   CR,   SO,   SI,   */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    DLE,  DC1,  DC2,  DC3,  DC4,  NAK,  SYN,  ETB,  */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n    CAN,  EM,   SUB,  ESC,  FS,   GS,   RS,   US,   */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    ' ',  '!',  '\"',  '#',  '$',  '%',  '&',  '\\'', */\n    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n    '(',  ')',  '*',  '+',  ',',  '-',  '.',  '/',  */\n    -1,   -1,   -1,   62,   -1,   -1,   -1,   63,\n    /*\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  */\n    52,   53,   54,   55,   56,   57,   58,   59,\n    /*\n    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n    '8',  '9',  ':',  ';',  '<',  '=',  '>',  '?',  */\n    60,   61,   -1,   -1,   -1,   -2,   -1,   -1,\n    /*\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',  */\n    -1,    0,    1,    2,    3,    4,    5,    6,\n    /*\n    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n    'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',  */\n    7,     8,    9,   10,   11,   12,   13,   14,\n    /*\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',  */\n    15,   16,   17,   18,   19,   20,   21,   22,\n    /*\n     0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n    'X',  'Y',  'Z',  '[',  '\\',  ']',  '^',  '_',  */\n    23,   24,   25,   -1,   -1,   -1,   -1,   -1,\n    /*\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',  */\n    -1,   26,   27,   28,   29,   30,   31,   32,\n    /*\n    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n    'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',  */\n    33,   34,   35,   36,   37,   38,   39,   40,\n    /*\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    'p',  'q',  'r',  's',  't',  'u',  'v',  'w',  */\n    41,   42,   43,   44,   45,   46,   47,   48,\n    /*\n    0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n    'x',  'y',  'z',  '{',  '|',  '}',  '~',  DEL,  */\n    49,   50,   51,   -1,   -1,   -1,   -1,   -1\n\n#if MHD_BASE64_FUNC_VERSION == 3\n    ,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 80..8F */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 90..9F */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* A0..AF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* B0..BF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* C0..CF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* D0..DF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* E0..EF */\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* F0..FF */\n#endif /* ! MHD_BASE64_FUNC_VERSION == 3 */\n  };\n#define base64_char_to_value_(c) map[(c)]\n#endif /* MHD_BASE64_FUNC_VERSION >= 2 */\n  const uint8_t *const in = (const uint8_t *) base64;\n  uint8_t *const out = (uint8_t *) bin;\n  size_t i;\n  size_t j;\n  if (0 == base64_len)\n    return 0;  /* Nothing to decode */\n  if (0 != base64_len % 4)\n    return 0;  /* Wrong input length */\n  if (base64_len / 4 * 3 - 2 > bin_size)\n    return 0;\n\n  j = 0;\n  for (i = 0; i < (base64_len - 4); i += 4)\n  {\n#if MHD_BASE64_FUNC_VERSION == 2\n    if (0 != (0x80 & (in[i] | in[i + 1] | in[i + 2] | in[i + 3])))\n      return 0;\n#endif /* MHD_BASE64_FUNC_VERSION == 2 */\n    if (1)\n    {\n      const MHD_base64_map_type_ v1 = base64_char_to_value_ (in[i + 0]);\n      const MHD_base64_map_type_ v2 = base64_char_to_value_ (in[i + 1]);\n      const MHD_base64_map_type_ v3 = base64_char_to_value_ (in[i + 2]);\n      const MHD_base64_map_type_ v4 = base64_char_to_value_ (in[i + 3]);\n      if ((0 > v1) || (0 > v2) || (0 > v3) || (0 > v4))\n        return 0;\n      out[j + 0] = (uint8_t) (((uint8_t) (((uint8_t) v1) << 2))\n                              | ((uint8_t) (((uint8_t) v2) >> 4)));\n      out[j + 1] = (uint8_t) (((uint8_t) (((uint8_t) v2) << 4))\n                              | ((uint8_t) (((uint8_t) v3) >> 2)));\n      out[j + 2] = (uint8_t) (((uint8_t) (((uint8_t) v3) << 6))\n                              | ((uint8_t) v4));\n    }\n    j += 3;\n  }\n#if MHD_BASE64_FUNC_VERSION == 2\n  if (0 != (0x80 & (in[i] | in[i + 1] | in[i + 2] | in[i + 3])))\n    return 0;\n#endif /* MHD_BASE64_FUNC_VERSION == 2 */\n  if (1)\n  { /* The last four chars block */\n    const MHD_base64_map_type_ v1 = base64_char_to_value_ (in[i + 0]);\n    const MHD_base64_map_type_ v2 = base64_char_to_value_ (in[i + 1]);\n    const MHD_base64_map_type_ v3 = base64_char_to_value_ (in[i + 2]);\n    const MHD_base64_map_type_ v4 = base64_char_to_value_ (in[i + 3]);\n    if ((0 > v1) || (0 > v2))\n      return 0; /* Invalid char or padding at first two positions */\n    mhd_assert (j < bin_size);\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v1) << 2))\n                          | ((uint8_t) (((uint8_t) v2) >> 4)));\n    if (0 > v3)\n    { /* Third char is either padding or invalid */\n      if ((-2 != v3) || (-2 != v4))\n        return 0;  /* Both two last chars must be padding */\n      if (0 != (uint8_t) (((uint8_t) v2) << 4))\n        return 0;  /* Wrong last char */\n      return j;\n    }\n    if (j >= bin_size)\n      return 0; /* Not enough space */\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v2) << 4))\n                          | ((uint8_t) (((uint8_t) v3) >> 2)));\n    if (0 > v4)\n    { /* Fourth char is either padding or invalid */\n      if (-2 != v4)\n        return 0;  /* The char must be padding */\n      if (0 != (uint8_t) (((uint8_t) v3) << 6))\n        return 0;  /* Wrong last char */\n      return j;\n    }\n    if (j >= bin_size)\n      return 0; /* Not enough space */\n    out[j++] = (uint8_t) (((uint8_t) (((uint8_t) v3) << 6))\n                          | ((uint8_t) v4));\n  }\n  return j;\n#if MHD_BASE64_FUNC_VERSION >= 2\n#undef base64_char_to_value_\n#endif /* MHD_BASE64_FUNC_VERSION >= 2 */\n}\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n...\nstruct MHD_BasicAuthInfo\n{\n  /**\n   * The username, cannot be NULL.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username, not including zero-termination\n   */\n  size_t username_len;\n\n  /**\n   * The password, may be NULL if password is not encoded by the client.\n   * The buffer pointed by the @a password becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *password;\n\n  /**\n   * The length of the @a password, not including zero-termination;\n   * when the @a password is NULL, the length is always zero.\n   */\n  size_t password_len;\n}\n...\nstruct MHD_Connection\n{\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * Next pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *nextE;\n\n  /**\n   * Previous pointer for the EDLL listing connections that are epoll-ready.\n   */\n  struct MHD_Connection *prevE;\n#endif\n\n  /**\n   * Next pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *next;\n\n  /**\n   * Previous pointer for the DLL describing our IO state.\n   */\n  struct MHD_Connection *prev;\n\n  /**\n   * Next pointer for the XDLL organizing connections by timeout.\n   * This DLL can be either the\n   * 'manual_timeout_head/manual_timeout_tail' or the\n   * 'normal_timeout_head/normal_timeout_tail', depending on whether a\n   * custom timeout is set for the connection.\n   */\n  struct MHD_Connection *nextX;\n\n  /**\n   * Previous pointer for the XDLL organizing connections by timeout.\n   */\n  struct MHD_Connection *prevX;\n\n  /**\n   * Reference to the MHD_Daemon struct.\n   */\n  struct MHD_Daemon *daemon;\n\n  /**\n   * Request-specific data\n   */\n  struct MHD_Request rq;\n\n  /**\n   * Reply-specific data\n   */\n  struct MHD_Reply rp;\n\n  /**\n   * The memory pool is created whenever we first read from the TCP\n   * stream and destroyed at the end of each request (and re-created\n   * for the next request).  In the meantime, this pointer is NULL.\n   * The pool is used for all connection-related data except for the\n   * response (which maybe shared between connections) and the IP\n   * address (which persists across individual requests).\n   */\n  struct MemoryPool *pool;\n\n  /**\n   * We allow the main application to associate some pointer with the\n   * TCP connection (which may span multiple HTTP requests).  Here is\n   * where we store it.  (MHD does not know or care what it is).\n   * The location is given to the #MHD_NotifyConnectionCallback and\n   * also accessible via #MHD_CONNECTION_INFO_SOCKET_CONTEXT.\n   */\n  void *socket_context;\n\n  /**\n   * Close connection after sending response?\n   * Functions may change value from \"Unknown\" or \"KeepAlive\" to \"Must close\",\n   * but no functions reset value \"Must Close\" to any other value.\n   */\n  enum MHD_ConnKeepAlive keepalive;\n\n  /**\n   * Buffer for reading requests.  Allocated in pool.  Actually one\n   * byte larger than @e read_buffer_size (if non-NULL) to allow for\n   * 0-termination.\n   */\n  char *read_buffer;\n\n  /**\n   * Buffer for writing response (headers only).  Allocated\n   * in pool.\n   */\n  char *write_buffer;\n\n  /**\n   * Foreign address (of length @e addr_len).  MALLOCED (not\n   * in pool!).\n   */\n  struct sockaddr_storage *addr;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Thread handle for this connection (if we are using\n   * one thread per connection).\n   */\n  MHD_thread_handle_ID_ tid;\n#endif\n\n  /**\n   * Size of @e read_buffer (in bytes).\n   * This value indicates how many bytes we're willing to read\n   * into the buffer.\n   */\n  size_t read_buffer_size;\n\n  /**\n   * Position where we currently append data in @e read_buffer (the\n   * next char after the last valid position).\n   */\n  size_t read_buffer_offset;\n\n  /**\n   * Size of @e write_buffer (in bytes).\n   */\n  size_t write_buffer_size;\n\n  /**\n   * Offset where we are with sending from @e write_buffer.\n   */\n  size_t write_buffer_send_offset;\n\n  /**\n   * Last valid location in write_buffer (where do we\n   * append and up to where is it safe to send?)\n   */\n  size_t write_buffer_append_offset;\n\n  /**\n   * Position in the 100 CONTINUE message that\n   * we need to send when receiving http 1.1 requests.\n   */\n  size_t continue_message_write_offset;\n\n  /**\n   * Length of the foreign address.\n   */\n  socklen_t addr_len;\n\n  /**\n   * Last time this connection had any activity\n   * (reading or writing).\n   */\n  uint64_t last_activity;\n\n  /**\n   * After how many milliseconds of inactivity should\n   * this connection time out?\n   * Zero for no timeout.\n   */\n  uint64_t connection_timeout_ms;\n\n  /**\n   * Socket for this connection.  Set to #MHD_INVALID_SOCKET if\n   * this connection has died (daemon should clean\n   * up in that case).\n   */\n  MHD_socket socket_fd;\n\n  /**\n   * true if @e socket_fd is not TCP/IP (a UNIX domain socket, a pipe),\n   * false (TCP/IP) otherwise.\n   */\n  enum MHD_tristate is_nonip;\n\n  /**\n   * true if #socket_fd is non-blocking, false otherwise.\n   */\n  bool sk_nonblck;\n\n  /**\n   * true if connection socket has set SIGPIPE suppression\n   */\n  bool sk_spipe_suppress;\n\n  /**\n   * Tracks TCP_CORK / TCP_NOPUSH of the connection socket.\n   */\n  enum MHD_tristate sk_corked;\n\n  /**\n   * Tracks TCP_NODELAY state of the connection socket.\n   */\n  enum MHD_tristate sk_nodelay;\n\n  /**\n   * Has this socket been closed for reading (i.e.  other side closed\n   * the connection)?  If so, we must completely close the connection\n   * once we are done sending our response (and stop trying to read\n   * from this socket).\n   */\n  bool read_closed;\n\n  /**\n   * Some error happens during processing the connection therefore this\n   * connection must be closed.\n   * The error may come from the client side (like wrong request format),\n   * from the application side (like data callback returned error), or from\n   * the OS side (like out-of-memory).\n   */\n  bool stop_with_error;\n\n  /**\n   * Response queued early, before the request is fully processed,\n   * the client upload is rejected.\n   * The connection cannot be reused for additional requests as the current\n   * request is incompletely read and it is unclear where is the initial\n   * byte of the next request.\n   */\n  bool discard_request;\n\n#if defined(MHD_USE_POSIX_THREADS) || defined(MHD_USE_W32_THREADS)\n  /**\n   * Set to `true` if the thread has been joined.\n   */\n  bool thread_joined;\n#endif\n\n  /**\n   * Are we currently inside the \"idle\" handler (to avoid recursively\n   * invoking it).\n   */\n  bool in_idle;\n\n  /**\n   * Connection is in the cleanup DL-linked list.\n   */\n  bool in_cleanup;\n\n#ifdef EPOLL_SUPPORT\n  /**\n   * What is the state of this socket in relation to epoll?\n   */\n  enum MHD_EpollState epoll_state;\n#endif\n\n  /**\n   * State in the FSM for this connection.\n   */\n  enum MHD_CONNECTION_STATE state;\n\n  /**\n   * What is this connection waiting for?\n   */\n  enum MHD_ConnectionEventLoopInfo event_loop_info;\n\n  /**\n   * Function used for reading HTTP request stream.\n   */\n  ReceiveCallback recv_cls;\n\n#ifdef UPGRADE_SUPPORT\n  /**\n   * If this connection was upgraded, this points to\n   * the upgrade response details such that the\n   * #thread_main_connection_upgrade()-logic can perform the\n   * bi-directional forwarding.\n   */\n  struct MHD_UpgradeResponseHandle *urh;\n#endif /* UPGRADE_SUPPORT */\n\n#ifdef HTTPS_SUPPORT\n\n  /**\n   * State required for HTTPS/SSL/TLS support.\n   */\n  gnutls_session_t tls_session;\n\n  /**\n   * State of connection's TLS layer\n   */\n  enum MHD_TLS_CONN_STATE tls_state;\n\n  /**\n   * Could it be that we are ready to read due to TLS buffers\n   * even though the socket is not?\n   */\n  bool tls_read_ready;\n#endif /* HTTPS_SUPPORT */\n\n  /**\n   * Is the connection suspended?\n   */\n  bool suspended;\n\n  /**\n   * Are we currently in the #MHD_AccessHandlerCallback\n   * for this connection (and thus eligible to receive\n   * calls to #MHD_queue_response()?).\n   */\n  bool in_access_handler;\n\n  /**\n   * Is the connection wanting to resume?\n   */\n  volatile bool resuming;\n\n  /**\n   * Special member to be returned by #MHD_get_connection_info()\n   */\n  union MHD_ConnectionInfo connection_info_dummy;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "  j = 0;\n  for (i = 0; i < (base64_len - 4); i += 4)\n  {\n#if MHD_BASE64_FUNC_VERSION == 2\n    if (0 != (0x80 & (in[i] | in[i + 1] | in[i + 2] | in[i + 3])))\n      return 0;\n#endif /* MHD_BASE64_FUNC_VERSION == 2 */\n    if (1)\n    {\n      const MHD_base64_map_type_ v1 = base64_char_to_value_ (in[i + 0]);\n      const MHD_base64_map_type_ v2 = base64_char_to_value_ (in[i + 1]);\n      const MHD_base64_map_type_ v3 = base64_char_to_value_ (in[i + 2]);\n      const MHD_base64_map_type_ v4 = base64_char_to_value_ (in[i + 3]);\n      if ((0 > v1) || (0 > v2) || (0 > v3) || (0 > v4))\n        return 0;\n      out[j + 0] = (uint8_t) (((uint8_t) (((uint8_t) v1) << 2))\n                              | ((uint8_t) (((uint8_t) v2) >> 4)));\n      out[j + 1] = (uint8_t) (((uint8_t) (((uint8_t) v2) << 4))\n                              | ((uint8_t) (((uint8_t) v3) >> 2)));\n      out[j + 2] = (uint8_t) (((uint8_t) (((uint8_t) v3) << 6))\n                              | ((uint8_t) v4));\n    }\n    j += 3;\n  }"
  ],
  "explanation": "Only the above for-statement(s) need investigation for compliance with MISRA C:2023 Rule 14.2. The remainder of the provided code contains no other for statements: MHD_basic_auth_get_username_password itself has no for loops (it uses allocation, memcpy, free and conditional returns), MHD_basic_auth_get_username_password3 uses no for loops, and other helper functions/structures in the snippet either contain no for loops or only conditional/return logic. Therefore other fragments do not fall under Rule 14.2 and need not be investigated."
}