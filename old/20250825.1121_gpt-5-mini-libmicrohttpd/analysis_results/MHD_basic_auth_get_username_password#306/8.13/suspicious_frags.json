{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 8.13 is: A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_basic_auth_get_username_password:\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_basic_auth_get_username_password:\nstruct MHD_BasicAuthInfo\n{\n  /**\n   * The username, cannot be NULL.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username, not including zero-termination\n   */\n  size_t username_len;\n\n  /**\n   * The password, may be NULL if password is not encoded by the client.\n   * The buffer pointed by the @a password becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *password;\n\n  /**\n   * The length of the @a password, not including zero-termination;\n   * when the @a password is NULL, the length is always zero.\n   */\n  size_t password_len;\n}\n...\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n...\n#define mhd_assert(ignore) ((void)0)\n...\nvoid\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [
    "      memcpy (username, info->username, info->username_len + 1);",
    "  char *username;",
    "_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)",
    "  char *password;",
    "          memcpy (*password, info->password, info->password_len + 1);",
    "  struct MHD_BasicAuthInfo *info;",
    "  struct MHD_BasicAuthInfo *ret;"
  ],
  "explanation": "Fragments not reported as suspicious: params is already declared as const (const struct MHD_RqBAuth *params) so it follows the rule; the decoded buffer (decoded) is written to (zero-termination and base64 decoding), so it cannot be const; the malloc/returned buffers from MHD_basic_auth_get_username_password are intentionally returned as modifiable memory to the caller (so a non-const char * return is appropriate); the password parameter (char **password) is an output parameter that is assigned newly allocated memory, so it cannot be a pointer-to-const; calls to free() operate on allocated objects and may complicate making the structure pointer itself const without additional casts, so those uses were not flagged. These reasons explain why other pointer usages in the provided code were not included among the suspicious fragments."
}