{
  "user_message": "<misra_rule>\nThe target MISRA C 2023 Rule 14.3 is: Controlling expressions shall not be invariant.\nHere are exceptions to this rule:\n1. Invariants that are used to create infinite loops are permitted.\n2. A do-while loop with an essentially Boolean controlling expression that evaluates to false and satisfies the constraints and semantics for an integer constant expression is permitted.\n</misra_rule>\n<instruction>\nOther agents will judge whether the code follows the MISRA C 2023 guidelines.\nThey will investigate the code fragments you give.\nYour job is to find code fragments in the code that should be investigated to check whether the code follows the MISRA C rule.\n</instruction>\n<response format>\nProvide your answer with these fields.\n- suspicious_frags: The list of suspicious code fragments in the code.\nIt should contain only the code fragments exists in the code. If you do not find any suspicious code fragments, return an empty list for suspicious_frags\n- explanation: The explanation of why other code fragments should NOT be investigated.\nIt is very important to not miss any suspicious code fragments, so please give a sufficient explanation why other code fragments should not be investigated.\nDO NOT give any explanation for the selected suspicious code fragments.\n</response format>\n<target_code>\nHere is the code of MHD_basic_auth_get_username_password:\n```c\n_MHD_EXTERN char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n                                      char **password)\n{\n  struct MHD_BasicAuthInfo *info;\n\n  info = MHD_basic_auth_get_username_password3 (connection);\n  if (NULL == info)\n    return NULL;\n\n  /* For backward compatibility this function must return NULL if\n   * no password is provided */\n  if (NULL != info->password)\n  {\n    char *username;\n\n    username = malloc (info->username_len + 1);\n    if (NULL != username)\n    {\n      memcpy (username, info->username, info->username_len + 1);\n      mhd_assert (0 == username[info->username_len]);\n      if (NULL != password)\n      {\n        *password = malloc (info->password_len + 1);\n        if (NULL != *password)\n        {\n          memcpy (*password, info->password, info->password_len + 1);\n          mhd_assert (0 == (*password)[info->password_len]);\n\n          free (info);\n          return username; /* Success exit point */\n        }\n#ifdef HAVE_MESSAGES\n        else\n          MHD_DLOG (connection->daemon,\n                    _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n      }\n      else\n      {\n        free (info);\n        return username; /* Success exit point */\n      }\n\n      free (username);\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Failed to allocate memory.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n  }\n  free (info);\n  if (NULL != password)\n    *password = NULL;\n  return NULL;  /* Failure exit point */\n}\n```\n</target_code>\n<additional code>Here are the definitions of symbols that are related to the target function MHD_basic_auth_get_username_password:\n_MHD_EXTERN struct MHD_BasicAuthInfo *\nMHD_basic_auth_get_username_password3 (struct MHD_Connection *connection)\n{\n  const struct MHD_RqBAuth *params;\n  size_t decoded_max_len;\n  struct MHD_BasicAuthInfo *ret;\n\n  params = MHD_get_rq_bauth_params_ (connection);\n\n  if (NULL == params)\n    return NULL;\n\n  if ((NULL == params->token68.str) || (0 == params->token68.len))\n    return NULL;\n\n  decoded_max_len = MHD_base64_max_dec_size_ (params->token68.len);\n  ret = (struct MHD_BasicAuthInfo *) malloc (sizeof(struct MHD_BasicAuthInfo)\n                                             + decoded_max_len + 1);\n  if (NULL != ret)\n  {\n    size_t decoded_len;\n    char *decoded;\n\n    decoded = (char *) (ret + 1);\n    decoded_len = MHD_base64_to_bin_n (params->token68.str, params->token68.len,\n                                       decoded, decoded_max_len);\n    mhd_assert (decoded_max_len >= decoded_len);\n    if (0 != decoded_len)\n    {\n      size_t username_len;\n      char *colon;\n\n      colon = memchr (decoded, ':', decoded_len);\n      if (NULL != colon)\n      {\n        size_t password_pos;\n        size_t password_len;\n\n        username_len = (size_t) (colon - decoded);\n        password_pos = username_len + 1;\n        password_len = decoded_len - password_pos;\n        ret->password = decoded + password_pos;\n        ret->password[password_len] = 0;  /* Zero-terminate the string */\n        ret->password_len = password_len;\n      }\n      else\n      {\n        username_len = decoded_len;\n        ret->password = NULL;\n        ret->password_len = 0;\n      }\n      ret->username = decoded;\n      ret->username[username_len] = 0;  /* Zero-terminate the string */\n      ret->username_len = username_len;\n\n      return ret; /* Success exit point */\n    }\n#ifdef HAVE_MESSAGES\n    else\n      MHD_DLOG (connection->daemon,\n                _ (\"Error decoding Basic Authorization authentication.\\n\"));\n#endif /* HAVE_MESSAGES */\n\n    free (ret);\n  }\n#ifdef HAVE_MESSAGES\n  else\n  {\n    MHD_DLOG (connection->daemon,\n              _ (\"Failed to allocate memory to process \" \\\n                 \"Basic Authorization authentication.\\n\"));\n  }\n#endif /* HAVE_MESSAGES */\n\n  return NULL; /* Failure exit point */\n}\n...\nstruct MHD_BasicAuthInfo\n{\n  /**\n   * The username, cannot be NULL.\n   * The buffer pointed by the @a username becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *username;\n\n  /**\n   * The length of the @a username, not including zero-termination\n   */\n  size_t username_len;\n\n  /**\n   * The password, may be NULL if password is not encoded by the client.\n   * The buffer pointed by the @a password becomes invalid when the pointer\n   * to the structure is freed by #MHD_free().\n   */\n  char *password;\n\n  /**\n   * The length of the @a password, not including zero-termination;\n   * when the @a password is NULL, the length is always zero.\n   */\n  size_t password_len;\n}\n</additional code>\nPlease find suspicious code fragments in the code and report them. Other agents can not investigate other fragments that you do not report, so it is very important to find all suspicious fragments without missing any. Report the suspicious fragments AS MUCH AS POSSIBLE.",
  "suspicious_frags": [],
  "explanation": "No suspicious controlling expressions were found that appear invariant. The MISRA C 2023 Rule 14.3 targets controlling expressions that are constant or invariant (for example constant true/false loops like while(1) or if(0), or loop conditions that do not change within the loop). In the provided code all controlling expressions depend on runtime values and therefore are not invariant:\n\n- In MHD_basic_auth_get_username_password: if (NULL == info), if (NULL != info->password), if (NULL != username), if (NULL != password), if (NULL != *password), and the final if (NULL != password) all test pointer values that are set at runtime and can vary.\n\n- In MHD_basic_auth_get_username_password3: if (NULL == params), if ((NULL == params->token68.str) || (0 == params->token68.len)), if (NULL != ret), if (0 != decoded_len), if (NULL != colon), and the checks around malloc/free are all dependent on runtime results (function returns, decoded lengths, malloc returning NULL) rather than compile-time constants.\n\n- There are no while/for/do-while loops with constant controlling expressions; no controlling expression is a compile-time constant (e.g., 0 or 1) nor obviously invariant within a loop.\n\nConditional compilation blocks (#ifdef HAVE_MESSAGES) and mhd_assert calls are not controlling expressions subject to Rule 14.3. Therefore no fragments need further investigation under Rule 14.3."
}