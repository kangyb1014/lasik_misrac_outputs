{
  "user_message": "Target function code is:\n```c\nsize_t\nMHD_str_pct_decode_in_place_lenient_ (char *str,\n                                      bool *broken_encoding)\n{\n#ifdef MHD_FAVOR_SMALL_CODE\n  size_t len;\n  size_t res;\n\n  len = strlen (str);\n  res = MHD_str_pct_decode_lenient_n_ (str, len, str, len, broken_encoding);\n  str[res] = 0;\n\n  return res;\n#else  /* ! MHD_FAVOR_SMALL_CODE */\n  size_t r;\n  size_t w;\n  if (NULL != broken_encoding)\n    *broken_encoding = false;\n  r = 0;\n  w = 0;\n  while (0 != str[r])\n  {\n    const char chr = str[r++];\n    if ('%' == chr)\n    {\n      const char d1 = str[r++];\n      if (0 == d1)\n      {\n        if (NULL != broken_encoding)\n          *broken_encoding = true;\n        str[w++] = chr; /* Copy \"as is\" */\n        str[w] = 0;\n        return w;\n      }\n      else\n      {\n        const char d2 = str[r++];\n        if (0 == d2)\n        {\n          if (NULL != broken_encoding)\n            *broken_encoding = true;\n          str[w++] = chr; /* Copy \"as is\" */\n          str[w++] = d1; /* Copy \"as is\" */\n          str[w] = 0;\n          return w;\n        }\n        else\n        {\n          const int h = toxdigitvalue (d1);\n          const int l = toxdigitvalue (d2);\n          unsigned char out;\n          if ((0 > h) || (0 > l))\n          {\n            if (NULL != broken_encoding)\n              *broken_encoding = true;\n            str[w++] = chr; /* Copy \"as is\" */\n            str[w++] = d1;\n            str[w++] = d2;\n            continue;\n          }\n          out =\n            (unsigned char) (((uint8_t) (((uint8_t) ((unsigned int) h)) << 4))\n                             | ((uint8_t) ((unsigned int) l)));\n          str[w++] = (char) out;\n          continue;\n        }\n      }\n    }\n    str[w++] = chr;\n  }\n  str[w] = 0;\n  return w;\n#endif /* ! MHD_FAVOR_SMALL_CODE */\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_str_pct_decode_in_place_lenient_': {'callees': ['toxdigitvalue'], 'callers': ['unescape_wrapper', 'MHD_http_unescape']}, 'toxdigitvalue': {'callees': [], 'callers': ['MHD_strx_to_uint32_', 'MHD_strx_to_uint32_n_', 'MHD_strx_to_uint64_', 'MHD_strx_to_uint64_n_', 'MHD_hex_to_bin', 'MHD_str_pct_decode_strict_n_', 'MHD_str_pct_decode_lenient_n_', 'MHD_str_pct_decode_in_place_strict_', 'MHD_str_pct_decode_in_place_lenient_']}, 'unescape_wrapper': {'callees': ['MHD_str_pct_decode_in_place_strict_', 'MHD_str_pct_decode_in_place_lenient_', 'MHD_DLOG'], 'callers': []}, 'MHD_http_unescape': {'callees': ['MHD_str_pct_decode_in_place_lenient_'], 'callers': ['process_value', 'post_process_urlencoded']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "toxdigitvalue",
    "MHD_str_pct_decode_lenient_n_",
    "strlen",
    "MHD_FAVOR_SMALL_CODE (preprocessor macro)",
    "uint8_t (typedef / stdint.h)",
    "bool (stdbool.h)",
    "size_t (stddef.h)",
    "NULL (macro)"
  ],
  "explanation": "Explain why each symbol is required for checking language-extension use in the target function:\n\n- toxdigitvalue: The function is called from the non-small-code path and its implementation may use compiler-specific extensions (inline asm, statement expressions, __attribute__ annotations, typeof, builtins, nested functions, etc.). You must inspect its definition to determine whether any language extensions are used that would affect compliance.\n\n- MHD_str_pct_decode_lenient_n_: When MHD_FAVOR_SMALL_CODE is defined the target delegates to this helper. Its implementation must be inspected for any compiler-specific extensions or nonstandard constructs; whether the small-code path is used depends on the macro, so this callee is required for a complete analysis.\n\n- strlen: The small-code path calls strlen. Some standard library functions may be implemented as compiler intrinsics or macros that rely on extensions (e.g., __builtin_strlen or other nonstandard wrappers). Check how strlen is provided in the build (header/macro/intrinsic) to ensure no extension is implicitly used.\n\n- MHD_FAVOR_SMALL_CODE (preprocessor macro): This macro controls which compilation path is present in the final binary. You must know whether it is defined in the build environment to determine which code (the in-place loop or the helper-call + strlen path) should be analyzed for extensions.\n\n- uint8_t (typedef / stdint.h): The code casts to uint8_t. Confirm the typedef is provided by a standard header (stdint.h) and not by a project-specific typedef that may expand to an extension or nonstandard type alias.\n\n- bool (stdbool.h): The function uses bool/true/false. Verify bool comes from the standard header (stdbool.h) and is not a project macro or extension type.\n\n- size_t (stddef.h): size_t is used as the return type and locals. Ensure size_t is the standard typedef and not replaced or altered by a compiler extension or nonstandard header.\n\n- NULL (macro): NULL is used for pointer checks. Some codebases redefine NULL in nonstandard ways; check its definition to ensure it is not implemented using a compiler-specific extension.\n\nRationale summary: To determine whether the target function violates the MISRA rule banning language extensions you must inspect any called functions and any macros/types that can hide compiler-specific constructs or builtins. The listed symbols either are callees that might contain extensions, or are macros/types that could be provided via nonstandard means, and thus are necessary for a complete, accurate assessment."
}