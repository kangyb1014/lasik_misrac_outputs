{
  "user_message": "An agent A claimed that the following MHD_get_timeout_i code violates the MISRA C 2023 rule 8.13.\n<misra_rule>\nMISRA C 2023 Rule 8.13 is A pointer should point to a const-qualified type whenever possible.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_get_timeout_i.\n```c\n_MHD_EXTERN int\nMHD_get_timeout_i (struct MHD_Daemon *daemon)\n{\n#if SIZEOF_INT >= SIZEOF_INT64_T\n  return MHD_get_timeout64s (daemon);\n#else  /* SIZEOF_INT < SIZEOF_INT64_T */\n  const int64_t to64 = MHD_get_timeout64s (daemon);\n  if (INT_MAX >= to64)\n    return (int) to64;\n  return INT_MAX;\n#endif /* SIZEOF_INT < SIZEOF_INT64_T */\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe function MHD_get_timeout_i declares its parameter as 'struct MHD_Daemon *daemon' (non-const) and calls MHD_get_timeout64s(daemon). If MHD_get_timeout64s only reads the daemon (does not modify it), the parameter in MHD_get_timeout_i should be declared as 'const struct MHD_Daemon *daemon' (or MHD_get_timeout64s should take a const pointer). Leaving the parameter as a non-const pointer when it could be const violates MISRA C 2023 Rule 8.13.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "The report is not justified from the snippet alone. Rule 8.13 requires a pointer be to a const-qualified type when it is possible to do so (i.e. the pointee is not modified). In MHD_get_timeout_i the parameter daemon is only passed to MHD_get_timeout64s and never directly modified in the shown code, but whether it can be declared const depends on the signature and behavior of MHD_get_timeout64s (and any other callees). If MHD_get_timeout64s already takes a const struct MHD_Daemon * (or could be changed to do so), then MHD_get_timeout_i should likewise take a const pointer. If, however, MHD_get_timeout64s requires a non-const pointer because it modifies the object (or the public API requires a non-const parameter), then declaring daemon as const in MHD_get_timeout_i would be incorrect and the rule would not be violated. The agent\u2019s claim assumes facts not present in the snippet (that MHD_get_timeout64s only reads daemon). Without confirming the callee\u2019s signature/behavior, you cannot conclude a Rule 8.13 violation."
}