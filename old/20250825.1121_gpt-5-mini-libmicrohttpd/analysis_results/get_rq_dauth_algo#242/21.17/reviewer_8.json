{
  "user_message": "An agent A claimed that the following get_rq_dauth_algo code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_dauth_algo.\n```c\nstatic enum MHD_DigestAuthAlgo3\nget_rq_dauth_algo (const struct MHD_RqDAuthParam *const algo_param)\n{\n  if (NULL == algo_param->value.str)\n    return MHD_DIGEST_AUTH_ALGO3_MD5; /* Assume MD5 by default */\n\n  if (algo_param->quoted)\n  {\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_MD5_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_MD5;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA256_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_MD5_TOKEN _MHD_SESS_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA512_256_TOKEN \\\n                                               _MHD_SESS_TOKEN))\n\n      /* Algorithms below are not supported by MHD for authentication */\n\n      return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA256_TOKEN \\\n                                               _MHD_SESS_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n    if (MHD_str_equal_caseless_quoted_s_bin_n (algo_param->value.str, \\\n                                               algo_param->value.len, \\\n                                               _MHD_SHA512_256_TOKEN))\n      return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n    /* No known algorithm has been detected */\n    return MHD_DIGEST_AUTH_ALGO3_INVALID;\n  }\n  /* The algorithm value is not quoted */\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_MD5_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_MD5;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA256_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA512_256_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256;\n\n  /* Algorithms below are not supported by MHD for authentication */\n\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_MD5_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_MD5_SESSION;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA256_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA256_SESSION;\n  if (MHD_str_equal_caseless_s_bin_n_ (_MHD_SHA512_256_TOKEN _MHD_SESS_TOKEN, \\\n                                       algo_param->value.str, \\\n                                       algo_param->value.len))\n    return MHD_DIGEST_AUTH_ALGO3_SHA512_256_SESSION;\n\n  /* No known algorithm has been detected */\n  return MHD_DIGEST_AUTH_ALGO3_INVALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nThe token macro concatenation yields the literal \"SHA-256-sess\" (12 characters + terminating NUL). If MHD_str_equal_caseless_quoted_s_bin_n internally uses a string.h routine such as memcmp/strncmp with the length parameter algo_param->value.len (e.g. algo_param->value.len == 20), that routine would read algo_param->value.len bytes from the token pointer and thus read beyond the bounds of the token literal (only 13 bytes including the NUL). In that implementation scenario, Rule 21.17 is violated because the call can cause accesses beyond the bounds of the object referenced by the token pointer.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function get_rq_dauth_algo:\n#define _MHD_MD5_TOKEN \"MD5\"\n...\n#define _MHD_SHA256_TOKEN \"SHA-256\"\n...\n#define _MHD_SHA512_256_TOKEN \"SHA-512-256\"\n...\n#define _MHD_SESS_TOKEN \"-sess\"\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": false,
  "explanation": "Agent A\u2019s scenario describes a plausible out\u2011of\u2011bounds read, but it is not proven from the code shown. The calls in get_rq_dauth_algo pass a string literal token and a separate length (algo_param->value.len) into helper functions named MHD_str_equal_caseless_quoted_s_bin_n / MHD_str_equal_caseless_s_bin_n_. Whether Rule 21.17 is violated depends entirely on the implementation of those helper functions. If a helper unconditionally calls a string.h routine (e.g. memcmp, strncmp) with the caller\u2019s length parameter and does not limit that length by the token\u2019s actual length (or otherwise ensure the token object is large enough), then that implementation would read past the end of the token literal and would violate MISRA C 2023 Rule 21.17. Conversely, if the helper functions compute or use the token\u2019s length (or otherwise bound the comparison length) before calling the string.h routine, no violation occurs.\n\nTherefore the report is not deterministically correct based only on get_rq_dauth_algo: the violation is possible but not demonstrated. To decide definitively you must inspect the implementations of the MHD_str_equal_* helpers. If they use the caller-supplied length without bounding it by the token length, the report would be correct; otherwise it would be false. As a corrective measure, ensure those helpers do not pass a length greater than the token object size to any string.h routine (for example, use the token\u2019s strlen/sizeof(token)-1 or min(algo_param->value.len, token_len) before calling memcmp/strncmp)."
}