{
  "user_message": "An agent A claimed that the following get_rq_nc code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_nc.\n```c\nstatic enum MHD_GetRqNCResult\nget_rq_nc (const struct MHD_RqDAuth *params,\n           uint32_t *nc)\n{\n  const struct MHD_RqDAuthParam *const nc_param =\n    &params->nc;\n  char unq[16];\n  const char *val;\n  size_t val_len;\n  size_t res;\n  uint64_t nc_val;\n\n  if (NULL == nc_param->value.str)\n    return MHD_GET_RQ_NC_NONE;\n\n  if (0 == nc_param->value.len)\n    return MHD_GET_RQ_NC_BROKEN;\n\n  if (! nc_param->quoted)\n  {\n    val = nc_param->value.str;\n    val_len = nc_param->value.len;\n  }\n  else\n  {\n    /* Actually no backslashes must be used in 'nc' */\n    if (sizeof(unq) < params->nc.value.len)\n      return MHD_GET_RQ_NC_TOO_LONG;\n    val_len = MHD_str_unquote (nc_param->value.str, nc_param->value.len, unq);\n    if (0 == val_len)\n      return MHD_GET_RQ_NC_BROKEN;\n    val = unq;\n  }\n\n  res = MHD_strx_to_uint64_n_ (val, val_len, &nc_val);\n  if (0 == res)\n  {\n    const char f = val[0];\n    if ( (('9' >= f) && ('0' <= f)) ||\n         (('F' >= f) && ('A' <= f)) ||\n         (('a' <= f) && ('f' >= f)) )\n      return MHD_GET_RQ_NC_TOO_LARGE;\n    else\n      return MHD_GET_RQ_NC_BROKEN;\n  }\n  if (val_len != res)\n    return MHD_GET_RQ_NC_BROKEN;\n  if (UINT32_MAX < nc_val)\n    return MHD_GET_RQ_NC_TOO_LARGE;\n  *nc = (uint32_t) nc_val;\n  return MHD_GET_RQ_NC_VALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential out-of-bounds write when unquoting an input whose length equals the buffer size. The code allows params->nc.value.len == sizeof(unq) (16) and then calls MHD_str_unquote(..., unq). If MHD_str_unquote copies src_len bytes and also writes a terminating '\\0' (or otherwise writes up to src_len+1 bytes) or internally uses a string.h function like memcpy/memmove with a length that exceeds the buffer, that will write 17 bytes into the 16-byte unq buffer and cause an out-of-bounds access. The code does not guarantee room for a trailing NUL or any expansion by MHD_str_unquote, so this is a potential violation of MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The agent A report is correct as a potential MISRA violation. The code allows params->nc.value.len to be equal to sizeof(unq) (16) because it only rejects lengths strictly greater than sizeof(unq). It then calls MHD_str_unquote(..., unq). If MHD_str_unquote writes a terminating NUL (or otherwise writes up to src_len+1 bytes) or internally uses a <string.h> function with a length that exceeds the 16-byte buffer, that will produce a write beyond the bounds of unq and therefore violate the intent of MISRA C 2023 Rule 21.17 (string handling must not access beyond object bounds).\n\nWhether an actual violation occurs depends on the documented/implemented behaviour of MHD_str_unquote: if it guarantees that it will write at most src_len bytes and never writes an extra NUL (or otherwise require an extra byte), or if it ensures it never calls string.h routines with a size that would overflow the destination, then the code is safe. However, in the absence of such a guarantee, the caller must assume the potential for an extra byte and protect against it (for example, change the check to reject lengths >= sizeof(unq) or ensure the destination has room for a terminator). Therefore the reported potential out-of-bounds is valid."
}