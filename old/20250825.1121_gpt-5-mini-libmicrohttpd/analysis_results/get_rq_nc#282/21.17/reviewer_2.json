{
  "user_message": "An agent A claimed that the following get_rq_nc code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_nc.\n```c\nstatic enum MHD_GetRqNCResult\nget_rq_nc (const struct MHD_RqDAuth *params,\n           uint32_t *nc)\n{\n  const struct MHD_RqDAuthParam *const nc_param =\n    &params->nc;\n  char unq[16];\n  const char *val;\n  size_t val_len;\n  size_t res;\n  uint64_t nc_val;\n\n  if (NULL == nc_param->value.str)\n    return MHD_GET_RQ_NC_NONE;\n\n  if (0 == nc_param->value.len)\n    return MHD_GET_RQ_NC_BROKEN;\n\n  if (! nc_param->quoted)\n  {\n    val = nc_param->value.str;\n    val_len = nc_param->value.len;\n  }\n  else\n  {\n    /* Actually no backslashes must be used in 'nc' */\n    if (sizeof(unq) < params->nc.value.len)\n      return MHD_GET_RQ_NC_TOO_LONG;\n    val_len = MHD_str_unquote (nc_param->value.str, nc_param->value.len, unq);\n    if (0 == val_len)\n      return MHD_GET_RQ_NC_BROKEN;\n    val = unq;\n  }\n\n  res = MHD_strx_to_uint64_n_ (val, val_len, &nc_val);\n  if (0 == res)\n  {\n    const char f = val[0];\n    if ( (('9' >= f) && ('0' <= f)) ||\n         (('F' >= f) && ('A' <= f)) ||\n         (('a' <= f) && ('f' >= f)) )\n      return MHD_GET_RQ_NC_TOO_LARGE;\n    else\n      return MHD_GET_RQ_NC_BROKEN;\n  }\n  if (val_len != res)\n    return MHD_GET_RQ_NC_BROKEN;\n  if (UINT32_MAX < nc_val)\n    return MHD_GET_RQ_NC_TOO_LARGE;\n  *nc = (uint32_t) nc_val;\n  return MHD_GET_RQ_NC_VALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nPotential buffer overflow when unquoting into the fixed-size local array 'unq'. The code checks if (sizeof(unq) < params->nc.value.len) return TOO_LONG; allowing params->nc.value.len == sizeof(unq). If MHD_str_unquote writes val_len bytes plus a terminating NUL (or otherwise writes more than params->nc.value.len bytes) it will write beyond the 16-byte buffer (e.g. input quoted length == 16 => MHD_str_unquote copies 16 bytes and appends '\\0' -> 17 bytes written). If MHD_str_unquote internally uses <string.h> functions (memcpy/strcpy) without knowing the destination size this can result in out-of-bounds accesses and thus violate MISRA C 2023 Rule 21.17.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. The code allows params->nc.value.len == sizeof(unq) (16) to proceed into the unquoted branch. If MHD_str_unquote writes a terminating '\\0' (or otherwise writes more bytes than the source length) into the destination buffer unq[16], that will write 17 bytes and overflow the fixed-size array. Rule 21.17 forbids string.h usage that can access beyond object bounds; if MHD_str_unquote uses string.h functions (e.g. memcpy/strcpy) or otherwise writes a terminator without the caller ensuring space for it, an out-of-bounds write can occur and the rule is violated. Whether an actual violation occurs depends on the exact contract/implementation of MHD_str_unquote (whether it NUL-terminates or requires destination size), but the caller does not enforce the stricter bound and is therefore at risk. The safe check should ensure space for any terminator or the exact behavior of MHD_str_unquote must be documented/enforced (e.g. use if (sizeof(unq) <= params->nc.value.len) return TOO_LONG; or pass a size and have MHD_str_unquote respect it)."
}