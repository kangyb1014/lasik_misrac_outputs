{
  "user_message": "An agent A claimed that the following get_rq_nc code violates the MISRA C 2023 rule 21.17.\n<misra_rule>\nMISRA C 2023 Rule 21.17 is Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.\nThis rule strictly applies to the Standard Library functions in <string.h> such as memcpy, memmove, memset, memcmp, strcpy, strncpy, strcat, strncat, strlen, and strspn.\n</misra_rule>\n<target_code>\nHere is the original code of get_rq_nc.\n```c\nstatic enum MHD_GetRqNCResult\nget_rq_nc (const struct MHD_RqDAuth *params,\n           uint32_t *nc)\n{\n  const struct MHD_RqDAuthParam *const nc_param =\n    &params->nc;\n  char unq[16];\n  const char *val;\n  size_t val_len;\n  size_t res;\n  uint64_t nc_val;\n\n  if (NULL == nc_param->value.str)\n    return MHD_GET_RQ_NC_NONE;\n\n  if (0 == nc_param->value.len)\n    return MHD_GET_RQ_NC_BROKEN;\n\n  if (! nc_param->quoted)\n  {\n    val = nc_param->value.str;\n    val_len = nc_param->value.len;\n  }\n  else\n  {\n    /* Actually no backslashes must be used in 'nc' */\n    if (sizeof(unq) < params->nc.value.len)\n      return MHD_GET_RQ_NC_TOO_LONG;\n    val_len = MHD_str_unquote (nc_param->value.str, nc_param->value.len, unq);\n    if (0 == val_len)\n      return MHD_GET_RQ_NC_BROKEN;\n    val = unq;\n  }\n\n  res = MHD_strx_to_uint64_n_ (val, val_len, &nc_val);\n  if (0 == res)\n  {\n    const char f = val[0];\n    if ( (('9' >= f) && ('0' <= f)) ||\n         (('F' >= f) && ('A' <= f)) ||\n         (('a' <= f) && ('f' >= f)) )\n      return MHD_GET_RQ_NC_TOO_LARGE;\n    else\n      return MHD_GET_RQ_NC_BROKEN;\n  }\n  if (val_len != res)\n    return MHD_GET_RQ_NC_BROKEN;\n  if (UINT32_MAX < nc_val)\n    return MHD_GET_RQ_NC_TOO_LARGE;\n  *nc = (uint32_t) nc_val;\n  return MHD_GET_RQ_NC_VALID;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nViolation: if params->nc.value.len equals sizeof(unq) (16) the check (sizeof(unq) < params->nc.value.len) passes and MHD_str_unquote is called with unq as destination. If MHD_str_unquote writes a terminating NUL or otherwise writes value.len+1 bytes or uses a string.h routine that copies the source length plus a terminator (e.g. strcpy/memcpy of len+1), this will write beyond the unq buffer and thus violate Rule 21.17. The check should ensure room for any required terminator (e.g. use <=) or the unquote function should receive the destination size to avoid out\u2011of\u2011bounds accesses.\n</scenario>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct: there is a plausible out\u2011of\u2011bounds scenario. The code only checks sizeof(unq) < params->nc.value.len, so when params->nc.value.len == sizeof(unq) (16) the branch allows calling MHD_str_unquote with unq as the destination buffer but without supplying its size. If MHD_str_unquote writes a terminating NUL or internally calls a <string.h> routine (e.g. memcpy/strcpy/strncpy) that copies value.len+1 bytes or otherwise writes more than params->nc.value.len bytes into unq, that will write beyond unq and thus violate MISRA C 2023 Rule 21.17.\n\nWhether an actual violation occurs depends on the guarantees/implementation of MHD_str_unquote: if it is specified to write exactly value.len bytes (no terminator) and never uses string.h functions that copy an extra byte, the code is safe; otherwise it is not. Given the caller does not ensure space for any terminator nor passes the destination size to the unquote routine, the call is potentially unsafe and the reported violation is justified.\n\nRecommended fixes: ensure the check reserves room for any terminator (use <= or check for params->nc.value.len + 1 <= sizeof(unq) as appropriate), or modify MHD_str_unquote to accept a destination size and guarantee it never writes beyond that, or otherwise document and enforce the exact behavior so the caller can ensure safety."
}