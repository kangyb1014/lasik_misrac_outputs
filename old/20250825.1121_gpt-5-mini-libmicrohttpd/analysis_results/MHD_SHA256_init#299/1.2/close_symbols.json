{
  "user_message": "Target function code is:\n```c\nvoid\nMHD_SHA256_init (struct Sha256Ctx *ctx)\n{\n  /* Initial hash values, see FIPS PUB 180-4 paragraph 5.3.3 */\n  /* First thirty-two bits of the fractional parts of the square\n   * roots of the first eight prime numbers: 2, 3, 5, 7, 11, 13,\n   * 17, 19.\" */\n  ctx->H[0] = UINT32_C (0x6a09e667);\n  ctx->H[1] = UINT32_C (0xbb67ae85);\n  ctx->H[2] = UINT32_C (0x3c6ef372);\n  ctx->H[3] = UINT32_C (0xa54ff53a);\n  ctx->H[4] = UINT32_C (0x510e527f);\n  ctx->H[5] = UINT32_C (0x9b05688c);\n  ctx->H[6] = UINT32_C (0x1f83d9ab);\n  ctx->H[7] = UINT32_C (0x5be0cd19);\n\n  /* Initialise number of bytes. */\n  ctx->count = 0;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'MHD_SHA256_init': {'callees': [], 'callers': ['digest_init_one_time', 'digest_reset']}, 'digest_init_one_time': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['MHD_digest_auth_calc_userdigest', 'MHD_digest_auth_calc_userhash', 'digest_auth_check_all_inner', 'queue_auth_required_response3_inner']}, 'digest_reset': {'callees': ['MHD_MD5_init', 'MHD_SHA256_init', 'MHD_SHA512_256_init'], 'callers': ['calculate_add_nonce_with_retry', 'digest_auth_check_all_inner']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct Sha256Ctx",
    "Sha256Ctx.H",
    "Sha256Ctx.count",
    "UINT32_C",
    "uint32_t",
    "Header that defines UINT32_C (e.g. <stdint.h> or project header that provides it)",
    "__STDC_VERSION__",
    "compiler predefined macros (e.g. __GNUC__, __clang__, _MSC_VER)"
  ],
  "explanation": "To determine whether MHD_SHA256_init uses any compiler language extensions you must see the exact declarations/definitions that affect the code sample:\n\n- struct Sha256Ctx: the full struct definition is required to confirm how members are declared (their types, any unusual attributes, storage-class specifiers, or compiler-specific extensions attached to the struct). If the struct uses non\u2011standard extensions (e.g. packed/attribute annotations) that would violate the MISRA rule, they must be visible.\n\n- Sha256Ctx.H and Sha256Ctx.count: listing the specific member declarations (H and count) is necessary to confirm H's element type, array bounds, and whether count uses any nonstandard integer type or extension (bit\u2011fields with implementation\u2011specific width, compiler attributes, etc.). These are normally part of the struct but called out to emphasize the need to inspect member types.\n\n- UINT32_C: this macro is used directly in the function. You must inspect its definition/expansion to confirm it is a standard macro (from C99 <stdint.h>) and that its expansion does not rely on compiler extensions (for example, unusual suffixes, casts to compiler-specific types, or use of builtin extensions).\n\n- uint32_t: H is expected to be an array of uint32_t (or compatible type). The exact typedef must be known to confirm it is the standard fixed-width integer type rather than a project/extension alias.\n\n- Header that defines UINT32_C (e.g. <stdint.h> or a project header): you need to know which header supplies UINT32_C in the build and inspect that header for any non\u2011standard constructs. In some environments project headers or vendor headers replace or redefine standard macros using extensions.\n\n- __STDC_VERSION__: this macro tells which C standard the compiler is operating under (e.g. C99/C11). Presence/absence/value influences whether UINT32_C is expected to be a standard macro and whether certain language constructs are standard or extensions.\n\n- compiler predefined macros (e.g. __GNUC__, __clang__, _MSC_VER): knowing the compiler/implementation enables checking whether any headers or macros rely on compiler-specific language extensions. Some implementations provide nonstandard definitions or extension macros that could make the code rely on extensions.\n\nCollecting these symbols/definitions lets the next analyst determine whether the used macro and the data types are standard (C99/C11) constructs or whether they come from or expand to compiler\u2011specific extensions that would violate the MISRA requirement against language extensions."
}