{
  "user_message": "Target function code is:\n```c\ntime_t\nMHD_monotonic_sec_counter (void)\n{\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return ts.tv_sec - mono_clock_start;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return cur_time.tv_sec - mono_clock_start;\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (time_t) (((uint64_t) (GetTickCount64 () - tick_start)) / 1000);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    return (time_t) (((uint64_t) perf_counter.QuadPart - perf_start)\n                     / perf_freq);\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return (time_t) (((uint64_t) (gethrtime () - hrtime_start)) / 1000000000);\n#endif /* HAVE_GETHRTIME */\n\n  return time (NULL) - sys_clock_start;\n}\n```\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "HAVE_CLOCK_GETTIME",
    "struct timespec",
    "_MHD_UNWANTED_CLOCK",
    "mono_clock_id",
    "clock_gettime",
    "mono_clock_start",
    "HAVE_CLOCK_GET_TIME",
    "_MHD_INVALID_CLOCK_SERV",
    "mono_clock_service",
    "mach_timespec_t",
    "KERN_SUCCESS",
    "clock_get_time",
    "_WIN32",
    "_WIN32_WINNT",
    "GetTickCount64",
    "tick_start",
    "perf_freq",
    "LARGE_INTEGER",
    "QueryPerformanceCounter",
    "perf_start",
    "HAVE_GETHRTIME",
    "gethrtime",
    "hrtime_start",
    "time",
    "sys_clock_start",
    "uint64_t",
    "time_t"
  ],
  "explanation": "To decide whether MHD_monotonic_sec_counter uses any compiler language extensions you must inspect the definitions and conditional-compilation decisions for all external macros, types, functions and globals referenced by the function. For each listed symbol you need to know whether its declaration/definition introduces nonstandard language features (compiler-specific keywords/attributes, builtin types, nonstandard integer types, __attribute__/__declspec, or other documented compiler extensions), and whether the preprocessor symbols change which code is actually compiled. Brief justification for each symbol:\n\n- HAVE_CLOCK_GETTIME: controls whether the clock_gettime branch is compiled; needed to see if that branch (and any extensions it uses) is present.\n- struct timespec: the type and its members (tv_sec) must be inspected to ensure no compiler-specific extensions (nonstandard members or attributes) are used.\n- _MHD_UNWANTED_CLOCK: its definition may be an enum or macro that could use compiler-specific constructs; also affects branch condition semantics.\n- mono_clock_id: its type (enum, int, or platform clockid_t) may involve platform typedefs or extensions.\n- clock_gettime: its prototype may use nonstandard attributes or calling conventions (e.g. function attributes, macros expanding to builtins).\n- mono_clock_start: its type matters (time_t or other) and whether its definition uses extensions.\n- HAVE_CLOCK_GET_TIME: controls inclusion of the Mach clock_get_time branch.\n- _MHD_INVALID_CLOCK_SERV: affects branch selection; its definition type may be platform-specific.\n- mono_clock_service: its type and declaration (mach port/service type) may use nonstandard types or attributes.\n- mach_timespec_t: must check its typedef/members for nonstandard extensions.\n- KERN_SUCCESS: constant/macro definition may be platform-specific; check for extension usage in its definition.\n- clock_get_time: prototype may use platform-specific calling conventions or attributes; check for extensions.\n- _WIN32: controls Windows-specific branches; needed to know which platform-specific code is compiled.\n- _WIN32_WINNT: refines Windows-branch selection; its value controls whether GetTickCount64 or QueryPerformanceCounter code is compiled.\n- GetTickCount64: Windows API declaration (or macro) may hide compiler-specific decorations; check for extensions in its declaration.\n- tick_start: global variable/type must be inspected for any nonstandard type or extension usage.\n- perf_freq: its type and definition (could be zero/nonzero; also might be defined via platform-specific types) affect compiled code and whether any extension appears.\n- LARGE_INTEGER: Windows type definition (union/struct) may use compiler-specific features (e.g. anonymous unions/structs) which are language extensions in some compilers.\n- QueryPerformanceCounter: API prototype may include nonstandard calling conventions/attributes; check definition for extensions.\n- perf_start: its type/definition may incorporate platform-specific types or extensions.\n- HAVE_GETHRTIME: controls inclusion of gethrtime branch; needed to know if that code is present.\n- gethrtime: prototype/definition may be platform-specific; check for extensions.\n- hrtime_start: its type/definition must be checked for extensions.\n- time: standard library time(); but its declaration should be checked if platform headers annotate it with compiler-specific attributes or calling conventions.\n- sys_clock_start: global/time base; its type/definition must be inspected for any nonstandard constructs.\n- uint64_t: fixed-width integer type; its underlying typedef (unsigned long long, unsigned long, or compiler builtin like unsigned __int128) must be known to determine if a nonstandard integer type is used.\n- time_t: return type of the function and types used in arithmetic; its typedef may be platform-specific and could involve extensions.\n\nIn short: to verify compliance with the MISRA rule banning language extensions you must examine the declarations/definitions and the preprocessor configuration for every external macro, type, function and global referenced above, because any of them could introduce compiler-specific extensions (attributes, anonymous unions, nonstandard integer widths, builtin types, or compiler annotations)."
}