{
  "user_message": "An agent A claimed that the following MHD_monotonic_sec_counter code violates the MISRA C 2023 rule 2.1.\n<misra_rule>\nMISRA C 2023 Rule 2.1 is A project shall not contain unreachable code.\n\n</misra_rule>\n<target_code>\nHere is the original code of MHD_monotonic_sec_counter.\n```c\ntime_t\nMHD_monotonic_sec_counter (void)\n{\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id,\n                            &ts)) )\n    return ts.tv_sec - mono_clock_start;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n  {\n    mach_timespec_t cur_time;\n\n    if (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time))\n      return cur_time.tv_sec - mono_clock_start;\n  }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (time_t) (((uint64_t) (GetTickCount64 () - tick_start)) / 1000);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n  {\n    LARGE_INTEGER perf_counter;\n\n    QueryPerformanceCounter (&perf_counter);   /* never fail on XP and later */\n    return (time_t) (((uint64_t) perf_counter.QuadPart - perf_start)\n                     / perf_freq);\n  }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return (time_t) (((uint64_t) (gethrtime () - hrtime_start)) / 1000000000);\n#endif /* HAVE_GETHRTIME */\n\n  return time (NULL) - sys_clock_start;\n}\n```\n</target_code>\n<response format>\nProvide your answer with these fields.\n- explanation: your evaluation of the scenario provided by the agent A.\n- is_report_correct: whether the report is correct or not (true/false). True means there is a violation.\n</response format>\n<scenario>\nThe agent A provided the following violation scenario:\nWhen compiled for Windows (_WIN32 defined) with _WIN32_WINNT >= 0x0600 the fragment contains an if (1) that always returns from the function. That makes the remainder of the function (e.g. the later timing alternatives and the final return at the end of the function) unreachable in that build configuration, violating MISRA C 2023 Rule 2.1.\n</scenario>\n<additional code>Here are the definitions of symbols that are close to the target function MHD_monotonic_sec_counter:\n#define HAVE_CLOCK_GETTIME 1\n...\nstatic clockid_t mono_clock_id = _MHD_UNWANTED_CLOCK\n...\n#define _MHD_UNWANTED_CLOCK CLOCK_REALTIME\n...\nstatic time_t mono_clock_start\n...\nstatic time_t sys_clock_start\n</additional code>\n\n<instruction>\nJudge whether the report is correct or not.\n</instruction>\n",
  "is_report_correct": true,
  "explanation": "The report is correct. In the specified build configuration (_WIN32 defined and _WIN32_WINNT >= 0x0600) the code contains an if (1) that always executes the return. That makes every statement that follows in the function (the later platform-specific alternatives and the final return) unreachable for that translation of the source, which violates MISRA C:2023 Rule 2.1 (a project shall not contain unreachable code). To fix this, make the platform alternatives mutually exclusive at preprocessing time (e.g. use #elif chains or otherwise restructure the conditionals so only the chosen implementation is compiled), so there are no unconditional returns leaving subsequent compiled code unreachable."
}