{
  "user_message": "Target function code is:\n```c\nstatic ssize_t\nsend_iov_nontls (struct MHD_Connection *connection,\n                 struct MHD_iovec_track_ *const r_iov,\n                 bool push_data)\n{\n  ssize_t res;\n  size_t items_to_send;\n#ifdef HAVE_SENDMSG\n  struct msghdr msg;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  DWORD bytes_sent;\n  DWORD cnt_w;\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  mhd_assert (0 == (connection->daemon->options & MHD_USE_TLS));\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n  {\n    return MHD_ERR_NOTCONN_;\n  }\n\n  items_to_send = r_iov->cnt - r_iov->sent;\n#ifdef _MHD_IOV_MAX\n  if (_MHD_IOV_MAX < items_to_send)\n  {\n    mhd_assert (0 < _MHD_IOV_MAX);\n    if (0 == _MHD_IOV_MAX)\n      return MHD_ERR_NOTCONN_; /* Should never happen */\n    items_to_send = _MHD_IOV_MAX;\n    push_data = false; /* Incomplete response */\n  }\n#endif /* _MHD_IOV_MAX */\n#ifdef HAVE_SENDMSG\n  memset (&msg, 0, sizeof(struct msghdr));\n  msg.msg_iov = r_iov->iov + r_iov->sent;\n  msg.msg_iovlen = items_to_send;\n\n  pre_send_setopt (connection, true, push_data);\n#ifdef MHD_USE_MSG_MORE\n  res = sendmsg (connection->socket_fd, &msg,\n                 MSG_NOSIGNAL_OR_ZERO | (push_data ? 0 : MSG_MORE));\n#else  /* ! MHD_USE_MSG_MORE */\n  res = sendmsg (connection->socket_fd, &msg, MSG_NOSIGNAL_OR_ZERO);\n#endif /* ! MHD_USE_MSG_MORE */\n#elif defined(HAVE_WRITEV)\n  pre_send_setopt (connection, true, push_data);\n  res = writev (connection->socket_fd, r_iov->iov + r_iov->sent,\n                items_to_send);\n#elif defined(MHD_WINSOCK_SOCKETS)\n#ifdef _WIN64\n  if (items_to_send > UINT32_MAX)\n  {\n    cnt_w = UINT32_MAX;\n    push_data = false; /* Incomplete response */\n  }\n  else\n    cnt_w = (DWORD) items_to_send;\n#else  /* ! _WIN64 */\n  cnt_w = (DWORD) items_to_send;\n#endif /* ! _WIN64 */\n  pre_send_setopt (connection, true, push_data);\n  if (0 == WSASend (connection->socket_fd,\n                    (LPWSABUF) (r_iov->iov + r_iov->sent),\n                    cnt_w,\n                    &bytes_sent, 0, NULL, NULL))\n    res = (ssize_t) bytes_sent;\n  else\n    res = -1;\n#else /* !HAVE_SENDMSG && !HAVE_WRITEV && !MHD_WINSOCK_SOCKETS */\n#error No vector-send function available\n#endif\n\n  if (0 > res)\n  {\n    const int err = MHD_socket_get_error_ ();\n\n    if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n    {\n#ifdef EPOLL_SUPPORT\n      /* EAGAIN --- no longer write-ready */\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      return MHD_ERR_AGAIN_;\n    }\n    if (MHD_SCKT_ERR_IS_EINTR_ (err))\n      return MHD_ERR_AGAIN_;\n    if (MHD_SCKT_ERR_IS_REMOTE_DISCNN_ (err))\n      return MHD_ERR_CONNRESET_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EPIPE_))\n      return MHD_ERR_PIPE_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EOPNOTSUPP_))\n      return MHD_ERR_OPNOTSUPP_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ENOTCONN_))\n      return MHD_ERR_NOTCONN_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EINVAL_))\n      return MHD_ERR_INVAL_;\n    if (MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err))\n      return MHD_ERR_NOMEM_;\n    if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_EBADF_))\n      return MHD_ERR_BADF_;\n    /* Treat any other error as a hard error. */\n    return MHD_ERR_NOTCONN_;\n  }\n\n  /* Some data has been sent */\n  if (1)\n  {\n    size_t track_sent = (size_t) res;\n    /* Adjust the internal tracking information for the iovec to\n     * take this last send into account. */\n    while ((0 != track_sent) && (r_iov->iov[r_iov->sent].iov_len <= track_sent))\n    {\n      track_sent -= r_iov->iov[r_iov->sent].iov_len;\n      r_iov->sent++; /* The iov element has been completely sent */\n      mhd_assert ((r_iov->cnt > r_iov->sent) || (0 == track_sent));\n    }\n\n    if (r_iov->cnt == r_iov->sent)\n      post_send_setopt (connection, true, push_data);\n    else\n    {\n#ifdef EPOLL_SUPPORT\n      connection->epoll_state &=\n        ~((enum MHD_EpollState) MHD_EPOLL_STATE_WRITE_READY);\n#endif /* EPOLL_SUPPORT */\n      if (0 != track_sent)\n      {\n        mhd_assert (r_iov->cnt > r_iov->sent);\n        /* The last iov element has been partially sent */\n        r_iov->iov[r_iov->sent].iov_base =\n          (void *) ((uint8_t *) r_iov->iov[r_iov->sent].iov_base + track_sent);\n        r_iov->iov[r_iov->sent].iov_len -= (MHD_iov_size_) track_sent;\n      }\n    }\n  }\n\n  return res;\n}\n```\n\nStatic call graph of the target function is:\n```json\n{'send_iov_nontls': {'callees': ['pre_send_setopt', 'post_send_setopt'], 'callers': ['MHD_send_iovec_']}, 'pre_send_setopt': {'callees': [], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'post_send_setopt': {'callees': ['MHD_DLOG'], 'callers': ['MHD_send_data_', 'MHD_send_hdr_and_body_', 'MHD_send_sendfile_', 'send_iov_nontls']}, 'MHD_send_iovec_': {'callees': ['send_iov_nontls'], 'callers': ['MHD_connection_handle_write']}}\n```\n\n\nList additional symbols that are required to analyze the target function to determine if the target function code violates the following MISRA C rule:\nLanguage extensions should not be used. You should report only when the code uses any language compiler extensions that are explicitly stated as an extension in compiler documentations.\nThe list will be included in the prompt for the next agent, so be concise and clear.\nExplain why each symbol is required in the analysis of the target function for the MISRA C rule.\n",
  "close_symbols": [
    "struct MHD_iovec_track_",
    "definition of r_iov->iov element type (e.g., struct iovec / MHD iov type)",
    "MHD_iov_size_",
    "struct MHD_Connection",
    "daemon->options (type/definition of struct/enum MHD_Daemon/options)",
    "mhd_assert (macro / function definition)",
    "pre_send_setopt (definition)",
    "post_send_setopt (definition)",
    "MHD_INVALID_SOCKET",
    "MHD_CONNECTION_CLOSED",
    "MHD_ERR_NOTCONN_",
    "MHD_ERR_AGAIN_",
    "MHD_ERR_CONNRESET_",
    "MHD_ERR_PIPE_",
    "MHD_ERR_OPNOTSUPP_",
    "MHD_ERR_INVAL_",
    "MHD_ERR_NOMEM_",
    "MHD_ERR_BADF_",
    "_MHD_IOV_MAX",
    "HAVE_SENDMSG",
    "HAVE_WRITEV",
    "MHD_WINSOCK_SOCKETS",
    "MHD_USE_MSG_MORE",
    "MSG_NOSIGNAL_OR_ZERO",
    "MSG_MORE",
    "sendmsg (prototype / macro)",
    "writev (prototype / macro)",
    "WSASend (prototype / macro)",
    "LPWSABUF",
    "DWORD",
    "UINT32_MAX",
    "_WIN64",
    "MHD_socket_get_error_",
    "MHD_SCKT_ERR_IS_EAGAIN_",
    "MHD_SCKT_ERR_IS_EINTR_",
    "MHD_SCKT_ERR_IS_REMOTE_DISCNN_",
    "MHD_SCKT_ERR_IS_ (macro family)",
    "MHD_SCKT_EPIPE_",
    "MHD_SCKT_EOPNOTSUPP_",
    "MHD_SCKT_ENOTCONN_",
    "MHD_SCKT_EINVAL_",
    "MHD_SCKT_ERR_IS_LOW_RESOURCES_",
    "MHD_SCKT_EBADF_",
    "EPOLL_SUPPORT",
    "enum MHD_EpollState",
    "MHD_EPOLL_STATE_WRITE_READY",
    "struct msghdr (system definition)",
    "ssize_t",
    "size_t",
    "uint8_t"
  ],
  "explanation": "To determine whether send_iov_nontls uses compiler/language extensions you must inspect the definitions and expansions of all macros, typedefs, structs and called functions that appear in its source. Specifically:\n\n- struct MHD_iovec_track_ and the r_iov->iov element type (e.g. struct iovec or project iov type): needed to check whether the iov storage is declared as a flexible array (C99) or a zero-length array (GCC extension) or uses other non\u2011standard constructs.\n- MHD_iov_size_: to verify whether the iov_len type or arithmetic uses any non\u2011standard typedefs or attributes.\n- struct MHD_Connection and daemon->options (and the MHD_Daemon/options definition): to check for bitfield usage, compiler-specific attribute annotations, or non\u2011standard layout qualifiers in those types.\n- mhd_assert: macros like assert are frequently implemented with statement-expressions, __extension__ or GCC-specific builtins \u2014 the macro body must be inspected for such extensions.\n- pre_send_setopt and post_send_setopt definitions: these callees could themselves use compiler extensions (attributes, inline asm, statement-expressions). post_send_setopt calls MHD_DLOG; its implementation might use extensions too.\n- All return/value macros (MHD_INVALID_SOCKET, MHD_CONNECTION_CLOSED, MHD_ERR_...): macros can hide compiler extensions (e.g., statement expressions, typeof, __builtin_*). Their definitions must be checked.\n- _MHD_IOV_MAX and the conditional compilation macros (HAVE_SENDMSG, HAVE_WRITEV, MHD_WINSOCK_SOCKETS, MHD_USE_MSG_MORE, EPOLL_SUPPORT): these influence which code path is compiled; their definitions (or configuration headers) may themselves rely on extensions or platform-specific constructs. Also the value/definition of _MHD_IOV_MAX could be a macro using non\u2011standard constructs.\n- MSG_NOSIGNAL_OR_ZERO, MSG_MORE and system call wrappers (sendmsg, writev, WSASend) and related types (LPWSABUF, DWORD, UINT32_MAX, _WIN64): these may be macros/typedefs that expand to platform-specific or compiler-specific constructs \u2014 their actual definitions are needed to ensure no language extensions are used in the paths taken.\n- MHD_socket_get_error_ and the MHD_SCKT_ERR_IS_* family and MHD_SCKT_* error constants: these are macros/functions used to test/translate errors. Macros in this family often wrap platform calls and can use compiler extensions; their definitions must be inspected.\n- enum MHD_EpollState and MHD_EPOLL_STATE_WRITE_READY and EPOLL_SUPPORT: required to check bitwise operations and any casts/enum usage for non\u2011standard constructs.\n- struct msghdr (system definition) and fundamental types ssize_t, size_t, uint8_t: need to ensure the code's use and casts are to standard types and not to compiler\u2011specific extended types/attributes.\n\nInspecting these definitions lets the analyst detect language extensions such as GCC statement-expressions ({ ... }), typeof, __attribute__ annotations, inline asm, zero-length arrays (nonstandard), _Pragma or other compiler-specific keywords used in macro or type definitions. Without these symbols the static source of send_iov_nontls alone cannot prove absence of hidden extensions in macros, typedefs or called functions."
}